{
  "origin": "codeshovel",
  "repositoryName": "Math-64b",
  "repositoryPath": "/tmp/Math-64b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "LevenbergMarquardtOptimizer.java",
  "functionName": "qrDecomposition",
  "functionId": "qrDecomposition",
  "sourceFilePath": "src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java",
  "functionAnnotation": "",
  "functionDoc": "Decompose a matrix A as A.P \u003d Q.R using Householder transforms.\n\u003cp\u003eAs suggested in the P. Lascaux and R. Theodor book\n\u003ci\u003eAnalyse num\u0026eacute;rique matricielle appliqu\u0026eacute;e \u0026agrave;\nl\u0027art de l\u0027ing\u0026eacute;nieur\u003c/i\u003e (Masson, 1986), instead of representing\nthe Householder transforms with u\u003csub\u003ek\u003c/sub\u003e unit vectors such that:\n\u003cpre\u003e\nH\u003csub\u003ek\u003c/sub\u003e \u003d I - 2u\u003csub\u003ek\u003c/sub\u003e.u\u003csub\u003ek\u003c/sub\u003e\u003csup\u003et\u003c/sup\u003e\n\u003c/pre\u003e\nwe use \u003csub\u003ek\u003c/sub\u003e non-unit vectors such that:\n\u003cpre\u003e\nH\u003csub\u003ek\u003c/sub\u003e \u003d I - beta\u003csub\u003ek\u003c/sub\u003ev\u003csub\u003ek\u003c/sub\u003e.v\u003csub\u003ek\u003c/sub\u003e\u003csup\u003et\u003c/sup\u003e\n\u003c/pre\u003e\nwhere v\u003csub\u003ek\u003c/sub\u003e \u003d a\u003csub\u003ek\u003c/sub\u003e - alpha\u003csub\u003ek\u003c/sub\u003e e\u003csub\u003ek\u003c/sub\u003e.\nThe beta\u003csub\u003ek\u003c/sub\u003e coefficients are provided upon exit as recomputing\nthem from the v\u003csub\u003ek\u003c/sub\u003e vectors would be costly.\u003c/p\u003e\n\u003cp\u003eThis decomposition handles rank deficient cases since the tranformations\nare performed in non-increasing columns norms order thanks to columns\npivoting. The diagonal elements of the R matrix are therefore also in\nnon-increasing absolute values order.\u003c/p\u003e\n\n@exception OptimizationException if the decomposition cannot be performed\n",
  "functionStartLine": 788,
  "functionEndLine": 856,
  "numCommitsSeen": 34,
  "timeTaken": 3956,
  "changeHistory": [
    "1eaea0b549f685bd416cef68faa3a137b9bb3519",
    "006e834bc3d18fc1d649392a606f4f291378c965",
    "f62b589b10d3bd94ab24006c70ae5d86ec9bd3fb",
    "5f33585147ed8917bcc40f67794e9476bf1d53f8",
    "d6a438e931412713e99624cf9ed74470f1040184",
    "8541f303370cec9a25f2b32b3d660b3f188913f0",
    "fbe565694aa2721d4a8538eb053171cc8ecfde47",
    "7f88773d6c3c96c0a2fd24c3e50d1eb80daca11d",
    "fd0f87590d1c88c18f669e9b168c8fd20631f23c",
    "2c6b6be4ba2b9abf4dc6d52864b148a910de8e90",
    "6d21abba54a9b3a0cca222abfacd26cabd88561c",
    "89ac173c2b467e6289df0e62f2a43ed1730fbad5"
  ],
  "changeHistoryShort": {
    "1eaea0b549f685bd416cef68faa3a137b9bb3519": "Ybodychange",
    "006e834bc3d18fc1d649392a606f4f291378c965": "Ybodychange",
    "f62b589b10d3bd94ab24006c70ae5d86ec9bd3fb": "Ybodychange",
    "5f33585147ed8917bcc40f67794e9476bf1d53f8": "Ybodychange",
    "d6a438e931412713e99624cf9ed74470f1040184": "Yfilerename",
    "8541f303370cec9a25f2b32b3d660b3f188913f0": "Ymultichange(Ymovefromfile,Ybodychange)",
    "fbe565694aa2721d4a8538eb053171cc8ecfde47": "Ymultichange(Yfilerename,Yexceptionschange,Ybodychange,Ydocchange)",
    "7f88773d6c3c96c0a2fd24c3e50d1eb80daca11d": "Ybodychange",
    "fd0f87590d1c88c18f669e9b168c8fd20631f23c": "Ybodychange",
    "2c6b6be4ba2b9abf4dc6d52864b148a910de8e90": "Ymultichange(Yexceptionschange,Ybodychange,Ydocchange)",
    "6d21abba54a9b3a0cca222abfacd26cabd88561c": "Yfilerename",
    "89ac173c2b467e6289df0e62f2a43ed1730fbad5": "Yintroduced"
  },
  "changeHistoryDetails": {
    "1eaea0b549f685bd416cef68faa3a137b9bb3519": {
      "type": "Ybodychange",
      "commitMessage": "changed the localization mechanism for error messages. The new system is based on an enum rather than on duplicated string literals.\nJIRA: MATH-361\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@955423 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "6/16/10, 4:03 PM",
      "commitName": "1eaea0b549f685bd416cef68faa3a137b9bb3519",
      "commitAuthor": "Luc Maisonobe",
      "commitDateOld": "6/6/10, 7:01 AM",
      "commitNameOld": "006e834bc3d18fc1d649392a606f4f291378c965",
      "commitAuthorOld": "Luc Maisonobe",
      "daysBetweenCommits": 10.38,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "private void qrDecomposition() throws OptimizationException {\n    for (int k \u003d 0; k \u003c cols; ++k) {\n        permutation[k] \u003d k;\n        double norm2 \u003d 0;\n        for (int i \u003d 0; i \u003c jacobian.length; ++i) {\n            double akk \u003d jacobian[i][k];\n            norm2 +\u003d akk * akk;\n        }\n        jacNorm[k] \u003d Math.sqrt(norm2);\n    }\n    for (int k \u003d 0; k \u003c cols; ++k) {\n        int nextColumn \u003d -1;\n        double ak2 \u003d Double.NEGATIVE_INFINITY;\n        for (int i \u003d k; i \u003c cols; ++i) {\n            double norm2 \u003d 0;\n            for (int j \u003d k; j \u003c jacobian.length; ++j) {\n                double aki \u003d jacobian[j][permutation[i]];\n                norm2 +\u003d aki * aki;\n            }\n            if (Double.isInfinite(norm2) || Double.isNaN(norm2)) {\n                throw new OptimizationException(LocalizedFormats.UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN, rows, cols);\n            }\n            if (norm2 \u003e ak2) {\n                nextColumn \u003d i;\n                ak2 \u003d norm2;\n            }\n        }\n        if (ak2 \u003c\u003d qrRankingThreshold) {\n            rank \u003d k;\n            return;\n        }\n        int pk \u003d permutation[nextColumn];\n        permutation[nextColumn] \u003d permutation[k];\n        permutation[k] \u003d pk;\n        double akk \u003d jacobian[k][pk];\n        double alpha \u003d (akk \u003e 0) ? -Math.sqrt(ak2) : Math.sqrt(ak2);\n        double betak \u003d 1.0 / (ak2 - akk * alpha);\n        beta[pk] \u003d betak;\n        diagR[pk] \u003d alpha;\n        jacobian[k][pk] -\u003d alpha;\n        for (int dk \u003d cols - 1 - k; dk \u003e 0; --dk) {\n            double gamma \u003d 0;\n            for (int j \u003d k; j \u003c jacobian.length; ++j) {\n                gamma +\u003d jacobian[j][pk] * jacobian[j][permutation[k + dk]];\n            }\n            gamma *\u003d betak;\n            for (int j \u003d k; j \u003c jacobian.length; ++j) {\n                jacobian[j][permutation[k + dk]] -\u003d gamma * jacobian[j][pk];\n            }\n        }\n    }\n    rank \u003d solvedCols;\n}",
      "path": "src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java",
      "functionStartLine": 788,
      "functionName": "qrDecomposition",
      "functionAnnotation": "",
      "functionDoc": "Decompose a matrix A as A.P \u003d Q.R using Householder transforms.\n\u003cp\u003eAs suggested in the P. Lascaux and R. Theodor book\n\u003ci\u003eAnalyse num\u0026eacute;rique matricielle appliqu\u0026eacute;e \u0026agrave;\nl\u0027art de l\u0027ing\u0026eacute;nieur\u003c/i\u003e (Masson, 1986), instead of representing\nthe Householder transforms with u\u003csub\u003ek\u003c/sub\u003e unit vectors such that:\n\u003cpre\u003e\nH\u003csub\u003ek\u003c/sub\u003e \u003d I - 2u\u003csub\u003ek\u003c/sub\u003e.u\u003csub\u003ek\u003c/sub\u003e\u003csup\u003et\u003c/sup\u003e\n\u003c/pre\u003e\nwe use \u003csub\u003ek\u003c/sub\u003e non-unit vectors such that:\n\u003cpre\u003e\nH\u003csub\u003ek\u003c/sub\u003e \u003d I - beta\u003csub\u003ek\u003c/sub\u003ev\u003csub\u003ek\u003c/sub\u003e.v\u003csub\u003ek\u003c/sub\u003e\u003csup\u003et\u003c/sup\u003e\n\u003c/pre\u003e\nwhere v\u003csub\u003ek\u003c/sub\u003e \u003d a\u003csub\u003ek\u003c/sub\u003e - alpha\u003csub\u003ek\u003c/sub\u003e e\u003csub\u003ek\u003c/sub\u003e.\nThe beta\u003csub\u003ek\u003c/sub\u003e coefficients are provided upon exit as recomputing\nthem from the v\u003csub\u003ek\u003c/sub\u003e vectors would be costly.\u003c/p\u003e\n\u003cp\u003eThis decomposition handles rank deficient cases since the tranformations\nare performed in non-increasing columns norms order thanks to columns\npivoting. The diagonal elements of the R matrix are therefore also in\nnon-increasing absolute values order.\u003c/p\u003e\n\n@exception OptimizationException if the decomposition cannot be performed\n",
      "diff": "@@ -1,53 +1,53 @@\n private void qrDecomposition() throws OptimizationException {\n     for (int k \u003d 0; k \u003c cols; ++k) {\n         permutation[k] \u003d k;\n         double norm2 \u003d 0;\n         for (int i \u003d 0; i \u003c jacobian.length; ++i) {\n             double akk \u003d jacobian[i][k];\n             norm2 +\u003d akk * akk;\n         }\n         jacNorm[k] \u003d Math.sqrt(norm2);\n     }\n     for (int k \u003d 0; k \u003c cols; ++k) {\n         int nextColumn \u003d -1;\n         double ak2 \u003d Double.NEGATIVE_INFINITY;\n         for (int i \u003d k; i \u003c cols; ++i) {\n             double norm2 \u003d 0;\n             for (int j \u003d k; j \u003c jacobian.length; ++j) {\n                 double aki \u003d jacobian[j][permutation[i]];\n                 norm2 +\u003d aki * aki;\n             }\n             if (Double.isInfinite(norm2) || Double.isNaN(norm2)) {\n-                throw new OptimizationException(\"unable to perform Q.R decomposition on the {0}x{1} jacobian matrix\", rows, cols);\n+                throw new OptimizationException(LocalizedFormats.UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN, rows, cols);\n             }\n             if (norm2 \u003e ak2) {\n                 nextColumn \u003d i;\n                 ak2 \u003d norm2;\n             }\n         }\n         if (ak2 \u003c\u003d qrRankingThreshold) {\n             rank \u003d k;\n             return;\n         }\n         int pk \u003d permutation[nextColumn];\n         permutation[nextColumn] \u003d permutation[k];\n         permutation[k] \u003d pk;\n         double akk \u003d jacobian[k][pk];\n         double alpha \u003d (akk \u003e 0) ? -Math.sqrt(ak2) : Math.sqrt(ak2);\n         double betak \u003d 1.0 / (ak2 - akk * alpha);\n         beta[pk] \u003d betak;\n         diagR[pk] \u003d alpha;\n         jacobian[k][pk] -\u003d alpha;\n         for (int dk \u003d cols - 1 - k; dk \u003e 0; --dk) {\n             double gamma \u003d 0;\n             for (int j \u003d k; j \u003c jacobian.length; ++j) {\n                 gamma +\u003d jacobian[j][pk] * jacobian[j][permutation[k + dk]];\n             }\n             gamma *\u003d betak;\n             for (int j \u003d k; j \u003c jacobian.length; ++j) {\n                 jacobian[j][permutation[k + dk]] -\u003d gamma * jacobian[j][pk];\n             }\n         }\n     }\n     rank \u003d solvedCols;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "006e834bc3d18fc1d649392a606f4f291378c965": {
      "type": "Ybodychange",
      "commitMessage": "Added a setQRRankingThreshold method to Levenberg-Marquardt optimizer to improve robustness of rank determination.\nJIRA: MATH-352\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@951864 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "6/6/10, 7:01 AM",
      "commitName": "006e834bc3d18fc1d649392a606f4f291378c965",
      "commitAuthor": "Luc Maisonobe",
      "commitDateOld": "5/31/10, 11:35 PM",
      "commitNameOld": "f62b589b10d3bd94ab24006c70ae5d86ec9bd3fb",
      "commitAuthorOld": "Luc Maisonobe",
      "daysBetweenCommits": 5.31,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "private void qrDecomposition() throws OptimizationException {\n    for (int k \u003d 0; k \u003c cols; ++k) {\n        permutation[k] \u003d k;\n        double norm2 \u003d 0;\n        for (int i \u003d 0; i \u003c jacobian.length; ++i) {\n            double akk \u003d jacobian[i][k];\n            norm2 +\u003d akk * akk;\n        }\n        jacNorm[k] \u003d Math.sqrt(norm2);\n    }\n    for (int k \u003d 0; k \u003c cols; ++k) {\n        int nextColumn \u003d -1;\n        double ak2 \u003d Double.NEGATIVE_INFINITY;\n        for (int i \u003d k; i \u003c cols; ++i) {\n            double norm2 \u003d 0;\n            for (int j \u003d k; j \u003c jacobian.length; ++j) {\n                double aki \u003d jacobian[j][permutation[i]];\n                norm2 +\u003d aki * aki;\n            }\n            if (Double.isInfinite(norm2) || Double.isNaN(norm2)) {\n                throw new OptimizationException(\"unable to perform Q.R decomposition on the {0}x{1} jacobian matrix\", rows, cols);\n            }\n            if (norm2 \u003e ak2) {\n                nextColumn \u003d i;\n                ak2 \u003d norm2;\n            }\n        }\n        if (ak2 \u003c\u003d qrRankingThreshold) {\n            rank \u003d k;\n            return;\n        }\n        int pk \u003d permutation[nextColumn];\n        permutation[nextColumn] \u003d permutation[k];\n        permutation[k] \u003d pk;\n        double akk \u003d jacobian[k][pk];\n        double alpha \u003d (akk \u003e 0) ? -Math.sqrt(ak2) : Math.sqrt(ak2);\n        double betak \u003d 1.0 / (ak2 - akk * alpha);\n        beta[pk] \u003d betak;\n        diagR[pk] \u003d alpha;\n        jacobian[k][pk] -\u003d alpha;\n        for (int dk \u003d cols - 1 - k; dk \u003e 0; --dk) {\n            double gamma \u003d 0;\n            for (int j \u003d k; j \u003c jacobian.length; ++j) {\n                gamma +\u003d jacobian[j][pk] * jacobian[j][permutation[k + dk]];\n            }\n            gamma *\u003d betak;\n            for (int j \u003d k; j \u003c jacobian.length; ++j) {\n                jacobian[j][permutation[k + dk]] -\u003d gamma * jacobian[j][pk];\n            }\n        }\n    }\n    rank \u003d solvedCols;\n}",
      "path": "src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java",
      "functionStartLine": 792,
      "functionName": "qrDecomposition",
      "functionAnnotation": "",
      "functionDoc": "Decompose a matrix A as A.P \u003d Q.R using Householder transforms.\n\u003cp\u003eAs suggested in the P. Lascaux and R. Theodor book\n\u003ci\u003eAnalyse num\u0026eacute;rique matricielle appliqu\u0026eacute;e \u0026agrave;\nl\u0027art de l\u0027ing\u0026eacute;nieur\u003c/i\u003e (Masson, 1986), instead of representing\nthe Householder transforms with u\u003csub\u003ek\u003c/sub\u003e unit vectors such that:\n\u003cpre\u003e\nH\u003csub\u003ek\u003c/sub\u003e \u003d I - 2u\u003csub\u003ek\u003c/sub\u003e.u\u003csub\u003ek\u003c/sub\u003e\u003csup\u003et\u003c/sup\u003e\n\u003c/pre\u003e\nwe use \u003csub\u003ek\u003c/sub\u003e non-unit vectors such that:\n\u003cpre\u003e\nH\u003csub\u003ek\u003c/sub\u003e \u003d I - beta\u003csub\u003ek\u003c/sub\u003ev\u003csub\u003ek\u003c/sub\u003e.v\u003csub\u003ek\u003c/sub\u003e\u003csup\u003et\u003c/sup\u003e\n\u003c/pre\u003e\nwhere v\u003csub\u003ek\u003c/sub\u003e \u003d a\u003csub\u003ek\u003c/sub\u003e - alpha\u003csub\u003ek\u003c/sub\u003e e\u003csub\u003ek\u003c/sub\u003e.\nThe beta\u003csub\u003ek\u003c/sub\u003e coefficients are provided upon exit as recomputing\nthem from the v\u003csub\u003ek\u003c/sub\u003e vectors would be costly.\u003c/p\u003e\n\u003cp\u003eThis decomposition handles rank deficient cases since the tranformations\nare performed in non-increasing columns norms order thanks to columns\npivoting. The diagonal elements of the R matrix are therefore also in\nnon-increasing absolute values order.\u003c/p\u003e\n\n@exception OptimizationException if the decomposition cannot be performed\n",
      "diff": "@@ -1,53 +1,53 @@\n private void qrDecomposition() throws OptimizationException {\n     for (int k \u003d 0; k \u003c cols; ++k) {\n         permutation[k] \u003d k;\n         double norm2 \u003d 0;\n         for (int i \u003d 0; i \u003c jacobian.length; ++i) {\n             double akk \u003d jacobian[i][k];\n             norm2 +\u003d akk * akk;\n         }\n         jacNorm[k] \u003d Math.sqrt(norm2);\n     }\n     for (int k \u003d 0; k \u003c cols; ++k) {\n         int nextColumn \u003d -1;\n         double ak2 \u003d Double.NEGATIVE_INFINITY;\n         for (int i \u003d k; i \u003c cols; ++i) {\n             double norm2 \u003d 0;\n             for (int j \u003d k; j \u003c jacobian.length; ++j) {\n                 double aki \u003d jacobian[j][permutation[i]];\n                 norm2 +\u003d aki * aki;\n             }\n             if (Double.isInfinite(norm2) || Double.isNaN(norm2)) {\n                 throw new OptimizationException(\"unable to perform Q.R decomposition on the {0}x{1} jacobian matrix\", rows, cols);\n             }\n             if (norm2 \u003e ak2) {\n                 nextColumn \u003d i;\n                 ak2 \u003d norm2;\n             }\n         }\n-        if (ak2 \u003d\u003d 0) {\n+        if (ak2 \u003c\u003d qrRankingThreshold) {\n             rank \u003d k;\n             return;\n         }\n         int pk \u003d permutation[nextColumn];\n         permutation[nextColumn] \u003d permutation[k];\n         permutation[k] \u003d pk;\n         double akk \u003d jacobian[k][pk];\n         double alpha \u003d (akk \u003e 0) ? -Math.sqrt(ak2) : Math.sqrt(ak2);\n         double betak \u003d 1.0 / (ak2 - akk * alpha);\n         beta[pk] \u003d betak;\n         diagR[pk] \u003d alpha;\n         jacobian[k][pk] -\u003d alpha;\n         for (int dk \u003d cols - 1 - k; dk \u003e 0; --dk) {\n             double gamma \u003d 0;\n             for (int j \u003d k; j \u003c jacobian.length; ++j) {\n                 gamma +\u003d jacobian[j][pk] * jacobian[j][permutation[k + dk]];\n             }\n             gamma *\u003d betak;\n             for (int j \u003d k; j \u003c jacobian.length; ++j) {\n                 jacobian[j][permutation[k + dk]] -\u003d gamma * jacobian[j][pk];\n             }\n         }\n     }\n     rank \u003d solvedCols;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f62b589b10d3bd94ab24006c70ae5d86ec9bd3fb": {
      "type": "Ybodychange",
      "commitMessage": "reverting a change introduced by error in r949935\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@949936 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "5/31/10, 11:35 PM",
      "commitName": "f62b589b10d3bd94ab24006c70ae5d86ec9bd3fb",
      "commitAuthor": "Luc Maisonobe",
      "commitDateOld": "5/31/10, 11:25 PM",
      "commitNameOld": "5f33585147ed8917bcc40f67794e9476bf1d53f8",
      "commitAuthorOld": "Luc Maisonobe",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private void qrDecomposition() throws OptimizationException {\n    for (int k \u003d 0; k \u003c cols; ++k) {\n        permutation[k] \u003d k;\n        double norm2 \u003d 0;\n        for (int i \u003d 0; i \u003c jacobian.length; ++i) {\n            double akk \u003d jacobian[i][k];\n            norm2 +\u003d akk * akk;\n        }\n        jacNorm[k] \u003d Math.sqrt(norm2);\n    }\n    for (int k \u003d 0; k \u003c cols; ++k) {\n        int nextColumn \u003d -1;\n        double ak2 \u003d Double.NEGATIVE_INFINITY;\n        for (int i \u003d k; i \u003c cols; ++i) {\n            double norm2 \u003d 0;\n            for (int j \u003d k; j \u003c jacobian.length; ++j) {\n                double aki \u003d jacobian[j][permutation[i]];\n                norm2 +\u003d aki * aki;\n            }\n            if (Double.isInfinite(norm2) || Double.isNaN(norm2)) {\n                throw new OptimizationException(\"unable to perform Q.R decomposition on the {0}x{1} jacobian matrix\", rows, cols);\n            }\n            if (norm2 \u003e ak2) {\n                nextColumn \u003d i;\n                ak2 \u003d norm2;\n            }\n        }\n        if (ak2 \u003d\u003d 0) {\n            rank \u003d k;\n            return;\n        }\n        int pk \u003d permutation[nextColumn];\n        permutation[nextColumn] \u003d permutation[k];\n        permutation[k] \u003d pk;\n        double akk \u003d jacobian[k][pk];\n        double alpha \u003d (akk \u003e 0) ? -Math.sqrt(ak2) : Math.sqrt(ak2);\n        double betak \u003d 1.0 / (ak2 - akk * alpha);\n        beta[pk] \u003d betak;\n        diagR[pk] \u003d alpha;\n        jacobian[k][pk] -\u003d alpha;\n        for (int dk \u003d cols - 1 - k; dk \u003e 0; --dk) {\n            double gamma \u003d 0;\n            for (int j \u003d k; j \u003c jacobian.length; ++j) {\n                gamma +\u003d jacobian[j][pk] * jacobian[j][permutation[k + dk]];\n            }\n            gamma *\u003d betak;\n            for (int j \u003d k; j \u003c jacobian.length; ++j) {\n                jacobian[j][permutation[k + dk]] -\u003d gamma * jacobian[j][pk];\n            }\n        }\n    }\n    rank \u003d solvedCols;\n}",
      "path": "src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java",
      "functionStartLine": 773,
      "functionName": "qrDecomposition",
      "functionAnnotation": "",
      "functionDoc": "Decompose a matrix A as A.P \u003d Q.R using Householder transforms.\n\u003cp\u003eAs suggested in the P. Lascaux and R. Theodor book\n\u003ci\u003eAnalyse num\u0026eacute;rique matricielle appliqu\u0026eacute;e \u0026agrave;\nl\u0027art de l\u0027ing\u0026eacute;nieur\u003c/i\u003e (Masson, 1986), instead of representing\nthe Householder transforms with u\u003csub\u003ek\u003c/sub\u003e unit vectors such that:\n\u003cpre\u003e\nH\u003csub\u003ek\u003c/sub\u003e \u003d I - 2u\u003csub\u003ek\u003c/sub\u003e.u\u003csub\u003ek\u003c/sub\u003e\u003csup\u003et\u003c/sup\u003e\n\u003c/pre\u003e\nwe use \u003csub\u003ek\u003c/sub\u003e non-unit vectors such that:\n\u003cpre\u003e\nH\u003csub\u003ek\u003c/sub\u003e \u003d I - beta\u003csub\u003ek\u003c/sub\u003ev\u003csub\u003ek\u003c/sub\u003e.v\u003csub\u003ek\u003c/sub\u003e\u003csup\u003et\u003c/sup\u003e\n\u003c/pre\u003e\nwhere v\u003csub\u003ek\u003c/sub\u003e \u003d a\u003csub\u003ek\u003c/sub\u003e - alpha\u003csub\u003ek\u003c/sub\u003e e\u003csub\u003ek\u003c/sub\u003e.\nThe beta\u003csub\u003ek\u003c/sub\u003e coefficients are provided upon exit as recomputing\nthem from the v\u003csub\u003ek\u003c/sub\u003e vectors would be costly.\u003c/p\u003e\n\u003cp\u003eThis decomposition handles rank deficient cases since the tranformations\nare performed in non-increasing columns norms order thanks to columns\npivoting. The diagonal elements of the R matrix are therefore also in\nnon-increasing absolute values order.\u003c/p\u003e\n\n@exception OptimizationException if the decomposition cannot be performed\n",
      "diff": "@@ -1,53 +1,53 @@\n private void qrDecomposition() throws OptimizationException {\n     for (int k \u003d 0; k \u003c cols; ++k) {\n         permutation[k] \u003d k;\n         double norm2 \u003d 0;\n         for (int i \u003d 0; i \u003c jacobian.length; ++i) {\n             double akk \u003d jacobian[i][k];\n             norm2 +\u003d akk * akk;\n         }\n         jacNorm[k] \u003d Math.sqrt(norm2);\n     }\n     for (int k \u003d 0; k \u003c cols; ++k) {\n         int nextColumn \u003d -1;\n         double ak2 \u003d Double.NEGATIVE_INFINITY;\n         for (int i \u003d k; i \u003c cols; ++i) {\n             double norm2 \u003d 0;\n             for (int j \u003d k; j \u003c jacobian.length; ++j) {\n                 double aki \u003d jacobian[j][permutation[i]];\n                 norm2 +\u003d aki * aki;\n             }\n             if (Double.isInfinite(norm2) || Double.isNaN(norm2)) {\n                 throw new OptimizationException(\"unable to perform Q.R decomposition on the {0}x{1} jacobian matrix\", rows, cols);\n             }\n             if (norm2 \u003e ak2) {\n                 nextColumn \u003d i;\n                 ak2 \u003d norm2;\n             }\n         }\n-        if (ak2 \u003c 1.0e-66) {\n+        if (ak2 \u003d\u003d 0) {\n             rank \u003d k;\n             return;\n         }\n         int pk \u003d permutation[nextColumn];\n         permutation[nextColumn] \u003d permutation[k];\n         permutation[k] \u003d pk;\n         double akk \u003d jacobian[k][pk];\n         double alpha \u003d (akk \u003e 0) ? -Math.sqrt(ak2) : Math.sqrt(ak2);\n         double betak \u003d 1.0 / (ak2 - akk * alpha);\n         beta[pk] \u003d betak;\n         diagR[pk] \u003d alpha;\n         jacobian[k][pk] -\u003d alpha;\n         for (int dk \u003d cols - 1 - k; dk \u003e 0; --dk) {\n             double gamma \u003d 0;\n             for (int j \u003d k; j \u003c jacobian.length; ++j) {\n                 gamma +\u003d jacobian[j][pk] * jacobian[j][permutation[k + dk]];\n             }\n             gamma *\u003d betak;\n             for (int j \u003d k; j \u003c jacobian.length; ++j) {\n                 jacobian[j][permutation[k + dk]] -\u003d gamma * jacobian[j][pk];\n             }\n         }\n     }\n     rank \u003d solvedCols;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5f33585147ed8917bcc40f67794e9476bf1d53f8": {
      "type": "Ybodychange",
      "commitMessage": "fixed an error message\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@949935 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "5/31/10, 11:25 PM",
      "commitName": "5f33585147ed8917bcc40f67794e9476bf1d53f8",
      "commitAuthor": "Luc Maisonobe",
      "commitDateOld": "5/30/10, 11:34 AM",
      "commitNameOld": "5908f8a7ae04be852b45b66ef6b12562b832cba8",
      "commitAuthorOld": "Phil Steitz",
      "daysBetweenCommits": 1.49,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "private void qrDecomposition() throws OptimizationException {\n    for (int k \u003d 0; k \u003c cols; ++k) {\n        permutation[k] \u003d k;\n        double norm2 \u003d 0;\n        for (int i \u003d 0; i \u003c jacobian.length; ++i) {\n            double akk \u003d jacobian[i][k];\n            norm2 +\u003d akk * akk;\n        }\n        jacNorm[k] \u003d Math.sqrt(norm2);\n    }\n    for (int k \u003d 0; k \u003c cols; ++k) {\n        int nextColumn \u003d -1;\n        double ak2 \u003d Double.NEGATIVE_INFINITY;\n        for (int i \u003d k; i \u003c cols; ++i) {\n            double norm2 \u003d 0;\n            for (int j \u003d k; j \u003c jacobian.length; ++j) {\n                double aki \u003d jacobian[j][permutation[i]];\n                norm2 +\u003d aki * aki;\n            }\n            if (Double.isInfinite(norm2) || Double.isNaN(norm2)) {\n                throw new OptimizationException(\"unable to perform Q.R decomposition on the {0}x{1} jacobian matrix\", rows, cols);\n            }\n            if (norm2 \u003e ak2) {\n                nextColumn \u003d i;\n                ak2 \u003d norm2;\n            }\n        }\n        if (ak2 \u003c 1.0e-66) {\n            rank \u003d k;\n            return;\n        }\n        int pk \u003d permutation[nextColumn];\n        permutation[nextColumn] \u003d permutation[k];\n        permutation[k] \u003d pk;\n        double akk \u003d jacobian[k][pk];\n        double alpha \u003d (akk \u003e 0) ? -Math.sqrt(ak2) : Math.sqrt(ak2);\n        double betak \u003d 1.0 / (ak2 - akk * alpha);\n        beta[pk] \u003d betak;\n        diagR[pk] \u003d alpha;\n        jacobian[k][pk] -\u003d alpha;\n        for (int dk \u003d cols - 1 - k; dk \u003e 0; --dk) {\n            double gamma \u003d 0;\n            for (int j \u003d k; j \u003c jacobian.length; ++j) {\n                gamma +\u003d jacobian[j][pk] * jacobian[j][permutation[k + dk]];\n            }\n            gamma *\u003d betak;\n            for (int j \u003d k; j \u003c jacobian.length; ++j) {\n                jacobian[j][permutation[k + dk]] -\u003d gamma * jacobian[j][pk];\n            }\n        }\n    }\n    rank \u003d solvedCols;\n}",
      "path": "src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java",
      "functionStartLine": 773,
      "functionName": "qrDecomposition",
      "functionAnnotation": "",
      "functionDoc": "Decompose a matrix A as A.P \u003d Q.R using Householder transforms.\n\u003cp\u003eAs suggested in the P. Lascaux and R. Theodor book\n\u003ci\u003eAnalyse num\u0026eacute;rique matricielle appliqu\u0026eacute;e \u0026agrave;\nl\u0027art de l\u0027ing\u0026eacute;nieur\u003c/i\u003e (Masson, 1986), instead of representing\nthe Householder transforms with u\u003csub\u003ek\u003c/sub\u003e unit vectors such that:\n\u003cpre\u003e\nH\u003csub\u003ek\u003c/sub\u003e \u003d I - 2u\u003csub\u003ek\u003c/sub\u003e.u\u003csub\u003ek\u003c/sub\u003e\u003csup\u003et\u003c/sup\u003e\n\u003c/pre\u003e\nwe use \u003csub\u003ek\u003c/sub\u003e non-unit vectors such that:\n\u003cpre\u003e\nH\u003csub\u003ek\u003c/sub\u003e \u003d I - beta\u003csub\u003ek\u003c/sub\u003ev\u003csub\u003ek\u003c/sub\u003e.v\u003csub\u003ek\u003c/sub\u003e\u003csup\u003et\u003c/sup\u003e\n\u003c/pre\u003e\nwhere v\u003csub\u003ek\u003c/sub\u003e \u003d a\u003csub\u003ek\u003c/sub\u003e - alpha\u003csub\u003ek\u003c/sub\u003e e\u003csub\u003ek\u003c/sub\u003e.\nThe beta\u003csub\u003ek\u003c/sub\u003e coefficients are provided upon exit as recomputing\nthem from the v\u003csub\u003ek\u003c/sub\u003e vectors would be costly.\u003c/p\u003e\n\u003cp\u003eThis decomposition handles rank deficient cases since the tranformations\nare performed in non-increasing columns norms order thanks to columns\npivoting. The diagonal elements of the R matrix are therefore also in\nnon-increasing absolute values order.\u003c/p\u003e\n\n@exception OptimizationException if the decomposition cannot be performed\n",
      "diff": "@@ -1,53 +1,53 @@\n private void qrDecomposition() throws OptimizationException {\n     for (int k \u003d 0; k \u003c cols; ++k) {\n         permutation[k] \u003d k;\n         double norm2 \u003d 0;\n         for (int i \u003d 0; i \u003c jacobian.length; ++i) {\n             double akk \u003d jacobian[i][k];\n             norm2 +\u003d akk * akk;\n         }\n         jacNorm[k] \u003d Math.sqrt(norm2);\n     }\n     for (int k \u003d 0; k \u003c cols; ++k) {\n         int nextColumn \u003d -1;\n         double ak2 \u003d Double.NEGATIVE_INFINITY;\n         for (int i \u003d k; i \u003c cols; ++i) {\n             double norm2 \u003d 0;\n             for (int j \u003d k; j \u003c jacobian.length; ++j) {\n                 double aki \u003d jacobian[j][permutation[i]];\n                 norm2 +\u003d aki * aki;\n             }\n             if (Double.isInfinite(norm2) || Double.isNaN(norm2)) {\n                 throw new OptimizationException(\"unable to perform Q.R decomposition on the {0}x{1} jacobian matrix\", rows, cols);\n             }\n             if (norm2 \u003e ak2) {\n                 nextColumn \u003d i;\n                 ak2 \u003d norm2;\n             }\n         }\n-        if (ak2 \u003d\u003d 0) {\n+        if (ak2 \u003c 1.0e-66) {\n             rank \u003d k;\n             return;\n         }\n         int pk \u003d permutation[nextColumn];\n         permutation[nextColumn] \u003d permutation[k];\n         permutation[k] \u003d pk;\n         double akk \u003d jacobian[k][pk];\n         double alpha \u003d (akk \u003e 0) ? -Math.sqrt(ak2) : Math.sqrt(ak2);\n         double betak \u003d 1.0 / (ak2 - akk * alpha);\n         beta[pk] \u003d betak;\n         diagR[pk] \u003d alpha;\n         jacobian[k][pk] -\u003d alpha;\n         for (int dk \u003d cols - 1 - k; dk \u003e 0; --dk) {\n             double gamma \u003d 0;\n             for (int j \u003d k; j \u003c jacobian.length; ++j) {\n                 gamma +\u003d jacobian[j][pk] * jacobian[j][permutation[k + dk]];\n             }\n             gamma *\u003d betak;\n             for (int j \u003d k; j \u003c jacobian.length; ++j) {\n                 jacobian[j][permutation[k + dk]] -\u003d gamma * jacobian[j][pk];\n             }\n         }\n     }\n     rank \u003d solvedCols;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d6a438e931412713e99624cf9ed74470f1040184": {
      "type": "Yfilerename",
      "commitMessage": "moved main java directory for compliance with maven standard directory layout\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@799870 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "8/1/09, 7:30 AM",
      "commitName": "d6a438e931412713e99624cf9ed74470f1040184",
      "commitAuthor": "Luc Maisonobe",
      "commitDateOld": "8/1/09, 7:23 AM",
      "commitNameOld": "2ad5ef61630be627f46ae1c266cf796f044bd4a8",
      "commitAuthorOld": "Luc Maisonobe",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private void qrDecomposition() throws OptimizationException {\n    for (int k \u003d 0; k \u003c cols; ++k) {\n        permutation[k] \u003d k;\n        double norm2 \u003d 0;\n        for (int i \u003d 0; i \u003c jacobian.length; ++i) {\n            double akk \u003d jacobian[i][k];\n            norm2 +\u003d akk * akk;\n        }\n        jacNorm[k] \u003d Math.sqrt(norm2);\n    }\n    for (int k \u003d 0; k \u003c cols; ++k) {\n        int nextColumn \u003d -1;\n        double ak2 \u003d Double.NEGATIVE_INFINITY;\n        for (int i \u003d k; i \u003c cols; ++i) {\n            double norm2 \u003d 0;\n            for (int j \u003d k; j \u003c jacobian.length; ++j) {\n                double aki \u003d jacobian[j][permutation[i]];\n                norm2 +\u003d aki * aki;\n            }\n            if (Double.isInfinite(norm2) || Double.isNaN(norm2)) {\n                throw new OptimizationException(\"unable to perform Q.R decomposition on the {0}x{1} jacobian matrix\", rows, cols);\n            }\n            if (norm2 \u003e ak2) {\n                nextColumn \u003d i;\n                ak2 \u003d norm2;\n            }\n        }\n        if (ak2 \u003d\u003d 0) {\n            rank \u003d k;\n            return;\n        }\n        int pk \u003d permutation[nextColumn];\n        permutation[nextColumn] \u003d permutation[k];\n        permutation[k] \u003d pk;\n        double akk \u003d jacobian[k][pk];\n        double alpha \u003d (akk \u003e 0) ? -Math.sqrt(ak2) : Math.sqrt(ak2);\n        double betak \u003d 1.0 / (ak2 - akk * alpha);\n        beta[pk] \u003d betak;\n        diagR[pk] \u003d alpha;\n        jacobian[k][pk] -\u003d alpha;\n        for (int dk \u003d cols - 1 - k; dk \u003e 0; --dk) {\n            double gamma \u003d 0;\n            for (int j \u003d k; j \u003c jacobian.length; ++j) {\n                gamma +\u003d jacobian[j][pk] * jacobian[j][permutation[k + dk]];\n            }\n            gamma *\u003d betak;\n            for (int j \u003d k; j \u003c jacobian.length; ++j) {\n                jacobian[j][permutation[k + dk]] -\u003d gamma * jacobian[j][pk];\n            }\n        }\n    }\n    rank \u003d solvedCols;\n}",
      "path": "src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java",
      "functionStartLine": 748,
      "functionName": "qrDecomposition",
      "functionAnnotation": "",
      "functionDoc": "Decompose a matrix A as A.P \u003d Q.R using Householder transforms.\n\u003cp\u003eAs suggested in the P. Lascaux and R. Theodor book\n\u003ci\u003eAnalyse num\u0026eacute;rique matricielle appliqu\u0026eacute;e \u0026agrave;\nl\u0027art de l\u0027ing\u0026eacute;nieur\u003c/i\u003e (Masson, 1986), instead of representing\nthe Householder transforms with u\u003csub\u003ek\u003c/sub\u003e unit vectors such that:\n\u003cpre\u003e\nH\u003csub\u003ek\u003c/sub\u003e \u003d I - 2u\u003csub\u003ek\u003c/sub\u003e.u\u003csub\u003ek\u003c/sub\u003e\u003csup\u003et\u003c/sup\u003e\n\u003c/pre\u003e\nwe use \u003csub\u003ek\u003c/sub\u003e non-unit vectors such that:\n\u003cpre\u003e\nH\u003csub\u003ek\u003c/sub\u003e \u003d I - beta\u003csub\u003ek\u003c/sub\u003ev\u003csub\u003ek\u003c/sub\u003e.v\u003csub\u003ek\u003c/sub\u003e\u003csup\u003et\u003c/sup\u003e\n\u003c/pre\u003e\nwhere v\u003csub\u003ek\u003c/sub\u003e \u003d a\u003csub\u003ek\u003c/sub\u003e - alpha\u003csub\u003ek\u003c/sub\u003e e\u003csub\u003ek\u003c/sub\u003e.\nThe beta\u003csub\u003ek\u003c/sub\u003e coefficients are provided upon exit as recomputing\nthem from the v\u003csub\u003ek\u003c/sub\u003e vectors would be costly.\u003c/p\u003e\n\u003cp\u003eThis decomposition handles rank deficient cases since the tranformations\nare performed in non-increasing columns norms order thanks to columns\npivoting. The diagonal elements of the R matrix are therefore also in\nnon-increasing absolute values order.\u003c/p\u003e\n\n@exception OptimizationException if the decomposition cannot be performed\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java",
        "newPath": "src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java"
      }
    },
    "8541f303370cec9a25f2b32b3d660b3f188913f0": {
      "type": "Ymultichange(Ymovefromfile,Ybodychange)",
      "commitMessage": "adapted old Levenberg-Marquardt estimator to new top level optimizers API\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@754727 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "3/15/09, 12:11 PM",
      "commitName": "8541f303370cec9a25f2b32b3d660b3f188913f0",
      "commitAuthor": "Luc Maisonobe",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "adapted old Levenberg-Marquardt estimator to new top level optimizers API\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@754727 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "3/15/09, 12:11 PM",
          "commitName": "8541f303370cec9a25f2b32b3d660b3f188913f0",
          "commitAuthor": "Luc Maisonobe",
          "commitDateOld": "3/14/09, 10:38 AM",
          "commitNameOld": "8cb418e7fa50aba9977fe073aec66ad3f6e4f07c",
          "commitAuthorOld": "Luc Maisonobe",
          "daysBetweenCommits": 1.06,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "private void qrDecomposition() throws OptimizationException {\n    for (int k \u003d 0; k \u003c cols; ++k) {\n        permutation[k] \u003d k;\n        double norm2 \u003d 0;\n        for (int i \u003d 0; i \u003c jacobian.length; ++i) {\n            double akk \u003d jacobian[i][k];\n            norm2 +\u003d akk * akk;\n        }\n        jacNorm[k] \u003d Math.sqrt(norm2);\n    }\n    for (int k \u003d 0; k \u003c cols; ++k) {\n        int nextColumn \u003d -1;\n        double ak2 \u003d Double.NEGATIVE_INFINITY;\n        for (int i \u003d k; i \u003c cols; ++i) {\n            double norm2 \u003d 0;\n            for (int j \u003d k; j \u003c jacobian.length; ++j) {\n                double aki \u003d jacobian[j][permutation[i]];\n                norm2 +\u003d aki * aki;\n            }\n            if (Double.isInfinite(norm2) || Double.isNaN(norm2)) {\n                throw new OptimizationException(\"unable to perform Q.R decomposition on the {0}x{1} jacobian matrix\", rows, cols);\n            }\n            if (norm2 \u003e ak2) {\n                nextColumn \u003d i;\n                ak2 \u003d norm2;\n            }\n        }\n        if (ak2 \u003d\u003d 0) {\n            rank \u003d k;\n            return;\n        }\n        int pk \u003d permutation[nextColumn];\n        permutation[nextColumn] \u003d permutation[k];\n        permutation[k] \u003d pk;\n        double akk \u003d jacobian[k][pk];\n        double alpha \u003d (akk \u003e 0) ? -Math.sqrt(ak2) : Math.sqrt(ak2);\n        double betak \u003d 1.0 / (ak2 - akk * alpha);\n        beta[pk] \u003d betak;\n        diagR[pk] \u003d alpha;\n        jacobian[k][pk] -\u003d alpha;\n        for (int dk \u003d cols - 1 - k; dk \u003e 0; --dk) {\n            double gamma \u003d 0;\n            for (int j \u003d k; j \u003c jacobian.length; ++j) {\n                gamma +\u003d jacobian[j][pk] * jacobian[j][permutation[k + dk]];\n            }\n            gamma *\u003d betak;\n            for (int j \u003d k; j \u003c jacobian.length; ++j) {\n                jacobian[j][permutation[k + dk]] -\u003d gamma * jacobian[j][pk];\n            }\n        }\n    }\n    rank \u003d solvedCols;\n}",
          "path": "src/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java",
          "functionStartLine": 748,
          "functionName": "qrDecomposition",
          "functionAnnotation": "",
          "functionDoc": "Decompose a matrix A as A.P \u003d Q.R using Householder transforms.\n\u003cp\u003eAs suggested in the P. Lascaux and R. Theodor book\n\u003ci\u003eAnalyse num\u0026eacute;rique matricielle appliqu\u0026eacute;e \u0026agrave;\nl\u0027art de l\u0027ing\u0026eacute;nieur\u003c/i\u003e (Masson, 1986), instead of representing\nthe Householder transforms with u\u003csub\u003ek\u003c/sub\u003e unit vectors such that:\n\u003cpre\u003e\nH\u003csub\u003ek\u003c/sub\u003e \u003d I - 2u\u003csub\u003ek\u003c/sub\u003e.u\u003csub\u003ek\u003c/sub\u003e\u003csup\u003et\u003c/sup\u003e\n\u003c/pre\u003e\nwe use \u003csub\u003ek\u003c/sub\u003e non-unit vectors such that:\n\u003cpre\u003e\nH\u003csub\u003ek\u003c/sub\u003e \u003d I - beta\u003csub\u003ek\u003c/sub\u003ev\u003csub\u003ek\u003c/sub\u003e.v\u003csub\u003ek\u003c/sub\u003e\u003csup\u003et\u003c/sup\u003e\n\u003c/pre\u003e\nwhere v\u003csub\u003ek\u003c/sub\u003e \u003d a\u003csub\u003ek\u003c/sub\u003e - alpha\u003csub\u003ek\u003c/sub\u003e e\u003csub\u003ek\u003c/sub\u003e.\nThe beta\u003csub\u003ek\u003c/sub\u003e coefficients are provided upon exit as recomputing\nthem from the v\u003csub\u003ek\u003c/sub\u003e vectors would be costly.\u003c/p\u003e\n\u003cp\u003eThis decomposition handles rank deficient cases since the tranformations\nare performed in non-increasing columns norms order thanks to columns\npivoting. The diagonal elements of the R matrix are therefore also in\nnon-increasing absolute values order.\u003c/p\u003e\n\n@exception OptimizationException if the decomposition cannot be performed\n",
          "diff": "@@ -1,56 +1,53 @@\n private void qrDecomposition() throws OptimizationException {\n     for (int k \u003d 0; k \u003c cols; ++k) {\n         permutation[k] \u003d k;\n         double norm2 \u003d 0;\n-        for (int index \u003d k; index \u003c jacobian.length; index +\u003d cols) {\n-            double akk \u003d jacobian[index];\n+        for (int i \u003d 0; i \u003c jacobian.length; ++i) {\n+            double akk \u003d jacobian[i][k];\n             norm2 +\u003d akk * akk;\n         }\n         jacNorm[k] \u003d Math.sqrt(norm2);\n     }\n     for (int k \u003d 0; k \u003c cols; ++k) {\n         int nextColumn \u003d -1;\n         double ak2 \u003d Double.NEGATIVE_INFINITY;\n         for (int i \u003d k; i \u003c cols; ++i) {\n             double norm2 \u003d 0;\n-            int iDiag \u003d k * cols + permutation[i];\n-            for (int index \u003d iDiag; index \u003c jacobian.length; index +\u003d cols) {\n-                double aki \u003d jacobian[index];\n+            for (int j \u003d k; j \u003c jacobian.length; ++j) {\n+                double aki \u003d jacobian[j][permutation[i]];\n                 norm2 +\u003d aki * aki;\n             }\n             if (Double.isInfinite(norm2) || Double.isNaN(norm2)) {\n                 throw new OptimizationException(\"unable to perform Q.R decomposition on the {0}x{1} jacobian matrix\", rows, cols);\n             }\n             if (norm2 \u003e ak2) {\n                 nextColumn \u003d i;\n                 ak2 \u003d norm2;\n             }\n         }\n         if (ak2 \u003d\u003d 0) {\n             rank \u003d k;\n             return;\n         }\n         int pk \u003d permutation[nextColumn];\n         permutation[nextColumn] \u003d permutation[k];\n         permutation[k] \u003d pk;\n-        int kDiag \u003d k * cols + pk;\n-        double akk \u003d jacobian[kDiag];\n+        double akk \u003d jacobian[k][pk];\n         double alpha \u003d (akk \u003e 0) ? -Math.sqrt(ak2) : Math.sqrt(ak2);\n         double betak \u003d 1.0 / (ak2 - akk * alpha);\n         beta[pk] \u003d betak;\n         diagR[pk] \u003d alpha;\n-        jacobian[kDiag] -\u003d alpha;\n+        jacobian[k][pk] -\u003d alpha;\n         for (int dk \u003d cols - 1 - k; dk \u003e 0; --dk) {\n-            int dkp \u003d permutation[k + dk] - pk;\n             double gamma \u003d 0;\n-            for (int index \u003d kDiag; index \u003c jacobian.length; index +\u003d cols) {\n-                gamma +\u003d jacobian[index] * jacobian[index + dkp];\n+            for (int j \u003d k; j \u003c jacobian.length; ++j) {\n+                gamma +\u003d jacobian[j][pk] * jacobian[j][permutation[k + dk]];\n             }\n             gamma *\u003d betak;\n-            for (int index \u003d kDiag; index \u003c jacobian.length; index +\u003d cols) {\n-                jacobian[index + dkp] -\u003d gamma * jacobian[index];\n+            for (int j \u003d k; j \u003c jacobian.length; ++j) {\n+                jacobian[j][permutation[k + dk]] -\u003d gamma * jacobian[j][pk];\n             }\n         }\n     }\n     rank \u003d solvedCols;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldPath": "src/java/org/apache/commons/math/optimization/general/LevenbergMarquardtEstimator.java",
            "newPath": "src/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java",
            "oldMethodName": "qrDecomposition",
            "newMethodName": "qrDecomposition"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "adapted old Levenberg-Marquardt estimator to new top level optimizers API\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@754727 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "3/15/09, 12:11 PM",
          "commitName": "8541f303370cec9a25f2b32b3d660b3f188913f0",
          "commitAuthor": "Luc Maisonobe",
          "commitDateOld": "3/14/09, 10:38 AM",
          "commitNameOld": "8cb418e7fa50aba9977fe073aec66ad3f6e4f07c",
          "commitAuthorOld": "Luc Maisonobe",
          "daysBetweenCommits": 1.06,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "private void qrDecomposition() throws OptimizationException {\n    for (int k \u003d 0; k \u003c cols; ++k) {\n        permutation[k] \u003d k;\n        double norm2 \u003d 0;\n        for (int i \u003d 0; i \u003c jacobian.length; ++i) {\n            double akk \u003d jacobian[i][k];\n            norm2 +\u003d akk * akk;\n        }\n        jacNorm[k] \u003d Math.sqrt(norm2);\n    }\n    for (int k \u003d 0; k \u003c cols; ++k) {\n        int nextColumn \u003d -1;\n        double ak2 \u003d Double.NEGATIVE_INFINITY;\n        for (int i \u003d k; i \u003c cols; ++i) {\n            double norm2 \u003d 0;\n            for (int j \u003d k; j \u003c jacobian.length; ++j) {\n                double aki \u003d jacobian[j][permutation[i]];\n                norm2 +\u003d aki * aki;\n            }\n            if (Double.isInfinite(norm2) || Double.isNaN(norm2)) {\n                throw new OptimizationException(\"unable to perform Q.R decomposition on the {0}x{1} jacobian matrix\", rows, cols);\n            }\n            if (norm2 \u003e ak2) {\n                nextColumn \u003d i;\n                ak2 \u003d norm2;\n            }\n        }\n        if (ak2 \u003d\u003d 0) {\n            rank \u003d k;\n            return;\n        }\n        int pk \u003d permutation[nextColumn];\n        permutation[nextColumn] \u003d permutation[k];\n        permutation[k] \u003d pk;\n        double akk \u003d jacobian[k][pk];\n        double alpha \u003d (akk \u003e 0) ? -Math.sqrt(ak2) : Math.sqrt(ak2);\n        double betak \u003d 1.0 / (ak2 - akk * alpha);\n        beta[pk] \u003d betak;\n        diagR[pk] \u003d alpha;\n        jacobian[k][pk] -\u003d alpha;\n        for (int dk \u003d cols - 1 - k; dk \u003e 0; --dk) {\n            double gamma \u003d 0;\n            for (int j \u003d k; j \u003c jacobian.length; ++j) {\n                gamma +\u003d jacobian[j][pk] * jacobian[j][permutation[k + dk]];\n            }\n            gamma *\u003d betak;\n            for (int j \u003d k; j \u003c jacobian.length; ++j) {\n                jacobian[j][permutation[k + dk]] -\u003d gamma * jacobian[j][pk];\n            }\n        }\n    }\n    rank \u003d solvedCols;\n}",
          "path": "src/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java",
          "functionStartLine": 748,
          "functionName": "qrDecomposition",
          "functionAnnotation": "",
          "functionDoc": "Decompose a matrix A as A.P \u003d Q.R using Householder transforms.\n\u003cp\u003eAs suggested in the P. Lascaux and R. Theodor book\n\u003ci\u003eAnalyse num\u0026eacute;rique matricielle appliqu\u0026eacute;e \u0026agrave;\nl\u0027art de l\u0027ing\u0026eacute;nieur\u003c/i\u003e (Masson, 1986), instead of representing\nthe Householder transforms with u\u003csub\u003ek\u003c/sub\u003e unit vectors such that:\n\u003cpre\u003e\nH\u003csub\u003ek\u003c/sub\u003e \u003d I - 2u\u003csub\u003ek\u003c/sub\u003e.u\u003csub\u003ek\u003c/sub\u003e\u003csup\u003et\u003c/sup\u003e\n\u003c/pre\u003e\nwe use \u003csub\u003ek\u003c/sub\u003e non-unit vectors such that:\n\u003cpre\u003e\nH\u003csub\u003ek\u003c/sub\u003e \u003d I - beta\u003csub\u003ek\u003c/sub\u003ev\u003csub\u003ek\u003c/sub\u003e.v\u003csub\u003ek\u003c/sub\u003e\u003csup\u003et\u003c/sup\u003e\n\u003c/pre\u003e\nwhere v\u003csub\u003ek\u003c/sub\u003e \u003d a\u003csub\u003ek\u003c/sub\u003e - alpha\u003csub\u003ek\u003c/sub\u003e e\u003csub\u003ek\u003c/sub\u003e.\nThe beta\u003csub\u003ek\u003c/sub\u003e coefficients are provided upon exit as recomputing\nthem from the v\u003csub\u003ek\u003c/sub\u003e vectors would be costly.\u003c/p\u003e\n\u003cp\u003eThis decomposition handles rank deficient cases since the tranformations\nare performed in non-increasing columns norms order thanks to columns\npivoting. The diagonal elements of the R matrix are therefore also in\nnon-increasing absolute values order.\u003c/p\u003e\n\n@exception OptimizationException if the decomposition cannot be performed\n",
          "diff": "@@ -1,56 +1,53 @@\n private void qrDecomposition() throws OptimizationException {\n     for (int k \u003d 0; k \u003c cols; ++k) {\n         permutation[k] \u003d k;\n         double norm2 \u003d 0;\n-        for (int index \u003d k; index \u003c jacobian.length; index +\u003d cols) {\n-            double akk \u003d jacobian[index];\n+        for (int i \u003d 0; i \u003c jacobian.length; ++i) {\n+            double akk \u003d jacobian[i][k];\n             norm2 +\u003d akk * akk;\n         }\n         jacNorm[k] \u003d Math.sqrt(norm2);\n     }\n     for (int k \u003d 0; k \u003c cols; ++k) {\n         int nextColumn \u003d -1;\n         double ak2 \u003d Double.NEGATIVE_INFINITY;\n         for (int i \u003d k; i \u003c cols; ++i) {\n             double norm2 \u003d 0;\n-            int iDiag \u003d k * cols + permutation[i];\n-            for (int index \u003d iDiag; index \u003c jacobian.length; index +\u003d cols) {\n-                double aki \u003d jacobian[index];\n+            for (int j \u003d k; j \u003c jacobian.length; ++j) {\n+                double aki \u003d jacobian[j][permutation[i]];\n                 norm2 +\u003d aki * aki;\n             }\n             if (Double.isInfinite(norm2) || Double.isNaN(norm2)) {\n                 throw new OptimizationException(\"unable to perform Q.R decomposition on the {0}x{1} jacobian matrix\", rows, cols);\n             }\n             if (norm2 \u003e ak2) {\n                 nextColumn \u003d i;\n                 ak2 \u003d norm2;\n             }\n         }\n         if (ak2 \u003d\u003d 0) {\n             rank \u003d k;\n             return;\n         }\n         int pk \u003d permutation[nextColumn];\n         permutation[nextColumn] \u003d permutation[k];\n         permutation[k] \u003d pk;\n-        int kDiag \u003d k * cols + pk;\n-        double akk \u003d jacobian[kDiag];\n+        double akk \u003d jacobian[k][pk];\n         double alpha \u003d (akk \u003e 0) ? -Math.sqrt(ak2) : Math.sqrt(ak2);\n         double betak \u003d 1.0 / (ak2 - akk * alpha);\n         beta[pk] \u003d betak;\n         diagR[pk] \u003d alpha;\n-        jacobian[kDiag] -\u003d alpha;\n+        jacobian[k][pk] -\u003d alpha;\n         for (int dk \u003d cols - 1 - k; dk \u003e 0; --dk) {\n-            int dkp \u003d permutation[k + dk] - pk;\n             double gamma \u003d 0;\n-            for (int index \u003d kDiag; index \u003c jacobian.length; index +\u003d cols) {\n-                gamma +\u003d jacobian[index] * jacobian[index + dkp];\n+            for (int j \u003d k; j \u003c jacobian.length; ++j) {\n+                gamma +\u003d jacobian[j][pk] * jacobian[j][permutation[k + dk]];\n             }\n             gamma *\u003d betak;\n-            for (int index \u003d kDiag; index \u003c jacobian.length; index +\u003d cols) {\n-                jacobian[index + dkp] -\u003d gamma * jacobian[index];\n+            for (int j \u003d k; j \u003c jacobian.length; ++j) {\n+                jacobian[j][permutation[k + dk]] -\u003d gamma * jacobian[j][pk];\n             }\n         }\n     }\n     rank \u003d solvedCols;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "fbe565694aa2721d4a8538eb053171cc8ecfde47": {
      "type": "Ymultichange(Yfilerename,Yexceptionschange,Ybodychange,Ydocchange)",
      "commitMessage": "started refactoring of optimization framework:\n - created subpackages optimization.direct, optimization.general,\n   optimization.linear (currently empty) and optimization.univariate\n - removed packages analysis.minimization and estimation\n - renamed all Cost-related interfaces/classes into Objective\n   (this allows both minimization and maximization)\n - added a few new general interfaces\n\nThis work is not complete yet. The direct and general packages classes\nare very close to the former design, they have almost not been changed\nstructurally.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@748274 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2/26/09, 11:17 AM",
      "commitName": "fbe565694aa2721d4a8538eb053171cc8ecfde47",
      "commitAuthor": "Luc Maisonobe",
      "subchanges": [
        {
          "type": "Yfilerename",
          "commitMessage": "started refactoring of optimization framework:\n - created subpackages optimization.direct, optimization.general,\n   optimization.linear (currently empty) and optimization.univariate\n - removed packages analysis.minimization and estimation\n - renamed all Cost-related interfaces/classes into Objective\n   (this allows both minimization and maximization)\n - added a few new general interfaces\n\nThis work is not complete yet. The direct and general packages classes\nare very close to the former design, they have almost not been changed\nstructurally.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@748274 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2/26/09, 11:17 AM",
          "commitName": "fbe565694aa2721d4a8538eb053171cc8ecfde47",
          "commitAuthor": "Luc Maisonobe",
          "commitDateOld": "2/24/09, 7:32 PM",
          "commitNameOld": "911f0fe11146590554ec11d1277d6e2ba55bd7e9",
          "commitAuthorOld": "William Barker",
          "daysBetweenCommits": 1.66,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "private void qrDecomposition() throws OptimizationException {\n    for (int k \u003d 0; k \u003c cols; ++k) {\n        permutation[k] \u003d k;\n        double norm2 \u003d 0;\n        for (int index \u003d k; index \u003c jacobian.length; index +\u003d cols) {\n            double akk \u003d jacobian[index];\n            norm2 +\u003d akk * akk;\n        }\n        jacNorm[k] \u003d Math.sqrt(norm2);\n    }\n    for (int k \u003d 0; k \u003c cols; ++k) {\n        int nextColumn \u003d -1;\n        double ak2 \u003d Double.NEGATIVE_INFINITY;\n        for (int i \u003d k; i \u003c cols; ++i) {\n            double norm2 \u003d 0;\n            int iDiag \u003d k * cols + permutation[i];\n            for (int index \u003d iDiag; index \u003c jacobian.length; index +\u003d cols) {\n                double aki \u003d jacobian[index];\n                norm2 +\u003d aki * aki;\n            }\n            if (Double.isInfinite(norm2) || Double.isNaN(norm2)) {\n                throw new OptimizationException(\"unable to perform Q.R decomposition on the {0}x{1} jacobian matrix\", rows, cols);\n            }\n            if (norm2 \u003e ak2) {\n                nextColumn \u003d i;\n                ak2 \u003d norm2;\n            }\n        }\n        if (ak2 \u003d\u003d 0) {\n            rank \u003d k;\n            return;\n        }\n        int pk \u003d permutation[nextColumn];\n        permutation[nextColumn] \u003d permutation[k];\n        permutation[k] \u003d pk;\n        int kDiag \u003d k * cols + pk;\n        double akk \u003d jacobian[kDiag];\n        double alpha \u003d (akk \u003e 0) ? -Math.sqrt(ak2) : Math.sqrt(ak2);\n        double betak \u003d 1.0 / (ak2 - akk * alpha);\n        beta[pk] \u003d betak;\n        diagR[pk] \u003d alpha;\n        jacobian[kDiag] -\u003d alpha;\n        for (int dk \u003d cols - 1 - k; dk \u003e 0; --dk) {\n            int dkp \u003d permutation[k + dk] - pk;\n            double gamma \u003d 0;\n            for (int index \u003d kDiag; index \u003c jacobian.length; index +\u003d cols) {\n                gamma +\u003d jacobian[index] * jacobian[index + dkp];\n            }\n            gamma *\u003d betak;\n            for (int index \u003d kDiag; index \u003c jacobian.length; index +\u003d cols) {\n                jacobian[index + dkp] -\u003d gamma * jacobian[index];\n            }\n        }\n    }\n    rank \u003d solvedCols;\n}",
          "path": "src/java/org/apache/commons/math/optimization/general/LevenbergMarquardtEstimator.java",
          "functionStartLine": 739,
          "functionName": "qrDecomposition",
          "functionAnnotation": "",
          "functionDoc": "Decompose a matrix A as A.P \u003d Q.R using Householder transforms.\n\u003cp\u003eAs suggested in the P. Lascaux and R. Theodor book\n\u003ci\u003eAnalyse num\u0026eacute;rique matricielle appliqu\u0026eacute;e \u0026agrave;\nl\u0027art de l\u0027ing\u0026eacute;nieur\u003c/i\u003e (Masson, 1986), instead of representing\nthe Householder transforms with u\u003csub\u003ek\u003c/sub\u003e unit vectors such that:\n\u003cpre\u003e\nH\u003csub\u003ek\u003c/sub\u003e \u003d I - 2u\u003csub\u003ek\u003c/sub\u003e.u\u003csub\u003ek\u003c/sub\u003e\u003csup\u003et\u003c/sup\u003e\n\u003c/pre\u003e\nwe use \u003csub\u003ek\u003c/sub\u003e non-unit vectors such that:\n\u003cpre\u003e\nH\u003csub\u003ek\u003c/sub\u003e \u003d I - beta\u003csub\u003ek\u003c/sub\u003ev\u003csub\u003ek\u003c/sub\u003e.v\u003csub\u003ek\u003c/sub\u003e\u003csup\u003et\u003c/sup\u003e\n\u003c/pre\u003e\nwhere v\u003csub\u003ek\u003c/sub\u003e \u003d a\u003csub\u003ek\u003c/sub\u003e - alpha\u003csub\u003ek\u003c/sub\u003e e\u003csub\u003ek\u003c/sub\u003e.\nThe beta\u003csub\u003ek\u003c/sub\u003e coefficients are provided upon exit as recomputing\nthem from the v\u003csub\u003ek\u003c/sub\u003e vectors would be costly.\u003c/p\u003e\n\u003cp\u003eThis decomposition handles rank deficient cases since the tranformations\nare performed in non-increasing columns norms order thanks to columns\npivoting. The diagonal elements of the R matrix are therefore also in\nnon-increasing absolute values order.\u003c/p\u003e\n\n@exception OptimizationException if the decomposition cannot be performed\n",
          "diff": "@@ -1,56 +1,56 @@\n-private void qrDecomposition() throws EstimationException {\n+private void qrDecomposition() throws OptimizationException {\n     for (int k \u003d 0; k \u003c cols; ++k) {\n         permutation[k] \u003d k;\n         double norm2 \u003d 0;\n         for (int index \u003d k; index \u003c jacobian.length; index +\u003d cols) {\n             double akk \u003d jacobian[index];\n             norm2 +\u003d akk * akk;\n         }\n         jacNorm[k] \u003d Math.sqrt(norm2);\n     }\n     for (int k \u003d 0; k \u003c cols; ++k) {\n         int nextColumn \u003d -1;\n         double ak2 \u003d Double.NEGATIVE_INFINITY;\n         for (int i \u003d k; i \u003c cols; ++i) {\n             double norm2 \u003d 0;\n             int iDiag \u003d k * cols + permutation[i];\n             for (int index \u003d iDiag; index \u003c jacobian.length; index +\u003d cols) {\n                 double aki \u003d jacobian[index];\n                 norm2 +\u003d aki * aki;\n             }\n             if (Double.isInfinite(norm2) || Double.isNaN(norm2)) {\n-                throw new EstimationException(\"unable to perform Q.R decomposition on the {0}x{1} jacobian matrix\", rows, cols);\n+                throw new OptimizationException(\"unable to perform Q.R decomposition on the {0}x{1} jacobian matrix\", rows, cols);\n             }\n             if (norm2 \u003e ak2) {\n                 nextColumn \u003d i;\n                 ak2 \u003d norm2;\n             }\n         }\n         if (ak2 \u003d\u003d 0) {\n             rank \u003d k;\n             return;\n         }\n         int pk \u003d permutation[nextColumn];\n         permutation[nextColumn] \u003d permutation[k];\n         permutation[k] \u003d pk;\n         int kDiag \u003d k * cols + pk;\n         double akk \u003d jacobian[kDiag];\n         double alpha \u003d (akk \u003e 0) ? -Math.sqrt(ak2) : Math.sqrt(ak2);\n         double betak \u003d 1.0 / (ak2 - akk * alpha);\n         beta[pk] \u003d betak;\n         diagR[pk] \u003d alpha;\n         jacobian[kDiag] -\u003d alpha;\n         for (int dk \u003d cols - 1 - k; dk \u003e 0; --dk) {\n             int dkp \u003d permutation[k + dk] - pk;\n             double gamma \u003d 0;\n             for (int index \u003d kDiag; index \u003c jacobian.length; index +\u003d cols) {\n                 gamma +\u003d jacobian[index] * jacobian[index + dkp];\n             }\n             gamma *\u003d betak;\n             for (int index \u003d kDiag; index \u003c jacobian.length; index +\u003d cols) {\n                 jacobian[index + dkp] -\u003d gamma * jacobian[index];\n             }\n         }\n     }\n     rank \u003d solvedCols;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldPath": "src/java/org/apache/commons/math/estimation/LevenbergMarquardtEstimator.java",
            "newPath": "src/java/org/apache/commons/math/optimization/general/LevenbergMarquardtEstimator.java"
          }
        },
        {
          "type": "Yexceptionschange",
          "commitMessage": "started refactoring of optimization framework:\n - created subpackages optimization.direct, optimization.general,\n   optimization.linear (currently empty) and optimization.univariate\n - removed packages analysis.minimization and estimation\n - renamed all Cost-related interfaces/classes into Objective\n   (this allows both minimization and maximization)\n - added a few new general interfaces\n\nThis work is not complete yet. The direct and general packages classes\nare very close to the former design, they have almost not been changed\nstructurally.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@748274 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2/26/09, 11:17 AM",
          "commitName": "fbe565694aa2721d4a8538eb053171cc8ecfde47",
          "commitAuthor": "Luc Maisonobe",
          "commitDateOld": "2/24/09, 7:32 PM",
          "commitNameOld": "911f0fe11146590554ec11d1277d6e2ba55bd7e9",
          "commitAuthorOld": "William Barker",
          "daysBetweenCommits": 1.66,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "private void qrDecomposition() throws OptimizationException {\n    for (int k \u003d 0; k \u003c cols; ++k) {\n        permutation[k] \u003d k;\n        double norm2 \u003d 0;\n        for (int index \u003d k; index \u003c jacobian.length; index +\u003d cols) {\n            double akk \u003d jacobian[index];\n            norm2 +\u003d akk * akk;\n        }\n        jacNorm[k] \u003d Math.sqrt(norm2);\n    }\n    for (int k \u003d 0; k \u003c cols; ++k) {\n        int nextColumn \u003d -1;\n        double ak2 \u003d Double.NEGATIVE_INFINITY;\n        for (int i \u003d k; i \u003c cols; ++i) {\n            double norm2 \u003d 0;\n            int iDiag \u003d k * cols + permutation[i];\n            for (int index \u003d iDiag; index \u003c jacobian.length; index +\u003d cols) {\n                double aki \u003d jacobian[index];\n                norm2 +\u003d aki * aki;\n            }\n            if (Double.isInfinite(norm2) || Double.isNaN(norm2)) {\n                throw new OptimizationException(\"unable to perform Q.R decomposition on the {0}x{1} jacobian matrix\", rows, cols);\n            }\n            if (norm2 \u003e ak2) {\n                nextColumn \u003d i;\n                ak2 \u003d norm2;\n            }\n        }\n        if (ak2 \u003d\u003d 0) {\n            rank \u003d k;\n            return;\n        }\n        int pk \u003d permutation[nextColumn];\n        permutation[nextColumn] \u003d permutation[k];\n        permutation[k] \u003d pk;\n        int kDiag \u003d k * cols + pk;\n        double akk \u003d jacobian[kDiag];\n        double alpha \u003d (akk \u003e 0) ? -Math.sqrt(ak2) : Math.sqrt(ak2);\n        double betak \u003d 1.0 / (ak2 - akk * alpha);\n        beta[pk] \u003d betak;\n        diagR[pk] \u003d alpha;\n        jacobian[kDiag] -\u003d alpha;\n        for (int dk \u003d cols - 1 - k; dk \u003e 0; --dk) {\n            int dkp \u003d permutation[k + dk] - pk;\n            double gamma \u003d 0;\n            for (int index \u003d kDiag; index \u003c jacobian.length; index +\u003d cols) {\n                gamma +\u003d jacobian[index] * jacobian[index + dkp];\n            }\n            gamma *\u003d betak;\n            for (int index \u003d kDiag; index \u003c jacobian.length; index +\u003d cols) {\n                jacobian[index + dkp] -\u003d gamma * jacobian[index];\n            }\n        }\n    }\n    rank \u003d solvedCols;\n}",
          "path": "src/java/org/apache/commons/math/optimization/general/LevenbergMarquardtEstimator.java",
          "functionStartLine": 739,
          "functionName": "qrDecomposition",
          "functionAnnotation": "",
          "functionDoc": "Decompose a matrix A as A.P \u003d Q.R using Householder transforms.\n\u003cp\u003eAs suggested in the P. Lascaux and R. Theodor book\n\u003ci\u003eAnalyse num\u0026eacute;rique matricielle appliqu\u0026eacute;e \u0026agrave;\nl\u0027art de l\u0027ing\u0026eacute;nieur\u003c/i\u003e (Masson, 1986), instead of representing\nthe Householder transforms with u\u003csub\u003ek\u003c/sub\u003e unit vectors such that:\n\u003cpre\u003e\nH\u003csub\u003ek\u003c/sub\u003e \u003d I - 2u\u003csub\u003ek\u003c/sub\u003e.u\u003csub\u003ek\u003c/sub\u003e\u003csup\u003et\u003c/sup\u003e\n\u003c/pre\u003e\nwe use \u003csub\u003ek\u003c/sub\u003e non-unit vectors such that:\n\u003cpre\u003e\nH\u003csub\u003ek\u003c/sub\u003e \u003d I - beta\u003csub\u003ek\u003c/sub\u003ev\u003csub\u003ek\u003c/sub\u003e.v\u003csub\u003ek\u003c/sub\u003e\u003csup\u003et\u003c/sup\u003e\n\u003c/pre\u003e\nwhere v\u003csub\u003ek\u003c/sub\u003e \u003d a\u003csub\u003ek\u003c/sub\u003e - alpha\u003csub\u003ek\u003c/sub\u003e e\u003csub\u003ek\u003c/sub\u003e.\nThe beta\u003csub\u003ek\u003c/sub\u003e coefficients are provided upon exit as recomputing\nthem from the v\u003csub\u003ek\u003c/sub\u003e vectors would be costly.\u003c/p\u003e\n\u003cp\u003eThis decomposition handles rank deficient cases since the tranformations\nare performed in non-increasing columns norms order thanks to columns\npivoting. The diagonal elements of the R matrix are therefore also in\nnon-increasing absolute values order.\u003c/p\u003e\n\n@exception OptimizationException if the decomposition cannot be performed\n",
          "diff": "@@ -1,56 +1,56 @@\n-private void qrDecomposition() throws EstimationException {\n+private void qrDecomposition() throws OptimizationException {\n     for (int k \u003d 0; k \u003c cols; ++k) {\n         permutation[k] \u003d k;\n         double norm2 \u003d 0;\n         for (int index \u003d k; index \u003c jacobian.length; index +\u003d cols) {\n             double akk \u003d jacobian[index];\n             norm2 +\u003d akk * akk;\n         }\n         jacNorm[k] \u003d Math.sqrt(norm2);\n     }\n     for (int k \u003d 0; k \u003c cols; ++k) {\n         int nextColumn \u003d -1;\n         double ak2 \u003d Double.NEGATIVE_INFINITY;\n         for (int i \u003d k; i \u003c cols; ++i) {\n             double norm2 \u003d 0;\n             int iDiag \u003d k * cols + permutation[i];\n             for (int index \u003d iDiag; index \u003c jacobian.length; index +\u003d cols) {\n                 double aki \u003d jacobian[index];\n                 norm2 +\u003d aki * aki;\n             }\n             if (Double.isInfinite(norm2) || Double.isNaN(norm2)) {\n-                throw new EstimationException(\"unable to perform Q.R decomposition on the {0}x{1} jacobian matrix\", rows, cols);\n+                throw new OptimizationException(\"unable to perform Q.R decomposition on the {0}x{1} jacobian matrix\", rows, cols);\n             }\n             if (norm2 \u003e ak2) {\n                 nextColumn \u003d i;\n                 ak2 \u003d norm2;\n             }\n         }\n         if (ak2 \u003d\u003d 0) {\n             rank \u003d k;\n             return;\n         }\n         int pk \u003d permutation[nextColumn];\n         permutation[nextColumn] \u003d permutation[k];\n         permutation[k] \u003d pk;\n         int kDiag \u003d k * cols + pk;\n         double akk \u003d jacobian[kDiag];\n         double alpha \u003d (akk \u003e 0) ? -Math.sqrt(ak2) : Math.sqrt(ak2);\n         double betak \u003d 1.0 / (ak2 - akk * alpha);\n         beta[pk] \u003d betak;\n         diagR[pk] \u003d alpha;\n         jacobian[kDiag] -\u003d alpha;\n         for (int dk \u003d cols - 1 - k; dk \u003e 0; --dk) {\n             int dkp \u003d permutation[k + dk] - pk;\n             double gamma \u003d 0;\n             for (int index \u003d kDiag; index \u003c jacobian.length; index +\u003d cols) {\n                 gamma +\u003d jacobian[index] * jacobian[index + dkp];\n             }\n             gamma *\u003d betak;\n             for (int index \u003d kDiag; index \u003c jacobian.length; index +\u003d cols) {\n                 jacobian[index + dkp] -\u003d gamma * jacobian[index];\n             }\n         }\n     }\n     rank \u003d solvedCols;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[EstimationException]",
            "newValue": "[OptimizationException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "started refactoring of optimization framework:\n - created subpackages optimization.direct, optimization.general,\n   optimization.linear (currently empty) and optimization.univariate\n - removed packages analysis.minimization and estimation\n - renamed all Cost-related interfaces/classes into Objective\n   (this allows both minimization and maximization)\n - added a few new general interfaces\n\nThis work is not complete yet. The direct and general packages classes\nare very close to the former design, they have almost not been changed\nstructurally.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@748274 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2/26/09, 11:17 AM",
          "commitName": "fbe565694aa2721d4a8538eb053171cc8ecfde47",
          "commitAuthor": "Luc Maisonobe",
          "commitDateOld": "2/24/09, 7:32 PM",
          "commitNameOld": "911f0fe11146590554ec11d1277d6e2ba55bd7e9",
          "commitAuthorOld": "William Barker",
          "daysBetweenCommits": 1.66,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "private void qrDecomposition() throws OptimizationException {\n    for (int k \u003d 0; k \u003c cols; ++k) {\n        permutation[k] \u003d k;\n        double norm2 \u003d 0;\n        for (int index \u003d k; index \u003c jacobian.length; index +\u003d cols) {\n            double akk \u003d jacobian[index];\n            norm2 +\u003d akk * akk;\n        }\n        jacNorm[k] \u003d Math.sqrt(norm2);\n    }\n    for (int k \u003d 0; k \u003c cols; ++k) {\n        int nextColumn \u003d -1;\n        double ak2 \u003d Double.NEGATIVE_INFINITY;\n        for (int i \u003d k; i \u003c cols; ++i) {\n            double norm2 \u003d 0;\n            int iDiag \u003d k * cols + permutation[i];\n            for (int index \u003d iDiag; index \u003c jacobian.length; index +\u003d cols) {\n                double aki \u003d jacobian[index];\n                norm2 +\u003d aki * aki;\n            }\n            if (Double.isInfinite(norm2) || Double.isNaN(norm2)) {\n                throw new OptimizationException(\"unable to perform Q.R decomposition on the {0}x{1} jacobian matrix\", rows, cols);\n            }\n            if (norm2 \u003e ak2) {\n                nextColumn \u003d i;\n                ak2 \u003d norm2;\n            }\n        }\n        if (ak2 \u003d\u003d 0) {\n            rank \u003d k;\n            return;\n        }\n        int pk \u003d permutation[nextColumn];\n        permutation[nextColumn] \u003d permutation[k];\n        permutation[k] \u003d pk;\n        int kDiag \u003d k * cols + pk;\n        double akk \u003d jacobian[kDiag];\n        double alpha \u003d (akk \u003e 0) ? -Math.sqrt(ak2) : Math.sqrt(ak2);\n        double betak \u003d 1.0 / (ak2 - akk * alpha);\n        beta[pk] \u003d betak;\n        diagR[pk] \u003d alpha;\n        jacobian[kDiag] -\u003d alpha;\n        for (int dk \u003d cols - 1 - k; dk \u003e 0; --dk) {\n            int dkp \u003d permutation[k + dk] - pk;\n            double gamma \u003d 0;\n            for (int index \u003d kDiag; index \u003c jacobian.length; index +\u003d cols) {\n                gamma +\u003d jacobian[index] * jacobian[index + dkp];\n            }\n            gamma *\u003d betak;\n            for (int index \u003d kDiag; index \u003c jacobian.length; index +\u003d cols) {\n                jacobian[index + dkp] -\u003d gamma * jacobian[index];\n            }\n        }\n    }\n    rank \u003d solvedCols;\n}",
          "path": "src/java/org/apache/commons/math/optimization/general/LevenbergMarquardtEstimator.java",
          "functionStartLine": 739,
          "functionName": "qrDecomposition",
          "functionAnnotation": "",
          "functionDoc": "Decompose a matrix A as A.P \u003d Q.R using Householder transforms.\n\u003cp\u003eAs suggested in the P. Lascaux and R. Theodor book\n\u003ci\u003eAnalyse num\u0026eacute;rique matricielle appliqu\u0026eacute;e \u0026agrave;\nl\u0027art de l\u0027ing\u0026eacute;nieur\u003c/i\u003e (Masson, 1986), instead of representing\nthe Householder transforms with u\u003csub\u003ek\u003c/sub\u003e unit vectors such that:\n\u003cpre\u003e\nH\u003csub\u003ek\u003c/sub\u003e \u003d I - 2u\u003csub\u003ek\u003c/sub\u003e.u\u003csub\u003ek\u003c/sub\u003e\u003csup\u003et\u003c/sup\u003e\n\u003c/pre\u003e\nwe use \u003csub\u003ek\u003c/sub\u003e non-unit vectors such that:\n\u003cpre\u003e\nH\u003csub\u003ek\u003c/sub\u003e \u003d I - beta\u003csub\u003ek\u003c/sub\u003ev\u003csub\u003ek\u003c/sub\u003e.v\u003csub\u003ek\u003c/sub\u003e\u003csup\u003et\u003c/sup\u003e\n\u003c/pre\u003e\nwhere v\u003csub\u003ek\u003c/sub\u003e \u003d a\u003csub\u003ek\u003c/sub\u003e - alpha\u003csub\u003ek\u003c/sub\u003e e\u003csub\u003ek\u003c/sub\u003e.\nThe beta\u003csub\u003ek\u003c/sub\u003e coefficients are provided upon exit as recomputing\nthem from the v\u003csub\u003ek\u003c/sub\u003e vectors would be costly.\u003c/p\u003e\n\u003cp\u003eThis decomposition handles rank deficient cases since the tranformations\nare performed in non-increasing columns norms order thanks to columns\npivoting. The diagonal elements of the R matrix are therefore also in\nnon-increasing absolute values order.\u003c/p\u003e\n\n@exception OptimizationException if the decomposition cannot be performed\n",
          "diff": "@@ -1,56 +1,56 @@\n-private void qrDecomposition() throws EstimationException {\n+private void qrDecomposition() throws OptimizationException {\n     for (int k \u003d 0; k \u003c cols; ++k) {\n         permutation[k] \u003d k;\n         double norm2 \u003d 0;\n         for (int index \u003d k; index \u003c jacobian.length; index +\u003d cols) {\n             double akk \u003d jacobian[index];\n             norm2 +\u003d akk * akk;\n         }\n         jacNorm[k] \u003d Math.sqrt(norm2);\n     }\n     for (int k \u003d 0; k \u003c cols; ++k) {\n         int nextColumn \u003d -1;\n         double ak2 \u003d Double.NEGATIVE_INFINITY;\n         for (int i \u003d k; i \u003c cols; ++i) {\n             double norm2 \u003d 0;\n             int iDiag \u003d k * cols + permutation[i];\n             for (int index \u003d iDiag; index \u003c jacobian.length; index +\u003d cols) {\n                 double aki \u003d jacobian[index];\n                 norm2 +\u003d aki * aki;\n             }\n             if (Double.isInfinite(norm2) || Double.isNaN(norm2)) {\n-                throw new EstimationException(\"unable to perform Q.R decomposition on the {0}x{1} jacobian matrix\", rows, cols);\n+                throw new OptimizationException(\"unable to perform Q.R decomposition on the {0}x{1} jacobian matrix\", rows, cols);\n             }\n             if (norm2 \u003e ak2) {\n                 nextColumn \u003d i;\n                 ak2 \u003d norm2;\n             }\n         }\n         if (ak2 \u003d\u003d 0) {\n             rank \u003d k;\n             return;\n         }\n         int pk \u003d permutation[nextColumn];\n         permutation[nextColumn] \u003d permutation[k];\n         permutation[k] \u003d pk;\n         int kDiag \u003d k * cols + pk;\n         double akk \u003d jacobian[kDiag];\n         double alpha \u003d (akk \u003e 0) ? -Math.sqrt(ak2) : Math.sqrt(ak2);\n         double betak \u003d 1.0 / (ak2 - akk * alpha);\n         beta[pk] \u003d betak;\n         diagR[pk] \u003d alpha;\n         jacobian[kDiag] -\u003d alpha;\n         for (int dk \u003d cols - 1 - k; dk \u003e 0; --dk) {\n             int dkp \u003d permutation[k + dk] - pk;\n             double gamma \u003d 0;\n             for (int index \u003d kDiag; index \u003c jacobian.length; index +\u003d cols) {\n                 gamma +\u003d jacobian[index] * jacobian[index + dkp];\n             }\n             gamma *\u003d betak;\n             for (int index \u003d kDiag; index \u003c jacobian.length; index +\u003d cols) {\n                 jacobian[index + dkp] -\u003d gamma * jacobian[index];\n             }\n         }\n     }\n     rank \u003d solvedCols;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "started refactoring of optimization framework:\n - created subpackages optimization.direct, optimization.general,\n   optimization.linear (currently empty) and optimization.univariate\n - removed packages analysis.minimization and estimation\n - renamed all Cost-related interfaces/classes into Objective\n   (this allows both minimization and maximization)\n - added a few new general interfaces\n\nThis work is not complete yet. The direct and general packages classes\nare very close to the former design, they have almost not been changed\nstructurally.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@748274 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2/26/09, 11:17 AM",
          "commitName": "fbe565694aa2721d4a8538eb053171cc8ecfde47",
          "commitAuthor": "Luc Maisonobe",
          "commitDateOld": "2/24/09, 7:32 PM",
          "commitNameOld": "911f0fe11146590554ec11d1277d6e2ba55bd7e9",
          "commitAuthorOld": "William Barker",
          "daysBetweenCommits": 1.66,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "private void qrDecomposition() throws OptimizationException {\n    for (int k \u003d 0; k \u003c cols; ++k) {\n        permutation[k] \u003d k;\n        double norm2 \u003d 0;\n        for (int index \u003d k; index \u003c jacobian.length; index +\u003d cols) {\n            double akk \u003d jacobian[index];\n            norm2 +\u003d akk * akk;\n        }\n        jacNorm[k] \u003d Math.sqrt(norm2);\n    }\n    for (int k \u003d 0; k \u003c cols; ++k) {\n        int nextColumn \u003d -1;\n        double ak2 \u003d Double.NEGATIVE_INFINITY;\n        for (int i \u003d k; i \u003c cols; ++i) {\n            double norm2 \u003d 0;\n            int iDiag \u003d k * cols + permutation[i];\n            for (int index \u003d iDiag; index \u003c jacobian.length; index +\u003d cols) {\n                double aki \u003d jacobian[index];\n                norm2 +\u003d aki * aki;\n            }\n            if (Double.isInfinite(norm2) || Double.isNaN(norm2)) {\n                throw new OptimizationException(\"unable to perform Q.R decomposition on the {0}x{1} jacobian matrix\", rows, cols);\n            }\n            if (norm2 \u003e ak2) {\n                nextColumn \u003d i;\n                ak2 \u003d norm2;\n            }\n        }\n        if (ak2 \u003d\u003d 0) {\n            rank \u003d k;\n            return;\n        }\n        int pk \u003d permutation[nextColumn];\n        permutation[nextColumn] \u003d permutation[k];\n        permutation[k] \u003d pk;\n        int kDiag \u003d k * cols + pk;\n        double akk \u003d jacobian[kDiag];\n        double alpha \u003d (akk \u003e 0) ? -Math.sqrt(ak2) : Math.sqrt(ak2);\n        double betak \u003d 1.0 / (ak2 - akk * alpha);\n        beta[pk] \u003d betak;\n        diagR[pk] \u003d alpha;\n        jacobian[kDiag] -\u003d alpha;\n        for (int dk \u003d cols - 1 - k; dk \u003e 0; --dk) {\n            int dkp \u003d permutation[k + dk] - pk;\n            double gamma \u003d 0;\n            for (int index \u003d kDiag; index \u003c jacobian.length; index +\u003d cols) {\n                gamma +\u003d jacobian[index] * jacobian[index + dkp];\n            }\n            gamma *\u003d betak;\n            for (int index \u003d kDiag; index \u003c jacobian.length; index +\u003d cols) {\n                jacobian[index + dkp] -\u003d gamma * jacobian[index];\n            }\n        }\n    }\n    rank \u003d solvedCols;\n}",
          "path": "src/java/org/apache/commons/math/optimization/general/LevenbergMarquardtEstimator.java",
          "functionStartLine": 739,
          "functionName": "qrDecomposition",
          "functionAnnotation": "",
          "functionDoc": "Decompose a matrix A as A.P \u003d Q.R using Householder transforms.\n\u003cp\u003eAs suggested in the P. Lascaux and R. Theodor book\n\u003ci\u003eAnalyse num\u0026eacute;rique matricielle appliqu\u0026eacute;e \u0026agrave;\nl\u0027art de l\u0027ing\u0026eacute;nieur\u003c/i\u003e (Masson, 1986), instead of representing\nthe Householder transforms with u\u003csub\u003ek\u003c/sub\u003e unit vectors such that:\n\u003cpre\u003e\nH\u003csub\u003ek\u003c/sub\u003e \u003d I - 2u\u003csub\u003ek\u003c/sub\u003e.u\u003csub\u003ek\u003c/sub\u003e\u003csup\u003et\u003c/sup\u003e\n\u003c/pre\u003e\nwe use \u003csub\u003ek\u003c/sub\u003e non-unit vectors such that:\n\u003cpre\u003e\nH\u003csub\u003ek\u003c/sub\u003e \u003d I - beta\u003csub\u003ek\u003c/sub\u003ev\u003csub\u003ek\u003c/sub\u003e.v\u003csub\u003ek\u003c/sub\u003e\u003csup\u003et\u003c/sup\u003e\n\u003c/pre\u003e\nwhere v\u003csub\u003ek\u003c/sub\u003e \u003d a\u003csub\u003ek\u003c/sub\u003e - alpha\u003csub\u003ek\u003c/sub\u003e e\u003csub\u003ek\u003c/sub\u003e.\nThe beta\u003csub\u003ek\u003c/sub\u003e coefficients are provided upon exit as recomputing\nthem from the v\u003csub\u003ek\u003c/sub\u003e vectors would be costly.\u003c/p\u003e\n\u003cp\u003eThis decomposition handles rank deficient cases since the tranformations\nare performed in non-increasing columns norms order thanks to columns\npivoting. The diagonal elements of the R matrix are therefore also in\nnon-increasing absolute values order.\u003c/p\u003e\n\n@exception OptimizationException if the decomposition cannot be performed\n",
          "diff": "@@ -1,56 +1,56 @@\n-private void qrDecomposition() throws EstimationException {\n+private void qrDecomposition() throws OptimizationException {\n     for (int k \u003d 0; k \u003c cols; ++k) {\n         permutation[k] \u003d k;\n         double norm2 \u003d 0;\n         for (int index \u003d k; index \u003c jacobian.length; index +\u003d cols) {\n             double akk \u003d jacobian[index];\n             norm2 +\u003d akk * akk;\n         }\n         jacNorm[k] \u003d Math.sqrt(norm2);\n     }\n     for (int k \u003d 0; k \u003c cols; ++k) {\n         int nextColumn \u003d -1;\n         double ak2 \u003d Double.NEGATIVE_INFINITY;\n         for (int i \u003d k; i \u003c cols; ++i) {\n             double norm2 \u003d 0;\n             int iDiag \u003d k * cols + permutation[i];\n             for (int index \u003d iDiag; index \u003c jacobian.length; index +\u003d cols) {\n                 double aki \u003d jacobian[index];\n                 norm2 +\u003d aki * aki;\n             }\n             if (Double.isInfinite(norm2) || Double.isNaN(norm2)) {\n-                throw new EstimationException(\"unable to perform Q.R decomposition on the {0}x{1} jacobian matrix\", rows, cols);\n+                throw new OptimizationException(\"unable to perform Q.R decomposition on the {0}x{1} jacobian matrix\", rows, cols);\n             }\n             if (norm2 \u003e ak2) {\n                 nextColumn \u003d i;\n                 ak2 \u003d norm2;\n             }\n         }\n         if (ak2 \u003d\u003d 0) {\n             rank \u003d k;\n             return;\n         }\n         int pk \u003d permutation[nextColumn];\n         permutation[nextColumn] \u003d permutation[k];\n         permutation[k] \u003d pk;\n         int kDiag \u003d k * cols + pk;\n         double akk \u003d jacobian[kDiag];\n         double alpha \u003d (akk \u003e 0) ? -Math.sqrt(ak2) : Math.sqrt(ak2);\n         double betak \u003d 1.0 / (ak2 - akk * alpha);\n         beta[pk] \u003d betak;\n         diagR[pk] \u003d alpha;\n         jacobian[kDiag] -\u003d alpha;\n         for (int dk \u003d cols - 1 - k; dk \u003e 0; --dk) {\n             int dkp \u003d permutation[k + dk] - pk;\n             double gamma \u003d 0;\n             for (int index \u003d kDiag; index \u003c jacobian.length; index +\u003d cols) {\n                 gamma +\u003d jacobian[index] * jacobian[index + dkp];\n             }\n             gamma *\u003d betak;\n             for (int index \u003d kDiag; index \u003c jacobian.length; index +\u003d cols) {\n                 jacobian[index + dkp] -\u003d gamma * jacobian[index];\n             }\n         }\n     }\n     rank \u003d solvedCols;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Decompose a matrix A as A.P \u003d Q.R using Householder transforms.\n\u003cp\u003eAs suggested in the P. Lascaux and R. Theodor book\n\u003ci\u003eAnalyse num\u0026eacute;rique matricielle appliqu\u0026eacute;e \u0026agrave;\nl\u0027art de l\u0027ing\u0026eacute;nieur\u003c/i\u003e (Masson, 1986), instead of representing\nthe Householder transforms with u\u003csub\u003ek\u003c/sub\u003e unit vectors such that:\n\u003cpre\u003e\nH\u003csub\u003ek\u003c/sub\u003e \u003d I - 2u\u003csub\u003ek\u003c/sub\u003e.u\u003csub\u003ek\u003c/sub\u003e\u003csup\u003et\u003c/sup\u003e\n\u003c/pre\u003e\nwe use \u003csub\u003ek\u003c/sub\u003e non-unit vectors such that:\n\u003cpre\u003e\nH\u003csub\u003ek\u003c/sub\u003e \u003d I - beta\u003csub\u003ek\u003c/sub\u003ev\u003csub\u003ek\u003c/sub\u003e.v\u003csub\u003ek\u003c/sub\u003e\u003csup\u003et\u003c/sup\u003e\n\u003c/pre\u003e\nwhere v\u003csub\u003ek\u003c/sub\u003e \u003d a\u003csub\u003ek\u003c/sub\u003e - alpha\u003csub\u003ek\u003c/sub\u003e e\u003csub\u003ek\u003c/sub\u003e.\nThe beta\u003csub\u003ek\u003c/sub\u003e coefficients are provided upon exit as recomputing\nthem from the v\u003csub\u003ek\u003c/sub\u003e vectors would be costly.\u003c/p\u003e\n\u003cp\u003eThis decomposition handles rank deficient cases since the tranformations\nare performed in non-increasing columns norms order thanks to columns\npivoting. The diagonal elements of the R matrix are therefore also in\nnon-increasing absolute values order.\u003c/p\u003e\n\n@exception EstimationException if the decomposition cannot be performed\n",
            "newValue": "Decompose a matrix A as A.P \u003d Q.R using Householder transforms.\n\u003cp\u003eAs suggested in the P. Lascaux and R. Theodor book\n\u003ci\u003eAnalyse num\u0026eacute;rique matricielle appliqu\u0026eacute;e \u0026agrave;\nl\u0027art de l\u0027ing\u0026eacute;nieur\u003c/i\u003e (Masson, 1986), instead of representing\nthe Householder transforms with u\u003csub\u003ek\u003c/sub\u003e unit vectors such that:\n\u003cpre\u003e\nH\u003csub\u003ek\u003c/sub\u003e \u003d I - 2u\u003csub\u003ek\u003c/sub\u003e.u\u003csub\u003ek\u003c/sub\u003e\u003csup\u003et\u003c/sup\u003e\n\u003c/pre\u003e\nwe use \u003csub\u003ek\u003c/sub\u003e non-unit vectors such that:\n\u003cpre\u003e\nH\u003csub\u003ek\u003c/sub\u003e \u003d I - beta\u003csub\u003ek\u003c/sub\u003ev\u003csub\u003ek\u003c/sub\u003e.v\u003csub\u003ek\u003c/sub\u003e\u003csup\u003et\u003c/sup\u003e\n\u003c/pre\u003e\nwhere v\u003csub\u003ek\u003c/sub\u003e \u003d a\u003csub\u003ek\u003c/sub\u003e - alpha\u003csub\u003ek\u003c/sub\u003e e\u003csub\u003ek\u003c/sub\u003e.\nThe beta\u003csub\u003ek\u003c/sub\u003e coefficients are provided upon exit as recomputing\nthem from the v\u003csub\u003ek\u003c/sub\u003e vectors would be costly.\u003c/p\u003e\n\u003cp\u003eThis decomposition handles rank deficient cases since the tranformations\nare performed in non-increasing columns norms order thanks to columns\npivoting. The diagonal elements of the R matrix are therefore also in\nnon-increasing absolute values order.\u003c/p\u003e\n\n@exception OptimizationException if the decomposition cannot be performed\n"
          }
        }
      ]
    },
    "7f88773d6c3c96c0a2fd24c3e50d1eb80daca11d": {
      "type": "Ybodychange",
      "commitMessage": "replaced Object[] parameters by variable arguments in exceptions constructors\nthis allows simpler error declaration and removes the need for the strange\nnull argument with fixed messages\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@746578 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2/21/09, 12:01 PM",
      "commitName": "7f88773d6c3c96c0a2fd24c3e50d1eb80daca11d",
      "commitAuthor": "Luc Maisonobe",
      "commitDateOld": "12/8/08, 5:40 AM",
      "commitNameOld": "8bf7df05e8df6530d6d47c21421ba026d9df0132",
      "commitAuthorOld": "Luc Maisonobe",
      "daysBetweenCommits": 75.26,
      "commitsBetweenForRepo": 128,
      "commitsBetweenForFile": 1,
      "actualSource": "private void qrDecomposition() throws EstimationException {\n    for (int k \u003d 0; k \u003c cols; ++k) {\n        permutation[k] \u003d k;\n        double norm2 \u003d 0;\n        for (int index \u003d k; index \u003c jacobian.length; index +\u003d cols) {\n            double akk \u003d jacobian[index];\n            norm2 +\u003d akk * akk;\n        }\n        jacNorm[k] \u003d Math.sqrt(norm2);\n    }\n    for (int k \u003d 0; k \u003c cols; ++k) {\n        int nextColumn \u003d -1;\n        double ak2 \u003d Double.NEGATIVE_INFINITY;\n        for (int i \u003d k; i \u003c cols; ++i) {\n            double norm2 \u003d 0;\n            int iDiag \u003d k * cols + permutation[i];\n            for (int index \u003d iDiag; index \u003c jacobian.length; index +\u003d cols) {\n                double aki \u003d jacobian[index];\n                norm2 +\u003d aki * aki;\n            }\n            if (Double.isInfinite(norm2) || Double.isNaN(norm2)) {\n                throw new EstimationException(\"unable to perform Q.R decomposition on the {0}x{1} jacobian matrix\", rows, cols);\n            }\n            if (norm2 \u003e ak2) {\n                nextColumn \u003d i;\n                ak2 \u003d norm2;\n            }\n        }\n        if (ak2 \u003d\u003d 0) {\n            rank \u003d k;\n            return;\n        }\n        int pk \u003d permutation[nextColumn];\n        permutation[nextColumn] \u003d permutation[k];\n        permutation[k] \u003d pk;\n        int kDiag \u003d k * cols + pk;\n        double akk \u003d jacobian[kDiag];\n        double alpha \u003d (akk \u003e 0) ? -Math.sqrt(ak2) : Math.sqrt(ak2);\n        double betak \u003d 1.0 / (ak2 - akk * alpha);\n        beta[pk] \u003d betak;\n        diagR[pk] \u003d alpha;\n        jacobian[kDiag] -\u003d alpha;\n        for (int dk \u003d cols - 1 - k; dk \u003e 0; --dk) {\n            int dkp \u003d permutation[k + dk] - pk;\n            double gamma \u003d 0;\n            for (int index \u003d kDiag; index \u003c jacobian.length; index +\u003d cols) {\n                gamma +\u003d jacobian[index] * jacobian[index + dkp];\n            }\n            gamma *\u003d betak;\n            for (int index \u003d kDiag; index \u003c jacobian.length; index +\u003d cols) {\n                jacobian[index + dkp] -\u003d gamma * jacobian[index];\n            }\n        }\n    }\n    rank \u003d solvedCols;\n}",
      "path": "src/java/org/apache/commons/math/estimation/LevenbergMarquardtEstimator.java",
      "functionStartLine": 737,
      "functionName": "qrDecomposition",
      "functionAnnotation": "",
      "functionDoc": "Decompose a matrix A as A.P \u003d Q.R using Householder transforms.\n\u003cp\u003eAs suggested in the P. Lascaux and R. Theodor book\n\u003ci\u003eAnalyse num\u0026eacute;rique matricielle appliqu\u0026eacute;e \u0026agrave;\nl\u0027art de l\u0027ing\u0026eacute;nieur\u003c/i\u003e (Masson, 1986), instead of representing\nthe Householder transforms with u\u003csub\u003ek\u003c/sub\u003e unit vectors such that:\n\u003cpre\u003e\nH\u003csub\u003ek\u003c/sub\u003e \u003d I - 2u\u003csub\u003ek\u003c/sub\u003e.u\u003csub\u003ek\u003c/sub\u003e\u003csup\u003et\u003c/sup\u003e\n\u003c/pre\u003e\nwe use \u003csub\u003ek\u003c/sub\u003e non-unit vectors such that:\n\u003cpre\u003e\nH\u003csub\u003ek\u003c/sub\u003e \u003d I - beta\u003csub\u003ek\u003c/sub\u003ev\u003csub\u003ek\u003c/sub\u003e.v\u003csub\u003ek\u003c/sub\u003e\u003csup\u003et\u003c/sup\u003e\n\u003c/pre\u003e\nwhere v\u003csub\u003ek\u003c/sub\u003e \u003d a\u003csub\u003ek\u003c/sub\u003e - alpha\u003csub\u003ek\u003c/sub\u003e e\u003csub\u003ek\u003c/sub\u003e.\nThe beta\u003csub\u003ek\u003c/sub\u003e coefficients are provided upon exit as recomputing\nthem from the v\u003csub\u003ek\u003c/sub\u003e vectors would be costly.\u003c/p\u003e\n\u003cp\u003eThis decomposition handles rank deficient cases since the tranformations\nare performed in non-increasing columns norms order thanks to columns\npivoting. The diagonal elements of the R matrix are therefore also in\nnon-increasing absolute values order.\u003c/p\u003e\n\n@exception EstimationException if the decomposition cannot be performed\n",
      "diff": "@@ -1,56 +1,56 @@\n private void qrDecomposition() throws EstimationException {\n     for (int k \u003d 0; k \u003c cols; ++k) {\n         permutation[k] \u003d k;\n         double norm2 \u003d 0;\n         for (int index \u003d k; index \u003c jacobian.length; index +\u003d cols) {\n             double akk \u003d jacobian[index];\n             norm2 +\u003d akk * akk;\n         }\n         jacNorm[k] \u003d Math.sqrt(norm2);\n     }\n     for (int k \u003d 0; k \u003c cols; ++k) {\n         int nextColumn \u003d -1;\n         double ak2 \u003d Double.NEGATIVE_INFINITY;\n         for (int i \u003d k; i \u003c cols; ++i) {\n             double norm2 \u003d 0;\n             int iDiag \u003d k * cols + permutation[i];\n             for (int index \u003d iDiag; index \u003c jacobian.length; index +\u003d cols) {\n                 double aki \u003d jacobian[index];\n                 norm2 +\u003d aki * aki;\n             }\n             if (Double.isInfinite(norm2) || Double.isNaN(norm2)) {\n-                throw new EstimationException(\"unable to perform Q.R decomposition on the {0}x{1} jacobian matrix\", new Object[] { Integer.valueOf(rows), Integer.valueOf(cols) });\n+                throw new EstimationException(\"unable to perform Q.R decomposition on the {0}x{1} jacobian matrix\", rows, cols);\n             }\n             if (norm2 \u003e ak2) {\n                 nextColumn \u003d i;\n                 ak2 \u003d norm2;\n             }\n         }\n         if (ak2 \u003d\u003d 0) {\n             rank \u003d k;\n             return;\n         }\n         int pk \u003d permutation[nextColumn];\n         permutation[nextColumn] \u003d permutation[k];\n         permutation[k] \u003d pk;\n         int kDiag \u003d k * cols + pk;\n         double akk \u003d jacobian[kDiag];\n         double alpha \u003d (akk \u003e 0) ? -Math.sqrt(ak2) : Math.sqrt(ak2);\n         double betak \u003d 1.0 / (ak2 - akk * alpha);\n         beta[pk] \u003d betak;\n         diagR[pk] \u003d alpha;\n         jacobian[kDiag] -\u003d alpha;\n         for (int dk \u003d cols - 1 - k; dk \u003e 0; --dk) {\n             int dkp \u003d permutation[k + dk] - pk;\n             double gamma \u003d 0;\n             for (int index \u003d kDiag; index \u003c jacobian.length; index +\u003d cols) {\n                 gamma +\u003d jacobian[index] * jacobian[index + dkp];\n             }\n             gamma *\u003d betak;\n             for (int index \u003d kDiag; index \u003c jacobian.length; index +\u003d cols) {\n                 jacobian[index + dkp] -\u003d gamma * jacobian[index];\n             }\n         }\n     }\n     rank \u003d solvedCols;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fd0f87590d1c88c18f669e9b168c8fd20631f23c": {
      "type": "Ybodychange",
      "commitMessage": "replaced inefficient use of constructors for Integer, Long, Float and Double\nby the recommended static valueOf methods that cache results\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/branches/MATH_2_0@666292 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "6/10/08, 12:32 PM",
      "commitName": "fd0f87590d1c88c18f669e9b168c8fd20631f23c",
      "commitAuthor": "Luc Maisonobe",
      "commitDateOld": "3/23/08, 6:36 AM",
      "commitNameOld": "2c6b6be4ba2b9abf4dc6d52864b148a910de8e90",
      "commitAuthorOld": "Luc Maisonobe",
      "daysBetweenCommits": 79.25,
      "commitsBetweenForRepo": 47,
      "commitsBetweenForFile": 1,
      "actualSource": "private void qrDecomposition() throws EstimationException {\n    for (int k \u003d 0; k \u003c cols; ++k) {\n        permutation[k] \u003d k;\n        double norm2 \u003d 0;\n        for (int index \u003d k; index \u003c jacobian.length; index +\u003d cols) {\n            double akk \u003d jacobian[index];\n            norm2 +\u003d akk * akk;\n        }\n        jacNorm[k] \u003d Math.sqrt(norm2);\n    }\n    for (int k \u003d 0; k \u003c cols; ++k) {\n        int nextColumn \u003d -1;\n        double ak2 \u003d Double.NEGATIVE_INFINITY;\n        for (int i \u003d k; i \u003c cols; ++i) {\n            double norm2 \u003d 0;\n            int iDiag \u003d k * cols + permutation[i];\n            for (int index \u003d iDiag; index \u003c jacobian.length; index +\u003d cols) {\n                double aki \u003d jacobian[index];\n                norm2 +\u003d aki * aki;\n            }\n            if (Double.isInfinite(norm2) || Double.isNaN(norm2)) {\n                throw new EstimationException(\"unable to perform Q.R decomposition on the {0}x{1} jacobian matrix\", new Object[] { Integer.valueOf(rows), Integer.valueOf(cols) });\n            }\n            if (norm2 \u003e ak2) {\n                nextColumn \u003d i;\n                ak2 \u003d norm2;\n            }\n        }\n        if (ak2 \u003d\u003d 0) {\n            rank \u003d k;\n            return;\n        }\n        int pk \u003d permutation[nextColumn];\n        permutation[nextColumn] \u003d permutation[k];\n        permutation[k] \u003d pk;\n        int kDiag \u003d k * cols + pk;\n        double akk \u003d jacobian[kDiag];\n        double alpha \u003d (akk \u003e 0) ? -Math.sqrt(ak2) : Math.sqrt(ak2);\n        double betak \u003d 1.0 / (ak2 - akk * alpha);\n        beta[pk] \u003d betak;\n        diagR[pk] \u003d alpha;\n        jacobian[kDiag] -\u003d alpha;\n        for (int dk \u003d cols - 1 - k; dk \u003e 0; --dk) {\n            int dkp \u003d permutation[k + dk] - pk;\n            double gamma \u003d 0;\n            for (int index \u003d kDiag; index \u003c jacobian.length; index +\u003d cols) {\n                gamma +\u003d jacobian[index] * jacobian[index + dkp];\n            }\n            gamma *\u003d betak;\n            for (int index \u003d kDiag; index \u003c jacobian.length; index +\u003d cols) {\n                jacobian[index + dkp] -\u003d gamma * jacobian[index];\n            }\n        }\n    }\n    rank \u003d solvedCols;\n}",
      "path": "src/java/org/apache/commons/math/estimation/LevenbergMarquardtEstimator.java",
      "functionStartLine": 738,
      "functionName": "qrDecomposition",
      "functionAnnotation": "",
      "functionDoc": "Decompose a matrix A as A.P \u003d Q.R using Householder transforms.\n\u003cp\u003eAs suggested in the P. Lascaux and R. Theodor book\n\u003ci\u003eAnalyse num\u0026eacute;rique matricielle appliqu\u0026eacute;e \u0026agrave;\nl\u0027art de l\u0027ing\u0026eacute;nieur\u003c/i\u003e (Masson, 1986), instead of representing\nthe Householder transforms with u\u003csub\u003ek\u003c/sub\u003e unit vectors such that:\n\u003cpre\u003e\nH\u003csub\u003ek\u003c/sub\u003e \u003d I - 2u\u003csub\u003ek\u003c/sub\u003e.u\u003csub\u003ek\u003c/sub\u003e\u003csup\u003et\u003c/sup\u003e\n\u003c/pre\u003e\nwe use \u003csub\u003ek\u003c/sub\u003e non-unit vectors such that:\n\u003cpre\u003e\nH\u003csub\u003ek\u003c/sub\u003e \u003d I - beta\u003csub\u003ek\u003c/sub\u003ev\u003csub\u003ek\u003c/sub\u003e.v\u003csub\u003ek\u003c/sub\u003e\u003csup\u003et\u003c/sup\u003e\n\u003c/pre\u003e\nwhere v\u003csub\u003ek\u003c/sub\u003e \u003d a\u003csub\u003ek\u003c/sub\u003e - alpha\u003csub\u003ek\u003c/sub\u003e e\u003csub\u003ek\u003c/sub\u003e.\nThe beta\u003csub\u003ek\u003c/sub\u003e coefficients are provided upon exit as recomputing\nthem from the v\u003csub\u003ek\u003c/sub\u003e vectors would be costly.\u003c/p\u003e\n\u003cp\u003eThis decomposition handles rank deficient cases since the tranformations\nare performed in non-increasing columns norms order thanks to columns\npivoting. The diagonal elements of the R matrix are therefore also in\nnon-increasing absolute values order.\u003c/p\u003e\n\n@exception EstimationException if the decomposition cannot be performed\n",
      "diff": "@@ -1,56 +1,56 @@\n private void qrDecomposition() throws EstimationException {\n     for (int k \u003d 0; k \u003c cols; ++k) {\n         permutation[k] \u003d k;\n         double norm2 \u003d 0;\n         for (int index \u003d k; index \u003c jacobian.length; index +\u003d cols) {\n             double akk \u003d jacobian[index];\n             norm2 +\u003d akk * akk;\n         }\n         jacNorm[k] \u003d Math.sqrt(norm2);\n     }\n     for (int k \u003d 0; k \u003c cols; ++k) {\n         int nextColumn \u003d -1;\n         double ak2 \u003d Double.NEGATIVE_INFINITY;\n         for (int i \u003d k; i \u003c cols; ++i) {\n             double norm2 \u003d 0;\n             int iDiag \u003d k * cols + permutation[i];\n             for (int index \u003d iDiag; index \u003c jacobian.length; index +\u003d cols) {\n                 double aki \u003d jacobian[index];\n                 norm2 +\u003d aki * aki;\n             }\n             if (Double.isInfinite(norm2) || Double.isNaN(norm2)) {\n-                throw new EstimationException(\"unable to perform Q.R decomposition on the {0}x{1} jacobian matrix\", new Object[] { new Integer(rows), new Integer(cols) });\n+                throw new EstimationException(\"unable to perform Q.R decomposition on the {0}x{1} jacobian matrix\", new Object[] { Integer.valueOf(rows), Integer.valueOf(cols) });\n             }\n             if (norm2 \u003e ak2) {\n                 nextColumn \u003d i;\n                 ak2 \u003d norm2;\n             }\n         }\n         if (ak2 \u003d\u003d 0) {\n             rank \u003d k;\n             return;\n         }\n         int pk \u003d permutation[nextColumn];\n         permutation[nextColumn] \u003d permutation[k];\n         permutation[k] \u003d pk;\n         int kDiag \u003d k * cols + pk;\n         double akk \u003d jacobian[kDiag];\n         double alpha \u003d (akk \u003e 0) ? -Math.sqrt(ak2) : Math.sqrt(ak2);\n         double betak \u003d 1.0 / (ak2 - akk * alpha);\n         beta[pk] \u003d betak;\n         diagR[pk] \u003d alpha;\n         jacobian[kDiag] -\u003d alpha;\n         for (int dk \u003d cols - 1 - k; dk \u003e 0; --dk) {\n             int dkp \u003d permutation[k + dk] - pk;\n             double gamma \u003d 0;\n             for (int index \u003d kDiag; index \u003c jacobian.length; index +\u003d cols) {\n                 gamma +\u003d jacobian[index] * jacobian[index + dkp];\n             }\n             gamma *\u003d betak;\n             for (int index \u003d kDiag; index \u003c jacobian.length; index +\u003d cols) {\n                 jacobian[index + dkp] -\u003d gamma * jacobian[index];\n             }\n         }\n     }\n     rank \u003d solvedCols;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2c6b6be4ba2b9abf4dc6d52864b148a910de8e90": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange,Ydocchange)",
      "commitMessage": "detect numerical problems in Q.R decomposition for Levenberg-Marquardt estimator\nand report them appropriately\nJIRA: MATH-199\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@640204 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "3/23/08, 6:36 AM",
      "commitName": "2c6b6be4ba2b9abf4dc6d52864b148a910de8e90",
      "commitAuthor": "Luc Maisonobe",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "detect numerical problems in Q.R decomposition for Levenberg-Marquardt estimator\nand report them appropriately\nJIRA: MATH-199\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@640204 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "3/23/08, 6:36 AM",
          "commitName": "2c6b6be4ba2b9abf4dc6d52864b148a910de8e90",
          "commitAuthor": "Luc Maisonobe",
          "commitDateOld": "2/10/08, 11:28 AM",
          "commitNameOld": "a7755a3c8c1b7aa200f1b0411851d392ee35702b",
          "commitAuthorOld": "Phil Steitz",
          "daysBetweenCommits": 41.75,
          "commitsBetweenForRepo": 37,
          "commitsBetweenForFile": 1,
          "actualSource": "private void qrDecomposition() throws EstimationException {\n    for (int k \u003d 0; k \u003c cols; ++k) {\n        permutation[k] \u003d k;\n        double norm2 \u003d 0;\n        for (int index \u003d k; index \u003c jacobian.length; index +\u003d cols) {\n            double akk \u003d jacobian[index];\n            norm2 +\u003d akk * akk;\n        }\n        jacNorm[k] \u003d Math.sqrt(norm2);\n    }\n    for (int k \u003d 0; k \u003c cols; ++k) {\n        int nextColumn \u003d -1;\n        double ak2 \u003d Double.NEGATIVE_INFINITY;\n        for (int i \u003d k; i \u003c cols; ++i) {\n            double norm2 \u003d 0;\n            int iDiag \u003d k * cols + permutation[i];\n            for (int index \u003d iDiag; index \u003c jacobian.length; index +\u003d cols) {\n                double aki \u003d jacobian[index];\n                norm2 +\u003d aki * aki;\n            }\n            if (Double.isInfinite(norm2) || Double.isNaN(norm2)) {\n                throw new EstimationException(\"unable to perform Q.R decomposition on the {0}x{1} jacobian matrix\", new Object[] { new Integer(rows), new Integer(cols) });\n            }\n            if (norm2 \u003e ak2) {\n                nextColumn \u003d i;\n                ak2 \u003d norm2;\n            }\n        }\n        if (ak2 \u003d\u003d 0) {\n            rank \u003d k;\n            return;\n        }\n        int pk \u003d permutation[nextColumn];\n        permutation[nextColumn] \u003d permutation[k];\n        permutation[k] \u003d pk;\n        int kDiag \u003d k * cols + pk;\n        double akk \u003d jacobian[kDiag];\n        double alpha \u003d (akk \u003e 0) ? -Math.sqrt(ak2) : Math.sqrt(ak2);\n        double betak \u003d 1.0 / (ak2 - akk * alpha);\n        beta[pk] \u003d betak;\n        diagR[pk] \u003d alpha;\n        jacobian[kDiag] -\u003d alpha;\n        for (int dk \u003d cols - 1 - k; dk \u003e 0; --dk) {\n            int dkp \u003d permutation[k + dk] - pk;\n            double gamma \u003d 0;\n            for (int index \u003d kDiag; index \u003c jacobian.length; index +\u003d cols) {\n                gamma +\u003d jacobian[index] * jacobian[index + dkp];\n            }\n            gamma *\u003d betak;\n            for (int index \u003d kDiag; index \u003c jacobian.length; index +\u003d cols) {\n                jacobian[index + dkp] -\u003d gamma * jacobian[index];\n            }\n        }\n    }\n    rank \u003d solvedCols;\n}",
          "path": "src/java/org/apache/commons/math/estimation/LevenbergMarquardtEstimator.java",
          "functionStartLine": 738,
          "functionName": "qrDecomposition",
          "functionAnnotation": "",
          "functionDoc": "Decompose a matrix A as A.P \u003d Q.R using Householder transforms.\n\u003cp\u003eAs suggested in the P. Lascaux and R. Theodor book\n\u003ci\u003eAnalyse num\u0026eacute;rique matricielle appliqu\u0026eacute;e \u0026agrave;\nl\u0027art de l\u0027ing\u0026eacute;nieur\u003c/i\u003e (Masson, 1986), instead of representing\nthe Householder transforms with u\u003csub\u003ek\u003c/sub\u003e unit vectors such that:\n\u003cpre\u003e\nH\u003csub\u003ek\u003c/sub\u003e \u003d I - 2u\u003csub\u003ek\u003c/sub\u003e.u\u003csub\u003ek\u003c/sub\u003e\u003csup\u003et\u003c/sup\u003e\n\u003c/pre\u003e\nwe use \u003csub\u003ek\u003c/sub\u003e non-unit vectors such that:\n\u003cpre\u003e\nH\u003csub\u003ek\u003c/sub\u003e \u003d I - beta\u003csub\u003ek\u003c/sub\u003ev\u003csub\u003ek\u003c/sub\u003e.v\u003csub\u003ek\u003c/sub\u003e\u003csup\u003et\u003c/sup\u003e\n\u003c/pre\u003e\nwhere v\u003csub\u003ek\u003c/sub\u003e \u003d a\u003csub\u003ek\u003c/sub\u003e - alpha\u003csub\u003ek\u003c/sub\u003e e\u003csub\u003ek\u003c/sub\u003e.\nThe beta\u003csub\u003ek\u003c/sub\u003e coefficients are provided upon exit as recomputing\nthem from the v\u003csub\u003ek\u003c/sub\u003e vectors would be costly.\u003c/p\u003e\n\u003cp\u003eThis decomposition handles rank deficient cases since the tranformations\nare performed in non-increasing columns norms order thanks to columns\npivoting. The diagonal elements of the R matrix are therefore also in\nnon-increasing absolute values order.\u003c/p\u003e\n\n@exception EstimationException if the decomposition cannot be performed\n",
          "diff": "@@ -1,53 +1,56 @@\n-private void qrDecomposition() {\n+private void qrDecomposition() throws EstimationException {\n     for (int k \u003d 0; k \u003c cols; ++k) {\n         permutation[k] \u003d k;\n         double norm2 \u003d 0;\n         for (int index \u003d k; index \u003c jacobian.length; index +\u003d cols) {\n             double akk \u003d jacobian[index];\n             norm2 +\u003d akk * akk;\n         }\n         jacNorm[k] \u003d Math.sqrt(norm2);\n     }\n     for (int k \u003d 0; k \u003c cols; ++k) {\n         int nextColumn \u003d -1;\n         double ak2 \u003d Double.NEGATIVE_INFINITY;\n         for (int i \u003d k; i \u003c cols; ++i) {\n             double norm2 \u003d 0;\n             int iDiag \u003d k * cols + permutation[i];\n             for (int index \u003d iDiag; index \u003c jacobian.length; index +\u003d cols) {\n                 double aki \u003d jacobian[index];\n                 norm2 +\u003d aki * aki;\n             }\n+            if (Double.isInfinite(norm2) || Double.isNaN(norm2)) {\n+                throw new EstimationException(\"unable to perform Q.R decomposition on the {0}x{1} jacobian matrix\", new Object[] { new Integer(rows), new Integer(cols) });\n+            }\n             if (norm2 \u003e ak2) {\n                 nextColumn \u003d i;\n                 ak2 \u003d norm2;\n             }\n         }\n         if (ak2 \u003d\u003d 0) {\n             rank \u003d k;\n             return;\n         }\n         int pk \u003d permutation[nextColumn];\n         permutation[nextColumn] \u003d permutation[k];\n         permutation[k] \u003d pk;\n         int kDiag \u003d k * cols + pk;\n         double akk \u003d jacobian[kDiag];\n         double alpha \u003d (akk \u003e 0) ? -Math.sqrt(ak2) : Math.sqrt(ak2);\n         double betak \u003d 1.0 / (ak2 - akk * alpha);\n         beta[pk] \u003d betak;\n         diagR[pk] \u003d alpha;\n         jacobian[kDiag] -\u003d alpha;\n         for (int dk \u003d cols - 1 - k; dk \u003e 0; --dk) {\n             int dkp \u003d permutation[k + dk] - pk;\n             double gamma \u003d 0;\n             for (int index \u003d kDiag; index \u003c jacobian.length; index +\u003d cols) {\n                 gamma +\u003d jacobian[index] * jacobian[index + dkp];\n             }\n             gamma *\u003d betak;\n             for (int index \u003d kDiag; index \u003c jacobian.length; index +\u003d cols) {\n                 jacobian[index + dkp] -\u003d gamma * jacobian[index];\n             }\n         }\n     }\n     rank \u003d solvedCols;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[EstimationException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "detect numerical problems in Q.R decomposition for Levenberg-Marquardt estimator\nand report them appropriately\nJIRA: MATH-199\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@640204 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "3/23/08, 6:36 AM",
          "commitName": "2c6b6be4ba2b9abf4dc6d52864b148a910de8e90",
          "commitAuthor": "Luc Maisonobe",
          "commitDateOld": "2/10/08, 11:28 AM",
          "commitNameOld": "a7755a3c8c1b7aa200f1b0411851d392ee35702b",
          "commitAuthorOld": "Phil Steitz",
          "daysBetweenCommits": 41.75,
          "commitsBetweenForRepo": 37,
          "commitsBetweenForFile": 1,
          "actualSource": "private void qrDecomposition() throws EstimationException {\n    for (int k \u003d 0; k \u003c cols; ++k) {\n        permutation[k] \u003d k;\n        double norm2 \u003d 0;\n        for (int index \u003d k; index \u003c jacobian.length; index +\u003d cols) {\n            double akk \u003d jacobian[index];\n            norm2 +\u003d akk * akk;\n        }\n        jacNorm[k] \u003d Math.sqrt(norm2);\n    }\n    for (int k \u003d 0; k \u003c cols; ++k) {\n        int nextColumn \u003d -1;\n        double ak2 \u003d Double.NEGATIVE_INFINITY;\n        for (int i \u003d k; i \u003c cols; ++i) {\n            double norm2 \u003d 0;\n            int iDiag \u003d k * cols + permutation[i];\n            for (int index \u003d iDiag; index \u003c jacobian.length; index +\u003d cols) {\n                double aki \u003d jacobian[index];\n                norm2 +\u003d aki * aki;\n            }\n            if (Double.isInfinite(norm2) || Double.isNaN(norm2)) {\n                throw new EstimationException(\"unable to perform Q.R decomposition on the {0}x{1} jacobian matrix\", new Object[] { new Integer(rows), new Integer(cols) });\n            }\n            if (norm2 \u003e ak2) {\n                nextColumn \u003d i;\n                ak2 \u003d norm2;\n            }\n        }\n        if (ak2 \u003d\u003d 0) {\n            rank \u003d k;\n            return;\n        }\n        int pk \u003d permutation[nextColumn];\n        permutation[nextColumn] \u003d permutation[k];\n        permutation[k] \u003d pk;\n        int kDiag \u003d k * cols + pk;\n        double akk \u003d jacobian[kDiag];\n        double alpha \u003d (akk \u003e 0) ? -Math.sqrt(ak2) : Math.sqrt(ak2);\n        double betak \u003d 1.0 / (ak2 - akk * alpha);\n        beta[pk] \u003d betak;\n        diagR[pk] \u003d alpha;\n        jacobian[kDiag] -\u003d alpha;\n        for (int dk \u003d cols - 1 - k; dk \u003e 0; --dk) {\n            int dkp \u003d permutation[k + dk] - pk;\n            double gamma \u003d 0;\n            for (int index \u003d kDiag; index \u003c jacobian.length; index +\u003d cols) {\n                gamma +\u003d jacobian[index] * jacobian[index + dkp];\n            }\n            gamma *\u003d betak;\n            for (int index \u003d kDiag; index \u003c jacobian.length; index +\u003d cols) {\n                jacobian[index + dkp] -\u003d gamma * jacobian[index];\n            }\n        }\n    }\n    rank \u003d solvedCols;\n}",
          "path": "src/java/org/apache/commons/math/estimation/LevenbergMarquardtEstimator.java",
          "functionStartLine": 738,
          "functionName": "qrDecomposition",
          "functionAnnotation": "",
          "functionDoc": "Decompose a matrix A as A.P \u003d Q.R using Householder transforms.\n\u003cp\u003eAs suggested in the P. Lascaux and R. Theodor book\n\u003ci\u003eAnalyse num\u0026eacute;rique matricielle appliqu\u0026eacute;e \u0026agrave;\nl\u0027art de l\u0027ing\u0026eacute;nieur\u003c/i\u003e (Masson, 1986), instead of representing\nthe Householder transforms with u\u003csub\u003ek\u003c/sub\u003e unit vectors such that:\n\u003cpre\u003e\nH\u003csub\u003ek\u003c/sub\u003e \u003d I - 2u\u003csub\u003ek\u003c/sub\u003e.u\u003csub\u003ek\u003c/sub\u003e\u003csup\u003et\u003c/sup\u003e\n\u003c/pre\u003e\nwe use \u003csub\u003ek\u003c/sub\u003e non-unit vectors such that:\n\u003cpre\u003e\nH\u003csub\u003ek\u003c/sub\u003e \u003d I - beta\u003csub\u003ek\u003c/sub\u003ev\u003csub\u003ek\u003c/sub\u003e.v\u003csub\u003ek\u003c/sub\u003e\u003csup\u003et\u003c/sup\u003e\n\u003c/pre\u003e\nwhere v\u003csub\u003ek\u003c/sub\u003e \u003d a\u003csub\u003ek\u003c/sub\u003e - alpha\u003csub\u003ek\u003c/sub\u003e e\u003csub\u003ek\u003c/sub\u003e.\nThe beta\u003csub\u003ek\u003c/sub\u003e coefficients are provided upon exit as recomputing\nthem from the v\u003csub\u003ek\u003c/sub\u003e vectors would be costly.\u003c/p\u003e\n\u003cp\u003eThis decomposition handles rank deficient cases since the tranformations\nare performed in non-increasing columns norms order thanks to columns\npivoting. The diagonal elements of the R matrix are therefore also in\nnon-increasing absolute values order.\u003c/p\u003e\n\n@exception EstimationException if the decomposition cannot be performed\n",
          "diff": "@@ -1,53 +1,56 @@\n-private void qrDecomposition() {\n+private void qrDecomposition() throws EstimationException {\n     for (int k \u003d 0; k \u003c cols; ++k) {\n         permutation[k] \u003d k;\n         double norm2 \u003d 0;\n         for (int index \u003d k; index \u003c jacobian.length; index +\u003d cols) {\n             double akk \u003d jacobian[index];\n             norm2 +\u003d akk * akk;\n         }\n         jacNorm[k] \u003d Math.sqrt(norm2);\n     }\n     for (int k \u003d 0; k \u003c cols; ++k) {\n         int nextColumn \u003d -1;\n         double ak2 \u003d Double.NEGATIVE_INFINITY;\n         for (int i \u003d k; i \u003c cols; ++i) {\n             double norm2 \u003d 0;\n             int iDiag \u003d k * cols + permutation[i];\n             for (int index \u003d iDiag; index \u003c jacobian.length; index +\u003d cols) {\n                 double aki \u003d jacobian[index];\n                 norm2 +\u003d aki * aki;\n             }\n+            if (Double.isInfinite(norm2) || Double.isNaN(norm2)) {\n+                throw new EstimationException(\"unable to perform Q.R decomposition on the {0}x{1} jacobian matrix\", new Object[] { new Integer(rows), new Integer(cols) });\n+            }\n             if (norm2 \u003e ak2) {\n                 nextColumn \u003d i;\n                 ak2 \u003d norm2;\n             }\n         }\n         if (ak2 \u003d\u003d 0) {\n             rank \u003d k;\n             return;\n         }\n         int pk \u003d permutation[nextColumn];\n         permutation[nextColumn] \u003d permutation[k];\n         permutation[k] \u003d pk;\n         int kDiag \u003d k * cols + pk;\n         double akk \u003d jacobian[kDiag];\n         double alpha \u003d (akk \u003e 0) ? -Math.sqrt(ak2) : Math.sqrt(ak2);\n         double betak \u003d 1.0 / (ak2 - akk * alpha);\n         beta[pk] \u003d betak;\n         diagR[pk] \u003d alpha;\n         jacobian[kDiag] -\u003d alpha;\n         for (int dk \u003d cols - 1 - k; dk \u003e 0; --dk) {\n             int dkp \u003d permutation[k + dk] - pk;\n             double gamma \u003d 0;\n             for (int index \u003d kDiag; index \u003c jacobian.length; index +\u003d cols) {\n                 gamma +\u003d jacobian[index] * jacobian[index + dkp];\n             }\n             gamma *\u003d betak;\n             for (int index \u003d kDiag; index \u003c jacobian.length; index +\u003d cols) {\n                 jacobian[index + dkp] -\u003d gamma * jacobian[index];\n             }\n         }\n     }\n     rank \u003d solvedCols;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "detect numerical problems in Q.R decomposition for Levenberg-Marquardt estimator\nand report them appropriately\nJIRA: MATH-199\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@640204 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "3/23/08, 6:36 AM",
          "commitName": "2c6b6be4ba2b9abf4dc6d52864b148a910de8e90",
          "commitAuthor": "Luc Maisonobe",
          "commitDateOld": "2/10/08, 11:28 AM",
          "commitNameOld": "a7755a3c8c1b7aa200f1b0411851d392ee35702b",
          "commitAuthorOld": "Phil Steitz",
          "daysBetweenCommits": 41.75,
          "commitsBetweenForRepo": 37,
          "commitsBetweenForFile": 1,
          "actualSource": "private void qrDecomposition() throws EstimationException {\n    for (int k \u003d 0; k \u003c cols; ++k) {\n        permutation[k] \u003d k;\n        double norm2 \u003d 0;\n        for (int index \u003d k; index \u003c jacobian.length; index +\u003d cols) {\n            double akk \u003d jacobian[index];\n            norm2 +\u003d akk * akk;\n        }\n        jacNorm[k] \u003d Math.sqrt(norm2);\n    }\n    for (int k \u003d 0; k \u003c cols; ++k) {\n        int nextColumn \u003d -1;\n        double ak2 \u003d Double.NEGATIVE_INFINITY;\n        for (int i \u003d k; i \u003c cols; ++i) {\n            double norm2 \u003d 0;\n            int iDiag \u003d k * cols + permutation[i];\n            for (int index \u003d iDiag; index \u003c jacobian.length; index +\u003d cols) {\n                double aki \u003d jacobian[index];\n                norm2 +\u003d aki * aki;\n            }\n            if (Double.isInfinite(norm2) || Double.isNaN(norm2)) {\n                throw new EstimationException(\"unable to perform Q.R decomposition on the {0}x{1} jacobian matrix\", new Object[] { new Integer(rows), new Integer(cols) });\n            }\n            if (norm2 \u003e ak2) {\n                nextColumn \u003d i;\n                ak2 \u003d norm2;\n            }\n        }\n        if (ak2 \u003d\u003d 0) {\n            rank \u003d k;\n            return;\n        }\n        int pk \u003d permutation[nextColumn];\n        permutation[nextColumn] \u003d permutation[k];\n        permutation[k] \u003d pk;\n        int kDiag \u003d k * cols + pk;\n        double akk \u003d jacobian[kDiag];\n        double alpha \u003d (akk \u003e 0) ? -Math.sqrt(ak2) : Math.sqrt(ak2);\n        double betak \u003d 1.0 / (ak2 - akk * alpha);\n        beta[pk] \u003d betak;\n        diagR[pk] \u003d alpha;\n        jacobian[kDiag] -\u003d alpha;\n        for (int dk \u003d cols - 1 - k; dk \u003e 0; --dk) {\n            int dkp \u003d permutation[k + dk] - pk;\n            double gamma \u003d 0;\n            for (int index \u003d kDiag; index \u003c jacobian.length; index +\u003d cols) {\n                gamma +\u003d jacobian[index] * jacobian[index + dkp];\n            }\n            gamma *\u003d betak;\n            for (int index \u003d kDiag; index \u003c jacobian.length; index +\u003d cols) {\n                jacobian[index + dkp] -\u003d gamma * jacobian[index];\n            }\n        }\n    }\n    rank \u003d solvedCols;\n}",
          "path": "src/java/org/apache/commons/math/estimation/LevenbergMarquardtEstimator.java",
          "functionStartLine": 738,
          "functionName": "qrDecomposition",
          "functionAnnotation": "",
          "functionDoc": "Decompose a matrix A as A.P \u003d Q.R using Householder transforms.\n\u003cp\u003eAs suggested in the P. Lascaux and R. Theodor book\n\u003ci\u003eAnalyse num\u0026eacute;rique matricielle appliqu\u0026eacute;e \u0026agrave;\nl\u0027art de l\u0027ing\u0026eacute;nieur\u003c/i\u003e (Masson, 1986), instead of representing\nthe Householder transforms with u\u003csub\u003ek\u003c/sub\u003e unit vectors such that:\n\u003cpre\u003e\nH\u003csub\u003ek\u003c/sub\u003e \u003d I - 2u\u003csub\u003ek\u003c/sub\u003e.u\u003csub\u003ek\u003c/sub\u003e\u003csup\u003et\u003c/sup\u003e\n\u003c/pre\u003e\nwe use \u003csub\u003ek\u003c/sub\u003e non-unit vectors such that:\n\u003cpre\u003e\nH\u003csub\u003ek\u003c/sub\u003e \u003d I - beta\u003csub\u003ek\u003c/sub\u003ev\u003csub\u003ek\u003c/sub\u003e.v\u003csub\u003ek\u003c/sub\u003e\u003csup\u003et\u003c/sup\u003e\n\u003c/pre\u003e\nwhere v\u003csub\u003ek\u003c/sub\u003e \u003d a\u003csub\u003ek\u003c/sub\u003e - alpha\u003csub\u003ek\u003c/sub\u003e e\u003csub\u003ek\u003c/sub\u003e.\nThe beta\u003csub\u003ek\u003c/sub\u003e coefficients are provided upon exit as recomputing\nthem from the v\u003csub\u003ek\u003c/sub\u003e vectors would be costly.\u003c/p\u003e\n\u003cp\u003eThis decomposition handles rank deficient cases since the tranformations\nare performed in non-increasing columns norms order thanks to columns\npivoting. The diagonal elements of the R matrix are therefore also in\nnon-increasing absolute values order.\u003c/p\u003e\n\n@exception EstimationException if the decomposition cannot be performed\n",
          "diff": "@@ -1,53 +1,56 @@\n-private void qrDecomposition() {\n+private void qrDecomposition() throws EstimationException {\n     for (int k \u003d 0; k \u003c cols; ++k) {\n         permutation[k] \u003d k;\n         double norm2 \u003d 0;\n         for (int index \u003d k; index \u003c jacobian.length; index +\u003d cols) {\n             double akk \u003d jacobian[index];\n             norm2 +\u003d akk * akk;\n         }\n         jacNorm[k] \u003d Math.sqrt(norm2);\n     }\n     for (int k \u003d 0; k \u003c cols; ++k) {\n         int nextColumn \u003d -1;\n         double ak2 \u003d Double.NEGATIVE_INFINITY;\n         for (int i \u003d k; i \u003c cols; ++i) {\n             double norm2 \u003d 0;\n             int iDiag \u003d k * cols + permutation[i];\n             for (int index \u003d iDiag; index \u003c jacobian.length; index +\u003d cols) {\n                 double aki \u003d jacobian[index];\n                 norm2 +\u003d aki * aki;\n             }\n+            if (Double.isInfinite(norm2) || Double.isNaN(norm2)) {\n+                throw new EstimationException(\"unable to perform Q.R decomposition on the {0}x{1} jacobian matrix\", new Object[] { new Integer(rows), new Integer(cols) });\n+            }\n             if (norm2 \u003e ak2) {\n                 nextColumn \u003d i;\n                 ak2 \u003d norm2;\n             }\n         }\n         if (ak2 \u003d\u003d 0) {\n             rank \u003d k;\n             return;\n         }\n         int pk \u003d permutation[nextColumn];\n         permutation[nextColumn] \u003d permutation[k];\n         permutation[k] \u003d pk;\n         int kDiag \u003d k * cols + pk;\n         double akk \u003d jacobian[kDiag];\n         double alpha \u003d (akk \u003e 0) ? -Math.sqrt(ak2) : Math.sqrt(ak2);\n         double betak \u003d 1.0 / (ak2 - akk * alpha);\n         beta[pk] \u003d betak;\n         diagR[pk] \u003d alpha;\n         jacobian[kDiag] -\u003d alpha;\n         for (int dk \u003d cols - 1 - k; dk \u003e 0; --dk) {\n             int dkp \u003d permutation[k + dk] - pk;\n             double gamma \u003d 0;\n             for (int index \u003d kDiag; index \u003c jacobian.length; index +\u003d cols) {\n                 gamma +\u003d jacobian[index] * jacobian[index + dkp];\n             }\n             gamma *\u003d betak;\n             for (int index \u003d kDiag; index \u003c jacobian.length; index +\u003d cols) {\n                 jacobian[index + dkp] -\u003d gamma * jacobian[index];\n             }\n         }\n     }\n     rank \u003d solvedCols;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Decompose a matrix A as A.P \u003d Q.R using Householder transforms.\n\u003cp\u003eAs suggested in the P. Lascaux and R. Theodor book\n\u003ci\u003eAnalyse num\u0026eacute;rique matricielle appliqu\u0026eacute;e \u0026agrave;\nl\u0027art de l\u0027ing\u0026eacute;nieur\u003c/i\u003e (Masson, 1986), instead of representing\nthe Householder transforms with u\u003csub\u003ek\u003c/sub\u003e unit vectors such that:\n\u003cpre\u003e\nH\u003csub\u003ek\u003c/sub\u003e \u003d I - 2u\u003csub\u003ek\u003c/sub\u003e.u\u003csub\u003ek\u003c/sub\u003e\u003csup\u003et\u003c/sup\u003e\n\u003c/pre\u003e\nwe use \u003csub\u003ek\u003c/sub\u003e non-unit vectors such that:\n\u003cpre\u003e\nH\u003csub\u003ek\u003c/sub\u003e \u003d I - beta\u003csub\u003ek\u003c/sub\u003ev\u003csub\u003ek\u003c/sub\u003e.v\u003csub\u003ek\u003c/sub\u003e\u003csup\u003et\u003c/sup\u003e\n\u003c/pre\u003e\nwhere v\u003csub\u003ek\u003c/sub\u003e \u003d a\u003csub\u003ek\u003c/sub\u003e - alpha\u003csub\u003ek\u003c/sub\u003e e\u003csub\u003ek\u003c/sub\u003e.\nThe beta\u003csub\u003ek\u003c/sub\u003e coefficients are provided upon exit as recomputing\nthem from the v\u003csub\u003ek\u003c/sub\u003e vectors would be costly.\u003c/p\u003e\n\u003cp\u003eThis decomposition handles rank deficient cases since the tranformations\nare performed in non-increasing columns norms order thanks to columns\npivoting. The diagonal elements of the R matrix are therefore also in\nnon-increasing absolute values order.\u003c/p\u003e\n",
            "newValue": "Decompose a matrix A as A.P \u003d Q.R using Householder transforms.\n\u003cp\u003eAs suggested in the P. Lascaux and R. Theodor book\n\u003ci\u003eAnalyse num\u0026eacute;rique matricielle appliqu\u0026eacute;e \u0026agrave;\nl\u0027art de l\u0027ing\u0026eacute;nieur\u003c/i\u003e (Masson, 1986), instead of representing\nthe Householder transforms with u\u003csub\u003ek\u003c/sub\u003e unit vectors such that:\n\u003cpre\u003e\nH\u003csub\u003ek\u003c/sub\u003e \u003d I - 2u\u003csub\u003ek\u003c/sub\u003e.u\u003csub\u003ek\u003c/sub\u003e\u003csup\u003et\u003c/sup\u003e\n\u003c/pre\u003e\nwe use \u003csub\u003ek\u003c/sub\u003e non-unit vectors such that:\n\u003cpre\u003e\nH\u003csub\u003ek\u003c/sub\u003e \u003d I - beta\u003csub\u003ek\u003c/sub\u003ev\u003csub\u003ek\u003c/sub\u003e.v\u003csub\u003ek\u003c/sub\u003e\u003csup\u003et\u003c/sup\u003e\n\u003c/pre\u003e\nwhere v\u003csub\u003ek\u003c/sub\u003e \u003d a\u003csub\u003ek\u003c/sub\u003e - alpha\u003csub\u003ek\u003c/sub\u003e e\u003csub\u003ek\u003c/sub\u003e.\nThe beta\u003csub\u003ek\u003c/sub\u003e coefficients are provided upon exit as recomputing\nthem from the v\u003csub\u003ek\u003c/sub\u003e vectors would be costly.\u003c/p\u003e\n\u003cp\u003eThis decomposition handles rank deficient cases since the tranformations\nare performed in non-increasing columns norms order thanks to columns\npivoting. The diagonal elements of the R matrix are therefore also in\nnon-increasing absolute values order.\u003c/p\u003e\n\n@exception EstimationException if the decomposition cannot be performed\n"
          }
        }
      ]
    },
    "6d21abba54a9b3a0cca222abfacd26cabd88561c": {
      "type": "Yfilerename",
      "commitMessage": "added the estimation package from Mantissa\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/math/trunk@512061 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2/26/07, 2:59 PM",
      "commitName": "6d21abba54a9b3a0cca222abfacd26cabd88561c",
      "commitAuthor": "Luc Maisonobe",
      "commitDateOld": "2/26/07, 2:44 PM",
      "commitNameOld": "8ce6b30d7126356da4e18fb73f0bd836b921ce1c",
      "commitAuthorOld": "Luc Maisonobe",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private void qrDecomposition() {\n    for (int k \u003d 0; k \u003c cols; ++k) {\n        permutation[k] \u003d k;\n        double norm2 \u003d 0;\n        for (int index \u003d k; index \u003c jacobian.length; index +\u003d cols) {\n            double akk \u003d jacobian[index];\n            norm2 +\u003d akk * akk;\n        }\n        jacNorm[k] \u003d Math.sqrt(norm2);\n    }\n    for (int k \u003d 0; k \u003c cols; ++k) {\n        int nextColumn \u003d -1;\n        double ak2 \u003d Double.NEGATIVE_INFINITY;\n        for (int i \u003d k; i \u003c cols; ++i) {\n            double norm2 \u003d 0;\n            int iDiag \u003d k * cols + permutation[i];\n            for (int index \u003d iDiag; index \u003c jacobian.length; index +\u003d cols) {\n                double aki \u003d jacobian[index];\n                norm2 +\u003d aki * aki;\n            }\n            if (norm2 \u003e ak2) {\n                nextColumn \u003d i;\n                ak2 \u003d norm2;\n            }\n        }\n        if (ak2 \u003d\u003d 0) {\n            rank \u003d k;\n            return;\n        }\n        int pk \u003d permutation[nextColumn];\n        permutation[nextColumn] \u003d permutation[k];\n        permutation[k] \u003d pk;\n        int kDiag \u003d k * cols + pk;\n        double akk \u003d jacobian[kDiag];\n        double alpha \u003d (akk \u003e 0) ? -Math.sqrt(ak2) : Math.sqrt(ak2);\n        double betak \u003d 1.0 / (ak2 - akk * alpha);\n        beta[pk] \u003d betak;\n        diagR[pk] \u003d alpha;\n        jacobian[kDiag] -\u003d alpha;\n        for (int dk \u003d cols - 1 - k; dk \u003e 0; --dk) {\n            int dkp \u003d permutation[k + dk] - pk;\n            double gamma \u003d 0;\n            for (int index \u003d kDiag; index \u003c jacobian.length; index +\u003d cols) {\n                gamma +\u003d jacobian[index] * jacobian[index + dkp];\n            }\n            gamma *\u003d betak;\n            for (int index \u003d kDiag; index \u003c jacobian.length; index +\u003d cols) {\n                jacobian[index + dkp] -\u003d gamma * jacobian[index];\n            }\n        }\n    }\n    rank \u003d solvedCols;\n}",
      "path": "src/java/org/apache/commons/math/estimation/LevenbergMarquardtEstimator.java",
      "functionStartLine": 807,
      "functionName": "qrDecomposition",
      "functionAnnotation": "",
      "functionDoc": "Decompose a matrix A as A.P \u003d Q.R using Householder transforms.\n\u003cp\u003eAs suggested in the P. Lascaux and R. Theodor book\n\u003ci\u003eAnalyse num\u0026eacute;rique matricielle appliqu\u0026eacute;e \u0026agrave;\nl\u0027art de l\u0027ing\u0026eacute;nieur\u003c/i\u003e (Masson, 1986), instead of representing\nthe Householder transforms with u\u003csub\u003ek\u003c/sub\u003e unit vectors such that:\n\u003cpre\u003e\nH\u003csub\u003ek\u003c/sub\u003e \u003d I - 2u\u003csub\u003ek\u003c/sub\u003e.u\u003csub\u003ek\u003c/sub\u003e\u003csup\u003et\u003c/sup\u003e\n\u003c/pre\u003e\nwe use \u003csub\u003ek\u003c/sub\u003e non-unit vectors such that:\n\u003cpre\u003e\nH\u003csub\u003ek\u003c/sub\u003e \u003d I - beta\u003csub\u003ek\u003c/sub\u003ev\u003csub\u003ek\u003c/sub\u003e.v\u003csub\u003ek\u003c/sub\u003e\u003csup\u003et\u003c/sup\u003e\n\u003c/pre\u003e\nwhere v\u003csub\u003ek\u003c/sub\u003e \u003d a\u003csub\u003ek\u003c/sub\u003e - alpha\u003csub\u003ek\u003c/sub\u003e e\u003csub\u003ek\u003c/sub\u003e.\nThe beta\u003csub\u003ek\u003c/sub\u003e coefficients are provided upon exit as recomputing\nthem from the v\u003csub\u003ek\u003c/sub\u003e vectors would be costly.\u003c/p\u003e\n\u003cp\u003eThis decomposition handles rank deficient cases since the tranformations\nare performed in non-increasing columns norms order thanks to columns\npivoting. The diagonal elements of the R matrix are therefore also in\nnon-increasing absolute values order.\u003c/p\u003e\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/mantissa/src/org/spaceroots/mantissa/estimation/LevenbergMarquardtEstimator.java",
        "newPath": "src/java/org/apache/commons/math/estimation/LevenbergMarquardtEstimator.java"
      }
    },
    "89ac173c2b467e6289df0e62f2a43ed1730fbad5": {
      "type": "Yintroduced",
      "commitMessage": "Initial commit\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/math/trunk@476930 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/19/06, 1:36 PM",
      "commitName": "89ac173c2b467e6289df0e62f2a43ed1730fbad5",
      "commitAuthor": "Phil Steitz",
      "diff": "@@ -0,0 +1,53 @@\n+private void qrDecomposition() {\n+    for (int k \u003d 0; k \u003c cols; ++k) {\n+        permutation[k] \u003d k;\n+        double norm2 \u003d 0;\n+        for (int index \u003d k; index \u003c jacobian.length; index +\u003d cols) {\n+            double akk \u003d jacobian[index];\n+            norm2 +\u003d akk * akk;\n+        }\n+        jacNorm[k] \u003d Math.sqrt(norm2);\n+    }\n+    for (int k \u003d 0; k \u003c cols; ++k) {\n+        int nextColumn \u003d -1;\n+        double ak2 \u003d Double.NEGATIVE_INFINITY;\n+        for (int i \u003d k; i \u003c cols; ++i) {\n+            double norm2 \u003d 0;\n+            int iDiag \u003d k * cols + permutation[i];\n+            for (int index \u003d iDiag; index \u003c jacobian.length; index +\u003d cols) {\n+                double aki \u003d jacobian[index];\n+                norm2 +\u003d aki * aki;\n+            }\n+            if (norm2 \u003e ak2) {\n+                nextColumn \u003d i;\n+                ak2 \u003d norm2;\n+            }\n+        }\n+        if (ak2 \u003d\u003d 0) {\n+            rank \u003d k;\n+            return;\n+        }\n+        int pk \u003d permutation[nextColumn];\n+        permutation[nextColumn] \u003d permutation[k];\n+        permutation[k] \u003d pk;\n+        int kDiag \u003d k * cols + pk;\n+        double akk \u003d jacobian[kDiag];\n+        double alpha \u003d (akk \u003e 0) ? -Math.sqrt(ak2) : Math.sqrt(ak2);\n+        double betak \u003d 1.0 / (ak2 - akk * alpha);\n+        beta[pk] \u003d betak;\n+        diagR[pk] \u003d alpha;\n+        jacobian[kDiag] -\u003d alpha;\n+        for (int dk \u003d cols - 1 - k; dk \u003e 0; --dk) {\n+            int dkp \u003d permutation[k + dk] - pk;\n+            double gamma \u003d 0;\n+            for (int index \u003d kDiag; index \u003c jacobian.length; index +\u003d cols) {\n+                gamma +\u003d jacobian[index] * jacobian[index + dkp];\n+            }\n+            gamma *\u003d betak;\n+            for (int index \u003d kDiag; index \u003c jacobian.length; index +\u003d cols) {\n+                jacobian[index + dkp] -\u003d gamma * jacobian[index];\n+            }\n+        }\n+    }\n+    rank \u003d solvedCols;\n+}\n\\ No newline at end of file\n",
      "actualSource": "private void qrDecomposition() {\n    for (int k \u003d 0; k \u003c cols; ++k) {\n        permutation[k] \u003d k;\n        double norm2 \u003d 0;\n        for (int index \u003d k; index \u003c jacobian.length; index +\u003d cols) {\n            double akk \u003d jacobian[index];\n            norm2 +\u003d akk * akk;\n        }\n        jacNorm[k] \u003d Math.sqrt(norm2);\n    }\n    for (int k \u003d 0; k \u003c cols; ++k) {\n        int nextColumn \u003d -1;\n        double ak2 \u003d Double.NEGATIVE_INFINITY;\n        for (int i \u003d k; i \u003c cols; ++i) {\n            double norm2 \u003d 0;\n            int iDiag \u003d k * cols + permutation[i];\n            for (int index \u003d iDiag; index \u003c jacobian.length; index +\u003d cols) {\n                double aki \u003d jacobian[index];\n                norm2 +\u003d aki * aki;\n            }\n            if (norm2 \u003e ak2) {\n                nextColumn \u003d i;\n                ak2 \u003d norm2;\n            }\n        }\n        if (ak2 \u003d\u003d 0) {\n            rank \u003d k;\n            return;\n        }\n        int pk \u003d permutation[nextColumn];\n        permutation[nextColumn] \u003d permutation[k];\n        permutation[k] \u003d pk;\n        int kDiag \u003d k * cols + pk;\n        double akk \u003d jacobian[kDiag];\n        double alpha \u003d (akk \u003e 0) ? -Math.sqrt(ak2) : Math.sqrt(ak2);\n        double betak \u003d 1.0 / (ak2 - akk * alpha);\n        beta[pk] \u003d betak;\n        diagR[pk] \u003d alpha;\n        jacobian[kDiag] -\u003d alpha;\n        for (int dk \u003d cols - 1 - k; dk \u003e 0; --dk) {\n            int dkp \u003d permutation[k + dk] - pk;\n            double gamma \u003d 0;\n            for (int index \u003d kDiag; index \u003c jacobian.length; index +\u003d cols) {\n                gamma +\u003d jacobian[index] * jacobian[index + dkp];\n            }\n            gamma *\u003d betak;\n            for (int index \u003d kDiag; index \u003c jacobian.length; index +\u003d cols) {\n                jacobian[index + dkp] -\u003d gamma * jacobian[index];\n            }\n        }\n    }\n    rank \u003d solvedCols;\n}",
      "path": "src/mantissa/src/org/spaceroots/mantissa/estimation/LevenbergMarquardtEstimator.java",
      "functionStartLine": 808,
      "functionName": "qrDecomposition",
      "functionAnnotation": "",
      "functionDoc": "Decompose a matrix A as A.P \u003d Q.R using Householder transforms.\n\u003cp\u003eAs suggested in the P. Lascaux and R. Theodor book\n\u003ci\u003eAnalyse num\u0026eacute;rique matricielle appliqu\u0026eacute;e \u0026agrave;\nl\u0027art de l\u0027ing\u0026eacute;nieur\u003c/i\u003e (Masson, 1986), instead of representing\nthe Householder transforms with u\u003csub\u003ek\u003c/sub\u003e unit vectors such that:\n\u003cpre\u003e\nH\u003csub\u003ek\u003c/sub\u003e \u003d I - 2u\u003csub\u003ek\u003c/sub\u003e.u\u003csub\u003ek\u003c/sub\u003e\u003csup\u003et\u003c/sup\u003e\n\u003c/pre\u003e\nwe use \u003csub\u003ek\u003c/sub\u003e non-unit vectors such that:\n\u003cpre\u003e\nH\u003csub\u003ek\u003c/sub\u003e \u003d I - beta\u003csub\u003ek\u003c/sub\u003ev\u003csub\u003ek\u003c/sub\u003e.v\u003csub\u003ek\u003c/sub\u003e\u003csup\u003et\u003c/sup\u003e\n\u003c/pre\u003e\nwhere v\u003csub\u003ek\u003c/sub\u003e \u003d a\u003csub\u003ek\u003c/sub\u003e - alpha\u003csub\u003ek\u003c/sub\u003e e\u003csub\u003ek\u003c/sub\u003e.\nThe beta\u003csub\u003ek\u003c/sub\u003e coefficients are provided upon exit as recomputing\nthem from the v\u003csub\u003ek\u003c/sub\u003e vectors would be costly.\u003c/p\u003e\n\u003cp\u003eThis decomposition handles rank deficient cases since the tranformations\nare performed in non-increasing columns norms order thanks to columns\npivoting. The diagonal elements of the R matrix are therefore also in\nnon-increasing absolute values order.\u003c/p\u003e\n"
    }
  }
}