{
  "origin": "codeshovel",
  "repositoryName": "Math-64b",
  "repositoryPath": "/tmp/Math-64b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "LevenbergMarquardtOptimizer.java",
  "functionName": "doOptimize",
  "functionId": "doOptimize",
  "sourceFilePath": "src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java",
  "functionAnnotation": "@Override",
  "functionDoc": "@inheritDoc}\n",
  "functionStartLine": 241,
  "functionEndLine": 469,
  "numCommitsSeen": 19,
  "timeTaken": 2864,
  "changeHistory": [
    "1eaea0b549f685bd416cef68faa3a137b9bb3519",
    "5908f8a7ae04be852b45b66ef6b12562b832cba8",
    "615ca9a000c253575e6f62bed87db6110b750834",
    "0905e8cf724b358277e219cbf1a06413faa48c9e",
    "d6a438e931412713e99624cf9ed74470f1040184",
    "9c8d2c79c1ef565337599849cd066ff63b8d5816",
    "ae6753dd5e4ce3b0ed9bd67f92d2d4e92587300f",
    "a7faf40b61f445d15d9a210b23fa0008b87e25e2",
    "8541f303370cec9a25f2b32b3d660b3f188913f0"
  ],
  "changeHistoryShort": {
    "1eaea0b549f685bd416cef68faa3a137b9bb3519": "Ybodychange",
    "5908f8a7ae04be852b45b66ef6b12562b832cba8": "Yformatchange",
    "615ca9a000c253575e6f62bed87db6110b750834": "Ybodychange",
    "0905e8cf724b358277e219cbf1a06413faa48c9e": "Ybodychange",
    "d6a438e931412713e99624cf9ed74470f1040184": "Yfilerename",
    "9c8d2c79c1ef565337599849cd066ff63b8d5816": "Yannotationchange",
    "ae6753dd5e4ce3b0ed9bd67f92d2d4e92587300f": "Ymultichange(Yexceptionschange,Ybodychange)",
    "a7faf40b61f445d15d9a210b23fa0008b87e25e2": "Ybodychange",
    "8541f303370cec9a25f2b32b3d660b3f188913f0": "Yintroduced"
  },
  "changeHistoryDetails": {
    "1eaea0b549f685bd416cef68faa3a137b9bb3519": {
      "type": "Ybodychange",
      "commitMessage": "changed the localization mechanism for error messages. The new system is based on an enum rather than on duplicated string literals.\nJIRA: MATH-361\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@955423 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "6/16/10, 4:03 PM",
      "commitName": "1eaea0b549f685bd416cef68faa3a137b9bb3519",
      "commitAuthor": "Luc Maisonobe",
      "commitDateOld": "6/6/10, 7:01 AM",
      "commitNameOld": "006e834bc3d18fc1d649392a606f4f291378c965",
      "commitAuthorOld": "Luc Maisonobe",
      "daysBetweenCommits": 10.38,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected VectorialPointValuePair doOptimize() throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n    solvedCols \u003d Math.min(rows, cols);\n    diagR \u003d new double[cols];\n    jacNorm \u003d new double[cols];\n    beta \u003d new double[cols];\n    permutation \u003d new int[cols];\n    lmDir \u003d new double[cols];\n    double delta \u003d 0;\n    double xNorm \u003d 0;\n    double[] diag \u003d new double[cols];\n    double[] oldX \u003d new double[cols];\n    double[] oldRes \u003d new double[rows];\n    double[] work1 \u003d new double[cols];\n    double[] work2 \u003d new double[cols];\n    double[] work3 \u003d new double[cols];\n    updateResidualsAndCost();\n    lmPar \u003d 0;\n    boolean firstIteration \u003d true;\n    VectorialPointValuePair current \u003d new VectorialPointValuePair(point, objective);\n    while (true) {\n        incrementIterationsCounter();\n        VectorialPointValuePair previous \u003d current;\n        updateJacobian();\n        qrDecomposition();\n        qTy(residuals);\n        for (int k \u003d 0; k \u003c solvedCols; ++k) {\n            int pk \u003d permutation[k];\n            jacobian[k][pk] \u003d diagR[pk];\n        }\n        if (firstIteration) {\n            xNorm \u003d 0;\n            for (int k \u003d 0; k \u003c cols; ++k) {\n                double dk \u003d jacNorm[k];\n                if (dk \u003d\u003d 0) {\n                    dk \u003d 1.0;\n                }\n                double xk \u003d dk * point[k];\n                xNorm +\u003d xk * xk;\n                diag[k] \u003d dk;\n            }\n            xNorm \u003d Math.sqrt(xNorm);\n            delta \u003d (xNorm \u003d\u003d 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n        }\n        double maxCosine \u003d 0;\n        if (cost !\u003d 0) {\n            for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                int pj \u003d permutation[j];\n                double s \u003d jacNorm[pj];\n                if (s !\u003d 0) {\n                    double sum \u003d 0;\n                    for (int i \u003d 0; i \u003c\u003d j; ++i) {\n                        sum +\u003d jacobian[i][pj] * residuals[i];\n                    }\n                    maxCosine \u003d Math.max(maxCosine, Math.abs(sum) / (s * cost));\n                }\n            }\n        }\n        if (maxCosine \u003c\u003d orthoTolerance) {\n            return current;\n        }\n        for (int j \u003d 0; j \u003c cols; ++j) {\n            diag[j] \u003d Math.max(diag[j], jacNorm[j]);\n        }\n        for (double ratio \u003d 0; ratio \u003c 1.0e-4; ) {\n            for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                int pj \u003d permutation[j];\n                oldX[pj] \u003d point[pj];\n            }\n            double previousCost \u003d cost;\n            double[] tmpVec \u003d residuals;\n            residuals \u003d oldRes;\n            oldRes \u003d tmpVec;\n            determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n            double lmNorm \u003d 0;\n            for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                int pj \u003d permutation[j];\n                lmDir[pj] \u003d -lmDir[pj];\n                point[pj] \u003d oldX[pj] + lmDir[pj];\n                double s \u003d diag[pj] * lmDir[pj];\n                lmNorm +\u003d s * s;\n            }\n            lmNorm \u003d Math.sqrt(lmNorm);\n            if (firstIteration) {\n                delta \u003d Math.min(delta, lmNorm);\n            }\n            updateResidualsAndCost();\n            current \u003d new VectorialPointValuePair(point, objective);\n            double actRed \u003d -1.0;\n            if (0.1 * cost \u003c previousCost) {\n                double r \u003d cost / previousCost;\n                actRed \u003d 1.0 - r * r;\n            }\n            for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                int pj \u003d permutation[j];\n                double dirJ \u003d lmDir[pj];\n                work1[j] \u003d 0;\n                for (int i \u003d 0; i \u003c\u003d j; ++i) {\n                    work1[i] +\u003d jacobian[i][pj] * dirJ;\n                }\n            }\n            double coeff1 \u003d 0;\n            for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                coeff1 +\u003d work1[j] * work1[j];\n            }\n            double pc2 \u003d previousCost * previousCost;\n            coeff1 \u003d coeff1 / pc2;\n            double coeff2 \u003d lmPar * lmNorm * lmNorm / pc2;\n            double preRed \u003d coeff1 + 2 * coeff2;\n            double dirDer \u003d -(coeff1 + coeff2);\n            ratio \u003d (preRed \u003d\u003d 0) ? 0 : (actRed / preRed);\n            if (ratio \u003c\u003d 0.25) {\n                double tmp \u003d (actRed \u003c 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n                if ((0.1 * cost \u003e\u003d previousCost) || (tmp \u003c 0.1)) {\n                    tmp \u003d 0.1;\n                }\n                delta \u003d tmp * Math.min(delta, 10.0 * lmNorm);\n                lmPar /\u003d tmp;\n            } else if ((lmPar \u003d\u003d 0) || (ratio \u003e\u003d 0.75)) {\n                delta \u003d 2 * lmNorm;\n                lmPar *\u003d 0.5;\n            }\n            if (ratio \u003e\u003d 1.0e-4) {\n                firstIteration \u003d false;\n                xNorm \u003d 0;\n                for (int k \u003d 0; k \u003c cols; ++k) {\n                    double xK \u003d diag[k] * point[k];\n                    xNorm +\u003d xK * xK;\n                }\n                xNorm \u003d Math.sqrt(xNorm);\n            } else {\n                cost \u003d previousCost;\n                for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                    int pj \u003d permutation[j];\n                    point[pj] \u003d oldX[pj];\n                }\n                tmpVec \u003d residuals;\n                residuals \u003d oldRes;\n                oldRes \u003d tmpVec;\n            }\n            if (checker !\u003d null) {\n                if (checker.converged(getIterations(), previous, current)) {\n                    return current;\n                }\n            } else {\n                if (((Math.abs(actRed) \u003c\u003d costRelativeTolerance) \u0026\u0026 (preRed \u003c\u003d costRelativeTolerance) \u0026\u0026 (ratio \u003c\u003d 2.0)) || (delta \u003c\u003d parRelativeTolerance * xNorm)) {\n                    return current;\n                }\n            }\n            if ((Math.abs(actRed) \u003c\u003d 2.2204e-16) \u0026\u0026 (preRed \u003c\u003d 2.2204e-16) \u0026\u0026 (ratio \u003c\u003d 2.0)) {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance);\n            } else if (delta \u003c\u003d 2.2204e-16 * xNorm) {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance);\n            } else if (maxCosine \u003c\u003d 2.2204e-16) {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance);\n            }\n        }\n    }\n}",
      "path": "src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java",
      "functionStartLine": 241,
      "functionName": "doOptimize",
      "functionAnnotation": "@Override",
      "functionDoc": "@inheritDoc}\n",
      "diff": "@@ -1,159 +1,159 @@\n @Override\n protected VectorialPointValuePair doOptimize() throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n     solvedCols \u003d Math.min(rows, cols);\n     diagR \u003d new double[cols];\n     jacNorm \u003d new double[cols];\n     beta \u003d new double[cols];\n     permutation \u003d new int[cols];\n     lmDir \u003d new double[cols];\n     double delta \u003d 0;\n     double xNorm \u003d 0;\n     double[] diag \u003d new double[cols];\n     double[] oldX \u003d new double[cols];\n     double[] oldRes \u003d new double[rows];\n     double[] work1 \u003d new double[cols];\n     double[] work2 \u003d new double[cols];\n     double[] work3 \u003d new double[cols];\n     updateResidualsAndCost();\n     lmPar \u003d 0;\n     boolean firstIteration \u003d true;\n     VectorialPointValuePair current \u003d new VectorialPointValuePair(point, objective);\n     while (true) {\n         incrementIterationsCounter();\n         VectorialPointValuePair previous \u003d current;\n         updateJacobian();\n         qrDecomposition();\n         qTy(residuals);\n         for (int k \u003d 0; k \u003c solvedCols; ++k) {\n             int pk \u003d permutation[k];\n             jacobian[k][pk] \u003d diagR[pk];\n         }\n         if (firstIteration) {\n             xNorm \u003d 0;\n             for (int k \u003d 0; k \u003c cols; ++k) {\n                 double dk \u003d jacNorm[k];\n                 if (dk \u003d\u003d 0) {\n                     dk \u003d 1.0;\n                 }\n                 double xk \u003d dk * point[k];\n                 xNorm +\u003d xk * xk;\n                 diag[k] \u003d dk;\n             }\n             xNorm \u003d Math.sqrt(xNorm);\n             delta \u003d (xNorm \u003d\u003d 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n         }\n         double maxCosine \u003d 0;\n         if (cost !\u003d 0) {\n             for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                 int pj \u003d permutation[j];\n                 double s \u003d jacNorm[pj];\n                 if (s !\u003d 0) {\n                     double sum \u003d 0;\n                     for (int i \u003d 0; i \u003c\u003d j; ++i) {\n                         sum +\u003d jacobian[i][pj] * residuals[i];\n                     }\n                     maxCosine \u003d Math.max(maxCosine, Math.abs(sum) / (s * cost));\n                 }\n             }\n         }\n         if (maxCosine \u003c\u003d orthoTolerance) {\n             return current;\n         }\n         for (int j \u003d 0; j \u003c cols; ++j) {\n             diag[j] \u003d Math.max(diag[j], jacNorm[j]);\n         }\n         for (double ratio \u003d 0; ratio \u003c 1.0e-4; ) {\n             for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                 int pj \u003d permutation[j];\n                 oldX[pj] \u003d point[pj];\n             }\n             double previousCost \u003d cost;\n             double[] tmpVec \u003d residuals;\n             residuals \u003d oldRes;\n             oldRes \u003d tmpVec;\n             determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n             double lmNorm \u003d 0;\n             for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                 int pj \u003d permutation[j];\n                 lmDir[pj] \u003d -lmDir[pj];\n                 point[pj] \u003d oldX[pj] + lmDir[pj];\n                 double s \u003d diag[pj] * lmDir[pj];\n                 lmNorm +\u003d s * s;\n             }\n             lmNorm \u003d Math.sqrt(lmNorm);\n             if (firstIteration) {\n                 delta \u003d Math.min(delta, lmNorm);\n             }\n             updateResidualsAndCost();\n             current \u003d new VectorialPointValuePair(point, objective);\n             double actRed \u003d -1.0;\n             if (0.1 * cost \u003c previousCost) {\n                 double r \u003d cost / previousCost;\n                 actRed \u003d 1.0 - r * r;\n             }\n             for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                 int pj \u003d permutation[j];\n                 double dirJ \u003d lmDir[pj];\n                 work1[j] \u003d 0;\n                 for (int i \u003d 0; i \u003c\u003d j; ++i) {\n                     work1[i] +\u003d jacobian[i][pj] * dirJ;\n                 }\n             }\n             double coeff1 \u003d 0;\n             for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                 coeff1 +\u003d work1[j] * work1[j];\n             }\n             double pc2 \u003d previousCost * previousCost;\n             coeff1 \u003d coeff1 / pc2;\n             double coeff2 \u003d lmPar * lmNorm * lmNorm / pc2;\n             double preRed \u003d coeff1 + 2 * coeff2;\n             double dirDer \u003d -(coeff1 + coeff2);\n             ratio \u003d (preRed \u003d\u003d 0) ? 0 : (actRed / preRed);\n             if (ratio \u003c\u003d 0.25) {\n                 double tmp \u003d (actRed \u003c 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n                 if ((0.1 * cost \u003e\u003d previousCost) || (tmp \u003c 0.1)) {\n                     tmp \u003d 0.1;\n                 }\n                 delta \u003d tmp * Math.min(delta, 10.0 * lmNorm);\n                 lmPar /\u003d tmp;\n             } else if ((lmPar \u003d\u003d 0) || (ratio \u003e\u003d 0.75)) {\n                 delta \u003d 2 * lmNorm;\n                 lmPar *\u003d 0.5;\n             }\n             if (ratio \u003e\u003d 1.0e-4) {\n                 firstIteration \u003d false;\n                 xNorm \u003d 0;\n                 for (int k \u003d 0; k \u003c cols; ++k) {\n                     double xK \u003d diag[k] * point[k];\n                     xNorm +\u003d xK * xK;\n                 }\n                 xNorm \u003d Math.sqrt(xNorm);\n             } else {\n                 cost \u003d previousCost;\n                 for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                     int pj \u003d permutation[j];\n                     point[pj] \u003d oldX[pj];\n                 }\n                 tmpVec \u003d residuals;\n                 residuals \u003d oldRes;\n                 oldRes \u003d tmpVec;\n             }\n             if (checker !\u003d null) {\n                 if (checker.converged(getIterations(), previous, current)) {\n                     return current;\n                 }\n             } else {\n                 if (((Math.abs(actRed) \u003c\u003d costRelativeTolerance) \u0026\u0026 (preRed \u003c\u003d costRelativeTolerance) \u0026\u0026 (ratio \u003c\u003d 2.0)) || (delta \u003c\u003d parRelativeTolerance * xNorm)) {\n                     return current;\n                 }\n             }\n             if ((Math.abs(actRed) \u003c\u003d 2.2204e-16) \u0026\u0026 (preRed \u003c\u003d 2.2204e-16) \u0026\u0026 (ratio \u003c\u003d 2.0)) {\n-                throw new OptimizationException(\"cost relative tolerance is too small ({0}),\" + \" no further reduction in the\" + \" sum of squares is possible\", costRelativeTolerance);\n+                throw new OptimizationException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance);\n             } else if (delta \u003c\u003d 2.2204e-16 * xNorm) {\n-                throw new OptimizationException(\"parameters relative tolerance is too small\" + \" ({0}), no further improvement in\" + \" the approximate solution is possible\", parRelativeTolerance);\n+                throw new OptimizationException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance);\n             } else if (maxCosine \u003c\u003d 2.2204e-16) {\n-                throw new OptimizationException(\"orthogonality tolerance is too small ({0}),\" + \" solution is orthogonal to the jacobian\", orthoTolerance);\n+                throw new OptimizationException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance);\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5908f8a7ae04be852b45b66ef6b12562b832cba8": {
      "type": "Yformatchange",
      "commitMessage": "Eliminated trailing spaces.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@949555 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "5/30/10, 11:34 AM",
      "commitName": "5908f8a7ae04be852b45b66ef6b12562b832cba8",
      "commitAuthor": "Phil Steitz",
      "commitDateOld": "5/29/10, 11:15 AM",
      "commitNameOld": "615ca9a000c253575e6f62bed87db6110b750834",
      "commitAuthorOld": "Luc Maisonobe",
      "daysBetweenCommits": 1.01,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected VectorialPointValuePair doOptimize() throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n    solvedCols \u003d Math.min(rows, cols);\n    diagR \u003d new double[cols];\n    jacNorm \u003d new double[cols];\n    beta \u003d new double[cols];\n    permutation \u003d new int[cols];\n    lmDir \u003d new double[cols];\n    double delta \u003d 0;\n    double xNorm \u003d 0;\n    double[] diag \u003d new double[cols];\n    double[] oldX \u003d new double[cols];\n    double[] oldRes \u003d new double[rows];\n    double[] work1 \u003d new double[cols];\n    double[] work2 \u003d new double[cols];\n    double[] work3 \u003d new double[cols];\n    updateResidualsAndCost();\n    lmPar \u003d 0;\n    boolean firstIteration \u003d true;\n    VectorialPointValuePair current \u003d new VectorialPointValuePair(point, objective);\n    while (true) {\n        incrementIterationsCounter();\n        VectorialPointValuePair previous \u003d current;\n        updateJacobian();\n        qrDecomposition();\n        qTy(residuals);\n        for (int k \u003d 0; k \u003c solvedCols; ++k) {\n            int pk \u003d permutation[k];\n            jacobian[k][pk] \u003d diagR[pk];\n        }\n        if (firstIteration) {\n            xNorm \u003d 0;\n            for (int k \u003d 0; k \u003c cols; ++k) {\n                double dk \u003d jacNorm[k];\n                if (dk \u003d\u003d 0) {\n                    dk \u003d 1.0;\n                }\n                double xk \u003d dk * point[k];\n                xNorm +\u003d xk * xk;\n                diag[k] \u003d dk;\n            }\n            xNorm \u003d Math.sqrt(xNorm);\n            delta \u003d (xNorm \u003d\u003d 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n        }\n        double maxCosine \u003d 0;\n        if (cost !\u003d 0) {\n            for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                int pj \u003d permutation[j];\n                double s \u003d jacNorm[pj];\n                if (s !\u003d 0) {\n                    double sum \u003d 0;\n                    for (int i \u003d 0; i \u003c\u003d j; ++i) {\n                        sum +\u003d jacobian[i][pj] * residuals[i];\n                    }\n                    maxCosine \u003d Math.max(maxCosine, Math.abs(sum) / (s * cost));\n                }\n            }\n        }\n        if (maxCosine \u003c\u003d orthoTolerance) {\n            return current;\n        }\n        for (int j \u003d 0; j \u003c cols; ++j) {\n            diag[j] \u003d Math.max(diag[j], jacNorm[j]);\n        }\n        for (double ratio \u003d 0; ratio \u003c 1.0e-4; ) {\n            for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                int pj \u003d permutation[j];\n                oldX[pj] \u003d point[pj];\n            }\n            double previousCost \u003d cost;\n            double[] tmpVec \u003d residuals;\n            residuals \u003d oldRes;\n            oldRes \u003d tmpVec;\n            determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n            double lmNorm \u003d 0;\n            for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                int pj \u003d permutation[j];\n                lmDir[pj] \u003d -lmDir[pj];\n                point[pj] \u003d oldX[pj] + lmDir[pj];\n                double s \u003d diag[pj] * lmDir[pj];\n                lmNorm +\u003d s * s;\n            }\n            lmNorm \u003d Math.sqrt(lmNorm);\n            if (firstIteration) {\n                delta \u003d Math.min(delta, lmNorm);\n            }\n            updateResidualsAndCost();\n            current \u003d new VectorialPointValuePair(point, objective);\n            double actRed \u003d -1.0;\n            if (0.1 * cost \u003c previousCost) {\n                double r \u003d cost / previousCost;\n                actRed \u003d 1.0 - r * r;\n            }\n            for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                int pj \u003d permutation[j];\n                double dirJ \u003d lmDir[pj];\n                work1[j] \u003d 0;\n                for (int i \u003d 0; i \u003c\u003d j; ++i) {\n                    work1[i] +\u003d jacobian[i][pj] * dirJ;\n                }\n            }\n            double coeff1 \u003d 0;\n            for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                coeff1 +\u003d work1[j] * work1[j];\n            }\n            double pc2 \u003d previousCost * previousCost;\n            coeff1 \u003d coeff1 / pc2;\n            double coeff2 \u003d lmPar * lmNorm * lmNorm / pc2;\n            double preRed \u003d coeff1 + 2 * coeff2;\n            double dirDer \u003d -(coeff1 + coeff2);\n            ratio \u003d (preRed \u003d\u003d 0) ? 0 : (actRed / preRed);\n            if (ratio \u003c\u003d 0.25) {\n                double tmp \u003d (actRed \u003c 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n                if ((0.1 * cost \u003e\u003d previousCost) || (tmp \u003c 0.1)) {\n                    tmp \u003d 0.1;\n                }\n                delta \u003d tmp * Math.min(delta, 10.0 * lmNorm);\n                lmPar /\u003d tmp;\n            } else if ((lmPar \u003d\u003d 0) || (ratio \u003e\u003d 0.75)) {\n                delta \u003d 2 * lmNorm;\n                lmPar *\u003d 0.5;\n            }\n            if (ratio \u003e\u003d 1.0e-4) {\n                firstIteration \u003d false;\n                xNorm \u003d 0;\n                for (int k \u003d 0; k \u003c cols; ++k) {\n                    double xK \u003d diag[k] * point[k];\n                    xNorm +\u003d xK * xK;\n                }\n                xNorm \u003d Math.sqrt(xNorm);\n            } else {\n                cost \u003d previousCost;\n                for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                    int pj \u003d permutation[j];\n                    point[pj] \u003d oldX[pj];\n                }\n                tmpVec \u003d residuals;\n                residuals \u003d oldRes;\n                oldRes \u003d tmpVec;\n            }\n            if (checker !\u003d null) {\n                if (checker.converged(getIterations(), previous, current)) {\n                    return current;\n                }\n            } else {\n                if (((Math.abs(actRed) \u003c\u003d costRelativeTolerance) \u0026\u0026 (preRed \u003c\u003d costRelativeTolerance) \u0026\u0026 (ratio \u003c\u003d 2.0)) || (delta \u003c\u003d parRelativeTolerance * xNorm)) {\n                    return current;\n                }\n            }\n            if ((Math.abs(actRed) \u003c\u003d 2.2204e-16) \u0026\u0026 (preRed \u003c\u003d 2.2204e-16) \u0026\u0026 (ratio \u003c\u003d 2.0)) {\n                throw new OptimizationException(\"cost relative tolerance is too small ({0}),\" + \" no further reduction in the\" + \" sum of squares is possible\", costRelativeTolerance);\n            } else if (delta \u003c\u003d 2.2204e-16 * xNorm) {\n                throw new OptimizationException(\"parameters relative tolerance is too small\" + \" ({0}), no further improvement in\" + \" the approximate solution is possible\", parRelativeTolerance);\n            } else if (maxCosine \u003c\u003d 2.2204e-16) {\n                throw new OptimizationException(\"orthogonality tolerance is too small ({0}),\" + \" solution is orthogonal to the jacobian\", orthoTolerance);\n            }\n        }\n    }\n}",
      "path": "src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java",
      "functionStartLine": 221,
      "functionName": "doOptimize",
      "functionAnnotation": "@Override",
      "functionDoc": "@inheritDoc}\n",
      "diff": "",
      "extendedDetails": {}
    },
    "615ca9a000c253575e6f62bed87db6110b750834": {
      "type": "Ybodychange",
      "commitMessage": "Fixed Levenberg-Marquardt optimizer that did not use the vectorial convergence checker.\nNow this optimizer can use either the general vectorial convergence checker or its own specialized convergence settings.\nMinor changes had to be introduced in the test data, they have been validated\nJIRA: MATH-362\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@949433 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "5/29/10, 11:15 AM",
      "commitName": "615ca9a000c253575e6f62bed87db6110b750834",
      "commitAuthor": "Luc Maisonobe",
      "commitDateOld": "10/16/09, 7:51 AM",
      "commitNameOld": "0905e8cf724b358277e219cbf1a06413faa48c9e",
      "commitAuthorOld": "Luc Maisonobe",
      "daysBetweenCommits": 225.14,
      "commitsBetweenForRepo": 223,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected VectorialPointValuePair doOptimize() throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n    solvedCols \u003d Math.min(rows, cols);\n    diagR \u003d new double[cols];\n    jacNorm \u003d new double[cols];\n    beta \u003d new double[cols];\n    permutation \u003d new int[cols];\n    lmDir \u003d new double[cols];\n    double delta \u003d 0;\n    double xNorm \u003d 0;\n    double[] diag \u003d new double[cols];\n    double[] oldX \u003d new double[cols];\n    double[] oldRes \u003d new double[rows];\n    double[] work1 \u003d new double[cols];\n    double[] work2 \u003d new double[cols];\n    double[] work3 \u003d new double[cols];\n    updateResidualsAndCost();\n    lmPar \u003d 0;\n    boolean firstIteration \u003d true;\n    VectorialPointValuePair current \u003d new VectorialPointValuePair(point, objective);\n    while (true) {\n        incrementIterationsCounter();\n        VectorialPointValuePair previous \u003d current;\n        updateJacobian();\n        qrDecomposition();\n        qTy(residuals);\n        for (int k \u003d 0; k \u003c solvedCols; ++k) {\n            int pk \u003d permutation[k];\n            jacobian[k][pk] \u003d diagR[pk];\n        }\n        if (firstIteration) {\n            xNorm \u003d 0;\n            for (int k \u003d 0; k \u003c cols; ++k) {\n                double dk \u003d jacNorm[k];\n                if (dk \u003d\u003d 0) {\n                    dk \u003d 1.0;\n                }\n                double xk \u003d dk * point[k];\n                xNorm +\u003d xk * xk;\n                diag[k] \u003d dk;\n            }\n            xNorm \u003d Math.sqrt(xNorm);\n            delta \u003d (xNorm \u003d\u003d 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n        }\n        double maxCosine \u003d 0;\n        if (cost !\u003d 0) {\n            for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                int pj \u003d permutation[j];\n                double s \u003d jacNorm[pj];\n                if (s !\u003d 0) {\n                    double sum \u003d 0;\n                    for (int i \u003d 0; i \u003c\u003d j; ++i) {\n                        sum +\u003d jacobian[i][pj] * residuals[i];\n                    }\n                    maxCosine \u003d Math.max(maxCosine, Math.abs(sum) / (s * cost));\n                }\n            }\n        }\n        if (maxCosine \u003c\u003d orthoTolerance) {\n            return current;\n        }\n        for (int j \u003d 0; j \u003c cols; ++j) {\n            diag[j] \u003d Math.max(diag[j], jacNorm[j]);\n        }\n        for (double ratio \u003d 0; ratio \u003c 1.0e-4; ) {\n            for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                int pj \u003d permutation[j];\n                oldX[pj] \u003d point[pj];\n            }\n            double previousCost \u003d cost;\n            double[] tmpVec \u003d residuals;\n            residuals \u003d oldRes;\n            oldRes \u003d tmpVec;\n            determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n            double lmNorm \u003d 0;\n            for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                int pj \u003d permutation[j];\n                lmDir[pj] \u003d -lmDir[pj];\n                point[pj] \u003d oldX[pj] + lmDir[pj];\n                double s \u003d diag[pj] * lmDir[pj];\n                lmNorm +\u003d s * s;\n            }\n            lmNorm \u003d Math.sqrt(lmNorm);\n            if (firstIteration) {\n                delta \u003d Math.min(delta, lmNorm);\n            }\n            updateResidualsAndCost();\n            current \u003d new VectorialPointValuePair(point, objective);\n            double actRed \u003d -1.0;\n            if (0.1 * cost \u003c previousCost) {\n                double r \u003d cost / previousCost;\n                actRed \u003d 1.0 - r * r;\n            }\n            for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                int pj \u003d permutation[j];\n                double dirJ \u003d lmDir[pj];\n                work1[j] \u003d 0;\n                for (int i \u003d 0; i \u003c\u003d j; ++i) {\n                    work1[i] +\u003d jacobian[i][pj] * dirJ;\n                }\n            }\n            double coeff1 \u003d 0;\n            for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                coeff1 +\u003d work1[j] * work1[j];\n            }\n            double pc2 \u003d previousCost * previousCost;\n            coeff1 \u003d coeff1 / pc2;\n            double coeff2 \u003d lmPar * lmNorm * lmNorm / pc2;\n            double preRed \u003d coeff1 + 2 * coeff2;\n            double dirDer \u003d -(coeff1 + coeff2);\n            ratio \u003d (preRed \u003d\u003d 0) ? 0 : (actRed / preRed);\n            if (ratio \u003c\u003d 0.25) {\n                double tmp \u003d (actRed \u003c 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n                if ((0.1 * cost \u003e\u003d previousCost) || (tmp \u003c 0.1)) {\n                    tmp \u003d 0.1;\n                }\n                delta \u003d tmp * Math.min(delta, 10.0 * lmNorm);\n                lmPar /\u003d tmp;\n            } else if ((lmPar \u003d\u003d 0) || (ratio \u003e\u003d 0.75)) {\n                delta \u003d 2 * lmNorm;\n                lmPar *\u003d 0.5;\n            }\n            if (ratio \u003e\u003d 1.0e-4) {\n                firstIteration \u003d false;\n                xNorm \u003d 0;\n                for (int k \u003d 0; k \u003c cols; ++k) {\n                    double xK \u003d diag[k] * point[k];\n                    xNorm +\u003d xK * xK;\n                }\n                xNorm \u003d Math.sqrt(xNorm);\n            } else {\n                cost \u003d previousCost;\n                for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                    int pj \u003d permutation[j];\n                    point[pj] \u003d oldX[pj];\n                }\n                tmpVec \u003d residuals;\n                residuals \u003d oldRes;\n                oldRes \u003d tmpVec;\n            }\n            if (checker !\u003d null) {\n                if (checker.converged(getIterations(), previous, current)) {\n                    return current;\n                }\n            } else {\n                if (((Math.abs(actRed) \u003c\u003d costRelativeTolerance) \u0026\u0026 (preRed \u003c\u003d costRelativeTolerance) \u0026\u0026 (ratio \u003c\u003d 2.0)) || (delta \u003c\u003d parRelativeTolerance * xNorm)) {\n                    return current;\n                }\n            }\n            if ((Math.abs(actRed) \u003c\u003d 2.2204e-16) \u0026\u0026 (preRed \u003c\u003d 2.2204e-16) \u0026\u0026 (ratio \u003c\u003d 2.0)) {\n                throw new OptimizationException(\"cost relative tolerance is too small ({0}),\" + \" no further reduction in the\" + \" sum of squares is possible\", costRelativeTolerance);\n            } else if (delta \u003c\u003d 2.2204e-16 * xNorm) {\n                throw new OptimizationException(\"parameters relative tolerance is too small\" + \" ({0}), no further improvement in\" + \" the approximate solution is possible\", parRelativeTolerance);\n            } else if (maxCosine \u003c\u003d 2.2204e-16) {\n                throw new OptimizationException(\"orthogonality tolerance is too small ({0}),\" + \" solution is orthogonal to the jacobian\", orthoTolerance);\n            }\n        }\n    }\n}",
      "path": "src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java",
      "functionStartLine": 221,
      "functionName": "doOptimize",
      "functionAnnotation": "@Override",
      "functionDoc": "@inheritDoc}\n",
      "diff": "@@ -1,150 +1,159 @@\n @Override\n protected VectorialPointValuePair doOptimize() throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n     solvedCols \u003d Math.min(rows, cols);\n     diagR \u003d new double[cols];\n     jacNorm \u003d new double[cols];\n     beta \u003d new double[cols];\n     permutation \u003d new int[cols];\n     lmDir \u003d new double[cols];\n     double delta \u003d 0;\n     double xNorm \u003d 0;\n     double[] diag \u003d new double[cols];\n     double[] oldX \u003d new double[cols];\n     double[] oldRes \u003d new double[rows];\n     double[] work1 \u003d new double[cols];\n     double[] work2 \u003d new double[cols];\n     double[] work3 \u003d new double[cols];\n     updateResidualsAndCost();\n     lmPar \u003d 0;\n     boolean firstIteration \u003d true;\n+    VectorialPointValuePair current \u003d new VectorialPointValuePair(point, objective);\n     while (true) {\n         incrementIterationsCounter();\n+        VectorialPointValuePair previous \u003d current;\n         updateJacobian();\n         qrDecomposition();\n         qTy(residuals);\n         for (int k \u003d 0; k \u003c solvedCols; ++k) {\n             int pk \u003d permutation[k];\n             jacobian[k][pk] \u003d diagR[pk];\n         }\n         if (firstIteration) {\n             xNorm \u003d 0;\n             for (int k \u003d 0; k \u003c cols; ++k) {\n                 double dk \u003d jacNorm[k];\n                 if (dk \u003d\u003d 0) {\n                     dk \u003d 1.0;\n                 }\n                 double xk \u003d dk * point[k];\n                 xNorm +\u003d xk * xk;\n                 diag[k] \u003d dk;\n             }\n             xNorm \u003d Math.sqrt(xNorm);\n             delta \u003d (xNorm \u003d\u003d 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n         }\n         double maxCosine \u003d 0;\n         if (cost !\u003d 0) {\n             for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                 int pj \u003d permutation[j];\n                 double s \u003d jacNorm[pj];\n                 if (s !\u003d 0) {\n                     double sum \u003d 0;\n                     for (int i \u003d 0; i \u003c\u003d j; ++i) {\n                         sum +\u003d jacobian[i][pj] * residuals[i];\n                     }\n                     maxCosine \u003d Math.max(maxCosine, Math.abs(sum) / (s * cost));\n                 }\n             }\n         }\n         if (maxCosine \u003c\u003d orthoTolerance) {\n-            return new VectorialPointValuePair(point, objective);\n+            return current;\n         }\n         for (int j \u003d 0; j \u003c cols; ++j) {\n             diag[j] \u003d Math.max(diag[j], jacNorm[j]);\n         }\n         for (double ratio \u003d 0; ratio \u003c 1.0e-4; ) {\n             for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                 int pj \u003d permutation[j];\n                 oldX[pj] \u003d point[pj];\n             }\n             double previousCost \u003d cost;\n             double[] tmpVec \u003d residuals;\n             residuals \u003d oldRes;\n             oldRes \u003d tmpVec;\n             determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n             double lmNorm \u003d 0;\n             for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                 int pj \u003d permutation[j];\n                 lmDir[pj] \u003d -lmDir[pj];\n                 point[pj] \u003d oldX[pj] + lmDir[pj];\n                 double s \u003d diag[pj] * lmDir[pj];\n                 lmNorm +\u003d s * s;\n             }\n             lmNorm \u003d Math.sqrt(lmNorm);\n             if (firstIteration) {\n                 delta \u003d Math.min(delta, lmNorm);\n             }\n             updateResidualsAndCost();\n+            current \u003d new VectorialPointValuePair(point, objective);\n             double actRed \u003d -1.0;\n             if (0.1 * cost \u003c previousCost) {\n                 double r \u003d cost / previousCost;\n                 actRed \u003d 1.0 - r * r;\n             }\n             for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                 int pj \u003d permutation[j];\n                 double dirJ \u003d lmDir[pj];\n                 work1[j] \u003d 0;\n                 for (int i \u003d 0; i \u003c\u003d j; ++i) {\n                     work1[i] +\u003d jacobian[i][pj] * dirJ;\n                 }\n             }\n             double coeff1 \u003d 0;\n             for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                 coeff1 +\u003d work1[j] * work1[j];\n             }\n             double pc2 \u003d previousCost * previousCost;\n             coeff1 \u003d coeff1 / pc2;\n             double coeff2 \u003d lmPar * lmNorm * lmNorm / pc2;\n             double preRed \u003d coeff1 + 2 * coeff2;\n             double dirDer \u003d -(coeff1 + coeff2);\n             ratio \u003d (preRed \u003d\u003d 0) ? 0 : (actRed / preRed);\n             if (ratio \u003c\u003d 0.25) {\n                 double tmp \u003d (actRed \u003c 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n                 if ((0.1 * cost \u003e\u003d previousCost) || (tmp \u003c 0.1)) {\n                     tmp \u003d 0.1;\n                 }\n                 delta \u003d tmp * Math.min(delta, 10.0 * lmNorm);\n                 lmPar /\u003d tmp;\n             } else if ((lmPar \u003d\u003d 0) || (ratio \u003e\u003d 0.75)) {\n                 delta \u003d 2 * lmNorm;\n                 lmPar *\u003d 0.5;\n             }\n             if (ratio \u003e\u003d 1.0e-4) {\n                 firstIteration \u003d false;\n                 xNorm \u003d 0;\n                 for (int k \u003d 0; k \u003c cols; ++k) {\n                     double xK \u003d diag[k] * point[k];\n                     xNorm +\u003d xK * xK;\n                 }\n                 xNorm \u003d Math.sqrt(xNorm);\n             } else {\n                 cost \u003d previousCost;\n                 for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                     int pj \u003d permutation[j];\n                     point[pj] \u003d oldX[pj];\n                 }\n                 tmpVec \u003d residuals;\n                 residuals \u003d oldRes;\n                 oldRes \u003d tmpVec;\n             }\n-            if (((Math.abs(actRed) \u003c\u003d costRelativeTolerance) \u0026\u0026 (preRed \u003c\u003d costRelativeTolerance) \u0026\u0026 (ratio \u003c\u003d 2.0)) || (delta \u003c\u003d parRelativeTolerance * xNorm)) {\n-                return new VectorialPointValuePair(point, objective);\n+            if (checker !\u003d null) {\n+                if (checker.converged(getIterations(), previous, current)) {\n+                    return current;\n+                }\n+            } else {\n+                if (((Math.abs(actRed) \u003c\u003d costRelativeTolerance) \u0026\u0026 (preRed \u003c\u003d costRelativeTolerance) \u0026\u0026 (ratio \u003c\u003d 2.0)) || (delta \u003c\u003d parRelativeTolerance * xNorm)) {\n+                    return current;\n+                }\n             }\n             if ((Math.abs(actRed) \u003c\u003d 2.2204e-16) \u0026\u0026 (preRed \u003c\u003d 2.2204e-16) \u0026\u0026 (ratio \u003c\u003d 2.0)) {\n                 throw new OptimizationException(\"cost relative tolerance is too small ({0}),\" + \" no further reduction in the\" + \" sum of squares is possible\", costRelativeTolerance);\n             } else if (delta \u003c\u003d 2.2204e-16 * xNorm) {\n                 throw new OptimizationException(\"parameters relative tolerance is too small\" + \" ({0}), no further improvement in\" + \" the approximate solution is possible\", parRelativeTolerance);\n             } else if (maxCosine \u003c\u003d 2.2204e-16) {\n                 throw new OptimizationException(\"orthogonality tolerance is too small ({0}),\" + \" solution is orthogonal to the jacobian\", orthoTolerance);\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0905e8cf724b358277e219cbf1a06413faa48c9e": {
      "type": "Ybodychange",
      "commitMessage": "tighten checkstyle rules: declaring multiple variables in one statement is now forbidden\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@825919 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/16/09, 7:51 AM",
      "commitName": "0905e8cf724b358277e219cbf1a06413faa48c9e",
      "commitAuthor": "Luc Maisonobe",
      "commitDateOld": "9/6/09, 1:56 AM",
      "commitNameOld": "fd5e4bf4e2efc81c9d3b1d6ad125ef034705d0ed",
      "commitAuthorOld": "Luc Maisonobe",
      "daysBetweenCommits": 40.25,
      "commitsBetweenForRepo": 30,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected VectorialPointValuePair doOptimize() throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n    solvedCols \u003d Math.min(rows, cols);\n    diagR \u003d new double[cols];\n    jacNorm \u003d new double[cols];\n    beta \u003d new double[cols];\n    permutation \u003d new int[cols];\n    lmDir \u003d new double[cols];\n    double delta \u003d 0;\n    double xNorm \u003d 0;\n    double[] diag \u003d new double[cols];\n    double[] oldX \u003d new double[cols];\n    double[] oldRes \u003d new double[rows];\n    double[] work1 \u003d new double[cols];\n    double[] work2 \u003d new double[cols];\n    double[] work3 \u003d new double[cols];\n    updateResidualsAndCost();\n    lmPar \u003d 0;\n    boolean firstIteration \u003d true;\n    while (true) {\n        incrementIterationsCounter();\n        updateJacobian();\n        qrDecomposition();\n        qTy(residuals);\n        for (int k \u003d 0; k \u003c solvedCols; ++k) {\n            int pk \u003d permutation[k];\n            jacobian[k][pk] \u003d diagR[pk];\n        }\n        if (firstIteration) {\n            xNorm \u003d 0;\n            for (int k \u003d 0; k \u003c cols; ++k) {\n                double dk \u003d jacNorm[k];\n                if (dk \u003d\u003d 0) {\n                    dk \u003d 1.0;\n                }\n                double xk \u003d dk * point[k];\n                xNorm +\u003d xk * xk;\n                diag[k] \u003d dk;\n            }\n            xNorm \u003d Math.sqrt(xNorm);\n            delta \u003d (xNorm \u003d\u003d 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n        }\n        double maxCosine \u003d 0;\n        if (cost !\u003d 0) {\n            for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                int pj \u003d permutation[j];\n                double s \u003d jacNorm[pj];\n                if (s !\u003d 0) {\n                    double sum \u003d 0;\n                    for (int i \u003d 0; i \u003c\u003d j; ++i) {\n                        sum +\u003d jacobian[i][pj] * residuals[i];\n                    }\n                    maxCosine \u003d Math.max(maxCosine, Math.abs(sum) / (s * cost));\n                }\n            }\n        }\n        if (maxCosine \u003c\u003d orthoTolerance) {\n            return new VectorialPointValuePair(point, objective);\n        }\n        for (int j \u003d 0; j \u003c cols; ++j) {\n            diag[j] \u003d Math.max(diag[j], jacNorm[j]);\n        }\n        for (double ratio \u003d 0; ratio \u003c 1.0e-4; ) {\n            for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                int pj \u003d permutation[j];\n                oldX[pj] \u003d point[pj];\n            }\n            double previousCost \u003d cost;\n            double[] tmpVec \u003d residuals;\n            residuals \u003d oldRes;\n            oldRes \u003d tmpVec;\n            determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n            double lmNorm \u003d 0;\n            for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                int pj \u003d permutation[j];\n                lmDir[pj] \u003d -lmDir[pj];\n                point[pj] \u003d oldX[pj] + lmDir[pj];\n                double s \u003d diag[pj] * lmDir[pj];\n                lmNorm +\u003d s * s;\n            }\n            lmNorm \u003d Math.sqrt(lmNorm);\n            if (firstIteration) {\n                delta \u003d Math.min(delta, lmNorm);\n            }\n            updateResidualsAndCost();\n            double actRed \u003d -1.0;\n            if (0.1 * cost \u003c previousCost) {\n                double r \u003d cost / previousCost;\n                actRed \u003d 1.0 - r * r;\n            }\n            for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                int pj \u003d permutation[j];\n                double dirJ \u003d lmDir[pj];\n                work1[j] \u003d 0;\n                for (int i \u003d 0; i \u003c\u003d j; ++i) {\n                    work1[i] +\u003d jacobian[i][pj] * dirJ;\n                }\n            }\n            double coeff1 \u003d 0;\n            for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                coeff1 +\u003d work1[j] * work1[j];\n            }\n            double pc2 \u003d previousCost * previousCost;\n            coeff1 \u003d coeff1 / pc2;\n            double coeff2 \u003d lmPar * lmNorm * lmNorm / pc2;\n            double preRed \u003d coeff1 + 2 * coeff2;\n            double dirDer \u003d -(coeff1 + coeff2);\n            ratio \u003d (preRed \u003d\u003d 0) ? 0 : (actRed / preRed);\n            if (ratio \u003c\u003d 0.25) {\n                double tmp \u003d (actRed \u003c 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n                if ((0.1 * cost \u003e\u003d previousCost) || (tmp \u003c 0.1)) {\n                    tmp \u003d 0.1;\n                }\n                delta \u003d tmp * Math.min(delta, 10.0 * lmNorm);\n                lmPar /\u003d tmp;\n            } else if ((lmPar \u003d\u003d 0) || (ratio \u003e\u003d 0.75)) {\n                delta \u003d 2 * lmNorm;\n                lmPar *\u003d 0.5;\n            }\n            if (ratio \u003e\u003d 1.0e-4) {\n                firstIteration \u003d false;\n                xNorm \u003d 0;\n                for (int k \u003d 0; k \u003c cols; ++k) {\n                    double xK \u003d diag[k] * point[k];\n                    xNorm +\u003d xK * xK;\n                }\n                xNorm \u003d Math.sqrt(xNorm);\n            } else {\n                cost \u003d previousCost;\n                for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                    int pj \u003d permutation[j];\n                    point[pj] \u003d oldX[pj];\n                }\n                tmpVec \u003d residuals;\n                residuals \u003d oldRes;\n                oldRes \u003d tmpVec;\n            }\n            if (((Math.abs(actRed) \u003c\u003d costRelativeTolerance) \u0026\u0026 (preRed \u003c\u003d costRelativeTolerance) \u0026\u0026 (ratio \u003c\u003d 2.0)) || (delta \u003c\u003d parRelativeTolerance * xNorm)) {\n                return new VectorialPointValuePair(point, objective);\n            }\n            if ((Math.abs(actRed) \u003c\u003d 2.2204e-16) \u0026\u0026 (preRed \u003c\u003d 2.2204e-16) \u0026\u0026 (ratio \u003c\u003d 2.0)) {\n                throw new OptimizationException(\"cost relative tolerance is too small ({0}),\" + \" no further reduction in the\" + \" sum of squares is possible\", costRelativeTolerance);\n            } else if (delta \u003c\u003d 2.2204e-16 * xNorm) {\n                throw new OptimizationException(\"parameters relative tolerance is too small\" + \" ({0}), no further improvement in\" + \" the approximate solution is possible\", parRelativeTolerance);\n            } else if (maxCosine \u003c\u003d 2.2204e-16) {\n                throw new OptimizationException(\"orthogonality tolerance is too small ({0}),\" + \" solution is orthogonal to the jacobian\", orthoTolerance);\n            }\n        }\n    }\n}",
      "path": "src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java",
      "functionStartLine": 211,
      "functionName": "doOptimize",
      "functionAnnotation": "@Override",
      "functionDoc": "@inheritDoc}\n",
      "diff": "@@ -1,149 +1,150 @@\n @Override\n protected VectorialPointValuePair doOptimize() throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n     solvedCols \u003d Math.min(rows, cols);\n     diagR \u003d new double[cols];\n     jacNorm \u003d new double[cols];\n     beta \u003d new double[cols];\n     permutation \u003d new int[cols];\n     lmDir \u003d new double[cols];\n-    double delta \u003d 0, xNorm \u003d 0;\n+    double delta \u003d 0;\n+    double xNorm \u003d 0;\n     double[] diag \u003d new double[cols];\n     double[] oldX \u003d new double[cols];\n     double[] oldRes \u003d new double[rows];\n     double[] work1 \u003d new double[cols];\n     double[] work2 \u003d new double[cols];\n     double[] work3 \u003d new double[cols];\n     updateResidualsAndCost();\n     lmPar \u003d 0;\n     boolean firstIteration \u003d true;\n     while (true) {\n         incrementIterationsCounter();\n         updateJacobian();\n         qrDecomposition();\n         qTy(residuals);\n         for (int k \u003d 0; k \u003c solvedCols; ++k) {\n             int pk \u003d permutation[k];\n             jacobian[k][pk] \u003d diagR[pk];\n         }\n         if (firstIteration) {\n             xNorm \u003d 0;\n             for (int k \u003d 0; k \u003c cols; ++k) {\n                 double dk \u003d jacNorm[k];\n                 if (dk \u003d\u003d 0) {\n                     dk \u003d 1.0;\n                 }\n                 double xk \u003d dk * point[k];\n                 xNorm +\u003d xk * xk;\n                 diag[k] \u003d dk;\n             }\n             xNorm \u003d Math.sqrt(xNorm);\n             delta \u003d (xNorm \u003d\u003d 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n         }\n         double maxCosine \u003d 0;\n         if (cost !\u003d 0) {\n             for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                 int pj \u003d permutation[j];\n                 double s \u003d jacNorm[pj];\n                 if (s !\u003d 0) {\n                     double sum \u003d 0;\n                     for (int i \u003d 0; i \u003c\u003d j; ++i) {\n                         sum +\u003d jacobian[i][pj] * residuals[i];\n                     }\n                     maxCosine \u003d Math.max(maxCosine, Math.abs(sum) / (s * cost));\n                 }\n             }\n         }\n         if (maxCosine \u003c\u003d orthoTolerance) {\n             return new VectorialPointValuePair(point, objective);\n         }\n         for (int j \u003d 0; j \u003c cols; ++j) {\n             diag[j] \u003d Math.max(diag[j], jacNorm[j]);\n         }\n         for (double ratio \u003d 0; ratio \u003c 1.0e-4; ) {\n             for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                 int pj \u003d permutation[j];\n                 oldX[pj] \u003d point[pj];\n             }\n             double previousCost \u003d cost;\n             double[] tmpVec \u003d residuals;\n             residuals \u003d oldRes;\n             oldRes \u003d tmpVec;\n             determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n             double lmNorm \u003d 0;\n             for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                 int pj \u003d permutation[j];\n                 lmDir[pj] \u003d -lmDir[pj];\n                 point[pj] \u003d oldX[pj] + lmDir[pj];\n                 double s \u003d diag[pj] * lmDir[pj];\n                 lmNorm +\u003d s * s;\n             }\n             lmNorm \u003d Math.sqrt(lmNorm);\n             if (firstIteration) {\n                 delta \u003d Math.min(delta, lmNorm);\n             }\n             updateResidualsAndCost();\n             double actRed \u003d -1.0;\n             if (0.1 * cost \u003c previousCost) {\n                 double r \u003d cost / previousCost;\n                 actRed \u003d 1.0 - r * r;\n             }\n             for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                 int pj \u003d permutation[j];\n                 double dirJ \u003d lmDir[pj];\n                 work1[j] \u003d 0;\n                 for (int i \u003d 0; i \u003c\u003d j; ++i) {\n                     work1[i] +\u003d jacobian[i][pj] * dirJ;\n                 }\n             }\n             double coeff1 \u003d 0;\n             for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                 coeff1 +\u003d work1[j] * work1[j];\n             }\n             double pc2 \u003d previousCost * previousCost;\n             coeff1 \u003d coeff1 / pc2;\n             double coeff2 \u003d lmPar * lmNorm * lmNorm / pc2;\n             double preRed \u003d coeff1 + 2 * coeff2;\n             double dirDer \u003d -(coeff1 + coeff2);\n             ratio \u003d (preRed \u003d\u003d 0) ? 0 : (actRed / preRed);\n             if (ratio \u003c\u003d 0.25) {\n                 double tmp \u003d (actRed \u003c 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n                 if ((0.1 * cost \u003e\u003d previousCost) || (tmp \u003c 0.1)) {\n                     tmp \u003d 0.1;\n                 }\n                 delta \u003d tmp * Math.min(delta, 10.0 * lmNorm);\n                 lmPar /\u003d tmp;\n             } else if ((lmPar \u003d\u003d 0) || (ratio \u003e\u003d 0.75)) {\n                 delta \u003d 2 * lmNorm;\n                 lmPar *\u003d 0.5;\n             }\n             if (ratio \u003e\u003d 1.0e-4) {\n                 firstIteration \u003d false;\n                 xNorm \u003d 0;\n                 for (int k \u003d 0; k \u003c cols; ++k) {\n                     double xK \u003d diag[k] * point[k];\n                     xNorm +\u003d xK * xK;\n                 }\n                 xNorm \u003d Math.sqrt(xNorm);\n             } else {\n                 cost \u003d previousCost;\n                 for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                     int pj \u003d permutation[j];\n                     point[pj] \u003d oldX[pj];\n                 }\n                 tmpVec \u003d residuals;\n                 residuals \u003d oldRes;\n                 oldRes \u003d tmpVec;\n             }\n             if (((Math.abs(actRed) \u003c\u003d costRelativeTolerance) \u0026\u0026 (preRed \u003c\u003d costRelativeTolerance) \u0026\u0026 (ratio \u003c\u003d 2.0)) || (delta \u003c\u003d parRelativeTolerance * xNorm)) {\n                 return new VectorialPointValuePair(point, objective);\n             }\n             if ((Math.abs(actRed) \u003c\u003d 2.2204e-16) \u0026\u0026 (preRed \u003c\u003d 2.2204e-16) \u0026\u0026 (ratio \u003c\u003d 2.0)) {\n                 throw new OptimizationException(\"cost relative tolerance is too small ({0}),\" + \" no further reduction in the\" + \" sum of squares is possible\", costRelativeTolerance);\n             } else if (delta \u003c\u003d 2.2204e-16 * xNorm) {\n                 throw new OptimizationException(\"parameters relative tolerance is too small\" + \" ({0}), no further improvement in\" + \" the approximate solution is possible\", parRelativeTolerance);\n             } else if (maxCosine \u003c\u003d 2.2204e-16) {\n                 throw new OptimizationException(\"orthogonality tolerance is too small ({0}),\" + \" solution is orthogonal to the jacobian\", orthoTolerance);\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d6a438e931412713e99624cf9ed74470f1040184": {
      "type": "Yfilerename",
      "commitMessage": "moved main java directory for compliance with maven standard directory layout\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@799870 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "8/1/09, 7:30 AM",
      "commitName": "d6a438e931412713e99624cf9ed74470f1040184",
      "commitAuthor": "Luc Maisonobe",
      "commitDateOld": "8/1/09, 7:23 AM",
      "commitNameOld": "2ad5ef61630be627f46ae1c266cf796f044bd4a8",
      "commitAuthorOld": "Luc Maisonobe",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected VectorialPointValuePair doOptimize() throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n    solvedCols \u003d Math.min(rows, cols);\n    diagR \u003d new double[cols];\n    jacNorm \u003d new double[cols];\n    beta \u003d new double[cols];\n    permutation \u003d new int[cols];\n    lmDir \u003d new double[cols];\n    double delta \u003d 0, xNorm \u003d 0;\n    double[] diag \u003d new double[cols];\n    double[] oldX \u003d new double[cols];\n    double[] oldRes \u003d new double[rows];\n    double[] work1 \u003d new double[cols];\n    double[] work2 \u003d new double[cols];\n    double[] work3 \u003d new double[cols];\n    updateResidualsAndCost();\n    lmPar \u003d 0;\n    boolean firstIteration \u003d true;\n    while (true) {\n        incrementIterationsCounter();\n        updateJacobian();\n        qrDecomposition();\n        qTy(residuals);\n        for (int k \u003d 0; k \u003c solvedCols; ++k) {\n            int pk \u003d permutation[k];\n            jacobian[k][pk] \u003d diagR[pk];\n        }\n        if (firstIteration) {\n            xNorm \u003d 0;\n            for (int k \u003d 0; k \u003c cols; ++k) {\n                double dk \u003d jacNorm[k];\n                if (dk \u003d\u003d 0) {\n                    dk \u003d 1.0;\n                }\n                double xk \u003d dk * point[k];\n                xNorm +\u003d xk * xk;\n                diag[k] \u003d dk;\n            }\n            xNorm \u003d Math.sqrt(xNorm);\n            delta \u003d (xNorm \u003d\u003d 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n        }\n        double maxCosine \u003d 0;\n        if (cost !\u003d 0) {\n            for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                int pj \u003d permutation[j];\n                double s \u003d jacNorm[pj];\n                if (s !\u003d 0) {\n                    double sum \u003d 0;\n                    for (int i \u003d 0; i \u003c\u003d j; ++i) {\n                        sum +\u003d jacobian[i][pj] * residuals[i];\n                    }\n                    maxCosine \u003d Math.max(maxCosine, Math.abs(sum) / (s * cost));\n                }\n            }\n        }\n        if (maxCosine \u003c\u003d orthoTolerance) {\n            return new VectorialPointValuePair(point, objective);\n        }\n        for (int j \u003d 0; j \u003c cols; ++j) {\n            diag[j] \u003d Math.max(diag[j], jacNorm[j]);\n        }\n        for (double ratio \u003d 0; ratio \u003c 1.0e-4; ) {\n            for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                int pj \u003d permutation[j];\n                oldX[pj] \u003d point[pj];\n            }\n            double previousCost \u003d cost;\n            double[] tmpVec \u003d residuals;\n            residuals \u003d oldRes;\n            oldRes \u003d tmpVec;\n            determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n            double lmNorm \u003d 0;\n            for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                int pj \u003d permutation[j];\n                lmDir[pj] \u003d -lmDir[pj];\n                point[pj] \u003d oldX[pj] + lmDir[pj];\n                double s \u003d diag[pj] * lmDir[pj];\n                lmNorm +\u003d s * s;\n            }\n            lmNorm \u003d Math.sqrt(lmNorm);\n            if (firstIteration) {\n                delta \u003d Math.min(delta, lmNorm);\n            }\n            updateResidualsAndCost();\n            double actRed \u003d -1.0;\n            if (0.1 * cost \u003c previousCost) {\n                double r \u003d cost / previousCost;\n                actRed \u003d 1.0 - r * r;\n            }\n            for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                int pj \u003d permutation[j];\n                double dirJ \u003d lmDir[pj];\n                work1[j] \u003d 0;\n                for (int i \u003d 0; i \u003c\u003d j; ++i) {\n                    work1[i] +\u003d jacobian[i][pj] * dirJ;\n                }\n            }\n            double coeff1 \u003d 0;\n            for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                coeff1 +\u003d work1[j] * work1[j];\n            }\n            double pc2 \u003d previousCost * previousCost;\n            coeff1 \u003d coeff1 / pc2;\n            double coeff2 \u003d lmPar * lmNorm * lmNorm / pc2;\n            double preRed \u003d coeff1 + 2 * coeff2;\n            double dirDer \u003d -(coeff1 + coeff2);\n            ratio \u003d (preRed \u003d\u003d 0) ? 0 : (actRed / preRed);\n            if (ratio \u003c\u003d 0.25) {\n                double tmp \u003d (actRed \u003c 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n                if ((0.1 * cost \u003e\u003d previousCost) || (tmp \u003c 0.1)) {\n                    tmp \u003d 0.1;\n                }\n                delta \u003d tmp * Math.min(delta, 10.0 * lmNorm);\n                lmPar /\u003d tmp;\n            } else if ((lmPar \u003d\u003d 0) || (ratio \u003e\u003d 0.75)) {\n                delta \u003d 2 * lmNorm;\n                lmPar *\u003d 0.5;\n            }\n            if (ratio \u003e\u003d 1.0e-4) {\n                firstIteration \u003d false;\n                xNorm \u003d 0;\n                for (int k \u003d 0; k \u003c cols; ++k) {\n                    double xK \u003d diag[k] * point[k];\n                    xNorm +\u003d xK * xK;\n                }\n                xNorm \u003d Math.sqrt(xNorm);\n            } else {\n                cost \u003d previousCost;\n                for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                    int pj \u003d permutation[j];\n                    point[pj] \u003d oldX[pj];\n                }\n                tmpVec \u003d residuals;\n                residuals \u003d oldRes;\n                oldRes \u003d tmpVec;\n            }\n            if (((Math.abs(actRed) \u003c\u003d costRelativeTolerance) \u0026\u0026 (preRed \u003c\u003d costRelativeTolerance) \u0026\u0026 (ratio \u003c\u003d 2.0)) || (delta \u003c\u003d parRelativeTolerance * xNorm)) {\n                return new VectorialPointValuePair(point, objective);\n            }\n            if ((Math.abs(actRed) \u003c\u003d 2.2204e-16) \u0026\u0026 (preRed \u003c\u003d 2.2204e-16) \u0026\u0026 (ratio \u003c\u003d 2.0)) {\n                throw new OptimizationException(\"cost relative tolerance is too small ({0}),\" + \" no further reduction in the\" + \" sum of squares is possible\", costRelativeTolerance);\n            } else if (delta \u003c\u003d 2.2204e-16 * xNorm) {\n                throw new OptimizationException(\"parameters relative tolerance is too small\" + \" ({0}), no further improvement in\" + \" the approximate solution is possible\", parRelativeTolerance);\n            } else if (maxCosine \u003c\u003d 2.2204e-16) {\n                throw new OptimizationException(\"orthogonality tolerance is too small ({0}),\" + \" solution is orthogonal to the jacobian\", orthoTolerance);\n            }\n        }\n    }\n}",
      "path": "src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java",
      "functionStartLine": 210,
      "functionName": "doOptimize",
      "functionAnnotation": "@Override",
      "functionDoc": "@inheritDoc}\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java",
        "newPath": "src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java"
      }
    },
    "9c8d2c79c1ef565337599849cd066ff63b8d5816": {
      "type": "Yannotationchange",
      "commitMessage": "added missing @Override annotations\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@762087 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "4/5/09, 7:20 AM",
      "commitName": "9c8d2c79c1ef565337599849cd066ff63b8d5816",
      "commitAuthor": "Luc Maisonobe",
      "commitDateOld": "3/24/09, 3:15 PM",
      "commitNameOld": "ae6753dd5e4ce3b0ed9bd67f92d2d4e92587300f",
      "commitAuthorOld": "Luc Maisonobe",
      "daysBetweenCommits": 11.67,
      "commitsBetweenForRepo": 25,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected VectorialPointValuePair doOptimize() throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n    solvedCols \u003d Math.min(rows, cols);\n    diagR \u003d new double[cols];\n    jacNorm \u003d new double[cols];\n    beta \u003d new double[cols];\n    permutation \u003d new int[cols];\n    lmDir \u003d new double[cols];\n    double delta \u003d 0, xNorm \u003d 0;\n    double[] diag \u003d new double[cols];\n    double[] oldX \u003d new double[cols];\n    double[] oldRes \u003d new double[rows];\n    double[] work1 \u003d new double[cols];\n    double[] work2 \u003d new double[cols];\n    double[] work3 \u003d new double[cols];\n    updateResidualsAndCost();\n    lmPar \u003d 0;\n    boolean firstIteration \u003d true;\n    while (true) {\n        incrementIterationsCounter();\n        updateJacobian();\n        qrDecomposition();\n        qTy(residuals);\n        for (int k \u003d 0; k \u003c solvedCols; ++k) {\n            int pk \u003d permutation[k];\n            jacobian[k][pk] \u003d diagR[pk];\n        }\n        if (firstIteration) {\n            xNorm \u003d 0;\n            for (int k \u003d 0; k \u003c cols; ++k) {\n                double dk \u003d jacNorm[k];\n                if (dk \u003d\u003d 0) {\n                    dk \u003d 1.0;\n                }\n                double xk \u003d dk * point[k];\n                xNorm +\u003d xk * xk;\n                diag[k] \u003d dk;\n            }\n            xNorm \u003d Math.sqrt(xNorm);\n            delta \u003d (xNorm \u003d\u003d 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n        }\n        double maxCosine \u003d 0;\n        if (cost !\u003d 0) {\n            for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                int pj \u003d permutation[j];\n                double s \u003d jacNorm[pj];\n                if (s !\u003d 0) {\n                    double sum \u003d 0;\n                    for (int i \u003d 0; i \u003c\u003d j; ++i) {\n                        sum +\u003d jacobian[i][pj] * residuals[i];\n                    }\n                    maxCosine \u003d Math.max(maxCosine, Math.abs(sum) / (s * cost));\n                }\n            }\n        }\n        if (maxCosine \u003c\u003d orthoTolerance) {\n            return new VectorialPointValuePair(point, objective);\n        }\n        for (int j \u003d 0; j \u003c cols; ++j) {\n            diag[j] \u003d Math.max(diag[j], jacNorm[j]);\n        }\n        for (double ratio \u003d 0; ratio \u003c 1.0e-4; ) {\n            for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                int pj \u003d permutation[j];\n                oldX[pj] \u003d point[pj];\n            }\n            double previousCost \u003d cost;\n            double[] tmpVec \u003d residuals;\n            residuals \u003d oldRes;\n            oldRes \u003d tmpVec;\n            determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n            double lmNorm \u003d 0;\n            for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                int pj \u003d permutation[j];\n                lmDir[pj] \u003d -lmDir[pj];\n                point[pj] \u003d oldX[pj] + lmDir[pj];\n                double s \u003d diag[pj] * lmDir[pj];\n                lmNorm +\u003d s * s;\n            }\n            lmNorm \u003d Math.sqrt(lmNorm);\n            if (firstIteration) {\n                delta \u003d Math.min(delta, lmNorm);\n            }\n            updateResidualsAndCost();\n            double actRed \u003d -1.0;\n            if (0.1 * cost \u003c previousCost) {\n                double r \u003d cost / previousCost;\n                actRed \u003d 1.0 - r * r;\n            }\n            for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                int pj \u003d permutation[j];\n                double dirJ \u003d lmDir[pj];\n                work1[j] \u003d 0;\n                for (int i \u003d 0; i \u003c\u003d j; ++i) {\n                    work1[i] +\u003d jacobian[i][pj] * dirJ;\n                }\n            }\n            double coeff1 \u003d 0;\n            for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                coeff1 +\u003d work1[j] * work1[j];\n            }\n            double pc2 \u003d previousCost * previousCost;\n            coeff1 \u003d coeff1 / pc2;\n            double coeff2 \u003d lmPar * lmNorm * lmNorm / pc2;\n            double preRed \u003d coeff1 + 2 * coeff2;\n            double dirDer \u003d -(coeff1 + coeff2);\n            ratio \u003d (preRed \u003d\u003d 0) ? 0 : (actRed / preRed);\n            if (ratio \u003c\u003d 0.25) {\n                double tmp \u003d (actRed \u003c 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n                if ((0.1 * cost \u003e\u003d previousCost) || (tmp \u003c 0.1)) {\n                    tmp \u003d 0.1;\n                }\n                delta \u003d tmp * Math.min(delta, 10.0 * lmNorm);\n                lmPar /\u003d tmp;\n            } else if ((lmPar \u003d\u003d 0) || (ratio \u003e\u003d 0.75)) {\n                delta \u003d 2 * lmNorm;\n                lmPar *\u003d 0.5;\n            }\n            if (ratio \u003e\u003d 1.0e-4) {\n                firstIteration \u003d false;\n                xNorm \u003d 0;\n                for (int k \u003d 0; k \u003c cols; ++k) {\n                    double xK \u003d diag[k] * point[k];\n                    xNorm +\u003d xK * xK;\n                }\n                xNorm \u003d Math.sqrt(xNorm);\n            } else {\n                cost \u003d previousCost;\n                for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                    int pj \u003d permutation[j];\n                    point[pj] \u003d oldX[pj];\n                }\n                tmpVec \u003d residuals;\n                residuals \u003d oldRes;\n                oldRes \u003d tmpVec;\n            }\n            if (((Math.abs(actRed) \u003c\u003d costRelativeTolerance) \u0026\u0026 (preRed \u003c\u003d costRelativeTolerance) \u0026\u0026 (ratio \u003c\u003d 2.0)) || (delta \u003c\u003d parRelativeTolerance * xNorm)) {\n                return new VectorialPointValuePair(point, objective);\n            }\n            if ((Math.abs(actRed) \u003c\u003d 2.2204e-16) \u0026\u0026 (preRed \u003c\u003d 2.2204e-16) \u0026\u0026 (ratio \u003c\u003d 2.0)) {\n                throw new OptimizationException(\"cost relative tolerance is too small ({0}),\" + \" no further reduction in the\" + \" sum of squares is possible\", costRelativeTolerance);\n            } else if (delta \u003c\u003d 2.2204e-16 * xNorm) {\n                throw new OptimizationException(\"parameters relative tolerance is too small\" + \" ({0}), no further improvement in\" + \" the approximate solution is possible\", parRelativeTolerance);\n            } else if (maxCosine \u003c\u003d 2.2204e-16) {\n                throw new OptimizationException(\"orthogonality tolerance is too small ({0}),\" + \" solution is orthogonal to the jacobian\", orthoTolerance);\n            }\n        }\n    }\n}",
      "path": "src/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java",
      "functionStartLine": 213,
      "functionName": "doOptimize",
      "functionAnnotation": "@Override",
      "functionDoc": "@inheritDoc}\n",
      "diff": "@@ -1,148 +1,149 @@\n+@Override\n protected VectorialPointValuePair doOptimize() throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n     solvedCols \u003d Math.min(rows, cols);\n     diagR \u003d new double[cols];\n     jacNorm \u003d new double[cols];\n     beta \u003d new double[cols];\n     permutation \u003d new int[cols];\n     lmDir \u003d new double[cols];\n     double delta \u003d 0, xNorm \u003d 0;\n     double[] diag \u003d new double[cols];\n     double[] oldX \u003d new double[cols];\n     double[] oldRes \u003d new double[rows];\n     double[] work1 \u003d new double[cols];\n     double[] work2 \u003d new double[cols];\n     double[] work3 \u003d new double[cols];\n     updateResidualsAndCost();\n     lmPar \u003d 0;\n     boolean firstIteration \u003d true;\n     while (true) {\n         incrementIterationsCounter();\n         updateJacobian();\n         qrDecomposition();\n         qTy(residuals);\n         for (int k \u003d 0; k \u003c solvedCols; ++k) {\n             int pk \u003d permutation[k];\n             jacobian[k][pk] \u003d diagR[pk];\n         }\n         if (firstIteration) {\n             xNorm \u003d 0;\n             for (int k \u003d 0; k \u003c cols; ++k) {\n                 double dk \u003d jacNorm[k];\n                 if (dk \u003d\u003d 0) {\n                     dk \u003d 1.0;\n                 }\n                 double xk \u003d dk * point[k];\n                 xNorm +\u003d xk * xk;\n                 diag[k] \u003d dk;\n             }\n             xNorm \u003d Math.sqrt(xNorm);\n             delta \u003d (xNorm \u003d\u003d 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n         }\n         double maxCosine \u003d 0;\n         if (cost !\u003d 0) {\n             for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                 int pj \u003d permutation[j];\n                 double s \u003d jacNorm[pj];\n                 if (s !\u003d 0) {\n                     double sum \u003d 0;\n                     for (int i \u003d 0; i \u003c\u003d j; ++i) {\n                         sum +\u003d jacobian[i][pj] * residuals[i];\n                     }\n                     maxCosine \u003d Math.max(maxCosine, Math.abs(sum) / (s * cost));\n                 }\n             }\n         }\n         if (maxCosine \u003c\u003d orthoTolerance) {\n             return new VectorialPointValuePair(point, objective);\n         }\n         for (int j \u003d 0; j \u003c cols; ++j) {\n             diag[j] \u003d Math.max(diag[j], jacNorm[j]);\n         }\n         for (double ratio \u003d 0; ratio \u003c 1.0e-4; ) {\n             for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                 int pj \u003d permutation[j];\n                 oldX[pj] \u003d point[pj];\n             }\n             double previousCost \u003d cost;\n             double[] tmpVec \u003d residuals;\n             residuals \u003d oldRes;\n             oldRes \u003d tmpVec;\n             determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n             double lmNorm \u003d 0;\n             for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                 int pj \u003d permutation[j];\n                 lmDir[pj] \u003d -lmDir[pj];\n                 point[pj] \u003d oldX[pj] + lmDir[pj];\n                 double s \u003d diag[pj] * lmDir[pj];\n                 lmNorm +\u003d s * s;\n             }\n             lmNorm \u003d Math.sqrt(lmNorm);\n             if (firstIteration) {\n                 delta \u003d Math.min(delta, lmNorm);\n             }\n             updateResidualsAndCost();\n             double actRed \u003d -1.0;\n             if (0.1 * cost \u003c previousCost) {\n                 double r \u003d cost / previousCost;\n                 actRed \u003d 1.0 - r * r;\n             }\n             for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                 int pj \u003d permutation[j];\n                 double dirJ \u003d lmDir[pj];\n                 work1[j] \u003d 0;\n                 for (int i \u003d 0; i \u003c\u003d j; ++i) {\n                     work1[i] +\u003d jacobian[i][pj] * dirJ;\n                 }\n             }\n             double coeff1 \u003d 0;\n             for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                 coeff1 +\u003d work1[j] * work1[j];\n             }\n             double pc2 \u003d previousCost * previousCost;\n             coeff1 \u003d coeff1 / pc2;\n             double coeff2 \u003d lmPar * lmNorm * lmNorm / pc2;\n             double preRed \u003d coeff1 + 2 * coeff2;\n             double dirDer \u003d -(coeff1 + coeff2);\n             ratio \u003d (preRed \u003d\u003d 0) ? 0 : (actRed / preRed);\n             if (ratio \u003c\u003d 0.25) {\n                 double tmp \u003d (actRed \u003c 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n                 if ((0.1 * cost \u003e\u003d previousCost) || (tmp \u003c 0.1)) {\n                     tmp \u003d 0.1;\n                 }\n                 delta \u003d tmp * Math.min(delta, 10.0 * lmNorm);\n                 lmPar /\u003d tmp;\n             } else if ((lmPar \u003d\u003d 0) || (ratio \u003e\u003d 0.75)) {\n                 delta \u003d 2 * lmNorm;\n                 lmPar *\u003d 0.5;\n             }\n             if (ratio \u003e\u003d 1.0e-4) {\n                 firstIteration \u003d false;\n                 xNorm \u003d 0;\n                 for (int k \u003d 0; k \u003c cols; ++k) {\n                     double xK \u003d diag[k] * point[k];\n                     xNorm +\u003d xK * xK;\n                 }\n                 xNorm \u003d Math.sqrt(xNorm);\n             } else {\n                 cost \u003d previousCost;\n                 for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                     int pj \u003d permutation[j];\n                     point[pj] \u003d oldX[pj];\n                 }\n                 tmpVec \u003d residuals;\n                 residuals \u003d oldRes;\n                 oldRes \u003d tmpVec;\n             }\n             if (((Math.abs(actRed) \u003c\u003d costRelativeTolerance) \u0026\u0026 (preRed \u003c\u003d costRelativeTolerance) \u0026\u0026 (ratio \u003c\u003d 2.0)) || (delta \u003c\u003d parRelativeTolerance * xNorm)) {\n                 return new VectorialPointValuePair(point, objective);\n             }\n             if ((Math.abs(actRed) \u003c\u003d 2.2204e-16) \u0026\u0026 (preRed \u003c\u003d 2.2204e-16) \u0026\u0026 (ratio \u003c\u003d 2.0)) {\n                 throw new OptimizationException(\"cost relative tolerance is too small ({0}),\" + \" no further reduction in the\" + \" sum of squares is possible\", costRelativeTolerance);\n             } else if (delta \u003c\u003d 2.2204e-16 * xNorm) {\n                 throw new OptimizationException(\"parameters relative tolerance is too small\" + \" ({0}), no further improvement in\" + \" the approximate solution is possible\", parRelativeTolerance);\n             } else if (maxCosine \u003c\u003d 2.2204e-16) {\n                 throw new OptimizationException(\"orthogonality tolerance is too small ({0}),\" + \" solution is orthogonal to the jacobian\", orthoTolerance);\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "",
        "newValue": "@Override"
      }
    },
    "ae6753dd5e4ce3b0ed9bd67f92d2d4e92587300f": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "updated general algorithms with latest interfaces definitions\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@758058 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "3/24/09, 3:15 PM",
      "commitName": "ae6753dd5e4ce3b0ed9bd67f92d2d4e92587300f",
      "commitAuthor": "Luc Maisonobe",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "updated general algorithms with latest interfaces definitions\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@758058 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "3/24/09, 3:15 PM",
          "commitName": "ae6753dd5e4ce3b0ed9bd67f92d2d4e92587300f",
          "commitAuthor": "Luc Maisonobe",
          "commitDateOld": "3/22/09, 6:00 AM",
          "commitNameOld": "a7faf40b61f445d15d9a210b23fa0008b87e25e2",
          "commitAuthorOld": "Luc Maisonobe",
          "daysBetweenCommits": 2.39,
          "commitsBetweenForRepo": 10,
          "commitsBetweenForFile": 1,
          "actualSource": "protected VectorialPointValuePair doOptimize() throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n    solvedCols \u003d Math.min(rows, cols);\n    diagR \u003d new double[cols];\n    jacNorm \u003d new double[cols];\n    beta \u003d new double[cols];\n    permutation \u003d new int[cols];\n    lmDir \u003d new double[cols];\n    double delta \u003d 0, xNorm \u003d 0;\n    double[] diag \u003d new double[cols];\n    double[] oldX \u003d new double[cols];\n    double[] oldRes \u003d new double[rows];\n    double[] work1 \u003d new double[cols];\n    double[] work2 \u003d new double[cols];\n    double[] work3 \u003d new double[cols];\n    updateResidualsAndCost();\n    lmPar \u003d 0;\n    boolean firstIteration \u003d true;\n    while (true) {\n        incrementIterationsCounter();\n        updateJacobian();\n        qrDecomposition();\n        qTy(residuals);\n        for (int k \u003d 0; k \u003c solvedCols; ++k) {\n            int pk \u003d permutation[k];\n            jacobian[k][pk] \u003d diagR[pk];\n        }\n        if (firstIteration) {\n            xNorm \u003d 0;\n            for (int k \u003d 0; k \u003c cols; ++k) {\n                double dk \u003d jacNorm[k];\n                if (dk \u003d\u003d 0) {\n                    dk \u003d 1.0;\n                }\n                double xk \u003d dk * point[k];\n                xNorm +\u003d xk * xk;\n                diag[k] \u003d dk;\n            }\n            xNorm \u003d Math.sqrt(xNorm);\n            delta \u003d (xNorm \u003d\u003d 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n        }\n        double maxCosine \u003d 0;\n        if (cost !\u003d 0) {\n            for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                int pj \u003d permutation[j];\n                double s \u003d jacNorm[pj];\n                if (s !\u003d 0) {\n                    double sum \u003d 0;\n                    for (int i \u003d 0; i \u003c\u003d j; ++i) {\n                        sum +\u003d jacobian[i][pj] * residuals[i];\n                    }\n                    maxCosine \u003d Math.max(maxCosine, Math.abs(sum) / (s * cost));\n                }\n            }\n        }\n        if (maxCosine \u003c\u003d orthoTolerance) {\n            return new VectorialPointValuePair(point, objective);\n        }\n        for (int j \u003d 0; j \u003c cols; ++j) {\n            diag[j] \u003d Math.max(diag[j], jacNorm[j]);\n        }\n        for (double ratio \u003d 0; ratio \u003c 1.0e-4; ) {\n            for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                int pj \u003d permutation[j];\n                oldX[pj] \u003d point[pj];\n            }\n            double previousCost \u003d cost;\n            double[] tmpVec \u003d residuals;\n            residuals \u003d oldRes;\n            oldRes \u003d tmpVec;\n            determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n            double lmNorm \u003d 0;\n            for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                int pj \u003d permutation[j];\n                lmDir[pj] \u003d -lmDir[pj];\n                point[pj] \u003d oldX[pj] + lmDir[pj];\n                double s \u003d diag[pj] * lmDir[pj];\n                lmNorm +\u003d s * s;\n            }\n            lmNorm \u003d Math.sqrt(lmNorm);\n            if (firstIteration) {\n                delta \u003d Math.min(delta, lmNorm);\n            }\n            updateResidualsAndCost();\n            double actRed \u003d -1.0;\n            if (0.1 * cost \u003c previousCost) {\n                double r \u003d cost / previousCost;\n                actRed \u003d 1.0 - r * r;\n            }\n            for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                int pj \u003d permutation[j];\n                double dirJ \u003d lmDir[pj];\n                work1[j] \u003d 0;\n                for (int i \u003d 0; i \u003c\u003d j; ++i) {\n                    work1[i] +\u003d jacobian[i][pj] * dirJ;\n                }\n            }\n            double coeff1 \u003d 0;\n            for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                coeff1 +\u003d work1[j] * work1[j];\n            }\n            double pc2 \u003d previousCost * previousCost;\n            coeff1 \u003d coeff1 / pc2;\n            double coeff2 \u003d lmPar * lmNorm * lmNorm / pc2;\n            double preRed \u003d coeff1 + 2 * coeff2;\n            double dirDer \u003d -(coeff1 + coeff2);\n            ratio \u003d (preRed \u003d\u003d 0) ? 0 : (actRed / preRed);\n            if (ratio \u003c\u003d 0.25) {\n                double tmp \u003d (actRed \u003c 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n                if ((0.1 * cost \u003e\u003d previousCost) || (tmp \u003c 0.1)) {\n                    tmp \u003d 0.1;\n                }\n                delta \u003d tmp * Math.min(delta, 10.0 * lmNorm);\n                lmPar /\u003d tmp;\n            } else if ((lmPar \u003d\u003d 0) || (ratio \u003e\u003d 0.75)) {\n                delta \u003d 2 * lmNorm;\n                lmPar *\u003d 0.5;\n            }\n            if (ratio \u003e\u003d 1.0e-4) {\n                firstIteration \u003d false;\n                xNorm \u003d 0;\n                for (int k \u003d 0; k \u003c cols; ++k) {\n                    double xK \u003d diag[k] * point[k];\n                    xNorm +\u003d xK * xK;\n                }\n                xNorm \u003d Math.sqrt(xNorm);\n            } else {\n                cost \u003d previousCost;\n                for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                    int pj \u003d permutation[j];\n                    point[pj] \u003d oldX[pj];\n                }\n                tmpVec \u003d residuals;\n                residuals \u003d oldRes;\n                oldRes \u003d tmpVec;\n            }\n            if (((Math.abs(actRed) \u003c\u003d costRelativeTolerance) \u0026\u0026 (preRed \u003c\u003d costRelativeTolerance) \u0026\u0026 (ratio \u003c\u003d 2.0)) || (delta \u003c\u003d parRelativeTolerance * xNorm)) {\n                return new VectorialPointValuePair(point, objective);\n            }\n            if ((Math.abs(actRed) \u003c\u003d 2.2204e-16) \u0026\u0026 (preRed \u003c\u003d 2.2204e-16) \u0026\u0026 (ratio \u003c\u003d 2.0)) {\n                throw new OptimizationException(\"cost relative tolerance is too small ({0}),\" + \" no further reduction in the\" + \" sum of squares is possible\", costRelativeTolerance);\n            } else if (delta \u003c\u003d 2.2204e-16 * xNorm) {\n                throw new OptimizationException(\"parameters relative tolerance is too small\" + \" ({0}), no further improvement in\" + \" the approximate solution is possible\", parRelativeTolerance);\n            } else if (maxCosine \u003c\u003d 2.2204e-16) {\n                throw new OptimizationException(\"orthogonality tolerance is too small ({0}),\" + \" solution is orthogonal to the jacobian\", orthoTolerance);\n            }\n        }\n    }\n}",
          "path": "src/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java",
          "functionStartLine": 212,
          "functionName": "doOptimize",
          "functionAnnotation": "",
          "functionDoc": "@inheritDoc}\n",
          "diff": "@@ -1,148 +1,148 @@\n-protected VectorialPointValuePair doOptimize() throws ObjectiveException, OptimizationException, IllegalArgumentException {\n+protected VectorialPointValuePair doOptimize() throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n     solvedCols \u003d Math.min(rows, cols);\n     diagR \u003d new double[cols];\n     jacNorm \u003d new double[cols];\n     beta \u003d new double[cols];\n     permutation \u003d new int[cols];\n     lmDir \u003d new double[cols];\n     double delta \u003d 0, xNorm \u003d 0;\n     double[] diag \u003d new double[cols];\n     double[] oldX \u003d new double[cols];\n     double[] oldRes \u003d new double[rows];\n     double[] work1 \u003d new double[cols];\n     double[] work2 \u003d new double[cols];\n     double[] work3 \u003d new double[cols];\n     updateResidualsAndCost();\n     lmPar \u003d 0;\n     boolean firstIteration \u003d true;\n     while (true) {\n         incrementIterationsCounter();\n         updateJacobian();\n         qrDecomposition();\n         qTy(residuals);\n         for (int k \u003d 0; k \u003c solvedCols; ++k) {\n             int pk \u003d permutation[k];\n             jacobian[k][pk] \u003d diagR[pk];\n         }\n         if (firstIteration) {\n             xNorm \u003d 0;\n             for (int k \u003d 0; k \u003c cols; ++k) {\n                 double dk \u003d jacNorm[k];\n                 if (dk \u003d\u003d 0) {\n                     dk \u003d 1.0;\n                 }\n-                double xk \u003d dk * variables[k];\n+                double xk \u003d dk * point[k];\n                 xNorm +\u003d xk * xk;\n                 diag[k] \u003d dk;\n             }\n             xNorm \u003d Math.sqrt(xNorm);\n             delta \u003d (xNorm \u003d\u003d 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n         }\n         double maxCosine \u003d 0;\n         if (cost !\u003d 0) {\n             for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                 int pj \u003d permutation[j];\n                 double s \u003d jacNorm[pj];\n                 if (s !\u003d 0) {\n                     double sum \u003d 0;\n                     for (int i \u003d 0; i \u003c\u003d j; ++i) {\n                         sum +\u003d jacobian[i][pj] * residuals[i];\n                     }\n                     maxCosine \u003d Math.max(maxCosine, Math.abs(sum) / (s * cost));\n                 }\n             }\n         }\n         if (maxCosine \u003c\u003d orthoTolerance) {\n-            return new VectorialPointValuePair(variables, objective);\n+            return new VectorialPointValuePair(point, objective);\n         }\n         for (int j \u003d 0; j \u003c cols; ++j) {\n             diag[j] \u003d Math.max(diag[j], jacNorm[j]);\n         }\n         for (double ratio \u003d 0; ratio \u003c 1.0e-4; ) {\n             for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                 int pj \u003d permutation[j];\n-                oldX[pj] \u003d variables[pj];\n+                oldX[pj] \u003d point[pj];\n             }\n             double previousCost \u003d cost;\n             double[] tmpVec \u003d residuals;\n             residuals \u003d oldRes;\n             oldRes \u003d tmpVec;\n             determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n             double lmNorm \u003d 0;\n             for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                 int pj \u003d permutation[j];\n                 lmDir[pj] \u003d -lmDir[pj];\n-                variables[pj] \u003d oldX[pj] + lmDir[pj];\n+                point[pj] \u003d oldX[pj] + lmDir[pj];\n                 double s \u003d diag[pj] * lmDir[pj];\n                 lmNorm +\u003d s * s;\n             }\n             lmNorm \u003d Math.sqrt(lmNorm);\n             if (firstIteration) {\n                 delta \u003d Math.min(delta, lmNorm);\n             }\n             updateResidualsAndCost();\n             double actRed \u003d -1.0;\n             if (0.1 * cost \u003c previousCost) {\n                 double r \u003d cost / previousCost;\n                 actRed \u003d 1.0 - r * r;\n             }\n             for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                 int pj \u003d permutation[j];\n                 double dirJ \u003d lmDir[pj];\n                 work1[j] \u003d 0;\n                 for (int i \u003d 0; i \u003c\u003d j; ++i) {\n                     work1[i] +\u003d jacobian[i][pj] * dirJ;\n                 }\n             }\n             double coeff1 \u003d 0;\n             for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                 coeff1 +\u003d work1[j] * work1[j];\n             }\n             double pc2 \u003d previousCost * previousCost;\n             coeff1 \u003d coeff1 / pc2;\n             double coeff2 \u003d lmPar * lmNorm * lmNorm / pc2;\n             double preRed \u003d coeff1 + 2 * coeff2;\n             double dirDer \u003d -(coeff1 + coeff2);\n             ratio \u003d (preRed \u003d\u003d 0) ? 0 : (actRed / preRed);\n             if (ratio \u003c\u003d 0.25) {\n                 double tmp \u003d (actRed \u003c 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n                 if ((0.1 * cost \u003e\u003d previousCost) || (tmp \u003c 0.1)) {\n                     tmp \u003d 0.1;\n                 }\n                 delta \u003d tmp * Math.min(delta, 10.0 * lmNorm);\n                 lmPar /\u003d tmp;\n             } else if ((lmPar \u003d\u003d 0) || (ratio \u003e\u003d 0.75)) {\n                 delta \u003d 2 * lmNorm;\n                 lmPar *\u003d 0.5;\n             }\n             if (ratio \u003e\u003d 1.0e-4) {\n                 firstIteration \u003d false;\n                 xNorm \u003d 0;\n                 for (int k \u003d 0; k \u003c cols; ++k) {\n-                    double xK \u003d diag[k] * variables[k];\n+                    double xK \u003d diag[k] * point[k];\n                     xNorm +\u003d xK * xK;\n                 }\n                 xNorm \u003d Math.sqrt(xNorm);\n             } else {\n                 cost \u003d previousCost;\n                 for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                     int pj \u003d permutation[j];\n-                    variables[pj] \u003d oldX[pj];\n+                    point[pj] \u003d oldX[pj];\n                 }\n                 tmpVec \u003d residuals;\n                 residuals \u003d oldRes;\n                 oldRes \u003d tmpVec;\n             }\n             if (((Math.abs(actRed) \u003c\u003d costRelativeTolerance) \u0026\u0026 (preRed \u003c\u003d costRelativeTolerance) \u0026\u0026 (ratio \u003c\u003d 2.0)) || (delta \u003c\u003d parRelativeTolerance * xNorm)) {\n-                return new VectorialPointValuePair(variables, objective);\n+                return new VectorialPointValuePair(point, objective);\n             }\n             if ((Math.abs(actRed) \u003c\u003d 2.2204e-16) \u0026\u0026 (preRed \u003c\u003d 2.2204e-16) \u0026\u0026 (ratio \u003c\u003d 2.0)) {\n                 throw new OptimizationException(\"cost relative tolerance is too small ({0}),\" + \" no further reduction in the\" + \" sum of squares is possible\", costRelativeTolerance);\n             } else if (delta \u003c\u003d 2.2204e-16 * xNorm) {\n                 throw new OptimizationException(\"parameters relative tolerance is too small\" + \" ({0}), no further improvement in\" + \" the approximate solution is possible\", parRelativeTolerance);\n             } else if (maxCosine \u003c\u003d 2.2204e-16) {\n                 throw new OptimizationException(\"orthogonality tolerance is too small ({0}),\" + \" solution is orthogonal to the jacobian\", orthoTolerance);\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[ObjectiveException, OptimizationException, IllegalArgumentException]",
            "newValue": "[FunctionEvaluationException, OptimizationException, IllegalArgumentException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "updated general algorithms with latest interfaces definitions\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@758058 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "3/24/09, 3:15 PM",
          "commitName": "ae6753dd5e4ce3b0ed9bd67f92d2d4e92587300f",
          "commitAuthor": "Luc Maisonobe",
          "commitDateOld": "3/22/09, 6:00 AM",
          "commitNameOld": "a7faf40b61f445d15d9a210b23fa0008b87e25e2",
          "commitAuthorOld": "Luc Maisonobe",
          "daysBetweenCommits": 2.39,
          "commitsBetweenForRepo": 10,
          "commitsBetweenForFile": 1,
          "actualSource": "protected VectorialPointValuePair doOptimize() throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n    solvedCols \u003d Math.min(rows, cols);\n    diagR \u003d new double[cols];\n    jacNorm \u003d new double[cols];\n    beta \u003d new double[cols];\n    permutation \u003d new int[cols];\n    lmDir \u003d new double[cols];\n    double delta \u003d 0, xNorm \u003d 0;\n    double[] diag \u003d new double[cols];\n    double[] oldX \u003d new double[cols];\n    double[] oldRes \u003d new double[rows];\n    double[] work1 \u003d new double[cols];\n    double[] work2 \u003d new double[cols];\n    double[] work3 \u003d new double[cols];\n    updateResidualsAndCost();\n    lmPar \u003d 0;\n    boolean firstIteration \u003d true;\n    while (true) {\n        incrementIterationsCounter();\n        updateJacobian();\n        qrDecomposition();\n        qTy(residuals);\n        for (int k \u003d 0; k \u003c solvedCols; ++k) {\n            int pk \u003d permutation[k];\n            jacobian[k][pk] \u003d diagR[pk];\n        }\n        if (firstIteration) {\n            xNorm \u003d 0;\n            for (int k \u003d 0; k \u003c cols; ++k) {\n                double dk \u003d jacNorm[k];\n                if (dk \u003d\u003d 0) {\n                    dk \u003d 1.0;\n                }\n                double xk \u003d dk * point[k];\n                xNorm +\u003d xk * xk;\n                diag[k] \u003d dk;\n            }\n            xNorm \u003d Math.sqrt(xNorm);\n            delta \u003d (xNorm \u003d\u003d 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n        }\n        double maxCosine \u003d 0;\n        if (cost !\u003d 0) {\n            for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                int pj \u003d permutation[j];\n                double s \u003d jacNorm[pj];\n                if (s !\u003d 0) {\n                    double sum \u003d 0;\n                    for (int i \u003d 0; i \u003c\u003d j; ++i) {\n                        sum +\u003d jacobian[i][pj] * residuals[i];\n                    }\n                    maxCosine \u003d Math.max(maxCosine, Math.abs(sum) / (s * cost));\n                }\n            }\n        }\n        if (maxCosine \u003c\u003d orthoTolerance) {\n            return new VectorialPointValuePair(point, objective);\n        }\n        for (int j \u003d 0; j \u003c cols; ++j) {\n            diag[j] \u003d Math.max(diag[j], jacNorm[j]);\n        }\n        for (double ratio \u003d 0; ratio \u003c 1.0e-4; ) {\n            for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                int pj \u003d permutation[j];\n                oldX[pj] \u003d point[pj];\n            }\n            double previousCost \u003d cost;\n            double[] tmpVec \u003d residuals;\n            residuals \u003d oldRes;\n            oldRes \u003d tmpVec;\n            determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n            double lmNorm \u003d 0;\n            for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                int pj \u003d permutation[j];\n                lmDir[pj] \u003d -lmDir[pj];\n                point[pj] \u003d oldX[pj] + lmDir[pj];\n                double s \u003d diag[pj] * lmDir[pj];\n                lmNorm +\u003d s * s;\n            }\n            lmNorm \u003d Math.sqrt(lmNorm);\n            if (firstIteration) {\n                delta \u003d Math.min(delta, lmNorm);\n            }\n            updateResidualsAndCost();\n            double actRed \u003d -1.0;\n            if (0.1 * cost \u003c previousCost) {\n                double r \u003d cost / previousCost;\n                actRed \u003d 1.0 - r * r;\n            }\n            for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                int pj \u003d permutation[j];\n                double dirJ \u003d lmDir[pj];\n                work1[j] \u003d 0;\n                for (int i \u003d 0; i \u003c\u003d j; ++i) {\n                    work1[i] +\u003d jacobian[i][pj] * dirJ;\n                }\n            }\n            double coeff1 \u003d 0;\n            for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                coeff1 +\u003d work1[j] * work1[j];\n            }\n            double pc2 \u003d previousCost * previousCost;\n            coeff1 \u003d coeff1 / pc2;\n            double coeff2 \u003d lmPar * lmNorm * lmNorm / pc2;\n            double preRed \u003d coeff1 + 2 * coeff2;\n            double dirDer \u003d -(coeff1 + coeff2);\n            ratio \u003d (preRed \u003d\u003d 0) ? 0 : (actRed / preRed);\n            if (ratio \u003c\u003d 0.25) {\n                double tmp \u003d (actRed \u003c 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n                if ((0.1 * cost \u003e\u003d previousCost) || (tmp \u003c 0.1)) {\n                    tmp \u003d 0.1;\n                }\n                delta \u003d tmp * Math.min(delta, 10.0 * lmNorm);\n                lmPar /\u003d tmp;\n            } else if ((lmPar \u003d\u003d 0) || (ratio \u003e\u003d 0.75)) {\n                delta \u003d 2 * lmNorm;\n                lmPar *\u003d 0.5;\n            }\n            if (ratio \u003e\u003d 1.0e-4) {\n                firstIteration \u003d false;\n                xNorm \u003d 0;\n                for (int k \u003d 0; k \u003c cols; ++k) {\n                    double xK \u003d diag[k] * point[k];\n                    xNorm +\u003d xK * xK;\n                }\n                xNorm \u003d Math.sqrt(xNorm);\n            } else {\n                cost \u003d previousCost;\n                for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                    int pj \u003d permutation[j];\n                    point[pj] \u003d oldX[pj];\n                }\n                tmpVec \u003d residuals;\n                residuals \u003d oldRes;\n                oldRes \u003d tmpVec;\n            }\n            if (((Math.abs(actRed) \u003c\u003d costRelativeTolerance) \u0026\u0026 (preRed \u003c\u003d costRelativeTolerance) \u0026\u0026 (ratio \u003c\u003d 2.0)) || (delta \u003c\u003d parRelativeTolerance * xNorm)) {\n                return new VectorialPointValuePair(point, objective);\n            }\n            if ((Math.abs(actRed) \u003c\u003d 2.2204e-16) \u0026\u0026 (preRed \u003c\u003d 2.2204e-16) \u0026\u0026 (ratio \u003c\u003d 2.0)) {\n                throw new OptimizationException(\"cost relative tolerance is too small ({0}),\" + \" no further reduction in the\" + \" sum of squares is possible\", costRelativeTolerance);\n            } else if (delta \u003c\u003d 2.2204e-16 * xNorm) {\n                throw new OptimizationException(\"parameters relative tolerance is too small\" + \" ({0}), no further improvement in\" + \" the approximate solution is possible\", parRelativeTolerance);\n            } else if (maxCosine \u003c\u003d 2.2204e-16) {\n                throw new OptimizationException(\"orthogonality tolerance is too small ({0}),\" + \" solution is orthogonal to the jacobian\", orthoTolerance);\n            }\n        }\n    }\n}",
          "path": "src/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java",
          "functionStartLine": 212,
          "functionName": "doOptimize",
          "functionAnnotation": "",
          "functionDoc": "@inheritDoc}\n",
          "diff": "@@ -1,148 +1,148 @@\n-protected VectorialPointValuePair doOptimize() throws ObjectiveException, OptimizationException, IllegalArgumentException {\n+protected VectorialPointValuePair doOptimize() throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n     solvedCols \u003d Math.min(rows, cols);\n     diagR \u003d new double[cols];\n     jacNorm \u003d new double[cols];\n     beta \u003d new double[cols];\n     permutation \u003d new int[cols];\n     lmDir \u003d new double[cols];\n     double delta \u003d 0, xNorm \u003d 0;\n     double[] diag \u003d new double[cols];\n     double[] oldX \u003d new double[cols];\n     double[] oldRes \u003d new double[rows];\n     double[] work1 \u003d new double[cols];\n     double[] work2 \u003d new double[cols];\n     double[] work3 \u003d new double[cols];\n     updateResidualsAndCost();\n     lmPar \u003d 0;\n     boolean firstIteration \u003d true;\n     while (true) {\n         incrementIterationsCounter();\n         updateJacobian();\n         qrDecomposition();\n         qTy(residuals);\n         for (int k \u003d 0; k \u003c solvedCols; ++k) {\n             int pk \u003d permutation[k];\n             jacobian[k][pk] \u003d diagR[pk];\n         }\n         if (firstIteration) {\n             xNorm \u003d 0;\n             for (int k \u003d 0; k \u003c cols; ++k) {\n                 double dk \u003d jacNorm[k];\n                 if (dk \u003d\u003d 0) {\n                     dk \u003d 1.0;\n                 }\n-                double xk \u003d dk * variables[k];\n+                double xk \u003d dk * point[k];\n                 xNorm +\u003d xk * xk;\n                 diag[k] \u003d dk;\n             }\n             xNorm \u003d Math.sqrt(xNorm);\n             delta \u003d (xNorm \u003d\u003d 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n         }\n         double maxCosine \u003d 0;\n         if (cost !\u003d 0) {\n             for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                 int pj \u003d permutation[j];\n                 double s \u003d jacNorm[pj];\n                 if (s !\u003d 0) {\n                     double sum \u003d 0;\n                     for (int i \u003d 0; i \u003c\u003d j; ++i) {\n                         sum +\u003d jacobian[i][pj] * residuals[i];\n                     }\n                     maxCosine \u003d Math.max(maxCosine, Math.abs(sum) / (s * cost));\n                 }\n             }\n         }\n         if (maxCosine \u003c\u003d orthoTolerance) {\n-            return new VectorialPointValuePair(variables, objective);\n+            return new VectorialPointValuePair(point, objective);\n         }\n         for (int j \u003d 0; j \u003c cols; ++j) {\n             diag[j] \u003d Math.max(diag[j], jacNorm[j]);\n         }\n         for (double ratio \u003d 0; ratio \u003c 1.0e-4; ) {\n             for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                 int pj \u003d permutation[j];\n-                oldX[pj] \u003d variables[pj];\n+                oldX[pj] \u003d point[pj];\n             }\n             double previousCost \u003d cost;\n             double[] tmpVec \u003d residuals;\n             residuals \u003d oldRes;\n             oldRes \u003d tmpVec;\n             determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n             double lmNorm \u003d 0;\n             for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                 int pj \u003d permutation[j];\n                 lmDir[pj] \u003d -lmDir[pj];\n-                variables[pj] \u003d oldX[pj] + lmDir[pj];\n+                point[pj] \u003d oldX[pj] + lmDir[pj];\n                 double s \u003d diag[pj] * lmDir[pj];\n                 lmNorm +\u003d s * s;\n             }\n             lmNorm \u003d Math.sqrt(lmNorm);\n             if (firstIteration) {\n                 delta \u003d Math.min(delta, lmNorm);\n             }\n             updateResidualsAndCost();\n             double actRed \u003d -1.0;\n             if (0.1 * cost \u003c previousCost) {\n                 double r \u003d cost / previousCost;\n                 actRed \u003d 1.0 - r * r;\n             }\n             for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                 int pj \u003d permutation[j];\n                 double dirJ \u003d lmDir[pj];\n                 work1[j] \u003d 0;\n                 for (int i \u003d 0; i \u003c\u003d j; ++i) {\n                     work1[i] +\u003d jacobian[i][pj] * dirJ;\n                 }\n             }\n             double coeff1 \u003d 0;\n             for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                 coeff1 +\u003d work1[j] * work1[j];\n             }\n             double pc2 \u003d previousCost * previousCost;\n             coeff1 \u003d coeff1 / pc2;\n             double coeff2 \u003d lmPar * lmNorm * lmNorm / pc2;\n             double preRed \u003d coeff1 + 2 * coeff2;\n             double dirDer \u003d -(coeff1 + coeff2);\n             ratio \u003d (preRed \u003d\u003d 0) ? 0 : (actRed / preRed);\n             if (ratio \u003c\u003d 0.25) {\n                 double tmp \u003d (actRed \u003c 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n                 if ((0.1 * cost \u003e\u003d previousCost) || (tmp \u003c 0.1)) {\n                     tmp \u003d 0.1;\n                 }\n                 delta \u003d tmp * Math.min(delta, 10.0 * lmNorm);\n                 lmPar /\u003d tmp;\n             } else if ((lmPar \u003d\u003d 0) || (ratio \u003e\u003d 0.75)) {\n                 delta \u003d 2 * lmNorm;\n                 lmPar *\u003d 0.5;\n             }\n             if (ratio \u003e\u003d 1.0e-4) {\n                 firstIteration \u003d false;\n                 xNorm \u003d 0;\n                 for (int k \u003d 0; k \u003c cols; ++k) {\n-                    double xK \u003d diag[k] * variables[k];\n+                    double xK \u003d diag[k] * point[k];\n                     xNorm +\u003d xK * xK;\n                 }\n                 xNorm \u003d Math.sqrt(xNorm);\n             } else {\n                 cost \u003d previousCost;\n                 for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                     int pj \u003d permutation[j];\n-                    variables[pj] \u003d oldX[pj];\n+                    point[pj] \u003d oldX[pj];\n                 }\n                 tmpVec \u003d residuals;\n                 residuals \u003d oldRes;\n                 oldRes \u003d tmpVec;\n             }\n             if (((Math.abs(actRed) \u003c\u003d costRelativeTolerance) \u0026\u0026 (preRed \u003c\u003d costRelativeTolerance) \u0026\u0026 (ratio \u003c\u003d 2.0)) || (delta \u003c\u003d parRelativeTolerance * xNorm)) {\n-                return new VectorialPointValuePair(variables, objective);\n+                return new VectorialPointValuePair(point, objective);\n             }\n             if ((Math.abs(actRed) \u003c\u003d 2.2204e-16) \u0026\u0026 (preRed \u003c\u003d 2.2204e-16) \u0026\u0026 (ratio \u003c\u003d 2.0)) {\n                 throw new OptimizationException(\"cost relative tolerance is too small ({0}),\" + \" no further reduction in the\" + \" sum of squares is possible\", costRelativeTolerance);\n             } else if (delta \u003c\u003d 2.2204e-16 * xNorm) {\n                 throw new OptimizationException(\"parameters relative tolerance is too small\" + \" ({0}), no further improvement in\" + \" the approximate solution is possible\", parRelativeTolerance);\n             } else if (maxCosine \u003c\u003d 2.2204e-16) {\n                 throw new OptimizationException(\"orthogonality tolerance is too small ({0}),\" + \" solution is orthogonal to the jacobian\", orthoTolerance);\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "a7faf40b61f445d15d9a210b23fa0008b87e25e2": {
      "type": "Ybodychange",
      "commitMessage": "separated iteration counter from function evaluation counters,\nsome optimizers are based on gradient/jacobian only and cannot\nreliably be protected by monitoring the objective function calls.\n\nWe now have two or three counters for each algorithm:\n - iteration counter, which is checked against a max allowance\n   to prevent infinite loops if no convergence is reached\n - objective function evaluations, for user information only\n - objective function gradient/jacobian if the function is\n   differentiable, for user information only\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@757181 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "3/22/09, 6:00 AM",
      "commitName": "a7faf40b61f445d15d9a210b23fa0008b87e25e2",
      "commitAuthor": "Luc Maisonobe",
      "commitDateOld": "3/15/09, 12:11 PM",
      "commitNameOld": "8541f303370cec9a25f2b32b3d660b3f188913f0",
      "commitAuthorOld": "Luc Maisonobe",
      "daysBetweenCommits": 6.74,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "protected VectorialPointValuePair doOptimize() throws ObjectiveException, OptimizationException, IllegalArgumentException {\n    solvedCols \u003d Math.min(rows, cols);\n    diagR \u003d new double[cols];\n    jacNorm \u003d new double[cols];\n    beta \u003d new double[cols];\n    permutation \u003d new int[cols];\n    lmDir \u003d new double[cols];\n    double delta \u003d 0, xNorm \u003d 0;\n    double[] diag \u003d new double[cols];\n    double[] oldX \u003d new double[cols];\n    double[] oldRes \u003d new double[rows];\n    double[] work1 \u003d new double[cols];\n    double[] work2 \u003d new double[cols];\n    double[] work3 \u003d new double[cols];\n    updateResidualsAndCost();\n    lmPar \u003d 0;\n    boolean firstIteration \u003d true;\n    while (true) {\n        incrementIterationsCounter();\n        updateJacobian();\n        qrDecomposition();\n        qTy(residuals);\n        for (int k \u003d 0; k \u003c solvedCols; ++k) {\n            int pk \u003d permutation[k];\n            jacobian[k][pk] \u003d diagR[pk];\n        }\n        if (firstIteration) {\n            xNorm \u003d 0;\n            for (int k \u003d 0; k \u003c cols; ++k) {\n                double dk \u003d jacNorm[k];\n                if (dk \u003d\u003d 0) {\n                    dk \u003d 1.0;\n                }\n                double xk \u003d dk * variables[k];\n                xNorm +\u003d xk * xk;\n                diag[k] \u003d dk;\n            }\n            xNorm \u003d Math.sqrt(xNorm);\n            delta \u003d (xNorm \u003d\u003d 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n        }\n        double maxCosine \u003d 0;\n        if (cost !\u003d 0) {\n            for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                int pj \u003d permutation[j];\n                double s \u003d jacNorm[pj];\n                if (s !\u003d 0) {\n                    double sum \u003d 0;\n                    for (int i \u003d 0; i \u003c\u003d j; ++i) {\n                        sum +\u003d jacobian[i][pj] * residuals[i];\n                    }\n                    maxCosine \u003d Math.max(maxCosine, Math.abs(sum) / (s * cost));\n                }\n            }\n        }\n        if (maxCosine \u003c\u003d orthoTolerance) {\n            return new VectorialPointValuePair(variables, objective);\n        }\n        for (int j \u003d 0; j \u003c cols; ++j) {\n            diag[j] \u003d Math.max(diag[j], jacNorm[j]);\n        }\n        for (double ratio \u003d 0; ratio \u003c 1.0e-4; ) {\n            for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                int pj \u003d permutation[j];\n                oldX[pj] \u003d variables[pj];\n            }\n            double previousCost \u003d cost;\n            double[] tmpVec \u003d residuals;\n            residuals \u003d oldRes;\n            oldRes \u003d tmpVec;\n            determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n            double lmNorm \u003d 0;\n            for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                int pj \u003d permutation[j];\n                lmDir[pj] \u003d -lmDir[pj];\n                variables[pj] \u003d oldX[pj] + lmDir[pj];\n                double s \u003d diag[pj] * lmDir[pj];\n                lmNorm +\u003d s * s;\n            }\n            lmNorm \u003d Math.sqrt(lmNorm);\n            if (firstIteration) {\n                delta \u003d Math.min(delta, lmNorm);\n            }\n            updateResidualsAndCost();\n            double actRed \u003d -1.0;\n            if (0.1 * cost \u003c previousCost) {\n                double r \u003d cost / previousCost;\n                actRed \u003d 1.0 - r * r;\n            }\n            for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                int pj \u003d permutation[j];\n                double dirJ \u003d lmDir[pj];\n                work1[j] \u003d 0;\n                for (int i \u003d 0; i \u003c\u003d j; ++i) {\n                    work1[i] +\u003d jacobian[i][pj] * dirJ;\n                }\n            }\n            double coeff1 \u003d 0;\n            for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                coeff1 +\u003d work1[j] * work1[j];\n            }\n            double pc2 \u003d previousCost * previousCost;\n            coeff1 \u003d coeff1 / pc2;\n            double coeff2 \u003d lmPar * lmNorm * lmNorm / pc2;\n            double preRed \u003d coeff1 + 2 * coeff2;\n            double dirDer \u003d -(coeff1 + coeff2);\n            ratio \u003d (preRed \u003d\u003d 0) ? 0 : (actRed / preRed);\n            if (ratio \u003c\u003d 0.25) {\n                double tmp \u003d (actRed \u003c 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n                if ((0.1 * cost \u003e\u003d previousCost) || (tmp \u003c 0.1)) {\n                    tmp \u003d 0.1;\n                }\n                delta \u003d tmp * Math.min(delta, 10.0 * lmNorm);\n                lmPar /\u003d tmp;\n            } else if ((lmPar \u003d\u003d 0) || (ratio \u003e\u003d 0.75)) {\n                delta \u003d 2 * lmNorm;\n                lmPar *\u003d 0.5;\n            }\n            if (ratio \u003e\u003d 1.0e-4) {\n                firstIteration \u003d false;\n                xNorm \u003d 0;\n                for (int k \u003d 0; k \u003c cols; ++k) {\n                    double xK \u003d diag[k] * variables[k];\n                    xNorm +\u003d xK * xK;\n                }\n                xNorm \u003d Math.sqrt(xNorm);\n            } else {\n                cost \u003d previousCost;\n                for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                    int pj \u003d permutation[j];\n                    variables[pj] \u003d oldX[pj];\n                }\n                tmpVec \u003d residuals;\n                residuals \u003d oldRes;\n                oldRes \u003d tmpVec;\n            }\n            if (((Math.abs(actRed) \u003c\u003d costRelativeTolerance) \u0026\u0026 (preRed \u003c\u003d costRelativeTolerance) \u0026\u0026 (ratio \u003c\u003d 2.0)) || (delta \u003c\u003d parRelativeTolerance * xNorm)) {\n                return new VectorialPointValuePair(variables, objective);\n            }\n            if ((Math.abs(actRed) \u003c\u003d 2.2204e-16) \u0026\u0026 (preRed \u003c\u003d 2.2204e-16) \u0026\u0026 (ratio \u003c\u003d 2.0)) {\n                throw new OptimizationException(\"cost relative tolerance is too small ({0}),\" + \" no further reduction in the\" + \" sum of squares is possible\", costRelativeTolerance);\n            } else if (delta \u003c\u003d 2.2204e-16 * xNorm) {\n                throw new OptimizationException(\"parameters relative tolerance is too small\" + \" ({0}), no further improvement in\" + \" the approximate solution is possible\", parRelativeTolerance);\n            } else if (maxCosine \u003c\u003d 2.2204e-16) {\n                throw new OptimizationException(\"orthogonality tolerance is too small ({0}),\" + \" solution is orthogonal to the jacobian\", orthoTolerance);\n            }\n        }\n    }\n}",
      "path": "src/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java",
      "functionStartLine": 212,
      "functionName": "doOptimize",
      "functionAnnotation": "",
      "functionDoc": "@inheritDoc}\n",
      "diff": "@@ -1,147 +1,148 @@\n protected VectorialPointValuePair doOptimize() throws ObjectiveException, OptimizationException, IllegalArgumentException {\n     solvedCols \u003d Math.min(rows, cols);\n     diagR \u003d new double[cols];\n     jacNorm \u003d new double[cols];\n     beta \u003d new double[cols];\n     permutation \u003d new int[cols];\n     lmDir \u003d new double[cols];\n     double delta \u003d 0, xNorm \u003d 0;\n     double[] diag \u003d new double[cols];\n     double[] oldX \u003d new double[cols];\n     double[] oldRes \u003d new double[rows];\n     double[] work1 \u003d new double[cols];\n     double[] work2 \u003d new double[cols];\n     double[] work3 \u003d new double[cols];\n     updateResidualsAndCost();\n     lmPar \u003d 0;\n     boolean firstIteration \u003d true;\n     while (true) {\n+        incrementIterationsCounter();\n         updateJacobian();\n         qrDecomposition();\n         qTy(residuals);\n         for (int k \u003d 0; k \u003c solvedCols; ++k) {\n             int pk \u003d permutation[k];\n             jacobian[k][pk] \u003d diagR[pk];\n         }\n         if (firstIteration) {\n             xNorm \u003d 0;\n             for (int k \u003d 0; k \u003c cols; ++k) {\n                 double dk \u003d jacNorm[k];\n                 if (dk \u003d\u003d 0) {\n                     dk \u003d 1.0;\n                 }\n                 double xk \u003d dk * variables[k];\n                 xNorm +\u003d xk * xk;\n                 diag[k] \u003d dk;\n             }\n             xNorm \u003d Math.sqrt(xNorm);\n             delta \u003d (xNorm \u003d\u003d 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n         }\n         double maxCosine \u003d 0;\n         if (cost !\u003d 0) {\n             for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                 int pj \u003d permutation[j];\n                 double s \u003d jacNorm[pj];\n                 if (s !\u003d 0) {\n                     double sum \u003d 0;\n                     for (int i \u003d 0; i \u003c\u003d j; ++i) {\n                         sum +\u003d jacobian[i][pj] * residuals[i];\n                     }\n                     maxCosine \u003d Math.max(maxCosine, Math.abs(sum) / (s * cost));\n                 }\n             }\n         }\n         if (maxCosine \u003c\u003d orthoTolerance) {\n             return new VectorialPointValuePair(variables, objective);\n         }\n         for (int j \u003d 0; j \u003c cols; ++j) {\n             diag[j] \u003d Math.max(diag[j], jacNorm[j]);\n         }\n         for (double ratio \u003d 0; ratio \u003c 1.0e-4; ) {\n             for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                 int pj \u003d permutation[j];\n                 oldX[pj] \u003d variables[pj];\n             }\n             double previousCost \u003d cost;\n             double[] tmpVec \u003d residuals;\n             residuals \u003d oldRes;\n             oldRes \u003d tmpVec;\n             determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n             double lmNorm \u003d 0;\n             for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                 int pj \u003d permutation[j];\n                 lmDir[pj] \u003d -lmDir[pj];\n                 variables[pj] \u003d oldX[pj] + lmDir[pj];\n                 double s \u003d diag[pj] * lmDir[pj];\n                 lmNorm +\u003d s * s;\n             }\n             lmNorm \u003d Math.sqrt(lmNorm);\n             if (firstIteration) {\n                 delta \u003d Math.min(delta, lmNorm);\n             }\n             updateResidualsAndCost();\n             double actRed \u003d -1.0;\n             if (0.1 * cost \u003c previousCost) {\n                 double r \u003d cost / previousCost;\n                 actRed \u003d 1.0 - r * r;\n             }\n             for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                 int pj \u003d permutation[j];\n                 double dirJ \u003d lmDir[pj];\n                 work1[j] \u003d 0;\n                 for (int i \u003d 0; i \u003c\u003d j; ++i) {\n                     work1[i] +\u003d jacobian[i][pj] * dirJ;\n                 }\n             }\n             double coeff1 \u003d 0;\n             for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                 coeff1 +\u003d work1[j] * work1[j];\n             }\n             double pc2 \u003d previousCost * previousCost;\n             coeff1 \u003d coeff1 / pc2;\n             double coeff2 \u003d lmPar * lmNorm * lmNorm / pc2;\n             double preRed \u003d coeff1 + 2 * coeff2;\n             double dirDer \u003d -(coeff1 + coeff2);\n             ratio \u003d (preRed \u003d\u003d 0) ? 0 : (actRed / preRed);\n             if (ratio \u003c\u003d 0.25) {\n                 double tmp \u003d (actRed \u003c 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n                 if ((0.1 * cost \u003e\u003d previousCost) || (tmp \u003c 0.1)) {\n                     tmp \u003d 0.1;\n                 }\n                 delta \u003d tmp * Math.min(delta, 10.0 * lmNorm);\n                 lmPar /\u003d tmp;\n             } else if ((lmPar \u003d\u003d 0) || (ratio \u003e\u003d 0.75)) {\n                 delta \u003d 2 * lmNorm;\n                 lmPar *\u003d 0.5;\n             }\n             if (ratio \u003e\u003d 1.0e-4) {\n                 firstIteration \u003d false;\n                 xNorm \u003d 0;\n                 for (int k \u003d 0; k \u003c cols; ++k) {\n                     double xK \u003d diag[k] * variables[k];\n                     xNorm +\u003d xK * xK;\n                 }\n                 xNorm \u003d Math.sqrt(xNorm);\n             } else {\n                 cost \u003d previousCost;\n                 for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                     int pj \u003d permutation[j];\n                     variables[pj] \u003d oldX[pj];\n                 }\n                 tmpVec \u003d residuals;\n                 residuals \u003d oldRes;\n                 oldRes \u003d tmpVec;\n             }\n             if (((Math.abs(actRed) \u003c\u003d costRelativeTolerance) \u0026\u0026 (preRed \u003c\u003d costRelativeTolerance) \u0026\u0026 (ratio \u003c\u003d 2.0)) || (delta \u003c\u003d parRelativeTolerance * xNorm)) {\n                 return new VectorialPointValuePair(variables, objective);\n             }\n             if ((Math.abs(actRed) \u003c\u003d 2.2204e-16) \u0026\u0026 (preRed \u003c\u003d 2.2204e-16) \u0026\u0026 (ratio \u003c\u003d 2.0)) {\n                 throw new OptimizationException(\"cost relative tolerance is too small ({0}),\" + \" no further reduction in the\" + \" sum of squares is possible\", costRelativeTolerance);\n             } else if (delta \u003c\u003d 2.2204e-16 * xNorm) {\n                 throw new OptimizationException(\"parameters relative tolerance is too small\" + \" ({0}), no further improvement in\" + \" the approximate solution is possible\", parRelativeTolerance);\n             } else if (maxCosine \u003c\u003d 2.2204e-16) {\n                 throw new OptimizationException(\"orthogonality tolerance is too small ({0}),\" + \" solution is orthogonal to the jacobian\", orthoTolerance);\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8541f303370cec9a25f2b32b3d660b3f188913f0": {
      "type": "Yintroduced",
      "commitMessage": "adapted old Levenberg-Marquardt estimator to new top level optimizers API\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@754727 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "3/15/09, 12:11 PM",
      "commitName": "8541f303370cec9a25f2b32b3d660b3f188913f0",
      "commitAuthor": "Luc Maisonobe",
      "diff": "@@ -0,0 +1,147 @@\n+protected VectorialPointValuePair doOptimize() throws ObjectiveException, OptimizationException, IllegalArgumentException {\n+    solvedCols \u003d Math.min(rows, cols);\n+    diagR \u003d new double[cols];\n+    jacNorm \u003d new double[cols];\n+    beta \u003d new double[cols];\n+    permutation \u003d new int[cols];\n+    lmDir \u003d new double[cols];\n+    double delta \u003d 0, xNorm \u003d 0;\n+    double[] diag \u003d new double[cols];\n+    double[] oldX \u003d new double[cols];\n+    double[] oldRes \u003d new double[rows];\n+    double[] work1 \u003d new double[cols];\n+    double[] work2 \u003d new double[cols];\n+    double[] work3 \u003d new double[cols];\n+    updateResidualsAndCost();\n+    lmPar \u003d 0;\n+    boolean firstIteration \u003d true;\n+    while (true) {\n+        updateJacobian();\n+        qrDecomposition();\n+        qTy(residuals);\n+        for (int k \u003d 0; k \u003c solvedCols; ++k) {\n+            int pk \u003d permutation[k];\n+            jacobian[k][pk] \u003d diagR[pk];\n+        }\n+        if (firstIteration) {\n+            xNorm \u003d 0;\n+            for (int k \u003d 0; k \u003c cols; ++k) {\n+                double dk \u003d jacNorm[k];\n+                if (dk \u003d\u003d 0) {\n+                    dk \u003d 1.0;\n+                }\n+                double xk \u003d dk * variables[k];\n+                xNorm +\u003d xk * xk;\n+                diag[k] \u003d dk;\n+            }\n+            xNorm \u003d Math.sqrt(xNorm);\n+            delta \u003d (xNorm \u003d\u003d 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n+        }\n+        double maxCosine \u003d 0;\n+        if (cost !\u003d 0) {\n+            for (int j \u003d 0; j \u003c solvedCols; ++j) {\n+                int pj \u003d permutation[j];\n+                double s \u003d jacNorm[pj];\n+                if (s !\u003d 0) {\n+                    double sum \u003d 0;\n+                    for (int i \u003d 0; i \u003c\u003d j; ++i) {\n+                        sum +\u003d jacobian[i][pj] * residuals[i];\n+                    }\n+                    maxCosine \u003d Math.max(maxCosine, Math.abs(sum) / (s * cost));\n+                }\n+            }\n+        }\n+        if (maxCosine \u003c\u003d orthoTolerance) {\n+            return new VectorialPointValuePair(variables, objective);\n+        }\n+        for (int j \u003d 0; j \u003c cols; ++j) {\n+            diag[j] \u003d Math.max(diag[j], jacNorm[j]);\n+        }\n+        for (double ratio \u003d 0; ratio \u003c 1.0e-4; ) {\n+            for (int j \u003d 0; j \u003c solvedCols; ++j) {\n+                int pj \u003d permutation[j];\n+                oldX[pj] \u003d variables[pj];\n+            }\n+            double previousCost \u003d cost;\n+            double[] tmpVec \u003d residuals;\n+            residuals \u003d oldRes;\n+            oldRes \u003d tmpVec;\n+            determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n+            double lmNorm \u003d 0;\n+            for (int j \u003d 0; j \u003c solvedCols; ++j) {\n+                int pj \u003d permutation[j];\n+                lmDir[pj] \u003d -lmDir[pj];\n+                variables[pj] \u003d oldX[pj] + lmDir[pj];\n+                double s \u003d diag[pj] * lmDir[pj];\n+                lmNorm +\u003d s * s;\n+            }\n+            lmNorm \u003d Math.sqrt(lmNorm);\n+            if (firstIteration) {\n+                delta \u003d Math.min(delta, lmNorm);\n+            }\n+            updateResidualsAndCost();\n+            double actRed \u003d -1.0;\n+            if (0.1 * cost \u003c previousCost) {\n+                double r \u003d cost / previousCost;\n+                actRed \u003d 1.0 - r * r;\n+            }\n+            for (int j \u003d 0; j \u003c solvedCols; ++j) {\n+                int pj \u003d permutation[j];\n+                double dirJ \u003d lmDir[pj];\n+                work1[j] \u003d 0;\n+                for (int i \u003d 0; i \u003c\u003d j; ++i) {\n+                    work1[i] +\u003d jacobian[i][pj] * dirJ;\n+                }\n+            }\n+            double coeff1 \u003d 0;\n+            for (int j \u003d 0; j \u003c solvedCols; ++j) {\n+                coeff1 +\u003d work1[j] * work1[j];\n+            }\n+            double pc2 \u003d previousCost * previousCost;\n+            coeff1 \u003d coeff1 / pc2;\n+            double coeff2 \u003d lmPar * lmNorm * lmNorm / pc2;\n+            double preRed \u003d coeff1 + 2 * coeff2;\n+            double dirDer \u003d -(coeff1 + coeff2);\n+            ratio \u003d (preRed \u003d\u003d 0) ? 0 : (actRed / preRed);\n+            if (ratio \u003c\u003d 0.25) {\n+                double tmp \u003d (actRed \u003c 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n+                if ((0.1 * cost \u003e\u003d previousCost) || (tmp \u003c 0.1)) {\n+                    tmp \u003d 0.1;\n+                }\n+                delta \u003d tmp * Math.min(delta, 10.0 * lmNorm);\n+                lmPar /\u003d tmp;\n+            } else if ((lmPar \u003d\u003d 0) || (ratio \u003e\u003d 0.75)) {\n+                delta \u003d 2 * lmNorm;\n+                lmPar *\u003d 0.5;\n+            }\n+            if (ratio \u003e\u003d 1.0e-4) {\n+                firstIteration \u003d false;\n+                xNorm \u003d 0;\n+                for (int k \u003d 0; k \u003c cols; ++k) {\n+                    double xK \u003d diag[k] * variables[k];\n+                    xNorm +\u003d xK * xK;\n+                }\n+                xNorm \u003d Math.sqrt(xNorm);\n+            } else {\n+                cost \u003d previousCost;\n+                for (int j \u003d 0; j \u003c solvedCols; ++j) {\n+                    int pj \u003d permutation[j];\n+                    variables[pj] \u003d oldX[pj];\n+                }\n+                tmpVec \u003d residuals;\n+                residuals \u003d oldRes;\n+                oldRes \u003d tmpVec;\n+            }\n+            if (((Math.abs(actRed) \u003c\u003d costRelativeTolerance) \u0026\u0026 (preRed \u003c\u003d costRelativeTolerance) \u0026\u0026 (ratio \u003c\u003d 2.0)) || (delta \u003c\u003d parRelativeTolerance * xNorm)) {\n+                return new VectorialPointValuePair(variables, objective);\n+            }\n+            if ((Math.abs(actRed) \u003c\u003d 2.2204e-16) \u0026\u0026 (preRed \u003c\u003d 2.2204e-16) \u0026\u0026 (ratio \u003c\u003d 2.0)) {\n+                throw new OptimizationException(\"cost relative tolerance is too small ({0}),\" + \" no further reduction in the\" + \" sum of squares is possible\", costRelativeTolerance);\n+            } else if (delta \u003c\u003d 2.2204e-16 * xNorm) {\n+                throw new OptimizationException(\"parameters relative tolerance is too small\" + \" ({0}), no further improvement in\" + \" the approximate solution is possible\", parRelativeTolerance);\n+            } else if (maxCosine \u003c\u003d 2.2204e-16) {\n+                throw new OptimizationException(\"orthogonality tolerance is too small ({0}),\" + \" solution is orthogonal to the jacobian\", orthoTolerance);\n+            }\n+        }\n+    }\n+}\n\\ No newline at end of file\n",
      "actualSource": "protected VectorialPointValuePair doOptimize() throws ObjectiveException, OptimizationException, IllegalArgumentException {\n    solvedCols \u003d Math.min(rows, cols);\n    diagR \u003d new double[cols];\n    jacNorm \u003d new double[cols];\n    beta \u003d new double[cols];\n    permutation \u003d new int[cols];\n    lmDir \u003d new double[cols];\n    double delta \u003d 0, xNorm \u003d 0;\n    double[] diag \u003d new double[cols];\n    double[] oldX \u003d new double[cols];\n    double[] oldRes \u003d new double[rows];\n    double[] work1 \u003d new double[cols];\n    double[] work2 \u003d new double[cols];\n    double[] work3 \u003d new double[cols];\n    updateResidualsAndCost();\n    lmPar \u003d 0;\n    boolean firstIteration \u003d true;\n    while (true) {\n        updateJacobian();\n        qrDecomposition();\n        qTy(residuals);\n        for (int k \u003d 0; k \u003c solvedCols; ++k) {\n            int pk \u003d permutation[k];\n            jacobian[k][pk] \u003d diagR[pk];\n        }\n        if (firstIteration) {\n            xNorm \u003d 0;\n            for (int k \u003d 0; k \u003c cols; ++k) {\n                double dk \u003d jacNorm[k];\n                if (dk \u003d\u003d 0) {\n                    dk \u003d 1.0;\n                }\n                double xk \u003d dk * variables[k];\n                xNorm +\u003d xk * xk;\n                diag[k] \u003d dk;\n            }\n            xNorm \u003d Math.sqrt(xNorm);\n            delta \u003d (xNorm \u003d\u003d 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n        }\n        double maxCosine \u003d 0;\n        if (cost !\u003d 0) {\n            for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                int pj \u003d permutation[j];\n                double s \u003d jacNorm[pj];\n                if (s !\u003d 0) {\n                    double sum \u003d 0;\n                    for (int i \u003d 0; i \u003c\u003d j; ++i) {\n                        sum +\u003d jacobian[i][pj] * residuals[i];\n                    }\n                    maxCosine \u003d Math.max(maxCosine, Math.abs(sum) / (s * cost));\n                }\n            }\n        }\n        if (maxCosine \u003c\u003d orthoTolerance) {\n            return new VectorialPointValuePair(variables, objective);\n        }\n        for (int j \u003d 0; j \u003c cols; ++j) {\n            diag[j] \u003d Math.max(diag[j], jacNorm[j]);\n        }\n        for (double ratio \u003d 0; ratio \u003c 1.0e-4; ) {\n            for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                int pj \u003d permutation[j];\n                oldX[pj] \u003d variables[pj];\n            }\n            double previousCost \u003d cost;\n            double[] tmpVec \u003d residuals;\n            residuals \u003d oldRes;\n            oldRes \u003d tmpVec;\n            determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n            double lmNorm \u003d 0;\n            for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                int pj \u003d permutation[j];\n                lmDir[pj] \u003d -lmDir[pj];\n                variables[pj] \u003d oldX[pj] + lmDir[pj];\n                double s \u003d diag[pj] * lmDir[pj];\n                lmNorm +\u003d s * s;\n            }\n            lmNorm \u003d Math.sqrt(lmNorm);\n            if (firstIteration) {\n                delta \u003d Math.min(delta, lmNorm);\n            }\n            updateResidualsAndCost();\n            double actRed \u003d -1.0;\n            if (0.1 * cost \u003c previousCost) {\n                double r \u003d cost / previousCost;\n                actRed \u003d 1.0 - r * r;\n            }\n            for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                int pj \u003d permutation[j];\n                double dirJ \u003d lmDir[pj];\n                work1[j] \u003d 0;\n                for (int i \u003d 0; i \u003c\u003d j; ++i) {\n                    work1[i] +\u003d jacobian[i][pj] * dirJ;\n                }\n            }\n            double coeff1 \u003d 0;\n            for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                coeff1 +\u003d work1[j] * work1[j];\n            }\n            double pc2 \u003d previousCost * previousCost;\n            coeff1 \u003d coeff1 / pc2;\n            double coeff2 \u003d lmPar * lmNorm * lmNorm / pc2;\n            double preRed \u003d coeff1 + 2 * coeff2;\n            double dirDer \u003d -(coeff1 + coeff2);\n            ratio \u003d (preRed \u003d\u003d 0) ? 0 : (actRed / preRed);\n            if (ratio \u003c\u003d 0.25) {\n                double tmp \u003d (actRed \u003c 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n                if ((0.1 * cost \u003e\u003d previousCost) || (tmp \u003c 0.1)) {\n                    tmp \u003d 0.1;\n                }\n                delta \u003d tmp * Math.min(delta, 10.0 * lmNorm);\n                lmPar /\u003d tmp;\n            } else if ((lmPar \u003d\u003d 0) || (ratio \u003e\u003d 0.75)) {\n                delta \u003d 2 * lmNorm;\n                lmPar *\u003d 0.5;\n            }\n            if (ratio \u003e\u003d 1.0e-4) {\n                firstIteration \u003d false;\n                xNorm \u003d 0;\n                for (int k \u003d 0; k \u003c cols; ++k) {\n                    double xK \u003d diag[k] * variables[k];\n                    xNorm +\u003d xK * xK;\n                }\n                xNorm \u003d Math.sqrt(xNorm);\n            } else {\n                cost \u003d previousCost;\n                for (int j \u003d 0; j \u003c solvedCols; ++j) {\n                    int pj \u003d permutation[j];\n                    variables[pj] \u003d oldX[pj];\n                }\n                tmpVec \u003d residuals;\n                residuals \u003d oldRes;\n                oldRes \u003d tmpVec;\n            }\n            if (((Math.abs(actRed) \u003c\u003d costRelativeTolerance) \u0026\u0026 (preRed \u003c\u003d costRelativeTolerance) \u0026\u0026 (ratio \u003c\u003d 2.0)) || (delta \u003c\u003d parRelativeTolerance * xNorm)) {\n                return new VectorialPointValuePair(variables, objective);\n            }\n            if ((Math.abs(actRed) \u003c\u003d 2.2204e-16) \u0026\u0026 (preRed \u003c\u003d 2.2204e-16) \u0026\u0026 (ratio \u003c\u003d 2.0)) {\n                throw new OptimizationException(\"cost relative tolerance is too small ({0}),\" + \" no further reduction in the\" + \" sum of squares is possible\", costRelativeTolerance);\n            } else if (delta \u003c\u003d 2.2204e-16 * xNorm) {\n                throw new OptimizationException(\"parameters relative tolerance is too small\" + \" ({0}), no further improvement in\" + \" the approximate solution is possible\", parRelativeTolerance);\n            } else if (maxCosine \u003c\u003d 2.2204e-16) {\n                throw new OptimizationException(\"orthogonality tolerance is too small ({0}),\" + \" solution is orthogonal to the jacobian\", orthoTolerance);\n            }\n        }\n    }\n}",
      "path": "src/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java",
      "functionStartLine": 212,
      "functionName": "doOptimize",
      "functionAnnotation": "",
      "functionDoc": "@inheritDoc}\n"
    }
  }
}