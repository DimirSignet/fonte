{
  "origin": "codeshovel",
  "repositoryName": "Time-11b",
  "repositoryPath": "/tmp/Time-11b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "DateTimeZoneBuilder.java",
  "functionName": "nextTransition",
  "functionId": "$nextTransition___instant-long(modifiers-final)__saveMillis-int(modifiers-final)",
  "sourceFilePath": "src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java",
  "functionAnnotation": "",
  "functionDoc": "Returns null if RuleSet is exhausted or upper limit reached. Calling\nthis method will throw away rules as they each become\nexhausted. Copy the RuleSet before using it to compute transitions.\n\nReturned transition may be a duplicate from previous\ntransition. Caller must call isTransitionFrom to filter out\nduplicates.\n\n@param saveMillis savings before next transition\n",
  "functionStartLine": 1081,
  "functionEndLine": 1125,
  "numCommitsSeen": 25,
  "timeTaken": 2656,
  "changeHistory": [
    "df4a82f4fb46cc2248280c462e18f08d55a3d112",
    "53feb3fa56af7260e607844524b7e5a9be49ecc1",
    "3f1e047c898c9c925e1faac33bb07e1cb05d88cb",
    "0e07ac6b2cff63550d7df336355ca63cc05aa40b",
    "7fe68f297f7c372b515fde7f0bc8d721ec257ceb"
  ],
  "changeHistoryShort": {
    "df4a82f4fb46cc2248280c462e18f08d55a3d112": "Yfilerename",
    "53feb3fa56af7260e607844524b7e5a9be49ecc1": "Yfilerename",
    "3f1e047c898c9c925e1faac33bb07e1cb05d88cb": "Ybodychange",
    "0e07ac6b2cff63550d7df336355ca63cc05aa40b": "Ymultichange(Yparameterchange,Ybodychange)",
    "7fe68f297f7c372b515fde7f0bc8d721ec257ceb": "Yintroduced"
  },
  "changeHistoryDetails": {
    "df4a82f4fb46cc2248280c462e18f08d55a3d112": {
      "type": "Yfilerename",
      "commitMessage": "Remove JodaTime folder moving files to top level\n",
      "commitDate": "5/16/11, 10:02 AM",
      "commitName": "df4a82f4fb46cc2248280c462e18f08d55a3d112",
      "commitAuthor": "Stephen Colebourne",
      "commitDateOld": "5/16/11, 9:58 AM",
      "commitNameOld": "72b22654962284bac59c2777131b42a2d1f53228",
      "commitAuthorOld": "Stephen Colebourne",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public Transition nextTransition(final long instant, final int saveMillis) {\n    Chronology chrono \u003d ISOChronology.getInstanceUTC();\n    Rule nextRule \u003d null;\n    long nextMillis \u003d Long.MAX_VALUE;\n    Iterator\u003cRule\u003e it \u003d iRules.iterator();\n    while (it.hasNext()) {\n        Rule rule \u003d it.next();\n        long next \u003d rule.next(instant, iStandardOffset, saveMillis);\n        if (next \u003c\u003d instant) {\n            it.remove();\n            continue;\n        }\n        if (next \u003c\u003d nextMillis) {\n            nextRule \u003d rule;\n            nextMillis \u003d next;\n        }\n    }\n    if (nextRule \u003d\u003d null) {\n        return null;\n    }\n    if (chrono.year().get(nextMillis) \u003e\u003d YEAR_LIMIT) {\n        return null;\n    }\n    if (iUpperYear \u003c Integer.MAX_VALUE) {\n        long upperMillis \u003d iUpperOfYear.setInstant(iUpperYear, iStandardOffset, saveMillis);\n        if (nextMillis \u003e\u003d upperMillis) {\n            return null;\n        }\n    }\n    return new Transition(nextMillis, nextRule, iStandardOffset);\n}",
      "path": "src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java",
      "functionStartLine": 1081,
      "functionName": "nextTransition",
      "functionAnnotation": "",
      "functionDoc": "Returns null if RuleSet is exhausted or upper limit reached. Calling\nthis method will throw away rules as they each become\nexhausted. Copy the RuleSet before using it to compute transitions.\n\nReturned transition may be a duplicate from previous\ntransition. Caller must call isTransitionFrom to filter out\nduplicates.\n\n@param saveMillis savings before next transition\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "JodaTime/src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java",
        "newPath": "src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java"
      }
    },
    "53feb3fa56af7260e607844524b7e5a9be49ecc1": {
      "type": "Yfilerename",
      "commitMessage": "Convert to maven 2\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@1540 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1\n",
      "commitDate": "8/8/10, 5:17 PM",
      "commitName": "53feb3fa56af7260e607844524b7e5a9be49ecc1",
      "commitAuthor": "Stephen Colebourne",
      "commitDateOld": "8/8/10, 5:02 PM",
      "commitNameOld": "7fa2ceaf5d95d050095432aa646ea803aa35e122",
      "commitAuthorOld": "Stephen Colebourne",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public Transition nextTransition(final long instant, final int saveMillis) {\n    Chronology chrono \u003d ISOChronology.getInstanceUTC();\n    Rule nextRule \u003d null;\n    long nextMillis \u003d Long.MAX_VALUE;\n    Iterator\u003cRule\u003e it \u003d iRules.iterator();\n    while (it.hasNext()) {\n        Rule rule \u003d it.next();\n        long next \u003d rule.next(instant, iStandardOffset, saveMillis);\n        if (next \u003c\u003d instant) {\n            it.remove();\n            continue;\n        }\n        if (next \u003c\u003d nextMillis) {\n            nextRule \u003d rule;\n            nextMillis \u003d next;\n        }\n    }\n    if (nextRule \u003d\u003d null) {\n        return null;\n    }\n    if (chrono.year().get(nextMillis) \u003e\u003d YEAR_LIMIT) {\n        return null;\n    }\n    if (iUpperYear \u003c Integer.MAX_VALUE) {\n        long upperMillis \u003d iUpperOfYear.setInstant(iUpperYear, iStandardOffset, saveMillis);\n        if (nextMillis \u003e\u003d upperMillis) {\n            return null;\n        }\n    }\n    return new Transition(nextMillis, nextRule, iStandardOffset);\n}",
      "path": "JodaTime/src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java",
      "functionStartLine": 1081,
      "functionName": "nextTransition",
      "functionAnnotation": "",
      "functionDoc": "Returns null if RuleSet is exhausted or upper limit reached. Calling\nthis method will throw away rules as they each become\nexhausted. Copy the RuleSet before using it to compute transitions.\n\nReturned transition may be a duplicate from previous\ntransition. Caller must call isTransitionFrom to filter out\nduplicates.\n\n@param saveMillis savings before next transition\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "JodaTime/src/java/org/joda/time/tz/DateTimeZoneBuilder.java",
        "newPath": "JodaTime/src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java"
      }
    },
    "3f1e047c898c9c925e1faac33bb07e1cb05d88cb": {
      "type": "Ybodychange",
      "commitMessage": "Move to Java 5 with generics\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@1406 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1\n",
      "commitDate": "11/4/09, 3:55 PM",
      "commitName": "3f1e047c898c9c925e1faac33bb07e1cb05d88cb",
      "commitAuthor": "Stephen Colebourne",
      "commitDateOld": "8/13/09, 4:26 PM",
      "commitNameOld": "6cd3a18f8cb3c907107017849ab1ac3b88e43fb5",
      "commitAuthorOld": "Stephen Colebourne",
      "daysBetweenCommits": 83.02,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "actualSource": "public Transition nextTransition(final long instant, final int saveMillis) {\n    Chronology chrono \u003d ISOChronology.getInstanceUTC();\n    Rule nextRule \u003d null;\n    long nextMillis \u003d Long.MAX_VALUE;\n    Iterator\u003cRule\u003e it \u003d iRules.iterator();\n    while (it.hasNext()) {\n        Rule rule \u003d it.next();\n        long next \u003d rule.next(instant, iStandardOffset, saveMillis);\n        if (next \u003c\u003d instant) {\n            it.remove();\n            continue;\n        }\n        if (next \u003c\u003d nextMillis) {\n            nextRule \u003d rule;\n            nextMillis \u003d next;\n        }\n    }\n    if (nextRule \u003d\u003d null) {\n        return null;\n    }\n    if (chrono.year().get(nextMillis) \u003e\u003d YEAR_LIMIT) {\n        return null;\n    }\n    if (iUpperYear \u003c Integer.MAX_VALUE) {\n        long upperMillis \u003d iUpperOfYear.setInstant(iUpperYear, iStandardOffset, saveMillis);\n        if (nextMillis \u003e\u003d upperMillis) {\n            return null;\n        }\n    }\n    return new Transition(nextMillis, nextRule, iStandardOffset);\n}",
      "path": "JodaTime/src/java/org/joda/time/tz/DateTimeZoneBuilder.java",
      "functionStartLine": 1083,
      "functionName": "nextTransition",
      "functionAnnotation": "",
      "functionDoc": "Returns null if RuleSet is exhausted or upper limit reached. Calling\nthis method will throw away rules as they each become\nexhausted. Copy the RuleSet before using it to compute transitions.\n\nReturned transition may be a duplicate from previous\ntransition. Caller must call isTransitionFrom to filter out\nduplicates.\n\n@param saveMillis savings before next transition\n",
      "diff": "@@ -1,31 +1,31 @@\n public Transition nextTransition(final long instant, final int saveMillis) {\n     Chronology chrono \u003d ISOChronology.getInstanceUTC();\n     Rule nextRule \u003d null;\n     long nextMillis \u003d Long.MAX_VALUE;\n-    Iterator it \u003d iRules.iterator();\n+    Iterator\u003cRule\u003e it \u003d iRules.iterator();\n     while (it.hasNext()) {\n-        Rule rule \u003d (Rule) it.next();\n+        Rule rule \u003d it.next();\n         long next \u003d rule.next(instant, iStandardOffset, saveMillis);\n         if (next \u003c\u003d instant) {\n             it.remove();\n             continue;\n         }\n         if (next \u003c\u003d nextMillis) {\n             nextRule \u003d rule;\n             nextMillis \u003d next;\n         }\n     }\n     if (nextRule \u003d\u003d null) {\n         return null;\n     }\n     if (chrono.year().get(nextMillis) \u003e\u003d YEAR_LIMIT) {\n         return null;\n     }\n     if (iUpperYear \u003c Integer.MAX_VALUE) {\n         long upperMillis \u003d iUpperOfYear.setInstant(iUpperYear, iStandardOffset, saveMillis);\n         if (nextMillis \u003e\u003d upperMillis) {\n             return null;\n         }\n     }\n     return new Transition(nextMillis, nextRule, iStandardOffset);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0e07ac6b2cff63550d7df336355ca63cc05aa40b": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Move from Joda CVS\n\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@10 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1\n",
      "commitDate": "12/18/03, 6:07 PM",
      "commitName": "0e07ac6b2cff63550d7df336355ca63cc05aa40b",
      "commitAuthor": "Stephen Colebourne",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Move from Joda CVS\n\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@10 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1\n",
          "commitDate": "12/18/03, 6:07 PM",
          "commitName": "0e07ac6b2cff63550d7df336355ca63cc05aa40b",
          "commitAuthor": "Stephen Colebourne",
          "commitDateOld": "12/16/03, 1:39 PM",
          "commitNameOld": "7fe68f297f7c372b515fde7f0bc8d721ec257ceb",
          "commitAuthorOld": "Stephen Colebourne",
          "daysBetweenCommits": 2.19,
          "commitsBetweenForRepo": 6,
          "commitsBetweenForFile": 1,
          "actualSource": "public Transition nextTransition(final long instant, final int saveMillis) {\n    Chronology chrono \u003d ISOChronology.getInstanceUTC();\n    Rule nextRule \u003d null;\n    long nextMillis \u003d Long.MAX_VALUE;\n    Iterator it \u003d iRules.iterator();\n    while (it.hasNext()) {\n        Rule rule \u003d (Rule) it.next();\n        long next \u003d rule.next(instant, iStandardOffset, saveMillis);\n        if (next \u003c\u003d instant) {\n            it.remove();\n            continue;\n        }\n        if (next \u003c\u003d nextMillis) {\n            nextRule \u003d rule;\n            nextMillis \u003d next;\n        }\n    }\n    if (nextRule \u003d\u003d null) {\n        return null;\n    }\n    if (chrono.year().get(nextMillis) \u003e\u003d YEAR_LIMIT) {\n        return null;\n    }\n    if (iUpperYear \u003c Integer.MAX_VALUE) {\n        long upperMillis \u003d iUpperOfYear.setInstant(iUpperYear, iStandardOffset, saveMillis);\n        if (nextMillis \u003e\u003d upperMillis) {\n            return null;\n        }\n    }\n    return new Transition(nextMillis, nextRule, iStandardOffset);\n}",
          "path": "JodaTime/src/java/org/joda/time/tz/DateTimeZoneBuilder.java",
          "functionStartLine": 1072,
          "functionName": "nextTransition",
          "functionAnnotation": "",
          "functionDoc": "Returns null if RuleSet is exhausted or upper limit reached. Calling\nthis method will throw away rules as they each become\nexhausted. Copy the RuleSet before using it to compute transitions.\n\nReturned transition may be a duplicate from previous\ntransition. Caller must call isTransitionFrom to filter out\nduplicates.\n\n@param saveMillis savings before next transition\n",
          "diff": "@@ -1,31 +1,31 @@\n-public Transition nextTransition(final long millis, final int saveMillis) {\n+public Transition nextTransition(final long instant, final int saveMillis) {\n     Chronology chrono \u003d ISOChronology.getInstanceUTC();\n     Rule nextRule \u003d null;\n     long nextMillis \u003d Long.MAX_VALUE;\n     Iterator it \u003d iRules.iterator();\n     while (it.hasNext()) {\n         Rule rule \u003d (Rule) it.next();\n-        long next \u003d rule.next(millis, iStandardOffset, saveMillis);\n-        if (next \u003c\u003d millis) {\n+        long next \u003d rule.next(instant, iStandardOffset, saveMillis);\n+        if (next \u003c\u003d instant) {\n             it.remove();\n             continue;\n         }\n         if (next \u003c\u003d nextMillis) {\n             nextRule \u003d rule;\n             nextMillis \u003d next;\n         }\n     }\n     if (nextRule \u003d\u003d null) {\n         return null;\n     }\n     if (chrono.year().get(nextMillis) \u003e\u003d YEAR_LIMIT) {\n         return null;\n     }\n     if (iUpperYear \u003c Integer.MAX_VALUE) {\n         long upperMillis \u003d iUpperOfYear.setInstant(iUpperYear, iStandardOffset, saveMillis);\n         if (nextMillis \u003e\u003d upperMillis) {\n             return null;\n         }\n     }\n     return new Transition(nextMillis, nextRule, iStandardOffset);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[millis-long(modifiers-final), saveMillis-int(modifiers-final)]",
            "newValue": "[instant-long(modifiers-final), saveMillis-int(modifiers-final)]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Move from Joda CVS\n\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@10 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1\n",
          "commitDate": "12/18/03, 6:07 PM",
          "commitName": "0e07ac6b2cff63550d7df336355ca63cc05aa40b",
          "commitAuthor": "Stephen Colebourne",
          "commitDateOld": "12/16/03, 1:39 PM",
          "commitNameOld": "7fe68f297f7c372b515fde7f0bc8d721ec257ceb",
          "commitAuthorOld": "Stephen Colebourne",
          "daysBetweenCommits": 2.19,
          "commitsBetweenForRepo": 6,
          "commitsBetweenForFile": 1,
          "actualSource": "public Transition nextTransition(final long instant, final int saveMillis) {\n    Chronology chrono \u003d ISOChronology.getInstanceUTC();\n    Rule nextRule \u003d null;\n    long nextMillis \u003d Long.MAX_VALUE;\n    Iterator it \u003d iRules.iterator();\n    while (it.hasNext()) {\n        Rule rule \u003d (Rule) it.next();\n        long next \u003d rule.next(instant, iStandardOffset, saveMillis);\n        if (next \u003c\u003d instant) {\n            it.remove();\n            continue;\n        }\n        if (next \u003c\u003d nextMillis) {\n            nextRule \u003d rule;\n            nextMillis \u003d next;\n        }\n    }\n    if (nextRule \u003d\u003d null) {\n        return null;\n    }\n    if (chrono.year().get(nextMillis) \u003e\u003d YEAR_LIMIT) {\n        return null;\n    }\n    if (iUpperYear \u003c Integer.MAX_VALUE) {\n        long upperMillis \u003d iUpperOfYear.setInstant(iUpperYear, iStandardOffset, saveMillis);\n        if (nextMillis \u003e\u003d upperMillis) {\n            return null;\n        }\n    }\n    return new Transition(nextMillis, nextRule, iStandardOffset);\n}",
          "path": "JodaTime/src/java/org/joda/time/tz/DateTimeZoneBuilder.java",
          "functionStartLine": 1072,
          "functionName": "nextTransition",
          "functionAnnotation": "",
          "functionDoc": "Returns null if RuleSet is exhausted or upper limit reached. Calling\nthis method will throw away rules as they each become\nexhausted. Copy the RuleSet before using it to compute transitions.\n\nReturned transition may be a duplicate from previous\ntransition. Caller must call isTransitionFrom to filter out\nduplicates.\n\n@param saveMillis savings before next transition\n",
          "diff": "@@ -1,31 +1,31 @@\n-public Transition nextTransition(final long millis, final int saveMillis) {\n+public Transition nextTransition(final long instant, final int saveMillis) {\n     Chronology chrono \u003d ISOChronology.getInstanceUTC();\n     Rule nextRule \u003d null;\n     long nextMillis \u003d Long.MAX_VALUE;\n     Iterator it \u003d iRules.iterator();\n     while (it.hasNext()) {\n         Rule rule \u003d (Rule) it.next();\n-        long next \u003d rule.next(millis, iStandardOffset, saveMillis);\n-        if (next \u003c\u003d millis) {\n+        long next \u003d rule.next(instant, iStandardOffset, saveMillis);\n+        if (next \u003c\u003d instant) {\n             it.remove();\n             continue;\n         }\n         if (next \u003c\u003d nextMillis) {\n             nextRule \u003d rule;\n             nextMillis \u003d next;\n         }\n     }\n     if (nextRule \u003d\u003d null) {\n         return null;\n     }\n     if (chrono.year().get(nextMillis) \u003e\u003d YEAR_LIMIT) {\n         return null;\n     }\n     if (iUpperYear \u003c Integer.MAX_VALUE) {\n         long upperMillis \u003d iUpperOfYear.setInstant(iUpperYear, iStandardOffset, saveMillis);\n         if (nextMillis \u003e\u003d upperMillis) {\n             return null;\n         }\n     }\n     return new Transition(nextMillis, nextRule, iStandardOffset);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "7fe68f297f7c372b515fde7f0bc8d721ec257ceb": {
      "type": "Yintroduced",
      "commitMessage": "Move version 0.9 to joda-time repository\n\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@4 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1\n",
      "commitDate": "12/16/03, 1:39 PM",
      "commitName": "7fe68f297f7c372b515fde7f0bc8d721ec257ceb",
      "commitAuthor": "Stephen Colebourne",
      "diff": "@@ -0,0 +1,31 @@\n+public Transition nextTransition(final long millis, final int saveMillis) {\n+    Chronology chrono \u003d ISOChronology.getInstanceUTC();\n+    Rule nextRule \u003d null;\n+    long nextMillis \u003d Long.MAX_VALUE;\n+    Iterator it \u003d iRules.iterator();\n+    while (it.hasNext()) {\n+        Rule rule \u003d (Rule) it.next();\n+        long next \u003d rule.next(millis, iStandardOffset, saveMillis);\n+        if (next \u003c\u003d millis) {\n+            it.remove();\n+            continue;\n+        }\n+        if (next \u003c\u003d nextMillis) {\n+            nextRule \u003d rule;\n+            nextMillis \u003d next;\n+        }\n+    }\n+    if (nextRule \u003d\u003d null) {\n+        return null;\n+    }\n+    if (chrono.year().get(nextMillis) \u003e\u003d YEAR_LIMIT) {\n+        return null;\n+    }\n+    if (iUpperYear \u003c Integer.MAX_VALUE) {\n+        long upperMillis \u003d iUpperOfYear.setInstant(iUpperYear, iStandardOffset, saveMillis);\n+        if (nextMillis \u003e\u003d upperMillis) {\n+            return null;\n+        }\n+    }\n+    return new Transition(nextMillis, nextRule, iStandardOffset);\n+}\n\\ No newline at end of file\n",
      "actualSource": "public Transition nextTransition(final long millis, final int saveMillis) {\n    Chronology chrono \u003d ISOChronology.getInstanceUTC();\n    Rule nextRule \u003d null;\n    long nextMillis \u003d Long.MAX_VALUE;\n    Iterator it \u003d iRules.iterator();\n    while (it.hasNext()) {\n        Rule rule \u003d (Rule) it.next();\n        long next \u003d rule.next(millis, iStandardOffset, saveMillis);\n        if (next \u003c\u003d millis) {\n            it.remove();\n            continue;\n        }\n        if (next \u003c\u003d nextMillis) {\n            nextRule \u003d rule;\n            nextMillis \u003d next;\n        }\n    }\n    if (nextRule \u003d\u003d null) {\n        return null;\n    }\n    if (chrono.year().get(nextMillis) \u003e\u003d YEAR_LIMIT) {\n        return null;\n    }\n    if (iUpperYear \u003c Integer.MAX_VALUE) {\n        long upperMillis \u003d iUpperOfYear.setInstant(iUpperYear, iStandardOffset, saveMillis);\n        if (nextMillis \u003e\u003d upperMillis) {\n            return null;\n        }\n    }\n    return new Transition(nextMillis, nextRule, iStandardOffset);\n}",
      "path": "JodaTime/src/java/org/joda/time/tz/DateTimeZoneBuilder.java",
      "functionStartLine": 1065,
      "functionName": "nextTransition",
      "functionAnnotation": "",
      "functionDoc": "Returns null if RuleSet is exhausted or upper limit reached. Calling\nthis method will throw away rules as they each become\nexhausted. Copy the RuleSet before using it to compute transitions.\n\nReturned transition may be a duplicate from previous\ntransition. Caller must call isTransitionFrom to filter out\nduplicates.\n\n@param saveMillis savings before next transition\n"
    }
  }
}