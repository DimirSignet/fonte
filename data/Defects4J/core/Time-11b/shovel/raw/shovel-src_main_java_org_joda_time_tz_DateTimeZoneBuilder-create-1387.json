{
  "origin": "codeshovel",
  "repositoryName": "Time-11b",
  "repositoryPath": "/tmp/Time-11b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "DateTimeZoneBuilder.java",
  "functionName": "create",
  "functionId": "$create___id-String__outputID-boolean__transitions-ArrayList__Transition____tailZone-DSTZone",
  "sourceFilePath": "src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java",
  "functionAnnotation": "",
  "functionDoc": "Factory to create instance from builder.\n\n@param id the zone id\n@param outputID true if the zone id should be output\n@param transitions the list of Transition objects\n@param tailZone optional zone for getting info beyond precalculated tables\n",
  "functionStartLine": 1387,
  "functionEndLine": 1482,
  "numCommitsSeen": 42,
  "timeTaken": 2577,
  "changeHistory": [
    "df4a82f4fb46cc2248280c462e18f08d55a3d112",
    "01ed04f3a83f17e9947c83d04cb258430429789d",
    "53feb3fa56af7260e607844524b7e5a9be49ecc1",
    "3f1e047c898c9c925e1faac33bb07e1cb05d88cb",
    "aa8986650e3820e03af178de7f69def85d780b64",
    "bb9aea5d7374bd98a8548008c40a29df3681c10b",
    "9b01b9e8b42e8f33f02caf91110fe6459e830fcb"
  ],
  "changeHistoryShort": {
    "df4a82f4fb46cc2248280c462e18f08d55a3d112": "Yfilerename",
    "01ed04f3a83f17e9947c83d04cb258430429789d": "Ybodychange",
    "53feb3fa56af7260e607844524b7e5a9be49ecc1": "Yfilerename",
    "3f1e047c898c9c925e1faac33bb07e1cb05d88cb": "Ymultichange(Yparameterchange,Ybodychange)",
    "aa8986650e3820e03af178de7f69def85d780b64": "Ybodychange",
    "bb9aea5d7374bd98a8548008c40a29df3681c10b": "Ybodychange",
    "9b01b9e8b42e8f33f02caf91110fe6459e830fcb": "Yintroduced"
  },
  "changeHistoryDetails": {
    "df4a82f4fb46cc2248280c462e18f08d55a3d112": {
      "type": "Yfilerename",
      "commitMessage": "Remove JodaTime folder moving files to top level\n",
      "commitDate": "5/16/11, 10:02 AM",
      "commitName": "df4a82f4fb46cc2248280c462e18f08d55a3d112",
      "commitAuthor": "Stephen Colebourne",
      "commitDateOld": "5/16/11, 9:58 AM",
      "commitNameOld": "72b22654962284bac59c2777131b42a2d1f53228",
      "commitAuthorOld": "Stephen Colebourne",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "static PrecalculatedZone create(String id, boolean outputID, ArrayList\u003cTransition\u003e transitions, DSTZone tailZone) {\n    int size \u003d transitions.size();\n    if (size \u003d\u003d 0) {\n        throw new IllegalArgumentException();\n    }\n    long[] trans \u003d new long[size];\n    int[] wallOffsets \u003d new int[size];\n    int[] standardOffsets \u003d new int[size];\n    String[] nameKeys \u003d new String[size];\n    Transition last \u003d null;\n    for (int i \u003d 0; i \u003c size; i++) {\n        Transition tr \u003d transitions.get(i);\n        if (!tr.isTransitionFrom(last)) {\n            throw new IllegalArgumentException(id);\n        }\n        trans[i] \u003d tr.getMillis();\n        wallOffsets[i] \u003d tr.getWallOffset();\n        standardOffsets[i] \u003d tr.getStandardOffset();\n        nameKeys[i] \u003d tr.getNameKey();\n        last \u003d tr;\n    }\n    String[] zoneNameData \u003d new String[5];\n    String[][] zoneStrings \u003d new DateFormatSymbols(Locale.ENGLISH).getZoneStrings();\n    for (int j \u003d 0; j \u003c zoneStrings.length; j++) {\n        String[] set \u003d zoneStrings[j];\n        if (set !\u003d null \u0026\u0026 set.length \u003d\u003d 5 \u0026\u0026 id.equals(set[0])) {\n            zoneNameData \u003d set;\n        }\n    }\n    Chronology chrono \u003d ISOChronology.getInstanceUTC();\n    for (int i \u003d 0; i \u003c nameKeys.length - 1; i++) {\n        String curNameKey \u003d nameKeys[i];\n        String nextNameKey \u003d nameKeys[i + 1];\n        long curOffset \u003d wallOffsets[i];\n        long nextOffset \u003d wallOffsets[i + 1];\n        long curStdOffset \u003d standardOffsets[i];\n        long nextStdOffset \u003d standardOffsets[i + 1];\n        Period p \u003d new Period(trans[i], trans[i + 1], PeriodType.yearMonthDay(), chrono);\n        if (curOffset !\u003d nextOffset \u0026\u0026 curStdOffset \u003d\u003d nextStdOffset \u0026\u0026 curNameKey.equals(nextNameKey) \u0026\u0026 p.getYears() \u003d\u003d 0 \u0026\u0026 p.getMonths() \u003e 4 \u0026\u0026 p.getMonths() \u003c 8 \u0026\u0026 curNameKey.equals(zoneNameData[2]) \u0026\u0026 curNameKey.equals(zoneNameData[4])) {\n            if (ZoneInfoCompiler.verbose()) {\n                System.out.println(\"Fixing duplicate name key - \" + nextNameKey);\n                System.out.println(\"     - \" + new DateTime(trans[i], chrono) + \" - \" + new DateTime(trans[i + 1], chrono));\n            }\n            if (curOffset \u003e nextOffset) {\n                nameKeys[i] \u003d (curNameKey + \"-Summer\").intern();\n            } else if (curOffset \u003c nextOffset) {\n                nameKeys[i + 1] \u003d (nextNameKey + \"-Summer\").intern();\n                i++;\n            }\n        }\n    }\n    if (tailZone !\u003d null) {\n        if (tailZone.iStartRecurrence.getNameKey().equals(tailZone.iEndRecurrence.getNameKey())) {\n            if (ZoneInfoCompiler.verbose()) {\n                System.out.println(\"Fixing duplicate recurrent name key - \" + tailZone.iStartRecurrence.getNameKey());\n            }\n            if (tailZone.iStartRecurrence.getSaveMillis() \u003e 0) {\n                tailZone \u003d new DSTZone(tailZone.getID(), tailZone.iStandardOffset, tailZone.iStartRecurrence.renameAppend(\"-Summer\"), tailZone.iEndRecurrence);\n            } else {\n                tailZone \u003d new DSTZone(tailZone.getID(), tailZone.iStandardOffset, tailZone.iStartRecurrence, tailZone.iEndRecurrence.renameAppend(\"-Summer\"));\n            }\n        }\n    }\n    return new PrecalculatedZone((outputID ? id : \"\"), trans, wallOffsets, standardOffsets, nameKeys, tailZone);\n}",
      "path": "src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java",
      "functionStartLine": 1387,
      "functionName": "create",
      "functionAnnotation": "",
      "functionDoc": "Factory to create instance from builder.\n\n@param id the zone id\n@param outputID true if the zone id should be output\n@param transitions the list of Transition objects\n@param tailZone optional zone for getting info beyond precalculated tables\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "JodaTime/src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java",
        "newPath": "src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java"
      }
    },
    "01ed04f3a83f17e9947c83d04cb258430429789d": {
      "type": "Ybodychange",
      "commitMessage": "Reduce logging from ZoneInfoCompiler by adding a verbose flag\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@1561 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1\n",
      "commitDate": "8/18/10, 4:43 PM",
      "commitName": "01ed04f3a83f17e9947c83d04cb258430429789d",
      "commitAuthor": "Stephen Colebourne",
      "commitDateOld": "8/8/10, 5:17 PM",
      "commitNameOld": "53feb3fa56af7260e607844524b7e5a9be49ecc1",
      "commitAuthorOld": "Stephen Colebourne",
      "daysBetweenCommits": 9.98,
      "commitsBetweenForRepo": 21,
      "commitsBetweenForFile": 1,
      "actualSource": "static PrecalculatedZone create(String id, boolean outputID, ArrayList\u003cTransition\u003e transitions, DSTZone tailZone) {\n    int size \u003d transitions.size();\n    if (size \u003d\u003d 0) {\n        throw new IllegalArgumentException();\n    }\n    long[] trans \u003d new long[size];\n    int[] wallOffsets \u003d new int[size];\n    int[] standardOffsets \u003d new int[size];\n    String[] nameKeys \u003d new String[size];\n    Transition last \u003d null;\n    for (int i \u003d 0; i \u003c size; i++) {\n        Transition tr \u003d transitions.get(i);\n        if (!tr.isTransitionFrom(last)) {\n            throw new IllegalArgumentException(id);\n        }\n        trans[i] \u003d tr.getMillis();\n        wallOffsets[i] \u003d tr.getWallOffset();\n        standardOffsets[i] \u003d tr.getStandardOffset();\n        nameKeys[i] \u003d tr.getNameKey();\n        last \u003d tr;\n    }\n    String[] zoneNameData \u003d new String[5];\n    String[][] zoneStrings \u003d new DateFormatSymbols(Locale.ENGLISH).getZoneStrings();\n    for (int j \u003d 0; j \u003c zoneStrings.length; j++) {\n        String[] set \u003d zoneStrings[j];\n        if (set !\u003d null \u0026\u0026 set.length \u003d\u003d 5 \u0026\u0026 id.equals(set[0])) {\n            zoneNameData \u003d set;\n        }\n    }\n    Chronology chrono \u003d ISOChronology.getInstanceUTC();\n    for (int i \u003d 0; i \u003c nameKeys.length - 1; i++) {\n        String curNameKey \u003d nameKeys[i];\n        String nextNameKey \u003d nameKeys[i + 1];\n        long curOffset \u003d wallOffsets[i];\n        long nextOffset \u003d wallOffsets[i + 1];\n        long curStdOffset \u003d standardOffsets[i];\n        long nextStdOffset \u003d standardOffsets[i + 1];\n        Period p \u003d new Period(trans[i], trans[i + 1], PeriodType.yearMonthDay(), chrono);\n        if (curOffset !\u003d nextOffset \u0026\u0026 curStdOffset \u003d\u003d nextStdOffset \u0026\u0026 curNameKey.equals(nextNameKey) \u0026\u0026 p.getYears() \u003d\u003d 0 \u0026\u0026 p.getMonths() \u003e 4 \u0026\u0026 p.getMonths() \u003c 8 \u0026\u0026 curNameKey.equals(zoneNameData[2]) \u0026\u0026 curNameKey.equals(zoneNameData[4])) {\n            if (ZoneInfoCompiler.verbose()) {\n                System.out.println(\"Fixing duplicate name key - \" + nextNameKey);\n                System.out.println(\"     - \" + new DateTime(trans[i], chrono) + \" - \" + new DateTime(trans[i + 1], chrono));\n            }\n            if (curOffset \u003e nextOffset) {\n                nameKeys[i] \u003d (curNameKey + \"-Summer\").intern();\n            } else if (curOffset \u003c nextOffset) {\n                nameKeys[i + 1] \u003d (nextNameKey + \"-Summer\").intern();\n                i++;\n            }\n        }\n    }\n    if (tailZone !\u003d null) {\n        if (tailZone.iStartRecurrence.getNameKey().equals(tailZone.iEndRecurrence.getNameKey())) {\n            if (ZoneInfoCompiler.verbose()) {\n                System.out.println(\"Fixing duplicate recurrent name key - \" + tailZone.iStartRecurrence.getNameKey());\n            }\n            if (tailZone.iStartRecurrence.getSaveMillis() \u003e 0) {\n                tailZone \u003d new DSTZone(tailZone.getID(), tailZone.iStandardOffset, tailZone.iStartRecurrence.renameAppend(\"-Summer\"), tailZone.iEndRecurrence);\n            } else {\n                tailZone \u003d new DSTZone(tailZone.getID(), tailZone.iStandardOffset, tailZone.iStartRecurrence, tailZone.iEndRecurrence.renameAppend(\"-Summer\"));\n            }\n        }\n    }\n    return new PrecalculatedZone((outputID ? id : \"\"), trans, wallOffsets, standardOffsets, nameKeys, tailZone);\n}",
      "path": "JodaTime/src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java",
      "functionStartLine": 1387,
      "functionName": "create",
      "functionAnnotation": "",
      "functionDoc": "Factory to create instance from builder.\n\n@param id the zone id\n@param outputID true if the zone id should be output\n@param transitions the list of Transition objects\n@param tailZone optional zone for getting info beyond precalculated tables\n",
      "diff": "@@ -1,61 +1,65 @@\n static PrecalculatedZone create(String id, boolean outputID, ArrayList\u003cTransition\u003e transitions, DSTZone tailZone) {\n     int size \u003d transitions.size();\n     if (size \u003d\u003d 0) {\n         throw new IllegalArgumentException();\n     }\n     long[] trans \u003d new long[size];\n     int[] wallOffsets \u003d new int[size];\n     int[] standardOffsets \u003d new int[size];\n     String[] nameKeys \u003d new String[size];\n     Transition last \u003d null;\n     for (int i \u003d 0; i \u003c size; i++) {\n         Transition tr \u003d transitions.get(i);\n         if (!tr.isTransitionFrom(last)) {\n             throw new IllegalArgumentException(id);\n         }\n         trans[i] \u003d tr.getMillis();\n         wallOffsets[i] \u003d tr.getWallOffset();\n         standardOffsets[i] \u003d tr.getStandardOffset();\n         nameKeys[i] \u003d tr.getNameKey();\n         last \u003d tr;\n     }\n     String[] zoneNameData \u003d new String[5];\n     String[][] zoneStrings \u003d new DateFormatSymbols(Locale.ENGLISH).getZoneStrings();\n     for (int j \u003d 0; j \u003c zoneStrings.length; j++) {\n         String[] set \u003d zoneStrings[j];\n         if (set !\u003d null \u0026\u0026 set.length \u003d\u003d 5 \u0026\u0026 id.equals(set[0])) {\n             zoneNameData \u003d set;\n         }\n     }\n     Chronology chrono \u003d ISOChronology.getInstanceUTC();\n     for (int i \u003d 0; i \u003c nameKeys.length - 1; i++) {\n         String curNameKey \u003d nameKeys[i];\n         String nextNameKey \u003d nameKeys[i + 1];\n         long curOffset \u003d wallOffsets[i];\n         long nextOffset \u003d wallOffsets[i + 1];\n         long curStdOffset \u003d standardOffsets[i];\n         long nextStdOffset \u003d standardOffsets[i + 1];\n         Period p \u003d new Period(trans[i], trans[i + 1], PeriodType.yearMonthDay(), chrono);\n         if (curOffset !\u003d nextOffset \u0026\u0026 curStdOffset \u003d\u003d nextStdOffset \u0026\u0026 curNameKey.equals(nextNameKey) \u0026\u0026 p.getYears() \u003d\u003d 0 \u0026\u0026 p.getMonths() \u003e 4 \u0026\u0026 p.getMonths() \u003c 8 \u0026\u0026 curNameKey.equals(zoneNameData[2]) \u0026\u0026 curNameKey.equals(zoneNameData[4])) {\n-            System.out.println(\"Fixing duplicate name key - \" + nextNameKey);\n-            System.out.println(\"     - \" + new DateTime(trans[i], chrono) + \" - \" + new DateTime(trans[i + 1], chrono));\n+            if (ZoneInfoCompiler.verbose()) {\n+                System.out.println(\"Fixing duplicate name key - \" + nextNameKey);\n+                System.out.println(\"     - \" + new DateTime(trans[i], chrono) + \" - \" + new DateTime(trans[i + 1], chrono));\n+            }\n             if (curOffset \u003e nextOffset) {\n                 nameKeys[i] \u003d (curNameKey + \"-Summer\").intern();\n             } else if (curOffset \u003c nextOffset) {\n                 nameKeys[i + 1] \u003d (nextNameKey + \"-Summer\").intern();\n                 i++;\n             }\n         }\n     }\n     if (tailZone !\u003d null) {\n         if (tailZone.iStartRecurrence.getNameKey().equals(tailZone.iEndRecurrence.getNameKey())) {\n-            System.out.println(\"Fixing duplicate recurrent name key - \" + tailZone.iStartRecurrence.getNameKey());\n+            if (ZoneInfoCompiler.verbose()) {\n+                System.out.println(\"Fixing duplicate recurrent name key - \" + tailZone.iStartRecurrence.getNameKey());\n+            }\n             if (tailZone.iStartRecurrence.getSaveMillis() \u003e 0) {\n                 tailZone \u003d new DSTZone(tailZone.getID(), tailZone.iStandardOffset, tailZone.iStartRecurrence.renameAppend(\"-Summer\"), tailZone.iEndRecurrence);\n             } else {\n                 tailZone \u003d new DSTZone(tailZone.getID(), tailZone.iStandardOffset, tailZone.iStartRecurrence, tailZone.iEndRecurrence.renameAppend(\"-Summer\"));\n             }\n         }\n     }\n     return new PrecalculatedZone((outputID ? id : \"\"), trans, wallOffsets, standardOffsets, nameKeys, tailZone);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "53feb3fa56af7260e607844524b7e5a9be49ecc1": {
      "type": "Yfilerename",
      "commitMessage": "Convert to maven 2\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@1540 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1\n",
      "commitDate": "8/8/10, 5:17 PM",
      "commitName": "53feb3fa56af7260e607844524b7e5a9be49ecc1",
      "commitAuthor": "Stephen Colebourne",
      "commitDateOld": "8/8/10, 5:02 PM",
      "commitNameOld": "7fa2ceaf5d95d050095432aa646ea803aa35e122",
      "commitAuthorOld": "Stephen Colebourne",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "static PrecalculatedZone create(String id, boolean outputID, ArrayList\u003cTransition\u003e transitions, DSTZone tailZone) {\n    int size \u003d transitions.size();\n    if (size \u003d\u003d 0) {\n        throw new IllegalArgumentException();\n    }\n    long[] trans \u003d new long[size];\n    int[] wallOffsets \u003d new int[size];\n    int[] standardOffsets \u003d new int[size];\n    String[] nameKeys \u003d new String[size];\n    Transition last \u003d null;\n    for (int i \u003d 0; i \u003c size; i++) {\n        Transition tr \u003d transitions.get(i);\n        if (!tr.isTransitionFrom(last)) {\n            throw new IllegalArgumentException(id);\n        }\n        trans[i] \u003d tr.getMillis();\n        wallOffsets[i] \u003d tr.getWallOffset();\n        standardOffsets[i] \u003d tr.getStandardOffset();\n        nameKeys[i] \u003d tr.getNameKey();\n        last \u003d tr;\n    }\n    String[] zoneNameData \u003d new String[5];\n    String[][] zoneStrings \u003d new DateFormatSymbols(Locale.ENGLISH).getZoneStrings();\n    for (int j \u003d 0; j \u003c zoneStrings.length; j++) {\n        String[] set \u003d zoneStrings[j];\n        if (set !\u003d null \u0026\u0026 set.length \u003d\u003d 5 \u0026\u0026 id.equals(set[0])) {\n            zoneNameData \u003d set;\n        }\n    }\n    Chronology chrono \u003d ISOChronology.getInstanceUTC();\n    for (int i \u003d 0; i \u003c nameKeys.length - 1; i++) {\n        String curNameKey \u003d nameKeys[i];\n        String nextNameKey \u003d nameKeys[i + 1];\n        long curOffset \u003d wallOffsets[i];\n        long nextOffset \u003d wallOffsets[i + 1];\n        long curStdOffset \u003d standardOffsets[i];\n        long nextStdOffset \u003d standardOffsets[i + 1];\n        Period p \u003d new Period(trans[i], trans[i + 1], PeriodType.yearMonthDay(), chrono);\n        if (curOffset !\u003d nextOffset \u0026\u0026 curStdOffset \u003d\u003d nextStdOffset \u0026\u0026 curNameKey.equals(nextNameKey) \u0026\u0026 p.getYears() \u003d\u003d 0 \u0026\u0026 p.getMonths() \u003e 4 \u0026\u0026 p.getMonths() \u003c 8 \u0026\u0026 curNameKey.equals(zoneNameData[2]) \u0026\u0026 curNameKey.equals(zoneNameData[4])) {\n            System.out.println(\"Fixing duplicate name key - \" + nextNameKey);\n            System.out.println(\"     - \" + new DateTime(trans[i], chrono) + \" - \" + new DateTime(trans[i + 1], chrono));\n            if (curOffset \u003e nextOffset) {\n                nameKeys[i] \u003d (curNameKey + \"-Summer\").intern();\n            } else if (curOffset \u003c nextOffset) {\n                nameKeys[i + 1] \u003d (nextNameKey + \"-Summer\").intern();\n                i++;\n            }\n        }\n    }\n    if (tailZone !\u003d null) {\n        if (tailZone.iStartRecurrence.getNameKey().equals(tailZone.iEndRecurrence.getNameKey())) {\n            System.out.println(\"Fixing duplicate recurrent name key - \" + tailZone.iStartRecurrence.getNameKey());\n            if (tailZone.iStartRecurrence.getSaveMillis() \u003e 0) {\n                tailZone \u003d new DSTZone(tailZone.getID(), tailZone.iStandardOffset, tailZone.iStartRecurrence.renameAppend(\"-Summer\"), tailZone.iEndRecurrence);\n            } else {\n                tailZone \u003d new DSTZone(tailZone.getID(), tailZone.iStandardOffset, tailZone.iStartRecurrence, tailZone.iEndRecurrence.renameAppend(\"-Summer\"));\n            }\n        }\n    }\n    return new PrecalculatedZone((outputID ? id : \"\"), trans, wallOffsets, standardOffsets, nameKeys, tailZone);\n}",
      "path": "JodaTime/src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java",
      "functionStartLine": 1387,
      "functionName": "create",
      "functionAnnotation": "",
      "functionDoc": "Factory to create instance from builder.\n\n@param id the zone id\n@param outputID true if the zone id should be output\n@param transitions the list of Transition objects\n@param tailZone optional zone for getting info beyond precalculated tables\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "JodaTime/src/java/org/joda/time/tz/DateTimeZoneBuilder.java",
        "newPath": "JodaTime/src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java"
      }
    },
    "3f1e047c898c9c925e1faac33bb07e1cb05d88cb": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Move to Java 5 with generics\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@1406 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1\n",
      "commitDate": "11/4/09, 3:55 PM",
      "commitName": "3f1e047c898c9c925e1faac33bb07e1cb05d88cb",
      "commitAuthor": "Stephen Colebourne",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Move to Java 5 with generics\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@1406 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1\n",
          "commitDate": "11/4/09, 3:55 PM",
          "commitName": "3f1e047c898c9c925e1faac33bb07e1cb05d88cb",
          "commitAuthor": "Stephen Colebourne",
          "commitDateOld": "8/13/09, 4:26 PM",
          "commitNameOld": "6cd3a18f8cb3c907107017849ab1ac3b88e43fb5",
          "commitAuthorOld": "Stephen Colebourne",
          "daysBetweenCommits": 83.02,
          "commitsBetweenForRepo": 10,
          "commitsBetweenForFile": 1,
          "actualSource": "static PrecalculatedZone create(String id, boolean outputID, ArrayList\u003cTransition\u003e transitions, DSTZone tailZone) {\n    int size \u003d transitions.size();\n    if (size \u003d\u003d 0) {\n        throw new IllegalArgumentException();\n    }\n    long[] trans \u003d new long[size];\n    int[] wallOffsets \u003d new int[size];\n    int[] standardOffsets \u003d new int[size];\n    String[] nameKeys \u003d new String[size];\n    Transition last \u003d null;\n    for (int i \u003d 0; i \u003c size; i++) {\n        Transition tr \u003d transitions.get(i);\n        if (!tr.isTransitionFrom(last)) {\n            throw new IllegalArgumentException(id);\n        }\n        trans[i] \u003d tr.getMillis();\n        wallOffsets[i] \u003d tr.getWallOffset();\n        standardOffsets[i] \u003d tr.getStandardOffset();\n        nameKeys[i] \u003d tr.getNameKey();\n        last \u003d tr;\n    }\n    String[] zoneNameData \u003d new String[5];\n    String[][] zoneStrings \u003d new DateFormatSymbols(Locale.ENGLISH).getZoneStrings();\n    for (int j \u003d 0; j \u003c zoneStrings.length; j++) {\n        String[] set \u003d zoneStrings[j];\n        if (set !\u003d null \u0026\u0026 set.length \u003d\u003d 5 \u0026\u0026 id.equals(set[0])) {\n            zoneNameData \u003d set;\n        }\n    }\n    Chronology chrono \u003d ISOChronology.getInstanceUTC();\n    for (int i \u003d 0; i \u003c nameKeys.length - 1; i++) {\n        String curNameKey \u003d nameKeys[i];\n        String nextNameKey \u003d nameKeys[i + 1];\n        long curOffset \u003d wallOffsets[i];\n        long nextOffset \u003d wallOffsets[i + 1];\n        long curStdOffset \u003d standardOffsets[i];\n        long nextStdOffset \u003d standardOffsets[i + 1];\n        Period p \u003d new Period(trans[i], trans[i + 1], PeriodType.yearMonthDay(), chrono);\n        if (curOffset !\u003d nextOffset \u0026\u0026 curStdOffset \u003d\u003d nextStdOffset \u0026\u0026 curNameKey.equals(nextNameKey) \u0026\u0026 p.getYears() \u003d\u003d 0 \u0026\u0026 p.getMonths() \u003e 4 \u0026\u0026 p.getMonths() \u003c 8 \u0026\u0026 curNameKey.equals(zoneNameData[2]) \u0026\u0026 curNameKey.equals(zoneNameData[4])) {\n            System.out.println(\"Fixing duplicate name key - \" + nextNameKey);\n            System.out.println(\"     - \" + new DateTime(trans[i], chrono) + \" - \" + new DateTime(trans[i + 1], chrono));\n            if (curOffset \u003e nextOffset) {\n                nameKeys[i] \u003d (curNameKey + \"-Summer\").intern();\n            } else if (curOffset \u003c nextOffset) {\n                nameKeys[i + 1] \u003d (nextNameKey + \"-Summer\").intern();\n                i++;\n            }\n        }\n    }\n    if (tailZone !\u003d null) {\n        if (tailZone.iStartRecurrence.getNameKey().equals(tailZone.iEndRecurrence.getNameKey())) {\n            System.out.println(\"Fixing duplicate recurrent name key - \" + tailZone.iStartRecurrence.getNameKey());\n            if (tailZone.iStartRecurrence.getSaveMillis() \u003e 0) {\n                tailZone \u003d new DSTZone(tailZone.getID(), tailZone.iStandardOffset, tailZone.iStartRecurrence.renameAppend(\"-Summer\"), tailZone.iEndRecurrence);\n            } else {\n                tailZone \u003d new DSTZone(tailZone.getID(), tailZone.iStandardOffset, tailZone.iStartRecurrence, tailZone.iEndRecurrence.renameAppend(\"-Summer\"));\n            }\n        }\n    }\n    return new PrecalculatedZone((outputID ? id : \"\"), trans, wallOffsets, standardOffsets, nameKeys, tailZone);\n}",
          "path": "JodaTime/src/java/org/joda/time/tz/DateTimeZoneBuilder.java",
          "functionStartLine": 1389,
          "functionName": "create",
          "functionAnnotation": "",
          "functionDoc": "Factory to create instance from builder.\n\n@param id the zone id\n@param outputID true if the zone id should be output\n@param transitions the list of Transition objects\n@param tailZone optional zone for getting info beyond precalculated tables\n",
          "diff": "@@ -1,61 +1,61 @@\n-static PrecalculatedZone create(String id, boolean outputID, ArrayList transitions, DSTZone tailZone) {\n+static PrecalculatedZone create(String id, boolean outputID, ArrayList\u003cTransition\u003e transitions, DSTZone tailZone) {\n     int size \u003d transitions.size();\n     if (size \u003d\u003d 0) {\n         throw new IllegalArgumentException();\n     }\n     long[] trans \u003d new long[size];\n     int[] wallOffsets \u003d new int[size];\n     int[] standardOffsets \u003d new int[size];\n     String[] nameKeys \u003d new String[size];\n     Transition last \u003d null;\n     for (int i \u003d 0; i \u003c size; i++) {\n-        Transition tr \u003d (Transition) transitions.get(i);\n+        Transition tr \u003d transitions.get(i);\n         if (!tr.isTransitionFrom(last)) {\n             throw new IllegalArgumentException(id);\n         }\n         trans[i] \u003d tr.getMillis();\n         wallOffsets[i] \u003d tr.getWallOffset();\n         standardOffsets[i] \u003d tr.getStandardOffset();\n         nameKeys[i] \u003d tr.getNameKey();\n         last \u003d tr;\n     }\n     String[] zoneNameData \u003d new String[5];\n     String[][] zoneStrings \u003d new DateFormatSymbols(Locale.ENGLISH).getZoneStrings();\n     for (int j \u003d 0; j \u003c zoneStrings.length; j++) {\n         String[] set \u003d zoneStrings[j];\n         if (set !\u003d null \u0026\u0026 set.length \u003d\u003d 5 \u0026\u0026 id.equals(set[0])) {\n             zoneNameData \u003d set;\n         }\n     }\n     Chronology chrono \u003d ISOChronology.getInstanceUTC();\n     for (int i \u003d 0; i \u003c nameKeys.length - 1; i++) {\n         String curNameKey \u003d nameKeys[i];\n         String nextNameKey \u003d nameKeys[i + 1];\n         long curOffset \u003d wallOffsets[i];\n         long nextOffset \u003d wallOffsets[i + 1];\n         long curStdOffset \u003d standardOffsets[i];\n         long nextStdOffset \u003d standardOffsets[i + 1];\n         Period p \u003d new Period(trans[i], trans[i + 1], PeriodType.yearMonthDay(), chrono);\n         if (curOffset !\u003d nextOffset \u0026\u0026 curStdOffset \u003d\u003d nextStdOffset \u0026\u0026 curNameKey.equals(nextNameKey) \u0026\u0026 p.getYears() \u003d\u003d 0 \u0026\u0026 p.getMonths() \u003e 4 \u0026\u0026 p.getMonths() \u003c 8 \u0026\u0026 curNameKey.equals(zoneNameData[2]) \u0026\u0026 curNameKey.equals(zoneNameData[4])) {\n             System.out.println(\"Fixing duplicate name key - \" + nextNameKey);\n             System.out.println(\"     - \" + new DateTime(trans[i], chrono) + \" - \" + new DateTime(trans[i + 1], chrono));\n             if (curOffset \u003e nextOffset) {\n                 nameKeys[i] \u003d (curNameKey + \"-Summer\").intern();\n             } else if (curOffset \u003c nextOffset) {\n                 nameKeys[i + 1] \u003d (nextNameKey + \"-Summer\").intern();\n                 i++;\n             }\n         }\n     }\n     if (tailZone !\u003d null) {\n         if (tailZone.iStartRecurrence.getNameKey().equals(tailZone.iEndRecurrence.getNameKey())) {\n             System.out.println(\"Fixing duplicate recurrent name key - \" + tailZone.iStartRecurrence.getNameKey());\n             if (tailZone.iStartRecurrence.getSaveMillis() \u003e 0) {\n                 tailZone \u003d new DSTZone(tailZone.getID(), tailZone.iStandardOffset, tailZone.iStartRecurrence.renameAppend(\"-Summer\"), tailZone.iEndRecurrence);\n             } else {\n                 tailZone \u003d new DSTZone(tailZone.getID(), tailZone.iStandardOffset, tailZone.iStartRecurrence, tailZone.iEndRecurrence.renameAppend(\"-Summer\"));\n             }\n         }\n     }\n     return new PrecalculatedZone((outputID ? id : \"\"), trans, wallOffsets, standardOffsets, nameKeys, tailZone);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[id-String, outputID-boolean, transitions-ArrayList, tailZone-DSTZone]",
            "newValue": "[id-String, outputID-boolean, transitions-ArrayList\u003cTransition\u003e, tailZone-DSTZone]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Move to Java 5 with generics\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@1406 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1\n",
          "commitDate": "11/4/09, 3:55 PM",
          "commitName": "3f1e047c898c9c925e1faac33bb07e1cb05d88cb",
          "commitAuthor": "Stephen Colebourne",
          "commitDateOld": "8/13/09, 4:26 PM",
          "commitNameOld": "6cd3a18f8cb3c907107017849ab1ac3b88e43fb5",
          "commitAuthorOld": "Stephen Colebourne",
          "daysBetweenCommits": 83.02,
          "commitsBetweenForRepo": 10,
          "commitsBetweenForFile": 1,
          "actualSource": "static PrecalculatedZone create(String id, boolean outputID, ArrayList\u003cTransition\u003e transitions, DSTZone tailZone) {\n    int size \u003d transitions.size();\n    if (size \u003d\u003d 0) {\n        throw new IllegalArgumentException();\n    }\n    long[] trans \u003d new long[size];\n    int[] wallOffsets \u003d new int[size];\n    int[] standardOffsets \u003d new int[size];\n    String[] nameKeys \u003d new String[size];\n    Transition last \u003d null;\n    for (int i \u003d 0; i \u003c size; i++) {\n        Transition tr \u003d transitions.get(i);\n        if (!tr.isTransitionFrom(last)) {\n            throw new IllegalArgumentException(id);\n        }\n        trans[i] \u003d tr.getMillis();\n        wallOffsets[i] \u003d tr.getWallOffset();\n        standardOffsets[i] \u003d tr.getStandardOffset();\n        nameKeys[i] \u003d tr.getNameKey();\n        last \u003d tr;\n    }\n    String[] zoneNameData \u003d new String[5];\n    String[][] zoneStrings \u003d new DateFormatSymbols(Locale.ENGLISH).getZoneStrings();\n    for (int j \u003d 0; j \u003c zoneStrings.length; j++) {\n        String[] set \u003d zoneStrings[j];\n        if (set !\u003d null \u0026\u0026 set.length \u003d\u003d 5 \u0026\u0026 id.equals(set[0])) {\n            zoneNameData \u003d set;\n        }\n    }\n    Chronology chrono \u003d ISOChronology.getInstanceUTC();\n    for (int i \u003d 0; i \u003c nameKeys.length - 1; i++) {\n        String curNameKey \u003d nameKeys[i];\n        String nextNameKey \u003d nameKeys[i + 1];\n        long curOffset \u003d wallOffsets[i];\n        long nextOffset \u003d wallOffsets[i + 1];\n        long curStdOffset \u003d standardOffsets[i];\n        long nextStdOffset \u003d standardOffsets[i + 1];\n        Period p \u003d new Period(trans[i], trans[i + 1], PeriodType.yearMonthDay(), chrono);\n        if (curOffset !\u003d nextOffset \u0026\u0026 curStdOffset \u003d\u003d nextStdOffset \u0026\u0026 curNameKey.equals(nextNameKey) \u0026\u0026 p.getYears() \u003d\u003d 0 \u0026\u0026 p.getMonths() \u003e 4 \u0026\u0026 p.getMonths() \u003c 8 \u0026\u0026 curNameKey.equals(zoneNameData[2]) \u0026\u0026 curNameKey.equals(zoneNameData[4])) {\n            System.out.println(\"Fixing duplicate name key - \" + nextNameKey);\n            System.out.println(\"     - \" + new DateTime(trans[i], chrono) + \" - \" + new DateTime(trans[i + 1], chrono));\n            if (curOffset \u003e nextOffset) {\n                nameKeys[i] \u003d (curNameKey + \"-Summer\").intern();\n            } else if (curOffset \u003c nextOffset) {\n                nameKeys[i + 1] \u003d (nextNameKey + \"-Summer\").intern();\n                i++;\n            }\n        }\n    }\n    if (tailZone !\u003d null) {\n        if (tailZone.iStartRecurrence.getNameKey().equals(tailZone.iEndRecurrence.getNameKey())) {\n            System.out.println(\"Fixing duplicate recurrent name key - \" + tailZone.iStartRecurrence.getNameKey());\n            if (tailZone.iStartRecurrence.getSaveMillis() \u003e 0) {\n                tailZone \u003d new DSTZone(tailZone.getID(), tailZone.iStandardOffset, tailZone.iStartRecurrence.renameAppend(\"-Summer\"), tailZone.iEndRecurrence);\n            } else {\n                tailZone \u003d new DSTZone(tailZone.getID(), tailZone.iStandardOffset, tailZone.iStartRecurrence, tailZone.iEndRecurrence.renameAppend(\"-Summer\"));\n            }\n        }\n    }\n    return new PrecalculatedZone((outputID ? id : \"\"), trans, wallOffsets, standardOffsets, nameKeys, tailZone);\n}",
          "path": "JodaTime/src/java/org/joda/time/tz/DateTimeZoneBuilder.java",
          "functionStartLine": 1389,
          "functionName": "create",
          "functionAnnotation": "",
          "functionDoc": "Factory to create instance from builder.\n\n@param id the zone id\n@param outputID true if the zone id should be output\n@param transitions the list of Transition objects\n@param tailZone optional zone for getting info beyond precalculated tables\n",
          "diff": "@@ -1,61 +1,61 @@\n-static PrecalculatedZone create(String id, boolean outputID, ArrayList transitions, DSTZone tailZone) {\n+static PrecalculatedZone create(String id, boolean outputID, ArrayList\u003cTransition\u003e transitions, DSTZone tailZone) {\n     int size \u003d transitions.size();\n     if (size \u003d\u003d 0) {\n         throw new IllegalArgumentException();\n     }\n     long[] trans \u003d new long[size];\n     int[] wallOffsets \u003d new int[size];\n     int[] standardOffsets \u003d new int[size];\n     String[] nameKeys \u003d new String[size];\n     Transition last \u003d null;\n     for (int i \u003d 0; i \u003c size; i++) {\n-        Transition tr \u003d (Transition) transitions.get(i);\n+        Transition tr \u003d transitions.get(i);\n         if (!tr.isTransitionFrom(last)) {\n             throw new IllegalArgumentException(id);\n         }\n         trans[i] \u003d tr.getMillis();\n         wallOffsets[i] \u003d tr.getWallOffset();\n         standardOffsets[i] \u003d tr.getStandardOffset();\n         nameKeys[i] \u003d tr.getNameKey();\n         last \u003d tr;\n     }\n     String[] zoneNameData \u003d new String[5];\n     String[][] zoneStrings \u003d new DateFormatSymbols(Locale.ENGLISH).getZoneStrings();\n     for (int j \u003d 0; j \u003c zoneStrings.length; j++) {\n         String[] set \u003d zoneStrings[j];\n         if (set !\u003d null \u0026\u0026 set.length \u003d\u003d 5 \u0026\u0026 id.equals(set[0])) {\n             zoneNameData \u003d set;\n         }\n     }\n     Chronology chrono \u003d ISOChronology.getInstanceUTC();\n     for (int i \u003d 0; i \u003c nameKeys.length - 1; i++) {\n         String curNameKey \u003d nameKeys[i];\n         String nextNameKey \u003d nameKeys[i + 1];\n         long curOffset \u003d wallOffsets[i];\n         long nextOffset \u003d wallOffsets[i + 1];\n         long curStdOffset \u003d standardOffsets[i];\n         long nextStdOffset \u003d standardOffsets[i + 1];\n         Period p \u003d new Period(trans[i], trans[i + 1], PeriodType.yearMonthDay(), chrono);\n         if (curOffset !\u003d nextOffset \u0026\u0026 curStdOffset \u003d\u003d nextStdOffset \u0026\u0026 curNameKey.equals(nextNameKey) \u0026\u0026 p.getYears() \u003d\u003d 0 \u0026\u0026 p.getMonths() \u003e 4 \u0026\u0026 p.getMonths() \u003c 8 \u0026\u0026 curNameKey.equals(zoneNameData[2]) \u0026\u0026 curNameKey.equals(zoneNameData[4])) {\n             System.out.println(\"Fixing duplicate name key - \" + nextNameKey);\n             System.out.println(\"     - \" + new DateTime(trans[i], chrono) + \" - \" + new DateTime(trans[i + 1], chrono));\n             if (curOffset \u003e nextOffset) {\n                 nameKeys[i] \u003d (curNameKey + \"-Summer\").intern();\n             } else if (curOffset \u003c nextOffset) {\n                 nameKeys[i + 1] \u003d (nextNameKey + \"-Summer\").intern();\n                 i++;\n             }\n         }\n     }\n     if (tailZone !\u003d null) {\n         if (tailZone.iStartRecurrence.getNameKey().equals(tailZone.iEndRecurrence.getNameKey())) {\n             System.out.println(\"Fixing duplicate recurrent name key - \" + tailZone.iStartRecurrence.getNameKey());\n             if (tailZone.iStartRecurrence.getSaveMillis() \u003e 0) {\n                 tailZone \u003d new DSTZone(tailZone.getID(), tailZone.iStandardOffset, tailZone.iStartRecurrence.renameAppend(\"-Summer\"), tailZone.iEndRecurrence);\n             } else {\n                 tailZone \u003d new DSTZone(tailZone.getID(), tailZone.iStandardOffset, tailZone.iStartRecurrence, tailZone.iEndRecurrence.renameAppend(\"-Summer\"));\n             }\n         }\n     }\n     return new PrecalculatedZone((outputID ? id : \"\"), trans, wallOffsets, standardOffsets, nameKeys, tailZone);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "aa8986650e3820e03af178de7f69def85d780b64": {
      "type": "Ybodychange",
      "commitMessage": "Fix so that builder works even when system time zone isn\u0027t UTC.\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@1378 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1\n",
      "commitDate": "3/26/09, 7:35 AM",
      "commitName": "aa8986650e3820e03af178de7f69def85d780b64",
      "commitAuthor": "Brian S O\u0027Neill",
      "commitDateOld": "10/29/07, 2:28 AM",
      "commitNameOld": "5ccd1def534f2e37637d0311fb8bcfba62f1c74d",
      "commitAuthorOld": "Stephen Colebourne",
      "daysBetweenCommits": 514.21,
      "commitsBetweenForRepo": 74,
      "commitsBetweenForFile": 1,
      "actualSource": "static PrecalculatedZone create(String id, boolean outputID, ArrayList transitions, DSTZone tailZone) {\n    int size \u003d transitions.size();\n    if (size \u003d\u003d 0) {\n        throw new IllegalArgumentException();\n    }\n    long[] trans \u003d new long[size];\n    int[] wallOffsets \u003d new int[size];\n    int[] standardOffsets \u003d new int[size];\n    String[] nameKeys \u003d new String[size];\n    Transition last \u003d null;\n    for (int i \u003d 0; i \u003c size; i++) {\n        Transition tr \u003d (Transition) transitions.get(i);\n        if (!tr.isTransitionFrom(last)) {\n            throw new IllegalArgumentException(id);\n        }\n        trans[i] \u003d tr.getMillis();\n        wallOffsets[i] \u003d tr.getWallOffset();\n        standardOffsets[i] \u003d tr.getStandardOffset();\n        nameKeys[i] \u003d tr.getNameKey();\n        last \u003d tr;\n    }\n    String[] zoneNameData \u003d new String[5];\n    String[][] zoneStrings \u003d new DateFormatSymbols(Locale.ENGLISH).getZoneStrings();\n    for (int j \u003d 0; j \u003c zoneStrings.length; j++) {\n        String[] set \u003d zoneStrings[j];\n        if (set !\u003d null \u0026\u0026 set.length \u003d\u003d 5 \u0026\u0026 id.equals(set[0])) {\n            zoneNameData \u003d set;\n        }\n    }\n    Chronology chrono \u003d ISOChronology.getInstanceUTC();\n    for (int i \u003d 0; i \u003c nameKeys.length - 1; i++) {\n        String curNameKey \u003d nameKeys[i];\n        String nextNameKey \u003d nameKeys[i + 1];\n        long curOffset \u003d wallOffsets[i];\n        long nextOffset \u003d wallOffsets[i + 1];\n        long curStdOffset \u003d standardOffsets[i];\n        long nextStdOffset \u003d standardOffsets[i + 1];\n        Period p \u003d new Period(trans[i], trans[i + 1], PeriodType.yearMonthDay(), chrono);\n        if (curOffset !\u003d nextOffset \u0026\u0026 curStdOffset \u003d\u003d nextStdOffset \u0026\u0026 curNameKey.equals(nextNameKey) \u0026\u0026 p.getYears() \u003d\u003d 0 \u0026\u0026 p.getMonths() \u003e 4 \u0026\u0026 p.getMonths() \u003c 8 \u0026\u0026 curNameKey.equals(zoneNameData[2]) \u0026\u0026 curNameKey.equals(zoneNameData[4])) {\n            System.out.println(\"Fixing duplicate name key - \" + nextNameKey);\n            System.out.println(\"     - \" + new DateTime(trans[i], chrono) + \" - \" + new DateTime(trans[i + 1], chrono));\n            if (curOffset \u003e nextOffset) {\n                nameKeys[i] \u003d (curNameKey + \"-Summer\").intern();\n            } else if (curOffset \u003c nextOffset) {\n                nameKeys[i + 1] \u003d (nextNameKey + \"-Summer\").intern();\n                i++;\n            }\n        }\n    }\n    if (tailZone !\u003d null) {\n        if (tailZone.iStartRecurrence.getNameKey().equals(tailZone.iEndRecurrence.getNameKey())) {\n            System.out.println(\"Fixing duplicate recurrent name key - \" + tailZone.iStartRecurrence.getNameKey());\n            if (tailZone.iStartRecurrence.getSaveMillis() \u003e 0) {\n                tailZone \u003d new DSTZone(tailZone.getID(), tailZone.iStandardOffset, tailZone.iStartRecurrence.renameAppend(\"-Summer\"), tailZone.iEndRecurrence);\n            } else {\n                tailZone \u003d new DSTZone(tailZone.getID(), tailZone.iStandardOffset, tailZone.iStartRecurrence, tailZone.iEndRecurrence.renameAppend(\"-Summer\"));\n            }\n        }\n    }\n    return new PrecalculatedZone((outputID ? id : \"\"), trans, wallOffsets, standardOffsets, nameKeys, tailZone);\n}",
      "path": "JodaTime/src/java/org/joda/time/tz/DateTimeZoneBuilder.java",
      "functionStartLine": 1388,
      "functionName": "create",
      "functionAnnotation": "",
      "functionDoc": "Factory to create instance from builder.\n\n@param id the zone id\n@param outputID true if the zone id should be output\n@param transitions the list of Transition objects\n@param tailZone optional zone for getting info beyond precalculated tables\n",
      "diff": "@@ -1,60 +1,61 @@\n static PrecalculatedZone create(String id, boolean outputID, ArrayList transitions, DSTZone tailZone) {\n     int size \u003d transitions.size();\n     if (size \u003d\u003d 0) {\n         throw new IllegalArgumentException();\n     }\n     long[] trans \u003d new long[size];\n     int[] wallOffsets \u003d new int[size];\n     int[] standardOffsets \u003d new int[size];\n     String[] nameKeys \u003d new String[size];\n     Transition last \u003d null;\n     for (int i \u003d 0; i \u003c size; i++) {\n         Transition tr \u003d (Transition) transitions.get(i);\n         if (!tr.isTransitionFrom(last)) {\n             throw new IllegalArgumentException(id);\n         }\n         trans[i] \u003d tr.getMillis();\n         wallOffsets[i] \u003d tr.getWallOffset();\n         standardOffsets[i] \u003d tr.getStandardOffset();\n         nameKeys[i] \u003d tr.getNameKey();\n         last \u003d tr;\n     }\n     String[] zoneNameData \u003d new String[5];\n     String[][] zoneStrings \u003d new DateFormatSymbols(Locale.ENGLISH).getZoneStrings();\n     for (int j \u003d 0; j \u003c zoneStrings.length; j++) {\n         String[] set \u003d zoneStrings[j];\n         if (set !\u003d null \u0026\u0026 set.length \u003d\u003d 5 \u0026\u0026 id.equals(set[0])) {\n             zoneNameData \u003d set;\n         }\n     }\n+    Chronology chrono \u003d ISOChronology.getInstanceUTC();\n     for (int i \u003d 0; i \u003c nameKeys.length - 1; i++) {\n         String curNameKey \u003d nameKeys[i];\n         String nextNameKey \u003d nameKeys[i + 1];\n         long curOffset \u003d wallOffsets[i];\n         long nextOffset \u003d wallOffsets[i + 1];\n         long curStdOffset \u003d standardOffsets[i];\n         long nextStdOffset \u003d standardOffsets[i + 1];\n-        Period p \u003d new Period(trans[i], trans[i + 1], PeriodType.yearMonthDay());\n+        Period p \u003d new Period(trans[i], trans[i + 1], PeriodType.yearMonthDay(), chrono);\n         if (curOffset !\u003d nextOffset \u0026\u0026 curStdOffset \u003d\u003d nextStdOffset \u0026\u0026 curNameKey.equals(nextNameKey) \u0026\u0026 p.getYears() \u003d\u003d 0 \u0026\u0026 p.getMonths() \u003e 4 \u0026\u0026 p.getMonths() \u003c 8 \u0026\u0026 curNameKey.equals(zoneNameData[2]) \u0026\u0026 curNameKey.equals(zoneNameData[4])) {\n             System.out.println(\"Fixing duplicate name key - \" + nextNameKey);\n-            System.out.println(\"     - \" + new DateTime(trans[i]) + \" - \" + new DateTime(trans[i + 1]));\n+            System.out.println(\"     - \" + new DateTime(trans[i], chrono) + \" - \" + new DateTime(trans[i + 1], chrono));\n             if (curOffset \u003e nextOffset) {\n                 nameKeys[i] \u003d (curNameKey + \"-Summer\").intern();\n             } else if (curOffset \u003c nextOffset) {\n                 nameKeys[i + 1] \u003d (nextNameKey + \"-Summer\").intern();\n                 i++;\n             }\n         }\n     }\n     if (tailZone !\u003d null) {\n         if (tailZone.iStartRecurrence.getNameKey().equals(tailZone.iEndRecurrence.getNameKey())) {\n             System.out.println(\"Fixing duplicate recurrent name key - \" + tailZone.iStartRecurrence.getNameKey());\n             if (tailZone.iStartRecurrence.getSaveMillis() \u003e 0) {\n                 tailZone \u003d new DSTZone(tailZone.getID(), tailZone.iStandardOffset, tailZone.iStartRecurrence.renameAppend(\"-Summer\"), tailZone.iEndRecurrence);\n             } else {\n                 tailZone \u003d new DSTZone(tailZone.getID(), tailZone.iStandardOffset, tailZone.iStartRecurrence, tailZone.iEndRecurrence.renameAppend(\"-Summer\"));\n             }\n         }\n     }\n     return new PrecalculatedZone((outputID ? id : \"\"), trans, wallOffsets, standardOffsets, nameKeys, tailZone);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "bb9aea5d7374bd98a8548008c40a29df3681c10b": {
      "type": "Ybodychange",
      "commitMessage": "Updated to TZ version 2007g.\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@1250 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1\n",
      "commitDate": "9/9/07, 11:31 AM",
      "commitName": "bb9aea5d7374bd98a8548008c40a29df3681c10b",
      "commitAuthor": "Brian S O\u0027Neill",
      "commitDateOld": "5/20/07, 3:02 AM",
      "commitNameOld": "9b01b9e8b42e8f33f02caf91110fe6459e830fcb",
      "commitAuthorOld": "Stephen Colebourne",
      "daysBetweenCommits": 112.35,
      "commitsBetweenForRepo": 32,
      "commitsBetweenForFile": 1,
      "actualSource": "static PrecalculatedZone create(String id, boolean outputID, ArrayList transitions, DSTZone tailZone) {\n    int size \u003d transitions.size();\n    if (size \u003d\u003d 0) {\n        throw new IllegalArgumentException();\n    }\n    long[] trans \u003d new long[size];\n    int[] wallOffsets \u003d new int[size];\n    int[] standardOffsets \u003d new int[size];\n    String[] nameKeys \u003d new String[size];\n    Transition last \u003d null;\n    for (int i \u003d 0; i \u003c size; i++) {\n        Transition tr \u003d (Transition) transitions.get(i);\n        if (!tr.isTransitionFrom(last)) {\n            throw new IllegalArgumentException(id);\n        }\n        trans[i] \u003d tr.getMillis();\n        wallOffsets[i] \u003d tr.getWallOffset();\n        standardOffsets[i] \u003d tr.getStandardOffset();\n        nameKeys[i] \u003d tr.getNameKey();\n        last \u003d tr;\n    }\n    String[] zoneNameData \u003d new String[5];\n    String[][] zoneStrings \u003d new DateFormatSymbols(Locale.ENGLISH).getZoneStrings();\n    for (int j \u003d 0; j \u003c zoneStrings.length; j++) {\n        String[] set \u003d zoneStrings[j];\n        if (set !\u003d null \u0026\u0026 set.length \u003d\u003d 5 \u0026\u0026 id.equals(set[0])) {\n            zoneNameData \u003d set;\n        }\n    }\n    for (int i \u003d 0; i \u003c nameKeys.length - 1; i++) {\n        String curNameKey \u003d nameKeys[i];\n        String nextNameKey \u003d nameKeys[i + 1];\n        long curOffset \u003d wallOffsets[i];\n        long nextOffset \u003d wallOffsets[i + 1];\n        long curStdOffset \u003d standardOffsets[i];\n        long nextStdOffset \u003d standardOffsets[i + 1];\n        Period p \u003d new Period(trans[i], trans[i + 1], PeriodType.yearMonthDay());\n        if (curOffset !\u003d nextOffset \u0026\u0026 curStdOffset \u003d\u003d nextStdOffset \u0026\u0026 curNameKey.equals(nextNameKey) \u0026\u0026 p.getYears() \u003d\u003d 0 \u0026\u0026 p.getMonths() \u003e 4 \u0026\u0026 p.getMonths() \u003c 8 \u0026\u0026 curNameKey.equals(zoneNameData[2]) \u0026\u0026 curNameKey.equals(zoneNameData[4])) {\n            System.out.println(\"Fixing duplicate name key - \" + nextNameKey);\n            System.out.println(\"     - \" + new DateTime(trans[i]) + \" - \" + new DateTime(trans[i + 1]));\n            if (curOffset \u003e nextOffset) {\n                nameKeys[i] \u003d (curNameKey + \"-Summer\").intern();\n            } else if (curOffset \u003c nextOffset) {\n                nameKeys[i + 1] \u003d (nextNameKey + \"-Summer\").intern();\n                i++;\n            }\n        }\n    }\n    if (tailZone !\u003d null) {\n        if (tailZone.iStartRecurrence.getNameKey().equals(tailZone.iEndRecurrence.getNameKey())) {\n            System.out.println(\"Fixing duplicate recurrent name key - \" + tailZone.iStartRecurrence.getNameKey());\n            if (tailZone.iStartRecurrence.getSaveMillis() \u003e 0) {\n                tailZone \u003d new DSTZone(tailZone.getID(), tailZone.iStandardOffset, tailZone.iStartRecurrence.renameAppend(\"-Summer\"), tailZone.iEndRecurrence);\n            } else {\n                tailZone \u003d new DSTZone(tailZone.getID(), tailZone.iStandardOffset, tailZone.iStartRecurrence, tailZone.iEndRecurrence.renameAppend(\"-Summer\"));\n            }\n        }\n    }\n    return new PrecalculatedZone((outputID ? id : \"\"), trans, wallOffsets, standardOffsets, nameKeys, tailZone);\n}",
      "path": "JodaTime/src/java/org/joda/time/tz/DateTimeZoneBuilder.java",
      "functionStartLine": 1386,
      "functionName": "create",
      "functionAnnotation": "",
      "functionDoc": "Factory to create instance from builder.\n\n@param id the zone id\n@param outputID true if the zone id should be output\n@param transitions the list of Transition objects\n@param tailZone optional zone for getting info beyond precalculated tables\n",
      "diff": "@@ -1,62 +1,60 @@\n static PrecalculatedZone create(String id, boolean outputID, ArrayList transitions, DSTZone tailZone) {\n     int size \u003d transitions.size();\n     if (size \u003d\u003d 0) {\n         throw new IllegalArgumentException();\n     }\n     long[] trans \u003d new long[size];\n     int[] wallOffsets \u003d new int[size];\n     int[] standardOffsets \u003d new int[size];\n     String[] nameKeys \u003d new String[size];\n     Transition last \u003d null;\n     for (int i \u003d 0; i \u003c size; i++) {\n         Transition tr \u003d (Transition) transitions.get(i);\n         if (!tr.isTransitionFrom(last)) {\n             throw new IllegalArgumentException(id);\n         }\n         trans[i] \u003d tr.getMillis();\n         wallOffsets[i] \u003d tr.getWallOffset();\n         standardOffsets[i] \u003d tr.getStandardOffset();\n         nameKeys[i] \u003d tr.getNameKey();\n         last \u003d tr;\n     }\n     String[] zoneNameData \u003d new String[5];\n     String[][] zoneStrings \u003d new DateFormatSymbols(Locale.ENGLISH).getZoneStrings();\n     for (int j \u003d 0; j \u003c zoneStrings.length; j++) {\n         String[] set \u003d zoneStrings[j];\n         if (set !\u003d null \u0026\u0026 set.length \u003d\u003d 5 \u0026\u0026 id.equals(set[0])) {\n             zoneNameData \u003d set;\n         }\n     }\n     for (int i \u003d 0; i \u003c nameKeys.length - 1; i++) {\n         String curNameKey \u003d nameKeys[i];\n         String nextNameKey \u003d nameKeys[i + 1];\n         long curOffset \u003d wallOffsets[i];\n         long nextOffset \u003d wallOffsets[i + 1];\n         long curStdOffset \u003d standardOffsets[i];\n         long nextStdOffset \u003d standardOffsets[i + 1];\n         Period p \u003d new Period(trans[i], trans[i + 1], PeriodType.yearMonthDay());\n         if (curOffset !\u003d nextOffset \u0026\u0026 curStdOffset \u003d\u003d nextStdOffset \u0026\u0026 curNameKey.equals(nextNameKey) \u0026\u0026 p.getYears() \u003d\u003d 0 \u0026\u0026 p.getMonths() \u003e 4 \u0026\u0026 p.getMonths() \u003c 8 \u0026\u0026 curNameKey.equals(zoneNameData[2]) \u0026\u0026 curNameKey.equals(zoneNameData[4])) {\n             System.out.println(\"Fixing duplicate name key - \" + nextNameKey);\n             System.out.println(\"     - \" + new DateTime(trans[i]) + \" - \" + new DateTime(trans[i + 1]));\n             if (curOffset \u003e nextOffset) {\n                 nameKeys[i] \u003d (curNameKey + \"-Summer\").intern();\n             } else if (curOffset \u003c nextOffset) {\n                 nameKeys[i + 1] \u003d (nextNameKey + \"-Summer\").intern();\n                 i++;\n             }\n         }\n     }\n     if (tailZone !\u003d null) {\n         if (tailZone.iStartRecurrence.getNameKey().equals(tailZone.iEndRecurrence.getNameKey())) {\n             System.out.println(\"Fixing duplicate recurrent name key - \" + tailZone.iStartRecurrence.getNameKey());\n             if (tailZone.iStartRecurrence.getSaveMillis() \u003e 0) {\n-                Recurrence r \u003d new Recurrence(tailZone.iStartRecurrence.iOfYear, tailZone.iStartRecurrence.iNameKey + \"-Summer\", tailZone.iStartRecurrence.iSaveMillis);\n-                tailZone \u003d new DSTZone(tailZone.getID(), tailZone.iStandardOffset, r, tailZone.iEndRecurrence);\n+                tailZone \u003d new DSTZone(tailZone.getID(), tailZone.iStandardOffset, tailZone.iStartRecurrence.renameAppend(\"-Summer\"), tailZone.iEndRecurrence);\n             } else {\n-                Recurrence r \u003d new Recurrence(tailZone.iEndRecurrence.iOfYear, tailZone.iEndRecurrence.iNameKey + \"-Summer\", tailZone.iEndRecurrence.iSaveMillis);\n-                tailZone \u003d new DSTZone(tailZone.getID(), tailZone.iStandardOffset, tailZone.iEndRecurrence, r);\n+                tailZone \u003d new DSTZone(tailZone.getID(), tailZone.iStandardOffset, tailZone.iStartRecurrence, tailZone.iEndRecurrence.renameAppend(\"-Summer\"));\n             }\n         }\n     }\n     return new PrecalculatedZone((outputID ? id : \"\"), trans, wallOffsets, standardOffsets, nameKeys, tailZone);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9b01b9e8b42e8f33f02caf91110fe6459e830fcb": {
      "type": "Yintroduced",
      "commitMessage": "Fix bug where some time zones (Australia) use same abbreviated zone name for summer and winter\nbug 1716305\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@1218 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1\n",
      "commitDate": "5/20/07, 3:02 AM",
      "commitName": "9b01b9e8b42e8f33f02caf91110fe6459e830fcb",
      "commitAuthor": "Stephen Colebourne",
      "diff": "@@ -0,0 +1,62 @@\n+static PrecalculatedZone create(String id, boolean outputID, ArrayList transitions, DSTZone tailZone) {\n+    int size \u003d transitions.size();\n+    if (size \u003d\u003d 0) {\n+        throw new IllegalArgumentException();\n+    }\n+    long[] trans \u003d new long[size];\n+    int[] wallOffsets \u003d new int[size];\n+    int[] standardOffsets \u003d new int[size];\n+    String[] nameKeys \u003d new String[size];\n+    Transition last \u003d null;\n+    for (int i \u003d 0; i \u003c size; i++) {\n+        Transition tr \u003d (Transition) transitions.get(i);\n+        if (!tr.isTransitionFrom(last)) {\n+            throw new IllegalArgumentException(id);\n+        }\n+        trans[i] \u003d tr.getMillis();\n+        wallOffsets[i] \u003d tr.getWallOffset();\n+        standardOffsets[i] \u003d tr.getStandardOffset();\n+        nameKeys[i] \u003d tr.getNameKey();\n+        last \u003d tr;\n+    }\n+    String[] zoneNameData \u003d new String[5];\n+    String[][] zoneStrings \u003d new DateFormatSymbols(Locale.ENGLISH).getZoneStrings();\n+    for (int j \u003d 0; j \u003c zoneStrings.length; j++) {\n+        String[] set \u003d zoneStrings[j];\n+        if (set !\u003d null \u0026\u0026 set.length \u003d\u003d 5 \u0026\u0026 id.equals(set[0])) {\n+            zoneNameData \u003d set;\n+        }\n+    }\n+    for (int i \u003d 0; i \u003c nameKeys.length - 1; i++) {\n+        String curNameKey \u003d nameKeys[i];\n+        String nextNameKey \u003d nameKeys[i + 1];\n+        long curOffset \u003d wallOffsets[i];\n+        long nextOffset \u003d wallOffsets[i + 1];\n+        long curStdOffset \u003d standardOffsets[i];\n+        long nextStdOffset \u003d standardOffsets[i + 1];\n+        Period p \u003d new Period(trans[i], trans[i + 1], PeriodType.yearMonthDay());\n+        if (curOffset !\u003d nextOffset \u0026\u0026 curStdOffset \u003d\u003d nextStdOffset \u0026\u0026 curNameKey.equals(nextNameKey) \u0026\u0026 p.getYears() \u003d\u003d 0 \u0026\u0026 p.getMonths() \u003e 4 \u0026\u0026 p.getMonths() \u003c 8 \u0026\u0026 curNameKey.equals(zoneNameData[2]) \u0026\u0026 curNameKey.equals(zoneNameData[4])) {\n+            System.out.println(\"Fixing duplicate name key - \" + nextNameKey);\n+            System.out.println(\"     - \" + new DateTime(trans[i]) + \" - \" + new DateTime(trans[i + 1]));\n+            if (curOffset \u003e nextOffset) {\n+                nameKeys[i] \u003d (curNameKey + \"-Summer\").intern();\n+            } else if (curOffset \u003c nextOffset) {\n+                nameKeys[i + 1] \u003d (nextNameKey + \"-Summer\").intern();\n+                i++;\n+            }\n+        }\n+    }\n+    if (tailZone !\u003d null) {\n+        if (tailZone.iStartRecurrence.getNameKey().equals(tailZone.iEndRecurrence.getNameKey())) {\n+            System.out.println(\"Fixing duplicate recurrent name key - \" + tailZone.iStartRecurrence.getNameKey());\n+            if (tailZone.iStartRecurrence.getSaveMillis() \u003e 0) {\n+                Recurrence r \u003d new Recurrence(tailZone.iStartRecurrence.iOfYear, tailZone.iStartRecurrence.iNameKey + \"-Summer\", tailZone.iStartRecurrence.iSaveMillis);\n+                tailZone \u003d new DSTZone(tailZone.getID(), tailZone.iStandardOffset, r, tailZone.iEndRecurrence);\n+            } else {\n+                Recurrence r \u003d new Recurrence(tailZone.iEndRecurrence.iOfYear, tailZone.iEndRecurrence.iNameKey + \"-Summer\", tailZone.iEndRecurrence.iSaveMillis);\n+                tailZone \u003d new DSTZone(tailZone.getID(), tailZone.iStandardOffset, tailZone.iEndRecurrence, r);\n+            }\n+        }\n+    }\n+    return new PrecalculatedZone((outputID ? id : \"\"), trans, wallOffsets, standardOffsets, nameKeys, tailZone);\n+}\n\\ No newline at end of file\n",
      "actualSource": "static PrecalculatedZone create(String id, boolean outputID, ArrayList transitions, DSTZone tailZone) {\n    int size \u003d transitions.size();\n    if (size \u003d\u003d 0) {\n        throw new IllegalArgumentException();\n    }\n    long[] trans \u003d new long[size];\n    int[] wallOffsets \u003d new int[size];\n    int[] standardOffsets \u003d new int[size];\n    String[] nameKeys \u003d new String[size];\n    Transition last \u003d null;\n    for (int i \u003d 0; i \u003c size; i++) {\n        Transition tr \u003d (Transition) transitions.get(i);\n        if (!tr.isTransitionFrom(last)) {\n            throw new IllegalArgumentException(id);\n        }\n        trans[i] \u003d tr.getMillis();\n        wallOffsets[i] \u003d tr.getWallOffset();\n        standardOffsets[i] \u003d tr.getStandardOffset();\n        nameKeys[i] \u003d tr.getNameKey();\n        last \u003d tr;\n    }\n    String[] zoneNameData \u003d new String[5];\n    String[][] zoneStrings \u003d new DateFormatSymbols(Locale.ENGLISH).getZoneStrings();\n    for (int j \u003d 0; j \u003c zoneStrings.length; j++) {\n        String[] set \u003d zoneStrings[j];\n        if (set !\u003d null \u0026\u0026 set.length \u003d\u003d 5 \u0026\u0026 id.equals(set[0])) {\n            zoneNameData \u003d set;\n        }\n    }\n    for (int i \u003d 0; i \u003c nameKeys.length - 1; i++) {\n        String curNameKey \u003d nameKeys[i];\n        String nextNameKey \u003d nameKeys[i + 1];\n        long curOffset \u003d wallOffsets[i];\n        long nextOffset \u003d wallOffsets[i + 1];\n        long curStdOffset \u003d standardOffsets[i];\n        long nextStdOffset \u003d standardOffsets[i + 1];\n        Period p \u003d new Period(trans[i], trans[i + 1], PeriodType.yearMonthDay());\n        if (curOffset !\u003d nextOffset \u0026\u0026 curStdOffset \u003d\u003d nextStdOffset \u0026\u0026 curNameKey.equals(nextNameKey) \u0026\u0026 p.getYears() \u003d\u003d 0 \u0026\u0026 p.getMonths() \u003e 4 \u0026\u0026 p.getMonths() \u003c 8 \u0026\u0026 curNameKey.equals(zoneNameData[2]) \u0026\u0026 curNameKey.equals(zoneNameData[4])) {\n            System.out.println(\"Fixing duplicate name key - \" + nextNameKey);\n            System.out.println(\"     - \" + new DateTime(trans[i]) + \" - \" + new DateTime(trans[i + 1]));\n            if (curOffset \u003e nextOffset) {\n                nameKeys[i] \u003d (curNameKey + \"-Summer\").intern();\n            } else if (curOffset \u003c nextOffset) {\n                nameKeys[i + 1] \u003d (nextNameKey + \"-Summer\").intern();\n                i++;\n            }\n        }\n    }\n    if (tailZone !\u003d null) {\n        if (tailZone.iStartRecurrence.getNameKey().equals(tailZone.iEndRecurrence.getNameKey())) {\n            System.out.println(\"Fixing duplicate recurrent name key - \" + tailZone.iStartRecurrence.getNameKey());\n            if (tailZone.iStartRecurrence.getSaveMillis() \u003e 0) {\n                Recurrence r \u003d new Recurrence(tailZone.iStartRecurrence.iOfYear, tailZone.iStartRecurrence.iNameKey + \"-Summer\", tailZone.iStartRecurrence.iSaveMillis);\n                tailZone \u003d new DSTZone(tailZone.getID(), tailZone.iStandardOffset, r, tailZone.iEndRecurrence);\n            } else {\n                Recurrence r \u003d new Recurrence(tailZone.iEndRecurrence.iOfYear, tailZone.iEndRecurrence.iNameKey + \"-Summer\", tailZone.iEndRecurrence.iSaveMillis);\n                tailZone \u003d new DSTZone(tailZone.getID(), tailZone.iStandardOffset, tailZone.iEndRecurrence, r);\n            }\n        }\n    }\n    return new PrecalculatedZone((outputID ? id : \"\"), trans, wallOffsets, standardOffsets, nameKeys, tailZone);\n}",
      "path": "JodaTime/src/java/org/joda/time/tz/DateTimeZoneBuilder.java",
      "functionStartLine": 1378,
      "functionName": "create",
      "functionAnnotation": "",
      "functionDoc": "Factory to create instance from builder.\n\n@param id the zone id\n@param outputID true if the zone id should be output\n@param transitions the list of Transition objects\n@param tailZone optional zone for getting info beyond precalculated tables\n"
    }
  }
}