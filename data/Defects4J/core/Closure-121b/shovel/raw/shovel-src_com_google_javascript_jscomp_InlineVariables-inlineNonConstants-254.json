{
  "origin": "codeshovel",
  "repositoryName": "Closure-121b",
  "repositoryPath": "/tmp/Closure-121b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "InlineVariables.java",
  "functionName": "inlineNonConstants",
  "functionId": "$inlineNonConstants___v-Var__referenceInfo-ReferenceCollection__maybeModifiedArguments-boolean",
  "sourceFilePath": "src/com/google/javascript/jscomp/InlineVariables.java",
  "functionAnnotation": "",
  "functionDoc": "",
  "functionStartLine": 254,
  "functionEndLine": 323,
  "numCommitsSeen": 51,
  "timeTaken": 2304,
  "changeHistory": [
    "fb1ca6ab49d90553268b711edc805c47ceae5088",
    "ba0119710233a1be87c10c5e71424dc5922cc627",
    "00c6b6e0f0798db704b3e5fc4a0547bd90e55289",
    "d1df970451b5a18956448097b3afb43f3a82263d",
    "6e3eb4f7619179ba6c23db2af7549ef02f588c35",
    "efe3e7ff6349539bae7e2c36dc627129e268de30",
    "bca9abb0e3062d373fe52c0e8340337588c05708",
    "78995bf9e88599055a8c4165d89c09dc92a44b30",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3"
  ],
  "changeHistoryShort": {
    "fb1ca6ab49d90553268b711edc805c47ceae5088": "Ybodychange",
    "ba0119710233a1be87c10c5e71424dc5922cc627": "Ymultichange(Yparameterchange,Ybodychange)",
    "00c6b6e0f0798db704b3e5fc4a0547bd90e55289": "Ybodychange",
    "d1df970451b5a18956448097b3afb43f3a82263d": "Ybodychange",
    "6e3eb4f7619179ba6c23db2af7549ef02f588c35": "Ybodychange",
    "efe3e7ff6349539bae7e2c36dc627129e268de30": "Ybodychange",
    "bca9abb0e3062d373fe52c0e8340337588c05708": "Ybodychange",
    "78995bf9e88599055a8c4165d89c09dc92a44b30": "Ymultichange(Yparameterchange,Ybodychange)",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "fb1ca6ab49d90553268b711edc805c47ceae5088": {
      "type": "Ybodychange",
      "commitMessage": "\nCreate an inferface for references in the symbol table\n\nR\u003dacleung\nDELTA\u003d275  (214 added, 16 deleted, 45 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d2317\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1185 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "6/16/11, 11:12 AM",
      "commitName": "fb1ca6ab49d90553268b711edc805c47ceae5088",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "5/24/11, 10:36 AM",
      "commitNameOld": "75a9013e3907e5db97f10578227497d7b018caf5",
      "commitAuthorOld": "bashir@google.com",
      "daysBetweenCommits": 23.02,
      "commitsBetweenForRepo": 55,
      "commitsBetweenForFile": 1,
      "actualSource": "private void inlineNonConstants(Var v, ReferenceCollection referenceInfo, boolean maybeModifiedArguments) {\n    int refCount \u003d referenceInfo.references.size();\n    Reference declaration \u003d referenceInfo.references.get(0);\n    Reference init \u003d referenceInfo.getInitializingReference();\n    int firstRefAfterInit \u003d (declaration \u003d\u003d init) ? 2 : 3;\n    if (refCount \u003e 1 \u0026\u0026 isImmutableAndWellDefinedVariable(v, referenceInfo)) {\n        Node value;\n        if (init !\u003d null) {\n            value \u003d init.getAssignedValue();\n        } else {\n            Node srcLocation \u003d declaration.getNode();\n            value \u003d NodeUtil.newUndefinedNode(srcLocation);\n        }\n        Preconditions.checkNotNull(value);\n        inlineWellDefinedVariable(v, value, referenceInfo.references);\n        staleVars.add(v);\n    } else if (refCount \u003d\u003d firstRefAfterInit) {\n        Reference reference \u003d referenceInfo.references.get(firstRefAfterInit - 1);\n        if (canInline(declaration, init, reference)) {\n            inline(v, declaration, init, reference);\n            staleVars.add(v);\n        }\n    } else if (declaration !\u003d init \u0026\u0026 refCount \u003d\u003d 2) {\n        if (isValidDeclaration(declaration) \u0026\u0026 isValidInitialization(init)) {\n            Node value \u003d init.getAssignedValue();\n            Preconditions.checkNotNull(value);\n            inlineWellDefinedVariable(v, value, referenceInfo.references);\n            staleVars.add(v);\n        }\n    }\n    if (!maybeModifiedArguments \u0026\u0026 !staleVars.contains(v) \u0026\u0026 referenceInfo.isWellDefined() \u0026\u0026 referenceInfo.isAssignedOnceInLifetime()) {\n        List\u003cReference\u003e refs \u003d referenceInfo.references;\n        for (int i \u003d 1; i \u003c refs.size(); i++) {\n            Node nameNode \u003d refs.get(i).getNode();\n            if (aliasCandidates.containsKey(nameNode)) {\n                AliasCandidate candidate \u003d aliasCandidates.get(nameNode);\n                if (!staleVars.contains(candidate.alias) \u0026\u0026 !isVarInlineForbidden(candidate.alias)) {\n                    Reference aliasInit;\n                    aliasInit \u003d candidate.refInfo.getInitializingReference();\n                    Node value \u003d aliasInit.getAssignedValue();\n                    Preconditions.checkNotNull(value);\n                    inlineWellDefinedVariable(candidate.alias, value, candidate.refInfo.references);\n                    staleVars.add(candidate.alias);\n                }\n            }\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/InlineVariables.java",
      "functionStartLine": 256,
      "functionName": "inlineNonConstants",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,48 +1,48 @@\n private void inlineNonConstants(Var v, ReferenceCollection referenceInfo, boolean maybeModifiedArguments) {\n     int refCount \u003d referenceInfo.references.size();\n     Reference declaration \u003d referenceInfo.references.get(0);\n     Reference init \u003d referenceInfo.getInitializingReference();\n     int firstRefAfterInit \u003d (declaration \u003d\u003d init) ? 2 : 3;\n     if (refCount \u003e 1 \u0026\u0026 isImmutableAndWellDefinedVariable(v, referenceInfo)) {\n         Node value;\n         if (init !\u003d null) {\n             value \u003d init.getAssignedValue();\n         } else {\n-            Node srcLocation \u003d declaration.getNameNode();\n+            Node srcLocation \u003d declaration.getNode();\n             value \u003d NodeUtil.newUndefinedNode(srcLocation);\n         }\n         Preconditions.checkNotNull(value);\n         inlineWellDefinedVariable(v, value, referenceInfo.references);\n         staleVars.add(v);\n     } else if (refCount \u003d\u003d firstRefAfterInit) {\n         Reference reference \u003d referenceInfo.references.get(firstRefAfterInit - 1);\n         if (canInline(declaration, init, reference)) {\n             inline(v, declaration, init, reference);\n             staleVars.add(v);\n         }\n     } else if (declaration !\u003d init \u0026\u0026 refCount \u003d\u003d 2) {\n         if (isValidDeclaration(declaration) \u0026\u0026 isValidInitialization(init)) {\n             Node value \u003d init.getAssignedValue();\n             Preconditions.checkNotNull(value);\n             inlineWellDefinedVariable(v, value, referenceInfo.references);\n             staleVars.add(v);\n         }\n     }\n     if (!maybeModifiedArguments \u0026\u0026 !staleVars.contains(v) \u0026\u0026 referenceInfo.isWellDefined() \u0026\u0026 referenceInfo.isAssignedOnceInLifetime()) {\n         List\u003cReference\u003e refs \u003d referenceInfo.references;\n         for (int i \u003d 1; i \u003c refs.size(); i++) {\n-            Node nameNode \u003d refs.get(i).getNameNode();\n+            Node nameNode \u003d refs.get(i).getNode();\n             if (aliasCandidates.containsKey(nameNode)) {\n                 AliasCandidate candidate \u003d aliasCandidates.get(nameNode);\n                 if (!staleVars.contains(candidate.alias) \u0026\u0026 !isVarInlineForbidden(candidate.alias)) {\n                     Reference aliasInit;\n                     aliasInit \u003d candidate.refInfo.getInitializingReference();\n                     Node value \u003d aliasInit.getAssignedValue();\n                     Preconditions.checkNotNull(value);\n                     inlineWellDefinedVariable(candidate.alias, value, candidate.refInfo.references);\n                     staleVars.add(candidate.alias);\n                 }\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ba0119710233a1be87c10c5e71424dc5922cc627": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "\nDon\u0027t inline alias if \"arguments\" are modified or escaped.\nFixes issue 378\n\nR\u003dacleung\nDELTA\u003d235  (228 added, 0 deleted, 7 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d1089\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@942 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "3/25/11, 5:16 PM",
      "commitName": "ba0119710233a1be87c10c5e71424dc5922cc627",
      "commitAuthor": "johnlenz@google.com",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "\nDon\u0027t inline alias if \"arguments\" are modified or escaped.\nFixes issue 378\n\nR\u003dacleung\nDELTA\u003d235  (228 added, 0 deleted, 7 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d1089\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@942 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "3/25/11, 5:16 PM",
          "commitName": "ba0119710233a1be87c10c5e71424dc5922cc627",
          "commitAuthor": "johnlenz@google.com",
          "commitDateOld": "3/10/11, 5:33 PM",
          "commitNameOld": "00c6b6e0f0798db704b3e5fc4a0547bd90e55289",
          "commitAuthorOld": "nicksantos@google.com",
          "daysBetweenCommits": 14.95,
          "commitsBetweenForRepo": 57,
          "commitsBetweenForFile": 1,
          "actualSource": "private void inlineNonConstants(Var v, ReferenceCollection referenceInfo, boolean maybeModifiedArguments) {\n    int refCount \u003d referenceInfo.references.size();\n    Reference declaration \u003d referenceInfo.references.get(0);\n    Reference init \u003d referenceInfo.getInitializingReference();\n    int firstRefAfterInit \u003d (declaration \u003d\u003d init) ? 2 : 3;\n    if (refCount \u003e 1 \u0026\u0026 isImmutableAndWellDefinedVariable(v, referenceInfo)) {\n        Node value;\n        if (init !\u003d null) {\n            value \u003d init.getAssignedValue();\n        } else {\n            Node srcLocation \u003d declaration.getNameNode();\n            value \u003d NodeUtil.newUndefinedNode(srcLocation);\n        }\n        Preconditions.checkNotNull(value);\n        inlineWellDefinedVariable(v, value, referenceInfo.references);\n        staleVars.add(v);\n    } else if (refCount \u003d\u003d firstRefAfterInit) {\n        Reference reference \u003d referenceInfo.references.get(firstRefAfterInit - 1);\n        if (canInline(declaration, init, reference)) {\n            inline(v, declaration, init, reference);\n            staleVars.add(v);\n        }\n    } else if (declaration !\u003d init \u0026\u0026 refCount \u003d\u003d 2) {\n        if (isValidDeclaration(declaration) \u0026\u0026 isValidInitialization(init)) {\n            Node value \u003d init.getAssignedValue();\n            Preconditions.checkNotNull(value);\n            inlineWellDefinedVariable(v, value, referenceInfo.references);\n            staleVars.add(v);\n        }\n    }\n    if (!maybeModifiedArguments \u0026\u0026 !staleVars.contains(v) \u0026\u0026 referenceInfo.isWellDefined() \u0026\u0026 referenceInfo.isAssignedOnceInLifetime()) {\n        List\u003cReference\u003e refs \u003d referenceInfo.references;\n        for (int i \u003d 1; i \u003c refs.size(); i++) {\n            Node nameNode \u003d refs.get(i).getNameNode();\n            if (aliasCandidates.containsKey(nameNode)) {\n                AliasCandidate candidate \u003d aliasCandidates.get(nameNode);\n                if (!staleVars.contains(candidate.alias) \u0026\u0026 !isVarInlineForbidden(candidate.alias)) {\n                    Reference aliasInit;\n                    aliasInit \u003d candidate.refInfo.getInitializingReference();\n                    Node value \u003d aliasInit.getAssignedValue();\n                    Preconditions.checkNotNull(value);\n                    inlineWellDefinedVariable(candidate.alias, value, candidate.refInfo.references);\n                    staleVars.add(candidate.alias);\n                }\n            }\n        }\n    }\n}",
          "path": "src/com/google/javascript/jscomp/InlineVariables.java",
          "functionStartLine": 257,
          "functionName": "inlineNonConstants",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,48 +1,48 @@\n-private void inlineNonConstants(Var v, ReferenceCollection referenceInfo) {\n+private void inlineNonConstants(Var v, ReferenceCollection referenceInfo, boolean maybeModifiedArguments) {\n     int refCount \u003d referenceInfo.references.size();\n     Reference declaration \u003d referenceInfo.references.get(0);\n     Reference init \u003d referenceInfo.getInitializingReference();\n     int firstRefAfterInit \u003d (declaration \u003d\u003d init) ? 2 : 3;\n     if (refCount \u003e 1 \u0026\u0026 isImmutableAndWellDefinedVariable(v, referenceInfo)) {\n         Node value;\n         if (init !\u003d null) {\n             value \u003d init.getAssignedValue();\n         } else {\n             Node srcLocation \u003d declaration.getNameNode();\n             value \u003d NodeUtil.newUndefinedNode(srcLocation);\n         }\n         Preconditions.checkNotNull(value);\n         inlineWellDefinedVariable(v, value, referenceInfo.references);\n         staleVars.add(v);\n     } else if (refCount \u003d\u003d firstRefAfterInit) {\n         Reference reference \u003d referenceInfo.references.get(firstRefAfterInit - 1);\n         if (canInline(declaration, init, reference)) {\n             inline(v, declaration, init, reference);\n             staleVars.add(v);\n         }\n     } else if (declaration !\u003d init \u0026\u0026 refCount \u003d\u003d 2) {\n         if (isValidDeclaration(declaration) \u0026\u0026 isValidInitialization(init)) {\n             Node value \u003d init.getAssignedValue();\n             Preconditions.checkNotNull(value);\n             inlineWellDefinedVariable(v, value, referenceInfo.references);\n             staleVars.add(v);\n         }\n     }\n-    if (!staleVars.contains(v) \u0026\u0026 referenceInfo.isWellDefined() \u0026\u0026 referenceInfo.isAssignedOnceInLifetime()) {\n+    if (!maybeModifiedArguments \u0026\u0026 !staleVars.contains(v) \u0026\u0026 referenceInfo.isWellDefined() \u0026\u0026 referenceInfo.isAssignedOnceInLifetime()) {\n         List\u003cReference\u003e refs \u003d referenceInfo.references;\n         for (int i \u003d 1; i \u003c refs.size(); i++) {\n             Node nameNode \u003d refs.get(i).getNameNode();\n             if (aliasCandidates.containsKey(nameNode)) {\n                 AliasCandidate candidate \u003d aliasCandidates.get(nameNode);\n                 if (!staleVars.contains(candidate.alias) \u0026\u0026 !isVarInlineForbidden(candidate.alias)) {\n                     Reference aliasInit;\n                     aliasInit \u003d candidate.refInfo.getInitializingReference();\n                     Node value \u003d aliasInit.getAssignedValue();\n                     Preconditions.checkNotNull(value);\n                     inlineWellDefinedVariable(candidate.alias, value, candidate.refInfo.references);\n                     staleVars.add(candidate.alias);\n                 }\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[v-Var, referenceInfo-ReferenceCollection]",
            "newValue": "[v-Var, referenceInfo-ReferenceCollection, maybeModifiedArguments-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "\nDon\u0027t inline alias if \"arguments\" are modified or escaped.\nFixes issue 378\n\nR\u003dacleung\nDELTA\u003d235  (228 added, 0 deleted, 7 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d1089\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@942 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "3/25/11, 5:16 PM",
          "commitName": "ba0119710233a1be87c10c5e71424dc5922cc627",
          "commitAuthor": "johnlenz@google.com",
          "commitDateOld": "3/10/11, 5:33 PM",
          "commitNameOld": "00c6b6e0f0798db704b3e5fc4a0547bd90e55289",
          "commitAuthorOld": "nicksantos@google.com",
          "daysBetweenCommits": 14.95,
          "commitsBetweenForRepo": 57,
          "commitsBetweenForFile": 1,
          "actualSource": "private void inlineNonConstants(Var v, ReferenceCollection referenceInfo, boolean maybeModifiedArguments) {\n    int refCount \u003d referenceInfo.references.size();\n    Reference declaration \u003d referenceInfo.references.get(0);\n    Reference init \u003d referenceInfo.getInitializingReference();\n    int firstRefAfterInit \u003d (declaration \u003d\u003d init) ? 2 : 3;\n    if (refCount \u003e 1 \u0026\u0026 isImmutableAndWellDefinedVariable(v, referenceInfo)) {\n        Node value;\n        if (init !\u003d null) {\n            value \u003d init.getAssignedValue();\n        } else {\n            Node srcLocation \u003d declaration.getNameNode();\n            value \u003d NodeUtil.newUndefinedNode(srcLocation);\n        }\n        Preconditions.checkNotNull(value);\n        inlineWellDefinedVariable(v, value, referenceInfo.references);\n        staleVars.add(v);\n    } else if (refCount \u003d\u003d firstRefAfterInit) {\n        Reference reference \u003d referenceInfo.references.get(firstRefAfterInit - 1);\n        if (canInline(declaration, init, reference)) {\n            inline(v, declaration, init, reference);\n            staleVars.add(v);\n        }\n    } else if (declaration !\u003d init \u0026\u0026 refCount \u003d\u003d 2) {\n        if (isValidDeclaration(declaration) \u0026\u0026 isValidInitialization(init)) {\n            Node value \u003d init.getAssignedValue();\n            Preconditions.checkNotNull(value);\n            inlineWellDefinedVariable(v, value, referenceInfo.references);\n            staleVars.add(v);\n        }\n    }\n    if (!maybeModifiedArguments \u0026\u0026 !staleVars.contains(v) \u0026\u0026 referenceInfo.isWellDefined() \u0026\u0026 referenceInfo.isAssignedOnceInLifetime()) {\n        List\u003cReference\u003e refs \u003d referenceInfo.references;\n        for (int i \u003d 1; i \u003c refs.size(); i++) {\n            Node nameNode \u003d refs.get(i).getNameNode();\n            if (aliasCandidates.containsKey(nameNode)) {\n                AliasCandidate candidate \u003d aliasCandidates.get(nameNode);\n                if (!staleVars.contains(candidate.alias) \u0026\u0026 !isVarInlineForbidden(candidate.alias)) {\n                    Reference aliasInit;\n                    aliasInit \u003d candidate.refInfo.getInitializingReference();\n                    Node value \u003d aliasInit.getAssignedValue();\n                    Preconditions.checkNotNull(value);\n                    inlineWellDefinedVariable(candidate.alias, value, candidate.refInfo.references);\n                    staleVars.add(candidate.alias);\n                }\n            }\n        }\n    }\n}",
          "path": "src/com/google/javascript/jscomp/InlineVariables.java",
          "functionStartLine": 257,
          "functionName": "inlineNonConstants",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,48 +1,48 @@\n-private void inlineNonConstants(Var v, ReferenceCollection referenceInfo) {\n+private void inlineNonConstants(Var v, ReferenceCollection referenceInfo, boolean maybeModifiedArguments) {\n     int refCount \u003d referenceInfo.references.size();\n     Reference declaration \u003d referenceInfo.references.get(0);\n     Reference init \u003d referenceInfo.getInitializingReference();\n     int firstRefAfterInit \u003d (declaration \u003d\u003d init) ? 2 : 3;\n     if (refCount \u003e 1 \u0026\u0026 isImmutableAndWellDefinedVariable(v, referenceInfo)) {\n         Node value;\n         if (init !\u003d null) {\n             value \u003d init.getAssignedValue();\n         } else {\n             Node srcLocation \u003d declaration.getNameNode();\n             value \u003d NodeUtil.newUndefinedNode(srcLocation);\n         }\n         Preconditions.checkNotNull(value);\n         inlineWellDefinedVariable(v, value, referenceInfo.references);\n         staleVars.add(v);\n     } else if (refCount \u003d\u003d firstRefAfterInit) {\n         Reference reference \u003d referenceInfo.references.get(firstRefAfterInit - 1);\n         if (canInline(declaration, init, reference)) {\n             inline(v, declaration, init, reference);\n             staleVars.add(v);\n         }\n     } else if (declaration !\u003d init \u0026\u0026 refCount \u003d\u003d 2) {\n         if (isValidDeclaration(declaration) \u0026\u0026 isValidInitialization(init)) {\n             Node value \u003d init.getAssignedValue();\n             Preconditions.checkNotNull(value);\n             inlineWellDefinedVariable(v, value, referenceInfo.references);\n             staleVars.add(v);\n         }\n     }\n-    if (!staleVars.contains(v) \u0026\u0026 referenceInfo.isWellDefined() \u0026\u0026 referenceInfo.isAssignedOnceInLifetime()) {\n+    if (!maybeModifiedArguments \u0026\u0026 !staleVars.contains(v) \u0026\u0026 referenceInfo.isWellDefined() \u0026\u0026 referenceInfo.isAssignedOnceInLifetime()) {\n         List\u003cReference\u003e refs \u003d referenceInfo.references;\n         for (int i \u003d 1; i \u003c refs.size(); i++) {\n             Node nameNode \u003d refs.get(i).getNameNode();\n             if (aliasCandidates.containsKey(nameNode)) {\n                 AliasCandidate candidate \u003d aliasCandidates.get(nameNode);\n                 if (!staleVars.contains(candidate.alias) \u0026\u0026 !isVarInlineForbidden(candidate.alias)) {\n                     Reference aliasInit;\n                     aliasInit \u003d candidate.refInfo.getInitializingReference();\n                     Node value \u003d aliasInit.getAssignedValue();\n                     Preconditions.checkNotNull(value);\n                     inlineWellDefinedVariable(candidate.alias, value, candidate.refInfo.references);\n                     staleVars.add(candidate.alias);\n                 }\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "00c6b6e0f0798db704b3e5fc4a0547bd90e55289": {
      "type": "Ybodychange",
      "commitMessage": "\ndon\u0027t inline exported aliases.\n\nR\u003djohnlenz\nDELTA\u003d7  (6 added, 0 deleted, 1 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d824\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@877 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "3/10/11, 5:33 PM",
      "commitName": "00c6b6e0f0798db704b3e5fc4a0547bd90e55289",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "11/11/10, 9:42 PM",
      "commitNameOld": "df223efd38c514d584f00d076488ab9a02011492",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 118.83,
      "commitsBetweenForRepo": 319,
      "commitsBetweenForFile": 1,
      "actualSource": "private void inlineNonConstants(Var v, ReferenceCollection referenceInfo) {\n    int refCount \u003d referenceInfo.references.size();\n    Reference declaration \u003d referenceInfo.references.get(0);\n    Reference init \u003d referenceInfo.getInitializingReference();\n    int firstRefAfterInit \u003d (declaration \u003d\u003d init) ? 2 : 3;\n    if (refCount \u003e 1 \u0026\u0026 isImmutableAndWellDefinedVariable(v, referenceInfo)) {\n        Node value;\n        if (init !\u003d null) {\n            value \u003d init.getAssignedValue();\n        } else {\n            Node srcLocation \u003d declaration.getNameNode();\n            value \u003d NodeUtil.newUndefinedNode(srcLocation);\n        }\n        Preconditions.checkNotNull(value);\n        inlineWellDefinedVariable(v, value, referenceInfo.references);\n        staleVars.add(v);\n    } else if (refCount \u003d\u003d firstRefAfterInit) {\n        Reference reference \u003d referenceInfo.references.get(firstRefAfterInit - 1);\n        if (canInline(declaration, init, reference)) {\n            inline(v, declaration, init, reference);\n            staleVars.add(v);\n        }\n    } else if (declaration !\u003d init \u0026\u0026 refCount \u003d\u003d 2) {\n        if (isValidDeclaration(declaration) \u0026\u0026 isValidInitialization(init)) {\n            Node value \u003d init.getAssignedValue();\n            Preconditions.checkNotNull(value);\n            inlineWellDefinedVariable(v, value, referenceInfo.references);\n            staleVars.add(v);\n        }\n    }\n    if (!staleVars.contains(v) \u0026\u0026 referenceInfo.isWellDefined() \u0026\u0026 referenceInfo.isAssignedOnceInLifetime()) {\n        List\u003cReference\u003e refs \u003d referenceInfo.references;\n        for (int i \u003d 1; i \u003c refs.size(); i++) {\n            Node nameNode \u003d refs.get(i).getNameNode();\n            if (aliasCandidates.containsKey(nameNode)) {\n                AliasCandidate candidate \u003d aliasCandidates.get(nameNode);\n                if (!staleVars.contains(candidate.alias) \u0026\u0026 !isVarInlineForbidden(candidate.alias)) {\n                    Reference aliasInit;\n                    aliasInit \u003d candidate.refInfo.getInitializingReference();\n                    Node value \u003d aliasInit.getAssignedValue();\n                    Preconditions.checkNotNull(value);\n                    inlineWellDefinedVariable(candidate.alias, value, candidate.refInfo.references);\n                    staleVars.add(candidate.alias);\n                }\n            }\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/InlineVariables.java",
      "functionStartLine": 225,
      "functionName": "inlineNonConstants",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,48 +1,48 @@\n private void inlineNonConstants(Var v, ReferenceCollection referenceInfo) {\n     int refCount \u003d referenceInfo.references.size();\n     Reference declaration \u003d referenceInfo.references.get(0);\n     Reference init \u003d referenceInfo.getInitializingReference();\n     int firstRefAfterInit \u003d (declaration \u003d\u003d init) ? 2 : 3;\n     if (refCount \u003e 1 \u0026\u0026 isImmutableAndWellDefinedVariable(v, referenceInfo)) {\n         Node value;\n         if (init !\u003d null) {\n             value \u003d init.getAssignedValue();\n         } else {\n             Node srcLocation \u003d declaration.getNameNode();\n             value \u003d NodeUtil.newUndefinedNode(srcLocation);\n         }\n         Preconditions.checkNotNull(value);\n         inlineWellDefinedVariable(v, value, referenceInfo.references);\n         staleVars.add(v);\n     } else if (refCount \u003d\u003d firstRefAfterInit) {\n         Reference reference \u003d referenceInfo.references.get(firstRefAfterInit - 1);\n         if (canInline(declaration, init, reference)) {\n             inline(v, declaration, init, reference);\n             staleVars.add(v);\n         }\n     } else if (declaration !\u003d init \u0026\u0026 refCount \u003d\u003d 2) {\n         if (isValidDeclaration(declaration) \u0026\u0026 isValidInitialization(init)) {\n             Node value \u003d init.getAssignedValue();\n             Preconditions.checkNotNull(value);\n             inlineWellDefinedVariable(v, value, referenceInfo.references);\n             staleVars.add(v);\n         }\n     }\n     if (!staleVars.contains(v) \u0026\u0026 referenceInfo.isWellDefined() \u0026\u0026 referenceInfo.isAssignedOnceInLifetime()) {\n         List\u003cReference\u003e refs \u003d referenceInfo.references;\n         for (int i \u003d 1; i \u003c refs.size(); i++) {\n             Node nameNode \u003d refs.get(i).getNameNode();\n             if (aliasCandidates.containsKey(nameNode)) {\n                 AliasCandidate candidate \u003d aliasCandidates.get(nameNode);\n-                if (!staleVars.contains(candidate.alias)) {\n+                if (!staleVars.contains(candidate.alias) \u0026\u0026 !isVarInlineForbidden(candidate.alias)) {\n                     Reference aliasInit;\n                     aliasInit \u003d candidate.refInfo.getInitializingReference();\n                     Node value \u003d aliasInit.getAssignedValue();\n                     Preconditions.checkNotNull(value);\n                     inlineWellDefinedVariable(candidate.alias, value, candidate.refInfo.references);\n                     staleVars.add(candidate.alias);\n                 }\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d1df970451b5a18956448097b3afb43f3a82263d": {
      "type": "Ybodychange",
      "commitMessage": "\n\nChange on 2010/06/09 by nicksantos\n\n        be clear that \"assigned once\" means \"assigned once in lifetime\"\n        fixes issue 174.\n\n        R\u003djohnlenz\n        DELTA\u003d125  (113 added, 0 deleted, 12 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d26002\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@241 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "6/10/10, 1:12 PM",
      "commitName": "d1df970451b5a18956448097b3afb43f3a82263d",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "4/23/10, 11:31 AM",
      "commitNameOld": "ebb59a97610015bc41bda7f458dd1428a3a3e335",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 48.07,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "actualSource": "private void inlineNonConstants(Var v, ReferenceCollection referenceInfo) {\n    int refCount \u003d referenceInfo.references.size();\n    Reference declaration \u003d referenceInfo.references.get(0);\n    Reference init \u003d referenceInfo.getInitializingReference();\n    int firstRefAfterInit \u003d (declaration \u003d\u003d init) ? 2 : 3;\n    if (refCount \u003e 1 \u0026\u0026 isImmutableAndWellDefinedVariable(v, referenceInfo)) {\n        Node value;\n        if (init !\u003d null) {\n            value \u003d init.getAssignedValue();\n        } else {\n            Node srcLocation \u003d declaration.getNameNode();\n            value \u003d NodeUtil.newUndefinedNode(srcLocation);\n        }\n        Preconditions.checkNotNull(value);\n        inlineWellDefinedVariable(v, value, referenceInfo.references);\n        staleVars.add(v);\n    } else if (refCount \u003d\u003d firstRefAfterInit) {\n        Reference reference \u003d referenceInfo.references.get(firstRefAfterInit - 1);\n        if (canInline(declaration, init, reference)) {\n            inline(v, declaration, init, reference);\n            staleVars.add(v);\n        }\n    } else if (declaration !\u003d init \u0026\u0026 refCount \u003d\u003d 2) {\n        if (isValidDeclaration(declaration) \u0026\u0026 isValidInitialization(init)) {\n            Node value \u003d init.getAssignedValue();\n            Preconditions.checkNotNull(value);\n            inlineWellDefinedVariable(v, value, referenceInfo.references);\n            staleVars.add(v);\n        }\n    }\n    if (!staleVars.contains(v) \u0026\u0026 referenceInfo.isWellDefined() \u0026\u0026 referenceInfo.isAssignedOnceInLifetime()) {\n        List\u003cReference\u003e refs \u003d referenceInfo.references;\n        for (int i \u003d 1; i \u003c refs.size(); i++) {\n            Node nameNode \u003d refs.get(i).getNameNode();\n            if (aliasCandidates.containsKey(nameNode)) {\n                AliasCandidate candidate \u003d aliasCandidates.get(nameNode);\n                if (!staleVars.contains(candidate.alias)) {\n                    Reference aliasInit;\n                    aliasInit \u003d candidate.refInfo.getInitializingReference();\n                    Node value \u003d aliasInit.getAssignedValue();\n                    Preconditions.checkNotNull(value);\n                    inlineWellDefinedVariable(candidate.alias, value, candidate.refInfo.references);\n                    staleVars.add(candidate.alias);\n                }\n            }\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/InlineVariables.java",
      "functionStartLine": 226,
      "functionName": "inlineNonConstants",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,48 +1,48 @@\n private void inlineNonConstants(Var v, ReferenceCollection referenceInfo) {\n     int refCount \u003d referenceInfo.references.size();\n     Reference declaration \u003d referenceInfo.references.get(0);\n     Reference init \u003d referenceInfo.getInitializingReference();\n     int firstRefAfterInit \u003d (declaration \u003d\u003d init) ? 2 : 3;\n     if (refCount \u003e 1 \u0026\u0026 isImmutableAndWellDefinedVariable(v, referenceInfo)) {\n         Node value;\n         if (init !\u003d null) {\n             value \u003d init.getAssignedValue();\n         } else {\n             Node srcLocation \u003d declaration.getNameNode();\n             value \u003d NodeUtil.newUndefinedNode(srcLocation);\n         }\n         Preconditions.checkNotNull(value);\n         inlineWellDefinedVariable(v, value, referenceInfo.references);\n         staleVars.add(v);\n     } else if (refCount \u003d\u003d firstRefAfterInit) {\n         Reference reference \u003d referenceInfo.references.get(firstRefAfterInit - 1);\n         if (canInline(declaration, init, reference)) {\n             inline(v, declaration, init, reference);\n             staleVars.add(v);\n         }\n     } else if (declaration !\u003d init \u0026\u0026 refCount \u003d\u003d 2) {\n         if (isValidDeclaration(declaration) \u0026\u0026 isValidInitialization(init)) {\n             Node value \u003d init.getAssignedValue();\n             Preconditions.checkNotNull(value);\n             inlineWellDefinedVariable(v, value, referenceInfo.references);\n             staleVars.add(v);\n         }\n     }\n-    if (!staleVars.contains(v) \u0026\u0026 referenceInfo.isWellDefined() \u0026\u0026 referenceInfo.isAssignedOnce()) {\n+    if (!staleVars.contains(v) \u0026\u0026 referenceInfo.isWellDefined() \u0026\u0026 referenceInfo.isAssignedOnceInLifetime()) {\n         List\u003cReference\u003e refs \u003d referenceInfo.references;\n         for (int i \u003d 1; i \u003c refs.size(); i++) {\n             Node nameNode \u003d refs.get(i).getNameNode();\n             if (aliasCandidates.containsKey(nameNode)) {\n                 AliasCandidate candidate \u003d aliasCandidates.get(nameNode);\n                 if (!staleVars.contains(candidate.alias)) {\n                     Reference aliasInit;\n                     aliasInit \u003d candidate.refInfo.getInitializingReference();\n                     Node value \u003d aliasInit.getAssignedValue();\n                     Preconditions.checkNotNull(value);\n                     inlineWellDefinedVariable(candidate.alias, value, candidate.refInfo.references);\n                     staleVars.add(candidate.alias);\n                 }\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6e3eb4f7619179ba6c23db2af7549ef02f588c35": {
      "type": "Ybodychange",
      "commitMessage": "\nChange on 2010/04/15 by john\n\n        Maintain source information in OverloadedMethodResolution.\n\n        R\u003dandrew\n        DELTA\u003d8  (5 added, 1 deleted, 2 changed)\n\nChange on 2010/04/15 by john\n\n        Maintain source information during function inlining.\n\n        R\u003dalan\n        DELTA\u003d104  (73 added, 2 deleted, 29 changed)\n\nChange on 2010/04/15 by john\n\n        Improve LineNumberCheck error message.\n\n        R\u003dnick\n        DELTA\u003d4  (3 added, 0 deleted, 1 changed)\n\nChange on 2010/04/15 by john\n\n        Maintain source information in smart name removal.\n        Enabled Normalize during tests, simplified VAR handling.\n\n        R\u003dantonio\n        DELTA\u003d71  (12 added, 48 deleted, 11 changed)\n\nChange on 2010/04/15 by john\n\n        Maintain source information in InlineGetters.\n\n        R\u003dalan\n        DELTA\u003d8  (7 added, 0 deleted, 1 changed)\n\nChange on 2010/04/15 by alan\n\n        Stops the post data from printing multiple times.\n\n        R\u003djohn\n        DELTA\u003d4  (1 added, 0 deleted, 3 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003dhuwaud\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@188 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/16/10, 10:20 AM",
      "commitName": "6e3eb4f7619179ba6c23db2af7549ef02f588c35",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "4/15/10, 8:29 AM",
      "commitNameOld": "efe3e7ff6349539bae7e2c36dc627129e268de30",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 1.08,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "private void inlineNonConstants(Var v, ReferenceCollection referenceInfo) {\n    int refCount \u003d referenceInfo.references.size();\n    Reference declaration \u003d referenceInfo.references.get(0);\n    Reference init \u003d referenceInfo.getInitializingReference();\n    int firstRefAfterInit \u003d (declaration \u003d\u003d init) ? 2 : 3;\n    if (refCount \u003e 1 \u0026\u0026 isImmutableAndWellDefinedVariable(v, referenceInfo)) {\n        Node value;\n        if (init !\u003d null) {\n            value \u003d init.getAssignedValue();\n        } else {\n            Node srcLocation \u003d declaration.getNameNode();\n            value \u003d NodeUtil.newUndefinedNode(srcLocation);\n        }\n        Preconditions.checkNotNull(value);\n        inlineWellDefinedVariable(v, value, referenceInfo.references);\n        staleVars.add(v);\n    } else if (refCount \u003d\u003d firstRefAfterInit) {\n        Reference reference \u003d referenceInfo.references.get(firstRefAfterInit - 1);\n        if (canInline(declaration, init, reference)) {\n            inline(v, declaration, init, reference);\n            staleVars.add(v);\n        }\n    } else if (declaration !\u003d init \u0026\u0026 refCount \u003d\u003d 2) {\n        if (isValidDeclaration(declaration) \u0026\u0026 isValidInitialization(init)) {\n            Node value \u003d init.getAssignedValue();\n            Preconditions.checkNotNull(value);\n            inlineWellDefinedVariable(v, value, referenceInfo.references);\n            staleVars.add(v);\n        }\n    }\n    if (!staleVars.contains(v) \u0026\u0026 referenceInfo.isWellDefined() \u0026\u0026 referenceInfo.isAssignedOnce()) {\n        List\u003cReference\u003e refs \u003d referenceInfo.references;\n        for (int i \u003d 1; i \u003c refs.size(); i++) {\n            Node nameNode \u003d refs.get(i).getNameNode();\n            if (aliasCandidates.containsKey(nameNode)) {\n                AliasCandidate candidate \u003d aliasCandidates.get(nameNode);\n                if (!staleVars.contains(candidate.alias)) {\n                    Reference aliasInit;\n                    aliasInit \u003d candidate.refInfo.getInitializingReference();\n                    Node value \u003d aliasInit.getAssignedValue();\n                    Preconditions.checkNotNull(value);\n                    inlineWellDefinedVariable(candidate.alias, value, candidate.refInfo.references);\n                    staleVars.add(candidate.alias);\n                }\n            }\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/InlineVariables.java",
      "functionStartLine": 226,
      "functionName": "inlineNonConstants",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,47 +1,48 @@\n private void inlineNonConstants(Var v, ReferenceCollection referenceInfo) {\n     int refCount \u003d referenceInfo.references.size();\n     Reference declaration \u003d referenceInfo.references.get(0);\n     Reference init \u003d referenceInfo.getInitializingReference();\n     int firstRefAfterInit \u003d (declaration \u003d\u003d init) ? 2 : 3;\n     if (refCount \u003e 1 \u0026\u0026 isImmutableAndWellDefinedVariable(v, referenceInfo)) {\n         Node value;\n         if (init !\u003d null) {\n             value \u003d init.getAssignedValue();\n         } else {\n-            value \u003d NodeUtil.newUndefinedNode().copyInformationFromForTree(declaration.getNameNode());\n+            Node srcLocation \u003d declaration.getNameNode();\n+            value \u003d NodeUtil.newUndefinedNode(srcLocation);\n         }\n         Preconditions.checkNotNull(value);\n         inlineWellDefinedVariable(v, value, referenceInfo.references);\n         staleVars.add(v);\n     } else if (refCount \u003d\u003d firstRefAfterInit) {\n         Reference reference \u003d referenceInfo.references.get(firstRefAfterInit - 1);\n         if (canInline(declaration, init, reference)) {\n             inline(v, declaration, init, reference);\n             staleVars.add(v);\n         }\n     } else if (declaration !\u003d init \u0026\u0026 refCount \u003d\u003d 2) {\n         if (isValidDeclaration(declaration) \u0026\u0026 isValidInitialization(init)) {\n             Node value \u003d init.getAssignedValue();\n             Preconditions.checkNotNull(value);\n             inlineWellDefinedVariable(v, value, referenceInfo.references);\n             staleVars.add(v);\n         }\n     }\n     if (!staleVars.contains(v) \u0026\u0026 referenceInfo.isWellDefined() \u0026\u0026 referenceInfo.isAssignedOnce()) {\n         List\u003cReference\u003e refs \u003d referenceInfo.references;\n         for (int i \u003d 1; i \u003c refs.size(); i++) {\n             Node nameNode \u003d refs.get(i).getNameNode();\n             if (aliasCandidates.containsKey(nameNode)) {\n                 AliasCandidate candidate \u003d aliasCandidates.get(nameNode);\n                 if (!staleVars.contains(candidate.alias)) {\n                     Reference aliasInit;\n                     aliasInit \u003d candidate.refInfo.getInitializingReference();\n                     Node value \u003d aliasInit.getAssignedValue();\n                     Preconditions.checkNotNull(value);\n                     inlineWellDefinedVariable(candidate.alias, value, candidate.refInfo.references);\n                     staleVars.add(candidate.alias);\n                 }\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "efe3e7ff6349539bae7e2c36dc627129e268de30": {
      "type": "Ybodychange",
      "commitMessage": "\nChange on 2010/04/14 by john\n\n        Remove redundant function.\n\n        R\u003drobert\n        DELTA\u003d20  (0 added, 18 deleted, 2 changed)\n\nChange on 2010/04/14 by john\n\n        Maintain source information in InlineVariables.\n\n        R\u003dalan\n        DELTA\u003d10  (7 added, 1 deleted, 2 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003dvjrbog\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@185 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/15/10, 8:29 AM",
      "commitName": "efe3e7ff6349539bae7e2c36dc627129e268de30",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "3/25/10, 1:21 PM",
      "commitNameOld": "40ab7fc97ed52e3a1c1235ee20f97c10e39d6390",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 20.8,
      "commitsBetweenForRepo": 28,
      "commitsBetweenForFile": 1,
      "actualSource": "private void inlineNonConstants(Var v, ReferenceCollection referenceInfo) {\n    int refCount \u003d referenceInfo.references.size();\n    Reference declaration \u003d referenceInfo.references.get(0);\n    Reference init \u003d referenceInfo.getInitializingReference();\n    int firstRefAfterInit \u003d (declaration \u003d\u003d init) ? 2 : 3;\n    if (refCount \u003e 1 \u0026\u0026 isImmutableAndWellDefinedVariable(v, referenceInfo)) {\n        Node value;\n        if (init !\u003d null) {\n            value \u003d init.getAssignedValue();\n        } else {\n            value \u003d NodeUtil.newUndefinedNode().copyInformationFromForTree(declaration.getNameNode());\n        }\n        Preconditions.checkNotNull(value);\n        inlineWellDefinedVariable(v, value, referenceInfo.references);\n        staleVars.add(v);\n    } else if (refCount \u003d\u003d firstRefAfterInit) {\n        Reference reference \u003d referenceInfo.references.get(firstRefAfterInit - 1);\n        if (canInline(declaration, init, reference)) {\n            inline(v, declaration, init, reference);\n            staleVars.add(v);\n        }\n    } else if (declaration !\u003d init \u0026\u0026 refCount \u003d\u003d 2) {\n        if (isValidDeclaration(declaration) \u0026\u0026 isValidInitialization(init)) {\n            Node value \u003d init.getAssignedValue();\n            Preconditions.checkNotNull(value);\n            inlineWellDefinedVariable(v, value, referenceInfo.references);\n            staleVars.add(v);\n        }\n    }\n    if (!staleVars.contains(v) \u0026\u0026 referenceInfo.isWellDefined() \u0026\u0026 referenceInfo.isAssignedOnce()) {\n        List\u003cReference\u003e refs \u003d referenceInfo.references;\n        for (int i \u003d 1; i \u003c refs.size(); i++) {\n            Node nameNode \u003d refs.get(i).getNameNode();\n            if (aliasCandidates.containsKey(nameNode)) {\n                AliasCandidate candidate \u003d aliasCandidates.get(nameNode);\n                if (!staleVars.contains(candidate.alias)) {\n                    Reference aliasInit;\n                    aliasInit \u003d candidate.refInfo.getInitializingReference();\n                    Node value \u003d aliasInit.getAssignedValue();\n                    Preconditions.checkNotNull(value);\n                    inlineWellDefinedVariable(candidate.alias, value, candidate.refInfo.references);\n                    staleVars.add(candidate.alias);\n                }\n            }\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/InlineVariables.java",
      "functionStartLine": 226,
      "functionName": "inlineNonConstants",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,47 +1,47 @@\n private void inlineNonConstants(Var v, ReferenceCollection referenceInfo) {\n     int refCount \u003d referenceInfo.references.size();\n     Reference declaration \u003d referenceInfo.references.get(0);\n     Reference init \u003d referenceInfo.getInitializingReference();\n     int firstRefAfterInit \u003d (declaration \u003d\u003d init) ? 2 : 3;\n     if (refCount \u003e 1 \u0026\u0026 isImmutableAndWellDefinedVariable(v, referenceInfo)) {\n         Node value;\n         if (init !\u003d null) {\n             value \u003d init.getAssignedValue();\n         } else {\n-            value \u003d NodeUtil.newUndefinedNode();\n+            value \u003d NodeUtil.newUndefinedNode().copyInformationFromForTree(declaration.getNameNode());\n         }\n         Preconditions.checkNotNull(value);\n         inlineWellDefinedVariable(v, value, referenceInfo.references);\n         staleVars.add(v);\n     } else if (refCount \u003d\u003d firstRefAfterInit) {\n         Reference reference \u003d referenceInfo.references.get(firstRefAfterInit - 1);\n         if (canInline(declaration, init, reference)) {\n             inline(v, declaration, init, reference);\n             staleVars.add(v);\n         }\n     } else if (declaration !\u003d init \u0026\u0026 refCount \u003d\u003d 2) {\n         if (isValidDeclaration(declaration) \u0026\u0026 isValidInitialization(init)) {\n             Node value \u003d init.getAssignedValue();\n             Preconditions.checkNotNull(value);\n             inlineWellDefinedVariable(v, value, referenceInfo.references);\n             staleVars.add(v);\n         }\n     }\n     if (!staleVars.contains(v) \u0026\u0026 referenceInfo.isWellDefined() \u0026\u0026 referenceInfo.isAssignedOnce()) {\n         List\u003cReference\u003e refs \u003d referenceInfo.references;\n         for (int i \u003d 1; i \u003c refs.size(); i++) {\n             Node nameNode \u003d refs.get(i).getNameNode();\n             if (aliasCandidates.containsKey(nameNode)) {\n                 AliasCandidate candidate \u003d aliasCandidates.get(nameNode);\n                 if (!staleVars.contains(candidate.alias)) {\n                     Reference aliasInit;\n                     aliasInit \u003d candidate.refInfo.getInitializingReference();\n                     Node value \u003d aliasInit.getAssignedValue();\n                     Preconditions.checkNotNull(value);\n                     inlineWellDefinedVariable(candidate.alias, value, candidate.refInfo.references);\n                     staleVars.add(candidate.alias);\n                 }\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "bca9abb0e3062d373fe52c0e8340337588c05708": {
      "type": "Ybodychange",
      "commitMessage": "Make sure that InlineVariables can inline variables that are never defined.\n\nCreate a function-inlining blacklist.\n\nSome minor type inference fixes.\n\nStart re-architecting type resolution to happen differently.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@77 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "1/26/10, 1:59 PM",
      "commitName": "bca9abb0e3062d373fe52c0e8340337588c05708",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "11/25/09, 6:53 AM",
      "commitNameOld": "3bee5d740c96572faea4b9fb8b632e0e07b13cbb",
      "commitAuthorOld": "nicholas.j.santos@gmail.com",
      "daysBetweenCommits": 62.3,
      "commitsBetweenForRepo": 41,
      "commitsBetweenForFile": 1,
      "actualSource": "private void inlineNonConstants(Var v, ReferenceCollection referenceInfo) {\n    int refCount \u003d referenceInfo.references.size();\n    Reference declaration \u003d referenceInfo.references.get(0);\n    Reference init \u003d referenceInfo.getInitializingReference();\n    int firstRefAfterInit \u003d (declaration \u003d\u003d init) ? 2 : 3;\n    if (refCount \u003e 1 \u0026\u0026 isImmutableAndWellDefinedVariable(v, referenceInfo)) {\n        Node value;\n        if (init !\u003d null) {\n            value \u003d init.getAssignedValue();\n        } else {\n            value \u003d NodeUtil.newUndefinedNode();\n        }\n        Preconditions.checkNotNull(value);\n        inlineWellDefinedVariable(v, value, referenceInfo.references);\n        staleVars.add(v);\n    } else if (refCount \u003d\u003d firstRefAfterInit) {\n        Reference reference \u003d referenceInfo.references.get(firstRefAfterInit - 1);\n        if (canInline(declaration, init, reference)) {\n            inline(v, declaration, init, reference);\n            staleVars.add(v);\n        }\n    } else if (declaration !\u003d init \u0026\u0026 refCount \u003d\u003d 2) {\n        if (isValidDeclaration(declaration) \u0026\u0026 isValidInitialization(init)) {\n            Node value \u003d init.getAssignedValue();\n            Preconditions.checkNotNull(value);\n            inlineWellDefinedVariable(v, value, referenceInfo.references);\n            staleVars.add(v);\n        }\n    }\n    if (!staleVars.contains(v) \u0026\u0026 referenceInfo.isWellDefined() \u0026\u0026 referenceInfo.isAssignedOnce()) {\n        List\u003cReference\u003e refs \u003d referenceInfo.references;\n        for (int i \u003d 1; i \u003c refs.size(); i++) {\n            Node nameNode \u003d refs.get(i).getNameNode();\n            if (aliasCandidates.containsKey(nameNode)) {\n                AliasCandidate candidate \u003d aliasCandidates.get(nameNode);\n                if (!staleVars.contains(candidate.alias)) {\n                    Reference aliasInit;\n                    aliasInit \u003d candidate.refInfo.getInitializingReference();\n                    Node value \u003d aliasInit.getAssignedValue();\n                    Preconditions.checkNotNull(value);\n                    inlineWellDefinedVariable(candidate.alias, value, candidate.refInfo.references);\n                    staleVars.add(candidate.alias);\n                }\n            }\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/InlineVariables.java",
      "functionStartLine": 225,
      "functionName": "inlineNonConstants",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,42 +1,47 @@\n private void inlineNonConstants(Var v, ReferenceCollection referenceInfo) {\n     int refCount \u003d referenceInfo.references.size();\n     Reference declaration \u003d referenceInfo.references.get(0);\n     Reference init \u003d referenceInfo.getInitializingReference();\n     int firstRefAfterInit \u003d (declaration \u003d\u003d init) ? 2 : 3;\n     if (refCount \u003e 1 \u0026\u0026 isImmutableAndWellDefinedVariable(v, referenceInfo)) {\n-        Node value \u003d init.getAssignedValue();\n+        Node value;\n+        if (init !\u003d null) {\n+            value \u003d init.getAssignedValue();\n+        } else {\n+            value \u003d NodeUtil.newUndefinedNode();\n+        }\n         Preconditions.checkNotNull(value);\n         inlineWellDefinedVariable(v, value, referenceInfo.references);\n         staleVars.add(v);\n     } else if (refCount \u003d\u003d firstRefAfterInit) {\n         Reference reference \u003d referenceInfo.references.get(firstRefAfterInit - 1);\n         if (canInline(declaration, init, reference)) {\n             inline(v, declaration, init, reference);\n             staleVars.add(v);\n         }\n     } else if (declaration !\u003d init \u0026\u0026 refCount \u003d\u003d 2) {\n         if (isValidDeclaration(declaration) \u0026\u0026 isValidInitialization(init)) {\n             Node value \u003d init.getAssignedValue();\n             Preconditions.checkNotNull(value);\n             inlineWellDefinedVariable(v, value, referenceInfo.references);\n             staleVars.add(v);\n         }\n     }\n     if (!staleVars.contains(v) \u0026\u0026 referenceInfo.isWellDefined() \u0026\u0026 referenceInfo.isAssignedOnce()) {\n         List\u003cReference\u003e refs \u003d referenceInfo.references;\n         for (int i \u003d 1; i \u003c refs.size(); i++) {\n             Node nameNode \u003d refs.get(i).getNameNode();\n             if (aliasCandidates.containsKey(nameNode)) {\n                 AliasCandidate candidate \u003d aliasCandidates.get(nameNode);\n                 if (!staleVars.contains(candidate.alias)) {\n                     Reference aliasInit;\n                     aliasInit \u003d candidate.refInfo.getInitializingReference();\n                     Node value \u003d aliasInit.getAssignedValue();\n                     Preconditions.checkNotNull(value);\n                     inlineWellDefinedVariable(candidate.alias, value, candidate.refInfo.references);\n                     staleVars.add(candidate.alias);\n                 }\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "78995bf9e88599055a8c4165d89c09dc92a44b30": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Fix synthesis of vars in DEFAULT mode.\nBetter variable inlining\nBetter function inlining\nAssorted bug fixes\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@6 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/10/09, 11:16 AM",
      "commitName": "78995bf9e88599055a8c4165d89c09dc92a44b30",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Fix synthesis of vars in DEFAULT mode.\nBetter variable inlining\nBetter function inlining\nAssorted bug fixes\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@6 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "11/10/09, 11:16 AM",
          "commitName": "78995bf9e88599055a8c4165d89c09dc92a44b30",
          "commitAuthor": "nicholas.j.santos@gmail.com",
          "commitDateOld": "11/6/09, 5:24 PM",
          "commitNameOld": "0b7eccf2fd3a9293d7b513fbb766d7bc06abd7e0",
          "commitAuthorOld": "nicholas.j.santos@gmail.com",
          "daysBetweenCommits": 3.74,
          "commitsBetweenForRepo": 3,
          "commitsBetweenForFile": 1,
          "actualSource": "private void inlineNonConstants(Var v, ReferenceCollection referenceInfo) {\n    int refCount \u003d referenceInfo.references.size();\n    Reference declaration \u003d referenceInfo.references.get(0);\n    Reference init \u003d referenceInfo.getInitializingReference();\n    int firstRefAfterInit \u003d (declaration \u003d\u003d init) ? 2 : 3;\n    if (refCount \u003e 1 \u0026\u0026 isImmutableAndWellDefinedVariable(v, referenceInfo)) {\n        Node value \u003d init.getAssignedValue();\n        Preconditions.checkNotNull(value);\n        inlineWellDefinedVariable(v, value, referenceInfo.references);\n        staleVars.add(v);\n    } else if (refCount \u003d\u003d firstRefAfterInit) {\n        Reference reference \u003d referenceInfo.references.get(firstRefAfterInit - 1);\n        if (canInline(declaration, init, reference)) {\n            inline(v, declaration, init, reference);\n            staleVars.add(v);\n        }\n    } else if (declaration !\u003d init \u0026\u0026 refCount \u003d\u003d 2) {\n        if (isValidDeclaration(declaration) \u0026\u0026 isValidInitialization(init)) {\n            Node value \u003d init.getAssignedValue();\n            Preconditions.checkNotNull(value);\n            inlineWellDefinedVariable(v, value, referenceInfo.references);\n            staleVars.add(v);\n        }\n    }\n    if (!staleVars.contains(v) \u0026\u0026 referenceInfo.isWellDefined() \u0026\u0026 referenceInfo.isAssignedOnce()) {\n        List\u003cReference\u003e refs \u003d referenceInfo.references;\n        for (int i \u003d 1; i \u003c refs.size(); i++) {\n            Node nameNode \u003d refs.get(i).getNameNode();\n            if (aliasCandidates.containsKey(nameNode)) {\n                AliasCandidate candidate \u003d aliasCandidates.get(nameNode);\n                if (!staleVars.contains(candidate.alias)) {\n                    Reference aliasInit;\n                    aliasInit \u003d candidate.refInfo.getInitializingReference();\n                    Node value \u003d aliasInit.getAssignedValue();\n                    Preconditions.checkNotNull(value);\n                    inlineWellDefinedVariable(candidate.alias, value, candidate.refInfo.references);\n                    staleVars.add(candidate.alias);\n                }\n            }\n        }\n    }\n}",
          "path": "src/com/google/javascript/jscomp/InlineVariables.java",
          "functionStartLine": 196,
          "functionName": "inlineNonConstants",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,27 +1,42 @@\n-private void inlineNonConstants(Scope scope, Var v, ReferenceCollection referenceInfo) {\n-    if (referenceInfo.references.size() \u003e\u003d 2 \u0026\u0026 isImmutableAndWellDefinedVariable(v, referenceInfo)) {\n-        inlineWellDefinedVariable(v, referenceInfo.references);\n+private void inlineNonConstants(Var v, ReferenceCollection referenceInfo) {\n+    int refCount \u003d referenceInfo.references.size();\n+    Reference declaration \u003d referenceInfo.references.get(0);\n+    Reference init \u003d referenceInfo.getInitializingReference();\n+    int firstRefAfterInit \u003d (declaration \u003d\u003d init) ? 2 : 3;\n+    if (refCount \u003e 1 \u0026\u0026 isImmutableAndWellDefinedVariable(v, referenceInfo)) {\n+        Node value \u003d init.getAssignedValue();\n+        Preconditions.checkNotNull(value);\n+        inlineWellDefinedVariable(v, value, referenceInfo.references);\n         staleVars.add(v);\n-    } else if (referenceInfo.references.size() \u003d\u003d 2) {\n-        Reference declaration \u003d referenceInfo.references.get(0);\n-        Reference reference \u003d referenceInfo.references.get(1);\n-        if (canInline(declaration, reference)) {\n-            blacklistVarReferencesInTree(declaration.getNameNode().getFirstChild(), scope);\n-            inline(v, declaration, reference);\n+    } else if (refCount \u003d\u003d firstRefAfterInit) {\n+        Reference reference \u003d referenceInfo.references.get(firstRefAfterInit - 1);\n+        if (canInline(declaration, init, reference)) {\n+            inline(v, declaration, init, reference);\n+            staleVars.add(v);\n+        }\n+    } else if (declaration !\u003d init \u0026\u0026 refCount \u003d\u003d 2) {\n+        if (isValidDeclaration(declaration) \u0026\u0026 isValidInitialization(init)) {\n+            Node value \u003d init.getAssignedValue();\n+            Preconditions.checkNotNull(value);\n+            inlineWellDefinedVariable(v, value, referenceInfo.references);\n             staleVars.add(v);\n         }\n     }\n-    if (!staleVars.contains(v) \u0026\u0026 referenceInfo.isWellDefined() \u0026\u0026 referenceInfo.isNeverReassigned()) {\n+    if (!staleVars.contains(v) \u0026\u0026 referenceInfo.isWellDefined() \u0026\u0026 referenceInfo.isAssignedOnce()) {\n         List\u003cReference\u003e refs \u003d referenceInfo.references;\n         for (int i \u003d 1; i \u003c refs.size(); i++) {\n             Node nameNode \u003d refs.get(i).getNameNode();\n             if (aliasCandidates.containsKey(nameNode)) {\n                 AliasCandidate candidate \u003d aliasCandidates.get(nameNode);\n                 if (!staleVars.contains(candidate.alias)) {\n-                    inlineWellDefinedVariable(candidate.alias, candidate.refInfo.references);\n+                    Reference aliasInit;\n+                    aliasInit \u003d candidate.refInfo.getInitializingReference();\n+                    Node value \u003d aliasInit.getAssignedValue();\n+                    Preconditions.checkNotNull(value);\n+                    inlineWellDefinedVariable(candidate.alias, value, candidate.refInfo.references);\n                     staleVars.add(candidate.alias);\n                 }\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[scope-Scope, v-Var, referenceInfo-ReferenceCollection]",
            "newValue": "[v-Var, referenceInfo-ReferenceCollection]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Fix synthesis of vars in DEFAULT mode.\nBetter variable inlining\nBetter function inlining\nAssorted bug fixes\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@6 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "11/10/09, 11:16 AM",
          "commitName": "78995bf9e88599055a8c4165d89c09dc92a44b30",
          "commitAuthor": "nicholas.j.santos@gmail.com",
          "commitDateOld": "11/6/09, 5:24 PM",
          "commitNameOld": "0b7eccf2fd3a9293d7b513fbb766d7bc06abd7e0",
          "commitAuthorOld": "nicholas.j.santos@gmail.com",
          "daysBetweenCommits": 3.74,
          "commitsBetweenForRepo": 3,
          "commitsBetweenForFile": 1,
          "actualSource": "private void inlineNonConstants(Var v, ReferenceCollection referenceInfo) {\n    int refCount \u003d referenceInfo.references.size();\n    Reference declaration \u003d referenceInfo.references.get(0);\n    Reference init \u003d referenceInfo.getInitializingReference();\n    int firstRefAfterInit \u003d (declaration \u003d\u003d init) ? 2 : 3;\n    if (refCount \u003e 1 \u0026\u0026 isImmutableAndWellDefinedVariable(v, referenceInfo)) {\n        Node value \u003d init.getAssignedValue();\n        Preconditions.checkNotNull(value);\n        inlineWellDefinedVariable(v, value, referenceInfo.references);\n        staleVars.add(v);\n    } else if (refCount \u003d\u003d firstRefAfterInit) {\n        Reference reference \u003d referenceInfo.references.get(firstRefAfterInit - 1);\n        if (canInline(declaration, init, reference)) {\n            inline(v, declaration, init, reference);\n            staleVars.add(v);\n        }\n    } else if (declaration !\u003d init \u0026\u0026 refCount \u003d\u003d 2) {\n        if (isValidDeclaration(declaration) \u0026\u0026 isValidInitialization(init)) {\n            Node value \u003d init.getAssignedValue();\n            Preconditions.checkNotNull(value);\n            inlineWellDefinedVariable(v, value, referenceInfo.references);\n            staleVars.add(v);\n        }\n    }\n    if (!staleVars.contains(v) \u0026\u0026 referenceInfo.isWellDefined() \u0026\u0026 referenceInfo.isAssignedOnce()) {\n        List\u003cReference\u003e refs \u003d referenceInfo.references;\n        for (int i \u003d 1; i \u003c refs.size(); i++) {\n            Node nameNode \u003d refs.get(i).getNameNode();\n            if (aliasCandidates.containsKey(nameNode)) {\n                AliasCandidate candidate \u003d aliasCandidates.get(nameNode);\n                if (!staleVars.contains(candidate.alias)) {\n                    Reference aliasInit;\n                    aliasInit \u003d candidate.refInfo.getInitializingReference();\n                    Node value \u003d aliasInit.getAssignedValue();\n                    Preconditions.checkNotNull(value);\n                    inlineWellDefinedVariable(candidate.alias, value, candidate.refInfo.references);\n                    staleVars.add(candidate.alias);\n                }\n            }\n        }\n    }\n}",
          "path": "src/com/google/javascript/jscomp/InlineVariables.java",
          "functionStartLine": 196,
          "functionName": "inlineNonConstants",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,27 +1,42 @@\n-private void inlineNonConstants(Scope scope, Var v, ReferenceCollection referenceInfo) {\n-    if (referenceInfo.references.size() \u003e\u003d 2 \u0026\u0026 isImmutableAndWellDefinedVariable(v, referenceInfo)) {\n-        inlineWellDefinedVariable(v, referenceInfo.references);\n+private void inlineNonConstants(Var v, ReferenceCollection referenceInfo) {\n+    int refCount \u003d referenceInfo.references.size();\n+    Reference declaration \u003d referenceInfo.references.get(0);\n+    Reference init \u003d referenceInfo.getInitializingReference();\n+    int firstRefAfterInit \u003d (declaration \u003d\u003d init) ? 2 : 3;\n+    if (refCount \u003e 1 \u0026\u0026 isImmutableAndWellDefinedVariable(v, referenceInfo)) {\n+        Node value \u003d init.getAssignedValue();\n+        Preconditions.checkNotNull(value);\n+        inlineWellDefinedVariable(v, value, referenceInfo.references);\n         staleVars.add(v);\n-    } else if (referenceInfo.references.size() \u003d\u003d 2) {\n-        Reference declaration \u003d referenceInfo.references.get(0);\n-        Reference reference \u003d referenceInfo.references.get(1);\n-        if (canInline(declaration, reference)) {\n-            blacklistVarReferencesInTree(declaration.getNameNode().getFirstChild(), scope);\n-            inline(v, declaration, reference);\n+    } else if (refCount \u003d\u003d firstRefAfterInit) {\n+        Reference reference \u003d referenceInfo.references.get(firstRefAfterInit - 1);\n+        if (canInline(declaration, init, reference)) {\n+            inline(v, declaration, init, reference);\n+            staleVars.add(v);\n+        }\n+    } else if (declaration !\u003d init \u0026\u0026 refCount \u003d\u003d 2) {\n+        if (isValidDeclaration(declaration) \u0026\u0026 isValidInitialization(init)) {\n+            Node value \u003d init.getAssignedValue();\n+            Preconditions.checkNotNull(value);\n+            inlineWellDefinedVariable(v, value, referenceInfo.references);\n             staleVars.add(v);\n         }\n     }\n-    if (!staleVars.contains(v) \u0026\u0026 referenceInfo.isWellDefined() \u0026\u0026 referenceInfo.isNeverReassigned()) {\n+    if (!staleVars.contains(v) \u0026\u0026 referenceInfo.isWellDefined() \u0026\u0026 referenceInfo.isAssignedOnce()) {\n         List\u003cReference\u003e refs \u003d referenceInfo.references;\n         for (int i \u003d 1; i \u003c refs.size(); i++) {\n             Node nameNode \u003d refs.get(i).getNameNode();\n             if (aliasCandidates.containsKey(nameNode)) {\n                 AliasCandidate candidate \u003d aliasCandidates.get(nameNode);\n                 if (!staleVars.contains(candidate.alias)) {\n-                    inlineWellDefinedVariable(candidate.alias, candidate.refInfo.references);\n+                    Reference aliasInit;\n+                    aliasInit \u003d candidate.refInfo.getInitializingReference();\n+                    Node value \u003d aliasInit.getAssignedValue();\n+                    Preconditions.checkNotNull(value);\n+                    inlineWellDefinedVariable(candidate.alias, value, candidate.refInfo.references);\n                     staleVars.add(candidate.alias);\n                 }\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": {
      "type": "Yintroduced",
      "commitMessage": "Initial commit.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/3/09, 3:51 PM",
      "commitName": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "diff": "@@ -0,0 +1,27 @@\n+private void inlineNonConstants(Scope scope, Var v, ReferenceCollection referenceInfo) {\n+    if (referenceInfo.references.size() \u003e\u003d 2 \u0026\u0026 isImmutableAndWellDefinedVariable(v, referenceInfo)) {\n+        inlineWellDefinedVariable(v, referenceInfo.references);\n+        staleVars.add(v);\n+    } else if (referenceInfo.references.size() \u003d\u003d 2) {\n+        Reference declaration \u003d referenceInfo.references.get(0);\n+        Reference reference \u003d referenceInfo.references.get(1);\n+        if (canInline(declaration, reference)) {\n+            blacklistVarReferencesInTree(declaration.getNameNode().getFirstChild(), scope);\n+            inline(v, declaration, reference);\n+            staleVars.add(v);\n+        }\n+    }\n+    if (!staleVars.contains(v) \u0026\u0026 referenceInfo.isWellDefined() \u0026\u0026 referenceInfo.isNeverReassigned()) {\n+        List\u003cReference\u003e refs \u003d referenceInfo.references;\n+        for (int i \u003d 1; i \u003c refs.size(); i++) {\n+            Node nameNode \u003d refs.get(i).getNameNode();\n+            if (aliasCandidates.containsKey(nameNode)) {\n+                AliasCandidate candidate \u003d aliasCandidates.get(nameNode);\n+                if (!staleVars.contains(candidate.alias)) {\n+                    inlineWellDefinedVariable(candidate.alias, candidate.refInfo.references);\n+                    staleVars.add(candidate.alias);\n+                }\n+            }\n+        }\n+    }\n+}\n\\ No newline at end of file\n",
      "actualSource": "private void inlineNonConstants(Scope scope, Var v, ReferenceCollection referenceInfo) {\n    if (referenceInfo.references.size() \u003e\u003d 2 \u0026\u0026 isImmutableAndWellDefinedVariable(v, referenceInfo)) {\n        inlineWellDefinedVariable(v, referenceInfo.references);\n        staleVars.add(v);\n    } else if (referenceInfo.references.size() \u003d\u003d 2) {\n        Reference declaration \u003d referenceInfo.references.get(0);\n        Reference reference \u003d referenceInfo.references.get(1);\n        if (canInline(declaration, reference)) {\n            blacklistVarReferencesInTree(declaration.getNameNode().getFirstChild(), scope);\n            inline(v, declaration, reference);\n            staleVars.add(v);\n        }\n    }\n    if (!staleVars.contains(v) \u0026\u0026 referenceInfo.isWellDefined() \u0026\u0026 referenceInfo.isNeverReassigned()) {\n        List\u003cReference\u003e refs \u003d referenceInfo.references;\n        for (int i \u003d 1; i \u003c refs.size(); i++) {\n            Node nameNode \u003d refs.get(i).getNameNode();\n            if (aliasCandidates.containsKey(nameNode)) {\n                AliasCandidate candidate \u003d aliasCandidates.get(nameNode);\n                if (!staleVars.contains(candidate.alias)) {\n                    inlineWellDefinedVariable(candidate.alias, candidate.refInfo.references);\n                    staleVars.add(candidate.alias);\n                }\n            }\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/InlineVariables.java",
      "functionStartLine": 225,
      "functionName": "inlineNonConstants",
      "functionAnnotation": "",
      "functionDoc": ""
    }
  }
}