{
  "origin": "codeshovel",
  "repositoryName": "Closure-121b",
  "repositoryPath": "/tmp/Closure-121b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "CodeGenerator.java",
  "functionName": "add",
  "functionId": "add___n-Node__context-Context",
  "sourceFilePath": "src/com/google/javascript/jscomp/CodeGenerator.java",
  "functionAnnotation": "",
  "functionDoc": "",
  "functionStartLine": 107,
  "functionEndLine": 771,
  "numCommitsSeen": 83,
  "timeTaken": 7277,
  "changeHistory": [
    "8d11b8cc7a6183222b61c9bd398fed5448c59109",
    "42dbcc0d7086141c3f0e5a2091b23424c5d87538",
    "c4f38043f0aa21e74c341f3056a0d9b556a44c3e",
    "0b054d7d1b185b02c595c646bc0f11a6d809c934",
    "24fd842a5380a350bcde0bed60287053bc9b37f0",
    "5428589fcac11bb899a44ef827e12a253e29d323",
    "70a5626922ea7e8c98747e22b6986638ba38fadc",
    "59dbb7a28680caad08ddb1658123fe0cbb1ae689",
    "f412f0c0efd54842b30207c845d65cb826217fd6",
    "87b154f89cba3c67045cd7a783b79231d0630a4c",
    "746e26420bb2dde1339a72f15199373ab0182d33",
    "e85593d14461f5342013d0d6c6e8484dca003eef",
    "4e976ac213f448bab78f5c1432340c489b533d7b",
    "39f629a8cfaab37da55288010640d7e516000b1f",
    "5524adbda991632656059566b69cc2771ba42b7d",
    "ec324a9bb23eb78c76f537f4c4170ba88d542f1c",
    "6641663fa9970c4d7bcdd96a6f31b83b18c3ee3d",
    "0a58c69ede8450419f6309bf8d97a00fe48c1b33",
    "f78951b324be6cb453ebbefcb30ab83328282590",
    "75aa5f653b08995428743f6951a99ad101e73e37",
    "41acde3e8e5e8d37ade765b41d9fd29861f03e5e",
    "653599e7c3922059a78958ea32b216ff9c42800e",
    "ae2eb35cc611443ce1e440c2006bbe52f8191b4c",
    "6ee4f24898632726e63ade4b42636b18e1df6aa7",
    "7437e9b626c812301e3fe9449e4ee71506da9efb",
    "be0104009f06fafdb7428398d2c8299d13a1df12",
    "28982c32f367108886311969e01d69156230fd35",
    "1c92a5447451e3d6e663d4bf508237a6eaeccf90",
    "5b4d241bf1caf69e32bb55bc076ed70ce5cb3d4e",
    "34fd5f8275ae69fc772c2283a3c5fd13b93a7c42",
    "cc4824cb0e1ebc3f4fc6a8fe78f90e6bd8db6c0c",
    "6d8fd424925b186d720112e4f14e6898386a66b0",
    "f0e3cbc250fd9536ff92119bdf5e1a62120a7fac",
    "9390e7889e85aca41bdf98fb38a19bd69f6fdb87",
    "17296982d8892d972412352289c307a4d60d2c50",
    "d7e85b0997ebb3d920c977de7a4a3f8ede5ba2d8",
    "3c4504a78a84e4715439cddb4028c25be2ce308f",
    "9925370292834ea846727f1f9db76af0d40261df",
    "dff6e0114f19c20aeb63393d67aa0880ff5745b5",
    "b1ffe42efdaaf0266b4ba10e05de124a885cf979",
    "07663b6946caa097ad92b5375e333936351e3256",
    "c9e89727dc8063d087d28e42629606f4fd74a6e5",
    "e33e925eea3a8e4de958864e531e1adc4da62e18",
    "43859717972907dd1ecebd8dca6e05036386e28b",
    "de13c3313c05f4449c50c560324389d6905a214d",
    "222eafd303155b3eac5cd244584b2cb3c4c11975",
    "f01925cbf7a39a885e51865208368e861d25a0c1",
    "8c5eb247cb5361a6ffa2d86aa4c2de17c234bda7",
    "8ba5e1f86eaf3c31b9279f92823b4fa2a50574a3",
    "168bc14ff5e9e664863c3b1146f2a5b7a30ffb42",
    "847b296c23a63aa0a0b38cc3e63883e1688288e3",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3"
  ],
  "changeHistoryShort": {
    "8d11b8cc7a6183222b61c9bd398fed5448c59109": "Ybodychange",
    "42dbcc0d7086141c3f0e5a2091b23424c5d87538": "Ybodychange",
    "c4f38043f0aa21e74c341f3056a0d9b556a44c3e": "Ybodychange",
    "0b054d7d1b185b02c595c646bc0f11a6d809c934": "Ybodychange",
    "24fd842a5380a350bcde0bed60287053bc9b37f0": "Ybodychange",
    "5428589fcac11bb899a44ef827e12a253e29d323": "Ybodychange",
    "70a5626922ea7e8c98747e22b6986638ba38fadc": "Ybodychange",
    "59dbb7a28680caad08ddb1658123fe0cbb1ae689": "Ybodychange",
    "f412f0c0efd54842b30207c845d65cb826217fd6": "Ybodychange",
    "87b154f89cba3c67045cd7a783b79231d0630a4c": "Ybodychange",
    "746e26420bb2dde1339a72f15199373ab0182d33": "Ybodychange",
    "e85593d14461f5342013d0d6c6e8484dca003eef": "Ybodychange",
    "4e976ac213f448bab78f5c1432340c489b533d7b": "Ybodychange",
    "39f629a8cfaab37da55288010640d7e516000b1f": "Ybodychange",
    "5524adbda991632656059566b69cc2771ba42b7d": "Ybodychange",
    "ec324a9bb23eb78c76f537f4c4170ba88d542f1c": "Ybodychange",
    "6641663fa9970c4d7bcdd96a6f31b83b18c3ee3d": "Ybodychange",
    "0a58c69ede8450419f6309bf8d97a00fe48c1b33": "Ybodychange",
    "f78951b324be6cb453ebbefcb30ab83328282590": "Ybodychange",
    "75aa5f653b08995428743f6951a99ad101e73e37": "Ybodychange",
    "41acde3e8e5e8d37ade765b41d9fd29861f03e5e": "Ybodychange",
    "653599e7c3922059a78958ea32b216ff9c42800e": "Ybodychange",
    "ae2eb35cc611443ce1e440c2006bbe52f8191b4c": "Ybodychange",
    "6ee4f24898632726e63ade4b42636b18e1df6aa7": "Ybodychange",
    "7437e9b626c812301e3fe9449e4ee71506da9efb": "Ybodychange",
    "be0104009f06fafdb7428398d2c8299d13a1df12": "Ybodychange",
    "28982c32f367108886311969e01d69156230fd35": "Ybodychange",
    "1c92a5447451e3d6e663d4bf508237a6eaeccf90": "Ybodychange",
    "5b4d241bf1caf69e32bb55bc076ed70ce5cb3d4e": "Ybodychange",
    "34fd5f8275ae69fc772c2283a3c5fd13b93a7c42": "Ybodychange",
    "cc4824cb0e1ebc3f4fc6a8fe78f90e6bd8db6c0c": "Ybodychange",
    "6d8fd424925b186d720112e4f14e6898386a66b0": "Ybodychange",
    "f0e3cbc250fd9536ff92119bdf5e1a62120a7fac": "Ybodychange",
    "9390e7889e85aca41bdf98fb38a19bd69f6fdb87": "Ybodychange",
    "17296982d8892d972412352289c307a4d60d2c50": "Ybodychange",
    "d7e85b0997ebb3d920c977de7a4a3f8ede5ba2d8": "Ybodychange",
    "3c4504a78a84e4715439cddb4028c25be2ce308f": "Ybodychange",
    "9925370292834ea846727f1f9db76af0d40261df": "Ybodychange",
    "dff6e0114f19c20aeb63393d67aa0880ff5745b5": "Yformatchange",
    "b1ffe42efdaaf0266b4ba10e05de124a885cf979": "Ybodychange",
    "07663b6946caa097ad92b5375e333936351e3256": "Ybodychange",
    "c9e89727dc8063d087d28e42629606f4fd74a6e5": "Ybodychange",
    "e33e925eea3a8e4de958864e531e1adc4da62e18": "Ybodychange",
    "43859717972907dd1ecebd8dca6e05036386e28b": "Ybodychange",
    "de13c3313c05f4449c50c560324389d6905a214d": "Ybodychange",
    "222eafd303155b3eac5cd244584b2cb3c4c11975": "Ybodychange",
    "f01925cbf7a39a885e51865208368e861d25a0c1": "Ybodychange",
    "8c5eb247cb5361a6ffa2d86aa4c2de17c234bda7": "Ybodychange",
    "8ba5e1f86eaf3c31b9279f92823b4fa2a50574a3": "Ybodychange",
    "168bc14ff5e9e664863c3b1146f2a5b7a30ffb42": "Ybodychange",
    "847b296c23a63aa0a0b38cc3e63883e1688288e3": "Ybodychange",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "8d11b8cc7a6183222b61c9bd398fed5448c59109": {
      "type": "Ybodychange",
      "commitMessage": "Printing of IN statement inside HOOK inside FOR.\n\nFixes issue 1033\n-------------\nCreated by MOE: http://code.google.com/p/moe-java\nMOE_MIGRATED_REVID\u003d48696718\n",
      "commitDate": "6/28/13, 4:09 PM",
      "commitName": "8d11b8cc7a6183222b61c9bd398fed5448c59109",
      "commitAuthor": "Ben Lickly",
      "commitDateOld": "6/25/13, 4:15 PM",
      "commitNameOld": "42dbcc0d7086141c3f0e5a2091b23424c5d87538",
      "commitAuthorOld": "Ben Lickly",
      "daysBetweenCommits": 3.0,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "actualSource": "void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n        return;\n    }\n    int type \u003d n.getType();\n    String opstr \u003d NodeUtil.opToStr(type);\n    int childCount \u003d n.getChildCount();\n    Node first \u003d n.getFirstChild();\n    Node last \u003d n.getLastChild();\n    if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n        Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n        int p \u003d NodeUtil.precedence(type);\n        Context rhsContext \u003d getContextForNoInOperator(context);\n        if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n            addExpr(first, p, context);\n            cc.addOp(opstr, true);\n            addExpr(last, p, rhsContext);\n        } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n            addExpr(first, p, context);\n            cc.addOp(opstr, true);\n            addExpr(last, p, rhsContext);\n        } else {\n            unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n        }\n        return;\n    }\n    cc.startSourceMapping(n);\n    switch(type) {\n        case Token.TRY:\n            {\n                Preconditions.checkState(first.getNext().isBlock() \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n                Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                add(\"try\");\n                add(first, Context.PRESERVE_BLOCK);\n                Node catchblock \u003d first.getNext().getFirstChild();\n                if (catchblock !\u003d null) {\n                    add(catchblock);\n                }\n                if (childCount \u003d\u003d 3) {\n                    add(\"finally\");\n                    add(last, Context.PRESERVE_BLOCK);\n                }\n                break;\n            }\n        case Token.CATCH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"catch(\");\n            add(first);\n            add(\")\");\n            add(last, Context.PRESERVE_BLOCK);\n            break;\n        case Token.THROW:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"throw\");\n            add(first);\n            cc.endStatement(true);\n            break;\n        case Token.RETURN:\n            add(\"return\");\n            if (childCount \u003d\u003d 1) {\n                add(first);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 0);\n            }\n            cc.endStatement();\n            break;\n        case Token.VAR:\n            if (first !\u003d null) {\n                add(\"var \");\n                addList(first, false, getContextForNoInOperator(context));\n            }\n            break;\n        case Token.LABEL_NAME:\n            Preconditions.checkState(!n.getString().isEmpty());\n            addIdentifier(n.getString());\n            break;\n        case Token.NAME:\n            if (first \u003d\u003d null || first.isEmpty()) {\n                addIdentifier(n.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                addIdentifier(n.getString());\n                cc.addOp(\"\u003d\", true);\n                if (first.isComma()) {\n                    addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n                } else {\n                    addExpr(first, 0, getContextForNoInOperator(context));\n                }\n            }\n            break;\n        case Token.ARRAYLIT:\n            add(\"[\");\n            addArrayList(first);\n            add(\"]\");\n            break;\n        case Token.PARAM_LIST:\n            add(\"(\");\n            addList(first);\n            add(\")\");\n            break;\n        case Token.COMMA:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            unrollBinaryOperator(n, Token.COMMA, \",\", context, getContextForNoInOperator(context), 0, 0);\n            break;\n        case Token.NUMBER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            cc.addNumber(n.getDouble());\n            break;\n        case Token.TYPEOF:\n        case Token.VOID:\n        case Token.NOT:\n        case Token.BITNOT:\n        case Token.POS:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n                break;\n            }\n        case Token.NEG:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                if (n.getFirstChild().isNumber()) {\n                    cc.addNumber(-n.getFirstChild().getDouble());\n                } else {\n                    cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                    addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n                }\n                break;\n            }\n        case Token.HOOK:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                int p \u003d NodeUtil.precedence(type);\n                Context rhsContext \u003d getContextForNoInOperator(context);\n                addExpr(first, p + 1, context);\n                cc.addOp(\"?\", true);\n                addExpr(first.getNext(), 1, rhsContext);\n                cc.addOp(\":\", true);\n                addExpr(last, 1, rhsContext);\n                break;\n            }\n        case Token.REGEXP:\n            if (!first.isString() || !last.isString()) {\n                throw new Error(\"Expected children to be strings\");\n            }\n            String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n            if (childCount \u003d\u003d 2) {\n                add(regexp + last.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                add(regexp);\n            }\n            break;\n        case Token.FUNCTION:\n            if (n.getClass() !\u003d Node.class) {\n                throw new Error(\"Unexpected Node subclass.\");\n            }\n            Preconditions.checkState(childCount \u003d\u003d 3);\n            boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n            if (funcNeedsParens) {\n                add(\"(\");\n            }\n            add(\"function\");\n            add(first);\n            add(first.getNext());\n            add(last, Context.PRESERVE_BLOCK);\n            cc.endFunction(context \u003d\u003d Context.STATEMENT);\n            if (funcNeedsParens) {\n                add(\")\");\n            }\n            break;\n        case Token.GETTER_DEF:\n        case Token.SETTER_DEF:\n            Preconditions.checkState(n.getParent().isObjectLit());\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            Preconditions.checkState(first.isFunction());\n            Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n            if (type \u003d\u003d Token.GETTER_DEF) {\n                Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n                add(\"get \");\n            } else {\n                Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n                add(\"set \");\n            }\n            String name \u003d n.getString();\n            Node fn \u003d first;\n            Node parameters \u003d fn.getChildAtIndex(1);\n            Node body \u003d fn.getLastChild();\n            if (!n.isQuotedString() \u0026\u0026 TokenStream.isJSIdentifier(name) \u0026\u0026 NodeUtil.isLatin(name)) {\n                add(name);\n            } else {\n                double d \u003d getSimpleNumber(name);\n                if (!Double.isNaN(d)) {\n                    cc.addNumber(d);\n                } else {\n                    addJsString(n);\n                }\n            }\n            add(parameters);\n            add(body, Context.PRESERVE_BLOCK);\n            break;\n        case Token.SCRIPT:\n        case Token.BLOCK:\n            {\n                if (n.getClass() !\u003d Node.class) {\n                    throw new Error(\"Unexpected Node subclass.\");\n                }\n                boolean preserveBlock \u003d context \u003d\u003d Context.PRESERVE_BLOCK;\n                if (preserveBlock) {\n                    cc.beginBlock();\n                }\n                boolean preferLineBreaks \u003d type \u003d\u003d Token.SCRIPT || (type \u003d\u003d Token.BLOCK \u0026\u0026 !preserveBlock \u0026\u0026 n.getParent() !\u003d null \u0026\u0026 n.getParent().isScript());\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    add(c, Context.STATEMENT);\n                    if (c.isVar()) {\n                        cc.endStatement();\n                    }\n                    if (c.isFunction()) {\n                        cc.maybeLineBreak();\n                    }\n                    if (preferLineBreaks) {\n                        cc.notePreferredLineBreak();\n                    }\n                }\n                if (preserveBlock) {\n                    cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                }\n                break;\n            }\n        case Token.FOR:\n            if (childCount \u003d\u003d 4) {\n                add(\"for(\");\n                if (first.isVar()) {\n                    add(first, Context.IN_FOR_INIT_CLAUSE);\n                } else {\n                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                }\n                add(\";\");\n                add(first.getNext());\n                add(\";\");\n                add(first.getNext().getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                add(\"for(\");\n                add(first);\n                add(\"in\");\n                add(first.getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            }\n            break;\n        case Token.DO:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"do\");\n            addNonEmptyStatement(first, Context.OTHER, false);\n            add(\"while(\");\n            add(last);\n            add(\")\");\n            cc.endStatement();\n            break;\n        case Token.WHILE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"while(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.EMPTY:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            break;\n        case Token.GETPROP:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                Preconditions.checkState(last.isString(), \"Bad GETPROP: RHS should be STRING\");\n                boolean needsParens \u003d (first.isNumber());\n                if (needsParens) {\n                    add(\"(\");\n                }\n                addExpr(first, NodeUtil.precedence(type), context);\n                if (needsParens) {\n                    add(\")\");\n                }\n                if (this.languageMode \u003d\u003d LanguageMode.ECMASCRIPT3 \u0026\u0026 TokenStream.isKeyword(last.getString())) {\n                    add(\"[\");\n                    add(last);\n                    add(\"]\");\n                } else {\n                    add(\".\");\n                    addIdentifier(last.getString());\n                }\n                break;\n            }\n        case Token.GETELEM:\n            Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n            addExpr(first, NodeUtil.precedence(type), context);\n            add(\"[\");\n            add(first.getNext());\n            add(\"]\");\n            break;\n        case Token.WITH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"with(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.INC:\n        case Token.DEC:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                if (postProp !\u003d 0) {\n                    addExpr(first, NodeUtil.precedence(type), context);\n                    cc.addOp(o, false);\n                } else {\n                    cc.addOp(o, false);\n                    add(first);\n                }\n                break;\n            }\n        case Token.CALL:\n            if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) \u0026\u0026 NodeUtil.isGet(first)) {\n                add(\"(0,\");\n                addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n                add(\")\");\n            } else {\n                addExpr(first, NodeUtil.precedence(type), context);\n            }\n            add(\"(\");\n            addList(first.getNext());\n            add(\")\");\n            break;\n        case Token.IF:\n            boolean hasElse \u003d childCount \u003d\u003d 3;\n            boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n            if (ambiguousElseClause) {\n                cc.beginBlock();\n            }\n            add(\"if(\");\n            add(first);\n            add(\")\");\n            if (hasElse) {\n                addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                add(\"else\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n                Preconditions.checkState(childCount \u003d\u003d 2);\n            }\n            if (ambiguousElseClause) {\n                cc.endBlock();\n            }\n            break;\n        case Token.NULL:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            cc.addConstant(\"null\");\n            break;\n        case Token.THIS:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"this\");\n            break;\n        case Token.FALSE:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            cc.addConstant(\"false\");\n            break;\n        case Token.TRUE:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            cc.addConstant(\"true\");\n            break;\n        case Token.CONTINUE:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"continue\");\n            if (childCount \u003d\u003d 1) {\n                if (!first.isLabelName()) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.DEBUGGER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"debugger\");\n            cc.endStatement();\n            break;\n        case Token.BREAK:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"break\");\n            if (childCount \u003d\u003d 1) {\n                if (!first.isLabelName()) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.EXPR_RESULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first, Context.START_OF_EXPR);\n            cc.endStatement();\n            break;\n        case Token.NEW:\n            add(\"new \");\n            int precedence \u003d NodeUtil.precedence(type);\n            if (NodeUtil.containsType(first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n                precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n            }\n            addExpr(first, precedence, Context.OTHER);\n            Node next \u003d first.getNext();\n            if (next !\u003d null) {\n                add(\"(\");\n                addList(next);\n                add(\")\");\n            }\n            break;\n        case Token.STRING_KEY:\n            Preconditions.checkState(childCount \u003d\u003d 1, \"Object lit key must have 1 child\");\n            addJsString(n);\n            break;\n        case Token.STRING:\n            Preconditions.checkState(childCount \u003d\u003d 0, \"A string may not have children\");\n            addJsString(n);\n            break;\n        case Token.DELPROP:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"delete \");\n            add(first);\n            break;\n        case Token.OBJECTLIT:\n            {\n                boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                add(\"{\");\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    if (c !\u003d first) {\n                        cc.listSeparator();\n                    }\n                    if (c.isGetterDef() || c.isSetterDef()) {\n                        add(c);\n                    } else {\n                        Preconditions.checkState(c.isStringKey());\n                        String key \u003d c.getString();\n                        if (!c.isQuotedString() \u0026\u0026 !(languageMode \u003d\u003d LanguageMode.ECMASCRIPT3 \u0026\u0026 TokenStream.isKeyword(key)) \u0026\u0026 TokenStream.isJSIdentifier(key) \u0026\u0026 NodeUtil.isLatin(key)) {\n                            add(key);\n                        } else {\n                            double d \u003d getSimpleNumber(key);\n                            if (!Double.isNaN(d)) {\n                                cc.addNumber(d);\n                            } else {\n                                addExpr(c, 1, Context.OTHER);\n                            }\n                        }\n                        add(\":\");\n                        addExpr(c.getFirstChild(), 1, Context.OTHER);\n                    }\n                }\n                add(\"}\");\n                if (needsParens) {\n                    add(\")\");\n                }\n                break;\n            }\n        case Token.SWITCH:\n            add(\"switch(\");\n            add(first);\n            add(\")\");\n            cc.beginBlock();\n            addAllSiblings(first.getNext());\n            cc.endBlock(context \u003d\u003d Context.STATEMENT);\n            break;\n        case Token.CASE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"case \");\n            add(first);\n            addCaseBody(last);\n            break;\n        case Token.DEFAULT_CASE:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"default\");\n            addCaseBody(first);\n            break;\n        case Token.LABEL:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            if (!first.isLabelName()) {\n                throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n            }\n            add(first);\n            add(\":\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\n            break;\n        case Token.CAST:\n            add(\"(\");\n            add(first);\n            add(\")\");\n            break;\n        default:\n            throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n    cc.endSourceMapping(n);\n}",
      "path": "src/com/google/javascript/jscomp/CodeGenerator.java",
      "functionStartLine": 107,
      "functionName": "add",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,507 +1,508 @@\n void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n         return;\n     }\n     int type \u003d n.getType();\n     String opstr \u003d NodeUtil.opToStr(type);\n     int childCount \u003d n.getChildCount();\n     Node first \u003d n.getFirstChild();\n     Node last \u003d n.getLastChild();\n     if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n         Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n         int p \u003d NodeUtil.precedence(type);\n         Context rhsContext \u003d getContextForNoInOperator(context);\n         if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n             addExpr(first, p, context);\n             cc.addOp(opstr, true);\n             addExpr(last, p, rhsContext);\n         } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n             addExpr(first, p, context);\n             cc.addOp(opstr, true);\n             addExpr(last, p, rhsContext);\n         } else {\n             unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n         }\n         return;\n     }\n     cc.startSourceMapping(n);\n     switch(type) {\n         case Token.TRY:\n             {\n                 Preconditions.checkState(first.getNext().isBlock() \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n                 Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                 add(\"try\");\n                 add(first, Context.PRESERVE_BLOCK);\n                 Node catchblock \u003d first.getNext().getFirstChild();\n                 if (catchblock !\u003d null) {\n                     add(catchblock);\n                 }\n                 if (childCount \u003d\u003d 3) {\n                     add(\"finally\");\n                     add(last, Context.PRESERVE_BLOCK);\n                 }\n                 break;\n             }\n         case Token.CATCH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"catch(\");\n             add(first);\n             add(\")\");\n             add(last, Context.PRESERVE_BLOCK);\n             break;\n         case Token.THROW:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"throw\");\n             add(first);\n             cc.endStatement(true);\n             break;\n         case Token.RETURN:\n             add(\"return\");\n             if (childCount \u003d\u003d 1) {\n                 add(first);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 0);\n             }\n             cc.endStatement();\n             break;\n         case Token.VAR:\n             if (first !\u003d null) {\n                 add(\"var \");\n                 addList(first, false, getContextForNoInOperator(context));\n             }\n             break;\n         case Token.LABEL_NAME:\n             Preconditions.checkState(!n.getString().isEmpty());\n             addIdentifier(n.getString());\n             break;\n         case Token.NAME:\n             if (first \u003d\u003d null || first.isEmpty()) {\n                 addIdentifier(n.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 addIdentifier(n.getString());\n                 cc.addOp(\"\u003d\", true);\n                 if (first.isComma()) {\n                     addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n                 } else {\n                     addExpr(first, 0, getContextForNoInOperator(context));\n                 }\n             }\n             break;\n         case Token.ARRAYLIT:\n             add(\"[\");\n             addArrayList(first);\n             add(\"]\");\n             break;\n         case Token.PARAM_LIST:\n             add(\"(\");\n             addList(first);\n             add(\")\");\n             break;\n         case Token.COMMA:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             unrollBinaryOperator(n, Token.COMMA, \",\", context, getContextForNoInOperator(context), 0, 0);\n             break;\n         case Token.NUMBER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             cc.addNumber(n.getDouble());\n             break;\n         case Token.TYPEOF:\n         case Token.VOID:\n         case Token.NOT:\n         case Token.BITNOT:\n         case Token.POS:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                 addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n                 break;\n             }\n         case Token.NEG:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 if (n.getFirstChild().isNumber()) {\n                     cc.addNumber(-n.getFirstChild().getDouble());\n                 } else {\n                     cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                     addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n                 }\n                 break;\n             }\n         case Token.HOOK:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 int p \u003d NodeUtil.precedence(type);\n+                Context rhsContext \u003d getContextForNoInOperator(context);\n                 addExpr(first, p + 1, context);\n                 cc.addOp(\"?\", true);\n-                addExpr(first.getNext(), 1, Context.OTHER);\n+                addExpr(first.getNext(), 1, rhsContext);\n                 cc.addOp(\":\", true);\n-                addExpr(last, 1, Context.OTHER);\n+                addExpr(last, 1, rhsContext);\n                 break;\n             }\n         case Token.REGEXP:\n             if (!first.isString() || !last.isString()) {\n                 throw new Error(\"Expected children to be strings\");\n             }\n             String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n             if (childCount \u003d\u003d 2) {\n                 add(regexp + last.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 add(regexp);\n             }\n             break;\n         case Token.FUNCTION:\n             if (n.getClass() !\u003d Node.class) {\n                 throw new Error(\"Unexpected Node subclass.\");\n             }\n             Preconditions.checkState(childCount \u003d\u003d 3);\n             boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n             if (funcNeedsParens) {\n                 add(\"(\");\n             }\n             add(\"function\");\n             add(first);\n             add(first.getNext());\n             add(last, Context.PRESERVE_BLOCK);\n             cc.endFunction(context \u003d\u003d Context.STATEMENT);\n             if (funcNeedsParens) {\n                 add(\")\");\n             }\n             break;\n         case Token.GETTER_DEF:\n         case Token.SETTER_DEF:\n             Preconditions.checkState(n.getParent().isObjectLit());\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             Preconditions.checkState(first.isFunction());\n             Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n             if (type \u003d\u003d Token.GETTER_DEF) {\n                 Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n                 add(\"get \");\n             } else {\n                 Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n                 add(\"set \");\n             }\n             String name \u003d n.getString();\n             Node fn \u003d first;\n             Node parameters \u003d fn.getChildAtIndex(1);\n             Node body \u003d fn.getLastChild();\n             if (!n.isQuotedString() \u0026\u0026 TokenStream.isJSIdentifier(name) \u0026\u0026 NodeUtil.isLatin(name)) {\n                 add(name);\n             } else {\n                 double d \u003d getSimpleNumber(name);\n                 if (!Double.isNaN(d)) {\n                     cc.addNumber(d);\n                 } else {\n                     addJsString(n);\n                 }\n             }\n             add(parameters);\n             add(body, Context.PRESERVE_BLOCK);\n             break;\n         case Token.SCRIPT:\n         case Token.BLOCK:\n             {\n                 if (n.getClass() !\u003d Node.class) {\n                     throw new Error(\"Unexpected Node subclass.\");\n                 }\n                 boolean preserveBlock \u003d context \u003d\u003d Context.PRESERVE_BLOCK;\n                 if (preserveBlock) {\n                     cc.beginBlock();\n                 }\n                 boolean preferLineBreaks \u003d type \u003d\u003d Token.SCRIPT || (type \u003d\u003d Token.BLOCK \u0026\u0026 !preserveBlock \u0026\u0026 n.getParent() !\u003d null \u0026\u0026 n.getParent().isScript());\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     add(c, Context.STATEMENT);\n                     if (c.isVar()) {\n                         cc.endStatement();\n                     }\n                     if (c.isFunction()) {\n                         cc.maybeLineBreak();\n                     }\n                     if (preferLineBreaks) {\n                         cc.notePreferredLineBreak();\n                     }\n                 }\n                 if (preserveBlock) {\n                     cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                 }\n                 break;\n             }\n         case Token.FOR:\n             if (childCount \u003d\u003d 4) {\n                 add(\"for(\");\n                 if (first.isVar()) {\n                     add(first, Context.IN_FOR_INIT_CLAUSE);\n                 } else {\n                     addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                 }\n                 add(\";\");\n                 add(first.getNext());\n                 add(\";\");\n                 add(first.getNext().getNext());\n                 add(\")\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 add(\"for(\");\n                 add(first);\n                 add(\"in\");\n                 add(first.getNext());\n                 add(\")\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             }\n             break;\n         case Token.DO:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"do\");\n             addNonEmptyStatement(first, Context.OTHER, false);\n             add(\"while(\");\n             add(last);\n             add(\")\");\n             cc.endStatement();\n             break;\n         case Token.WHILE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"while(\");\n             add(first);\n             add(\")\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.EMPTY:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             break;\n         case Token.GETPROP:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                 Preconditions.checkState(last.isString(), \"Bad GETPROP: RHS should be STRING\");\n                 boolean needsParens \u003d (first.isNumber());\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 addExpr(first, NodeUtil.precedence(type), context);\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 if (this.languageMode \u003d\u003d LanguageMode.ECMASCRIPT3 \u0026\u0026 TokenStream.isKeyword(last.getString())) {\n                     add(\"[\");\n                     add(last);\n                     add(\"]\");\n                 } else {\n                     add(\".\");\n                     addIdentifier(last.getString());\n                 }\n                 break;\n             }\n         case Token.GETELEM:\n             Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n             addExpr(first, NodeUtil.precedence(type), context);\n             add(\"[\");\n             add(first.getNext());\n             add(\"]\");\n             break;\n         case Token.WITH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"with(\");\n             add(first);\n             add(\")\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.INC:\n         case Token.DEC:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                 int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                 if (postProp !\u003d 0) {\n                     addExpr(first, NodeUtil.precedence(type), context);\n                     cc.addOp(o, false);\n                 } else {\n                     cc.addOp(o, false);\n                     add(first);\n                 }\n                 break;\n             }\n         case Token.CALL:\n             if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) \u0026\u0026 NodeUtil.isGet(first)) {\n                 add(\"(0,\");\n                 addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n                 add(\")\");\n             } else {\n                 addExpr(first, NodeUtil.precedence(type), context);\n             }\n             add(\"(\");\n             addList(first.getNext());\n             add(\")\");\n             break;\n         case Token.IF:\n             boolean hasElse \u003d childCount \u003d\u003d 3;\n             boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n             if (ambiguousElseClause) {\n                 cc.beginBlock();\n             }\n             add(\"if(\");\n             add(first);\n             add(\")\");\n             if (hasElse) {\n                 addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                 add(\"else\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n                 Preconditions.checkState(childCount \u003d\u003d 2);\n             }\n             if (ambiguousElseClause) {\n                 cc.endBlock();\n             }\n             break;\n         case Token.NULL:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             cc.addConstant(\"null\");\n             break;\n         case Token.THIS:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(\"this\");\n             break;\n         case Token.FALSE:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             cc.addConstant(\"false\");\n             break;\n         case Token.TRUE:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             cc.addConstant(\"true\");\n             break;\n         case Token.CONTINUE:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"continue\");\n             if (childCount \u003d\u003d 1) {\n                 if (!first.isLabelName()) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.DEBUGGER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(\"debugger\");\n             cc.endStatement();\n             break;\n         case Token.BREAK:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"break\");\n             if (childCount \u003d\u003d 1) {\n                 if (!first.isLabelName()) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.EXPR_RESULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first, Context.START_OF_EXPR);\n             cc.endStatement();\n             break;\n         case Token.NEW:\n             add(\"new \");\n             int precedence \u003d NodeUtil.precedence(type);\n             if (NodeUtil.containsType(first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n                 precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n             }\n             addExpr(first, precedence, Context.OTHER);\n             Node next \u003d first.getNext();\n             if (next !\u003d null) {\n                 add(\"(\");\n                 addList(next);\n                 add(\")\");\n             }\n             break;\n         case Token.STRING_KEY:\n             Preconditions.checkState(childCount \u003d\u003d 1, \"Object lit key must have 1 child\");\n             addJsString(n);\n             break;\n         case Token.STRING:\n             Preconditions.checkState(childCount \u003d\u003d 0, \"A string may not have children\");\n             addJsString(n);\n             break;\n         case Token.DELPROP:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"delete \");\n             add(first);\n             break;\n         case Token.OBJECTLIT:\n             {\n                 boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 add(\"{\");\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     if (c !\u003d first) {\n                         cc.listSeparator();\n                     }\n                     if (c.isGetterDef() || c.isSetterDef()) {\n                         add(c);\n                     } else {\n                         Preconditions.checkState(c.isStringKey());\n                         String key \u003d c.getString();\n                         if (!c.isQuotedString() \u0026\u0026 !(languageMode \u003d\u003d LanguageMode.ECMASCRIPT3 \u0026\u0026 TokenStream.isKeyword(key)) \u0026\u0026 TokenStream.isJSIdentifier(key) \u0026\u0026 NodeUtil.isLatin(key)) {\n                             add(key);\n                         } else {\n                             double d \u003d getSimpleNumber(key);\n                             if (!Double.isNaN(d)) {\n                                 cc.addNumber(d);\n                             } else {\n                                 addExpr(c, 1, Context.OTHER);\n                             }\n                         }\n                         add(\":\");\n                         addExpr(c.getFirstChild(), 1, Context.OTHER);\n                     }\n                 }\n                 add(\"}\");\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 break;\n             }\n         case Token.SWITCH:\n             add(\"switch(\");\n             add(first);\n             add(\")\");\n             cc.beginBlock();\n             addAllSiblings(first.getNext());\n             cc.endBlock(context \u003d\u003d Context.STATEMENT);\n             break;\n         case Token.CASE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"case \");\n             add(first);\n             addCaseBody(last);\n             break;\n         case Token.DEFAULT_CASE:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"default\");\n             addCaseBody(first);\n             break;\n         case Token.LABEL:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             if (!first.isLabelName()) {\n                 throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n             }\n             add(first);\n             add(\":\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\n             break;\n         case Token.CAST:\n             add(\"(\");\n             add(first);\n             add(\")\");\n             break;\n         default:\n             throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n     }\n     cc.endSourceMapping(n);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "42dbcc0d7086141c3f0e5a2091b23424c5d87538": {
      "type": "Ybodychange",
      "commitMessage": "Swap where we handle ES3 keyword property quoting from the IRFactory to the CodeGenerator so these properties will be properly type-checked and optimized. Also, in ES5 mode we no longer always quote object literal keys when they are an ES3 keyword.\n-------------\nCreated by MOE: http://code.google.com/p/moe-java\nMOE_MIGRATED_REVID\u003d48523831\n",
      "commitDate": "6/25/13, 4:15 PM",
      "commitName": "42dbcc0d7086141c3f0e5a2091b23424c5d87538",
      "commitAuthor": "Ben Lickly",
      "commitDateOld": "5/17/13, 5:50 PM",
      "commitNameOld": "c4f38043f0aa21e74c341f3056a0d9b556a44c3e",
      "commitAuthorOld": "Ben Lickly",
      "daysBetweenCommits": 38.93,
      "commitsBetweenForRepo": 77,
      "commitsBetweenForFile": 1,
      "actualSource": "void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n        return;\n    }\n    int type \u003d n.getType();\n    String opstr \u003d NodeUtil.opToStr(type);\n    int childCount \u003d n.getChildCount();\n    Node first \u003d n.getFirstChild();\n    Node last \u003d n.getLastChild();\n    if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n        Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n        int p \u003d NodeUtil.precedence(type);\n        Context rhsContext \u003d getContextForNoInOperator(context);\n        if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n            addExpr(first, p, context);\n            cc.addOp(opstr, true);\n            addExpr(last, p, rhsContext);\n        } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n            addExpr(first, p, context);\n            cc.addOp(opstr, true);\n            addExpr(last, p, rhsContext);\n        } else {\n            unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n        }\n        return;\n    }\n    cc.startSourceMapping(n);\n    switch(type) {\n        case Token.TRY:\n            {\n                Preconditions.checkState(first.getNext().isBlock() \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n                Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                add(\"try\");\n                add(first, Context.PRESERVE_BLOCK);\n                Node catchblock \u003d first.getNext().getFirstChild();\n                if (catchblock !\u003d null) {\n                    add(catchblock);\n                }\n                if (childCount \u003d\u003d 3) {\n                    add(\"finally\");\n                    add(last, Context.PRESERVE_BLOCK);\n                }\n                break;\n            }\n        case Token.CATCH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"catch(\");\n            add(first);\n            add(\")\");\n            add(last, Context.PRESERVE_BLOCK);\n            break;\n        case Token.THROW:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"throw\");\n            add(first);\n            cc.endStatement(true);\n            break;\n        case Token.RETURN:\n            add(\"return\");\n            if (childCount \u003d\u003d 1) {\n                add(first);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 0);\n            }\n            cc.endStatement();\n            break;\n        case Token.VAR:\n            if (first !\u003d null) {\n                add(\"var \");\n                addList(first, false, getContextForNoInOperator(context));\n            }\n            break;\n        case Token.LABEL_NAME:\n            Preconditions.checkState(!n.getString().isEmpty());\n            addIdentifier(n.getString());\n            break;\n        case Token.NAME:\n            if (first \u003d\u003d null || first.isEmpty()) {\n                addIdentifier(n.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                addIdentifier(n.getString());\n                cc.addOp(\"\u003d\", true);\n                if (first.isComma()) {\n                    addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n                } else {\n                    addExpr(first, 0, getContextForNoInOperator(context));\n                }\n            }\n            break;\n        case Token.ARRAYLIT:\n            add(\"[\");\n            addArrayList(first);\n            add(\"]\");\n            break;\n        case Token.PARAM_LIST:\n            add(\"(\");\n            addList(first);\n            add(\")\");\n            break;\n        case Token.COMMA:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            unrollBinaryOperator(n, Token.COMMA, \",\", context, getContextForNoInOperator(context), 0, 0);\n            break;\n        case Token.NUMBER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            cc.addNumber(n.getDouble());\n            break;\n        case Token.TYPEOF:\n        case Token.VOID:\n        case Token.NOT:\n        case Token.BITNOT:\n        case Token.POS:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n                break;\n            }\n        case Token.NEG:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                if (n.getFirstChild().isNumber()) {\n                    cc.addNumber(-n.getFirstChild().getDouble());\n                } else {\n                    cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                    addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n                }\n                break;\n            }\n        case Token.HOOK:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                int p \u003d NodeUtil.precedence(type);\n                addExpr(first, p + 1, context);\n                cc.addOp(\"?\", true);\n                addExpr(first.getNext(), 1, Context.OTHER);\n                cc.addOp(\":\", true);\n                addExpr(last, 1, Context.OTHER);\n                break;\n            }\n        case Token.REGEXP:\n            if (!first.isString() || !last.isString()) {\n                throw new Error(\"Expected children to be strings\");\n            }\n            String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n            if (childCount \u003d\u003d 2) {\n                add(regexp + last.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                add(regexp);\n            }\n            break;\n        case Token.FUNCTION:\n            if (n.getClass() !\u003d Node.class) {\n                throw new Error(\"Unexpected Node subclass.\");\n            }\n            Preconditions.checkState(childCount \u003d\u003d 3);\n            boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n            if (funcNeedsParens) {\n                add(\"(\");\n            }\n            add(\"function\");\n            add(first);\n            add(first.getNext());\n            add(last, Context.PRESERVE_BLOCK);\n            cc.endFunction(context \u003d\u003d Context.STATEMENT);\n            if (funcNeedsParens) {\n                add(\")\");\n            }\n            break;\n        case Token.GETTER_DEF:\n        case Token.SETTER_DEF:\n            Preconditions.checkState(n.getParent().isObjectLit());\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            Preconditions.checkState(first.isFunction());\n            Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n            if (type \u003d\u003d Token.GETTER_DEF) {\n                Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n                add(\"get \");\n            } else {\n                Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n                add(\"set \");\n            }\n            String name \u003d n.getString();\n            Node fn \u003d first;\n            Node parameters \u003d fn.getChildAtIndex(1);\n            Node body \u003d fn.getLastChild();\n            if (!n.isQuotedString() \u0026\u0026 TokenStream.isJSIdentifier(name) \u0026\u0026 NodeUtil.isLatin(name)) {\n                add(name);\n            } else {\n                double d \u003d getSimpleNumber(name);\n                if (!Double.isNaN(d)) {\n                    cc.addNumber(d);\n                } else {\n                    addJsString(n);\n                }\n            }\n            add(parameters);\n            add(body, Context.PRESERVE_BLOCK);\n            break;\n        case Token.SCRIPT:\n        case Token.BLOCK:\n            {\n                if (n.getClass() !\u003d Node.class) {\n                    throw new Error(\"Unexpected Node subclass.\");\n                }\n                boolean preserveBlock \u003d context \u003d\u003d Context.PRESERVE_BLOCK;\n                if (preserveBlock) {\n                    cc.beginBlock();\n                }\n                boolean preferLineBreaks \u003d type \u003d\u003d Token.SCRIPT || (type \u003d\u003d Token.BLOCK \u0026\u0026 !preserveBlock \u0026\u0026 n.getParent() !\u003d null \u0026\u0026 n.getParent().isScript());\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    add(c, Context.STATEMENT);\n                    if (c.isVar()) {\n                        cc.endStatement();\n                    }\n                    if (c.isFunction()) {\n                        cc.maybeLineBreak();\n                    }\n                    if (preferLineBreaks) {\n                        cc.notePreferredLineBreak();\n                    }\n                }\n                if (preserveBlock) {\n                    cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                }\n                break;\n            }\n        case Token.FOR:\n            if (childCount \u003d\u003d 4) {\n                add(\"for(\");\n                if (first.isVar()) {\n                    add(first, Context.IN_FOR_INIT_CLAUSE);\n                } else {\n                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                }\n                add(\";\");\n                add(first.getNext());\n                add(\";\");\n                add(first.getNext().getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                add(\"for(\");\n                add(first);\n                add(\"in\");\n                add(first.getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            }\n            break;\n        case Token.DO:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"do\");\n            addNonEmptyStatement(first, Context.OTHER, false);\n            add(\"while(\");\n            add(last);\n            add(\")\");\n            cc.endStatement();\n            break;\n        case Token.WHILE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"while(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.EMPTY:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            break;\n        case Token.GETPROP:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                Preconditions.checkState(last.isString(), \"Bad GETPROP: RHS should be STRING\");\n                boolean needsParens \u003d (first.isNumber());\n                if (needsParens) {\n                    add(\"(\");\n                }\n                addExpr(first, NodeUtil.precedence(type), context);\n                if (needsParens) {\n                    add(\")\");\n                }\n                if (this.languageMode \u003d\u003d LanguageMode.ECMASCRIPT3 \u0026\u0026 TokenStream.isKeyword(last.getString())) {\n                    add(\"[\");\n                    add(last);\n                    add(\"]\");\n                } else {\n                    add(\".\");\n                    addIdentifier(last.getString());\n                }\n                break;\n            }\n        case Token.GETELEM:\n            Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n            addExpr(first, NodeUtil.precedence(type), context);\n            add(\"[\");\n            add(first.getNext());\n            add(\"]\");\n            break;\n        case Token.WITH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"with(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.INC:\n        case Token.DEC:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                if (postProp !\u003d 0) {\n                    addExpr(first, NodeUtil.precedence(type), context);\n                    cc.addOp(o, false);\n                } else {\n                    cc.addOp(o, false);\n                    add(first);\n                }\n                break;\n            }\n        case Token.CALL:\n            if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) \u0026\u0026 NodeUtil.isGet(first)) {\n                add(\"(0,\");\n                addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n                add(\")\");\n            } else {\n                addExpr(first, NodeUtil.precedence(type), context);\n            }\n            add(\"(\");\n            addList(first.getNext());\n            add(\")\");\n            break;\n        case Token.IF:\n            boolean hasElse \u003d childCount \u003d\u003d 3;\n            boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n            if (ambiguousElseClause) {\n                cc.beginBlock();\n            }\n            add(\"if(\");\n            add(first);\n            add(\")\");\n            if (hasElse) {\n                addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                add(\"else\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n                Preconditions.checkState(childCount \u003d\u003d 2);\n            }\n            if (ambiguousElseClause) {\n                cc.endBlock();\n            }\n            break;\n        case Token.NULL:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            cc.addConstant(\"null\");\n            break;\n        case Token.THIS:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"this\");\n            break;\n        case Token.FALSE:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            cc.addConstant(\"false\");\n            break;\n        case Token.TRUE:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            cc.addConstant(\"true\");\n            break;\n        case Token.CONTINUE:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"continue\");\n            if (childCount \u003d\u003d 1) {\n                if (!first.isLabelName()) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.DEBUGGER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"debugger\");\n            cc.endStatement();\n            break;\n        case Token.BREAK:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"break\");\n            if (childCount \u003d\u003d 1) {\n                if (!first.isLabelName()) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.EXPR_RESULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first, Context.START_OF_EXPR);\n            cc.endStatement();\n            break;\n        case Token.NEW:\n            add(\"new \");\n            int precedence \u003d NodeUtil.precedence(type);\n            if (NodeUtil.containsType(first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n                precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n            }\n            addExpr(first, precedence, Context.OTHER);\n            Node next \u003d first.getNext();\n            if (next !\u003d null) {\n                add(\"(\");\n                addList(next);\n                add(\")\");\n            }\n            break;\n        case Token.STRING_KEY:\n            Preconditions.checkState(childCount \u003d\u003d 1, \"Object lit key must have 1 child\");\n            addJsString(n);\n            break;\n        case Token.STRING:\n            Preconditions.checkState(childCount \u003d\u003d 0, \"A string may not have children\");\n            addJsString(n);\n            break;\n        case Token.DELPROP:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"delete \");\n            add(first);\n            break;\n        case Token.OBJECTLIT:\n            {\n                boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                add(\"{\");\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    if (c !\u003d first) {\n                        cc.listSeparator();\n                    }\n                    if (c.isGetterDef() || c.isSetterDef()) {\n                        add(c);\n                    } else {\n                        Preconditions.checkState(c.isStringKey());\n                        String key \u003d c.getString();\n                        if (!c.isQuotedString() \u0026\u0026 !(languageMode \u003d\u003d LanguageMode.ECMASCRIPT3 \u0026\u0026 TokenStream.isKeyword(key)) \u0026\u0026 TokenStream.isJSIdentifier(key) \u0026\u0026 NodeUtil.isLatin(key)) {\n                            add(key);\n                        } else {\n                            double d \u003d getSimpleNumber(key);\n                            if (!Double.isNaN(d)) {\n                                cc.addNumber(d);\n                            } else {\n                                addExpr(c, 1, Context.OTHER);\n                            }\n                        }\n                        add(\":\");\n                        addExpr(c.getFirstChild(), 1, Context.OTHER);\n                    }\n                }\n                add(\"}\");\n                if (needsParens) {\n                    add(\")\");\n                }\n                break;\n            }\n        case Token.SWITCH:\n            add(\"switch(\");\n            add(first);\n            add(\")\");\n            cc.beginBlock();\n            addAllSiblings(first.getNext());\n            cc.endBlock(context \u003d\u003d Context.STATEMENT);\n            break;\n        case Token.CASE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"case \");\n            add(first);\n            addCaseBody(last);\n            break;\n        case Token.DEFAULT_CASE:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"default\");\n            addCaseBody(first);\n            break;\n        case Token.LABEL:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            if (!first.isLabelName()) {\n                throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n            }\n            add(first);\n            add(\":\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\n            break;\n        case Token.CAST:\n            add(\"(\");\n            add(first);\n            add(\")\");\n            break;\n        default:\n            throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n    cc.endSourceMapping(n);\n}",
      "path": "src/com/google/javascript/jscomp/CodeGenerator.java",
      "functionStartLine": 107,
      "functionName": "add",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,501 +1,507 @@\n void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n         return;\n     }\n     int type \u003d n.getType();\n     String opstr \u003d NodeUtil.opToStr(type);\n     int childCount \u003d n.getChildCount();\n     Node first \u003d n.getFirstChild();\n     Node last \u003d n.getLastChild();\n     if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n         Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n         int p \u003d NodeUtil.precedence(type);\n         Context rhsContext \u003d getContextForNoInOperator(context);\n         if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n             addExpr(first, p, context);\n             cc.addOp(opstr, true);\n             addExpr(last, p, rhsContext);\n         } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n             addExpr(first, p, context);\n             cc.addOp(opstr, true);\n             addExpr(last, p, rhsContext);\n         } else {\n             unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n         }\n         return;\n     }\n     cc.startSourceMapping(n);\n     switch(type) {\n         case Token.TRY:\n             {\n                 Preconditions.checkState(first.getNext().isBlock() \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n                 Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                 add(\"try\");\n                 add(first, Context.PRESERVE_BLOCK);\n                 Node catchblock \u003d first.getNext().getFirstChild();\n                 if (catchblock !\u003d null) {\n                     add(catchblock);\n                 }\n                 if (childCount \u003d\u003d 3) {\n                     add(\"finally\");\n                     add(last, Context.PRESERVE_BLOCK);\n                 }\n                 break;\n             }\n         case Token.CATCH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"catch(\");\n             add(first);\n             add(\")\");\n             add(last, Context.PRESERVE_BLOCK);\n             break;\n         case Token.THROW:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"throw\");\n             add(first);\n             cc.endStatement(true);\n             break;\n         case Token.RETURN:\n             add(\"return\");\n             if (childCount \u003d\u003d 1) {\n                 add(first);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 0);\n             }\n             cc.endStatement();\n             break;\n         case Token.VAR:\n             if (first !\u003d null) {\n                 add(\"var \");\n                 addList(first, false, getContextForNoInOperator(context));\n             }\n             break;\n         case Token.LABEL_NAME:\n             Preconditions.checkState(!n.getString().isEmpty());\n             addIdentifier(n.getString());\n             break;\n         case Token.NAME:\n             if (first \u003d\u003d null || first.isEmpty()) {\n                 addIdentifier(n.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 addIdentifier(n.getString());\n                 cc.addOp(\"\u003d\", true);\n                 if (first.isComma()) {\n                     addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n                 } else {\n                     addExpr(first, 0, getContextForNoInOperator(context));\n                 }\n             }\n             break;\n         case Token.ARRAYLIT:\n             add(\"[\");\n             addArrayList(first);\n             add(\"]\");\n             break;\n         case Token.PARAM_LIST:\n             add(\"(\");\n             addList(first);\n             add(\")\");\n             break;\n         case Token.COMMA:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             unrollBinaryOperator(n, Token.COMMA, \",\", context, getContextForNoInOperator(context), 0, 0);\n             break;\n         case Token.NUMBER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             cc.addNumber(n.getDouble());\n             break;\n         case Token.TYPEOF:\n         case Token.VOID:\n         case Token.NOT:\n         case Token.BITNOT:\n         case Token.POS:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                 addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n                 break;\n             }\n         case Token.NEG:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 if (n.getFirstChild().isNumber()) {\n                     cc.addNumber(-n.getFirstChild().getDouble());\n                 } else {\n                     cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                     addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n                 }\n                 break;\n             }\n         case Token.HOOK:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 int p \u003d NodeUtil.precedence(type);\n                 addExpr(first, p + 1, context);\n                 cc.addOp(\"?\", true);\n                 addExpr(first.getNext(), 1, Context.OTHER);\n                 cc.addOp(\":\", true);\n                 addExpr(last, 1, Context.OTHER);\n                 break;\n             }\n         case Token.REGEXP:\n             if (!first.isString() || !last.isString()) {\n                 throw new Error(\"Expected children to be strings\");\n             }\n             String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n             if (childCount \u003d\u003d 2) {\n                 add(regexp + last.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 add(regexp);\n             }\n             break;\n         case Token.FUNCTION:\n             if (n.getClass() !\u003d Node.class) {\n                 throw new Error(\"Unexpected Node subclass.\");\n             }\n             Preconditions.checkState(childCount \u003d\u003d 3);\n             boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n             if (funcNeedsParens) {\n                 add(\"(\");\n             }\n             add(\"function\");\n             add(first);\n             add(first.getNext());\n             add(last, Context.PRESERVE_BLOCK);\n             cc.endFunction(context \u003d\u003d Context.STATEMENT);\n             if (funcNeedsParens) {\n                 add(\")\");\n             }\n             break;\n         case Token.GETTER_DEF:\n         case Token.SETTER_DEF:\n             Preconditions.checkState(n.getParent().isObjectLit());\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             Preconditions.checkState(first.isFunction());\n             Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n             if (type \u003d\u003d Token.GETTER_DEF) {\n                 Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n                 add(\"get \");\n             } else {\n                 Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n                 add(\"set \");\n             }\n             String name \u003d n.getString();\n             Node fn \u003d first;\n             Node parameters \u003d fn.getChildAtIndex(1);\n             Node body \u003d fn.getLastChild();\n             if (!n.isQuotedString() \u0026\u0026 TokenStream.isJSIdentifier(name) \u0026\u0026 NodeUtil.isLatin(name)) {\n                 add(name);\n             } else {\n                 double d \u003d getSimpleNumber(name);\n                 if (!Double.isNaN(d)) {\n                     cc.addNumber(d);\n                 } else {\n                     addJsString(n);\n                 }\n             }\n             add(parameters);\n             add(body, Context.PRESERVE_BLOCK);\n             break;\n         case Token.SCRIPT:\n         case Token.BLOCK:\n             {\n                 if (n.getClass() !\u003d Node.class) {\n                     throw new Error(\"Unexpected Node subclass.\");\n                 }\n                 boolean preserveBlock \u003d context \u003d\u003d Context.PRESERVE_BLOCK;\n                 if (preserveBlock) {\n                     cc.beginBlock();\n                 }\n                 boolean preferLineBreaks \u003d type \u003d\u003d Token.SCRIPT || (type \u003d\u003d Token.BLOCK \u0026\u0026 !preserveBlock \u0026\u0026 n.getParent() !\u003d null \u0026\u0026 n.getParent().isScript());\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     add(c, Context.STATEMENT);\n                     if (c.isVar()) {\n                         cc.endStatement();\n                     }\n                     if (c.isFunction()) {\n                         cc.maybeLineBreak();\n                     }\n                     if (preferLineBreaks) {\n                         cc.notePreferredLineBreak();\n                     }\n                 }\n                 if (preserveBlock) {\n                     cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                 }\n                 break;\n             }\n         case Token.FOR:\n             if (childCount \u003d\u003d 4) {\n                 add(\"for(\");\n                 if (first.isVar()) {\n                     add(first, Context.IN_FOR_INIT_CLAUSE);\n                 } else {\n                     addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                 }\n                 add(\";\");\n                 add(first.getNext());\n                 add(\";\");\n                 add(first.getNext().getNext());\n                 add(\")\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 add(\"for(\");\n                 add(first);\n                 add(\"in\");\n                 add(first.getNext());\n                 add(\")\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             }\n             break;\n         case Token.DO:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"do\");\n             addNonEmptyStatement(first, Context.OTHER, false);\n             add(\"while(\");\n             add(last);\n             add(\")\");\n             cc.endStatement();\n             break;\n         case Token.WHILE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"while(\");\n             add(first);\n             add(\")\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.EMPTY:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             break;\n         case Token.GETPROP:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                 Preconditions.checkState(last.isString(), \"Bad GETPROP: RHS should be STRING\");\n                 boolean needsParens \u003d (first.isNumber());\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 addExpr(first, NodeUtil.precedence(type), context);\n                 if (needsParens) {\n                     add(\")\");\n                 }\n-                add(\".\");\n-                addIdentifier(last.getString());\n+                if (this.languageMode \u003d\u003d LanguageMode.ECMASCRIPT3 \u0026\u0026 TokenStream.isKeyword(last.getString())) {\n+                    add(\"[\");\n+                    add(last);\n+                    add(\"]\");\n+                } else {\n+                    add(\".\");\n+                    addIdentifier(last.getString());\n+                }\n                 break;\n             }\n         case Token.GETELEM:\n             Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n             addExpr(first, NodeUtil.precedence(type), context);\n             add(\"[\");\n             add(first.getNext());\n             add(\"]\");\n             break;\n         case Token.WITH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"with(\");\n             add(first);\n             add(\")\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.INC:\n         case Token.DEC:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                 int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                 if (postProp !\u003d 0) {\n                     addExpr(first, NodeUtil.precedence(type), context);\n                     cc.addOp(o, false);\n                 } else {\n                     cc.addOp(o, false);\n                     add(first);\n                 }\n                 break;\n             }\n         case Token.CALL:\n             if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) \u0026\u0026 NodeUtil.isGet(first)) {\n                 add(\"(0,\");\n                 addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n                 add(\")\");\n             } else {\n                 addExpr(first, NodeUtil.precedence(type), context);\n             }\n             add(\"(\");\n             addList(first.getNext());\n             add(\")\");\n             break;\n         case Token.IF:\n             boolean hasElse \u003d childCount \u003d\u003d 3;\n             boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n             if (ambiguousElseClause) {\n                 cc.beginBlock();\n             }\n             add(\"if(\");\n             add(first);\n             add(\")\");\n             if (hasElse) {\n                 addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                 add(\"else\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n                 Preconditions.checkState(childCount \u003d\u003d 2);\n             }\n             if (ambiguousElseClause) {\n                 cc.endBlock();\n             }\n             break;\n         case Token.NULL:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             cc.addConstant(\"null\");\n             break;\n         case Token.THIS:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(\"this\");\n             break;\n         case Token.FALSE:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             cc.addConstant(\"false\");\n             break;\n         case Token.TRUE:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             cc.addConstant(\"true\");\n             break;\n         case Token.CONTINUE:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"continue\");\n             if (childCount \u003d\u003d 1) {\n                 if (!first.isLabelName()) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.DEBUGGER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(\"debugger\");\n             cc.endStatement();\n             break;\n         case Token.BREAK:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"break\");\n             if (childCount \u003d\u003d 1) {\n                 if (!first.isLabelName()) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.EXPR_RESULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first, Context.START_OF_EXPR);\n             cc.endStatement();\n             break;\n         case Token.NEW:\n             add(\"new \");\n             int precedence \u003d NodeUtil.precedence(type);\n             if (NodeUtil.containsType(first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n                 precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n             }\n             addExpr(first, precedence, Context.OTHER);\n             Node next \u003d first.getNext();\n             if (next !\u003d null) {\n                 add(\"(\");\n                 addList(next);\n                 add(\")\");\n             }\n             break;\n         case Token.STRING_KEY:\n             Preconditions.checkState(childCount \u003d\u003d 1, \"Object lit key must have 1 child\");\n             addJsString(n);\n             break;\n         case Token.STRING:\n             Preconditions.checkState(childCount \u003d\u003d 0, \"A string may not have children\");\n             addJsString(n);\n             break;\n         case Token.DELPROP:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"delete \");\n             add(first);\n             break;\n         case Token.OBJECTLIT:\n             {\n                 boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 add(\"{\");\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     if (c !\u003d first) {\n                         cc.listSeparator();\n                     }\n                     if (c.isGetterDef() || c.isSetterDef()) {\n                         add(c);\n                     } else {\n                         Preconditions.checkState(c.isStringKey());\n                         String key \u003d c.getString();\n-                        if (!c.isQuotedString() \u0026\u0026 !TokenStream.isKeyword(key) \u0026\u0026 TokenStream.isJSIdentifier(key) \u0026\u0026 NodeUtil.isLatin(key)) {\n+                        if (!c.isQuotedString() \u0026\u0026 !(languageMode \u003d\u003d LanguageMode.ECMASCRIPT3 \u0026\u0026 TokenStream.isKeyword(key)) \u0026\u0026 TokenStream.isJSIdentifier(key) \u0026\u0026 NodeUtil.isLatin(key)) {\n                             add(key);\n                         } else {\n                             double d \u003d getSimpleNumber(key);\n                             if (!Double.isNaN(d)) {\n                                 cc.addNumber(d);\n                             } else {\n                                 addExpr(c, 1, Context.OTHER);\n                             }\n                         }\n                         add(\":\");\n                         addExpr(c.getFirstChild(), 1, Context.OTHER);\n                     }\n                 }\n                 add(\"}\");\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 break;\n             }\n         case Token.SWITCH:\n             add(\"switch(\");\n             add(first);\n             add(\")\");\n             cc.beginBlock();\n             addAllSiblings(first.getNext());\n             cc.endBlock(context \u003d\u003d Context.STATEMENT);\n             break;\n         case Token.CASE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"case \");\n             add(first);\n             addCaseBody(last);\n             break;\n         case Token.DEFAULT_CASE:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"default\");\n             addCaseBody(first);\n             break;\n         case Token.LABEL:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             if (!first.isLabelName()) {\n                 throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n             }\n             add(first);\n             add(\":\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\n             break;\n         case Token.CAST:\n             add(\"(\");\n             add(first);\n             add(\")\");\n             break;\n         default:\n             throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n     }\n     cc.endSourceMapping(n);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c4f38043f0aa21e74c341f3056a0d9b556a44c3e": {
      "type": "Ybodychange",
      "commitMessage": "Fix bug with IN inside FOR in CodeGenerator.\n\nThis was exposed by the new MinimizeConditions algorithm.\n-------------\nCreated by MOE: http://code.google.com/p/moe-java\nMOE_MIGRATED_REVID\u003d46735852\n",
      "commitDate": "5/17/13, 5:50 PM",
      "commitName": "c4f38043f0aa21e74c341f3056a0d9b556a44c3e",
      "commitAuthor": "Ben Lickly",
      "commitDateOld": "3/20/13, 9:48 AM",
      "commitNameOld": "f423b0e9d4b2c0f3f74b3850dd5a35fd89ebc8a5",
      "commitAuthorOld": "Ben Lickly",
      "daysBetweenCommits": 58.33,
      "commitsBetweenForRepo": 105,
      "commitsBetweenForFile": 1,
      "actualSource": "void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n        return;\n    }\n    int type \u003d n.getType();\n    String opstr \u003d NodeUtil.opToStr(type);\n    int childCount \u003d n.getChildCount();\n    Node first \u003d n.getFirstChild();\n    Node last \u003d n.getLastChild();\n    if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n        Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n        int p \u003d NodeUtil.precedence(type);\n        Context rhsContext \u003d getContextForNoInOperator(context);\n        if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n            addExpr(first, p, context);\n            cc.addOp(opstr, true);\n            addExpr(last, p, rhsContext);\n        } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n            addExpr(first, p, context);\n            cc.addOp(opstr, true);\n            addExpr(last, p, rhsContext);\n        } else {\n            unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n        }\n        return;\n    }\n    cc.startSourceMapping(n);\n    switch(type) {\n        case Token.TRY:\n            {\n                Preconditions.checkState(first.getNext().isBlock() \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n                Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                add(\"try\");\n                add(first, Context.PRESERVE_BLOCK);\n                Node catchblock \u003d first.getNext().getFirstChild();\n                if (catchblock !\u003d null) {\n                    add(catchblock);\n                }\n                if (childCount \u003d\u003d 3) {\n                    add(\"finally\");\n                    add(last, Context.PRESERVE_BLOCK);\n                }\n                break;\n            }\n        case Token.CATCH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"catch(\");\n            add(first);\n            add(\")\");\n            add(last, Context.PRESERVE_BLOCK);\n            break;\n        case Token.THROW:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"throw\");\n            add(first);\n            cc.endStatement(true);\n            break;\n        case Token.RETURN:\n            add(\"return\");\n            if (childCount \u003d\u003d 1) {\n                add(first);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 0);\n            }\n            cc.endStatement();\n            break;\n        case Token.VAR:\n            if (first !\u003d null) {\n                add(\"var \");\n                addList(first, false, getContextForNoInOperator(context));\n            }\n            break;\n        case Token.LABEL_NAME:\n            Preconditions.checkState(!n.getString().isEmpty());\n            addIdentifier(n.getString());\n            break;\n        case Token.NAME:\n            if (first \u003d\u003d null || first.isEmpty()) {\n                addIdentifier(n.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                addIdentifier(n.getString());\n                cc.addOp(\"\u003d\", true);\n                if (first.isComma()) {\n                    addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n                } else {\n                    addExpr(first, 0, getContextForNoInOperator(context));\n                }\n            }\n            break;\n        case Token.ARRAYLIT:\n            add(\"[\");\n            addArrayList(first);\n            add(\"]\");\n            break;\n        case Token.PARAM_LIST:\n            add(\"(\");\n            addList(first);\n            add(\")\");\n            break;\n        case Token.COMMA:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            unrollBinaryOperator(n, Token.COMMA, \",\", context, getContextForNoInOperator(context), 0, 0);\n            break;\n        case Token.NUMBER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            cc.addNumber(n.getDouble());\n            break;\n        case Token.TYPEOF:\n        case Token.VOID:\n        case Token.NOT:\n        case Token.BITNOT:\n        case Token.POS:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n                break;\n            }\n        case Token.NEG:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                if (n.getFirstChild().isNumber()) {\n                    cc.addNumber(-n.getFirstChild().getDouble());\n                } else {\n                    cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                    addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n                }\n                break;\n            }\n        case Token.HOOK:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                int p \u003d NodeUtil.precedence(type);\n                addExpr(first, p + 1, context);\n                cc.addOp(\"?\", true);\n                addExpr(first.getNext(), 1, Context.OTHER);\n                cc.addOp(\":\", true);\n                addExpr(last, 1, Context.OTHER);\n                break;\n            }\n        case Token.REGEXP:\n            if (!first.isString() || !last.isString()) {\n                throw new Error(\"Expected children to be strings\");\n            }\n            String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n            if (childCount \u003d\u003d 2) {\n                add(regexp + last.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                add(regexp);\n            }\n            break;\n        case Token.FUNCTION:\n            if (n.getClass() !\u003d Node.class) {\n                throw new Error(\"Unexpected Node subclass.\");\n            }\n            Preconditions.checkState(childCount \u003d\u003d 3);\n            boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n            if (funcNeedsParens) {\n                add(\"(\");\n            }\n            add(\"function\");\n            add(first);\n            add(first.getNext());\n            add(last, Context.PRESERVE_BLOCK);\n            cc.endFunction(context \u003d\u003d Context.STATEMENT);\n            if (funcNeedsParens) {\n                add(\")\");\n            }\n            break;\n        case Token.GETTER_DEF:\n        case Token.SETTER_DEF:\n            Preconditions.checkState(n.getParent().isObjectLit());\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            Preconditions.checkState(first.isFunction());\n            Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n            if (type \u003d\u003d Token.GETTER_DEF) {\n                Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n                add(\"get \");\n            } else {\n                Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n                add(\"set \");\n            }\n            String name \u003d n.getString();\n            Node fn \u003d first;\n            Node parameters \u003d fn.getChildAtIndex(1);\n            Node body \u003d fn.getLastChild();\n            if (!n.isQuotedString() \u0026\u0026 TokenStream.isJSIdentifier(name) \u0026\u0026 NodeUtil.isLatin(name)) {\n                add(name);\n            } else {\n                double d \u003d getSimpleNumber(name);\n                if (!Double.isNaN(d)) {\n                    cc.addNumber(d);\n                } else {\n                    addJsString(n);\n                }\n            }\n            add(parameters);\n            add(body, Context.PRESERVE_BLOCK);\n            break;\n        case Token.SCRIPT:\n        case Token.BLOCK:\n            {\n                if (n.getClass() !\u003d Node.class) {\n                    throw new Error(\"Unexpected Node subclass.\");\n                }\n                boolean preserveBlock \u003d context \u003d\u003d Context.PRESERVE_BLOCK;\n                if (preserveBlock) {\n                    cc.beginBlock();\n                }\n                boolean preferLineBreaks \u003d type \u003d\u003d Token.SCRIPT || (type \u003d\u003d Token.BLOCK \u0026\u0026 !preserveBlock \u0026\u0026 n.getParent() !\u003d null \u0026\u0026 n.getParent().isScript());\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    add(c, Context.STATEMENT);\n                    if (c.isVar()) {\n                        cc.endStatement();\n                    }\n                    if (c.isFunction()) {\n                        cc.maybeLineBreak();\n                    }\n                    if (preferLineBreaks) {\n                        cc.notePreferredLineBreak();\n                    }\n                }\n                if (preserveBlock) {\n                    cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                }\n                break;\n            }\n        case Token.FOR:\n            if (childCount \u003d\u003d 4) {\n                add(\"for(\");\n                if (first.isVar()) {\n                    add(first, Context.IN_FOR_INIT_CLAUSE);\n                } else {\n                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                }\n                add(\";\");\n                add(first.getNext());\n                add(\";\");\n                add(first.getNext().getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                add(\"for(\");\n                add(first);\n                add(\"in\");\n                add(first.getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            }\n            break;\n        case Token.DO:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"do\");\n            addNonEmptyStatement(first, Context.OTHER, false);\n            add(\"while(\");\n            add(last);\n            add(\")\");\n            cc.endStatement();\n            break;\n        case Token.WHILE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"while(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.EMPTY:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            break;\n        case Token.GETPROP:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                Preconditions.checkState(last.isString(), \"Bad GETPROP: RHS should be STRING\");\n                boolean needsParens \u003d (first.isNumber());\n                if (needsParens) {\n                    add(\"(\");\n                }\n                addExpr(first, NodeUtil.precedence(type), context);\n                if (needsParens) {\n                    add(\")\");\n                }\n                add(\".\");\n                addIdentifier(last.getString());\n                break;\n            }\n        case Token.GETELEM:\n            Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n            addExpr(first, NodeUtil.precedence(type), context);\n            add(\"[\");\n            add(first.getNext());\n            add(\"]\");\n            break;\n        case Token.WITH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"with(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.INC:\n        case Token.DEC:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                if (postProp !\u003d 0) {\n                    addExpr(first, NodeUtil.precedence(type), context);\n                    cc.addOp(o, false);\n                } else {\n                    cc.addOp(o, false);\n                    add(first);\n                }\n                break;\n            }\n        case Token.CALL:\n            if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) \u0026\u0026 NodeUtil.isGet(first)) {\n                add(\"(0,\");\n                addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n                add(\")\");\n            } else {\n                addExpr(first, NodeUtil.precedence(type), context);\n            }\n            add(\"(\");\n            addList(first.getNext());\n            add(\")\");\n            break;\n        case Token.IF:\n            boolean hasElse \u003d childCount \u003d\u003d 3;\n            boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n            if (ambiguousElseClause) {\n                cc.beginBlock();\n            }\n            add(\"if(\");\n            add(first);\n            add(\")\");\n            if (hasElse) {\n                addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                add(\"else\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n                Preconditions.checkState(childCount \u003d\u003d 2);\n            }\n            if (ambiguousElseClause) {\n                cc.endBlock();\n            }\n            break;\n        case Token.NULL:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            cc.addConstant(\"null\");\n            break;\n        case Token.THIS:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"this\");\n            break;\n        case Token.FALSE:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            cc.addConstant(\"false\");\n            break;\n        case Token.TRUE:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            cc.addConstant(\"true\");\n            break;\n        case Token.CONTINUE:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"continue\");\n            if (childCount \u003d\u003d 1) {\n                if (!first.isLabelName()) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.DEBUGGER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"debugger\");\n            cc.endStatement();\n            break;\n        case Token.BREAK:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"break\");\n            if (childCount \u003d\u003d 1) {\n                if (!first.isLabelName()) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.EXPR_RESULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first, Context.START_OF_EXPR);\n            cc.endStatement();\n            break;\n        case Token.NEW:\n            add(\"new \");\n            int precedence \u003d NodeUtil.precedence(type);\n            if (NodeUtil.containsType(first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n                precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n            }\n            addExpr(first, precedence, Context.OTHER);\n            Node next \u003d first.getNext();\n            if (next !\u003d null) {\n                add(\"(\");\n                addList(next);\n                add(\")\");\n            }\n            break;\n        case Token.STRING_KEY:\n            Preconditions.checkState(childCount \u003d\u003d 1, \"Object lit key must have 1 child\");\n            addJsString(n);\n            break;\n        case Token.STRING:\n            Preconditions.checkState(childCount \u003d\u003d 0, \"A string may not have children\");\n            addJsString(n);\n            break;\n        case Token.DELPROP:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"delete \");\n            add(first);\n            break;\n        case Token.OBJECTLIT:\n            {\n                boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                add(\"{\");\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    if (c !\u003d first) {\n                        cc.listSeparator();\n                    }\n                    if (c.isGetterDef() || c.isSetterDef()) {\n                        add(c);\n                    } else {\n                        Preconditions.checkState(c.isStringKey());\n                        String key \u003d c.getString();\n                        if (!c.isQuotedString() \u0026\u0026 !TokenStream.isKeyword(key) \u0026\u0026 TokenStream.isJSIdentifier(key) \u0026\u0026 NodeUtil.isLatin(key)) {\n                            add(key);\n                        } else {\n                            double d \u003d getSimpleNumber(key);\n                            if (!Double.isNaN(d)) {\n                                cc.addNumber(d);\n                            } else {\n                                addExpr(c, 1, Context.OTHER);\n                            }\n                        }\n                        add(\":\");\n                        addExpr(c.getFirstChild(), 1, Context.OTHER);\n                    }\n                }\n                add(\"}\");\n                if (needsParens) {\n                    add(\")\");\n                }\n                break;\n            }\n        case Token.SWITCH:\n            add(\"switch(\");\n            add(first);\n            add(\")\");\n            cc.beginBlock();\n            addAllSiblings(first.getNext());\n            cc.endBlock(context \u003d\u003d Context.STATEMENT);\n            break;\n        case Token.CASE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"case \");\n            add(first);\n            addCaseBody(last);\n            break;\n        case Token.DEFAULT_CASE:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"default\");\n            addCaseBody(first);\n            break;\n        case Token.LABEL:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            if (!first.isLabelName()) {\n                throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n            }\n            add(first);\n            add(\":\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\n            break;\n        case Token.CAST:\n            add(\"(\");\n            add(first);\n            add(\")\");\n            break;\n        default:\n            throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n    cc.endSourceMapping(n);\n}",
      "path": "src/com/google/javascript/jscomp/CodeGenerator.java",
      "functionStartLine": 103,
      "functionName": "add",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,501 +1,501 @@\n void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n         return;\n     }\n     int type \u003d n.getType();\n     String opstr \u003d NodeUtil.opToStr(type);\n     int childCount \u003d n.getChildCount();\n     Node first \u003d n.getFirstChild();\n     Node last \u003d n.getLastChild();\n     if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n         Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n         int p \u003d NodeUtil.precedence(type);\n         Context rhsContext \u003d getContextForNoInOperator(context);\n         if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n             addExpr(first, p, context);\n             cc.addOp(opstr, true);\n             addExpr(last, p, rhsContext);\n         } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n             addExpr(first, p, context);\n             cc.addOp(opstr, true);\n             addExpr(last, p, rhsContext);\n         } else {\n             unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n         }\n         return;\n     }\n     cc.startSourceMapping(n);\n     switch(type) {\n         case Token.TRY:\n             {\n                 Preconditions.checkState(first.getNext().isBlock() \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n                 Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                 add(\"try\");\n                 add(first, Context.PRESERVE_BLOCK);\n                 Node catchblock \u003d first.getNext().getFirstChild();\n                 if (catchblock !\u003d null) {\n                     add(catchblock);\n                 }\n                 if (childCount \u003d\u003d 3) {\n                     add(\"finally\");\n                     add(last, Context.PRESERVE_BLOCK);\n                 }\n                 break;\n             }\n         case Token.CATCH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"catch(\");\n             add(first);\n             add(\")\");\n             add(last, Context.PRESERVE_BLOCK);\n             break;\n         case Token.THROW:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"throw\");\n             add(first);\n             cc.endStatement(true);\n             break;\n         case Token.RETURN:\n             add(\"return\");\n             if (childCount \u003d\u003d 1) {\n                 add(first);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 0);\n             }\n             cc.endStatement();\n             break;\n         case Token.VAR:\n             if (first !\u003d null) {\n                 add(\"var \");\n                 addList(first, false, getContextForNoInOperator(context));\n             }\n             break;\n         case Token.LABEL_NAME:\n             Preconditions.checkState(!n.getString().isEmpty());\n             addIdentifier(n.getString());\n             break;\n         case Token.NAME:\n             if (first \u003d\u003d null || first.isEmpty()) {\n                 addIdentifier(n.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 addIdentifier(n.getString());\n                 cc.addOp(\"\u003d\", true);\n                 if (first.isComma()) {\n                     addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n                 } else {\n                     addExpr(first, 0, getContextForNoInOperator(context));\n                 }\n             }\n             break;\n         case Token.ARRAYLIT:\n             add(\"[\");\n             addArrayList(first);\n             add(\"]\");\n             break;\n         case Token.PARAM_LIST:\n             add(\"(\");\n             addList(first);\n             add(\")\");\n             break;\n         case Token.COMMA:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n-            unrollBinaryOperator(n, Token.COMMA, \",\", context, Context.OTHER, 0, 0);\n+            unrollBinaryOperator(n, Token.COMMA, \",\", context, getContextForNoInOperator(context), 0, 0);\n             break;\n         case Token.NUMBER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             cc.addNumber(n.getDouble());\n             break;\n         case Token.TYPEOF:\n         case Token.VOID:\n         case Token.NOT:\n         case Token.BITNOT:\n         case Token.POS:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                 addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n                 break;\n             }\n         case Token.NEG:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 if (n.getFirstChild().isNumber()) {\n                     cc.addNumber(-n.getFirstChild().getDouble());\n                 } else {\n                     cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                     addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n                 }\n                 break;\n             }\n         case Token.HOOK:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 int p \u003d NodeUtil.precedence(type);\n                 addExpr(first, p + 1, context);\n                 cc.addOp(\"?\", true);\n                 addExpr(first.getNext(), 1, Context.OTHER);\n                 cc.addOp(\":\", true);\n                 addExpr(last, 1, Context.OTHER);\n                 break;\n             }\n         case Token.REGEXP:\n             if (!first.isString() || !last.isString()) {\n                 throw new Error(\"Expected children to be strings\");\n             }\n             String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n             if (childCount \u003d\u003d 2) {\n                 add(regexp + last.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 add(regexp);\n             }\n             break;\n         case Token.FUNCTION:\n             if (n.getClass() !\u003d Node.class) {\n                 throw new Error(\"Unexpected Node subclass.\");\n             }\n             Preconditions.checkState(childCount \u003d\u003d 3);\n             boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n             if (funcNeedsParens) {\n                 add(\"(\");\n             }\n             add(\"function\");\n             add(first);\n             add(first.getNext());\n             add(last, Context.PRESERVE_BLOCK);\n             cc.endFunction(context \u003d\u003d Context.STATEMENT);\n             if (funcNeedsParens) {\n                 add(\")\");\n             }\n             break;\n         case Token.GETTER_DEF:\n         case Token.SETTER_DEF:\n             Preconditions.checkState(n.getParent().isObjectLit());\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             Preconditions.checkState(first.isFunction());\n             Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n             if (type \u003d\u003d Token.GETTER_DEF) {\n                 Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n                 add(\"get \");\n             } else {\n                 Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n                 add(\"set \");\n             }\n             String name \u003d n.getString();\n             Node fn \u003d first;\n             Node parameters \u003d fn.getChildAtIndex(1);\n             Node body \u003d fn.getLastChild();\n             if (!n.isQuotedString() \u0026\u0026 TokenStream.isJSIdentifier(name) \u0026\u0026 NodeUtil.isLatin(name)) {\n                 add(name);\n             } else {\n                 double d \u003d getSimpleNumber(name);\n                 if (!Double.isNaN(d)) {\n                     cc.addNumber(d);\n                 } else {\n                     addJsString(n);\n                 }\n             }\n             add(parameters);\n             add(body, Context.PRESERVE_BLOCK);\n             break;\n         case Token.SCRIPT:\n         case Token.BLOCK:\n             {\n                 if (n.getClass() !\u003d Node.class) {\n                     throw new Error(\"Unexpected Node subclass.\");\n                 }\n                 boolean preserveBlock \u003d context \u003d\u003d Context.PRESERVE_BLOCK;\n                 if (preserveBlock) {\n                     cc.beginBlock();\n                 }\n                 boolean preferLineBreaks \u003d type \u003d\u003d Token.SCRIPT || (type \u003d\u003d Token.BLOCK \u0026\u0026 !preserveBlock \u0026\u0026 n.getParent() !\u003d null \u0026\u0026 n.getParent().isScript());\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     add(c, Context.STATEMENT);\n                     if (c.isVar()) {\n                         cc.endStatement();\n                     }\n                     if (c.isFunction()) {\n                         cc.maybeLineBreak();\n                     }\n                     if (preferLineBreaks) {\n                         cc.notePreferredLineBreak();\n                     }\n                 }\n                 if (preserveBlock) {\n                     cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                 }\n                 break;\n             }\n         case Token.FOR:\n             if (childCount \u003d\u003d 4) {\n                 add(\"for(\");\n                 if (first.isVar()) {\n                     add(first, Context.IN_FOR_INIT_CLAUSE);\n                 } else {\n                     addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                 }\n                 add(\";\");\n                 add(first.getNext());\n                 add(\";\");\n                 add(first.getNext().getNext());\n                 add(\")\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 add(\"for(\");\n                 add(first);\n                 add(\"in\");\n                 add(first.getNext());\n                 add(\")\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             }\n             break;\n         case Token.DO:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"do\");\n             addNonEmptyStatement(first, Context.OTHER, false);\n             add(\"while(\");\n             add(last);\n             add(\")\");\n             cc.endStatement();\n             break;\n         case Token.WHILE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"while(\");\n             add(first);\n             add(\")\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.EMPTY:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             break;\n         case Token.GETPROP:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                 Preconditions.checkState(last.isString(), \"Bad GETPROP: RHS should be STRING\");\n                 boolean needsParens \u003d (first.isNumber());\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 addExpr(first, NodeUtil.precedence(type), context);\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 add(\".\");\n                 addIdentifier(last.getString());\n                 break;\n             }\n         case Token.GETELEM:\n             Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n             addExpr(first, NodeUtil.precedence(type), context);\n             add(\"[\");\n             add(first.getNext());\n             add(\"]\");\n             break;\n         case Token.WITH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"with(\");\n             add(first);\n             add(\")\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.INC:\n         case Token.DEC:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                 int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                 if (postProp !\u003d 0) {\n                     addExpr(first, NodeUtil.precedence(type), context);\n                     cc.addOp(o, false);\n                 } else {\n                     cc.addOp(o, false);\n                     add(first);\n                 }\n                 break;\n             }\n         case Token.CALL:\n             if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) \u0026\u0026 NodeUtil.isGet(first)) {\n                 add(\"(0,\");\n                 addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n                 add(\")\");\n             } else {\n                 addExpr(first, NodeUtil.precedence(type), context);\n             }\n             add(\"(\");\n             addList(first.getNext());\n             add(\")\");\n             break;\n         case Token.IF:\n             boolean hasElse \u003d childCount \u003d\u003d 3;\n             boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n             if (ambiguousElseClause) {\n                 cc.beginBlock();\n             }\n             add(\"if(\");\n             add(first);\n             add(\")\");\n             if (hasElse) {\n                 addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                 add(\"else\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n                 Preconditions.checkState(childCount \u003d\u003d 2);\n             }\n             if (ambiguousElseClause) {\n                 cc.endBlock();\n             }\n             break;\n         case Token.NULL:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             cc.addConstant(\"null\");\n             break;\n         case Token.THIS:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(\"this\");\n             break;\n         case Token.FALSE:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             cc.addConstant(\"false\");\n             break;\n         case Token.TRUE:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             cc.addConstant(\"true\");\n             break;\n         case Token.CONTINUE:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"continue\");\n             if (childCount \u003d\u003d 1) {\n                 if (!first.isLabelName()) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.DEBUGGER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(\"debugger\");\n             cc.endStatement();\n             break;\n         case Token.BREAK:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"break\");\n             if (childCount \u003d\u003d 1) {\n                 if (!first.isLabelName()) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.EXPR_RESULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first, Context.START_OF_EXPR);\n             cc.endStatement();\n             break;\n         case Token.NEW:\n             add(\"new \");\n             int precedence \u003d NodeUtil.precedence(type);\n             if (NodeUtil.containsType(first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n                 precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n             }\n             addExpr(first, precedence, Context.OTHER);\n             Node next \u003d first.getNext();\n             if (next !\u003d null) {\n                 add(\"(\");\n                 addList(next);\n                 add(\")\");\n             }\n             break;\n         case Token.STRING_KEY:\n             Preconditions.checkState(childCount \u003d\u003d 1, \"Object lit key must have 1 child\");\n             addJsString(n);\n             break;\n         case Token.STRING:\n             Preconditions.checkState(childCount \u003d\u003d 0, \"A string may not have children\");\n             addJsString(n);\n             break;\n         case Token.DELPROP:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"delete \");\n             add(first);\n             break;\n         case Token.OBJECTLIT:\n             {\n                 boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 add(\"{\");\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     if (c !\u003d first) {\n                         cc.listSeparator();\n                     }\n                     if (c.isGetterDef() || c.isSetterDef()) {\n                         add(c);\n                     } else {\n                         Preconditions.checkState(c.isStringKey());\n                         String key \u003d c.getString();\n                         if (!c.isQuotedString() \u0026\u0026 !TokenStream.isKeyword(key) \u0026\u0026 TokenStream.isJSIdentifier(key) \u0026\u0026 NodeUtil.isLatin(key)) {\n                             add(key);\n                         } else {\n                             double d \u003d getSimpleNumber(key);\n                             if (!Double.isNaN(d)) {\n                                 cc.addNumber(d);\n                             } else {\n                                 addExpr(c, 1, Context.OTHER);\n                             }\n                         }\n                         add(\":\");\n                         addExpr(c.getFirstChild(), 1, Context.OTHER);\n                     }\n                 }\n                 add(\"}\");\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 break;\n             }\n         case Token.SWITCH:\n             add(\"switch(\");\n             add(first);\n             add(\")\");\n             cc.beginBlock();\n             addAllSiblings(first.getNext());\n             cc.endBlock(context \u003d\u003d Context.STATEMENT);\n             break;\n         case Token.CASE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"case \");\n             add(first);\n             addCaseBody(last);\n             break;\n         case Token.DEFAULT_CASE:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"default\");\n             addCaseBody(first);\n             break;\n         case Token.LABEL:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             if (!first.isLabelName()) {\n                 throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n             }\n             add(first);\n             add(\":\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\n             break;\n         case Token.CAST:\n             add(\"(\");\n             add(first);\n             add(\")\");\n             break;\n         default:\n             throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n     }\n     cc.endSourceMapping(n);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0b054d7d1b185b02c595c646bc0f11a6d809c934": {
      "type": "Ybodychange",
      "commitMessage": "\nAutomated g4 rollback\n\n*** Reason for rollback ***\n\nDisable cast warnings by default. Most projects however have\nit turn up to ERROR.\n\n*** Original change description ***\n\nAutomated g4 rollback.\n\n*** Reason for rollback ***\n\nbreaks various projects without whitelists\n\n*** Original change description ***\n\nIntroduced a CAST ast node\n\nR\u003dnicksantos\nDELTA\u003d1968  (1746 added, 44 deleted, 178 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d5970\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2394 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "12/12/12, 5:18 PM",
      "commitName": "0b054d7d1b185b02c595c646bc0f11a6d809c934",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "12/7/12, 11:39 AM",
      "commitNameOld": "6c51485e898eee8140bf05cbda29427cdc8bcc24",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 5.24,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "actualSource": "void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n        return;\n    }\n    int type \u003d n.getType();\n    String opstr \u003d NodeUtil.opToStr(type);\n    int childCount \u003d n.getChildCount();\n    Node first \u003d n.getFirstChild();\n    Node last \u003d n.getLastChild();\n    if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n        Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n        int p \u003d NodeUtil.precedence(type);\n        Context rhsContext \u003d getContextForNoInOperator(context);\n        if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n            addExpr(first, p, context);\n            cc.addOp(opstr, true);\n            addExpr(last, p, rhsContext);\n        } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n            addExpr(first, p, context);\n            cc.addOp(opstr, true);\n            addExpr(last, p, rhsContext);\n        } else {\n            unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n        }\n        return;\n    }\n    cc.startSourceMapping(n);\n    switch(type) {\n        case Token.TRY:\n            {\n                Preconditions.checkState(first.getNext().isBlock() \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n                Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                add(\"try\");\n                add(first, Context.PRESERVE_BLOCK);\n                Node catchblock \u003d first.getNext().getFirstChild();\n                if (catchblock !\u003d null) {\n                    add(catchblock);\n                }\n                if (childCount \u003d\u003d 3) {\n                    add(\"finally\");\n                    add(last, Context.PRESERVE_BLOCK);\n                }\n                break;\n            }\n        case Token.CATCH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"catch(\");\n            add(first);\n            add(\")\");\n            add(last, Context.PRESERVE_BLOCK);\n            break;\n        case Token.THROW:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"throw\");\n            add(first);\n            cc.endStatement(true);\n            break;\n        case Token.RETURN:\n            add(\"return\");\n            if (childCount \u003d\u003d 1) {\n                add(first);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 0);\n            }\n            cc.endStatement();\n            break;\n        case Token.VAR:\n            if (first !\u003d null) {\n                add(\"var \");\n                addList(first, false, getContextForNoInOperator(context));\n            }\n            break;\n        case Token.LABEL_NAME:\n            Preconditions.checkState(!n.getString().isEmpty());\n            addIdentifier(n.getString());\n            break;\n        case Token.NAME:\n            if (first \u003d\u003d null || first.isEmpty()) {\n                addIdentifier(n.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                addIdentifier(n.getString());\n                cc.addOp(\"\u003d\", true);\n                if (first.isComma()) {\n                    addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n                } else {\n                    addExpr(first, 0, getContextForNoInOperator(context));\n                }\n            }\n            break;\n        case Token.ARRAYLIT:\n            add(\"[\");\n            addArrayList(first);\n            add(\"]\");\n            break;\n        case Token.PARAM_LIST:\n            add(\"(\");\n            addList(first);\n            add(\")\");\n            break;\n        case Token.COMMA:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            unrollBinaryOperator(n, Token.COMMA, \",\", context, Context.OTHER, 0, 0);\n            break;\n        case Token.NUMBER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            cc.addNumber(n.getDouble());\n            break;\n        case Token.TYPEOF:\n        case Token.VOID:\n        case Token.NOT:\n        case Token.BITNOT:\n        case Token.POS:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n                break;\n            }\n        case Token.NEG:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                if (n.getFirstChild().isNumber()) {\n                    cc.addNumber(-n.getFirstChild().getDouble());\n                } else {\n                    cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                    addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n                }\n                break;\n            }\n        case Token.HOOK:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                int p \u003d NodeUtil.precedence(type);\n                addExpr(first, p + 1, context);\n                cc.addOp(\"?\", true);\n                addExpr(first.getNext(), 1, Context.OTHER);\n                cc.addOp(\":\", true);\n                addExpr(last, 1, Context.OTHER);\n                break;\n            }\n        case Token.REGEXP:\n            if (!first.isString() || !last.isString()) {\n                throw new Error(\"Expected children to be strings\");\n            }\n            String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n            if (childCount \u003d\u003d 2) {\n                add(regexp + last.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                add(regexp);\n            }\n            break;\n        case Token.FUNCTION:\n            if (n.getClass() !\u003d Node.class) {\n                throw new Error(\"Unexpected Node subclass.\");\n            }\n            Preconditions.checkState(childCount \u003d\u003d 3);\n            boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n            if (funcNeedsParens) {\n                add(\"(\");\n            }\n            add(\"function\");\n            add(first);\n            add(first.getNext());\n            add(last, Context.PRESERVE_BLOCK);\n            cc.endFunction(context \u003d\u003d Context.STATEMENT);\n            if (funcNeedsParens) {\n                add(\")\");\n            }\n            break;\n        case Token.GETTER_DEF:\n        case Token.SETTER_DEF:\n            Preconditions.checkState(n.getParent().isObjectLit());\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            Preconditions.checkState(first.isFunction());\n            Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n            if (type \u003d\u003d Token.GETTER_DEF) {\n                Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n                add(\"get \");\n            } else {\n                Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n                add(\"set \");\n            }\n            String name \u003d n.getString();\n            Node fn \u003d first;\n            Node parameters \u003d fn.getChildAtIndex(1);\n            Node body \u003d fn.getLastChild();\n            if (!n.isQuotedString() \u0026\u0026 TokenStream.isJSIdentifier(name) \u0026\u0026 NodeUtil.isLatin(name)) {\n                add(name);\n            } else {\n                double d \u003d getSimpleNumber(name);\n                if (!Double.isNaN(d)) {\n                    cc.addNumber(d);\n                } else {\n                    addJsString(n);\n                }\n            }\n            add(parameters);\n            add(body, Context.PRESERVE_BLOCK);\n            break;\n        case Token.SCRIPT:\n        case Token.BLOCK:\n            {\n                if (n.getClass() !\u003d Node.class) {\n                    throw new Error(\"Unexpected Node subclass.\");\n                }\n                boolean preserveBlock \u003d context \u003d\u003d Context.PRESERVE_BLOCK;\n                if (preserveBlock) {\n                    cc.beginBlock();\n                }\n                boolean preferLineBreaks \u003d type \u003d\u003d Token.SCRIPT || (type \u003d\u003d Token.BLOCK \u0026\u0026 !preserveBlock \u0026\u0026 n.getParent() !\u003d null \u0026\u0026 n.getParent().isScript());\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    add(c, Context.STATEMENT);\n                    if (c.isVar()) {\n                        cc.endStatement();\n                    }\n                    if (c.isFunction()) {\n                        cc.maybeLineBreak();\n                    }\n                    if (preferLineBreaks) {\n                        cc.notePreferredLineBreak();\n                    }\n                }\n                if (preserveBlock) {\n                    cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                }\n                break;\n            }\n        case Token.FOR:\n            if (childCount \u003d\u003d 4) {\n                add(\"for(\");\n                if (first.isVar()) {\n                    add(first, Context.IN_FOR_INIT_CLAUSE);\n                } else {\n                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                }\n                add(\";\");\n                add(first.getNext());\n                add(\";\");\n                add(first.getNext().getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                add(\"for(\");\n                add(first);\n                add(\"in\");\n                add(first.getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            }\n            break;\n        case Token.DO:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"do\");\n            addNonEmptyStatement(first, Context.OTHER, false);\n            add(\"while(\");\n            add(last);\n            add(\")\");\n            cc.endStatement();\n            break;\n        case Token.WHILE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"while(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.EMPTY:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            break;\n        case Token.GETPROP:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                Preconditions.checkState(last.isString(), \"Bad GETPROP: RHS should be STRING\");\n                boolean needsParens \u003d (first.isNumber());\n                if (needsParens) {\n                    add(\"(\");\n                }\n                addExpr(first, NodeUtil.precedence(type), context);\n                if (needsParens) {\n                    add(\")\");\n                }\n                add(\".\");\n                addIdentifier(last.getString());\n                break;\n            }\n        case Token.GETELEM:\n            Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n            addExpr(first, NodeUtil.precedence(type), context);\n            add(\"[\");\n            add(first.getNext());\n            add(\"]\");\n            break;\n        case Token.WITH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"with(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.INC:\n        case Token.DEC:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                if (postProp !\u003d 0) {\n                    addExpr(first, NodeUtil.precedence(type), context);\n                    cc.addOp(o, false);\n                } else {\n                    cc.addOp(o, false);\n                    add(first);\n                }\n                break;\n            }\n        case Token.CALL:\n            if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) \u0026\u0026 NodeUtil.isGet(first)) {\n                add(\"(0,\");\n                addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n                add(\")\");\n            } else {\n                addExpr(first, NodeUtil.precedence(type), context);\n            }\n            add(\"(\");\n            addList(first.getNext());\n            add(\")\");\n            break;\n        case Token.IF:\n            boolean hasElse \u003d childCount \u003d\u003d 3;\n            boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n            if (ambiguousElseClause) {\n                cc.beginBlock();\n            }\n            add(\"if(\");\n            add(first);\n            add(\")\");\n            if (hasElse) {\n                addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                add(\"else\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n                Preconditions.checkState(childCount \u003d\u003d 2);\n            }\n            if (ambiguousElseClause) {\n                cc.endBlock();\n            }\n            break;\n        case Token.NULL:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            cc.addConstant(\"null\");\n            break;\n        case Token.THIS:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"this\");\n            break;\n        case Token.FALSE:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            cc.addConstant(\"false\");\n            break;\n        case Token.TRUE:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            cc.addConstant(\"true\");\n            break;\n        case Token.CONTINUE:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"continue\");\n            if (childCount \u003d\u003d 1) {\n                if (!first.isLabelName()) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.DEBUGGER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"debugger\");\n            cc.endStatement();\n            break;\n        case Token.BREAK:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"break\");\n            if (childCount \u003d\u003d 1) {\n                if (!first.isLabelName()) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.EXPR_RESULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first, Context.START_OF_EXPR);\n            cc.endStatement();\n            break;\n        case Token.NEW:\n            add(\"new \");\n            int precedence \u003d NodeUtil.precedence(type);\n            if (NodeUtil.containsType(first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n                precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n            }\n            addExpr(first, precedence, Context.OTHER);\n            Node next \u003d first.getNext();\n            if (next !\u003d null) {\n                add(\"(\");\n                addList(next);\n                add(\")\");\n            }\n            break;\n        case Token.STRING_KEY:\n            Preconditions.checkState(childCount \u003d\u003d 1, \"Object lit key must have 1 child\");\n            addJsString(n);\n            break;\n        case Token.STRING:\n            Preconditions.checkState(childCount \u003d\u003d 0, \"A string may not have children\");\n            addJsString(n);\n            break;\n        case Token.DELPROP:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"delete \");\n            add(first);\n            break;\n        case Token.OBJECTLIT:\n            {\n                boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                add(\"{\");\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    if (c !\u003d first) {\n                        cc.listSeparator();\n                    }\n                    if (c.isGetterDef() || c.isSetterDef()) {\n                        add(c);\n                    } else {\n                        Preconditions.checkState(c.isStringKey());\n                        String key \u003d c.getString();\n                        if (!c.isQuotedString() \u0026\u0026 !TokenStream.isKeyword(key) \u0026\u0026 TokenStream.isJSIdentifier(key) \u0026\u0026 NodeUtil.isLatin(key)) {\n                            add(key);\n                        } else {\n                            double d \u003d getSimpleNumber(key);\n                            if (!Double.isNaN(d)) {\n                                cc.addNumber(d);\n                            } else {\n                                addExpr(c, 1, Context.OTHER);\n                            }\n                        }\n                        add(\":\");\n                        addExpr(c.getFirstChild(), 1, Context.OTHER);\n                    }\n                }\n                add(\"}\");\n                if (needsParens) {\n                    add(\")\");\n                }\n                break;\n            }\n        case Token.SWITCH:\n            add(\"switch(\");\n            add(first);\n            add(\")\");\n            cc.beginBlock();\n            addAllSiblings(first.getNext());\n            cc.endBlock(context \u003d\u003d Context.STATEMENT);\n            break;\n        case Token.CASE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"case \");\n            add(first);\n            addCaseBody(last);\n            break;\n        case Token.DEFAULT_CASE:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"default\");\n            addCaseBody(first);\n            break;\n        case Token.LABEL:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            if (!first.isLabelName()) {\n                throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n            }\n            add(first);\n            add(\":\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\n            break;\n        case Token.CAST:\n            add(\"(\");\n            add(first);\n            add(\")\");\n            break;\n        default:\n            throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n    cc.endSourceMapping(n);\n}",
      "path": "src/com/google/javascript/jscomp/CodeGenerator.java",
      "functionStartLine": 103,
      "functionName": "add",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,496 +1,501 @@\n void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n         return;\n     }\n     int type \u003d n.getType();\n     String opstr \u003d NodeUtil.opToStr(type);\n     int childCount \u003d n.getChildCount();\n     Node first \u003d n.getFirstChild();\n     Node last \u003d n.getLastChild();\n     if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n         Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n         int p \u003d NodeUtil.precedence(type);\n         Context rhsContext \u003d getContextForNoInOperator(context);\n         if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n             addExpr(first, p, context);\n             cc.addOp(opstr, true);\n             addExpr(last, p, rhsContext);\n         } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n             addExpr(first, p, context);\n             cc.addOp(opstr, true);\n             addExpr(last, p, rhsContext);\n         } else {\n             unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n         }\n         return;\n     }\n     cc.startSourceMapping(n);\n     switch(type) {\n         case Token.TRY:\n             {\n                 Preconditions.checkState(first.getNext().isBlock() \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n                 Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                 add(\"try\");\n                 add(first, Context.PRESERVE_BLOCK);\n                 Node catchblock \u003d first.getNext().getFirstChild();\n                 if (catchblock !\u003d null) {\n                     add(catchblock);\n                 }\n                 if (childCount \u003d\u003d 3) {\n                     add(\"finally\");\n                     add(last, Context.PRESERVE_BLOCK);\n                 }\n                 break;\n             }\n         case Token.CATCH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"catch(\");\n             add(first);\n             add(\")\");\n             add(last, Context.PRESERVE_BLOCK);\n             break;\n         case Token.THROW:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"throw\");\n             add(first);\n             cc.endStatement(true);\n             break;\n         case Token.RETURN:\n             add(\"return\");\n             if (childCount \u003d\u003d 1) {\n                 add(first);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 0);\n             }\n             cc.endStatement();\n             break;\n         case Token.VAR:\n             if (first !\u003d null) {\n                 add(\"var \");\n                 addList(first, false, getContextForNoInOperator(context));\n             }\n             break;\n         case Token.LABEL_NAME:\n             Preconditions.checkState(!n.getString().isEmpty());\n             addIdentifier(n.getString());\n             break;\n         case Token.NAME:\n             if (first \u003d\u003d null || first.isEmpty()) {\n                 addIdentifier(n.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 addIdentifier(n.getString());\n                 cc.addOp(\"\u003d\", true);\n                 if (first.isComma()) {\n                     addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n                 } else {\n                     addExpr(first, 0, getContextForNoInOperator(context));\n                 }\n             }\n             break;\n         case Token.ARRAYLIT:\n             add(\"[\");\n             addArrayList(first);\n             add(\"]\");\n             break;\n         case Token.PARAM_LIST:\n             add(\"(\");\n             addList(first);\n             add(\")\");\n             break;\n         case Token.COMMA:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             unrollBinaryOperator(n, Token.COMMA, \",\", context, Context.OTHER, 0, 0);\n             break;\n         case Token.NUMBER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             cc.addNumber(n.getDouble());\n             break;\n         case Token.TYPEOF:\n         case Token.VOID:\n         case Token.NOT:\n         case Token.BITNOT:\n         case Token.POS:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                 addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n                 break;\n             }\n         case Token.NEG:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 if (n.getFirstChild().isNumber()) {\n                     cc.addNumber(-n.getFirstChild().getDouble());\n                 } else {\n                     cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                     addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n                 }\n                 break;\n             }\n         case Token.HOOK:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 int p \u003d NodeUtil.precedence(type);\n                 addExpr(first, p + 1, context);\n                 cc.addOp(\"?\", true);\n                 addExpr(first.getNext(), 1, Context.OTHER);\n                 cc.addOp(\":\", true);\n                 addExpr(last, 1, Context.OTHER);\n                 break;\n             }\n         case Token.REGEXP:\n             if (!first.isString() || !last.isString()) {\n                 throw new Error(\"Expected children to be strings\");\n             }\n             String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n             if (childCount \u003d\u003d 2) {\n                 add(regexp + last.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 add(regexp);\n             }\n             break;\n         case Token.FUNCTION:\n             if (n.getClass() !\u003d Node.class) {\n                 throw new Error(\"Unexpected Node subclass.\");\n             }\n             Preconditions.checkState(childCount \u003d\u003d 3);\n             boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n             if (funcNeedsParens) {\n                 add(\"(\");\n             }\n             add(\"function\");\n             add(first);\n             add(first.getNext());\n             add(last, Context.PRESERVE_BLOCK);\n             cc.endFunction(context \u003d\u003d Context.STATEMENT);\n             if (funcNeedsParens) {\n                 add(\")\");\n             }\n             break;\n         case Token.GETTER_DEF:\n         case Token.SETTER_DEF:\n             Preconditions.checkState(n.getParent().isObjectLit());\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             Preconditions.checkState(first.isFunction());\n             Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n             if (type \u003d\u003d Token.GETTER_DEF) {\n                 Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n                 add(\"get \");\n             } else {\n                 Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n                 add(\"set \");\n             }\n             String name \u003d n.getString();\n             Node fn \u003d first;\n             Node parameters \u003d fn.getChildAtIndex(1);\n             Node body \u003d fn.getLastChild();\n             if (!n.isQuotedString() \u0026\u0026 TokenStream.isJSIdentifier(name) \u0026\u0026 NodeUtil.isLatin(name)) {\n                 add(name);\n             } else {\n                 double d \u003d getSimpleNumber(name);\n                 if (!Double.isNaN(d)) {\n                     cc.addNumber(d);\n                 } else {\n                     addJsString(n);\n                 }\n             }\n             add(parameters);\n             add(body, Context.PRESERVE_BLOCK);\n             break;\n         case Token.SCRIPT:\n         case Token.BLOCK:\n             {\n                 if (n.getClass() !\u003d Node.class) {\n                     throw new Error(\"Unexpected Node subclass.\");\n                 }\n                 boolean preserveBlock \u003d context \u003d\u003d Context.PRESERVE_BLOCK;\n                 if (preserveBlock) {\n                     cc.beginBlock();\n                 }\n                 boolean preferLineBreaks \u003d type \u003d\u003d Token.SCRIPT || (type \u003d\u003d Token.BLOCK \u0026\u0026 !preserveBlock \u0026\u0026 n.getParent() !\u003d null \u0026\u0026 n.getParent().isScript());\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     add(c, Context.STATEMENT);\n                     if (c.isVar()) {\n                         cc.endStatement();\n                     }\n                     if (c.isFunction()) {\n                         cc.maybeLineBreak();\n                     }\n                     if (preferLineBreaks) {\n                         cc.notePreferredLineBreak();\n                     }\n                 }\n                 if (preserveBlock) {\n                     cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                 }\n                 break;\n             }\n         case Token.FOR:\n             if (childCount \u003d\u003d 4) {\n                 add(\"for(\");\n                 if (first.isVar()) {\n                     add(first, Context.IN_FOR_INIT_CLAUSE);\n                 } else {\n                     addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                 }\n                 add(\";\");\n                 add(first.getNext());\n                 add(\";\");\n                 add(first.getNext().getNext());\n                 add(\")\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 add(\"for(\");\n                 add(first);\n                 add(\"in\");\n                 add(first.getNext());\n                 add(\")\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             }\n             break;\n         case Token.DO:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"do\");\n             addNonEmptyStatement(first, Context.OTHER, false);\n             add(\"while(\");\n             add(last);\n             add(\")\");\n             cc.endStatement();\n             break;\n         case Token.WHILE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"while(\");\n             add(first);\n             add(\")\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.EMPTY:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             break;\n         case Token.GETPROP:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                 Preconditions.checkState(last.isString(), \"Bad GETPROP: RHS should be STRING\");\n                 boolean needsParens \u003d (first.isNumber());\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 addExpr(first, NodeUtil.precedence(type), context);\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 add(\".\");\n                 addIdentifier(last.getString());\n                 break;\n             }\n         case Token.GETELEM:\n             Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n             addExpr(first, NodeUtil.precedence(type), context);\n             add(\"[\");\n             add(first.getNext());\n             add(\"]\");\n             break;\n         case Token.WITH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"with(\");\n             add(first);\n             add(\")\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.INC:\n         case Token.DEC:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                 int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                 if (postProp !\u003d 0) {\n                     addExpr(first, NodeUtil.precedence(type), context);\n                     cc.addOp(o, false);\n                 } else {\n                     cc.addOp(o, false);\n                     add(first);\n                 }\n                 break;\n             }\n         case Token.CALL:\n             if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) \u0026\u0026 NodeUtil.isGet(first)) {\n                 add(\"(0,\");\n                 addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n                 add(\")\");\n             } else {\n                 addExpr(first, NodeUtil.precedence(type), context);\n             }\n             add(\"(\");\n             addList(first.getNext());\n             add(\")\");\n             break;\n         case Token.IF:\n             boolean hasElse \u003d childCount \u003d\u003d 3;\n             boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n             if (ambiguousElseClause) {\n                 cc.beginBlock();\n             }\n             add(\"if(\");\n             add(first);\n             add(\")\");\n             if (hasElse) {\n                 addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                 add(\"else\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n                 Preconditions.checkState(childCount \u003d\u003d 2);\n             }\n             if (ambiguousElseClause) {\n                 cc.endBlock();\n             }\n             break;\n         case Token.NULL:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             cc.addConstant(\"null\");\n             break;\n         case Token.THIS:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(\"this\");\n             break;\n         case Token.FALSE:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             cc.addConstant(\"false\");\n             break;\n         case Token.TRUE:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             cc.addConstant(\"true\");\n             break;\n         case Token.CONTINUE:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"continue\");\n             if (childCount \u003d\u003d 1) {\n                 if (!first.isLabelName()) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.DEBUGGER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(\"debugger\");\n             cc.endStatement();\n             break;\n         case Token.BREAK:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"break\");\n             if (childCount \u003d\u003d 1) {\n                 if (!first.isLabelName()) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.EXPR_RESULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first, Context.START_OF_EXPR);\n             cc.endStatement();\n             break;\n         case Token.NEW:\n             add(\"new \");\n             int precedence \u003d NodeUtil.precedence(type);\n             if (NodeUtil.containsType(first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n                 precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n             }\n             addExpr(first, precedence, Context.OTHER);\n             Node next \u003d first.getNext();\n             if (next !\u003d null) {\n                 add(\"(\");\n                 addList(next);\n                 add(\")\");\n             }\n             break;\n         case Token.STRING_KEY:\n             Preconditions.checkState(childCount \u003d\u003d 1, \"Object lit key must have 1 child\");\n             addJsString(n);\n             break;\n         case Token.STRING:\n             Preconditions.checkState(childCount \u003d\u003d 0, \"A string may not have children\");\n             addJsString(n);\n             break;\n         case Token.DELPROP:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"delete \");\n             add(first);\n             break;\n         case Token.OBJECTLIT:\n             {\n                 boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 add(\"{\");\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     if (c !\u003d first) {\n                         cc.listSeparator();\n                     }\n                     if (c.isGetterDef() || c.isSetterDef()) {\n                         add(c);\n                     } else {\n                         Preconditions.checkState(c.isStringKey());\n                         String key \u003d c.getString();\n                         if (!c.isQuotedString() \u0026\u0026 !TokenStream.isKeyword(key) \u0026\u0026 TokenStream.isJSIdentifier(key) \u0026\u0026 NodeUtil.isLatin(key)) {\n                             add(key);\n                         } else {\n                             double d \u003d getSimpleNumber(key);\n                             if (!Double.isNaN(d)) {\n                                 cc.addNumber(d);\n                             } else {\n                                 addExpr(c, 1, Context.OTHER);\n                             }\n                         }\n                         add(\":\");\n                         addExpr(c.getFirstChild(), 1, Context.OTHER);\n                     }\n                 }\n                 add(\"}\");\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 break;\n             }\n         case Token.SWITCH:\n             add(\"switch(\");\n             add(first);\n             add(\")\");\n             cc.beginBlock();\n             addAllSiblings(first.getNext());\n             cc.endBlock(context \u003d\u003d Context.STATEMENT);\n             break;\n         case Token.CASE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"case \");\n             add(first);\n             addCaseBody(last);\n             break;\n         case Token.DEFAULT_CASE:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"default\");\n             addCaseBody(first);\n             break;\n         case Token.LABEL:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             if (!first.isLabelName()) {\n                 throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n             }\n             add(first);\n             add(\":\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\n             break;\n+        case Token.CAST:\n+            add(\"(\");\n+            add(first);\n+            add(\")\");\n+            break;\n         default:\n             throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n     }\n     cc.endSourceMapping(n);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "24fd842a5380a350bcde0bed60287053bc9b37f0": {
      "type": "Ybodychange",
      "commitMessage": "\nAutomated g4 rollback \n\n*** Reason for rollback ***\n\nbreaks various projects without whitelists\n\n*** Original change description ***\n\nIntroduced a CAST ast node\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d5848\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2334 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/19/12, 3:19 PM",
      "commitName": "24fd842a5380a350bcde0bed60287053bc9b37f0",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "11/19/12, 1:47 PM",
      "commitNameOld": "5428589fcac11bb899a44ef827e12a253e29d323",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 0.06,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n        return;\n    }\n    int type \u003d n.getType();\n    String opstr \u003d NodeUtil.opToStr(type);\n    int childCount \u003d n.getChildCount();\n    Node first \u003d n.getFirstChild();\n    Node last \u003d n.getLastChild();\n    if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n        Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n        int p \u003d NodeUtil.precedence(type);\n        Context rhsContext \u003d getContextForNoInOperator(context);\n        if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n            addExpr(first, p, context);\n            cc.addOp(opstr, true);\n            addExpr(last, p, rhsContext);\n        } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n            addExpr(first, p, context);\n            cc.addOp(opstr, true);\n            addExpr(last, p, rhsContext);\n        } else {\n            unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n        }\n        return;\n    }\n    cc.startSourceMapping(n);\n    switch(type) {\n        case Token.TRY:\n            {\n                Preconditions.checkState(first.getNext().isBlock() \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n                Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                add(\"try\");\n                add(first, Context.PRESERVE_BLOCK);\n                Node catchblock \u003d first.getNext().getFirstChild();\n                if (catchblock !\u003d null) {\n                    add(catchblock);\n                }\n                if (childCount \u003d\u003d 3) {\n                    add(\"finally\");\n                    add(last, Context.PRESERVE_BLOCK);\n                }\n                break;\n            }\n        case Token.CATCH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"catch(\");\n            add(first);\n            add(\")\");\n            add(last, Context.PRESERVE_BLOCK);\n            break;\n        case Token.THROW:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"throw\");\n            add(first);\n            cc.endStatement(true);\n            break;\n        case Token.RETURN:\n            add(\"return\");\n            if (childCount \u003d\u003d 1) {\n                add(first);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 0);\n            }\n            cc.endStatement();\n            break;\n        case Token.VAR:\n            if (first !\u003d null) {\n                add(\"var \");\n                addList(first, false, getContextForNoInOperator(context));\n            }\n            break;\n        case Token.LABEL_NAME:\n            Preconditions.checkState(!n.getString().isEmpty());\n            addIdentifier(n.getString());\n            break;\n        case Token.NAME:\n            if (first \u003d\u003d null || first.isEmpty()) {\n                addIdentifier(n.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                addIdentifier(n.getString());\n                cc.addOp(\"\u003d\", true);\n                if (first.isComma()) {\n                    addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n                } else {\n                    addExpr(first, 0, getContextForNoInOperator(context));\n                }\n            }\n            break;\n        case Token.ARRAYLIT:\n            add(\"[\");\n            addArrayList(first);\n            add(\"]\");\n            break;\n        case Token.PARAM_LIST:\n            add(\"(\");\n            addList(first);\n            add(\")\");\n            break;\n        case Token.COMMA:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            unrollBinaryOperator(n, Token.COMMA, \",\", context, Context.OTHER, 0, 0);\n            break;\n        case Token.NUMBER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            cc.addNumber(n.getDouble());\n            break;\n        case Token.TYPEOF:\n        case Token.VOID:\n        case Token.NOT:\n        case Token.BITNOT:\n        case Token.POS:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n                break;\n            }\n        case Token.NEG:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                if (n.getFirstChild().isNumber()) {\n                    cc.addNumber(-n.getFirstChild().getDouble());\n                } else {\n                    cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                    addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n                }\n                break;\n            }\n        case Token.HOOK:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                int p \u003d NodeUtil.precedence(type);\n                addExpr(first, p + 1, context);\n                cc.addOp(\"?\", true);\n                addExpr(first.getNext(), 1, Context.OTHER);\n                cc.addOp(\":\", true);\n                addExpr(last, 1, Context.OTHER);\n                break;\n            }\n        case Token.REGEXP:\n            if (!first.isString() || !last.isString()) {\n                throw new Error(\"Expected children to be strings\");\n            }\n            String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n            if (childCount \u003d\u003d 2) {\n                add(regexp + last.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                add(regexp);\n            }\n            break;\n        case Token.FUNCTION:\n            if (n.getClass() !\u003d Node.class) {\n                throw new Error(\"Unexpected Node subclass.\");\n            }\n            Preconditions.checkState(childCount \u003d\u003d 3);\n            boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n            if (funcNeedsParens) {\n                add(\"(\");\n            }\n            add(\"function\");\n            add(first);\n            add(first.getNext());\n            add(last, Context.PRESERVE_BLOCK);\n            cc.endFunction(context \u003d\u003d Context.STATEMENT);\n            if (funcNeedsParens) {\n                add(\")\");\n            }\n            break;\n        case Token.GETTER_DEF:\n        case Token.SETTER_DEF:\n            Preconditions.checkState(n.getParent().isObjectLit());\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            Preconditions.checkState(first.isFunction());\n            Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n            if (type \u003d\u003d Token.GETTER_DEF) {\n                Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n                add(\"get \");\n            } else {\n                Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n                add(\"set \");\n            }\n            String name \u003d n.getString();\n            Node fn \u003d first;\n            Node parameters \u003d fn.getChildAtIndex(1);\n            Node body \u003d fn.getLastChild();\n            if (!n.isQuotedString() \u0026\u0026 TokenStream.isJSIdentifier(name) \u0026\u0026 NodeUtil.isLatin(name)) {\n                add(name);\n            } else {\n                double d \u003d getSimpleNumber(name);\n                if (!Double.isNaN(d)) {\n                    cc.addNumber(d);\n                } else {\n                    addJsString(n);\n                }\n            }\n            add(parameters);\n            add(body, Context.PRESERVE_BLOCK);\n            break;\n        case Token.SCRIPT:\n        case Token.BLOCK:\n            {\n                if (n.getClass() !\u003d Node.class) {\n                    throw new Error(\"Unexpected Node subclass.\");\n                }\n                boolean preserveBlock \u003d context \u003d\u003d Context.PRESERVE_BLOCK;\n                if (preserveBlock) {\n                    cc.beginBlock();\n                }\n                boolean preferLineBreaks \u003d type \u003d\u003d Token.SCRIPT || (type \u003d\u003d Token.BLOCK \u0026\u0026 !preserveBlock \u0026\u0026 n.getParent() !\u003d null \u0026\u0026 n.getParent().isScript());\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    add(c, Context.STATEMENT);\n                    if (c.isVar()) {\n                        cc.endStatement();\n                    }\n                    if (c.isFunction()) {\n                        cc.maybeLineBreak();\n                    }\n                    if (preferLineBreaks) {\n                        cc.notePreferredLineBreak();\n                    }\n                }\n                if (preserveBlock) {\n                    cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                }\n                break;\n            }\n        case Token.FOR:\n            if (childCount \u003d\u003d 4) {\n                add(\"for(\");\n                if (first.isVar()) {\n                    add(first, Context.IN_FOR_INIT_CLAUSE);\n                } else {\n                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                }\n                add(\";\");\n                add(first.getNext());\n                add(\";\");\n                add(first.getNext().getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                add(\"for(\");\n                add(first);\n                add(\"in\");\n                add(first.getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            }\n            break;\n        case Token.DO:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"do\");\n            addNonEmptyStatement(first, Context.OTHER, false);\n            add(\"while(\");\n            add(last);\n            add(\")\");\n            cc.endStatement();\n            break;\n        case Token.WHILE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"while(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.EMPTY:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            break;\n        case Token.GETPROP:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                Preconditions.checkState(last.isString(), \"Bad GETPROP: RHS should be STRING\");\n                boolean needsParens \u003d (first.isNumber());\n                if (needsParens) {\n                    add(\"(\");\n                }\n                addExpr(first, NodeUtil.precedence(type), context);\n                if (needsParens) {\n                    add(\")\");\n                }\n                add(\".\");\n                addIdentifier(last.getString());\n                break;\n            }\n        case Token.GETELEM:\n            Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n            addExpr(first, NodeUtil.precedence(type), context);\n            add(\"[\");\n            add(first.getNext());\n            add(\"]\");\n            break;\n        case Token.WITH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"with(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.INC:\n        case Token.DEC:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                if (postProp !\u003d 0) {\n                    addExpr(first, NodeUtil.precedence(type), context);\n                    cc.addOp(o, false);\n                } else {\n                    cc.addOp(o, false);\n                    add(first);\n                }\n                break;\n            }\n        case Token.CALL:\n            if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) \u0026\u0026 NodeUtil.isGet(first)) {\n                add(\"(0,\");\n                addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n                add(\")\");\n            } else {\n                addExpr(first, NodeUtil.precedence(type), context);\n            }\n            add(\"(\");\n            addList(first.getNext());\n            add(\")\");\n            break;\n        case Token.IF:\n            boolean hasElse \u003d childCount \u003d\u003d 3;\n            boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n            if (ambiguousElseClause) {\n                cc.beginBlock();\n            }\n            add(\"if(\");\n            add(first);\n            add(\")\");\n            if (hasElse) {\n                addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                add(\"else\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n                Preconditions.checkState(childCount \u003d\u003d 2);\n            }\n            if (ambiguousElseClause) {\n                cc.endBlock();\n            }\n            break;\n        case Token.NULL:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            cc.addConstant(\"null\");\n            break;\n        case Token.THIS:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"this\");\n            break;\n        case Token.FALSE:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            cc.addConstant(\"false\");\n            break;\n        case Token.TRUE:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            cc.addConstant(\"true\");\n            break;\n        case Token.CONTINUE:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"continue\");\n            if (childCount \u003d\u003d 1) {\n                if (!first.isLabelName()) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.DEBUGGER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"debugger\");\n            cc.endStatement();\n            break;\n        case Token.BREAK:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"break\");\n            if (childCount \u003d\u003d 1) {\n                if (!first.isLabelName()) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.EXPR_RESULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first, Context.START_OF_EXPR);\n            cc.endStatement();\n            break;\n        case Token.NEW:\n            add(\"new \");\n            int precedence \u003d NodeUtil.precedence(type);\n            if (NodeUtil.containsType(first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n                precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n            }\n            addExpr(first, precedence, Context.OTHER);\n            Node next \u003d first.getNext();\n            if (next !\u003d null) {\n                add(\"(\");\n                addList(next);\n                add(\")\");\n            }\n            break;\n        case Token.STRING_KEY:\n            Preconditions.checkState(childCount \u003d\u003d 1, \"Object lit key must have 1 child\");\n            addJsString(n);\n            break;\n        case Token.STRING:\n            Preconditions.checkState(childCount \u003d\u003d 0, \"A string may not have children\");\n            addJsString(n);\n            break;\n        case Token.DELPROP:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"delete \");\n            add(first);\n            break;\n        case Token.OBJECTLIT:\n            {\n                boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                add(\"{\");\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    if (c !\u003d first) {\n                        cc.listSeparator();\n                    }\n                    if (c.isGetterDef() || c.isSetterDef()) {\n                        add(c);\n                    } else {\n                        Preconditions.checkState(c.isStringKey());\n                        String key \u003d c.getString();\n                        if (!c.isQuotedString() \u0026\u0026 !TokenStream.isKeyword(key) \u0026\u0026 TokenStream.isJSIdentifier(key) \u0026\u0026 NodeUtil.isLatin(key)) {\n                            add(key);\n                        } else {\n                            double d \u003d getSimpleNumber(key);\n                            if (!Double.isNaN(d)) {\n                                cc.addNumber(d);\n                            } else {\n                                addExpr(c, 1, Context.OTHER);\n                            }\n                        }\n                        add(\":\");\n                        addExpr(c.getFirstChild(), 1, Context.OTHER);\n                    }\n                }\n                add(\"}\");\n                if (needsParens) {\n                    add(\")\");\n                }\n                break;\n            }\n        case Token.SWITCH:\n            add(\"switch(\");\n            add(first);\n            add(\")\");\n            cc.beginBlock();\n            addAllSiblings(first.getNext());\n            cc.endBlock(context \u003d\u003d Context.STATEMENT);\n            break;\n        case Token.CASE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"case \");\n            add(first);\n            addCaseBody(last);\n            break;\n        case Token.DEFAULT_CASE:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"default\");\n            addCaseBody(first);\n            break;\n        case Token.LABEL:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            if (!first.isLabelName()) {\n                throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n            }\n            add(first);\n            add(\":\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\n            break;\n        default:\n            throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n    cc.endSourceMapping(n);\n}",
      "path": "src/com/google/javascript/jscomp/CodeGenerator.java",
      "functionStartLine": 85,
      "functionName": "add",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,501 +1,496 @@\n void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n         return;\n     }\n     int type \u003d n.getType();\n     String opstr \u003d NodeUtil.opToStr(type);\n     int childCount \u003d n.getChildCount();\n     Node first \u003d n.getFirstChild();\n     Node last \u003d n.getLastChild();\n     if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n         Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n         int p \u003d NodeUtil.precedence(type);\n         Context rhsContext \u003d getContextForNoInOperator(context);\n         if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n             addExpr(first, p, context);\n             cc.addOp(opstr, true);\n             addExpr(last, p, rhsContext);\n         } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n             addExpr(first, p, context);\n             cc.addOp(opstr, true);\n             addExpr(last, p, rhsContext);\n         } else {\n             unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n         }\n         return;\n     }\n     cc.startSourceMapping(n);\n     switch(type) {\n         case Token.TRY:\n             {\n                 Preconditions.checkState(first.getNext().isBlock() \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n                 Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                 add(\"try\");\n                 add(first, Context.PRESERVE_BLOCK);\n                 Node catchblock \u003d first.getNext().getFirstChild();\n                 if (catchblock !\u003d null) {\n                     add(catchblock);\n                 }\n                 if (childCount \u003d\u003d 3) {\n                     add(\"finally\");\n                     add(last, Context.PRESERVE_BLOCK);\n                 }\n                 break;\n             }\n         case Token.CATCH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"catch(\");\n             add(first);\n             add(\")\");\n             add(last, Context.PRESERVE_BLOCK);\n             break;\n         case Token.THROW:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"throw\");\n             add(first);\n             cc.endStatement(true);\n             break;\n         case Token.RETURN:\n             add(\"return\");\n             if (childCount \u003d\u003d 1) {\n                 add(first);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 0);\n             }\n             cc.endStatement();\n             break;\n         case Token.VAR:\n             if (first !\u003d null) {\n                 add(\"var \");\n                 addList(first, false, getContextForNoInOperator(context));\n             }\n             break;\n         case Token.LABEL_NAME:\n             Preconditions.checkState(!n.getString().isEmpty());\n             addIdentifier(n.getString());\n             break;\n         case Token.NAME:\n             if (first \u003d\u003d null || first.isEmpty()) {\n                 addIdentifier(n.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 addIdentifier(n.getString());\n                 cc.addOp(\"\u003d\", true);\n                 if (first.isComma()) {\n                     addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n                 } else {\n                     addExpr(first, 0, getContextForNoInOperator(context));\n                 }\n             }\n             break;\n         case Token.ARRAYLIT:\n             add(\"[\");\n             addArrayList(first);\n             add(\"]\");\n             break;\n         case Token.PARAM_LIST:\n             add(\"(\");\n             addList(first);\n             add(\")\");\n             break;\n         case Token.COMMA:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             unrollBinaryOperator(n, Token.COMMA, \",\", context, Context.OTHER, 0, 0);\n             break;\n         case Token.NUMBER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             cc.addNumber(n.getDouble());\n             break;\n         case Token.TYPEOF:\n         case Token.VOID:\n         case Token.NOT:\n         case Token.BITNOT:\n         case Token.POS:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                 addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n                 break;\n             }\n         case Token.NEG:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 if (n.getFirstChild().isNumber()) {\n                     cc.addNumber(-n.getFirstChild().getDouble());\n                 } else {\n                     cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                     addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n                 }\n                 break;\n             }\n         case Token.HOOK:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 int p \u003d NodeUtil.precedence(type);\n                 addExpr(first, p + 1, context);\n                 cc.addOp(\"?\", true);\n                 addExpr(first.getNext(), 1, Context.OTHER);\n                 cc.addOp(\":\", true);\n                 addExpr(last, 1, Context.OTHER);\n                 break;\n             }\n         case Token.REGEXP:\n             if (!first.isString() || !last.isString()) {\n                 throw new Error(\"Expected children to be strings\");\n             }\n             String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n             if (childCount \u003d\u003d 2) {\n                 add(regexp + last.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 add(regexp);\n             }\n             break;\n         case Token.FUNCTION:\n             if (n.getClass() !\u003d Node.class) {\n                 throw new Error(\"Unexpected Node subclass.\");\n             }\n             Preconditions.checkState(childCount \u003d\u003d 3);\n             boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n             if (funcNeedsParens) {\n                 add(\"(\");\n             }\n             add(\"function\");\n             add(first);\n             add(first.getNext());\n             add(last, Context.PRESERVE_BLOCK);\n             cc.endFunction(context \u003d\u003d Context.STATEMENT);\n             if (funcNeedsParens) {\n                 add(\")\");\n             }\n             break;\n         case Token.GETTER_DEF:\n         case Token.SETTER_DEF:\n             Preconditions.checkState(n.getParent().isObjectLit());\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             Preconditions.checkState(first.isFunction());\n             Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n             if (type \u003d\u003d Token.GETTER_DEF) {\n                 Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n                 add(\"get \");\n             } else {\n                 Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n                 add(\"set \");\n             }\n             String name \u003d n.getString();\n             Node fn \u003d first;\n             Node parameters \u003d fn.getChildAtIndex(1);\n             Node body \u003d fn.getLastChild();\n             if (!n.isQuotedString() \u0026\u0026 TokenStream.isJSIdentifier(name) \u0026\u0026 NodeUtil.isLatin(name)) {\n                 add(name);\n             } else {\n                 double d \u003d getSimpleNumber(name);\n                 if (!Double.isNaN(d)) {\n                     cc.addNumber(d);\n                 } else {\n                     addJsString(n);\n                 }\n             }\n             add(parameters);\n             add(body, Context.PRESERVE_BLOCK);\n             break;\n         case Token.SCRIPT:\n         case Token.BLOCK:\n             {\n                 if (n.getClass() !\u003d Node.class) {\n                     throw new Error(\"Unexpected Node subclass.\");\n                 }\n                 boolean preserveBlock \u003d context \u003d\u003d Context.PRESERVE_BLOCK;\n                 if (preserveBlock) {\n                     cc.beginBlock();\n                 }\n                 boolean preferLineBreaks \u003d type \u003d\u003d Token.SCRIPT || (type \u003d\u003d Token.BLOCK \u0026\u0026 !preserveBlock \u0026\u0026 n.getParent() !\u003d null \u0026\u0026 n.getParent().isScript());\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     add(c, Context.STATEMENT);\n                     if (c.isVar()) {\n                         cc.endStatement();\n                     }\n                     if (c.isFunction()) {\n                         cc.maybeLineBreak();\n                     }\n                     if (preferLineBreaks) {\n                         cc.notePreferredLineBreak();\n                     }\n                 }\n                 if (preserveBlock) {\n                     cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                 }\n                 break;\n             }\n         case Token.FOR:\n             if (childCount \u003d\u003d 4) {\n                 add(\"for(\");\n                 if (first.isVar()) {\n                     add(first, Context.IN_FOR_INIT_CLAUSE);\n                 } else {\n                     addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                 }\n                 add(\";\");\n                 add(first.getNext());\n                 add(\";\");\n                 add(first.getNext().getNext());\n                 add(\")\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 add(\"for(\");\n                 add(first);\n                 add(\"in\");\n                 add(first.getNext());\n                 add(\")\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             }\n             break;\n         case Token.DO:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"do\");\n             addNonEmptyStatement(first, Context.OTHER, false);\n             add(\"while(\");\n             add(last);\n             add(\")\");\n             cc.endStatement();\n             break;\n         case Token.WHILE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"while(\");\n             add(first);\n             add(\")\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.EMPTY:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             break;\n         case Token.GETPROP:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                 Preconditions.checkState(last.isString(), \"Bad GETPROP: RHS should be STRING\");\n                 boolean needsParens \u003d (first.isNumber());\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 addExpr(first, NodeUtil.precedence(type), context);\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 add(\".\");\n                 addIdentifier(last.getString());\n                 break;\n             }\n         case Token.GETELEM:\n             Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n             addExpr(first, NodeUtil.precedence(type), context);\n             add(\"[\");\n             add(first.getNext());\n             add(\"]\");\n             break;\n         case Token.WITH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"with(\");\n             add(first);\n             add(\")\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.INC:\n         case Token.DEC:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                 int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                 if (postProp !\u003d 0) {\n                     addExpr(first, NodeUtil.precedence(type), context);\n                     cc.addOp(o, false);\n                 } else {\n                     cc.addOp(o, false);\n                     add(first);\n                 }\n                 break;\n             }\n         case Token.CALL:\n             if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) \u0026\u0026 NodeUtil.isGet(first)) {\n                 add(\"(0,\");\n                 addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n                 add(\")\");\n             } else {\n                 addExpr(first, NodeUtil.precedence(type), context);\n             }\n             add(\"(\");\n             addList(first.getNext());\n             add(\")\");\n             break;\n         case Token.IF:\n             boolean hasElse \u003d childCount \u003d\u003d 3;\n             boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n             if (ambiguousElseClause) {\n                 cc.beginBlock();\n             }\n             add(\"if(\");\n             add(first);\n             add(\")\");\n             if (hasElse) {\n                 addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                 add(\"else\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n                 Preconditions.checkState(childCount \u003d\u003d 2);\n             }\n             if (ambiguousElseClause) {\n                 cc.endBlock();\n             }\n             break;\n         case Token.NULL:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             cc.addConstant(\"null\");\n             break;\n         case Token.THIS:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(\"this\");\n             break;\n         case Token.FALSE:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             cc.addConstant(\"false\");\n             break;\n         case Token.TRUE:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             cc.addConstant(\"true\");\n             break;\n         case Token.CONTINUE:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"continue\");\n             if (childCount \u003d\u003d 1) {\n                 if (!first.isLabelName()) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.DEBUGGER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(\"debugger\");\n             cc.endStatement();\n             break;\n         case Token.BREAK:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"break\");\n             if (childCount \u003d\u003d 1) {\n                 if (!first.isLabelName()) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.EXPR_RESULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first, Context.START_OF_EXPR);\n             cc.endStatement();\n             break;\n         case Token.NEW:\n             add(\"new \");\n             int precedence \u003d NodeUtil.precedence(type);\n             if (NodeUtil.containsType(first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n                 precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n             }\n             addExpr(first, precedence, Context.OTHER);\n             Node next \u003d first.getNext();\n             if (next !\u003d null) {\n                 add(\"(\");\n                 addList(next);\n                 add(\")\");\n             }\n             break;\n         case Token.STRING_KEY:\n             Preconditions.checkState(childCount \u003d\u003d 1, \"Object lit key must have 1 child\");\n             addJsString(n);\n             break;\n         case Token.STRING:\n             Preconditions.checkState(childCount \u003d\u003d 0, \"A string may not have children\");\n             addJsString(n);\n             break;\n         case Token.DELPROP:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"delete \");\n             add(first);\n             break;\n         case Token.OBJECTLIT:\n             {\n                 boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 add(\"{\");\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     if (c !\u003d first) {\n                         cc.listSeparator();\n                     }\n                     if (c.isGetterDef() || c.isSetterDef()) {\n                         add(c);\n                     } else {\n                         Preconditions.checkState(c.isStringKey());\n                         String key \u003d c.getString();\n                         if (!c.isQuotedString() \u0026\u0026 !TokenStream.isKeyword(key) \u0026\u0026 TokenStream.isJSIdentifier(key) \u0026\u0026 NodeUtil.isLatin(key)) {\n                             add(key);\n                         } else {\n                             double d \u003d getSimpleNumber(key);\n                             if (!Double.isNaN(d)) {\n                                 cc.addNumber(d);\n                             } else {\n                                 addExpr(c, 1, Context.OTHER);\n                             }\n                         }\n                         add(\":\");\n                         addExpr(c.getFirstChild(), 1, Context.OTHER);\n                     }\n                 }\n                 add(\"}\");\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 break;\n             }\n         case Token.SWITCH:\n             add(\"switch(\");\n             add(first);\n             add(\")\");\n             cc.beginBlock();\n             addAllSiblings(first.getNext());\n             cc.endBlock(context \u003d\u003d Context.STATEMENT);\n             break;\n         case Token.CASE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"case \");\n             add(first);\n             addCaseBody(last);\n             break;\n         case Token.DEFAULT_CASE:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"default\");\n             addCaseBody(first);\n             break;\n         case Token.LABEL:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             if (!first.isLabelName()) {\n                 throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n             }\n             add(first);\n             add(\":\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\n             break;\n-        case Token.CAST:\n-            add(\"(\");\n-            add(first);\n-            add(\")\");\n-            break;\n         default:\n             throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n     }\n     cc.endSourceMapping(n);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5428589fcac11bb899a44ef827e12a253e29d323": {
      "type": "Ybodychange",
      "commitMessage": "\nIntroduced a CAST ast node\n\nR\u003dnicksantos,dimvar\nDELTA\u003d2832  (2746 added, 13 deleted, 73 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d5846\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2332 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/19/12, 1:47 PM",
      "commitName": "5428589fcac11bb899a44ef827e12a253e29d323",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "10/24/12, 1:44 PM",
      "commitNameOld": "81ecaa689f9e33d3d0130d5991cbb4ed18ba6739",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 26.04,
      "commitsBetweenForRepo": 49,
      "commitsBetweenForFile": 1,
      "actualSource": "void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n        return;\n    }\n    int type \u003d n.getType();\n    String opstr \u003d NodeUtil.opToStr(type);\n    int childCount \u003d n.getChildCount();\n    Node first \u003d n.getFirstChild();\n    Node last \u003d n.getLastChild();\n    if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n        Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n        int p \u003d NodeUtil.precedence(type);\n        Context rhsContext \u003d getContextForNoInOperator(context);\n        if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n            addExpr(first, p, context);\n            cc.addOp(opstr, true);\n            addExpr(last, p, rhsContext);\n        } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n            addExpr(first, p, context);\n            cc.addOp(opstr, true);\n            addExpr(last, p, rhsContext);\n        } else {\n            unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n        }\n        return;\n    }\n    cc.startSourceMapping(n);\n    switch(type) {\n        case Token.TRY:\n            {\n                Preconditions.checkState(first.getNext().isBlock() \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n                Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                add(\"try\");\n                add(first, Context.PRESERVE_BLOCK);\n                Node catchblock \u003d first.getNext().getFirstChild();\n                if (catchblock !\u003d null) {\n                    add(catchblock);\n                }\n                if (childCount \u003d\u003d 3) {\n                    add(\"finally\");\n                    add(last, Context.PRESERVE_BLOCK);\n                }\n                break;\n            }\n        case Token.CATCH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"catch(\");\n            add(first);\n            add(\")\");\n            add(last, Context.PRESERVE_BLOCK);\n            break;\n        case Token.THROW:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"throw\");\n            add(first);\n            cc.endStatement(true);\n            break;\n        case Token.RETURN:\n            add(\"return\");\n            if (childCount \u003d\u003d 1) {\n                add(first);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 0);\n            }\n            cc.endStatement();\n            break;\n        case Token.VAR:\n            if (first !\u003d null) {\n                add(\"var \");\n                addList(first, false, getContextForNoInOperator(context));\n            }\n            break;\n        case Token.LABEL_NAME:\n            Preconditions.checkState(!n.getString().isEmpty());\n            addIdentifier(n.getString());\n            break;\n        case Token.NAME:\n            if (first \u003d\u003d null || first.isEmpty()) {\n                addIdentifier(n.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                addIdentifier(n.getString());\n                cc.addOp(\"\u003d\", true);\n                if (first.isComma()) {\n                    addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n                } else {\n                    addExpr(first, 0, getContextForNoInOperator(context));\n                }\n            }\n            break;\n        case Token.ARRAYLIT:\n            add(\"[\");\n            addArrayList(first);\n            add(\"]\");\n            break;\n        case Token.PARAM_LIST:\n            add(\"(\");\n            addList(first);\n            add(\")\");\n            break;\n        case Token.COMMA:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            unrollBinaryOperator(n, Token.COMMA, \",\", context, Context.OTHER, 0, 0);\n            break;\n        case Token.NUMBER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            cc.addNumber(n.getDouble());\n            break;\n        case Token.TYPEOF:\n        case Token.VOID:\n        case Token.NOT:\n        case Token.BITNOT:\n        case Token.POS:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n                break;\n            }\n        case Token.NEG:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                if (n.getFirstChild().isNumber()) {\n                    cc.addNumber(-n.getFirstChild().getDouble());\n                } else {\n                    cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                    addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n                }\n                break;\n            }\n        case Token.HOOK:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                int p \u003d NodeUtil.precedence(type);\n                addExpr(first, p + 1, context);\n                cc.addOp(\"?\", true);\n                addExpr(first.getNext(), 1, Context.OTHER);\n                cc.addOp(\":\", true);\n                addExpr(last, 1, Context.OTHER);\n                break;\n            }\n        case Token.REGEXP:\n            if (!first.isString() || !last.isString()) {\n                throw new Error(\"Expected children to be strings\");\n            }\n            String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n            if (childCount \u003d\u003d 2) {\n                add(regexp + last.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                add(regexp);\n            }\n            break;\n        case Token.FUNCTION:\n            if (n.getClass() !\u003d Node.class) {\n                throw new Error(\"Unexpected Node subclass.\");\n            }\n            Preconditions.checkState(childCount \u003d\u003d 3);\n            boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n            if (funcNeedsParens) {\n                add(\"(\");\n            }\n            add(\"function\");\n            add(first);\n            add(first.getNext());\n            add(last, Context.PRESERVE_BLOCK);\n            cc.endFunction(context \u003d\u003d Context.STATEMENT);\n            if (funcNeedsParens) {\n                add(\")\");\n            }\n            break;\n        case Token.GETTER_DEF:\n        case Token.SETTER_DEF:\n            Preconditions.checkState(n.getParent().isObjectLit());\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            Preconditions.checkState(first.isFunction());\n            Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n            if (type \u003d\u003d Token.GETTER_DEF) {\n                Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n                add(\"get \");\n            } else {\n                Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n                add(\"set \");\n            }\n            String name \u003d n.getString();\n            Node fn \u003d first;\n            Node parameters \u003d fn.getChildAtIndex(1);\n            Node body \u003d fn.getLastChild();\n            if (!n.isQuotedString() \u0026\u0026 TokenStream.isJSIdentifier(name) \u0026\u0026 NodeUtil.isLatin(name)) {\n                add(name);\n            } else {\n                double d \u003d getSimpleNumber(name);\n                if (!Double.isNaN(d)) {\n                    cc.addNumber(d);\n                } else {\n                    addJsString(n);\n                }\n            }\n            add(parameters);\n            add(body, Context.PRESERVE_BLOCK);\n            break;\n        case Token.SCRIPT:\n        case Token.BLOCK:\n            {\n                if (n.getClass() !\u003d Node.class) {\n                    throw new Error(\"Unexpected Node subclass.\");\n                }\n                boolean preserveBlock \u003d context \u003d\u003d Context.PRESERVE_BLOCK;\n                if (preserveBlock) {\n                    cc.beginBlock();\n                }\n                boolean preferLineBreaks \u003d type \u003d\u003d Token.SCRIPT || (type \u003d\u003d Token.BLOCK \u0026\u0026 !preserveBlock \u0026\u0026 n.getParent() !\u003d null \u0026\u0026 n.getParent().isScript());\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    add(c, Context.STATEMENT);\n                    if (c.isVar()) {\n                        cc.endStatement();\n                    }\n                    if (c.isFunction()) {\n                        cc.maybeLineBreak();\n                    }\n                    if (preferLineBreaks) {\n                        cc.notePreferredLineBreak();\n                    }\n                }\n                if (preserveBlock) {\n                    cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                }\n                break;\n            }\n        case Token.FOR:\n            if (childCount \u003d\u003d 4) {\n                add(\"for(\");\n                if (first.isVar()) {\n                    add(first, Context.IN_FOR_INIT_CLAUSE);\n                } else {\n                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                }\n                add(\";\");\n                add(first.getNext());\n                add(\";\");\n                add(first.getNext().getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                add(\"for(\");\n                add(first);\n                add(\"in\");\n                add(first.getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            }\n            break;\n        case Token.DO:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"do\");\n            addNonEmptyStatement(first, Context.OTHER, false);\n            add(\"while(\");\n            add(last);\n            add(\")\");\n            cc.endStatement();\n            break;\n        case Token.WHILE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"while(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.EMPTY:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            break;\n        case Token.GETPROP:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                Preconditions.checkState(last.isString(), \"Bad GETPROP: RHS should be STRING\");\n                boolean needsParens \u003d (first.isNumber());\n                if (needsParens) {\n                    add(\"(\");\n                }\n                addExpr(first, NodeUtil.precedence(type), context);\n                if (needsParens) {\n                    add(\")\");\n                }\n                add(\".\");\n                addIdentifier(last.getString());\n                break;\n            }\n        case Token.GETELEM:\n            Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n            addExpr(first, NodeUtil.precedence(type), context);\n            add(\"[\");\n            add(first.getNext());\n            add(\"]\");\n            break;\n        case Token.WITH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"with(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.INC:\n        case Token.DEC:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                if (postProp !\u003d 0) {\n                    addExpr(first, NodeUtil.precedence(type), context);\n                    cc.addOp(o, false);\n                } else {\n                    cc.addOp(o, false);\n                    add(first);\n                }\n                break;\n            }\n        case Token.CALL:\n            if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) \u0026\u0026 NodeUtil.isGet(first)) {\n                add(\"(0,\");\n                addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n                add(\")\");\n            } else {\n                addExpr(first, NodeUtil.precedence(type), context);\n            }\n            add(\"(\");\n            addList(first.getNext());\n            add(\")\");\n            break;\n        case Token.IF:\n            boolean hasElse \u003d childCount \u003d\u003d 3;\n            boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n            if (ambiguousElseClause) {\n                cc.beginBlock();\n            }\n            add(\"if(\");\n            add(first);\n            add(\")\");\n            if (hasElse) {\n                addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                add(\"else\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n                Preconditions.checkState(childCount \u003d\u003d 2);\n            }\n            if (ambiguousElseClause) {\n                cc.endBlock();\n            }\n            break;\n        case Token.NULL:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            cc.addConstant(\"null\");\n            break;\n        case Token.THIS:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"this\");\n            break;\n        case Token.FALSE:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            cc.addConstant(\"false\");\n            break;\n        case Token.TRUE:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            cc.addConstant(\"true\");\n            break;\n        case Token.CONTINUE:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"continue\");\n            if (childCount \u003d\u003d 1) {\n                if (!first.isLabelName()) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.DEBUGGER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"debugger\");\n            cc.endStatement();\n            break;\n        case Token.BREAK:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"break\");\n            if (childCount \u003d\u003d 1) {\n                if (!first.isLabelName()) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.EXPR_RESULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first, Context.START_OF_EXPR);\n            cc.endStatement();\n            break;\n        case Token.NEW:\n            add(\"new \");\n            int precedence \u003d NodeUtil.precedence(type);\n            if (NodeUtil.containsType(first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n                precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n            }\n            addExpr(first, precedence, Context.OTHER);\n            Node next \u003d first.getNext();\n            if (next !\u003d null) {\n                add(\"(\");\n                addList(next);\n                add(\")\");\n            }\n            break;\n        case Token.STRING_KEY:\n            Preconditions.checkState(childCount \u003d\u003d 1, \"Object lit key must have 1 child\");\n            addJsString(n);\n            break;\n        case Token.STRING:\n            Preconditions.checkState(childCount \u003d\u003d 0, \"A string may not have children\");\n            addJsString(n);\n            break;\n        case Token.DELPROP:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"delete \");\n            add(first);\n            break;\n        case Token.OBJECTLIT:\n            {\n                boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                add(\"{\");\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    if (c !\u003d first) {\n                        cc.listSeparator();\n                    }\n                    if (c.isGetterDef() || c.isSetterDef()) {\n                        add(c);\n                    } else {\n                        Preconditions.checkState(c.isStringKey());\n                        String key \u003d c.getString();\n                        if (!c.isQuotedString() \u0026\u0026 !TokenStream.isKeyword(key) \u0026\u0026 TokenStream.isJSIdentifier(key) \u0026\u0026 NodeUtil.isLatin(key)) {\n                            add(key);\n                        } else {\n                            double d \u003d getSimpleNumber(key);\n                            if (!Double.isNaN(d)) {\n                                cc.addNumber(d);\n                            } else {\n                                addExpr(c, 1, Context.OTHER);\n                            }\n                        }\n                        add(\":\");\n                        addExpr(c.getFirstChild(), 1, Context.OTHER);\n                    }\n                }\n                add(\"}\");\n                if (needsParens) {\n                    add(\")\");\n                }\n                break;\n            }\n        case Token.SWITCH:\n            add(\"switch(\");\n            add(first);\n            add(\")\");\n            cc.beginBlock();\n            addAllSiblings(first.getNext());\n            cc.endBlock(context \u003d\u003d Context.STATEMENT);\n            break;\n        case Token.CASE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"case \");\n            add(first);\n            addCaseBody(last);\n            break;\n        case Token.DEFAULT_CASE:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"default\");\n            addCaseBody(first);\n            break;\n        case Token.LABEL:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            if (!first.isLabelName()) {\n                throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n            }\n            add(first);\n            add(\":\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\n            break;\n        case Token.CAST:\n            add(\"(\");\n            add(first);\n            add(\")\");\n            break;\n        default:\n            throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n    cc.endSourceMapping(n);\n}",
      "path": "src/com/google/javascript/jscomp/CodeGenerator.java",
      "functionStartLine": 85,
      "functionName": "add",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,496 +1,501 @@\n void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n         return;\n     }\n     int type \u003d n.getType();\n     String opstr \u003d NodeUtil.opToStr(type);\n     int childCount \u003d n.getChildCount();\n     Node first \u003d n.getFirstChild();\n     Node last \u003d n.getLastChild();\n     if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n         Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n         int p \u003d NodeUtil.precedence(type);\n         Context rhsContext \u003d getContextForNoInOperator(context);\n         if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n             addExpr(first, p, context);\n             cc.addOp(opstr, true);\n             addExpr(last, p, rhsContext);\n         } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n             addExpr(first, p, context);\n             cc.addOp(opstr, true);\n             addExpr(last, p, rhsContext);\n         } else {\n             unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n         }\n         return;\n     }\n     cc.startSourceMapping(n);\n     switch(type) {\n         case Token.TRY:\n             {\n                 Preconditions.checkState(first.getNext().isBlock() \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n                 Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                 add(\"try\");\n                 add(first, Context.PRESERVE_BLOCK);\n                 Node catchblock \u003d first.getNext().getFirstChild();\n                 if (catchblock !\u003d null) {\n                     add(catchblock);\n                 }\n                 if (childCount \u003d\u003d 3) {\n                     add(\"finally\");\n                     add(last, Context.PRESERVE_BLOCK);\n                 }\n                 break;\n             }\n         case Token.CATCH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"catch(\");\n             add(first);\n             add(\")\");\n             add(last, Context.PRESERVE_BLOCK);\n             break;\n         case Token.THROW:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"throw\");\n             add(first);\n             cc.endStatement(true);\n             break;\n         case Token.RETURN:\n             add(\"return\");\n             if (childCount \u003d\u003d 1) {\n                 add(first);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 0);\n             }\n             cc.endStatement();\n             break;\n         case Token.VAR:\n             if (first !\u003d null) {\n                 add(\"var \");\n                 addList(first, false, getContextForNoInOperator(context));\n             }\n             break;\n         case Token.LABEL_NAME:\n             Preconditions.checkState(!n.getString().isEmpty());\n             addIdentifier(n.getString());\n             break;\n         case Token.NAME:\n             if (first \u003d\u003d null || first.isEmpty()) {\n                 addIdentifier(n.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 addIdentifier(n.getString());\n                 cc.addOp(\"\u003d\", true);\n                 if (first.isComma()) {\n                     addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n                 } else {\n                     addExpr(first, 0, getContextForNoInOperator(context));\n                 }\n             }\n             break;\n         case Token.ARRAYLIT:\n             add(\"[\");\n             addArrayList(first);\n             add(\"]\");\n             break;\n         case Token.PARAM_LIST:\n             add(\"(\");\n             addList(first);\n             add(\")\");\n             break;\n         case Token.COMMA:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             unrollBinaryOperator(n, Token.COMMA, \",\", context, Context.OTHER, 0, 0);\n             break;\n         case Token.NUMBER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             cc.addNumber(n.getDouble());\n             break;\n         case Token.TYPEOF:\n         case Token.VOID:\n         case Token.NOT:\n         case Token.BITNOT:\n         case Token.POS:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                 addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n                 break;\n             }\n         case Token.NEG:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 if (n.getFirstChild().isNumber()) {\n                     cc.addNumber(-n.getFirstChild().getDouble());\n                 } else {\n                     cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                     addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n                 }\n                 break;\n             }\n         case Token.HOOK:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 int p \u003d NodeUtil.precedence(type);\n                 addExpr(first, p + 1, context);\n                 cc.addOp(\"?\", true);\n                 addExpr(first.getNext(), 1, Context.OTHER);\n                 cc.addOp(\":\", true);\n                 addExpr(last, 1, Context.OTHER);\n                 break;\n             }\n         case Token.REGEXP:\n             if (!first.isString() || !last.isString()) {\n                 throw new Error(\"Expected children to be strings\");\n             }\n             String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n             if (childCount \u003d\u003d 2) {\n                 add(regexp + last.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 add(regexp);\n             }\n             break;\n         case Token.FUNCTION:\n             if (n.getClass() !\u003d Node.class) {\n                 throw new Error(\"Unexpected Node subclass.\");\n             }\n             Preconditions.checkState(childCount \u003d\u003d 3);\n             boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n             if (funcNeedsParens) {\n                 add(\"(\");\n             }\n             add(\"function\");\n             add(first);\n             add(first.getNext());\n             add(last, Context.PRESERVE_BLOCK);\n             cc.endFunction(context \u003d\u003d Context.STATEMENT);\n             if (funcNeedsParens) {\n                 add(\")\");\n             }\n             break;\n         case Token.GETTER_DEF:\n         case Token.SETTER_DEF:\n             Preconditions.checkState(n.getParent().isObjectLit());\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             Preconditions.checkState(first.isFunction());\n             Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n             if (type \u003d\u003d Token.GETTER_DEF) {\n                 Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n                 add(\"get \");\n             } else {\n                 Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n                 add(\"set \");\n             }\n             String name \u003d n.getString();\n             Node fn \u003d first;\n             Node parameters \u003d fn.getChildAtIndex(1);\n             Node body \u003d fn.getLastChild();\n             if (!n.isQuotedString() \u0026\u0026 TokenStream.isJSIdentifier(name) \u0026\u0026 NodeUtil.isLatin(name)) {\n                 add(name);\n             } else {\n                 double d \u003d getSimpleNumber(name);\n                 if (!Double.isNaN(d)) {\n                     cc.addNumber(d);\n                 } else {\n                     addJsString(n);\n                 }\n             }\n             add(parameters);\n             add(body, Context.PRESERVE_BLOCK);\n             break;\n         case Token.SCRIPT:\n         case Token.BLOCK:\n             {\n                 if (n.getClass() !\u003d Node.class) {\n                     throw new Error(\"Unexpected Node subclass.\");\n                 }\n                 boolean preserveBlock \u003d context \u003d\u003d Context.PRESERVE_BLOCK;\n                 if (preserveBlock) {\n                     cc.beginBlock();\n                 }\n                 boolean preferLineBreaks \u003d type \u003d\u003d Token.SCRIPT || (type \u003d\u003d Token.BLOCK \u0026\u0026 !preserveBlock \u0026\u0026 n.getParent() !\u003d null \u0026\u0026 n.getParent().isScript());\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     add(c, Context.STATEMENT);\n                     if (c.isVar()) {\n                         cc.endStatement();\n                     }\n                     if (c.isFunction()) {\n                         cc.maybeLineBreak();\n                     }\n                     if (preferLineBreaks) {\n                         cc.notePreferredLineBreak();\n                     }\n                 }\n                 if (preserveBlock) {\n                     cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                 }\n                 break;\n             }\n         case Token.FOR:\n             if (childCount \u003d\u003d 4) {\n                 add(\"for(\");\n                 if (first.isVar()) {\n                     add(first, Context.IN_FOR_INIT_CLAUSE);\n                 } else {\n                     addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                 }\n                 add(\";\");\n                 add(first.getNext());\n                 add(\";\");\n                 add(first.getNext().getNext());\n                 add(\")\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 add(\"for(\");\n                 add(first);\n                 add(\"in\");\n                 add(first.getNext());\n                 add(\")\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             }\n             break;\n         case Token.DO:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"do\");\n             addNonEmptyStatement(first, Context.OTHER, false);\n             add(\"while(\");\n             add(last);\n             add(\")\");\n             cc.endStatement();\n             break;\n         case Token.WHILE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"while(\");\n             add(first);\n             add(\")\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.EMPTY:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             break;\n         case Token.GETPROP:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                 Preconditions.checkState(last.isString(), \"Bad GETPROP: RHS should be STRING\");\n                 boolean needsParens \u003d (first.isNumber());\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 addExpr(first, NodeUtil.precedence(type), context);\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 add(\".\");\n                 addIdentifier(last.getString());\n                 break;\n             }\n         case Token.GETELEM:\n             Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n             addExpr(first, NodeUtil.precedence(type), context);\n             add(\"[\");\n             add(first.getNext());\n             add(\"]\");\n             break;\n         case Token.WITH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"with(\");\n             add(first);\n             add(\")\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.INC:\n         case Token.DEC:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                 int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                 if (postProp !\u003d 0) {\n                     addExpr(first, NodeUtil.precedence(type), context);\n                     cc.addOp(o, false);\n                 } else {\n                     cc.addOp(o, false);\n                     add(first);\n                 }\n                 break;\n             }\n         case Token.CALL:\n             if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) \u0026\u0026 NodeUtil.isGet(first)) {\n                 add(\"(0,\");\n                 addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n                 add(\")\");\n             } else {\n                 addExpr(first, NodeUtil.precedence(type), context);\n             }\n             add(\"(\");\n             addList(first.getNext());\n             add(\")\");\n             break;\n         case Token.IF:\n             boolean hasElse \u003d childCount \u003d\u003d 3;\n             boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n             if (ambiguousElseClause) {\n                 cc.beginBlock();\n             }\n             add(\"if(\");\n             add(first);\n             add(\")\");\n             if (hasElse) {\n                 addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                 add(\"else\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n                 Preconditions.checkState(childCount \u003d\u003d 2);\n             }\n             if (ambiguousElseClause) {\n                 cc.endBlock();\n             }\n             break;\n         case Token.NULL:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             cc.addConstant(\"null\");\n             break;\n         case Token.THIS:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(\"this\");\n             break;\n         case Token.FALSE:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             cc.addConstant(\"false\");\n             break;\n         case Token.TRUE:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             cc.addConstant(\"true\");\n             break;\n         case Token.CONTINUE:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"continue\");\n             if (childCount \u003d\u003d 1) {\n                 if (!first.isLabelName()) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.DEBUGGER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(\"debugger\");\n             cc.endStatement();\n             break;\n         case Token.BREAK:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"break\");\n             if (childCount \u003d\u003d 1) {\n                 if (!first.isLabelName()) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.EXPR_RESULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first, Context.START_OF_EXPR);\n             cc.endStatement();\n             break;\n         case Token.NEW:\n             add(\"new \");\n             int precedence \u003d NodeUtil.precedence(type);\n             if (NodeUtil.containsType(first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n                 precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n             }\n             addExpr(first, precedence, Context.OTHER);\n             Node next \u003d first.getNext();\n             if (next !\u003d null) {\n                 add(\"(\");\n                 addList(next);\n                 add(\")\");\n             }\n             break;\n         case Token.STRING_KEY:\n             Preconditions.checkState(childCount \u003d\u003d 1, \"Object lit key must have 1 child\");\n             addJsString(n);\n             break;\n         case Token.STRING:\n             Preconditions.checkState(childCount \u003d\u003d 0, \"A string may not have children\");\n             addJsString(n);\n             break;\n         case Token.DELPROP:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"delete \");\n             add(first);\n             break;\n         case Token.OBJECTLIT:\n             {\n                 boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 add(\"{\");\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     if (c !\u003d first) {\n                         cc.listSeparator();\n                     }\n                     if (c.isGetterDef() || c.isSetterDef()) {\n                         add(c);\n                     } else {\n                         Preconditions.checkState(c.isStringKey());\n                         String key \u003d c.getString();\n                         if (!c.isQuotedString() \u0026\u0026 !TokenStream.isKeyword(key) \u0026\u0026 TokenStream.isJSIdentifier(key) \u0026\u0026 NodeUtil.isLatin(key)) {\n                             add(key);\n                         } else {\n                             double d \u003d getSimpleNumber(key);\n                             if (!Double.isNaN(d)) {\n                                 cc.addNumber(d);\n                             } else {\n                                 addExpr(c, 1, Context.OTHER);\n                             }\n                         }\n                         add(\":\");\n                         addExpr(c.getFirstChild(), 1, Context.OTHER);\n                     }\n                 }\n                 add(\"}\");\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 break;\n             }\n         case Token.SWITCH:\n             add(\"switch(\");\n             add(first);\n             add(\")\");\n             cc.beginBlock();\n             addAllSiblings(first.getNext());\n             cc.endBlock(context \u003d\u003d Context.STATEMENT);\n             break;\n         case Token.CASE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"case \");\n             add(first);\n             addCaseBody(last);\n             break;\n         case Token.DEFAULT_CASE:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"default\");\n             addCaseBody(first);\n             break;\n         case Token.LABEL:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             if (!first.isLabelName()) {\n                 throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n             }\n             add(first);\n             add(\":\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\n             break;\n+        case Token.CAST:\n+            add(\"(\");\n+            add(first);\n+            add(\")\");\n+            break;\n         default:\n             throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n     }\n     cc.endSourceMapping(n);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "70a5626922ea7e8c98747e22b6986638ba38fadc": {
      "type": "Ybodychange",
      "commitMessage": "\nFix various typos, spelling and grammar errors.\nFixes issue 734. \nContributed by Robert Gust Bardon\n\nR\u003dnicksantos\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d4827\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1979 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "5/18/12, 11:09 AM",
      "commitName": "70a5626922ea7e8c98747e22b6986638ba38fadc",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "5/14/12, 11:02 AM",
      "commitNameOld": "59dbb7a28680caad08ddb1658123fe0cbb1ae689",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 4.0,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "actualSource": "void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n        return;\n    }\n    int type \u003d n.getType();\n    String opstr \u003d NodeUtil.opToStr(type);\n    int childCount \u003d n.getChildCount();\n    Node first \u003d n.getFirstChild();\n    Node last \u003d n.getLastChild();\n    if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n        Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n        int p \u003d NodeUtil.precedence(type);\n        Context rhsContext \u003d getContextForNoInOperator(context);\n        if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n            addExpr(first, p, context);\n            cc.addOp(opstr, true);\n            addExpr(last, p, rhsContext);\n        } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n            addExpr(first, p, context);\n            cc.addOp(opstr, true);\n            addExpr(last, p, rhsContext);\n        } else {\n            unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n        }\n        return;\n    }\n    cc.startSourceMapping(n);\n    switch(type) {\n        case Token.TRY:\n            {\n                Preconditions.checkState(first.getNext().isBlock() \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n                Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                add(\"try\");\n                add(first, Context.PRESERVE_BLOCK);\n                Node catchblock \u003d first.getNext().getFirstChild();\n                if (catchblock !\u003d null) {\n                    add(catchblock);\n                }\n                if (childCount \u003d\u003d 3) {\n                    add(\"finally\");\n                    add(last, Context.PRESERVE_BLOCK);\n                }\n                break;\n            }\n        case Token.CATCH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"catch(\");\n            add(first);\n            add(\")\");\n            add(last, Context.PRESERVE_BLOCK);\n            break;\n        case Token.THROW:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"throw\");\n            add(first);\n            cc.endStatement(true);\n            break;\n        case Token.RETURN:\n            add(\"return\");\n            if (childCount \u003d\u003d 1) {\n                add(first);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 0);\n            }\n            cc.endStatement();\n            break;\n        case Token.VAR:\n            if (first !\u003d null) {\n                add(\"var \");\n                addList(first, false, getContextForNoInOperator(context));\n            }\n            break;\n        case Token.LABEL_NAME:\n            Preconditions.checkState(!n.getString().isEmpty());\n            addIdentifier(n.getString());\n            break;\n        case Token.NAME:\n            if (first \u003d\u003d null || first.isEmpty()) {\n                addIdentifier(n.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                addIdentifier(n.getString());\n                cc.addOp(\"\u003d\", true);\n                if (first.isComma()) {\n                    addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n                } else {\n                    addExpr(first, 0, getContextForNoInOperator(context));\n                }\n            }\n            break;\n        case Token.ARRAYLIT:\n            add(\"[\");\n            addArrayList(first);\n            add(\"]\");\n            break;\n        case Token.PARAM_LIST:\n            add(\"(\");\n            addList(first);\n            add(\")\");\n            break;\n        case Token.COMMA:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            unrollBinaryOperator(n, Token.COMMA, \",\", context, Context.OTHER, 0, 0);\n            break;\n        case Token.NUMBER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            cc.addNumber(n.getDouble());\n            break;\n        case Token.TYPEOF:\n        case Token.VOID:\n        case Token.NOT:\n        case Token.BITNOT:\n        case Token.POS:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n                break;\n            }\n        case Token.NEG:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                if (n.getFirstChild().isNumber()) {\n                    cc.addNumber(-n.getFirstChild().getDouble());\n                } else {\n                    cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                    addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n                }\n                break;\n            }\n        case Token.HOOK:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                int p \u003d NodeUtil.precedence(type);\n                addExpr(first, p + 1, context);\n                cc.addOp(\"?\", true);\n                addExpr(first.getNext(), 1, Context.OTHER);\n                cc.addOp(\":\", true);\n                addExpr(last, 1, Context.OTHER);\n                break;\n            }\n        case Token.REGEXP:\n            if (!first.isString() || !last.isString()) {\n                throw new Error(\"Expected children to be strings\");\n            }\n            String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n            if (childCount \u003d\u003d 2) {\n                add(regexp + last.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                add(regexp);\n            }\n            break;\n        case Token.FUNCTION:\n            if (n.getClass() !\u003d Node.class) {\n                throw new Error(\"Unexpected Node subclass.\");\n            }\n            Preconditions.checkState(childCount \u003d\u003d 3);\n            boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n            if (funcNeedsParens) {\n                add(\"(\");\n            }\n            add(\"function\");\n            add(first);\n            add(first.getNext());\n            add(last, Context.PRESERVE_BLOCK);\n            cc.endFunction(context \u003d\u003d Context.STATEMENT);\n            if (funcNeedsParens) {\n                add(\")\");\n            }\n            break;\n        case Token.GETTER_DEF:\n        case Token.SETTER_DEF:\n            Preconditions.checkState(n.getParent().isObjectLit());\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            Preconditions.checkState(first.isFunction());\n            Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n            if (type \u003d\u003d Token.GETTER_DEF) {\n                Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n                add(\"get \");\n            } else {\n                Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n                add(\"set \");\n            }\n            String name \u003d n.getString();\n            Node fn \u003d first;\n            Node parameters \u003d fn.getChildAtIndex(1);\n            Node body \u003d fn.getLastChild();\n            if (!n.isQuotedString() \u0026\u0026 TokenStream.isJSIdentifier(name) \u0026\u0026 NodeUtil.isLatin(name)) {\n                add(name);\n            } else {\n                double d \u003d getSimpleNumber(name);\n                if (!Double.isNaN(d)) {\n                    cc.addNumber(d);\n                } else {\n                    addJsString(n);\n                }\n            }\n            add(parameters);\n            add(body, Context.PRESERVE_BLOCK);\n            break;\n        case Token.SCRIPT:\n        case Token.BLOCK:\n            {\n                if (n.getClass() !\u003d Node.class) {\n                    throw new Error(\"Unexpected Node subclass.\");\n                }\n                boolean preserveBlock \u003d context \u003d\u003d Context.PRESERVE_BLOCK;\n                if (preserveBlock) {\n                    cc.beginBlock();\n                }\n                boolean preferLineBreaks \u003d type \u003d\u003d Token.SCRIPT || (type \u003d\u003d Token.BLOCK \u0026\u0026 !preserveBlock \u0026\u0026 n.getParent() !\u003d null \u0026\u0026 n.getParent().isScript());\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    add(c, Context.STATEMENT);\n                    if (c.isVar()) {\n                        cc.endStatement();\n                    }\n                    if (c.isFunction()) {\n                        cc.maybeLineBreak();\n                    }\n                    if (preferLineBreaks) {\n                        cc.notePreferredLineBreak();\n                    }\n                }\n                if (preserveBlock) {\n                    cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                }\n                break;\n            }\n        case Token.FOR:\n            if (childCount \u003d\u003d 4) {\n                add(\"for(\");\n                if (first.isVar()) {\n                    add(first, Context.IN_FOR_INIT_CLAUSE);\n                } else {\n                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                }\n                add(\";\");\n                add(first.getNext());\n                add(\";\");\n                add(first.getNext().getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                add(\"for(\");\n                add(first);\n                add(\"in\");\n                add(first.getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            }\n            break;\n        case Token.DO:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"do\");\n            addNonEmptyStatement(first, Context.OTHER, false);\n            add(\"while(\");\n            add(last);\n            add(\")\");\n            cc.endStatement();\n            break;\n        case Token.WHILE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"while(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.EMPTY:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            break;\n        case Token.GETPROP:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                Preconditions.checkState(last.isString(), \"Bad GETPROP: RHS should be STRING\");\n                boolean needsParens \u003d (first.isNumber());\n                if (needsParens) {\n                    add(\"(\");\n                }\n                addExpr(first, NodeUtil.precedence(type), context);\n                if (needsParens) {\n                    add(\")\");\n                }\n                add(\".\");\n                addIdentifier(last.getString());\n                break;\n            }\n        case Token.GETELEM:\n            Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n            addExpr(first, NodeUtil.precedence(type), context);\n            add(\"[\");\n            add(first.getNext());\n            add(\"]\");\n            break;\n        case Token.WITH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"with(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.INC:\n        case Token.DEC:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                if (postProp !\u003d 0) {\n                    addExpr(first, NodeUtil.precedence(type), context);\n                    cc.addOp(o, false);\n                } else {\n                    cc.addOp(o, false);\n                    add(first);\n                }\n                break;\n            }\n        case Token.CALL:\n            if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) \u0026\u0026 NodeUtil.isGet(first)) {\n                add(\"(0,\");\n                addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n                add(\")\");\n            } else {\n                addExpr(first, NodeUtil.precedence(type), context);\n            }\n            add(\"(\");\n            addList(first.getNext());\n            add(\")\");\n            break;\n        case Token.IF:\n            boolean hasElse \u003d childCount \u003d\u003d 3;\n            boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n            if (ambiguousElseClause) {\n                cc.beginBlock();\n            }\n            add(\"if(\");\n            add(first);\n            add(\")\");\n            if (hasElse) {\n                addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                add(\"else\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n                Preconditions.checkState(childCount \u003d\u003d 2);\n            }\n            if (ambiguousElseClause) {\n                cc.endBlock();\n            }\n            break;\n        case Token.NULL:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            cc.addConstant(\"null\");\n            break;\n        case Token.THIS:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"this\");\n            break;\n        case Token.FALSE:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            cc.addConstant(\"false\");\n            break;\n        case Token.TRUE:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            cc.addConstant(\"true\");\n            break;\n        case Token.CONTINUE:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"continue\");\n            if (childCount \u003d\u003d 1) {\n                if (!first.isLabelName()) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.DEBUGGER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"debugger\");\n            cc.endStatement();\n            break;\n        case Token.BREAK:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"break\");\n            if (childCount \u003d\u003d 1) {\n                if (!first.isLabelName()) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.EXPR_RESULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first, Context.START_OF_EXPR);\n            cc.endStatement();\n            break;\n        case Token.NEW:\n            add(\"new \");\n            int precedence \u003d NodeUtil.precedence(type);\n            if (NodeUtil.containsType(first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n                precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n            }\n            addExpr(first, precedence, Context.OTHER);\n            Node next \u003d first.getNext();\n            if (next !\u003d null) {\n                add(\"(\");\n                addList(next);\n                add(\")\");\n            }\n            break;\n        case Token.STRING_KEY:\n            Preconditions.checkState(childCount \u003d\u003d 1, \"Object lit key must have 1 child\");\n            addJsString(n);\n            break;\n        case Token.STRING:\n            Preconditions.checkState(childCount \u003d\u003d 0, \"A string may not have children\");\n            addJsString(n);\n            break;\n        case Token.DELPROP:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"delete \");\n            add(first);\n            break;\n        case Token.OBJECTLIT:\n            {\n                boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                add(\"{\");\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    if (c !\u003d first) {\n                        cc.listSeparator();\n                    }\n                    if (c.isGetterDef() || c.isSetterDef()) {\n                        add(c);\n                    } else {\n                        Preconditions.checkState(c.isStringKey());\n                        String key \u003d c.getString();\n                        if (!c.isQuotedString() \u0026\u0026 !TokenStream.isKeyword(key) \u0026\u0026 TokenStream.isJSIdentifier(key) \u0026\u0026 NodeUtil.isLatin(key)) {\n                            add(key);\n                        } else {\n                            double d \u003d getSimpleNumber(key);\n                            if (!Double.isNaN(d)) {\n                                cc.addNumber(d);\n                            } else {\n                                addExpr(c, 1, Context.OTHER);\n                            }\n                        }\n                        add(\":\");\n                        addExpr(c.getFirstChild(), 1, Context.OTHER);\n                    }\n                }\n                add(\"}\");\n                if (needsParens) {\n                    add(\")\");\n                }\n                break;\n            }\n        case Token.SWITCH:\n            add(\"switch(\");\n            add(first);\n            add(\")\");\n            cc.beginBlock();\n            addAllSiblings(first.getNext());\n            cc.endBlock(context \u003d\u003d Context.STATEMENT);\n            break;\n        case Token.CASE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"case \");\n            add(first);\n            addCaseBody(last);\n            break;\n        case Token.DEFAULT_CASE:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"default\");\n            addCaseBody(first);\n            break;\n        case Token.LABEL:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            if (!first.isLabelName()) {\n                throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n            }\n            add(first);\n            add(\":\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\n            break;\n        default:\n            throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n    cc.endSourceMapping(n);\n}",
      "path": "src/com/google/javascript/jscomp/CodeGenerator.java",
      "functionStartLine": 85,
      "functionName": "add",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {}
    },
    "59dbb7a28680caad08ddb1658123fe0cbb1ae689": {
      "type": "Ybodychange",
      "commitMessage": "\nLower the cost of true/false/null.\nFixes issue 728\n\nR\u003djohnlenz\nDELTA\u003d35  (27 added, 0 deleted, 8 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d4778\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1969 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "5/14/12, 11:02 AM",
      "commitName": "59dbb7a28680caad08ddb1658123fe0cbb1ae689",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "5/2/12, 4:00 PM",
      "commitNameOld": "c9f5de5e7b5c8fff6c56b5bad2c0039aa3b4e72d",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 11.79,
      "commitsBetweenForRepo": 21,
      "commitsBetweenForFile": 1,
      "actualSource": "void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n        return;\n    }\n    int type \u003d n.getType();\n    String opstr \u003d NodeUtil.opToStr(type);\n    int childCount \u003d n.getChildCount();\n    Node first \u003d n.getFirstChild();\n    Node last \u003d n.getLastChild();\n    if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n        Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n        int p \u003d NodeUtil.precedence(type);\n        Context rhsContext \u003d getContextForNoInOperator(context);\n        if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n            addExpr(first, p, context);\n            cc.addOp(opstr, true);\n            addExpr(last, p, rhsContext);\n        } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n            addExpr(first, p, context);\n            cc.addOp(opstr, true);\n            addExpr(last, p, rhsContext);\n        } else {\n            unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n        }\n        return;\n    }\n    cc.startSourceMapping(n);\n    switch(type) {\n        case Token.TRY:\n            {\n                Preconditions.checkState(first.getNext().isBlock() \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n                Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                add(\"try\");\n                add(first, Context.PRESERVE_BLOCK);\n                Node catchblock \u003d first.getNext().getFirstChild();\n                if (catchblock !\u003d null) {\n                    add(catchblock);\n                }\n                if (childCount \u003d\u003d 3) {\n                    add(\"finally\");\n                    add(last, Context.PRESERVE_BLOCK);\n                }\n                break;\n            }\n        case Token.CATCH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"catch(\");\n            add(first);\n            add(\")\");\n            add(last, Context.PRESERVE_BLOCK);\n            break;\n        case Token.THROW:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"throw\");\n            add(first);\n            cc.endStatement(true);\n            break;\n        case Token.RETURN:\n            add(\"return\");\n            if (childCount \u003d\u003d 1) {\n                add(first);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 0);\n            }\n            cc.endStatement();\n            break;\n        case Token.VAR:\n            if (first !\u003d null) {\n                add(\"var \");\n                addList(first, false, getContextForNoInOperator(context));\n            }\n            break;\n        case Token.LABEL_NAME:\n            Preconditions.checkState(!n.getString().isEmpty());\n            addIdentifier(n.getString());\n            break;\n        case Token.NAME:\n            if (first \u003d\u003d null || first.isEmpty()) {\n                addIdentifier(n.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                addIdentifier(n.getString());\n                cc.addOp(\"\u003d\", true);\n                if (first.isComma()) {\n                    addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n                } else {\n                    addExpr(first, 0, getContextForNoInOperator(context));\n                }\n            }\n            break;\n        case Token.ARRAYLIT:\n            add(\"[\");\n            addArrayList(first);\n            add(\"]\");\n            break;\n        case Token.PARAM_LIST:\n            add(\"(\");\n            addList(first);\n            add(\")\");\n            break;\n        case Token.COMMA:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            unrollBinaryOperator(n, Token.COMMA, \",\", context, Context.OTHER, 0, 0);\n            break;\n        case Token.NUMBER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            cc.addNumber(n.getDouble());\n            break;\n        case Token.TYPEOF:\n        case Token.VOID:\n        case Token.NOT:\n        case Token.BITNOT:\n        case Token.POS:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n                break;\n            }\n        case Token.NEG:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                if (n.getFirstChild().isNumber()) {\n                    cc.addNumber(-n.getFirstChild().getDouble());\n                } else {\n                    cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                    addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n                }\n                break;\n            }\n        case Token.HOOK:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                int p \u003d NodeUtil.precedence(type);\n                addExpr(first, p + 1, context);\n                cc.addOp(\"?\", true);\n                addExpr(first.getNext(), 1, Context.OTHER);\n                cc.addOp(\":\", true);\n                addExpr(last, 1, Context.OTHER);\n                break;\n            }\n        case Token.REGEXP:\n            if (!first.isString() || !last.isString()) {\n                throw new Error(\"Expected children to be strings\");\n            }\n            String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n            if (childCount \u003d\u003d 2) {\n                add(regexp + last.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                add(regexp);\n            }\n            break;\n        case Token.FUNCTION:\n            if (n.getClass() !\u003d Node.class) {\n                throw new Error(\"Unexpected Node subclass.\");\n            }\n            Preconditions.checkState(childCount \u003d\u003d 3);\n            boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n            if (funcNeedsParens) {\n                add(\"(\");\n            }\n            add(\"function\");\n            add(first);\n            add(first.getNext());\n            add(last, Context.PRESERVE_BLOCK);\n            cc.endFunction(context \u003d\u003d Context.STATEMENT);\n            if (funcNeedsParens) {\n                add(\")\");\n            }\n            break;\n        case Token.GETTER_DEF:\n        case Token.SETTER_DEF:\n            Preconditions.checkState(n.getParent().isObjectLit());\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            Preconditions.checkState(first.isFunction());\n            Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n            if (type \u003d\u003d Token.GETTER_DEF) {\n                Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n                add(\"get \");\n            } else {\n                Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n                add(\"set \");\n            }\n            String name \u003d n.getString();\n            Node fn \u003d first;\n            Node parameters \u003d fn.getChildAtIndex(1);\n            Node body \u003d fn.getLastChild();\n            if (!n.isQuotedString() \u0026\u0026 TokenStream.isJSIdentifier(name) \u0026\u0026 NodeUtil.isLatin(name)) {\n                add(name);\n            } else {\n                double d \u003d getSimpleNumber(name);\n                if (!Double.isNaN(d)) {\n                    cc.addNumber(d);\n                } else {\n                    addJsString(n);\n                }\n            }\n            add(parameters);\n            add(body, Context.PRESERVE_BLOCK);\n            break;\n        case Token.SCRIPT:\n        case Token.BLOCK:\n            {\n                if (n.getClass() !\u003d Node.class) {\n                    throw new Error(\"Unexpected Node subclass.\");\n                }\n                boolean preserveBlock \u003d context \u003d\u003d Context.PRESERVE_BLOCK;\n                if (preserveBlock) {\n                    cc.beginBlock();\n                }\n                boolean preferLineBreaks \u003d type \u003d\u003d Token.SCRIPT || (type \u003d\u003d Token.BLOCK \u0026\u0026 !preserveBlock \u0026\u0026 n.getParent() !\u003d null \u0026\u0026 n.getParent().isScript());\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    add(c, Context.STATEMENT);\n                    if (c.isVar()) {\n                        cc.endStatement();\n                    }\n                    if (c.isFunction()) {\n                        cc.maybeLineBreak();\n                    }\n                    if (preferLineBreaks) {\n                        cc.notePreferredLineBreak();\n                    }\n                }\n                if (preserveBlock) {\n                    cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                }\n                break;\n            }\n        case Token.FOR:\n            if (childCount \u003d\u003d 4) {\n                add(\"for(\");\n                if (first.isVar()) {\n                    add(first, Context.IN_FOR_INIT_CLAUSE);\n                } else {\n                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                }\n                add(\";\");\n                add(first.getNext());\n                add(\";\");\n                add(first.getNext().getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                add(\"for(\");\n                add(first);\n                add(\"in\");\n                add(first.getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            }\n            break;\n        case Token.DO:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"do\");\n            addNonEmptyStatement(first, Context.OTHER, false);\n            add(\"while(\");\n            add(last);\n            add(\")\");\n            cc.endStatement();\n            break;\n        case Token.WHILE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"while(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.EMPTY:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            break;\n        case Token.GETPROP:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                Preconditions.checkState(last.isString(), \"Bad GETPROP: RHS should be STRING\");\n                boolean needsParens \u003d (first.isNumber());\n                if (needsParens) {\n                    add(\"(\");\n                }\n                addExpr(first, NodeUtil.precedence(type), context);\n                if (needsParens) {\n                    add(\")\");\n                }\n                add(\".\");\n                addIdentifier(last.getString());\n                break;\n            }\n        case Token.GETELEM:\n            Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n            addExpr(first, NodeUtil.precedence(type), context);\n            add(\"[\");\n            add(first.getNext());\n            add(\"]\");\n            break;\n        case Token.WITH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"with(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.INC:\n        case Token.DEC:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                if (postProp !\u003d 0) {\n                    addExpr(first, NodeUtil.precedence(type), context);\n                    cc.addOp(o, false);\n                } else {\n                    cc.addOp(o, false);\n                    add(first);\n                }\n                break;\n            }\n        case Token.CALL:\n            if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) \u0026\u0026 NodeUtil.isGet(first)) {\n                add(\"(0,\");\n                addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n                add(\")\");\n            } else {\n                addExpr(first, NodeUtil.precedence(type), context);\n            }\n            add(\"(\");\n            addList(first.getNext());\n            add(\")\");\n            break;\n        case Token.IF:\n            boolean hasElse \u003d childCount \u003d\u003d 3;\n            boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n            if (ambiguousElseClause) {\n                cc.beginBlock();\n            }\n            add(\"if(\");\n            add(first);\n            add(\")\");\n            if (hasElse) {\n                addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                add(\"else\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n                Preconditions.checkState(childCount \u003d\u003d 2);\n            }\n            if (ambiguousElseClause) {\n                cc.endBlock();\n            }\n            break;\n        case Token.NULL:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            cc.addConstant(\"null\");\n            break;\n        case Token.THIS:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"this\");\n            break;\n        case Token.FALSE:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            cc.addConstant(\"false\");\n            break;\n        case Token.TRUE:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            cc.addConstant(\"true\");\n            break;\n        case Token.CONTINUE:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"continue\");\n            if (childCount \u003d\u003d 1) {\n                if (!first.isLabelName()) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.DEBUGGER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"debugger\");\n            cc.endStatement();\n            break;\n        case Token.BREAK:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"break\");\n            if (childCount \u003d\u003d 1) {\n                if (!first.isLabelName()) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.EXPR_RESULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first, Context.START_OF_EXPR);\n            cc.endStatement();\n            break;\n        case Token.NEW:\n            add(\"new \");\n            int precedence \u003d NodeUtil.precedence(type);\n            if (NodeUtil.containsType(first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n                precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n            }\n            addExpr(first, precedence, Context.OTHER);\n            Node next \u003d first.getNext();\n            if (next !\u003d null) {\n                add(\"(\");\n                addList(next);\n                add(\")\");\n            }\n            break;\n        case Token.STRING_KEY:\n            Preconditions.checkState(childCount \u003d\u003d 1, \"Object lit key must have 1 child\");\n            addJsString(n);\n            break;\n        case Token.STRING:\n            Preconditions.checkState(childCount \u003d\u003d 0, \"A string may not have children\");\n            addJsString(n);\n            break;\n        case Token.DELPROP:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"delete \");\n            add(first);\n            break;\n        case Token.OBJECTLIT:\n            {\n                boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                add(\"{\");\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    if (c !\u003d first) {\n                        cc.listSeparator();\n                    }\n                    if (c.isGetterDef() || c.isSetterDef()) {\n                        add(c);\n                    } else {\n                        Preconditions.checkState(c.isStringKey());\n                        String key \u003d c.getString();\n                        if (!c.isQuotedString() \u0026\u0026 !TokenStream.isKeyword(key) \u0026\u0026 TokenStream.isJSIdentifier(key) \u0026\u0026 NodeUtil.isLatin(key)) {\n                            add(key);\n                        } else {\n                            double d \u003d getSimpleNumber(key);\n                            if (!Double.isNaN(d)) {\n                                cc.addNumber(d);\n                            } else {\n                                addExpr(c, 1, Context.OTHER);\n                            }\n                        }\n                        add(\":\");\n                        addExpr(c.getFirstChild(), 1, Context.OTHER);\n                    }\n                }\n                add(\"}\");\n                if (needsParens) {\n                    add(\")\");\n                }\n                break;\n            }\n        case Token.SWITCH:\n            add(\"switch(\");\n            add(first);\n            add(\")\");\n            cc.beginBlock();\n            addAllSiblings(first.getNext());\n            cc.endBlock(context \u003d\u003d Context.STATEMENT);\n            break;\n        case Token.CASE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"case \");\n            add(first);\n            addCaseBody(last);\n            break;\n        case Token.DEFAULT_CASE:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"default\");\n            addCaseBody(first);\n            break;\n        case Token.LABEL:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            if (!first.isLabelName()) {\n                throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n            }\n            add(first);\n            add(\":\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\n            break;\n        default:\n            throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n    cc.endSourceMapping(n);\n}",
      "path": "src/com/google/javascript/jscomp/CodeGenerator.java",
      "functionStartLine": 85,
      "functionName": "add",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,496 +1,496 @@\n void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n         return;\n     }\n     int type \u003d n.getType();\n     String opstr \u003d NodeUtil.opToStr(type);\n     int childCount \u003d n.getChildCount();\n     Node first \u003d n.getFirstChild();\n     Node last \u003d n.getLastChild();\n     if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n         Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n         int p \u003d NodeUtil.precedence(type);\n         Context rhsContext \u003d getContextForNoInOperator(context);\n         if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n             addExpr(first, p, context);\n             cc.addOp(opstr, true);\n             addExpr(last, p, rhsContext);\n         } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n             addExpr(first, p, context);\n             cc.addOp(opstr, true);\n             addExpr(last, p, rhsContext);\n         } else {\n             unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n         }\n         return;\n     }\n     cc.startSourceMapping(n);\n     switch(type) {\n         case Token.TRY:\n             {\n                 Preconditions.checkState(first.getNext().isBlock() \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n                 Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                 add(\"try\");\n                 add(first, Context.PRESERVE_BLOCK);\n                 Node catchblock \u003d first.getNext().getFirstChild();\n                 if (catchblock !\u003d null) {\n                     add(catchblock);\n                 }\n                 if (childCount \u003d\u003d 3) {\n                     add(\"finally\");\n                     add(last, Context.PRESERVE_BLOCK);\n                 }\n                 break;\n             }\n         case Token.CATCH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"catch(\");\n             add(first);\n             add(\")\");\n             add(last, Context.PRESERVE_BLOCK);\n             break;\n         case Token.THROW:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"throw\");\n             add(first);\n             cc.endStatement(true);\n             break;\n         case Token.RETURN:\n             add(\"return\");\n             if (childCount \u003d\u003d 1) {\n                 add(first);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 0);\n             }\n             cc.endStatement();\n             break;\n         case Token.VAR:\n             if (first !\u003d null) {\n                 add(\"var \");\n                 addList(first, false, getContextForNoInOperator(context));\n             }\n             break;\n         case Token.LABEL_NAME:\n             Preconditions.checkState(!n.getString().isEmpty());\n             addIdentifier(n.getString());\n             break;\n         case Token.NAME:\n             if (first \u003d\u003d null || first.isEmpty()) {\n                 addIdentifier(n.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 addIdentifier(n.getString());\n                 cc.addOp(\"\u003d\", true);\n                 if (first.isComma()) {\n                     addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n                 } else {\n                     addExpr(first, 0, getContextForNoInOperator(context));\n                 }\n             }\n             break;\n         case Token.ARRAYLIT:\n             add(\"[\");\n             addArrayList(first);\n             add(\"]\");\n             break;\n         case Token.PARAM_LIST:\n             add(\"(\");\n             addList(first);\n             add(\")\");\n             break;\n         case Token.COMMA:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             unrollBinaryOperator(n, Token.COMMA, \",\", context, Context.OTHER, 0, 0);\n             break;\n         case Token.NUMBER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             cc.addNumber(n.getDouble());\n             break;\n         case Token.TYPEOF:\n         case Token.VOID:\n         case Token.NOT:\n         case Token.BITNOT:\n         case Token.POS:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                 addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n                 break;\n             }\n         case Token.NEG:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 if (n.getFirstChild().isNumber()) {\n                     cc.addNumber(-n.getFirstChild().getDouble());\n                 } else {\n                     cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                     addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n                 }\n                 break;\n             }\n         case Token.HOOK:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 int p \u003d NodeUtil.precedence(type);\n                 addExpr(first, p + 1, context);\n                 cc.addOp(\"?\", true);\n                 addExpr(first.getNext(), 1, Context.OTHER);\n                 cc.addOp(\":\", true);\n                 addExpr(last, 1, Context.OTHER);\n                 break;\n             }\n         case Token.REGEXP:\n             if (!first.isString() || !last.isString()) {\n                 throw new Error(\"Expected children to be strings\");\n             }\n             String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n             if (childCount \u003d\u003d 2) {\n                 add(regexp + last.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 add(regexp);\n             }\n             break;\n         case Token.FUNCTION:\n             if (n.getClass() !\u003d Node.class) {\n                 throw new Error(\"Unexpected Node subclass.\");\n             }\n             Preconditions.checkState(childCount \u003d\u003d 3);\n             boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n             if (funcNeedsParens) {\n                 add(\"(\");\n             }\n             add(\"function\");\n             add(first);\n             add(first.getNext());\n             add(last, Context.PRESERVE_BLOCK);\n             cc.endFunction(context \u003d\u003d Context.STATEMENT);\n             if (funcNeedsParens) {\n                 add(\")\");\n             }\n             break;\n         case Token.GETTER_DEF:\n         case Token.SETTER_DEF:\n             Preconditions.checkState(n.getParent().isObjectLit());\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             Preconditions.checkState(first.isFunction());\n             Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n             if (type \u003d\u003d Token.GETTER_DEF) {\n                 Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n                 add(\"get \");\n             } else {\n                 Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n                 add(\"set \");\n             }\n             String name \u003d n.getString();\n             Node fn \u003d first;\n             Node parameters \u003d fn.getChildAtIndex(1);\n             Node body \u003d fn.getLastChild();\n             if (!n.isQuotedString() \u0026\u0026 TokenStream.isJSIdentifier(name) \u0026\u0026 NodeUtil.isLatin(name)) {\n                 add(name);\n             } else {\n                 double d \u003d getSimpleNumber(name);\n                 if (!Double.isNaN(d)) {\n                     cc.addNumber(d);\n                 } else {\n                     addJsString(n);\n                 }\n             }\n             add(parameters);\n             add(body, Context.PRESERVE_BLOCK);\n             break;\n         case Token.SCRIPT:\n         case Token.BLOCK:\n             {\n                 if (n.getClass() !\u003d Node.class) {\n                     throw new Error(\"Unexpected Node subclass.\");\n                 }\n                 boolean preserveBlock \u003d context \u003d\u003d Context.PRESERVE_BLOCK;\n                 if (preserveBlock) {\n                     cc.beginBlock();\n                 }\n                 boolean preferLineBreaks \u003d type \u003d\u003d Token.SCRIPT || (type \u003d\u003d Token.BLOCK \u0026\u0026 !preserveBlock \u0026\u0026 n.getParent() !\u003d null \u0026\u0026 n.getParent().isScript());\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     add(c, Context.STATEMENT);\n                     if (c.isVar()) {\n                         cc.endStatement();\n                     }\n                     if (c.isFunction()) {\n                         cc.maybeLineBreak();\n                     }\n                     if (preferLineBreaks) {\n                         cc.notePreferredLineBreak();\n                     }\n                 }\n                 if (preserveBlock) {\n                     cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                 }\n                 break;\n             }\n         case Token.FOR:\n             if (childCount \u003d\u003d 4) {\n                 add(\"for(\");\n                 if (first.isVar()) {\n                     add(first, Context.IN_FOR_INIT_CLAUSE);\n                 } else {\n                     addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                 }\n                 add(\";\");\n                 add(first.getNext());\n                 add(\";\");\n                 add(first.getNext().getNext());\n                 add(\")\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 add(\"for(\");\n                 add(first);\n                 add(\"in\");\n                 add(first.getNext());\n                 add(\")\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             }\n             break;\n         case Token.DO:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"do\");\n             addNonEmptyStatement(first, Context.OTHER, false);\n             add(\"while(\");\n             add(last);\n             add(\")\");\n             cc.endStatement();\n             break;\n         case Token.WHILE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"while(\");\n             add(first);\n             add(\")\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.EMPTY:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             break;\n         case Token.GETPROP:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                 Preconditions.checkState(last.isString(), \"Bad GETPROP: RHS should be STRING\");\n                 boolean needsParens \u003d (first.isNumber());\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 addExpr(first, NodeUtil.precedence(type), context);\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 add(\".\");\n                 addIdentifier(last.getString());\n                 break;\n             }\n         case Token.GETELEM:\n             Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n             addExpr(first, NodeUtil.precedence(type), context);\n             add(\"[\");\n             add(first.getNext());\n             add(\"]\");\n             break;\n         case Token.WITH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"with(\");\n             add(first);\n             add(\")\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.INC:\n         case Token.DEC:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                 int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                 if (postProp !\u003d 0) {\n                     addExpr(first, NodeUtil.precedence(type), context);\n                     cc.addOp(o, false);\n                 } else {\n                     cc.addOp(o, false);\n                     add(first);\n                 }\n                 break;\n             }\n         case Token.CALL:\n             if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) \u0026\u0026 NodeUtil.isGet(first)) {\n                 add(\"(0,\");\n                 addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n                 add(\")\");\n             } else {\n                 addExpr(first, NodeUtil.precedence(type), context);\n             }\n             add(\"(\");\n             addList(first.getNext());\n             add(\")\");\n             break;\n         case Token.IF:\n             boolean hasElse \u003d childCount \u003d\u003d 3;\n             boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n             if (ambiguousElseClause) {\n                 cc.beginBlock();\n             }\n             add(\"if(\");\n             add(first);\n             add(\")\");\n             if (hasElse) {\n                 addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                 add(\"else\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n                 Preconditions.checkState(childCount \u003d\u003d 2);\n             }\n             if (ambiguousElseClause) {\n                 cc.endBlock();\n             }\n             break;\n         case Token.NULL:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n-            add(\"null\");\n+            cc.addConstant(\"null\");\n             break;\n         case Token.THIS:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(\"this\");\n             break;\n         case Token.FALSE:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n-            add(\"false\");\n+            cc.addConstant(\"false\");\n             break;\n         case Token.TRUE:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n-            add(\"true\");\n+            cc.addConstant(\"true\");\n             break;\n         case Token.CONTINUE:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"continue\");\n             if (childCount \u003d\u003d 1) {\n                 if (!first.isLabelName()) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.DEBUGGER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(\"debugger\");\n             cc.endStatement();\n             break;\n         case Token.BREAK:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"break\");\n             if (childCount \u003d\u003d 1) {\n                 if (!first.isLabelName()) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.EXPR_RESULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first, Context.START_OF_EXPR);\n             cc.endStatement();\n             break;\n         case Token.NEW:\n             add(\"new \");\n             int precedence \u003d NodeUtil.precedence(type);\n             if (NodeUtil.containsType(first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n                 precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n             }\n             addExpr(first, precedence, Context.OTHER);\n             Node next \u003d first.getNext();\n             if (next !\u003d null) {\n                 add(\"(\");\n                 addList(next);\n                 add(\")\");\n             }\n             break;\n         case Token.STRING_KEY:\n             Preconditions.checkState(childCount \u003d\u003d 1, \"Object lit key must have 1 child\");\n             addJsString(n);\n             break;\n         case Token.STRING:\n             Preconditions.checkState(childCount \u003d\u003d 0, \"A string may not have children\");\n             addJsString(n);\n             break;\n         case Token.DELPROP:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"delete \");\n             add(first);\n             break;\n         case Token.OBJECTLIT:\n             {\n                 boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 add(\"{\");\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     if (c !\u003d first) {\n                         cc.listSeparator();\n                     }\n                     if (c.isGetterDef() || c.isSetterDef()) {\n                         add(c);\n                     } else {\n                         Preconditions.checkState(c.isStringKey());\n                         String key \u003d c.getString();\n                         if (!c.isQuotedString() \u0026\u0026 !TokenStream.isKeyword(key) \u0026\u0026 TokenStream.isJSIdentifier(key) \u0026\u0026 NodeUtil.isLatin(key)) {\n                             add(key);\n                         } else {\n                             double d \u003d getSimpleNumber(key);\n                             if (!Double.isNaN(d)) {\n                                 cc.addNumber(d);\n                             } else {\n                                 addExpr(c, 1, Context.OTHER);\n                             }\n                         }\n                         add(\":\");\n                         addExpr(c.getFirstChild(), 1, Context.OTHER);\n                     }\n                 }\n                 add(\"}\");\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 break;\n             }\n         case Token.SWITCH:\n             add(\"switch(\");\n             add(first);\n             add(\")\");\n             cc.beginBlock();\n             addAllSiblings(first.getNext());\n             cc.endBlock(context \u003d\u003d Context.STATEMENT);\n             break;\n         case Token.CASE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"case \");\n             add(first);\n             addCaseBody(last);\n             break;\n         case Token.DEFAULT_CASE:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"default\");\n             addCaseBody(first);\n             break;\n         case Token.LABEL:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             if (!first.isLabelName()) {\n                 throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n             }\n             add(first);\n             add(\":\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\n             break;\n         default:\n             throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n     }\n     cc.endSourceMapping(n);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f412f0c0efd54842b30207c845d65cb826217fd6": {
      "type": "Ybodychange",
      "commitMessage": "\nCreate a separate token for object literal keys.\ni was surprised how easy this was\n\nR\u003dacleung,johnlenz\nDELTA\u003d139  (52 added, 26 deleted, 61 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d4618\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1922 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/25/12, 1:34 PM",
      "commitName": "f412f0c0efd54842b30207c845d65cb826217fd6",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "3/27/12, 8:38 AM",
      "commitNameOld": "87b154f89cba3c67045cd7a783b79231d0630a4c",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 29.21,
      "commitsBetweenForRepo": 63,
      "commitsBetweenForFile": 1,
      "actualSource": "void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n        return;\n    }\n    int type \u003d n.getType();\n    String opstr \u003d NodeUtil.opToStr(type);\n    int childCount \u003d n.getChildCount();\n    Node first \u003d n.getFirstChild();\n    Node last \u003d n.getLastChild();\n    if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n        Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n        int p \u003d NodeUtil.precedence(type);\n        Context rhsContext \u003d getContextForNoInOperator(context);\n        if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n            addExpr(first, p, context);\n            cc.addOp(opstr, true);\n            addExpr(last, p, rhsContext);\n        } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n            addExpr(first, p, context);\n            cc.addOp(opstr, true);\n            addExpr(last, p, rhsContext);\n        } else {\n            unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n        }\n        return;\n    }\n    cc.startSourceMapping(n);\n    switch(type) {\n        case Token.TRY:\n            {\n                Preconditions.checkState(first.getNext().isBlock() \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n                Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                add(\"try\");\n                add(first, Context.PRESERVE_BLOCK);\n                Node catchblock \u003d first.getNext().getFirstChild();\n                if (catchblock !\u003d null) {\n                    add(catchblock);\n                }\n                if (childCount \u003d\u003d 3) {\n                    add(\"finally\");\n                    add(last, Context.PRESERVE_BLOCK);\n                }\n                break;\n            }\n        case Token.CATCH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"catch(\");\n            add(first);\n            add(\")\");\n            add(last, Context.PRESERVE_BLOCK);\n            break;\n        case Token.THROW:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"throw\");\n            add(first);\n            cc.endStatement(true);\n            break;\n        case Token.RETURN:\n            add(\"return\");\n            if (childCount \u003d\u003d 1) {\n                add(first);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 0);\n            }\n            cc.endStatement();\n            break;\n        case Token.VAR:\n            if (first !\u003d null) {\n                add(\"var \");\n                addList(first, false, getContextForNoInOperator(context));\n            }\n            break;\n        case Token.LABEL_NAME:\n            Preconditions.checkState(!n.getString().isEmpty());\n            addIdentifier(n.getString());\n            break;\n        case Token.NAME:\n            if (first \u003d\u003d null || first.isEmpty()) {\n                addIdentifier(n.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                addIdentifier(n.getString());\n                cc.addOp(\"\u003d\", true);\n                if (first.isComma()) {\n                    addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n                } else {\n                    addExpr(first, 0, getContextForNoInOperator(context));\n                }\n            }\n            break;\n        case Token.ARRAYLIT:\n            add(\"[\");\n            addArrayList(first);\n            add(\"]\");\n            break;\n        case Token.PARAM_LIST:\n            add(\"(\");\n            addList(first);\n            add(\")\");\n            break;\n        case Token.COMMA:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            unrollBinaryOperator(n, Token.COMMA, \",\", context, Context.OTHER, 0, 0);\n            break;\n        case Token.NUMBER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            cc.addNumber(n.getDouble());\n            break;\n        case Token.TYPEOF:\n        case Token.VOID:\n        case Token.NOT:\n        case Token.BITNOT:\n        case Token.POS:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n                break;\n            }\n        case Token.NEG:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                if (n.getFirstChild().isNumber()) {\n                    cc.addNumber(-n.getFirstChild().getDouble());\n                } else {\n                    cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                    addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n                }\n                break;\n            }\n        case Token.HOOK:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                int p \u003d NodeUtil.precedence(type);\n                addExpr(first, p + 1, context);\n                cc.addOp(\"?\", true);\n                addExpr(first.getNext(), 1, Context.OTHER);\n                cc.addOp(\":\", true);\n                addExpr(last, 1, Context.OTHER);\n                break;\n            }\n        case Token.REGEXP:\n            if (!first.isString() || !last.isString()) {\n                throw new Error(\"Expected children to be strings\");\n            }\n            String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n            if (childCount \u003d\u003d 2) {\n                add(regexp + last.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                add(regexp);\n            }\n            break;\n        case Token.FUNCTION:\n            if (n.getClass() !\u003d Node.class) {\n                throw new Error(\"Unexpected Node subclass.\");\n            }\n            Preconditions.checkState(childCount \u003d\u003d 3);\n            boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n            if (funcNeedsParens) {\n                add(\"(\");\n            }\n            add(\"function\");\n            add(first);\n            add(first.getNext());\n            add(last, Context.PRESERVE_BLOCK);\n            cc.endFunction(context \u003d\u003d Context.STATEMENT);\n            if (funcNeedsParens) {\n                add(\")\");\n            }\n            break;\n        case Token.GETTER_DEF:\n        case Token.SETTER_DEF:\n            Preconditions.checkState(n.getParent().isObjectLit());\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            Preconditions.checkState(first.isFunction());\n            Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n            if (type \u003d\u003d Token.GETTER_DEF) {\n                Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n                add(\"get \");\n            } else {\n                Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n                add(\"set \");\n            }\n            String name \u003d n.getString();\n            Node fn \u003d first;\n            Node parameters \u003d fn.getChildAtIndex(1);\n            Node body \u003d fn.getLastChild();\n            if (!n.isQuotedString() \u0026\u0026 TokenStream.isJSIdentifier(name) \u0026\u0026 NodeUtil.isLatin(name)) {\n                add(name);\n            } else {\n                double d \u003d getSimpleNumber(name);\n                if (!Double.isNaN(d)) {\n                    cc.addNumber(d);\n                } else {\n                    addJsString(n);\n                }\n            }\n            add(parameters);\n            add(body, Context.PRESERVE_BLOCK);\n            break;\n        case Token.SCRIPT:\n        case Token.BLOCK:\n            {\n                if (n.getClass() !\u003d Node.class) {\n                    throw new Error(\"Unexpected Node subclass.\");\n                }\n                boolean preserveBlock \u003d context \u003d\u003d Context.PRESERVE_BLOCK;\n                if (preserveBlock) {\n                    cc.beginBlock();\n                }\n                boolean preferLineBreaks \u003d type \u003d\u003d Token.SCRIPT || (type \u003d\u003d Token.BLOCK \u0026\u0026 !preserveBlock \u0026\u0026 n.getParent() !\u003d null \u0026\u0026 n.getParent().isScript());\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    add(c, Context.STATEMENT);\n                    if (c.isVar()) {\n                        cc.endStatement();\n                    }\n                    if (c.isFunction()) {\n                        cc.maybeLineBreak();\n                    }\n                    if (preferLineBreaks) {\n                        cc.notePreferredLineBreak();\n                    }\n                }\n                if (preserveBlock) {\n                    cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                }\n                break;\n            }\n        case Token.FOR:\n            if (childCount \u003d\u003d 4) {\n                add(\"for(\");\n                if (first.isVar()) {\n                    add(first, Context.IN_FOR_INIT_CLAUSE);\n                } else {\n                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                }\n                add(\";\");\n                add(first.getNext());\n                add(\";\");\n                add(first.getNext().getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                add(\"for(\");\n                add(first);\n                add(\"in\");\n                add(first.getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            }\n            break;\n        case Token.DO:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"do\");\n            addNonEmptyStatement(first, Context.OTHER, false);\n            add(\"while(\");\n            add(last);\n            add(\")\");\n            cc.endStatement();\n            break;\n        case Token.WHILE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"while(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.EMPTY:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            break;\n        case Token.GETPROP:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                Preconditions.checkState(last.isString(), \"Bad GETPROP: RHS should be STRING\");\n                boolean needsParens \u003d (first.isNumber());\n                if (needsParens) {\n                    add(\"(\");\n                }\n                addExpr(first, NodeUtil.precedence(type), context);\n                if (needsParens) {\n                    add(\")\");\n                }\n                add(\".\");\n                addIdentifier(last.getString());\n                break;\n            }\n        case Token.GETELEM:\n            Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n            addExpr(first, NodeUtil.precedence(type), context);\n            add(\"[\");\n            add(first.getNext());\n            add(\"]\");\n            break;\n        case Token.WITH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"with(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.INC:\n        case Token.DEC:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                if (postProp !\u003d 0) {\n                    addExpr(first, NodeUtil.precedence(type), context);\n                    cc.addOp(o, false);\n                } else {\n                    cc.addOp(o, false);\n                    add(first);\n                }\n                break;\n            }\n        case Token.CALL:\n            if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) \u0026\u0026 NodeUtil.isGet(first)) {\n                add(\"(0,\");\n                addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n                add(\")\");\n            } else {\n                addExpr(first, NodeUtil.precedence(type), context);\n            }\n            add(\"(\");\n            addList(first.getNext());\n            add(\")\");\n            break;\n        case Token.IF:\n            boolean hasElse \u003d childCount \u003d\u003d 3;\n            boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n            if (ambiguousElseClause) {\n                cc.beginBlock();\n            }\n            add(\"if(\");\n            add(first);\n            add(\")\");\n            if (hasElse) {\n                addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                add(\"else\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n                Preconditions.checkState(childCount \u003d\u003d 2);\n            }\n            if (ambiguousElseClause) {\n                cc.endBlock();\n            }\n            break;\n        case Token.NULL:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"null\");\n            break;\n        case Token.THIS:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"this\");\n            break;\n        case Token.FALSE:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"false\");\n            break;\n        case Token.TRUE:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"true\");\n            break;\n        case Token.CONTINUE:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"continue\");\n            if (childCount \u003d\u003d 1) {\n                if (!first.isLabelName()) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.DEBUGGER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"debugger\");\n            cc.endStatement();\n            break;\n        case Token.BREAK:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"break\");\n            if (childCount \u003d\u003d 1) {\n                if (!first.isLabelName()) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.EXPR_RESULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first, Context.START_OF_EXPR);\n            cc.endStatement();\n            break;\n        case Token.NEW:\n            add(\"new \");\n            int precedence \u003d NodeUtil.precedence(type);\n            if (NodeUtil.containsType(first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n                precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n            }\n            addExpr(first, precedence, Context.OTHER);\n            Node next \u003d first.getNext();\n            if (next !\u003d null) {\n                add(\"(\");\n                addList(next);\n                add(\")\");\n            }\n            break;\n        case Token.STRING_KEY:\n            Preconditions.checkState(childCount \u003d\u003d 1, \"Object lit key must have 1 child\");\n            addJsString(n);\n            break;\n        case Token.STRING:\n            Preconditions.checkState(childCount \u003d\u003d 0, \"A string may not have children\");\n            addJsString(n);\n            break;\n        case Token.DELPROP:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"delete \");\n            add(first);\n            break;\n        case Token.OBJECTLIT:\n            {\n                boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                add(\"{\");\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    if (c !\u003d first) {\n                        cc.listSeparator();\n                    }\n                    if (c.isGetterDef() || c.isSetterDef()) {\n                        add(c);\n                    } else {\n                        Preconditions.checkState(c.isStringKey());\n                        String key \u003d c.getString();\n                        if (!c.isQuotedString() \u0026\u0026 !TokenStream.isKeyword(key) \u0026\u0026 TokenStream.isJSIdentifier(key) \u0026\u0026 NodeUtil.isLatin(key)) {\n                            add(key);\n                        } else {\n                            double d \u003d getSimpleNumber(key);\n                            if (!Double.isNaN(d)) {\n                                cc.addNumber(d);\n                            } else {\n                                addExpr(c, 1, Context.OTHER);\n                            }\n                        }\n                        add(\":\");\n                        addExpr(c.getFirstChild(), 1, Context.OTHER);\n                    }\n                }\n                add(\"}\");\n                if (needsParens) {\n                    add(\")\");\n                }\n                break;\n            }\n        case Token.SWITCH:\n            add(\"switch(\");\n            add(first);\n            add(\")\");\n            cc.beginBlock();\n            addAllSiblings(first.getNext());\n            cc.endBlock(context \u003d\u003d Context.STATEMENT);\n            break;\n        case Token.CASE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"case \");\n            add(first);\n            addCaseBody(last);\n            break;\n        case Token.DEFAULT_CASE:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"default\");\n            addCaseBody(first);\n            break;\n        case Token.LABEL:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            if (!first.isLabelName()) {\n                throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n            }\n            add(first);\n            add(\":\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\n            break;\n        default:\n            throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n    cc.endSourceMapping(n);\n}",
      "path": "src/com/google/javascript/jscomp/CodeGenerator.java",
      "functionStartLine": 85,
      "functionName": "add",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,494 +1,496 @@\n void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n         return;\n     }\n     int type \u003d n.getType();\n     String opstr \u003d NodeUtil.opToStr(type);\n     int childCount \u003d n.getChildCount();\n     Node first \u003d n.getFirstChild();\n     Node last \u003d n.getLastChild();\n     if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n         Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n         int p \u003d NodeUtil.precedence(type);\n         Context rhsContext \u003d getContextForNoInOperator(context);\n         if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n             addExpr(first, p, context);\n             cc.addOp(opstr, true);\n             addExpr(last, p, rhsContext);\n         } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n             addExpr(first, p, context);\n             cc.addOp(opstr, true);\n             addExpr(last, p, rhsContext);\n         } else {\n             unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n         }\n         return;\n     }\n     cc.startSourceMapping(n);\n     switch(type) {\n         case Token.TRY:\n             {\n                 Preconditions.checkState(first.getNext().isBlock() \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n                 Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                 add(\"try\");\n                 add(first, Context.PRESERVE_BLOCK);\n                 Node catchblock \u003d first.getNext().getFirstChild();\n                 if (catchblock !\u003d null) {\n                     add(catchblock);\n                 }\n                 if (childCount \u003d\u003d 3) {\n                     add(\"finally\");\n                     add(last, Context.PRESERVE_BLOCK);\n                 }\n                 break;\n             }\n         case Token.CATCH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"catch(\");\n             add(first);\n             add(\")\");\n             add(last, Context.PRESERVE_BLOCK);\n             break;\n         case Token.THROW:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"throw\");\n             add(first);\n             cc.endStatement(true);\n             break;\n         case Token.RETURN:\n             add(\"return\");\n             if (childCount \u003d\u003d 1) {\n                 add(first);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 0);\n             }\n             cc.endStatement();\n             break;\n         case Token.VAR:\n             if (first !\u003d null) {\n                 add(\"var \");\n                 addList(first, false, getContextForNoInOperator(context));\n             }\n             break;\n         case Token.LABEL_NAME:\n             Preconditions.checkState(!n.getString().isEmpty());\n             addIdentifier(n.getString());\n             break;\n         case Token.NAME:\n             if (first \u003d\u003d null || first.isEmpty()) {\n                 addIdentifier(n.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 addIdentifier(n.getString());\n                 cc.addOp(\"\u003d\", true);\n                 if (first.isComma()) {\n                     addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n                 } else {\n                     addExpr(first, 0, getContextForNoInOperator(context));\n                 }\n             }\n             break;\n         case Token.ARRAYLIT:\n             add(\"[\");\n             addArrayList(first);\n             add(\"]\");\n             break;\n         case Token.PARAM_LIST:\n             add(\"(\");\n             addList(first);\n             add(\")\");\n             break;\n         case Token.COMMA:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             unrollBinaryOperator(n, Token.COMMA, \",\", context, Context.OTHER, 0, 0);\n             break;\n         case Token.NUMBER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             cc.addNumber(n.getDouble());\n             break;\n         case Token.TYPEOF:\n         case Token.VOID:\n         case Token.NOT:\n         case Token.BITNOT:\n         case Token.POS:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                 addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n                 break;\n             }\n         case Token.NEG:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 if (n.getFirstChild().isNumber()) {\n                     cc.addNumber(-n.getFirstChild().getDouble());\n                 } else {\n                     cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                     addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n                 }\n                 break;\n             }\n         case Token.HOOK:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 int p \u003d NodeUtil.precedence(type);\n                 addExpr(first, p + 1, context);\n                 cc.addOp(\"?\", true);\n                 addExpr(first.getNext(), 1, Context.OTHER);\n                 cc.addOp(\":\", true);\n                 addExpr(last, 1, Context.OTHER);\n                 break;\n             }\n         case Token.REGEXP:\n             if (!first.isString() || !last.isString()) {\n                 throw new Error(\"Expected children to be strings\");\n             }\n             String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n             if (childCount \u003d\u003d 2) {\n                 add(regexp + last.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 add(regexp);\n             }\n             break;\n         case Token.FUNCTION:\n             if (n.getClass() !\u003d Node.class) {\n                 throw new Error(\"Unexpected Node subclass.\");\n             }\n             Preconditions.checkState(childCount \u003d\u003d 3);\n             boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n             if (funcNeedsParens) {\n                 add(\"(\");\n             }\n             add(\"function\");\n             add(first);\n             add(first.getNext());\n             add(last, Context.PRESERVE_BLOCK);\n             cc.endFunction(context \u003d\u003d Context.STATEMENT);\n             if (funcNeedsParens) {\n                 add(\")\");\n             }\n             break;\n         case Token.GETTER_DEF:\n         case Token.SETTER_DEF:\n             Preconditions.checkState(n.getParent().isObjectLit());\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             Preconditions.checkState(first.isFunction());\n             Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n             if (type \u003d\u003d Token.GETTER_DEF) {\n                 Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n                 add(\"get \");\n             } else {\n                 Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n                 add(\"set \");\n             }\n             String name \u003d n.getString();\n             Node fn \u003d first;\n             Node parameters \u003d fn.getChildAtIndex(1);\n             Node body \u003d fn.getLastChild();\n             if (!n.isQuotedString() \u0026\u0026 TokenStream.isJSIdentifier(name) \u0026\u0026 NodeUtil.isLatin(name)) {\n                 add(name);\n             } else {\n                 double d \u003d getSimpleNumber(name);\n                 if (!Double.isNaN(d)) {\n                     cc.addNumber(d);\n                 } else {\n                     addJsString(n);\n                 }\n             }\n             add(parameters);\n             add(body, Context.PRESERVE_BLOCK);\n             break;\n         case Token.SCRIPT:\n         case Token.BLOCK:\n             {\n                 if (n.getClass() !\u003d Node.class) {\n                     throw new Error(\"Unexpected Node subclass.\");\n                 }\n                 boolean preserveBlock \u003d context \u003d\u003d Context.PRESERVE_BLOCK;\n                 if (preserveBlock) {\n                     cc.beginBlock();\n                 }\n                 boolean preferLineBreaks \u003d type \u003d\u003d Token.SCRIPT || (type \u003d\u003d Token.BLOCK \u0026\u0026 !preserveBlock \u0026\u0026 n.getParent() !\u003d null \u0026\u0026 n.getParent().isScript());\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     add(c, Context.STATEMENT);\n                     if (c.isVar()) {\n                         cc.endStatement();\n                     }\n                     if (c.isFunction()) {\n                         cc.maybeLineBreak();\n                     }\n                     if (preferLineBreaks) {\n                         cc.notePreferredLineBreak();\n                     }\n                 }\n                 if (preserveBlock) {\n                     cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                 }\n                 break;\n             }\n         case Token.FOR:\n             if (childCount \u003d\u003d 4) {\n                 add(\"for(\");\n                 if (first.isVar()) {\n                     add(first, Context.IN_FOR_INIT_CLAUSE);\n                 } else {\n                     addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                 }\n                 add(\";\");\n                 add(first.getNext());\n                 add(\";\");\n                 add(first.getNext().getNext());\n                 add(\")\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 add(\"for(\");\n                 add(first);\n                 add(\"in\");\n                 add(first.getNext());\n                 add(\")\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             }\n             break;\n         case Token.DO:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"do\");\n             addNonEmptyStatement(first, Context.OTHER, false);\n             add(\"while(\");\n             add(last);\n             add(\")\");\n             cc.endStatement();\n             break;\n         case Token.WHILE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"while(\");\n             add(first);\n             add(\")\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.EMPTY:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             break;\n         case Token.GETPROP:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                 Preconditions.checkState(last.isString(), \"Bad GETPROP: RHS should be STRING\");\n                 boolean needsParens \u003d (first.isNumber());\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 addExpr(first, NodeUtil.precedence(type), context);\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 add(\".\");\n                 addIdentifier(last.getString());\n                 break;\n             }\n         case Token.GETELEM:\n             Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n             addExpr(first, NodeUtil.precedence(type), context);\n             add(\"[\");\n             add(first.getNext());\n             add(\"]\");\n             break;\n         case Token.WITH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"with(\");\n             add(first);\n             add(\")\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.INC:\n         case Token.DEC:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                 int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                 if (postProp !\u003d 0) {\n                     addExpr(first, NodeUtil.precedence(type), context);\n                     cc.addOp(o, false);\n                 } else {\n                     cc.addOp(o, false);\n                     add(first);\n                 }\n                 break;\n             }\n         case Token.CALL:\n             if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) \u0026\u0026 NodeUtil.isGet(first)) {\n                 add(\"(0,\");\n                 addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n                 add(\")\");\n             } else {\n                 addExpr(first, NodeUtil.precedence(type), context);\n             }\n             add(\"(\");\n             addList(first.getNext());\n             add(\")\");\n             break;\n         case Token.IF:\n             boolean hasElse \u003d childCount \u003d\u003d 3;\n             boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n             if (ambiguousElseClause) {\n                 cc.beginBlock();\n             }\n             add(\"if(\");\n             add(first);\n             add(\")\");\n             if (hasElse) {\n                 addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                 add(\"else\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n                 Preconditions.checkState(childCount \u003d\u003d 2);\n             }\n             if (ambiguousElseClause) {\n                 cc.endBlock();\n             }\n             break;\n         case Token.NULL:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(\"null\");\n             break;\n         case Token.THIS:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(\"this\");\n             break;\n         case Token.FALSE:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(\"false\");\n             break;\n         case Token.TRUE:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(\"true\");\n             break;\n         case Token.CONTINUE:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"continue\");\n             if (childCount \u003d\u003d 1) {\n                 if (!first.isLabelName()) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.DEBUGGER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(\"debugger\");\n             cc.endStatement();\n             break;\n         case Token.BREAK:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"break\");\n             if (childCount \u003d\u003d 1) {\n                 if (!first.isLabelName()) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.EXPR_RESULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first, Context.START_OF_EXPR);\n             cc.endStatement();\n             break;\n         case Token.NEW:\n             add(\"new \");\n             int precedence \u003d NodeUtil.precedence(type);\n             if (NodeUtil.containsType(first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n                 precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n             }\n             addExpr(first, precedence, Context.OTHER);\n             Node next \u003d first.getNext();\n             if (next !\u003d null) {\n                 add(\"(\");\n                 addList(next);\n                 add(\")\");\n             }\n             break;\n+        case Token.STRING_KEY:\n+            Preconditions.checkState(childCount \u003d\u003d 1, \"Object lit key must have 1 child\");\n+            addJsString(n);\n+            break;\n         case Token.STRING:\n-            if (childCount !\u003d ((n.getParent() !\u003d null \u0026\u0026 n.getParent().isObjectLit()) ? 1 : 0)) {\n-                throw new IllegalStateException(\"Unexpected String children: \" + n.getParent().toStringTree());\n-            }\n+            Preconditions.checkState(childCount \u003d\u003d 0, \"A string may not have children\");\n             addJsString(n);\n             break;\n         case Token.DELPROP:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"delete \");\n             add(first);\n             break;\n         case Token.OBJECTLIT:\n             {\n                 boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 add(\"{\");\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     if (c !\u003d first) {\n                         cc.listSeparator();\n                     }\n                     if (c.isGetterDef() || c.isSetterDef()) {\n                         add(c);\n                     } else {\n-                        Preconditions.checkState(c.isString());\n+                        Preconditions.checkState(c.isStringKey());\n                         String key \u003d c.getString();\n                         if (!c.isQuotedString() \u0026\u0026 !TokenStream.isKeyword(key) \u0026\u0026 TokenStream.isJSIdentifier(key) \u0026\u0026 NodeUtil.isLatin(key)) {\n                             add(key);\n                         } else {\n                             double d \u003d getSimpleNumber(key);\n                             if (!Double.isNaN(d)) {\n                                 cc.addNumber(d);\n                             } else {\n                                 addExpr(c, 1, Context.OTHER);\n                             }\n                         }\n                         add(\":\");\n                         addExpr(c.getFirstChild(), 1, Context.OTHER);\n                     }\n                 }\n                 add(\"}\");\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 break;\n             }\n         case Token.SWITCH:\n             add(\"switch(\");\n             add(first);\n             add(\")\");\n             cc.beginBlock();\n             addAllSiblings(first.getNext());\n             cc.endBlock(context \u003d\u003d Context.STATEMENT);\n             break;\n         case Token.CASE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"case \");\n             add(first);\n             addCaseBody(last);\n             break;\n         case Token.DEFAULT_CASE:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"default\");\n             addCaseBody(first);\n             break;\n         case Token.LABEL:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             if (!first.isLabelName()) {\n                 throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n             }\n             add(first);\n             add(\":\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\n             break;\n         default:\n             throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n     }\n     cc.endSourceMapping(n);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "87b154f89cba3c67045cd7a783b79231d0630a4c": {
      "type": "Ybodychange",
      "commitMessage": "\nMore recursion unrolling\nFixes issue 691\n\nR\u003djohnlenz\nDELTA\u003d78  (54 added, 21 deleted, 3 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d4425\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1849 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "3/27/12, 8:38 AM",
      "commitName": "87b154f89cba3c67045cd7a783b79231d0630a4c",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "2/8/12, 4:28 PM",
      "commitNameOld": "746e26420bb2dde1339a72f15199373ab0182d33",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 47.63,
      "commitsBetweenForRepo": 65,
      "commitsBetweenForFile": 1,
      "actualSource": "void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n        return;\n    }\n    int type \u003d n.getType();\n    String opstr \u003d NodeUtil.opToStr(type);\n    int childCount \u003d n.getChildCount();\n    Node first \u003d n.getFirstChild();\n    Node last \u003d n.getLastChild();\n    if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n        Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n        int p \u003d NodeUtil.precedence(type);\n        Context rhsContext \u003d getContextForNoInOperator(context);\n        if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n            addExpr(first, p, context);\n            cc.addOp(opstr, true);\n            addExpr(last, p, rhsContext);\n        } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n            addExpr(first, p, context);\n            cc.addOp(opstr, true);\n            addExpr(last, p, rhsContext);\n        } else {\n            unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n        }\n        return;\n    }\n    cc.startSourceMapping(n);\n    switch(type) {\n        case Token.TRY:\n            {\n                Preconditions.checkState(first.getNext().isBlock() \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n                Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                add(\"try\");\n                add(first, Context.PRESERVE_BLOCK);\n                Node catchblock \u003d first.getNext().getFirstChild();\n                if (catchblock !\u003d null) {\n                    add(catchblock);\n                }\n                if (childCount \u003d\u003d 3) {\n                    add(\"finally\");\n                    add(last, Context.PRESERVE_BLOCK);\n                }\n                break;\n            }\n        case Token.CATCH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"catch(\");\n            add(first);\n            add(\")\");\n            add(last, Context.PRESERVE_BLOCK);\n            break;\n        case Token.THROW:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"throw\");\n            add(first);\n            cc.endStatement(true);\n            break;\n        case Token.RETURN:\n            add(\"return\");\n            if (childCount \u003d\u003d 1) {\n                add(first);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 0);\n            }\n            cc.endStatement();\n            break;\n        case Token.VAR:\n            if (first !\u003d null) {\n                add(\"var \");\n                addList(first, false, getContextForNoInOperator(context));\n            }\n            break;\n        case Token.LABEL_NAME:\n            Preconditions.checkState(!n.getString().isEmpty());\n            addIdentifier(n.getString());\n            break;\n        case Token.NAME:\n            if (first \u003d\u003d null || first.isEmpty()) {\n                addIdentifier(n.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                addIdentifier(n.getString());\n                cc.addOp(\"\u003d\", true);\n                if (first.isComma()) {\n                    addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n                } else {\n                    addExpr(first, 0, getContextForNoInOperator(context));\n                }\n            }\n            break;\n        case Token.ARRAYLIT:\n            add(\"[\");\n            addArrayList(first);\n            add(\"]\");\n            break;\n        case Token.PARAM_LIST:\n            add(\"(\");\n            addList(first);\n            add(\")\");\n            break;\n        case Token.COMMA:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            unrollBinaryOperator(n, Token.COMMA, \",\", context, Context.OTHER, 0, 0);\n            break;\n        case Token.NUMBER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            cc.addNumber(n.getDouble());\n            break;\n        case Token.TYPEOF:\n        case Token.VOID:\n        case Token.NOT:\n        case Token.BITNOT:\n        case Token.POS:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n                break;\n            }\n        case Token.NEG:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                if (n.getFirstChild().isNumber()) {\n                    cc.addNumber(-n.getFirstChild().getDouble());\n                } else {\n                    cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                    addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n                }\n                break;\n            }\n        case Token.HOOK:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                int p \u003d NodeUtil.precedence(type);\n                addExpr(first, p + 1, context);\n                cc.addOp(\"?\", true);\n                addExpr(first.getNext(), 1, Context.OTHER);\n                cc.addOp(\":\", true);\n                addExpr(last, 1, Context.OTHER);\n                break;\n            }\n        case Token.REGEXP:\n            if (!first.isString() || !last.isString()) {\n                throw new Error(\"Expected children to be strings\");\n            }\n            String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n            if (childCount \u003d\u003d 2) {\n                add(regexp + last.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                add(regexp);\n            }\n            break;\n        case Token.FUNCTION:\n            if (n.getClass() !\u003d Node.class) {\n                throw new Error(\"Unexpected Node subclass.\");\n            }\n            Preconditions.checkState(childCount \u003d\u003d 3);\n            boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n            if (funcNeedsParens) {\n                add(\"(\");\n            }\n            add(\"function\");\n            add(first);\n            add(first.getNext());\n            add(last, Context.PRESERVE_BLOCK);\n            cc.endFunction(context \u003d\u003d Context.STATEMENT);\n            if (funcNeedsParens) {\n                add(\")\");\n            }\n            break;\n        case Token.GETTER_DEF:\n        case Token.SETTER_DEF:\n            Preconditions.checkState(n.getParent().isObjectLit());\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            Preconditions.checkState(first.isFunction());\n            Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n            if (type \u003d\u003d Token.GETTER_DEF) {\n                Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n                add(\"get \");\n            } else {\n                Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n                add(\"set \");\n            }\n            String name \u003d n.getString();\n            Node fn \u003d first;\n            Node parameters \u003d fn.getChildAtIndex(1);\n            Node body \u003d fn.getLastChild();\n            if (!n.isQuotedString() \u0026\u0026 TokenStream.isJSIdentifier(name) \u0026\u0026 NodeUtil.isLatin(name)) {\n                add(name);\n            } else {\n                double d \u003d getSimpleNumber(name);\n                if (!Double.isNaN(d)) {\n                    cc.addNumber(d);\n                } else {\n                    addJsString(n);\n                }\n            }\n            add(parameters);\n            add(body, Context.PRESERVE_BLOCK);\n            break;\n        case Token.SCRIPT:\n        case Token.BLOCK:\n            {\n                if (n.getClass() !\u003d Node.class) {\n                    throw new Error(\"Unexpected Node subclass.\");\n                }\n                boolean preserveBlock \u003d context \u003d\u003d Context.PRESERVE_BLOCK;\n                if (preserveBlock) {\n                    cc.beginBlock();\n                }\n                boolean preferLineBreaks \u003d type \u003d\u003d Token.SCRIPT || (type \u003d\u003d Token.BLOCK \u0026\u0026 !preserveBlock \u0026\u0026 n.getParent() !\u003d null \u0026\u0026 n.getParent().isScript());\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    add(c, Context.STATEMENT);\n                    if (c.isVar()) {\n                        cc.endStatement();\n                    }\n                    if (c.isFunction()) {\n                        cc.maybeLineBreak();\n                    }\n                    if (preferLineBreaks) {\n                        cc.notePreferredLineBreak();\n                    }\n                }\n                if (preserveBlock) {\n                    cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                }\n                break;\n            }\n        case Token.FOR:\n            if (childCount \u003d\u003d 4) {\n                add(\"for(\");\n                if (first.isVar()) {\n                    add(first, Context.IN_FOR_INIT_CLAUSE);\n                } else {\n                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                }\n                add(\";\");\n                add(first.getNext());\n                add(\";\");\n                add(first.getNext().getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                add(\"for(\");\n                add(first);\n                add(\"in\");\n                add(first.getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            }\n            break;\n        case Token.DO:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"do\");\n            addNonEmptyStatement(first, Context.OTHER, false);\n            add(\"while(\");\n            add(last);\n            add(\")\");\n            cc.endStatement();\n            break;\n        case Token.WHILE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"while(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.EMPTY:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            break;\n        case Token.GETPROP:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                Preconditions.checkState(last.isString(), \"Bad GETPROP: RHS should be STRING\");\n                boolean needsParens \u003d (first.isNumber());\n                if (needsParens) {\n                    add(\"(\");\n                }\n                addExpr(first, NodeUtil.precedence(type), context);\n                if (needsParens) {\n                    add(\")\");\n                }\n                add(\".\");\n                addIdentifier(last.getString());\n                break;\n            }\n        case Token.GETELEM:\n            Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n            addExpr(first, NodeUtil.precedence(type), context);\n            add(\"[\");\n            add(first.getNext());\n            add(\"]\");\n            break;\n        case Token.WITH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"with(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.INC:\n        case Token.DEC:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                if (postProp !\u003d 0) {\n                    addExpr(first, NodeUtil.precedence(type), context);\n                    cc.addOp(o, false);\n                } else {\n                    cc.addOp(o, false);\n                    add(first);\n                }\n                break;\n            }\n        case Token.CALL:\n            if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) \u0026\u0026 NodeUtil.isGet(first)) {\n                add(\"(0,\");\n                addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n                add(\")\");\n            } else {\n                addExpr(first, NodeUtil.precedence(type), context);\n            }\n            add(\"(\");\n            addList(first.getNext());\n            add(\")\");\n            break;\n        case Token.IF:\n            boolean hasElse \u003d childCount \u003d\u003d 3;\n            boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n            if (ambiguousElseClause) {\n                cc.beginBlock();\n            }\n            add(\"if(\");\n            add(first);\n            add(\")\");\n            if (hasElse) {\n                addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                add(\"else\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n                Preconditions.checkState(childCount \u003d\u003d 2);\n            }\n            if (ambiguousElseClause) {\n                cc.endBlock();\n            }\n            break;\n        case Token.NULL:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"null\");\n            break;\n        case Token.THIS:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"this\");\n            break;\n        case Token.FALSE:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"false\");\n            break;\n        case Token.TRUE:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"true\");\n            break;\n        case Token.CONTINUE:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"continue\");\n            if (childCount \u003d\u003d 1) {\n                if (!first.isLabelName()) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.DEBUGGER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"debugger\");\n            cc.endStatement();\n            break;\n        case Token.BREAK:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"break\");\n            if (childCount \u003d\u003d 1) {\n                if (!first.isLabelName()) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.EXPR_RESULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first, Context.START_OF_EXPR);\n            cc.endStatement();\n            break;\n        case Token.NEW:\n            add(\"new \");\n            int precedence \u003d NodeUtil.precedence(type);\n            if (NodeUtil.containsType(first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n                precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n            }\n            addExpr(first, precedence, Context.OTHER);\n            Node next \u003d first.getNext();\n            if (next !\u003d null) {\n                add(\"(\");\n                addList(next);\n                add(\")\");\n            }\n            break;\n        case Token.STRING:\n            if (childCount !\u003d ((n.getParent() !\u003d null \u0026\u0026 n.getParent().isObjectLit()) ? 1 : 0)) {\n                throw new IllegalStateException(\"Unexpected String children: \" + n.getParent().toStringTree());\n            }\n            addJsString(n);\n            break;\n        case Token.DELPROP:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"delete \");\n            add(first);\n            break;\n        case Token.OBJECTLIT:\n            {\n                boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                add(\"{\");\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    if (c !\u003d first) {\n                        cc.listSeparator();\n                    }\n                    if (c.isGetterDef() || c.isSetterDef()) {\n                        add(c);\n                    } else {\n                        Preconditions.checkState(c.isString());\n                        String key \u003d c.getString();\n                        if (!c.isQuotedString() \u0026\u0026 !TokenStream.isKeyword(key) \u0026\u0026 TokenStream.isJSIdentifier(key) \u0026\u0026 NodeUtil.isLatin(key)) {\n                            add(key);\n                        } else {\n                            double d \u003d getSimpleNumber(key);\n                            if (!Double.isNaN(d)) {\n                                cc.addNumber(d);\n                            } else {\n                                addExpr(c, 1, Context.OTHER);\n                            }\n                        }\n                        add(\":\");\n                        addExpr(c.getFirstChild(), 1, Context.OTHER);\n                    }\n                }\n                add(\"}\");\n                if (needsParens) {\n                    add(\")\");\n                }\n                break;\n            }\n        case Token.SWITCH:\n            add(\"switch(\");\n            add(first);\n            add(\")\");\n            cc.beginBlock();\n            addAllSiblings(first.getNext());\n            cc.endBlock(context \u003d\u003d Context.STATEMENT);\n            break;\n        case Token.CASE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"case \");\n            add(first);\n            addCaseBody(last);\n            break;\n        case Token.DEFAULT_CASE:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"default\");\n            addCaseBody(first);\n            break;\n        case Token.LABEL:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            if (!first.isLabelName()) {\n                throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n            }\n            add(first);\n            add(\":\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\n            break;\n        default:\n            throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n    cc.endSourceMapping(n);\n}",
      "path": "src/com/google/javascript/jscomp/CodeGenerator.java",
      "functionStartLine": 85,
      "functionName": "add",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,502 +1,494 @@\n void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n         return;\n     }\n     int type \u003d n.getType();\n     String opstr \u003d NodeUtil.opToStr(type);\n     int childCount \u003d n.getChildCount();\n     Node first \u003d n.getFirstChild();\n     Node last \u003d n.getLastChild();\n     if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n         Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n         int p \u003d NodeUtil.precedence(type);\n-        addExpr(first, p, context);\n-        cc.addOp(opstr, true);\n         Context rhsContext \u003d getContextForNoInOperator(context);\n         if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n+            addExpr(first, p, context);\n+            cc.addOp(opstr, true);\n             addExpr(last, p, rhsContext);\n         } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n+            addExpr(first, p, context);\n+            cc.addOp(opstr, true);\n             addExpr(last, p, rhsContext);\n         } else {\n-            addExpr(last, p + 1, rhsContext);\n+            unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n         }\n         return;\n     }\n     cc.startSourceMapping(n);\n     switch(type) {\n         case Token.TRY:\n             {\n                 Preconditions.checkState(first.getNext().isBlock() \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n                 Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                 add(\"try\");\n                 add(first, Context.PRESERVE_BLOCK);\n                 Node catchblock \u003d first.getNext().getFirstChild();\n                 if (catchblock !\u003d null) {\n                     add(catchblock);\n                 }\n                 if (childCount \u003d\u003d 3) {\n                     add(\"finally\");\n                     add(last, Context.PRESERVE_BLOCK);\n                 }\n                 break;\n             }\n         case Token.CATCH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"catch(\");\n             add(first);\n             add(\")\");\n             add(last, Context.PRESERVE_BLOCK);\n             break;\n         case Token.THROW:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"throw\");\n             add(first);\n             cc.endStatement(true);\n             break;\n         case Token.RETURN:\n             add(\"return\");\n             if (childCount \u003d\u003d 1) {\n                 add(first);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 0);\n             }\n             cc.endStatement();\n             break;\n         case Token.VAR:\n             if (first !\u003d null) {\n                 add(\"var \");\n                 addList(first, false, getContextForNoInOperator(context));\n             }\n             break;\n         case Token.LABEL_NAME:\n             Preconditions.checkState(!n.getString().isEmpty());\n             addIdentifier(n.getString());\n             break;\n         case Token.NAME:\n             if (first \u003d\u003d null || first.isEmpty()) {\n                 addIdentifier(n.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 addIdentifier(n.getString());\n                 cc.addOp(\"\u003d\", true);\n                 if (first.isComma()) {\n                     addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n                 } else {\n                     addExpr(first, 0, getContextForNoInOperator(context));\n                 }\n             }\n             break;\n         case Token.ARRAYLIT:\n             add(\"[\");\n             addArrayList(first);\n             add(\"]\");\n             break;\n         case Token.PARAM_LIST:\n             add(\"(\");\n             addList(first);\n             add(\")\");\n             break;\n         case Token.COMMA:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n-            Node firstNonComma \u003d n.getFirstChild();\n-            while (firstNonComma.getType() \u003d\u003d Token.COMMA) {\n-                firstNonComma \u003d firstNonComma.getFirstChild();\n-            }\n-            addExpr(firstNonComma, 0, context);\n-            Node current \u003d firstNonComma;\n-            do {\n-                current \u003d current.getParent();\n-                cc.listSeparator();\n-                addExpr(current.getFirstChild().getNext(), 0, Context.OTHER);\n-            } while (current !\u003d n);\n+            unrollBinaryOperator(n, Token.COMMA, \",\", context, Context.OTHER, 0, 0);\n             break;\n         case Token.NUMBER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             cc.addNumber(n.getDouble());\n             break;\n         case Token.TYPEOF:\n         case Token.VOID:\n         case Token.NOT:\n         case Token.BITNOT:\n         case Token.POS:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                 addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n                 break;\n             }\n         case Token.NEG:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 if (n.getFirstChild().isNumber()) {\n                     cc.addNumber(-n.getFirstChild().getDouble());\n                 } else {\n                     cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                     addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n                 }\n                 break;\n             }\n         case Token.HOOK:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 int p \u003d NodeUtil.precedence(type);\n                 addExpr(first, p + 1, context);\n                 cc.addOp(\"?\", true);\n                 addExpr(first.getNext(), 1, Context.OTHER);\n                 cc.addOp(\":\", true);\n                 addExpr(last, 1, Context.OTHER);\n                 break;\n             }\n         case Token.REGEXP:\n             if (!first.isString() || !last.isString()) {\n                 throw new Error(\"Expected children to be strings\");\n             }\n             String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n             if (childCount \u003d\u003d 2) {\n                 add(regexp + last.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 add(regexp);\n             }\n             break;\n         case Token.FUNCTION:\n             if (n.getClass() !\u003d Node.class) {\n                 throw new Error(\"Unexpected Node subclass.\");\n             }\n             Preconditions.checkState(childCount \u003d\u003d 3);\n             boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n             if (funcNeedsParens) {\n                 add(\"(\");\n             }\n             add(\"function\");\n             add(first);\n             add(first.getNext());\n             add(last, Context.PRESERVE_BLOCK);\n             cc.endFunction(context \u003d\u003d Context.STATEMENT);\n             if (funcNeedsParens) {\n                 add(\")\");\n             }\n             break;\n         case Token.GETTER_DEF:\n         case Token.SETTER_DEF:\n             Preconditions.checkState(n.getParent().isObjectLit());\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             Preconditions.checkState(first.isFunction());\n             Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n             if (type \u003d\u003d Token.GETTER_DEF) {\n                 Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n                 add(\"get \");\n             } else {\n                 Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n                 add(\"set \");\n             }\n             String name \u003d n.getString();\n             Node fn \u003d first;\n             Node parameters \u003d fn.getChildAtIndex(1);\n             Node body \u003d fn.getLastChild();\n             if (!n.isQuotedString() \u0026\u0026 TokenStream.isJSIdentifier(name) \u0026\u0026 NodeUtil.isLatin(name)) {\n                 add(name);\n             } else {\n                 double d \u003d getSimpleNumber(name);\n                 if (!Double.isNaN(d)) {\n                     cc.addNumber(d);\n                 } else {\n                     addJsString(n);\n                 }\n             }\n             add(parameters);\n             add(body, Context.PRESERVE_BLOCK);\n             break;\n         case Token.SCRIPT:\n         case Token.BLOCK:\n             {\n                 if (n.getClass() !\u003d Node.class) {\n                     throw new Error(\"Unexpected Node subclass.\");\n                 }\n                 boolean preserveBlock \u003d context \u003d\u003d Context.PRESERVE_BLOCK;\n                 if (preserveBlock) {\n                     cc.beginBlock();\n                 }\n                 boolean preferLineBreaks \u003d type \u003d\u003d Token.SCRIPT || (type \u003d\u003d Token.BLOCK \u0026\u0026 !preserveBlock \u0026\u0026 n.getParent() !\u003d null \u0026\u0026 n.getParent().isScript());\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     add(c, Context.STATEMENT);\n                     if (c.isVar()) {\n                         cc.endStatement();\n                     }\n                     if (c.isFunction()) {\n                         cc.maybeLineBreak();\n                     }\n                     if (preferLineBreaks) {\n                         cc.notePreferredLineBreak();\n                     }\n                 }\n                 if (preserveBlock) {\n                     cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                 }\n                 break;\n             }\n         case Token.FOR:\n             if (childCount \u003d\u003d 4) {\n                 add(\"for(\");\n                 if (first.isVar()) {\n                     add(first, Context.IN_FOR_INIT_CLAUSE);\n                 } else {\n                     addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                 }\n                 add(\";\");\n                 add(first.getNext());\n                 add(\";\");\n                 add(first.getNext().getNext());\n                 add(\")\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 add(\"for(\");\n                 add(first);\n                 add(\"in\");\n                 add(first.getNext());\n                 add(\")\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             }\n             break;\n         case Token.DO:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"do\");\n             addNonEmptyStatement(first, Context.OTHER, false);\n             add(\"while(\");\n             add(last);\n             add(\")\");\n             cc.endStatement();\n             break;\n         case Token.WHILE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"while(\");\n             add(first);\n             add(\")\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.EMPTY:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             break;\n         case Token.GETPROP:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                 Preconditions.checkState(last.isString(), \"Bad GETPROP: RHS should be STRING\");\n                 boolean needsParens \u003d (first.isNumber());\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 addExpr(first, NodeUtil.precedence(type), context);\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 add(\".\");\n                 addIdentifier(last.getString());\n                 break;\n             }\n         case Token.GETELEM:\n             Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n             addExpr(first, NodeUtil.precedence(type), context);\n             add(\"[\");\n             add(first.getNext());\n             add(\"]\");\n             break;\n         case Token.WITH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"with(\");\n             add(first);\n             add(\")\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.INC:\n         case Token.DEC:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                 int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                 if (postProp !\u003d 0) {\n                     addExpr(first, NodeUtil.precedence(type), context);\n                     cc.addOp(o, false);\n                 } else {\n                     cc.addOp(o, false);\n                     add(first);\n                 }\n                 break;\n             }\n         case Token.CALL:\n             if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) \u0026\u0026 NodeUtil.isGet(first)) {\n                 add(\"(0,\");\n                 addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n                 add(\")\");\n             } else {\n                 addExpr(first, NodeUtil.precedence(type), context);\n             }\n             add(\"(\");\n             addList(first.getNext());\n             add(\")\");\n             break;\n         case Token.IF:\n             boolean hasElse \u003d childCount \u003d\u003d 3;\n             boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n             if (ambiguousElseClause) {\n                 cc.beginBlock();\n             }\n             add(\"if(\");\n             add(first);\n             add(\")\");\n             if (hasElse) {\n                 addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                 add(\"else\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n                 Preconditions.checkState(childCount \u003d\u003d 2);\n             }\n             if (ambiguousElseClause) {\n                 cc.endBlock();\n             }\n             break;\n         case Token.NULL:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(\"null\");\n             break;\n         case Token.THIS:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(\"this\");\n             break;\n         case Token.FALSE:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(\"false\");\n             break;\n         case Token.TRUE:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(\"true\");\n             break;\n         case Token.CONTINUE:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"continue\");\n             if (childCount \u003d\u003d 1) {\n                 if (!first.isLabelName()) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.DEBUGGER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(\"debugger\");\n             cc.endStatement();\n             break;\n         case Token.BREAK:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"break\");\n             if (childCount \u003d\u003d 1) {\n                 if (!first.isLabelName()) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.EXPR_RESULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first, Context.START_OF_EXPR);\n             cc.endStatement();\n             break;\n         case Token.NEW:\n             add(\"new \");\n             int precedence \u003d NodeUtil.precedence(type);\n             if (NodeUtil.containsType(first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n                 precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n             }\n             addExpr(first, precedence, Context.OTHER);\n             Node next \u003d first.getNext();\n             if (next !\u003d null) {\n                 add(\"(\");\n                 addList(next);\n                 add(\")\");\n             }\n             break;\n         case Token.STRING:\n             if (childCount !\u003d ((n.getParent() !\u003d null \u0026\u0026 n.getParent().isObjectLit()) ? 1 : 0)) {\n                 throw new IllegalStateException(\"Unexpected String children: \" + n.getParent().toStringTree());\n             }\n             addJsString(n);\n             break;\n         case Token.DELPROP:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"delete \");\n             add(first);\n             break;\n         case Token.OBJECTLIT:\n             {\n                 boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 add(\"{\");\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     if (c !\u003d first) {\n                         cc.listSeparator();\n                     }\n                     if (c.isGetterDef() || c.isSetterDef()) {\n                         add(c);\n                     } else {\n                         Preconditions.checkState(c.isString());\n                         String key \u003d c.getString();\n                         if (!c.isQuotedString() \u0026\u0026 !TokenStream.isKeyword(key) \u0026\u0026 TokenStream.isJSIdentifier(key) \u0026\u0026 NodeUtil.isLatin(key)) {\n                             add(key);\n                         } else {\n                             double d \u003d getSimpleNumber(key);\n                             if (!Double.isNaN(d)) {\n                                 cc.addNumber(d);\n                             } else {\n                                 addExpr(c, 1, Context.OTHER);\n                             }\n                         }\n                         add(\":\");\n                         addExpr(c.getFirstChild(), 1, Context.OTHER);\n                     }\n                 }\n                 add(\"}\");\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 break;\n             }\n         case Token.SWITCH:\n             add(\"switch(\");\n             add(first);\n             add(\")\");\n             cc.beginBlock();\n             addAllSiblings(first.getNext());\n             cc.endBlock(context \u003d\u003d Context.STATEMENT);\n             break;\n         case Token.CASE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"case \");\n             add(first);\n             addCaseBody(last);\n             break;\n         case Token.DEFAULT_CASE:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"default\");\n             addCaseBody(first);\n             break;\n         case Token.LABEL:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             if (!first.isLabelName()) {\n                 throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n             }\n             add(first);\n             add(\":\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\n             break;\n         default:\n             throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n     }\n     cc.endSourceMapping(n);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "746e26420bb2dde1339a72f15199373ab0182d33": {
      "type": "Ybodychange",
      "commitMessage": "\nInline some methods to save stack space, particularly\nfor expressions with loads of COMMAs\n\nR\u003dacleung\nDELTA\u003d77  (41 added, 17 deleted, 19 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d4194\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1772 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "2/8/12, 4:28 PM",
      "commitName": "746e26420bb2dde1339a72f15199373ab0182d33",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "11/21/11, 12:02 PM",
      "commitNameOld": "e85593d14461f5342013d0d6c6e8484dca003eef",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 79.18,
      "commitsBetweenForRepo": 124,
      "commitsBetweenForFile": 1,
      "actualSource": "void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n        return;\n    }\n    int type \u003d n.getType();\n    String opstr \u003d NodeUtil.opToStr(type);\n    int childCount \u003d n.getChildCount();\n    Node first \u003d n.getFirstChild();\n    Node last \u003d n.getLastChild();\n    if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n        Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n        int p \u003d NodeUtil.precedence(type);\n        addExpr(first, p, context);\n        cc.addOp(opstr, true);\n        Context rhsContext \u003d getContextForNoInOperator(context);\n        if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n            addExpr(last, p, rhsContext);\n        } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n            addExpr(last, p, rhsContext);\n        } else {\n            addExpr(last, p + 1, rhsContext);\n        }\n        return;\n    }\n    cc.startSourceMapping(n);\n    switch(type) {\n        case Token.TRY:\n            {\n                Preconditions.checkState(first.getNext().isBlock() \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n                Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                add(\"try\");\n                add(first, Context.PRESERVE_BLOCK);\n                Node catchblock \u003d first.getNext().getFirstChild();\n                if (catchblock !\u003d null) {\n                    add(catchblock);\n                }\n                if (childCount \u003d\u003d 3) {\n                    add(\"finally\");\n                    add(last, Context.PRESERVE_BLOCK);\n                }\n                break;\n            }\n        case Token.CATCH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"catch(\");\n            add(first);\n            add(\")\");\n            add(last, Context.PRESERVE_BLOCK);\n            break;\n        case Token.THROW:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"throw\");\n            add(first);\n            cc.endStatement(true);\n            break;\n        case Token.RETURN:\n            add(\"return\");\n            if (childCount \u003d\u003d 1) {\n                add(first);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 0);\n            }\n            cc.endStatement();\n            break;\n        case Token.VAR:\n            if (first !\u003d null) {\n                add(\"var \");\n                addList(first, false, getContextForNoInOperator(context));\n            }\n            break;\n        case Token.LABEL_NAME:\n            Preconditions.checkState(!n.getString().isEmpty());\n            addIdentifier(n.getString());\n            break;\n        case Token.NAME:\n            if (first \u003d\u003d null || first.isEmpty()) {\n                addIdentifier(n.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                addIdentifier(n.getString());\n                cc.addOp(\"\u003d\", true);\n                if (first.isComma()) {\n                    addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n                } else {\n                    addExpr(first, 0, getContextForNoInOperator(context));\n                }\n            }\n            break;\n        case Token.ARRAYLIT:\n            add(\"[\");\n            addArrayList(first);\n            add(\"]\");\n            break;\n        case Token.PARAM_LIST:\n            add(\"(\");\n            addList(first);\n            add(\")\");\n            break;\n        case Token.COMMA:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            Node firstNonComma \u003d n.getFirstChild();\n            while (firstNonComma.getType() \u003d\u003d Token.COMMA) {\n                firstNonComma \u003d firstNonComma.getFirstChild();\n            }\n            addExpr(firstNonComma, 0, context);\n            Node current \u003d firstNonComma;\n            do {\n                current \u003d current.getParent();\n                cc.listSeparator();\n                addExpr(current.getFirstChild().getNext(), 0, Context.OTHER);\n            } while (current !\u003d n);\n            break;\n        case Token.NUMBER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            cc.addNumber(n.getDouble());\n            break;\n        case Token.TYPEOF:\n        case Token.VOID:\n        case Token.NOT:\n        case Token.BITNOT:\n        case Token.POS:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n                break;\n            }\n        case Token.NEG:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                if (n.getFirstChild().isNumber()) {\n                    cc.addNumber(-n.getFirstChild().getDouble());\n                } else {\n                    cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                    addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n                }\n                break;\n            }\n        case Token.HOOK:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                int p \u003d NodeUtil.precedence(type);\n                addExpr(first, p + 1, context);\n                cc.addOp(\"?\", true);\n                addExpr(first.getNext(), 1, Context.OTHER);\n                cc.addOp(\":\", true);\n                addExpr(last, 1, Context.OTHER);\n                break;\n            }\n        case Token.REGEXP:\n            if (!first.isString() || !last.isString()) {\n                throw new Error(\"Expected children to be strings\");\n            }\n            String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n            if (childCount \u003d\u003d 2) {\n                add(regexp + last.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                add(regexp);\n            }\n            break;\n        case Token.FUNCTION:\n            if (n.getClass() !\u003d Node.class) {\n                throw new Error(\"Unexpected Node subclass.\");\n            }\n            Preconditions.checkState(childCount \u003d\u003d 3);\n            boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n            if (funcNeedsParens) {\n                add(\"(\");\n            }\n            add(\"function\");\n            add(first);\n            add(first.getNext());\n            add(last, Context.PRESERVE_BLOCK);\n            cc.endFunction(context \u003d\u003d Context.STATEMENT);\n            if (funcNeedsParens) {\n                add(\")\");\n            }\n            break;\n        case Token.GETTER_DEF:\n        case Token.SETTER_DEF:\n            Preconditions.checkState(n.getParent().isObjectLit());\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            Preconditions.checkState(first.isFunction());\n            Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n            if (type \u003d\u003d Token.GETTER_DEF) {\n                Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n                add(\"get \");\n            } else {\n                Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n                add(\"set \");\n            }\n            String name \u003d n.getString();\n            Node fn \u003d first;\n            Node parameters \u003d fn.getChildAtIndex(1);\n            Node body \u003d fn.getLastChild();\n            if (!n.isQuotedString() \u0026\u0026 TokenStream.isJSIdentifier(name) \u0026\u0026 NodeUtil.isLatin(name)) {\n                add(name);\n            } else {\n                double d \u003d getSimpleNumber(name);\n                if (!Double.isNaN(d)) {\n                    cc.addNumber(d);\n                } else {\n                    addJsString(n);\n                }\n            }\n            add(parameters);\n            add(body, Context.PRESERVE_BLOCK);\n            break;\n        case Token.SCRIPT:\n        case Token.BLOCK:\n            {\n                if (n.getClass() !\u003d Node.class) {\n                    throw new Error(\"Unexpected Node subclass.\");\n                }\n                boolean preserveBlock \u003d context \u003d\u003d Context.PRESERVE_BLOCK;\n                if (preserveBlock) {\n                    cc.beginBlock();\n                }\n                boolean preferLineBreaks \u003d type \u003d\u003d Token.SCRIPT || (type \u003d\u003d Token.BLOCK \u0026\u0026 !preserveBlock \u0026\u0026 n.getParent() !\u003d null \u0026\u0026 n.getParent().isScript());\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    add(c, Context.STATEMENT);\n                    if (c.isVar()) {\n                        cc.endStatement();\n                    }\n                    if (c.isFunction()) {\n                        cc.maybeLineBreak();\n                    }\n                    if (preferLineBreaks) {\n                        cc.notePreferredLineBreak();\n                    }\n                }\n                if (preserveBlock) {\n                    cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                }\n                break;\n            }\n        case Token.FOR:\n            if (childCount \u003d\u003d 4) {\n                add(\"for(\");\n                if (first.isVar()) {\n                    add(first, Context.IN_FOR_INIT_CLAUSE);\n                } else {\n                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                }\n                add(\";\");\n                add(first.getNext());\n                add(\";\");\n                add(first.getNext().getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                add(\"for(\");\n                add(first);\n                add(\"in\");\n                add(first.getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            }\n            break;\n        case Token.DO:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"do\");\n            addNonEmptyStatement(first, Context.OTHER, false);\n            add(\"while(\");\n            add(last);\n            add(\")\");\n            cc.endStatement();\n            break;\n        case Token.WHILE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"while(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.EMPTY:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            break;\n        case Token.GETPROP:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                Preconditions.checkState(last.isString(), \"Bad GETPROP: RHS should be STRING\");\n                boolean needsParens \u003d (first.isNumber());\n                if (needsParens) {\n                    add(\"(\");\n                }\n                addExpr(first, NodeUtil.precedence(type), context);\n                if (needsParens) {\n                    add(\")\");\n                }\n                add(\".\");\n                addIdentifier(last.getString());\n                break;\n            }\n        case Token.GETELEM:\n            Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n            addExpr(first, NodeUtil.precedence(type), context);\n            add(\"[\");\n            add(first.getNext());\n            add(\"]\");\n            break;\n        case Token.WITH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"with(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.INC:\n        case Token.DEC:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                if (postProp !\u003d 0) {\n                    addExpr(first, NodeUtil.precedence(type), context);\n                    cc.addOp(o, false);\n                } else {\n                    cc.addOp(o, false);\n                    add(first);\n                }\n                break;\n            }\n        case Token.CALL:\n            if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) \u0026\u0026 NodeUtil.isGet(first)) {\n                add(\"(0,\");\n                addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n                add(\")\");\n            } else {\n                addExpr(first, NodeUtil.precedence(type), context);\n            }\n            add(\"(\");\n            addList(first.getNext());\n            add(\")\");\n            break;\n        case Token.IF:\n            boolean hasElse \u003d childCount \u003d\u003d 3;\n            boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n            if (ambiguousElseClause) {\n                cc.beginBlock();\n            }\n            add(\"if(\");\n            add(first);\n            add(\")\");\n            if (hasElse) {\n                addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                add(\"else\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n                Preconditions.checkState(childCount \u003d\u003d 2);\n            }\n            if (ambiguousElseClause) {\n                cc.endBlock();\n            }\n            break;\n        case Token.NULL:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"null\");\n            break;\n        case Token.THIS:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"this\");\n            break;\n        case Token.FALSE:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"false\");\n            break;\n        case Token.TRUE:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"true\");\n            break;\n        case Token.CONTINUE:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"continue\");\n            if (childCount \u003d\u003d 1) {\n                if (!first.isLabelName()) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.DEBUGGER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"debugger\");\n            cc.endStatement();\n            break;\n        case Token.BREAK:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"break\");\n            if (childCount \u003d\u003d 1) {\n                if (!first.isLabelName()) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.EXPR_RESULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first, Context.START_OF_EXPR);\n            cc.endStatement();\n            break;\n        case Token.NEW:\n            add(\"new \");\n            int precedence \u003d NodeUtil.precedence(type);\n            if (NodeUtil.containsType(first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n                precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n            }\n            addExpr(first, precedence, Context.OTHER);\n            Node next \u003d first.getNext();\n            if (next !\u003d null) {\n                add(\"(\");\n                addList(next);\n                add(\")\");\n            }\n            break;\n        case Token.STRING:\n            if (childCount !\u003d ((n.getParent() !\u003d null \u0026\u0026 n.getParent().isObjectLit()) ? 1 : 0)) {\n                throw new IllegalStateException(\"Unexpected String children: \" + n.getParent().toStringTree());\n            }\n            addJsString(n);\n            break;\n        case Token.DELPROP:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"delete \");\n            add(first);\n            break;\n        case Token.OBJECTLIT:\n            {\n                boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                add(\"{\");\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    if (c !\u003d first) {\n                        cc.listSeparator();\n                    }\n                    if (c.isGetterDef() || c.isSetterDef()) {\n                        add(c);\n                    } else {\n                        Preconditions.checkState(c.isString());\n                        String key \u003d c.getString();\n                        if (!c.isQuotedString() \u0026\u0026 !TokenStream.isKeyword(key) \u0026\u0026 TokenStream.isJSIdentifier(key) \u0026\u0026 NodeUtil.isLatin(key)) {\n                            add(key);\n                        } else {\n                            double d \u003d getSimpleNumber(key);\n                            if (!Double.isNaN(d)) {\n                                cc.addNumber(d);\n                            } else {\n                                addExpr(c, 1, Context.OTHER);\n                            }\n                        }\n                        add(\":\");\n                        addExpr(c.getFirstChild(), 1, Context.OTHER);\n                    }\n                }\n                add(\"}\");\n                if (needsParens) {\n                    add(\")\");\n                }\n                break;\n            }\n        case Token.SWITCH:\n            add(\"switch(\");\n            add(first);\n            add(\")\");\n            cc.beginBlock();\n            addAllSiblings(first.getNext());\n            cc.endBlock(context \u003d\u003d Context.STATEMENT);\n            break;\n        case Token.CASE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"case \");\n            add(first);\n            addCaseBody(last);\n            break;\n        case Token.DEFAULT_CASE:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"default\");\n            addCaseBody(first);\n            break;\n        case Token.LABEL:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            if (!first.isLabelName()) {\n                throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n            }\n            add(first);\n            add(\":\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\n            break;\n        default:\n            throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n    cc.endSourceMapping(n);\n}",
      "path": "src/com/google/javascript/jscomp/CodeGenerator.java",
      "functionStartLine": 85,
      "functionName": "add",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,492 +1,502 @@\n void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n         return;\n     }\n     int type \u003d n.getType();\n     String opstr \u003d NodeUtil.opToStr(type);\n     int childCount \u003d n.getChildCount();\n     Node first \u003d n.getFirstChild();\n     Node last \u003d n.getLastChild();\n     if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n         Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n         int p \u003d NodeUtil.precedence(type);\n-        addLeftExpr(first, p, context);\n+        addExpr(first, p, context);\n         cc.addOp(opstr, true);\n         Context rhsContext \u003d getContextForNoInOperator(context);\n         if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n             addExpr(last, p, rhsContext);\n         } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n             addExpr(last, p, rhsContext);\n         } else {\n             addExpr(last, p + 1, rhsContext);\n         }\n         return;\n     }\n     cc.startSourceMapping(n);\n     switch(type) {\n         case Token.TRY:\n             {\n                 Preconditions.checkState(first.getNext().isBlock() \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n                 Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                 add(\"try\");\n                 add(first, Context.PRESERVE_BLOCK);\n                 Node catchblock \u003d first.getNext().getFirstChild();\n                 if (catchblock !\u003d null) {\n                     add(catchblock);\n                 }\n                 if (childCount \u003d\u003d 3) {\n                     add(\"finally\");\n                     add(last, Context.PRESERVE_BLOCK);\n                 }\n                 break;\n             }\n         case Token.CATCH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"catch(\");\n             add(first);\n             add(\")\");\n             add(last, Context.PRESERVE_BLOCK);\n             break;\n         case Token.THROW:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"throw\");\n             add(first);\n             cc.endStatement(true);\n             break;\n         case Token.RETURN:\n             add(\"return\");\n             if (childCount \u003d\u003d 1) {\n                 add(first);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 0);\n             }\n             cc.endStatement();\n             break;\n         case Token.VAR:\n             if (first !\u003d null) {\n                 add(\"var \");\n                 addList(first, false, getContextForNoInOperator(context));\n             }\n             break;\n         case Token.LABEL_NAME:\n             Preconditions.checkState(!n.getString().isEmpty());\n             addIdentifier(n.getString());\n             break;\n         case Token.NAME:\n             if (first \u003d\u003d null || first.isEmpty()) {\n                 addIdentifier(n.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 addIdentifier(n.getString());\n                 cc.addOp(\"\u003d\", true);\n                 if (first.isComma()) {\n-                    addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n+                    addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n                 } else {\n                     addExpr(first, 0, getContextForNoInOperator(context));\n                 }\n             }\n             break;\n         case Token.ARRAYLIT:\n             add(\"[\");\n             addArrayList(first);\n             add(\"]\");\n             break;\n         case Token.PARAM_LIST:\n             add(\"(\");\n             addList(first);\n             add(\")\");\n             break;\n         case Token.COMMA:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n-            addList(first, false, context);\n+            Node firstNonComma \u003d n.getFirstChild();\n+            while (firstNonComma.getType() \u003d\u003d Token.COMMA) {\n+                firstNonComma \u003d firstNonComma.getFirstChild();\n+            }\n+            addExpr(firstNonComma, 0, context);\n+            Node current \u003d firstNonComma;\n+            do {\n+                current \u003d current.getParent();\n+                cc.listSeparator();\n+                addExpr(current.getFirstChild().getNext(), 0, Context.OTHER);\n+            } while (current !\u003d n);\n             break;\n         case Token.NUMBER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             cc.addNumber(n.getDouble());\n             break;\n         case Token.TYPEOF:\n         case Token.VOID:\n         case Token.NOT:\n         case Token.BITNOT:\n         case Token.POS:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 cc.addOp(NodeUtil.opToStrNoFail(type), false);\n-                addExpr(first, NodeUtil.precedence(type));\n+                addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n                 break;\n             }\n         case Token.NEG:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 if (n.getFirstChild().isNumber()) {\n                     cc.addNumber(-n.getFirstChild().getDouble());\n                 } else {\n                     cc.addOp(NodeUtil.opToStrNoFail(type), false);\n-                    addExpr(first, NodeUtil.precedence(type));\n+                    addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n                 }\n                 break;\n             }\n         case Token.HOOK:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 int p \u003d NodeUtil.precedence(type);\n-                addLeftExpr(first, p + 1, context);\n+                addExpr(first, p + 1, context);\n                 cc.addOp(\"?\", true);\n-                addExpr(first.getNext(), 1);\n+                addExpr(first.getNext(), 1, Context.OTHER);\n                 cc.addOp(\":\", true);\n-                addExpr(last, 1);\n+                addExpr(last, 1, Context.OTHER);\n                 break;\n             }\n         case Token.REGEXP:\n             if (!first.isString() || !last.isString()) {\n                 throw new Error(\"Expected children to be strings\");\n             }\n             String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n             if (childCount \u003d\u003d 2) {\n                 add(regexp + last.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 add(regexp);\n             }\n             break;\n         case Token.FUNCTION:\n             if (n.getClass() !\u003d Node.class) {\n                 throw new Error(\"Unexpected Node subclass.\");\n             }\n             Preconditions.checkState(childCount \u003d\u003d 3);\n             boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n             if (funcNeedsParens) {\n                 add(\"(\");\n             }\n             add(\"function\");\n             add(first);\n             add(first.getNext());\n             add(last, Context.PRESERVE_BLOCK);\n             cc.endFunction(context \u003d\u003d Context.STATEMENT);\n             if (funcNeedsParens) {\n                 add(\")\");\n             }\n             break;\n         case Token.GETTER_DEF:\n         case Token.SETTER_DEF:\n             Preconditions.checkState(n.getParent().isObjectLit());\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             Preconditions.checkState(first.isFunction());\n             Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n             if (type \u003d\u003d Token.GETTER_DEF) {\n                 Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n                 add(\"get \");\n             } else {\n                 Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n                 add(\"set \");\n             }\n             String name \u003d n.getString();\n             Node fn \u003d first;\n             Node parameters \u003d fn.getChildAtIndex(1);\n             Node body \u003d fn.getLastChild();\n             if (!n.isQuotedString() \u0026\u0026 TokenStream.isJSIdentifier(name) \u0026\u0026 NodeUtil.isLatin(name)) {\n                 add(name);\n             } else {\n                 double d \u003d getSimpleNumber(name);\n                 if (!Double.isNaN(d)) {\n                     cc.addNumber(d);\n                 } else {\n                     addJsString(n);\n                 }\n             }\n             add(parameters);\n             add(body, Context.PRESERVE_BLOCK);\n             break;\n         case Token.SCRIPT:\n         case Token.BLOCK:\n             {\n                 if (n.getClass() !\u003d Node.class) {\n                     throw new Error(\"Unexpected Node subclass.\");\n                 }\n                 boolean preserveBlock \u003d context \u003d\u003d Context.PRESERVE_BLOCK;\n                 if (preserveBlock) {\n                     cc.beginBlock();\n                 }\n                 boolean preferLineBreaks \u003d type \u003d\u003d Token.SCRIPT || (type \u003d\u003d Token.BLOCK \u0026\u0026 !preserveBlock \u0026\u0026 n.getParent() !\u003d null \u0026\u0026 n.getParent().isScript());\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     add(c, Context.STATEMENT);\n                     if (c.isVar()) {\n                         cc.endStatement();\n                     }\n                     if (c.isFunction()) {\n                         cc.maybeLineBreak();\n                     }\n                     if (preferLineBreaks) {\n                         cc.notePreferredLineBreak();\n                     }\n                 }\n                 if (preserveBlock) {\n                     cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                 }\n                 break;\n             }\n         case Token.FOR:\n             if (childCount \u003d\u003d 4) {\n                 add(\"for(\");\n                 if (first.isVar()) {\n                     add(first, Context.IN_FOR_INIT_CLAUSE);\n                 } else {\n                     addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                 }\n                 add(\";\");\n                 add(first.getNext());\n                 add(\";\");\n                 add(first.getNext().getNext());\n                 add(\")\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 add(\"for(\");\n                 add(first);\n                 add(\"in\");\n                 add(first.getNext());\n                 add(\")\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             }\n             break;\n         case Token.DO:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"do\");\n             addNonEmptyStatement(first, Context.OTHER, false);\n             add(\"while(\");\n             add(last);\n             add(\")\");\n             cc.endStatement();\n             break;\n         case Token.WHILE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"while(\");\n             add(first);\n             add(\")\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.EMPTY:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             break;\n         case Token.GETPROP:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                 Preconditions.checkState(last.isString(), \"Bad GETPROP: RHS should be STRING\");\n                 boolean needsParens \u003d (first.isNumber());\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n-                addLeftExpr(first, NodeUtil.precedence(type), context);\n+                addExpr(first, NodeUtil.precedence(type), context);\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 add(\".\");\n                 addIdentifier(last.getString());\n                 break;\n             }\n         case Token.GETELEM:\n             Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n-            addLeftExpr(first, NodeUtil.precedence(type), context);\n+            addExpr(first, NodeUtil.precedence(type), context);\n             add(\"[\");\n             add(first.getNext());\n             add(\"]\");\n             break;\n         case Token.WITH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"with(\");\n             add(first);\n             add(\")\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.INC:\n         case Token.DEC:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                 int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                 if (postProp !\u003d 0) {\n-                    addLeftExpr(first, NodeUtil.precedence(type), context);\n+                    addExpr(first, NodeUtil.precedence(type), context);\n                     cc.addOp(o, false);\n                 } else {\n                     cc.addOp(o, false);\n                     add(first);\n                 }\n                 break;\n             }\n         case Token.CALL:\n             if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) \u0026\u0026 NodeUtil.isGet(first)) {\n                 add(\"(0,\");\n-                addExpr(first, NodeUtil.precedence(Token.COMMA));\n+                addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n                 add(\")\");\n             } else {\n-                addLeftExpr(first, NodeUtil.precedence(type), context);\n+                addExpr(first, NodeUtil.precedence(type), context);\n             }\n             add(\"(\");\n             addList(first.getNext());\n             add(\")\");\n             break;\n         case Token.IF:\n             boolean hasElse \u003d childCount \u003d\u003d 3;\n             boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n             if (ambiguousElseClause) {\n                 cc.beginBlock();\n             }\n             add(\"if(\");\n             add(first);\n             add(\")\");\n             if (hasElse) {\n                 addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                 add(\"else\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n                 Preconditions.checkState(childCount \u003d\u003d 2);\n             }\n             if (ambiguousElseClause) {\n                 cc.endBlock();\n             }\n             break;\n         case Token.NULL:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(\"null\");\n             break;\n         case Token.THIS:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(\"this\");\n             break;\n         case Token.FALSE:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(\"false\");\n             break;\n         case Token.TRUE:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(\"true\");\n             break;\n         case Token.CONTINUE:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"continue\");\n             if (childCount \u003d\u003d 1) {\n                 if (!first.isLabelName()) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.DEBUGGER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(\"debugger\");\n             cc.endStatement();\n             break;\n         case Token.BREAK:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"break\");\n             if (childCount \u003d\u003d 1) {\n                 if (!first.isLabelName()) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.EXPR_RESULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first, Context.START_OF_EXPR);\n             cc.endStatement();\n             break;\n         case Token.NEW:\n             add(\"new \");\n             int precedence \u003d NodeUtil.precedence(type);\n             if (NodeUtil.containsType(first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n                 precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n             }\n-            addExpr(first, precedence);\n+            addExpr(first, precedence, Context.OTHER);\n             Node next \u003d first.getNext();\n             if (next !\u003d null) {\n                 add(\"(\");\n                 addList(next);\n                 add(\")\");\n             }\n             break;\n         case Token.STRING:\n             if (childCount !\u003d ((n.getParent() !\u003d null \u0026\u0026 n.getParent().isObjectLit()) ? 1 : 0)) {\n                 throw new IllegalStateException(\"Unexpected String children: \" + n.getParent().toStringTree());\n             }\n             addJsString(n);\n             break;\n         case Token.DELPROP:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"delete \");\n             add(first);\n             break;\n         case Token.OBJECTLIT:\n             {\n                 boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 add(\"{\");\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     if (c !\u003d first) {\n                         cc.listSeparator();\n                     }\n                     if (c.isGetterDef() || c.isSetterDef()) {\n                         add(c);\n                     } else {\n                         Preconditions.checkState(c.isString());\n                         String key \u003d c.getString();\n                         if (!c.isQuotedString() \u0026\u0026 !TokenStream.isKeyword(key) \u0026\u0026 TokenStream.isJSIdentifier(key) \u0026\u0026 NodeUtil.isLatin(key)) {\n                             add(key);\n                         } else {\n                             double d \u003d getSimpleNumber(key);\n                             if (!Double.isNaN(d)) {\n                                 cc.addNumber(d);\n                             } else {\n-                                addExpr(c, 1);\n+                                addExpr(c, 1, Context.OTHER);\n                             }\n                         }\n                         add(\":\");\n-                        addExpr(c.getFirstChild(), 1);\n+                        addExpr(c.getFirstChild(), 1, Context.OTHER);\n                     }\n                 }\n                 add(\"}\");\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 break;\n             }\n         case Token.SWITCH:\n             add(\"switch(\");\n             add(first);\n             add(\")\");\n             cc.beginBlock();\n             addAllSiblings(first.getNext());\n             cc.endBlock(context \u003d\u003d Context.STATEMENT);\n             break;\n         case Token.CASE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"case \");\n             add(first);\n             addCaseBody(last);\n             break;\n         case Token.DEFAULT_CASE:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"default\");\n             addCaseBody(first);\n             break;\n         case Token.LABEL:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             if (!first.isLabelName()) {\n                 throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n             }\n             add(first);\n             add(\":\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\n             break;\n         default:\n             throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n     }\n     cc.endSourceMapping(n);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e85593d14461f5342013d0d6c6e8484dca003eef": {
      "type": "Ybodychange",
      "commitMessage": "\nfix vertical tab encoding\nfixes issue 601\n\nR\u003djohnlenz\nDELTA\u003d147  (119 added, 0 deleted, 28 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3787\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1627 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/21/11, 12:02 PM",
      "commitName": "e85593d14461f5342013d0d6c6e8484dca003eef",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "11/17/11, 10:08 AM",
      "commitNameOld": "4e976ac213f448bab78f5c1432340c489b533d7b",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 4.08,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n        return;\n    }\n    int type \u003d n.getType();\n    String opstr \u003d NodeUtil.opToStr(type);\n    int childCount \u003d n.getChildCount();\n    Node first \u003d n.getFirstChild();\n    Node last \u003d n.getLastChild();\n    if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n        Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n        int p \u003d NodeUtil.precedence(type);\n        addLeftExpr(first, p, context);\n        cc.addOp(opstr, true);\n        Context rhsContext \u003d getContextForNoInOperator(context);\n        if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n            addExpr(last, p, rhsContext);\n        } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n            addExpr(last, p, rhsContext);\n        } else {\n            addExpr(last, p + 1, rhsContext);\n        }\n        return;\n    }\n    cc.startSourceMapping(n);\n    switch(type) {\n        case Token.TRY:\n            {\n                Preconditions.checkState(first.getNext().isBlock() \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n                Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                add(\"try\");\n                add(first, Context.PRESERVE_BLOCK);\n                Node catchblock \u003d first.getNext().getFirstChild();\n                if (catchblock !\u003d null) {\n                    add(catchblock);\n                }\n                if (childCount \u003d\u003d 3) {\n                    add(\"finally\");\n                    add(last, Context.PRESERVE_BLOCK);\n                }\n                break;\n            }\n        case Token.CATCH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"catch(\");\n            add(first);\n            add(\")\");\n            add(last, Context.PRESERVE_BLOCK);\n            break;\n        case Token.THROW:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"throw\");\n            add(first);\n            cc.endStatement(true);\n            break;\n        case Token.RETURN:\n            add(\"return\");\n            if (childCount \u003d\u003d 1) {\n                add(first);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 0);\n            }\n            cc.endStatement();\n            break;\n        case Token.VAR:\n            if (first !\u003d null) {\n                add(\"var \");\n                addList(first, false, getContextForNoInOperator(context));\n            }\n            break;\n        case Token.LABEL_NAME:\n            Preconditions.checkState(!n.getString().isEmpty());\n            addIdentifier(n.getString());\n            break;\n        case Token.NAME:\n            if (first \u003d\u003d null || first.isEmpty()) {\n                addIdentifier(n.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                addIdentifier(n.getString());\n                cc.addOp(\"\u003d\", true);\n                if (first.isComma()) {\n                    addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                } else {\n                    addExpr(first, 0, getContextForNoInOperator(context));\n                }\n            }\n            break;\n        case Token.ARRAYLIT:\n            add(\"[\");\n            addArrayList(first);\n            add(\"]\");\n            break;\n        case Token.PARAM_LIST:\n            add(\"(\");\n            addList(first);\n            add(\")\");\n            break;\n        case Token.COMMA:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            addList(first, false, context);\n            break;\n        case Token.NUMBER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            cc.addNumber(n.getDouble());\n            break;\n        case Token.TYPEOF:\n        case Token.VOID:\n        case Token.NOT:\n        case Token.BITNOT:\n        case Token.POS:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                addExpr(first, NodeUtil.precedence(type));\n                break;\n            }\n        case Token.NEG:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                if (n.getFirstChild().isNumber()) {\n                    cc.addNumber(-n.getFirstChild().getDouble());\n                } else {\n                    cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                    addExpr(first, NodeUtil.precedence(type));\n                }\n                break;\n            }\n        case Token.HOOK:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                int p \u003d NodeUtil.precedence(type);\n                addLeftExpr(first, p + 1, context);\n                cc.addOp(\"?\", true);\n                addExpr(first.getNext(), 1);\n                cc.addOp(\":\", true);\n                addExpr(last, 1);\n                break;\n            }\n        case Token.REGEXP:\n            if (!first.isString() || !last.isString()) {\n                throw new Error(\"Expected children to be strings\");\n            }\n            String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n            if (childCount \u003d\u003d 2) {\n                add(regexp + last.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                add(regexp);\n            }\n            break;\n        case Token.FUNCTION:\n            if (n.getClass() !\u003d Node.class) {\n                throw new Error(\"Unexpected Node subclass.\");\n            }\n            Preconditions.checkState(childCount \u003d\u003d 3);\n            boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n            if (funcNeedsParens) {\n                add(\"(\");\n            }\n            add(\"function\");\n            add(first);\n            add(first.getNext());\n            add(last, Context.PRESERVE_BLOCK);\n            cc.endFunction(context \u003d\u003d Context.STATEMENT);\n            if (funcNeedsParens) {\n                add(\")\");\n            }\n            break;\n        case Token.GETTER_DEF:\n        case Token.SETTER_DEF:\n            Preconditions.checkState(n.getParent().isObjectLit());\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            Preconditions.checkState(first.isFunction());\n            Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n            if (type \u003d\u003d Token.GETTER_DEF) {\n                Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n                add(\"get \");\n            } else {\n                Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n                add(\"set \");\n            }\n            String name \u003d n.getString();\n            Node fn \u003d first;\n            Node parameters \u003d fn.getChildAtIndex(1);\n            Node body \u003d fn.getLastChild();\n            if (!n.isQuotedString() \u0026\u0026 TokenStream.isJSIdentifier(name) \u0026\u0026 NodeUtil.isLatin(name)) {\n                add(name);\n            } else {\n                double d \u003d getSimpleNumber(name);\n                if (!Double.isNaN(d)) {\n                    cc.addNumber(d);\n                } else {\n                    addJsString(n);\n                }\n            }\n            add(parameters);\n            add(body, Context.PRESERVE_BLOCK);\n            break;\n        case Token.SCRIPT:\n        case Token.BLOCK:\n            {\n                if (n.getClass() !\u003d Node.class) {\n                    throw new Error(\"Unexpected Node subclass.\");\n                }\n                boolean preserveBlock \u003d context \u003d\u003d Context.PRESERVE_BLOCK;\n                if (preserveBlock) {\n                    cc.beginBlock();\n                }\n                boolean preferLineBreaks \u003d type \u003d\u003d Token.SCRIPT || (type \u003d\u003d Token.BLOCK \u0026\u0026 !preserveBlock \u0026\u0026 n.getParent() !\u003d null \u0026\u0026 n.getParent().isScript());\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    add(c, Context.STATEMENT);\n                    if (c.isVar()) {\n                        cc.endStatement();\n                    }\n                    if (c.isFunction()) {\n                        cc.maybeLineBreak();\n                    }\n                    if (preferLineBreaks) {\n                        cc.notePreferredLineBreak();\n                    }\n                }\n                if (preserveBlock) {\n                    cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                }\n                break;\n            }\n        case Token.FOR:\n            if (childCount \u003d\u003d 4) {\n                add(\"for(\");\n                if (first.isVar()) {\n                    add(first, Context.IN_FOR_INIT_CLAUSE);\n                } else {\n                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                }\n                add(\";\");\n                add(first.getNext());\n                add(\";\");\n                add(first.getNext().getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                add(\"for(\");\n                add(first);\n                add(\"in\");\n                add(first.getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            }\n            break;\n        case Token.DO:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"do\");\n            addNonEmptyStatement(first, Context.OTHER, false);\n            add(\"while(\");\n            add(last);\n            add(\")\");\n            cc.endStatement();\n            break;\n        case Token.WHILE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"while(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.EMPTY:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            break;\n        case Token.GETPROP:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                Preconditions.checkState(last.isString(), \"Bad GETPROP: RHS should be STRING\");\n                boolean needsParens \u003d (first.isNumber());\n                if (needsParens) {\n                    add(\"(\");\n                }\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n                if (needsParens) {\n                    add(\")\");\n                }\n                add(\".\");\n                addIdentifier(last.getString());\n                break;\n            }\n        case Token.GETELEM:\n            Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n            addLeftExpr(first, NodeUtil.precedence(type), context);\n            add(\"[\");\n            add(first.getNext());\n            add(\"]\");\n            break;\n        case Token.WITH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"with(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.INC:\n        case Token.DEC:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                if (postProp !\u003d 0) {\n                    addLeftExpr(first, NodeUtil.precedence(type), context);\n                    cc.addOp(o, false);\n                } else {\n                    cc.addOp(o, false);\n                    add(first);\n                }\n                break;\n            }\n        case Token.CALL:\n            if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) \u0026\u0026 NodeUtil.isGet(first)) {\n                add(\"(0,\");\n                addExpr(first, NodeUtil.precedence(Token.COMMA));\n                add(\")\");\n            } else {\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n            }\n            add(\"(\");\n            addList(first.getNext());\n            add(\")\");\n            break;\n        case Token.IF:\n            boolean hasElse \u003d childCount \u003d\u003d 3;\n            boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n            if (ambiguousElseClause) {\n                cc.beginBlock();\n            }\n            add(\"if(\");\n            add(first);\n            add(\")\");\n            if (hasElse) {\n                addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                add(\"else\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n                Preconditions.checkState(childCount \u003d\u003d 2);\n            }\n            if (ambiguousElseClause) {\n                cc.endBlock();\n            }\n            break;\n        case Token.NULL:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"null\");\n            break;\n        case Token.THIS:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"this\");\n            break;\n        case Token.FALSE:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"false\");\n            break;\n        case Token.TRUE:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"true\");\n            break;\n        case Token.CONTINUE:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"continue\");\n            if (childCount \u003d\u003d 1) {\n                if (!first.isLabelName()) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.DEBUGGER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"debugger\");\n            cc.endStatement();\n            break;\n        case Token.BREAK:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"break\");\n            if (childCount \u003d\u003d 1) {\n                if (!first.isLabelName()) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.EXPR_RESULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first, Context.START_OF_EXPR);\n            cc.endStatement();\n            break;\n        case Token.NEW:\n            add(\"new \");\n            int precedence \u003d NodeUtil.precedence(type);\n            if (NodeUtil.containsType(first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n                precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n            }\n            addExpr(first, precedence);\n            Node next \u003d first.getNext();\n            if (next !\u003d null) {\n                add(\"(\");\n                addList(next);\n                add(\")\");\n            }\n            break;\n        case Token.STRING:\n            if (childCount !\u003d ((n.getParent() !\u003d null \u0026\u0026 n.getParent().isObjectLit()) ? 1 : 0)) {\n                throw new IllegalStateException(\"Unexpected String children: \" + n.getParent().toStringTree());\n            }\n            addJsString(n);\n            break;\n        case Token.DELPROP:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"delete \");\n            add(first);\n            break;\n        case Token.OBJECTLIT:\n            {\n                boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                add(\"{\");\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    if (c !\u003d first) {\n                        cc.listSeparator();\n                    }\n                    if (c.isGetterDef() || c.isSetterDef()) {\n                        add(c);\n                    } else {\n                        Preconditions.checkState(c.isString());\n                        String key \u003d c.getString();\n                        if (!c.isQuotedString() \u0026\u0026 !TokenStream.isKeyword(key) \u0026\u0026 TokenStream.isJSIdentifier(key) \u0026\u0026 NodeUtil.isLatin(key)) {\n                            add(key);\n                        } else {\n                            double d \u003d getSimpleNumber(key);\n                            if (!Double.isNaN(d)) {\n                                cc.addNumber(d);\n                            } else {\n                                addExpr(c, 1);\n                            }\n                        }\n                        add(\":\");\n                        addExpr(c.getFirstChild(), 1);\n                    }\n                }\n                add(\"}\");\n                if (needsParens) {\n                    add(\")\");\n                }\n                break;\n            }\n        case Token.SWITCH:\n            add(\"switch(\");\n            add(first);\n            add(\")\");\n            cc.beginBlock();\n            addAllSiblings(first.getNext());\n            cc.endBlock(context \u003d\u003d Context.STATEMENT);\n            break;\n        case Token.CASE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"case \");\n            add(first);\n            addCaseBody(last);\n            break;\n        case Token.DEFAULT_CASE:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"default\");\n            addCaseBody(first);\n            break;\n        case Token.LABEL:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            if (!first.isLabelName()) {\n                throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n            }\n            add(first);\n            add(\":\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\n            break;\n        default:\n            throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n    cc.endSourceMapping(n);\n}",
      "path": "src/com/google/javascript/jscomp/CodeGenerator.java",
      "functionStartLine": 85,
      "functionName": "add",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,492 +1,492 @@\n void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n         return;\n     }\n     int type \u003d n.getType();\n     String opstr \u003d NodeUtil.opToStr(type);\n     int childCount \u003d n.getChildCount();\n     Node first \u003d n.getFirstChild();\n     Node last \u003d n.getLastChild();\n     if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n         Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n         int p \u003d NodeUtil.precedence(type);\n         addLeftExpr(first, p, context);\n         cc.addOp(opstr, true);\n         Context rhsContext \u003d getContextForNoInOperator(context);\n         if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n             addExpr(last, p, rhsContext);\n         } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n             addExpr(last, p, rhsContext);\n         } else {\n             addExpr(last, p + 1, rhsContext);\n         }\n         return;\n     }\n     cc.startSourceMapping(n);\n     switch(type) {\n         case Token.TRY:\n             {\n                 Preconditions.checkState(first.getNext().isBlock() \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n                 Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                 add(\"try\");\n                 add(first, Context.PRESERVE_BLOCK);\n                 Node catchblock \u003d first.getNext().getFirstChild();\n                 if (catchblock !\u003d null) {\n                     add(catchblock);\n                 }\n                 if (childCount \u003d\u003d 3) {\n                     add(\"finally\");\n                     add(last, Context.PRESERVE_BLOCK);\n                 }\n                 break;\n             }\n         case Token.CATCH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"catch(\");\n             add(first);\n             add(\")\");\n             add(last, Context.PRESERVE_BLOCK);\n             break;\n         case Token.THROW:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"throw\");\n             add(first);\n             cc.endStatement(true);\n             break;\n         case Token.RETURN:\n             add(\"return\");\n             if (childCount \u003d\u003d 1) {\n                 add(first);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 0);\n             }\n             cc.endStatement();\n             break;\n         case Token.VAR:\n             if (first !\u003d null) {\n                 add(\"var \");\n                 addList(first, false, getContextForNoInOperator(context));\n             }\n             break;\n         case Token.LABEL_NAME:\n             Preconditions.checkState(!n.getString().isEmpty());\n             addIdentifier(n.getString());\n             break;\n         case Token.NAME:\n             if (first \u003d\u003d null || first.isEmpty()) {\n                 addIdentifier(n.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 addIdentifier(n.getString());\n                 cc.addOp(\"\u003d\", true);\n                 if (first.isComma()) {\n                     addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                 } else {\n                     addExpr(first, 0, getContextForNoInOperator(context));\n                 }\n             }\n             break;\n         case Token.ARRAYLIT:\n             add(\"[\");\n             addArrayList(first);\n             add(\"]\");\n             break;\n         case Token.PARAM_LIST:\n             add(\"(\");\n             addList(first);\n             add(\")\");\n             break;\n         case Token.COMMA:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             addList(first, false, context);\n             break;\n         case Token.NUMBER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             cc.addNumber(n.getDouble());\n             break;\n         case Token.TYPEOF:\n         case Token.VOID:\n         case Token.NOT:\n         case Token.BITNOT:\n         case Token.POS:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                 addExpr(first, NodeUtil.precedence(type));\n                 break;\n             }\n         case Token.NEG:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 if (n.getFirstChild().isNumber()) {\n                     cc.addNumber(-n.getFirstChild().getDouble());\n                 } else {\n                     cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                     addExpr(first, NodeUtil.precedence(type));\n                 }\n                 break;\n             }\n         case Token.HOOK:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 int p \u003d NodeUtil.precedence(type);\n                 addLeftExpr(first, p + 1, context);\n                 cc.addOp(\"?\", true);\n                 addExpr(first.getNext(), 1);\n                 cc.addOp(\":\", true);\n                 addExpr(last, 1);\n                 break;\n             }\n         case Token.REGEXP:\n             if (!first.isString() || !last.isString()) {\n                 throw new Error(\"Expected children to be strings\");\n             }\n             String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n             if (childCount \u003d\u003d 2) {\n                 add(regexp + last.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 add(regexp);\n             }\n             break;\n         case Token.FUNCTION:\n             if (n.getClass() !\u003d Node.class) {\n                 throw new Error(\"Unexpected Node subclass.\");\n             }\n             Preconditions.checkState(childCount \u003d\u003d 3);\n             boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n             if (funcNeedsParens) {\n                 add(\"(\");\n             }\n             add(\"function\");\n             add(first);\n             add(first.getNext());\n             add(last, Context.PRESERVE_BLOCK);\n             cc.endFunction(context \u003d\u003d Context.STATEMENT);\n             if (funcNeedsParens) {\n                 add(\")\");\n             }\n             break;\n         case Token.GETTER_DEF:\n         case Token.SETTER_DEF:\n             Preconditions.checkState(n.getParent().isObjectLit());\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             Preconditions.checkState(first.isFunction());\n             Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n             if (type \u003d\u003d Token.GETTER_DEF) {\n                 Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n                 add(\"get \");\n             } else {\n                 Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n                 add(\"set \");\n             }\n             String name \u003d n.getString();\n             Node fn \u003d first;\n             Node parameters \u003d fn.getChildAtIndex(1);\n             Node body \u003d fn.getLastChild();\n             if (!n.isQuotedString() \u0026\u0026 TokenStream.isJSIdentifier(name) \u0026\u0026 NodeUtil.isLatin(name)) {\n                 add(name);\n             } else {\n                 double d \u003d getSimpleNumber(name);\n                 if (!Double.isNaN(d)) {\n                     cc.addNumber(d);\n                 } else {\n-                    addJsString(n.getString());\n+                    addJsString(n);\n                 }\n             }\n             add(parameters);\n             add(body, Context.PRESERVE_BLOCK);\n             break;\n         case Token.SCRIPT:\n         case Token.BLOCK:\n             {\n                 if (n.getClass() !\u003d Node.class) {\n                     throw new Error(\"Unexpected Node subclass.\");\n                 }\n                 boolean preserveBlock \u003d context \u003d\u003d Context.PRESERVE_BLOCK;\n                 if (preserveBlock) {\n                     cc.beginBlock();\n                 }\n                 boolean preferLineBreaks \u003d type \u003d\u003d Token.SCRIPT || (type \u003d\u003d Token.BLOCK \u0026\u0026 !preserveBlock \u0026\u0026 n.getParent() !\u003d null \u0026\u0026 n.getParent().isScript());\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     add(c, Context.STATEMENT);\n                     if (c.isVar()) {\n                         cc.endStatement();\n                     }\n                     if (c.isFunction()) {\n                         cc.maybeLineBreak();\n                     }\n                     if (preferLineBreaks) {\n                         cc.notePreferredLineBreak();\n                     }\n                 }\n                 if (preserveBlock) {\n                     cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                 }\n                 break;\n             }\n         case Token.FOR:\n             if (childCount \u003d\u003d 4) {\n                 add(\"for(\");\n                 if (first.isVar()) {\n                     add(first, Context.IN_FOR_INIT_CLAUSE);\n                 } else {\n                     addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                 }\n                 add(\";\");\n                 add(first.getNext());\n                 add(\";\");\n                 add(first.getNext().getNext());\n                 add(\")\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 add(\"for(\");\n                 add(first);\n                 add(\"in\");\n                 add(first.getNext());\n                 add(\")\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             }\n             break;\n         case Token.DO:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"do\");\n             addNonEmptyStatement(first, Context.OTHER, false);\n             add(\"while(\");\n             add(last);\n             add(\")\");\n             cc.endStatement();\n             break;\n         case Token.WHILE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"while(\");\n             add(first);\n             add(\")\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.EMPTY:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             break;\n         case Token.GETPROP:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                 Preconditions.checkState(last.isString(), \"Bad GETPROP: RHS should be STRING\");\n                 boolean needsParens \u003d (first.isNumber());\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 add(\".\");\n                 addIdentifier(last.getString());\n                 break;\n             }\n         case Token.GETELEM:\n             Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n             addLeftExpr(first, NodeUtil.precedence(type), context);\n             add(\"[\");\n             add(first.getNext());\n             add(\"]\");\n             break;\n         case Token.WITH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"with(\");\n             add(first);\n             add(\")\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.INC:\n         case Token.DEC:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                 int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                 if (postProp !\u003d 0) {\n                     addLeftExpr(first, NodeUtil.precedence(type), context);\n                     cc.addOp(o, false);\n                 } else {\n                     cc.addOp(o, false);\n                     add(first);\n                 }\n                 break;\n             }\n         case Token.CALL:\n             if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) \u0026\u0026 NodeUtil.isGet(first)) {\n                 add(\"(0,\");\n                 addExpr(first, NodeUtil.precedence(Token.COMMA));\n                 add(\")\");\n             } else {\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n             }\n             add(\"(\");\n             addList(first.getNext());\n             add(\")\");\n             break;\n         case Token.IF:\n             boolean hasElse \u003d childCount \u003d\u003d 3;\n             boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n             if (ambiguousElseClause) {\n                 cc.beginBlock();\n             }\n             add(\"if(\");\n             add(first);\n             add(\")\");\n             if (hasElse) {\n                 addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                 add(\"else\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n                 Preconditions.checkState(childCount \u003d\u003d 2);\n             }\n             if (ambiguousElseClause) {\n                 cc.endBlock();\n             }\n             break;\n         case Token.NULL:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(\"null\");\n             break;\n         case Token.THIS:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(\"this\");\n             break;\n         case Token.FALSE:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(\"false\");\n             break;\n         case Token.TRUE:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(\"true\");\n             break;\n         case Token.CONTINUE:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"continue\");\n             if (childCount \u003d\u003d 1) {\n                 if (!first.isLabelName()) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.DEBUGGER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(\"debugger\");\n             cc.endStatement();\n             break;\n         case Token.BREAK:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"break\");\n             if (childCount \u003d\u003d 1) {\n                 if (!first.isLabelName()) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.EXPR_RESULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first, Context.START_OF_EXPR);\n             cc.endStatement();\n             break;\n         case Token.NEW:\n             add(\"new \");\n             int precedence \u003d NodeUtil.precedence(type);\n             if (NodeUtil.containsType(first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n                 precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n             }\n             addExpr(first, precedence);\n             Node next \u003d first.getNext();\n             if (next !\u003d null) {\n                 add(\"(\");\n                 addList(next);\n                 add(\")\");\n             }\n             break;\n         case Token.STRING:\n             if (childCount !\u003d ((n.getParent() !\u003d null \u0026\u0026 n.getParent().isObjectLit()) ? 1 : 0)) {\n                 throw new IllegalStateException(\"Unexpected String children: \" + n.getParent().toStringTree());\n             }\n-            addJsString(n.getString());\n+            addJsString(n);\n             break;\n         case Token.DELPROP:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"delete \");\n             add(first);\n             break;\n         case Token.OBJECTLIT:\n             {\n                 boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 add(\"{\");\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     if (c !\u003d first) {\n                         cc.listSeparator();\n                     }\n                     if (c.isGetterDef() || c.isSetterDef()) {\n                         add(c);\n                     } else {\n                         Preconditions.checkState(c.isString());\n                         String key \u003d c.getString();\n                         if (!c.isQuotedString() \u0026\u0026 !TokenStream.isKeyword(key) \u0026\u0026 TokenStream.isJSIdentifier(key) \u0026\u0026 NodeUtil.isLatin(key)) {\n                             add(key);\n                         } else {\n                             double d \u003d getSimpleNumber(key);\n                             if (!Double.isNaN(d)) {\n                                 cc.addNumber(d);\n                             } else {\n                                 addExpr(c, 1);\n                             }\n                         }\n                         add(\":\");\n                         addExpr(c.getFirstChild(), 1);\n                     }\n                 }\n                 add(\"}\");\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 break;\n             }\n         case Token.SWITCH:\n             add(\"switch(\");\n             add(first);\n             add(\")\");\n             cc.beginBlock();\n             addAllSiblings(first.getNext());\n             cc.endBlock(context \u003d\u003d Context.STATEMENT);\n             break;\n         case Token.CASE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"case \");\n             add(first);\n             addCaseBody(last);\n             break;\n         case Token.DEFAULT_CASE:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"default\");\n             addCaseBody(first);\n             break;\n         case Token.LABEL:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             if (!first.isLabelName()) {\n                 throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n             }\n             add(first);\n             add(\":\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\n             break;\n         default:\n             throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n     }\n     cc.endSourceMapping(n);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4e976ac213f448bab78f5c1432340c489b533d7b": {
      "type": "Ybodychange",
      "commitMessage": "\nRemove redundant Token to string function.\n\nR\u003dnicksantos\nDELTA\u003d148  (16 added, 89 deleted, 43 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3765\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1621 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/17/11, 10:08 AM",
      "commitName": "4e976ac213f448bab78f5c1432340c489b533d7b",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "11/15/11, 5:35 PM",
      "commitNameOld": "925a8f78c8c6a407435e6fb4513ad96d617643a3",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 1.69,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "actualSource": "void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n        return;\n    }\n    int type \u003d n.getType();\n    String opstr \u003d NodeUtil.opToStr(type);\n    int childCount \u003d n.getChildCount();\n    Node first \u003d n.getFirstChild();\n    Node last \u003d n.getLastChild();\n    if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n        Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n        int p \u003d NodeUtil.precedence(type);\n        addLeftExpr(first, p, context);\n        cc.addOp(opstr, true);\n        Context rhsContext \u003d getContextForNoInOperator(context);\n        if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n            addExpr(last, p, rhsContext);\n        } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n            addExpr(last, p, rhsContext);\n        } else {\n            addExpr(last, p + 1, rhsContext);\n        }\n        return;\n    }\n    cc.startSourceMapping(n);\n    switch(type) {\n        case Token.TRY:\n            {\n                Preconditions.checkState(first.getNext().isBlock() \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n                Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                add(\"try\");\n                add(first, Context.PRESERVE_BLOCK);\n                Node catchblock \u003d first.getNext().getFirstChild();\n                if (catchblock !\u003d null) {\n                    add(catchblock);\n                }\n                if (childCount \u003d\u003d 3) {\n                    add(\"finally\");\n                    add(last, Context.PRESERVE_BLOCK);\n                }\n                break;\n            }\n        case Token.CATCH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"catch(\");\n            add(first);\n            add(\")\");\n            add(last, Context.PRESERVE_BLOCK);\n            break;\n        case Token.THROW:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"throw\");\n            add(first);\n            cc.endStatement(true);\n            break;\n        case Token.RETURN:\n            add(\"return\");\n            if (childCount \u003d\u003d 1) {\n                add(first);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 0);\n            }\n            cc.endStatement();\n            break;\n        case Token.VAR:\n            if (first !\u003d null) {\n                add(\"var \");\n                addList(first, false, getContextForNoInOperator(context));\n            }\n            break;\n        case Token.LABEL_NAME:\n            Preconditions.checkState(!n.getString().isEmpty());\n            addIdentifier(n.getString());\n            break;\n        case Token.NAME:\n            if (first \u003d\u003d null || first.isEmpty()) {\n                addIdentifier(n.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                addIdentifier(n.getString());\n                cc.addOp(\"\u003d\", true);\n                if (first.isComma()) {\n                    addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                } else {\n                    addExpr(first, 0, getContextForNoInOperator(context));\n                }\n            }\n            break;\n        case Token.ARRAYLIT:\n            add(\"[\");\n            addArrayList(first);\n            add(\"]\");\n            break;\n        case Token.PARAM_LIST:\n            add(\"(\");\n            addList(first);\n            add(\")\");\n            break;\n        case Token.COMMA:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            addList(first, false, context);\n            break;\n        case Token.NUMBER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            cc.addNumber(n.getDouble());\n            break;\n        case Token.TYPEOF:\n        case Token.VOID:\n        case Token.NOT:\n        case Token.BITNOT:\n        case Token.POS:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                addExpr(first, NodeUtil.precedence(type));\n                break;\n            }\n        case Token.NEG:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                if (n.getFirstChild().isNumber()) {\n                    cc.addNumber(-n.getFirstChild().getDouble());\n                } else {\n                    cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                    addExpr(first, NodeUtil.precedence(type));\n                }\n                break;\n            }\n        case Token.HOOK:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                int p \u003d NodeUtil.precedence(type);\n                addLeftExpr(first, p + 1, context);\n                cc.addOp(\"?\", true);\n                addExpr(first.getNext(), 1);\n                cc.addOp(\":\", true);\n                addExpr(last, 1);\n                break;\n            }\n        case Token.REGEXP:\n            if (!first.isString() || !last.isString()) {\n                throw new Error(\"Expected children to be strings\");\n            }\n            String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n            if (childCount \u003d\u003d 2) {\n                add(regexp + last.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                add(regexp);\n            }\n            break;\n        case Token.FUNCTION:\n            if (n.getClass() !\u003d Node.class) {\n                throw new Error(\"Unexpected Node subclass.\");\n            }\n            Preconditions.checkState(childCount \u003d\u003d 3);\n            boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n            if (funcNeedsParens) {\n                add(\"(\");\n            }\n            add(\"function\");\n            add(first);\n            add(first.getNext());\n            add(last, Context.PRESERVE_BLOCK);\n            cc.endFunction(context \u003d\u003d Context.STATEMENT);\n            if (funcNeedsParens) {\n                add(\")\");\n            }\n            break;\n        case Token.GETTER_DEF:\n        case Token.SETTER_DEF:\n            Preconditions.checkState(n.getParent().isObjectLit());\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            Preconditions.checkState(first.isFunction());\n            Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n            if (type \u003d\u003d Token.GETTER_DEF) {\n                Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n                add(\"get \");\n            } else {\n                Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n                add(\"set \");\n            }\n            String name \u003d n.getString();\n            Node fn \u003d first;\n            Node parameters \u003d fn.getChildAtIndex(1);\n            Node body \u003d fn.getLastChild();\n            if (!n.isQuotedString() \u0026\u0026 TokenStream.isJSIdentifier(name) \u0026\u0026 NodeUtil.isLatin(name)) {\n                add(name);\n            } else {\n                double d \u003d getSimpleNumber(name);\n                if (!Double.isNaN(d)) {\n                    cc.addNumber(d);\n                } else {\n                    addJsString(n.getString());\n                }\n            }\n            add(parameters);\n            add(body, Context.PRESERVE_BLOCK);\n            break;\n        case Token.SCRIPT:\n        case Token.BLOCK:\n            {\n                if (n.getClass() !\u003d Node.class) {\n                    throw new Error(\"Unexpected Node subclass.\");\n                }\n                boolean preserveBlock \u003d context \u003d\u003d Context.PRESERVE_BLOCK;\n                if (preserveBlock) {\n                    cc.beginBlock();\n                }\n                boolean preferLineBreaks \u003d type \u003d\u003d Token.SCRIPT || (type \u003d\u003d Token.BLOCK \u0026\u0026 !preserveBlock \u0026\u0026 n.getParent() !\u003d null \u0026\u0026 n.getParent().isScript());\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    add(c, Context.STATEMENT);\n                    if (c.isVar()) {\n                        cc.endStatement();\n                    }\n                    if (c.isFunction()) {\n                        cc.maybeLineBreak();\n                    }\n                    if (preferLineBreaks) {\n                        cc.notePreferredLineBreak();\n                    }\n                }\n                if (preserveBlock) {\n                    cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                }\n                break;\n            }\n        case Token.FOR:\n            if (childCount \u003d\u003d 4) {\n                add(\"for(\");\n                if (first.isVar()) {\n                    add(first, Context.IN_FOR_INIT_CLAUSE);\n                } else {\n                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                }\n                add(\";\");\n                add(first.getNext());\n                add(\";\");\n                add(first.getNext().getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                add(\"for(\");\n                add(first);\n                add(\"in\");\n                add(first.getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            }\n            break;\n        case Token.DO:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"do\");\n            addNonEmptyStatement(first, Context.OTHER, false);\n            add(\"while(\");\n            add(last);\n            add(\")\");\n            cc.endStatement();\n            break;\n        case Token.WHILE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"while(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.EMPTY:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            break;\n        case Token.GETPROP:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                Preconditions.checkState(last.isString(), \"Bad GETPROP: RHS should be STRING\");\n                boolean needsParens \u003d (first.isNumber());\n                if (needsParens) {\n                    add(\"(\");\n                }\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n                if (needsParens) {\n                    add(\")\");\n                }\n                add(\".\");\n                addIdentifier(last.getString());\n                break;\n            }\n        case Token.GETELEM:\n            Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n            addLeftExpr(first, NodeUtil.precedence(type), context);\n            add(\"[\");\n            add(first.getNext());\n            add(\"]\");\n            break;\n        case Token.WITH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"with(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.INC:\n        case Token.DEC:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                if (postProp !\u003d 0) {\n                    addLeftExpr(first, NodeUtil.precedence(type), context);\n                    cc.addOp(o, false);\n                } else {\n                    cc.addOp(o, false);\n                    add(first);\n                }\n                break;\n            }\n        case Token.CALL:\n            if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) \u0026\u0026 NodeUtil.isGet(first)) {\n                add(\"(0,\");\n                addExpr(first, NodeUtil.precedence(Token.COMMA));\n                add(\")\");\n            } else {\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n            }\n            add(\"(\");\n            addList(first.getNext());\n            add(\")\");\n            break;\n        case Token.IF:\n            boolean hasElse \u003d childCount \u003d\u003d 3;\n            boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n            if (ambiguousElseClause) {\n                cc.beginBlock();\n            }\n            add(\"if(\");\n            add(first);\n            add(\")\");\n            if (hasElse) {\n                addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                add(\"else\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n                Preconditions.checkState(childCount \u003d\u003d 2);\n            }\n            if (ambiguousElseClause) {\n                cc.endBlock();\n            }\n            break;\n        case Token.NULL:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"null\");\n            break;\n        case Token.THIS:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"this\");\n            break;\n        case Token.FALSE:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"false\");\n            break;\n        case Token.TRUE:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"true\");\n            break;\n        case Token.CONTINUE:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"continue\");\n            if (childCount \u003d\u003d 1) {\n                if (!first.isLabelName()) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.DEBUGGER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"debugger\");\n            cc.endStatement();\n            break;\n        case Token.BREAK:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"break\");\n            if (childCount \u003d\u003d 1) {\n                if (!first.isLabelName()) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.EXPR_RESULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first, Context.START_OF_EXPR);\n            cc.endStatement();\n            break;\n        case Token.NEW:\n            add(\"new \");\n            int precedence \u003d NodeUtil.precedence(type);\n            if (NodeUtil.containsType(first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n                precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n            }\n            addExpr(first, precedence);\n            Node next \u003d first.getNext();\n            if (next !\u003d null) {\n                add(\"(\");\n                addList(next);\n                add(\")\");\n            }\n            break;\n        case Token.STRING:\n            if (childCount !\u003d ((n.getParent() !\u003d null \u0026\u0026 n.getParent().isObjectLit()) ? 1 : 0)) {\n                throw new IllegalStateException(\"Unexpected String children: \" + n.getParent().toStringTree());\n            }\n            addJsString(n.getString());\n            break;\n        case Token.DELPROP:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"delete \");\n            add(first);\n            break;\n        case Token.OBJECTLIT:\n            {\n                boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                add(\"{\");\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    if (c !\u003d first) {\n                        cc.listSeparator();\n                    }\n                    if (c.isGetterDef() || c.isSetterDef()) {\n                        add(c);\n                    } else {\n                        Preconditions.checkState(c.isString());\n                        String key \u003d c.getString();\n                        if (!c.isQuotedString() \u0026\u0026 !TokenStream.isKeyword(key) \u0026\u0026 TokenStream.isJSIdentifier(key) \u0026\u0026 NodeUtil.isLatin(key)) {\n                            add(key);\n                        } else {\n                            double d \u003d getSimpleNumber(key);\n                            if (!Double.isNaN(d)) {\n                                cc.addNumber(d);\n                            } else {\n                                addExpr(c, 1);\n                            }\n                        }\n                        add(\":\");\n                        addExpr(c.getFirstChild(), 1);\n                    }\n                }\n                add(\"}\");\n                if (needsParens) {\n                    add(\")\");\n                }\n                break;\n            }\n        case Token.SWITCH:\n            add(\"switch(\");\n            add(first);\n            add(\")\");\n            cc.beginBlock();\n            addAllSiblings(first.getNext());\n            cc.endBlock(context \u003d\u003d Context.STATEMENT);\n            break;\n        case Token.CASE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"case \");\n            add(first);\n            addCaseBody(last);\n            break;\n        case Token.DEFAULT_CASE:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"default\");\n            addCaseBody(first);\n            break;\n        case Token.LABEL:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            if (!first.isLabelName()) {\n                throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n            }\n            add(first);\n            add(\":\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\n            break;\n        default:\n            throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n    cc.endSourceMapping(n);\n}",
      "path": "src/com/google/javascript/jscomp/CodeGenerator.java",
      "functionStartLine": 85,
      "functionName": "add",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,483 +1,492 @@\n void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n         return;\n     }\n     int type \u003d n.getType();\n     String opstr \u003d NodeUtil.opToStr(type);\n     int childCount \u003d n.getChildCount();\n     Node first \u003d n.getFirstChild();\n     Node last \u003d n.getLastChild();\n     if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n         Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n         int p \u003d NodeUtil.precedence(type);\n         addLeftExpr(first, p, context);\n         cc.addOp(opstr, true);\n         Context rhsContext \u003d getContextForNoInOperator(context);\n         if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n             addExpr(last, p, rhsContext);\n         } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n             addExpr(last, p, rhsContext);\n         } else {\n             addExpr(last, p + 1, rhsContext);\n         }\n         return;\n     }\n     cc.startSourceMapping(n);\n     switch(type) {\n         case Token.TRY:\n             {\n                 Preconditions.checkState(first.getNext().isBlock() \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n                 Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                 add(\"try\");\n                 add(first, Context.PRESERVE_BLOCK);\n                 Node catchblock \u003d first.getNext().getFirstChild();\n                 if (catchblock !\u003d null) {\n                     add(catchblock);\n                 }\n                 if (childCount \u003d\u003d 3) {\n                     add(\"finally\");\n                     add(last, Context.PRESERVE_BLOCK);\n                 }\n                 break;\n             }\n         case Token.CATCH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"catch(\");\n             add(first);\n             add(\")\");\n             add(last, Context.PRESERVE_BLOCK);\n             break;\n         case Token.THROW:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"throw\");\n             add(first);\n             cc.endStatement(true);\n             break;\n         case Token.RETURN:\n             add(\"return\");\n             if (childCount \u003d\u003d 1) {\n                 add(first);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 0);\n             }\n             cc.endStatement();\n             break;\n         case Token.VAR:\n             if (first !\u003d null) {\n                 add(\"var \");\n                 addList(first, false, getContextForNoInOperator(context));\n             }\n             break;\n         case Token.LABEL_NAME:\n             Preconditions.checkState(!n.getString().isEmpty());\n             addIdentifier(n.getString());\n             break;\n         case Token.NAME:\n             if (first \u003d\u003d null || first.isEmpty()) {\n                 addIdentifier(n.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 addIdentifier(n.getString());\n                 cc.addOp(\"\u003d\", true);\n                 if (first.isComma()) {\n                     addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                 } else {\n                     addExpr(first, 0, getContextForNoInOperator(context));\n                 }\n             }\n             break;\n         case Token.ARRAYLIT:\n             add(\"[\");\n             addArrayList(first);\n             add(\"]\");\n             break;\n         case Token.PARAM_LIST:\n             add(\"(\");\n             addList(first);\n             add(\")\");\n             break;\n         case Token.COMMA:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             addList(first, false, context);\n             break;\n         case Token.NUMBER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             cc.addNumber(n.getDouble());\n             break;\n         case Token.TYPEOF:\n         case Token.VOID:\n         case Token.NOT:\n         case Token.BITNOT:\n         case Token.POS:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                 addExpr(first, NodeUtil.precedence(type));\n                 break;\n             }\n         case Token.NEG:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 if (n.getFirstChild().isNumber()) {\n                     cc.addNumber(-n.getFirstChild().getDouble());\n                 } else {\n                     cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                     addExpr(first, NodeUtil.precedence(type));\n                 }\n                 break;\n             }\n         case Token.HOOK:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 int p \u003d NodeUtil.precedence(type);\n                 addLeftExpr(first, p + 1, context);\n                 cc.addOp(\"?\", true);\n                 addExpr(first.getNext(), 1);\n                 cc.addOp(\":\", true);\n                 addExpr(last, 1);\n                 break;\n             }\n         case Token.REGEXP:\n             if (!first.isString() || !last.isString()) {\n                 throw new Error(\"Expected children to be strings\");\n             }\n             String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n             if (childCount \u003d\u003d 2) {\n                 add(regexp + last.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 add(regexp);\n             }\n             break;\n         case Token.FUNCTION:\n             if (n.getClass() !\u003d Node.class) {\n                 throw new Error(\"Unexpected Node subclass.\");\n             }\n             Preconditions.checkState(childCount \u003d\u003d 3);\n             boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n             if (funcNeedsParens) {\n                 add(\"(\");\n             }\n             add(\"function\");\n             add(first);\n             add(first.getNext());\n             add(last, Context.PRESERVE_BLOCK);\n             cc.endFunction(context \u003d\u003d Context.STATEMENT);\n             if (funcNeedsParens) {\n                 add(\")\");\n             }\n             break;\n         case Token.GETTER_DEF:\n         case Token.SETTER_DEF:\n             Preconditions.checkState(n.getParent().isObjectLit());\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             Preconditions.checkState(first.isFunction());\n             Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n             if (type \u003d\u003d Token.GETTER_DEF) {\n                 Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n                 add(\"get \");\n             } else {\n                 Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n                 add(\"set \");\n             }\n             String name \u003d n.getString();\n             Node fn \u003d first;\n             Node parameters \u003d fn.getChildAtIndex(1);\n             Node body \u003d fn.getLastChild();\n             if (!n.isQuotedString() \u0026\u0026 TokenStream.isJSIdentifier(name) \u0026\u0026 NodeUtil.isLatin(name)) {\n                 add(name);\n             } else {\n                 double d \u003d getSimpleNumber(name);\n                 if (!Double.isNaN(d)) {\n                     cc.addNumber(d);\n                 } else {\n                     addJsString(n.getString());\n                 }\n             }\n             add(parameters);\n             add(body, Context.PRESERVE_BLOCK);\n             break;\n         case Token.SCRIPT:\n         case Token.BLOCK:\n             {\n                 if (n.getClass() !\u003d Node.class) {\n                     throw new Error(\"Unexpected Node subclass.\");\n                 }\n                 boolean preserveBlock \u003d context \u003d\u003d Context.PRESERVE_BLOCK;\n                 if (preserveBlock) {\n                     cc.beginBlock();\n                 }\n                 boolean preferLineBreaks \u003d type \u003d\u003d Token.SCRIPT || (type \u003d\u003d Token.BLOCK \u0026\u0026 !preserveBlock \u0026\u0026 n.getParent() !\u003d null \u0026\u0026 n.getParent().isScript());\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     add(c, Context.STATEMENT);\n                     if (c.isVar()) {\n                         cc.endStatement();\n                     }\n                     if (c.isFunction()) {\n                         cc.maybeLineBreak();\n                     }\n                     if (preferLineBreaks) {\n                         cc.notePreferredLineBreak();\n                     }\n                 }\n                 if (preserveBlock) {\n                     cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                 }\n                 break;\n             }\n         case Token.FOR:\n             if (childCount \u003d\u003d 4) {\n                 add(\"for(\");\n                 if (first.isVar()) {\n                     add(first, Context.IN_FOR_INIT_CLAUSE);\n                 } else {\n                     addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                 }\n                 add(\";\");\n                 add(first.getNext());\n                 add(\";\");\n                 add(first.getNext().getNext());\n                 add(\")\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 add(\"for(\");\n                 add(first);\n                 add(\"in\");\n                 add(first.getNext());\n                 add(\")\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             }\n             break;\n         case Token.DO:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"do\");\n             addNonEmptyStatement(first, Context.OTHER, false);\n             add(\"while(\");\n             add(last);\n             add(\")\");\n             cc.endStatement();\n             break;\n         case Token.WHILE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"while(\");\n             add(first);\n             add(\")\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.EMPTY:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             break;\n         case Token.GETPROP:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                 Preconditions.checkState(last.isString(), \"Bad GETPROP: RHS should be STRING\");\n                 boolean needsParens \u003d (first.isNumber());\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 add(\".\");\n                 addIdentifier(last.getString());\n                 break;\n             }\n         case Token.GETELEM:\n             Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n             addLeftExpr(first, NodeUtil.precedence(type), context);\n             add(\"[\");\n             add(first.getNext());\n             add(\"]\");\n             break;\n         case Token.WITH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"with(\");\n             add(first);\n             add(\")\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.INC:\n         case Token.DEC:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                 int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                 if (postProp !\u003d 0) {\n                     addLeftExpr(first, NodeUtil.precedence(type), context);\n                     cc.addOp(o, false);\n                 } else {\n                     cc.addOp(o, false);\n                     add(first);\n                 }\n                 break;\n             }\n         case Token.CALL:\n             if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) \u0026\u0026 NodeUtil.isGet(first)) {\n                 add(\"(0,\");\n                 addExpr(first, NodeUtil.precedence(Token.COMMA));\n                 add(\")\");\n             } else {\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n             }\n             add(\"(\");\n             addList(first.getNext());\n             add(\")\");\n             break;\n         case Token.IF:\n             boolean hasElse \u003d childCount \u003d\u003d 3;\n             boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n             if (ambiguousElseClause) {\n                 cc.beginBlock();\n             }\n             add(\"if(\");\n             add(first);\n             add(\")\");\n             if (hasElse) {\n                 addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                 add(\"else\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n                 Preconditions.checkState(childCount \u003d\u003d 2);\n             }\n             if (ambiguousElseClause) {\n                 cc.endBlock();\n             }\n             break;\n         case Token.NULL:\n+            Preconditions.checkState(childCount \u003d\u003d 0);\n+            add(\"null\");\n+            break;\n         case Token.THIS:\n+            Preconditions.checkState(childCount \u003d\u003d 0);\n+            add(\"this\");\n+            break;\n         case Token.FALSE:\n+            Preconditions.checkState(childCount \u003d\u003d 0);\n+            add(\"false\");\n+            break;\n         case Token.TRUE:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n-            add(Node.tokenToName(type));\n+            add(\"true\");\n             break;\n         case Token.CONTINUE:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"continue\");\n             if (childCount \u003d\u003d 1) {\n                 if (!first.isLabelName()) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.DEBUGGER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(\"debugger\");\n             cc.endStatement();\n             break;\n         case Token.BREAK:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"break\");\n             if (childCount \u003d\u003d 1) {\n                 if (!first.isLabelName()) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.EXPR_RESULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first, Context.START_OF_EXPR);\n             cc.endStatement();\n             break;\n         case Token.NEW:\n             add(\"new \");\n             int precedence \u003d NodeUtil.precedence(type);\n             if (NodeUtil.containsType(first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n                 precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n             }\n             addExpr(first, precedence);\n             Node next \u003d first.getNext();\n             if (next !\u003d null) {\n                 add(\"(\");\n                 addList(next);\n                 add(\")\");\n             }\n             break;\n         case Token.STRING:\n             if (childCount !\u003d ((n.getParent() !\u003d null \u0026\u0026 n.getParent().isObjectLit()) ? 1 : 0)) {\n                 throw new IllegalStateException(\"Unexpected String children: \" + n.getParent().toStringTree());\n             }\n             addJsString(n.getString());\n             break;\n         case Token.DELPROP:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"delete \");\n             add(first);\n             break;\n         case Token.OBJECTLIT:\n             {\n                 boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 add(\"{\");\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     if (c !\u003d first) {\n                         cc.listSeparator();\n                     }\n                     if (c.isGetterDef() || c.isSetterDef()) {\n                         add(c);\n                     } else {\n                         Preconditions.checkState(c.isString());\n                         String key \u003d c.getString();\n                         if (!c.isQuotedString() \u0026\u0026 !TokenStream.isKeyword(key) \u0026\u0026 TokenStream.isJSIdentifier(key) \u0026\u0026 NodeUtil.isLatin(key)) {\n                             add(key);\n                         } else {\n                             double d \u003d getSimpleNumber(key);\n                             if (!Double.isNaN(d)) {\n                                 cc.addNumber(d);\n                             } else {\n                                 addExpr(c, 1);\n                             }\n                         }\n                         add(\":\");\n                         addExpr(c.getFirstChild(), 1);\n                     }\n                 }\n                 add(\"}\");\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 break;\n             }\n         case Token.SWITCH:\n             add(\"switch(\");\n             add(first);\n             add(\")\");\n             cc.beginBlock();\n             addAllSiblings(first.getNext());\n             cc.endBlock(context \u003d\u003d Context.STATEMENT);\n             break;\n         case Token.CASE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"case \");\n             add(first);\n             addCaseBody(last);\n             break;\n         case Token.DEFAULT_CASE:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"default\");\n             addCaseBody(first);\n             break;\n         case Token.LABEL:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             if (!first.isLabelName()) {\n                 throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n             }\n             add(first);\n             add(\":\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\n             break;\n         default:\n             throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n     }\n     cc.endSourceMapping(n);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "39f629a8cfaab37da55288010640d7e516000b1f": {
      "type": "Ybodychange",
      "commitMessage": "\nReplace calls of the form \"Node.getType() !\u003d Token.XX\" with\n\"!Node.isXX()\" calls.\n\nR\u003dnicksantos\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3706\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1598 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/14/11, 6:13 PM",
      "commitName": "39f629a8cfaab37da55288010640d7e516000b1f",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "11/11/11, 4:42 PM",
      "commitNameOld": "5524adbda991632656059566b69cc2771ba42b7d",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 3.06,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n        return;\n    }\n    int type \u003d n.getType();\n    String opstr \u003d NodeUtil.opToStr(type);\n    int childCount \u003d n.getChildCount();\n    Node first \u003d n.getFirstChild();\n    Node last \u003d n.getLastChild();\n    if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n        Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n        int p \u003d NodeUtil.precedence(type);\n        addLeftExpr(first, p, context);\n        cc.addOp(opstr, true);\n        Context rhsContext \u003d getContextForNoInOperator(context);\n        if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n            addExpr(last, p, rhsContext);\n        } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n            addExpr(last, p, rhsContext);\n        } else {\n            addExpr(last, p + 1, rhsContext);\n        }\n        return;\n    }\n    cc.startSourceMapping(n);\n    switch(type) {\n        case Token.TRY:\n            {\n                Preconditions.checkState(first.getNext().isBlock() \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n                Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                add(\"try\");\n                add(first, Context.PRESERVE_BLOCK);\n                Node catchblock \u003d first.getNext().getFirstChild();\n                if (catchblock !\u003d null) {\n                    add(catchblock);\n                }\n                if (childCount \u003d\u003d 3) {\n                    add(\"finally\");\n                    add(last, Context.PRESERVE_BLOCK);\n                }\n                break;\n            }\n        case Token.CATCH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"catch(\");\n            add(first);\n            add(\")\");\n            add(last, Context.PRESERVE_BLOCK);\n            break;\n        case Token.THROW:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"throw\");\n            add(first);\n            cc.endStatement(true);\n            break;\n        case Token.RETURN:\n            add(\"return\");\n            if (childCount \u003d\u003d 1) {\n                add(first);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 0);\n            }\n            cc.endStatement();\n            break;\n        case Token.VAR:\n            if (first !\u003d null) {\n                add(\"var \");\n                addList(first, false, getContextForNoInOperator(context));\n            }\n            break;\n        case Token.LABEL_NAME:\n            Preconditions.checkState(!n.getString().isEmpty());\n            addIdentifier(n.getString());\n            break;\n        case Token.NAME:\n            if (first \u003d\u003d null || first.isEmpty()) {\n                addIdentifier(n.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                addIdentifier(n.getString());\n                cc.addOp(\"\u003d\", true);\n                if (first.isComma()) {\n                    addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                } else {\n                    addExpr(first, 0, getContextForNoInOperator(context));\n                }\n            }\n            break;\n        case Token.ARRAYLIT:\n            add(\"[\");\n            addArrayList(first);\n            add(\"]\");\n            break;\n        case Token.PARAM_LIST:\n            add(\"(\");\n            addList(first);\n            add(\")\");\n            break;\n        case Token.COMMA:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            addList(first, false, context);\n            break;\n        case Token.NUMBER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            cc.addNumber(n.getDouble());\n            break;\n        case Token.TYPEOF:\n        case Token.VOID:\n        case Token.NOT:\n        case Token.BITNOT:\n        case Token.POS:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                addExpr(first, NodeUtil.precedence(type));\n                break;\n            }\n        case Token.NEG:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                if (n.getFirstChild().isNumber()) {\n                    cc.addNumber(-n.getFirstChild().getDouble());\n                } else {\n                    cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                    addExpr(first, NodeUtil.precedence(type));\n                }\n                break;\n            }\n        case Token.HOOK:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                int p \u003d NodeUtil.precedence(type);\n                addLeftExpr(first, p + 1, context);\n                cc.addOp(\"?\", true);\n                addExpr(first.getNext(), 1);\n                cc.addOp(\":\", true);\n                addExpr(last, 1);\n                break;\n            }\n        case Token.REGEXP:\n            if (!first.isString() || !last.isString()) {\n                throw new Error(\"Expected children to be strings\");\n            }\n            String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n            if (childCount \u003d\u003d 2) {\n                add(regexp + last.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                add(regexp);\n            }\n            break;\n        case Token.FUNCTION:\n            if (n.getClass() !\u003d Node.class) {\n                throw new Error(\"Unexpected Node subclass.\");\n            }\n            Preconditions.checkState(childCount \u003d\u003d 3);\n            boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n            if (funcNeedsParens) {\n                add(\"(\");\n            }\n            add(\"function\");\n            add(first);\n            add(first.getNext());\n            add(last, Context.PRESERVE_BLOCK);\n            cc.endFunction(context \u003d\u003d Context.STATEMENT);\n            if (funcNeedsParens) {\n                add(\")\");\n            }\n            break;\n        case Token.GETTER_DEF:\n        case Token.SETTER_DEF:\n            Preconditions.checkState(n.getParent().isObjectLit());\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            Preconditions.checkState(first.isFunction());\n            Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n            if (type \u003d\u003d Token.GETTER_DEF) {\n                Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n                add(\"get \");\n            } else {\n                Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n                add(\"set \");\n            }\n            String name \u003d n.getString();\n            Node fn \u003d first;\n            Node parameters \u003d fn.getChildAtIndex(1);\n            Node body \u003d fn.getLastChild();\n            if (!n.isQuotedString() \u0026\u0026 TokenStream.isJSIdentifier(name) \u0026\u0026 NodeUtil.isLatin(name)) {\n                add(name);\n            } else {\n                double d \u003d getSimpleNumber(name);\n                if (!Double.isNaN(d)) {\n                    cc.addNumber(d);\n                } else {\n                    addJsString(n.getString());\n                }\n            }\n            add(parameters);\n            add(body, Context.PRESERVE_BLOCK);\n            break;\n        case Token.SCRIPT:\n        case Token.BLOCK:\n            {\n                if (n.getClass() !\u003d Node.class) {\n                    throw new Error(\"Unexpected Node subclass.\");\n                }\n                boolean preserveBlock \u003d context \u003d\u003d Context.PRESERVE_BLOCK;\n                if (preserveBlock) {\n                    cc.beginBlock();\n                }\n                boolean preferLineBreaks \u003d type \u003d\u003d Token.SCRIPT || (type \u003d\u003d Token.BLOCK \u0026\u0026 !preserveBlock \u0026\u0026 n.getParent() !\u003d null \u0026\u0026 n.getParent().isScript());\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    add(c, Context.STATEMENT);\n                    if (c.isVar()) {\n                        cc.endStatement();\n                    }\n                    if (c.isFunction()) {\n                        cc.maybeLineBreak();\n                    }\n                    if (preferLineBreaks) {\n                        cc.notePreferredLineBreak();\n                    }\n                }\n                if (preserveBlock) {\n                    cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                }\n                break;\n            }\n        case Token.FOR:\n            if (childCount \u003d\u003d 4) {\n                add(\"for(\");\n                if (first.isVar()) {\n                    add(first, Context.IN_FOR_INIT_CLAUSE);\n                } else {\n                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                }\n                add(\";\");\n                add(first.getNext());\n                add(\";\");\n                add(first.getNext().getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                add(\"for(\");\n                add(first);\n                add(\"in\");\n                add(first.getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            }\n            break;\n        case Token.DO:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"do\");\n            addNonEmptyStatement(first, Context.OTHER, false);\n            add(\"while(\");\n            add(last);\n            add(\")\");\n            cc.endStatement();\n            break;\n        case Token.WHILE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"while(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.EMPTY:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            break;\n        case Token.GETPROP:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                Preconditions.checkState(last.isString(), \"Bad GETPROP: RHS should be STRING\");\n                boolean needsParens \u003d (first.isNumber());\n                if (needsParens) {\n                    add(\"(\");\n                }\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n                if (needsParens) {\n                    add(\")\");\n                }\n                add(\".\");\n                addIdentifier(last.getString());\n                break;\n            }\n        case Token.GETELEM:\n            Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n            addLeftExpr(first, NodeUtil.precedence(type), context);\n            add(\"[\");\n            add(first.getNext());\n            add(\"]\");\n            break;\n        case Token.WITH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"with(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.INC:\n        case Token.DEC:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                if (postProp !\u003d 0) {\n                    addLeftExpr(first, NodeUtil.precedence(type), context);\n                    cc.addOp(o, false);\n                } else {\n                    cc.addOp(o, false);\n                    add(first);\n                }\n                break;\n            }\n        case Token.CALL:\n            if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) \u0026\u0026 NodeUtil.isGet(first)) {\n                add(\"(0,\");\n                addExpr(first, NodeUtil.precedence(Token.COMMA));\n                add(\")\");\n            } else {\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n            }\n            add(\"(\");\n            addList(first.getNext());\n            add(\")\");\n            break;\n        case Token.IF:\n            boolean hasElse \u003d childCount \u003d\u003d 3;\n            boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n            if (ambiguousElseClause) {\n                cc.beginBlock();\n            }\n            add(\"if(\");\n            add(first);\n            add(\")\");\n            if (hasElse) {\n                addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                add(\"else\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n                Preconditions.checkState(childCount \u003d\u003d 2);\n            }\n            if (ambiguousElseClause) {\n                cc.endBlock();\n            }\n            break;\n        case Token.NULL:\n        case Token.THIS:\n        case Token.FALSE:\n        case Token.TRUE:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(Node.tokenToName(type));\n            break;\n        case Token.CONTINUE:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"continue\");\n            if (childCount \u003d\u003d 1) {\n                if (!first.isLabelName()) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.DEBUGGER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"debugger\");\n            cc.endStatement();\n            break;\n        case Token.BREAK:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"break\");\n            if (childCount \u003d\u003d 1) {\n                if (!first.isLabelName()) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.EXPR_RESULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first, Context.START_OF_EXPR);\n            cc.endStatement();\n            break;\n        case Token.NEW:\n            add(\"new \");\n            int precedence \u003d NodeUtil.precedence(type);\n            if (NodeUtil.containsType(first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n                precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n            }\n            addExpr(first, precedence);\n            Node next \u003d first.getNext();\n            if (next !\u003d null) {\n                add(\"(\");\n                addList(next);\n                add(\")\");\n            }\n            break;\n        case Token.STRING:\n            if (childCount !\u003d ((n.getParent() !\u003d null \u0026\u0026 n.getParent().isObjectLit()) ? 1 : 0)) {\n                throw new IllegalStateException(\"Unexpected String children: \" + n.getParent().toStringTree());\n            }\n            addJsString(n.getString());\n            break;\n        case Token.DELPROP:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"delete \");\n            add(first);\n            break;\n        case Token.OBJECTLIT:\n            {\n                boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                add(\"{\");\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    if (c !\u003d first) {\n                        cc.listSeparator();\n                    }\n                    if (c.isGetterDef() || c.isSetterDef()) {\n                        add(c);\n                    } else {\n                        Preconditions.checkState(c.isString());\n                        String key \u003d c.getString();\n                        if (!c.isQuotedString() \u0026\u0026 !TokenStream.isKeyword(key) \u0026\u0026 TokenStream.isJSIdentifier(key) \u0026\u0026 NodeUtil.isLatin(key)) {\n                            add(key);\n                        } else {\n                            double d \u003d getSimpleNumber(key);\n                            if (!Double.isNaN(d)) {\n                                cc.addNumber(d);\n                            } else {\n                                addExpr(c, 1);\n                            }\n                        }\n                        add(\":\");\n                        addExpr(c.getFirstChild(), 1);\n                    }\n                }\n                add(\"}\");\n                if (needsParens) {\n                    add(\")\");\n                }\n                break;\n            }\n        case Token.SWITCH:\n            add(\"switch(\");\n            add(first);\n            add(\")\");\n            cc.beginBlock();\n            addAllSiblings(first.getNext());\n            cc.endBlock(context \u003d\u003d Context.STATEMENT);\n            break;\n        case Token.CASE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"case \");\n            add(first);\n            addCaseBody(last);\n            break;\n        case Token.DEFAULT_CASE:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"default\");\n            addCaseBody(first);\n            break;\n        case Token.LABEL:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            if (!first.isLabelName()) {\n                throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n            }\n            add(first);\n            add(\":\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\n            break;\n        default:\n            throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n    cc.endSourceMapping(n);\n}",
      "path": "src/com/google/javascript/jscomp/CodeGenerator.java",
      "functionStartLine": 85,
      "functionName": "add",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,483 +1,483 @@\n void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n         return;\n     }\n     int type \u003d n.getType();\n     String opstr \u003d NodeUtil.opToStr(type);\n     int childCount \u003d n.getChildCount();\n     Node first \u003d n.getFirstChild();\n     Node last \u003d n.getLastChild();\n     if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n         Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n         int p \u003d NodeUtil.precedence(type);\n         addLeftExpr(first, p, context);\n         cc.addOp(opstr, true);\n         Context rhsContext \u003d getContextForNoInOperator(context);\n         if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n             addExpr(last, p, rhsContext);\n         } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n             addExpr(last, p, rhsContext);\n         } else {\n             addExpr(last, p + 1, rhsContext);\n         }\n         return;\n     }\n     cc.startSourceMapping(n);\n     switch(type) {\n         case Token.TRY:\n             {\n                 Preconditions.checkState(first.getNext().isBlock() \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n                 Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                 add(\"try\");\n                 add(first, Context.PRESERVE_BLOCK);\n                 Node catchblock \u003d first.getNext().getFirstChild();\n                 if (catchblock !\u003d null) {\n                     add(catchblock);\n                 }\n                 if (childCount \u003d\u003d 3) {\n                     add(\"finally\");\n                     add(last, Context.PRESERVE_BLOCK);\n                 }\n                 break;\n             }\n         case Token.CATCH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"catch(\");\n             add(first);\n             add(\")\");\n             add(last, Context.PRESERVE_BLOCK);\n             break;\n         case Token.THROW:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"throw\");\n             add(first);\n             cc.endStatement(true);\n             break;\n         case Token.RETURN:\n             add(\"return\");\n             if (childCount \u003d\u003d 1) {\n                 add(first);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 0);\n             }\n             cc.endStatement();\n             break;\n         case Token.VAR:\n             if (first !\u003d null) {\n                 add(\"var \");\n                 addList(first, false, getContextForNoInOperator(context));\n             }\n             break;\n         case Token.LABEL_NAME:\n             Preconditions.checkState(!n.getString().isEmpty());\n             addIdentifier(n.getString());\n             break;\n         case Token.NAME:\n             if (first \u003d\u003d null || first.isEmpty()) {\n                 addIdentifier(n.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 addIdentifier(n.getString());\n                 cc.addOp(\"\u003d\", true);\n                 if (first.isComma()) {\n                     addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                 } else {\n                     addExpr(first, 0, getContextForNoInOperator(context));\n                 }\n             }\n             break;\n         case Token.ARRAYLIT:\n             add(\"[\");\n             addArrayList(first);\n             add(\"]\");\n             break;\n         case Token.PARAM_LIST:\n             add(\"(\");\n             addList(first);\n             add(\")\");\n             break;\n         case Token.COMMA:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             addList(first, false, context);\n             break;\n         case Token.NUMBER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             cc.addNumber(n.getDouble());\n             break;\n         case Token.TYPEOF:\n         case Token.VOID:\n         case Token.NOT:\n         case Token.BITNOT:\n         case Token.POS:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                 addExpr(first, NodeUtil.precedence(type));\n                 break;\n             }\n         case Token.NEG:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 if (n.getFirstChild().isNumber()) {\n                     cc.addNumber(-n.getFirstChild().getDouble());\n                 } else {\n                     cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                     addExpr(first, NodeUtil.precedence(type));\n                 }\n                 break;\n             }\n         case Token.HOOK:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 int p \u003d NodeUtil.precedence(type);\n                 addLeftExpr(first, p + 1, context);\n                 cc.addOp(\"?\", true);\n                 addExpr(first.getNext(), 1);\n                 cc.addOp(\":\", true);\n                 addExpr(last, 1);\n                 break;\n             }\n         case Token.REGEXP:\n-            if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n+            if (!first.isString() || !last.isString()) {\n                 throw new Error(\"Expected children to be strings\");\n             }\n             String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n             if (childCount \u003d\u003d 2) {\n                 add(regexp + last.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 add(regexp);\n             }\n             break;\n         case Token.FUNCTION:\n             if (n.getClass() !\u003d Node.class) {\n                 throw new Error(\"Unexpected Node subclass.\");\n             }\n             Preconditions.checkState(childCount \u003d\u003d 3);\n             boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n             if (funcNeedsParens) {\n                 add(\"(\");\n             }\n             add(\"function\");\n             add(first);\n             add(first.getNext());\n             add(last, Context.PRESERVE_BLOCK);\n             cc.endFunction(context \u003d\u003d Context.STATEMENT);\n             if (funcNeedsParens) {\n                 add(\")\");\n             }\n             break;\n         case Token.GETTER_DEF:\n         case Token.SETTER_DEF:\n             Preconditions.checkState(n.getParent().isObjectLit());\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             Preconditions.checkState(first.isFunction());\n             Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n             if (type \u003d\u003d Token.GETTER_DEF) {\n                 Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n                 add(\"get \");\n             } else {\n                 Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n                 add(\"set \");\n             }\n             String name \u003d n.getString();\n             Node fn \u003d first;\n             Node parameters \u003d fn.getChildAtIndex(1);\n             Node body \u003d fn.getLastChild();\n             if (!n.isQuotedString() \u0026\u0026 TokenStream.isJSIdentifier(name) \u0026\u0026 NodeUtil.isLatin(name)) {\n                 add(name);\n             } else {\n                 double d \u003d getSimpleNumber(name);\n                 if (!Double.isNaN(d)) {\n                     cc.addNumber(d);\n                 } else {\n                     addJsString(n.getString());\n                 }\n             }\n             add(parameters);\n             add(body, Context.PRESERVE_BLOCK);\n             break;\n         case Token.SCRIPT:\n         case Token.BLOCK:\n             {\n                 if (n.getClass() !\u003d Node.class) {\n                     throw new Error(\"Unexpected Node subclass.\");\n                 }\n                 boolean preserveBlock \u003d context \u003d\u003d Context.PRESERVE_BLOCK;\n                 if (preserveBlock) {\n                     cc.beginBlock();\n                 }\n                 boolean preferLineBreaks \u003d type \u003d\u003d Token.SCRIPT || (type \u003d\u003d Token.BLOCK \u0026\u0026 !preserveBlock \u0026\u0026 n.getParent() !\u003d null \u0026\u0026 n.getParent().isScript());\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     add(c, Context.STATEMENT);\n                     if (c.isVar()) {\n                         cc.endStatement();\n                     }\n                     if (c.isFunction()) {\n                         cc.maybeLineBreak();\n                     }\n                     if (preferLineBreaks) {\n                         cc.notePreferredLineBreak();\n                     }\n                 }\n                 if (preserveBlock) {\n                     cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                 }\n                 break;\n             }\n         case Token.FOR:\n             if (childCount \u003d\u003d 4) {\n                 add(\"for(\");\n                 if (first.isVar()) {\n                     add(first, Context.IN_FOR_INIT_CLAUSE);\n                 } else {\n                     addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                 }\n                 add(\";\");\n                 add(first.getNext());\n                 add(\";\");\n                 add(first.getNext().getNext());\n                 add(\")\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 add(\"for(\");\n                 add(first);\n                 add(\"in\");\n                 add(first.getNext());\n                 add(\")\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             }\n             break;\n         case Token.DO:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"do\");\n             addNonEmptyStatement(first, Context.OTHER, false);\n             add(\"while(\");\n             add(last);\n             add(\")\");\n             cc.endStatement();\n             break;\n         case Token.WHILE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"while(\");\n             add(first);\n             add(\")\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.EMPTY:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             break;\n         case Token.GETPROP:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                 Preconditions.checkState(last.isString(), \"Bad GETPROP: RHS should be STRING\");\n                 boolean needsParens \u003d (first.isNumber());\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 add(\".\");\n                 addIdentifier(last.getString());\n                 break;\n             }\n         case Token.GETELEM:\n             Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n             addLeftExpr(first, NodeUtil.precedence(type), context);\n             add(\"[\");\n             add(first.getNext());\n             add(\"]\");\n             break;\n         case Token.WITH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"with(\");\n             add(first);\n             add(\")\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.INC:\n         case Token.DEC:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                 int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                 if (postProp !\u003d 0) {\n                     addLeftExpr(first, NodeUtil.precedence(type), context);\n                     cc.addOp(o, false);\n                 } else {\n                     cc.addOp(o, false);\n                     add(first);\n                 }\n                 break;\n             }\n         case Token.CALL:\n             if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) \u0026\u0026 NodeUtil.isGet(first)) {\n                 add(\"(0,\");\n                 addExpr(first, NodeUtil.precedence(Token.COMMA));\n                 add(\")\");\n             } else {\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n             }\n             add(\"(\");\n             addList(first.getNext());\n             add(\")\");\n             break;\n         case Token.IF:\n             boolean hasElse \u003d childCount \u003d\u003d 3;\n             boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n             if (ambiguousElseClause) {\n                 cc.beginBlock();\n             }\n             add(\"if(\");\n             add(first);\n             add(\")\");\n             if (hasElse) {\n                 addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                 add(\"else\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n                 Preconditions.checkState(childCount \u003d\u003d 2);\n             }\n             if (ambiguousElseClause) {\n                 cc.endBlock();\n             }\n             break;\n         case Token.NULL:\n         case Token.THIS:\n         case Token.FALSE:\n         case Token.TRUE:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(Node.tokenToName(type));\n             break;\n         case Token.CONTINUE:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"continue\");\n             if (childCount \u003d\u003d 1) {\n-                if (first.getType() !\u003d Token.LABEL_NAME) {\n+                if (!first.isLabelName()) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.DEBUGGER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(\"debugger\");\n             cc.endStatement();\n             break;\n         case Token.BREAK:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"break\");\n             if (childCount \u003d\u003d 1) {\n-                if (first.getType() !\u003d Token.LABEL_NAME) {\n+                if (!first.isLabelName()) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.EXPR_RESULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first, Context.START_OF_EXPR);\n             cc.endStatement();\n             break;\n         case Token.NEW:\n             add(\"new \");\n             int precedence \u003d NodeUtil.precedence(type);\n             if (NodeUtil.containsType(first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n                 precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n             }\n             addExpr(first, precedence);\n             Node next \u003d first.getNext();\n             if (next !\u003d null) {\n                 add(\"(\");\n                 addList(next);\n                 add(\")\");\n             }\n             break;\n         case Token.STRING:\n             if (childCount !\u003d ((n.getParent() !\u003d null \u0026\u0026 n.getParent().isObjectLit()) ? 1 : 0)) {\n                 throw new IllegalStateException(\"Unexpected String children: \" + n.getParent().toStringTree());\n             }\n             addJsString(n.getString());\n             break;\n         case Token.DELPROP:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"delete \");\n             add(first);\n             break;\n         case Token.OBJECTLIT:\n             {\n                 boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 add(\"{\");\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     if (c !\u003d first) {\n                         cc.listSeparator();\n                     }\n                     if (c.isGetterDef() || c.isSetterDef()) {\n                         add(c);\n                     } else {\n                         Preconditions.checkState(c.isString());\n                         String key \u003d c.getString();\n                         if (!c.isQuotedString() \u0026\u0026 !TokenStream.isKeyword(key) \u0026\u0026 TokenStream.isJSIdentifier(key) \u0026\u0026 NodeUtil.isLatin(key)) {\n                             add(key);\n                         } else {\n                             double d \u003d getSimpleNumber(key);\n                             if (!Double.isNaN(d)) {\n                                 cc.addNumber(d);\n                             } else {\n                                 addExpr(c, 1);\n                             }\n                         }\n                         add(\":\");\n                         addExpr(c.getFirstChild(), 1);\n                     }\n                 }\n                 add(\"}\");\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 break;\n             }\n         case Token.SWITCH:\n             add(\"switch(\");\n             add(first);\n             add(\")\");\n             cc.beginBlock();\n             addAllSiblings(first.getNext());\n             cc.endBlock(context \u003d\u003d Context.STATEMENT);\n             break;\n         case Token.CASE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"case \");\n             add(first);\n             addCaseBody(last);\n             break;\n         case Token.DEFAULT_CASE:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"default\");\n             addCaseBody(first);\n             break;\n         case Token.LABEL:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n-            if (first.getType() !\u003d Token.LABEL_NAME) {\n+            if (!first.isLabelName()) {\n                 throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n             }\n             add(first);\n             add(\":\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\n             break;\n         default:\n             throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n     }\n     cc.endSourceMapping(n);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5524adbda991632656059566b69cc2771ba42b7d": {
      "type": "Ybodychange",
      "commitMessage": "\nRename a couple of AST nodes:\nDEFAULT becomes DEFAULT_CASE\nLP becomes PARAM_LIST\nGET becomes GETTER_DEF\nSET becomes SETTER_DEF\n\nR\u003dnicksantos\nDELTA\u003d215  (40 added, 5 deleted, 170 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3695\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1590 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/11/11, 4:42 PM",
      "commitName": "5524adbda991632656059566b69cc2771ba42b7d",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "11/10/11, 8:36 AM",
      "commitNameOld": "ec324a9bb23eb78c76f537f4c4170ba88d542f1c",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 1.34,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n        return;\n    }\n    int type \u003d n.getType();\n    String opstr \u003d NodeUtil.opToStr(type);\n    int childCount \u003d n.getChildCount();\n    Node first \u003d n.getFirstChild();\n    Node last \u003d n.getLastChild();\n    if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n        Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n        int p \u003d NodeUtil.precedence(type);\n        addLeftExpr(first, p, context);\n        cc.addOp(opstr, true);\n        Context rhsContext \u003d getContextForNoInOperator(context);\n        if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n            addExpr(last, p, rhsContext);\n        } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n            addExpr(last, p, rhsContext);\n        } else {\n            addExpr(last, p + 1, rhsContext);\n        }\n        return;\n    }\n    cc.startSourceMapping(n);\n    switch(type) {\n        case Token.TRY:\n            {\n                Preconditions.checkState(first.getNext().isBlock() \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n                Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                add(\"try\");\n                add(first, Context.PRESERVE_BLOCK);\n                Node catchblock \u003d first.getNext().getFirstChild();\n                if (catchblock !\u003d null) {\n                    add(catchblock);\n                }\n                if (childCount \u003d\u003d 3) {\n                    add(\"finally\");\n                    add(last, Context.PRESERVE_BLOCK);\n                }\n                break;\n            }\n        case Token.CATCH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"catch(\");\n            add(first);\n            add(\")\");\n            add(last, Context.PRESERVE_BLOCK);\n            break;\n        case Token.THROW:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"throw\");\n            add(first);\n            cc.endStatement(true);\n            break;\n        case Token.RETURN:\n            add(\"return\");\n            if (childCount \u003d\u003d 1) {\n                add(first);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 0);\n            }\n            cc.endStatement();\n            break;\n        case Token.VAR:\n            if (first !\u003d null) {\n                add(\"var \");\n                addList(first, false, getContextForNoInOperator(context));\n            }\n            break;\n        case Token.LABEL_NAME:\n            Preconditions.checkState(!n.getString().isEmpty());\n            addIdentifier(n.getString());\n            break;\n        case Token.NAME:\n            if (first \u003d\u003d null || first.isEmpty()) {\n                addIdentifier(n.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                addIdentifier(n.getString());\n                cc.addOp(\"\u003d\", true);\n                if (first.isComma()) {\n                    addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                } else {\n                    addExpr(first, 0, getContextForNoInOperator(context));\n                }\n            }\n            break;\n        case Token.ARRAYLIT:\n            add(\"[\");\n            addArrayList(first);\n            add(\"]\");\n            break;\n        case Token.PARAM_LIST:\n            add(\"(\");\n            addList(first);\n            add(\")\");\n            break;\n        case Token.COMMA:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            addList(first, false, context);\n            break;\n        case Token.NUMBER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            cc.addNumber(n.getDouble());\n            break;\n        case Token.TYPEOF:\n        case Token.VOID:\n        case Token.NOT:\n        case Token.BITNOT:\n        case Token.POS:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                addExpr(first, NodeUtil.precedence(type));\n                break;\n            }\n        case Token.NEG:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                if (n.getFirstChild().isNumber()) {\n                    cc.addNumber(-n.getFirstChild().getDouble());\n                } else {\n                    cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                    addExpr(first, NodeUtil.precedence(type));\n                }\n                break;\n            }\n        case Token.HOOK:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                int p \u003d NodeUtil.precedence(type);\n                addLeftExpr(first, p + 1, context);\n                cc.addOp(\"?\", true);\n                addExpr(first.getNext(), 1);\n                cc.addOp(\":\", true);\n                addExpr(last, 1);\n                break;\n            }\n        case Token.REGEXP:\n            if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                throw new Error(\"Expected children to be strings\");\n            }\n            String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n            if (childCount \u003d\u003d 2) {\n                add(regexp + last.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                add(regexp);\n            }\n            break;\n        case Token.FUNCTION:\n            if (n.getClass() !\u003d Node.class) {\n                throw new Error(\"Unexpected Node subclass.\");\n            }\n            Preconditions.checkState(childCount \u003d\u003d 3);\n            boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n            if (funcNeedsParens) {\n                add(\"(\");\n            }\n            add(\"function\");\n            add(first);\n            add(first.getNext());\n            add(last, Context.PRESERVE_BLOCK);\n            cc.endFunction(context \u003d\u003d Context.STATEMENT);\n            if (funcNeedsParens) {\n                add(\")\");\n            }\n            break;\n        case Token.GETTER_DEF:\n        case Token.SETTER_DEF:\n            Preconditions.checkState(n.getParent().isObjectLit());\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            Preconditions.checkState(first.isFunction());\n            Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n            if (type \u003d\u003d Token.GETTER_DEF) {\n                Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n                add(\"get \");\n            } else {\n                Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n                add(\"set \");\n            }\n            String name \u003d n.getString();\n            Node fn \u003d first;\n            Node parameters \u003d fn.getChildAtIndex(1);\n            Node body \u003d fn.getLastChild();\n            if (!n.isQuotedString() \u0026\u0026 TokenStream.isJSIdentifier(name) \u0026\u0026 NodeUtil.isLatin(name)) {\n                add(name);\n            } else {\n                double d \u003d getSimpleNumber(name);\n                if (!Double.isNaN(d)) {\n                    cc.addNumber(d);\n                } else {\n                    addJsString(n.getString());\n                }\n            }\n            add(parameters);\n            add(body, Context.PRESERVE_BLOCK);\n            break;\n        case Token.SCRIPT:\n        case Token.BLOCK:\n            {\n                if (n.getClass() !\u003d Node.class) {\n                    throw new Error(\"Unexpected Node subclass.\");\n                }\n                boolean preserveBlock \u003d context \u003d\u003d Context.PRESERVE_BLOCK;\n                if (preserveBlock) {\n                    cc.beginBlock();\n                }\n                boolean preferLineBreaks \u003d type \u003d\u003d Token.SCRIPT || (type \u003d\u003d Token.BLOCK \u0026\u0026 !preserveBlock \u0026\u0026 n.getParent() !\u003d null \u0026\u0026 n.getParent().isScript());\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    add(c, Context.STATEMENT);\n                    if (c.isVar()) {\n                        cc.endStatement();\n                    }\n                    if (c.isFunction()) {\n                        cc.maybeLineBreak();\n                    }\n                    if (preferLineBreaks) {\n                        cc.notePreferredLineBreak();\n                    }\n                }\n                if (preserveBlock) {\n                    cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                }\n                break;\n            }\n        case Token.FOR:\n            if (childCount \u003d\u003d 4) {\n                add(\"for(\");\n                if (first.isVar()) {\n                    add(first, Context.IN_FOR_INIT_CLAUSE);\n                } else {\n                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                }\n                add(\";\");\n                add(first.getNext());\n                add(\";\");\n                add(first.getNext().getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                add(\"for(\");\n                add(first);\n                add(\"in\");\n                add(first.getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            }\n            break;\n        case Token.DO:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"do\");\n            addNonEmptyStatement(first, Context.OTHER, false);\n            add(\"while(\");\n            add(last);\n            add(\")\");\n            cc.endStatement();\n            break;\n        case Token.WHILE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"while(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.EMPTY:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            break;\n        case Token.GETPROP:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                Preconditions.checkState(last.isString(), \"Bad GETPROP: RHS should be STRING\");\n                boolean needsParens \u003d (first.isNumber());\n                if (needsParens) {\n                    add(\"(\");\n                }\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n                if (needsParens) {\n                    add(\")\");\n                }\n                add(\".\");\n                addIdentifier(last.getString());\n                break;\n            }\n        case Token.GETELEM:\n            Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n            addLeftExpr(first, NodeUtil.precedence(type), context);\n            add(\"[\");\n            add(first.getNext());\n            add(\"]\");\n            break;\n        case Token.WITH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"with(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.INC:\n        case Token.DEC:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                if (postProp !\u003d 0) {\n                    addLeftExpr(first, NodeUtil.precedence(type), context);\n                    cc.addOp(o, false);\n                } else {\n                    cc.addOp(o, false);\n                    add(first);\n                }\n                break;\n            }\n        case Token.CALL:\n            if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) \u0026\u0026 NodeUtil.isGet(first)) {\n                add(\"(0,\");\n                addExpr(first, NodeUtil.precedence(Token.COMMA));\n                add(\")\");\n            } else {\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n            }\n            add(\"(\");\n            addList(first.getNext());\n            add(\")\");\n            break;\n        case Token.IF:\n            boolean hasElse \u003d childCount \u003d\u003d 3;\n            boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n            if (ambiguousElseClause) {\n                cc.beginBlock();\n            }\n            add(\"if(\");\n            add(first);\n            add(\")\");\n            if (hasElse) {\n                addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                add(\"else\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n                Preconditions.checkState(childCount \u003d\u003d 2);\n            }\n            if (ambiguousElseClause) {\n                cc.endBlock();\n            }\n            break;\n        case Token.NULL:\n        case Token.THIS:\n        case Token.FALSE:\n        case Token.TRUE:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(Node.tokenToName(type));\n            break;\n        case Token.CONTINUE:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"continue\");\n            if (childCount \u003d\u003d 1) {\n                if (first.getType() !\u003d Token.LABEL_NAME) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.DEBUGGER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"debugger\");\n            cc.endStatement();\n            break;\n        case Token.BREAK:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"break\");\n            if (childCount \u003d\u003d 1) {\n                if (first.getType() !\u003d Token.LABEL_NAME) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.EXPR_RESULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first, Context.START_OF_EXPR);\n            cc.endStatement();\n            break;\n        case Token.NEW:\n            add(\"new \");\n            int precedence \u003d NodeUtil.precedence(type);\n            if (NodeUtil.containsType(first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n                precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n            }\n            addExpr(first, precedence);\n            Node next \u003d first.getNext();\n            if (next !\u003d null) {\n                add(\"(\");\n                addList(next);\n                add(\")\");\n            }\n            break;\n        case Token.STRING:\n            if (childCount !\u003d ((n.getParent() !\u003d null \u0026\u0026 n.getParent().isObjectLit()) ? 1 : 0)) {\n                throw new IllegalStateException(\"Unexpected String children: \" + n.getParent().toStringTree());\n            }\n            addJsString(n.getString());\n            break;\n        case Token.DELPROP:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"delete \");\n            add(first);\n            break;\n        case Token.OBJECTLIT:\n            {\n                boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                add(\"{\");\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    if (c !\u003d first) {\n                        cc.listSeparator();\n                    }\n                    if (c.isGetterDef() || c.isSetterDef()) {\n                        add(c);\n                    } else {\n                        Preconditions.checkState(c.isString());\n                        String key \u003d c.getString();\n                        if (!c.isQuotedString() \u0026\u0026 !TokenStream.isKeyword(key) \u0026\u0026 TokenStream.isJSIdentifier(key) \u0026\u0026 NodeUtil.isLatin(key)) {\n                            add(key);\n                        } else {\n                            double d \u003d getSimpleNumber(key);\n                            if (!Double.isNaN(d)) {\n                                cc.addNumber(d);\n                            } else {\n                                addExpr(c, 1);\n                            }\n                        }\n                        add(\":\");\n                        addExpr(c.getFirstChild(), 1);\n                    }\n                }\n                add(\"}\");\n                if (needsParens) {\n                    add(\")\");\n                }\n                break;\n            }\n        case Token.SWITCH:\n            add(\"switch(\");\n            add(first);\n            add(\")\");\n            cc.beginBlock();\n            addAllSiblings(first.getNext());\n            cc.endBlock(context \u003d\u003d Context.STATEMENT);\n            break;\n        case Token.CASE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"case \");\n            add(first);\n            addCaseBody(last);\n            break;\n        case Token.DEFAULT_CASE:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"default\");\n            addCaseBody(first);\n            break;\n        case Token.LABEL:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            if (first.getType() !\u003d Token.LABEL_NAME) {\n                throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n            }\n            add(first);\n            add(\":\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\n            break;\n        default:\n            throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n    cc.endSourceMapping(n);\n}",
      "path": "src/com/google/javascript/jscomp/CodeGenerator.java",
      "functionStartLine": 85,
      "functionName": "add",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,483 +1,483 @@\n void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n         return;\n     }\n     int type \u003d n.getType();\n     String opstr \u003d NodeUtil.opToStr(type);\n     int childCount \u003d n.getChildCount();\n     Node first \u003d n.getFirstChild();\n     Node last \u003d n.getLastChild();\n     if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n         Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n         int p \u003d NodeUtil.precedence(type);\n         addLeftExpr(first, p, context);\n         cc.addOp(opstr, true);\n         Context rhsContext \u003d getContextForNoInOperator(context);\n         if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n             addExpr(last, p, rhsContext);\n         } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n             addExpr(last, p, rhsContext);\n         } else {\n             addExpr(last, p + 1, rhsContext);\n         }\n         return;\n     }\n     cc.startSourceMapping(n);\n     switch(type) {\n         case Token.TRY:\n             {\n                 Preconditions.checkState(first.getNext().isBlock() \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n                 Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                 add(\"try\");\n                 add(first, Context.PRESERVE_BLOCK);\n                 Node catchblock \u003d first.getNext().getFirstChild();\n                 if (catchblock !\u003d null) {\n                     add(catchblock);\n                 }\n                 if (childCount \u003d\u003d 3) {\n                     add(\"finally\");\n                     add(last, Context.PRESERVE_BLOCK);\n                 }\n                 break;\n             }\n         case Token.CATCH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"catch(\");\n             add(first);\n             add(\")\");\n             add(last, Context.PRESERVE_BLOCK);\n             break;\n         case Token.THROW:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"throw\");\n             add(first);\n             cc.endStatement(true);\n             break;\n         case Token.RETURN:\n             add(\"return\");\n             if (childCount \u003d\u003d 1) {\n                 add(first);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 0);\n             }\n             cc.endStatement();\n             break;\n         case Token.VAR:\n             if (first !\u003d null) {\n                 add(\"var \");\n                 addList(first, false, getContextForNoInOperator(context));\n             }\n             break;\n         case Token.LABEL_NAME:\n             Preconditions.checkState(!n.getString().isEmpty());\n             addIdentifier(n.getString());\n             break;\n         case Token.NAME:\n             if (first \u003d\u003d null || first.isEmpty()) {\n                 addIdentifier(n.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 addIdentifier(n.getString());\n                 cc.addOp(\"\u003d\", true);\n                 if (first.isComma()) {\n                     addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                 } else {\n                     addExpr(first, 0, getContextForNoInOperator(context));\n                 }\n             }\n             break;\n         case Token.ARRAYLIT:\n             add(\"[\");\n             addArrayList(first);\n             add(\"]\");\n             break;\n-        case Token.LP:\n+        case Token.PARAM_LIST:\n             add(\"(\");\n             addList(first);\n             add(\")\");\n             break;\n         case Token.COMMA:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             addList(first, false, context);\n             break;\n         case Token.NUMBER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             cc.addNumber(n.getDouble());\n             break;\n         case Token.TYPEOF:\n         case Token.VOID:\n         case Token.NOT:\n         case Token.BITNOT:\n         case Token.POS:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                 addExpr(first, NodeUtil.precedence(type));\n                 break;\n             }\n         case Token.NEG:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 if (n.getFirstChild().isNumber()) {\n                     cc.addNumber(-n.getFirstChild().getDouble());\n                 } else {\n                     cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                     addExpr(first, NodeUtil.precedence(type));\n                 }\n                 break;\n             }\n         case Token.HOOK:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 int p \u003d NodeUtil.precedence(type);\n                 addLeftExpr(first, p + 1, context);\n                 cc.addOp(\"?\", true);\n                 addExpr(first.getNext(), 1);\n                 cc.addOp(\":\", true);\n                 addExpr(last, 1);\n                 break;\n             }\n         case Token.REGEXP:\n             if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                 throw new Error(\"Expected children to be strings\");\n             }\n             String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n             if (childCount \u003d\u003d 2) {\n                 add(regexp + last.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 add(regexp);\n             }\n             break;\n         case Token.FUNCTION:\n             if (n.getClass() !\u003d Node.class) {\n                 throw new Error(\"Unexpected Node subclass.\");\n             }\n             Preconditions.checkState(childCount \u003d\u003d 3);\n             boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n             if (funcNeedsParens) {\n                 add(\"(\");\n             }\n             add(\"function\");\n             add(first);\n             add(first.getNext());\n             add(last, Context.PRESERVE_BLOCK);\n             cc.endFunction(context \u003d\u003d Context.STATEMENT);\n             if (funcNeedsParens) {\n                 add(\")\");\n             }\n             break;\n-        case Token.GET:\n-        case Token.SET:\n+        case Token.GETTER_DEF:\n+        case Token.SETTER_DEF:\n             Preconditions.checkState(n.getParent().isObjectLit());\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             Preconditions.checkState(first.isFunction());\n             Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n-            if (type \u003d\u003d Token.GET) {\n+            if (type \u003d\u003d Token.GETTER_DEF) {\n                 Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n                 add(\"get \");\n             } else {\n                 Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n                 add(\"set \");\n             }\n             String name \u003d n.getString();\n             Node fn \u003d first;\n             Node parameters \u003d fn.getChildAtIndex(1);\n             Node body \u003d fn.getLastChild();\n             if (!n.isQuotedString() \u0026\u0026 TokenStream.isJSIdentifier(name) \u0026\u0026 NodeUtil.isLatin(name)) {\n                 add(name);\n             } else {\n                 double d \u003d getSimpleNumber(name);\n                 if (!Double.isNaN(d)) {\n                     cc.addNumber(d);\n                 } else {\n                     addJsString(n.getString());\n                 }\n             }\n             add(parameters);\n             add(body, Context.PRESERVE_BLOCK);\n             break;\n         case Token.SCRIPT:\n         case Token.BLOCK:\n             {\n                 if (n.getClass() !\u003d Node.class) {\n                     throw new Error(\"Unexpected Node subclass.\");\n                 }\n                 boolean preserveBlock \u003d context \u003d\u003d Context.PRESERVE_BLOCK;\n                 if (preserveBlock) {\n                     cc.beginBlock();\n                 }\n                 boolean preferLineBreaks \u003d type \u003d\u003d Token.SCRIPT || (type \u003d\u003d Token.BLOCK \u0026\u0026 !preserveBlock \u0026\u0026 n.getParent() !\u003d null \u0026\u0026 n.getParent().isScript());\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     add(c, Context.STATEMENT);\n                     if (c.isVar()) {\n                         cc.endStatement();\n                     }\n                     if (c.isFunction()) {\n                         cc.maybeLineBreak();\n                     }\n                     if (preferLineBreaks) {\n                         cc.notePreferredLineBreak();\n                     }\n                 }\n                 if (preserveBlock) {\n                     cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                 }\n                 break;\n             }\n         case Token.FOR:\n             if (childCount \u003d\u003d 4) {\n                 add(\"for(\");\n                 if (first.isVar()) {\n                     add(first, Context.IN_FOR_INIT_CLAUSE);\n                 } else {\n                     addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                 }\n                 add(\";\");\n                 add(first.getNext());\n                 add(\";\");\n                 add(first.getNext().getNext());\n                 add(\")\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 add(\"for(\");\n                 add(first);\n                 add(\"in\");\n                 add(first.getNext());\n                 add(\")\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             }\n             break;\n         case Token.DO:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"do\");\n             addNonEmptyStatement(first, Context.OTHER, false);\n             add(\"while(\");\n             add(last);\n             add(\")\");\n             cc.endStatement();\n             break;\n         case Token.WHILE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"while(\");\n             add(first);\n             add(\")\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.EMPTY:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             break;\n         case Token.GETPROP:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                 Preconditions.checkState(last.isString(), \"Bad GETPROP: RHS should be STRING\");\n                 boolean needsParens \u003d (first.isNumber());\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 add(\".\");\n                 addIdentifier(last.getString());\n                 break;\n             }\n         case Token.GETELEM:\n             Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n             addLeftExpr(first, NodeUtil.precedence(type), context);\n             add(\"[\");\n             add(first.getNext());\n             add(\"]\");\n             break;\n         case Token.WITH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"with(\");\n             add(first);\n             add(\")\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.INC:\n         case Token.DEC:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                 int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                 if (postProp !\u003d 0) {\n                     addLeftExpr(first, NodeUtil.precedence(type), context);\n                     cc.addOp(o, false);\n                 } else {\n                     cc.addOp(o, false);\n                     add(first);\n                 }\n                 break;\n             }\n         case Token.CALL:\n             if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) \u0026\u0026 NodeUtil.isGet(first)) {\n                 add(\"(0,\");\n                 addExpr(first, NodeUtil.precedence(Token.COMMA));\n                 add(\")\");\n             } else {\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n             }\n             add(\"(\");\n             addList(first.getNext());\n             add(\")\");\n             break;\n         case Token.IF:\n             boolean hasElse \u003d childCount \u003d\u003d 3;\n             boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n             if (ambiguousElseClause) {\n                 cc.beginBlock();\n             }\n             add(\"if(\");\n             add(first);\n             add(\")\");\n             if (hasElse) {\n                 addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                 add(\"else\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n                 Preconditions.checkState(childCount \u003d\u003d 2);\n             }\n             if (ambiguousElseClause) {\n                 cc.endBlock();\n             }\n             break;\n         case Token.NULL:\n         case Token.THIS:\n         case Token.FALSE:\n         case Token.TRUE:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(Node.tokenToName(type));\n             break;\n         case Token.CONTINUE:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"continue\");\n             if (childCount \u003d\u003d 1) {\n                 if (first.getType() !\u003d Token.LABEL_NAME) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.DEBUGGER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(\"debugger\");\n             cc.endStatement();\n             break;\n         case Token.BREAK:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"break\");\n             if (childCount \u003d\u003d 1) {\n                 if (first.getType() !\u003d Token.LABEL_NAME) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.EXPR_RESULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first, Context.START_OF_EXPR);\n             cc.endStatement();\n             break;\n         case Token.NEW:\n             add(\"new \");\n             int precedence \u003d NodeUtil.precedence(type);\n             if (NodeUtil.containsType(first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n                 precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n             }\n             addExpr(first, precedence);\n             Node next \u003d first.getNext();\n             if (next !\u003d null) {\n                 add(\"(\");\n                 addList(next);\n                 add(\")\");\n             }\n             break;\n         case Token.STRING:\n             if (childCount !\u003d ((n.getParent() !\u003d null \u0026\u0026 n.getParent().isObjectLit()) ? 1 : 0)) {\n                 throw new IllegalStateException(\"Unexpected String children: \" + n.getParent().toStringTree());\n             }\n             addJsString(n.getString());\n             break;\n         case Token.DELPROP:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"delete \");\n             add(first);\n             break;\n         case Token.OBJECTLIT:\n             {\n                 boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 add(\"{\");\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     if (c !\u003d first) {\n                         cc.listSeparator();\n                     }\n-                    if (c.isGet() || c.isSet()) {\n+                    if (c.isGetterDef() || c.isSetterDef()) {\n                         add(c);\n                     } else {\n                         Preconditions.checkState(c.isString());\n                         String key \u003d c.getString();\n                         if (!c.isQuotedString() \u0026\u0026 !TokenStream.isKeyword(key) \u0026\u0026 TokenStream.isJSIdentifier(key) \u0026\u0026 NodeUtil.isLatin(key)) {\n                             add(key);\n                         } else {\n                             double d \u003d getSimpleNumber(key);\n                             if (!Double.isNaN(d)) {\n                                 cc.addNumber(d);\n                             } else {\n                                 addExpr(c, 1);\n                             }\n                         }\n                         add(\":\");\n                         addExpr(c.getFirstChild(), 1);\n                     }\n                 }\n                 add(\"}\");\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 break;\n             }\n         case Token.SWITCH:\n             add(\"switch(\");\n             add(first);\n             add(\")\");\n             cc.beginBlock();\n             addAllSiblings(first.getNext());\n             cc.endBlock(context \u003d\u003d Context.STATEMENT);\n             break;\n         case Token.CASE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"case \");\n             add(first);\n             addCaseBody(last);\n             break;\n-        case Token.DEFAULT:\n+        case Token.DEFAULT_CASE:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"default\");\n             addCaseBody(first);\n             break;\n         case Token.LABEL:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             if (first.getType() !\u003d Token.LABEL_NAME) {\n                 throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n             }\n             add(first);\n             add(\":\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\n             break;\n         default:\n             throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n     }\n     cc.endSourceMapping(n);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ec324a9bb23eb78c76f537f4c4170ba88d542f1c": {
      "type": "Ybodychange",
      "commitMessage": "\nReplace the bulk of the Node.getType() \u003d\u003d Token.XXX calls with\nNode.isXXX calls.\n\nR\u003dnicksantos\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3677\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1582 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/10/11, 8:36 AM",
      "commitName": "ec324a9bb23eb78c76f537f4c4170ba88d542f1c",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "11/7/11, 2:21 PM",
      "commitNameOld": "6641663fa9970c4d7bcdd96a6f31b83b18c3ee3d",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 2.76,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "actualSource": "void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n        return;\n    }\n    int type \u003d n.getType();\n    String opstr \u003d NodeUtil.opToStr(type);\n    int childCount \u003d n.getChildCount();\n    Node first \u003d n.getFirstChild();\n    Node last \u003d n.getLastChild();\n    if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n        Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n        int p \u003d NodeUtil.precedence(type);\n        addLeftExpr(first, p, context);\n        cc.addOp(opstr, true);\n        Context rhsContext \u003d getContextForNoInOperator(context);\n        if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n            addExpr(last, p, rhsContext);\n        } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n            addExpr(last, p, rhsContext);\n        } else {\n            addExpr(last, p + 1, rhsContext);\n        }\n        return;\n    }\n    cc.startSourceMapping(n);\n    switch(type) {\n        case Token.TRY:\n            {\n                Preconditions.checkState(first.getNext().isBlock() \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n                Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                add(\"try\");\n                add(first, Context.PRESERVE_BLOCK);\n                Node catchblock \u003d first.getNext().getFirstChild();\n                if (catchblock !\u003d null) {\n                    add(catchblock);\n                }\n                if (childCount \u003d\u003d 3) {\n                    add(\"finally\");\n                    add(last, Context.PRESERVE_BLOCK);\n                }\n                break;\n            }\n        case Token.CATCH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"catch(\");\n            add(first);\n            add(\")\");\n            add(last, Context.PRESERVE_BLOCK);\n            break;\n        case Token.THROW:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"throw\");\n            add(first);\n            cc.endStatement(true);\n            break;\n        case Token.RETURN:\n            add(\"return\");\n            if (childCount \u003d\u003d 1) {\n                add(first);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 0);\n            }\n            cc.endStatement();\n            break;\n        case Token.VAR:\n            if (first !\u003d null) {\n                add(\"var \");\n                addList(first, false, getContextForNoInOperator(context));\n            }\n            break;\n        case Token.LABEL_NAME:\n            Preconditions.checkState(!n.getString().isEmpty());\n            addIdentifier(n.getString());\n            break;\n        case Token.NAME:\n            if (first \u003d\u003d null || first.isEmpty()) {\n                addIdentifier(n.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                addIdentifier(n.getString());\n                cc.addOp(\"\u003d\", true);\n                if (first.isComma()) {\n                    addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                } else {\n                    addExpr(first, 0, getContextForNoInOperator(context));\n                }\n            }\n            break;\n        case Token.ARRAYLIT:\n            add(\"[\");\n            addArrayList(first);\n            add(\"]\");\n            break;\n        case Token.LP:\n            add(\"(\");\n            addList(first);\n            add(\")\");\n            break;\n        case Token.COMMA:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            addList(first, false, context);\n            break;\n        case Token.NUMBER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            cc.addNumber(n.getDouble());\n            break;\n        case Token.TYPEOF:\n        case Token.VOID:\n        case Token.NOT:\n        case Token.BITNOT:\n        case Token.POS:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                addExpr(first, NodeUtil.precedence(type));\n                break;\n            }\n        case Token.NEG:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                if (n.getFirstChild().isNumber()) {\n                    cc.addNumber(-n.getFirstChild().getDouble());\n                } else {\n                    cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                    addExpr(first, NodeUtil.precedence(type));\n                }\n                break;\n            }\n        case Token.HOOK:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                int p \u003d NodeUtil.precedence(type);\n                addLeftExpr(first, p + 1, context);\n                cc.addOp(\"?\", true);\n                addExpr(first.getNext(), 1);\n                cc.addOp(\":\", true);\n                addExpr(last, 1);\n                break;\n            }\n        case Token.REGEXP:\n            if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                throw new Error(\"Expected children to be strings\");\n            }\n            String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n            if (childCount \u003d\u003d 2) {\n                add(regexp + last.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                add(regexp);\n            }\n            break;\n        case Token.FUNCTION:\n            if (n.getClass() !\u003d Node.class) {\n                throw new Error(\"Unexpected Node subclass.\");\n            }\n            Preconditions.checkState(childCount \u003d\u003d 3);\n            boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n            if (funcNeedsParens) {\n                add(\"(\");\n            }\n            add(\"function\");\n            add(first);\n            add(first.getNext());\n            add(last, Context.PRESERVE_BLOCK);\n            cc.endFunction(context \u003d\u003d Context.STATEMENT);\n            if (funcNeedsParens) {\n                add(\")\");\n            }\n            break;\n        case Token.GET:\n        case Token.SET:\n            Preconditions.checkState(n.getParent().isObjectLit());\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            Preconditions.checkState(first.isFunction());\n            Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n            if (type \u003d\u003d Token.GET) {\n                Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n                add(\"get \");\n            } else {\n                Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n                add(\"set \");\n            }\n            String name \u003d n.getString();\n            Node fn \u003d first;\n            Node parameters \u003d fn.getChildAtIndex(1);\n            Node body \u003d fn.getLastChild();\n            if (!n.isQuotedString() \u0026\u0026 TokenStream.isJSIdentifier(name) \u0026\u0026 NodeUtil.isLatin(name)) {\n                add(name);\n            } else {\n                double d \u003d getSimpleNumber(name);\n                if (!Double.isNaN(d)) {\n                    cc.addNumber(d);\n                } else {\n                    addJsString(n.getString());\n                }\n            }\n            add(parameters);\n            add(body, Context.PRESERVE_BLOCK);\n            break;\n        case Token.SCRIPT:\n        case Token.BLOCK:\n            {\n                if (n.getClass() !\u003d Node.class) {\n                    throw new Error(\"Unexpected Node subclass.\");\n                }\n                boolean preserveBlock \u003d context \u003d\u003d Context.PRESERVE_BLOCK;\n                if (preserveBlock) {\n                    cc.beginBlock();\n                }\n                boolean preferLineBreaks \u003d type \u003d\u003d Token.SCRIPT || (type \u003d\u003d Token.BLOCK \u0026\u0026 !preserveBlock \u0026\u0026 n.getParent() !\u003d null \u0026\u0026 n.getParent().isScript());\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    add(c, Context.STATEMENT);\n                    if (c.isVar()) {\n                        cc.endStatement();\n                    }\n                    if (c.isFunction()) {\n                        cc.maybeLineBreak();\n                    }\n                    if (preferLineBreaks) {\n                        cc.notePreferredLineBreak();\n                    }\n                }\n                if (preserveBlock) {\n                    cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                }\n                break;\n            }\n        case Token.FOR:\n            if (childCount \u003d\u003d 4) {\n                add(\"for(\");\n                if (first.isVar()) {\n                    add(first, Context.IN_FOR_INIT_CLAUSE);\n                } else {\n                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                }\n                add(\";\");\n                add(first.getNext());\n                add(\";\");\n                add(first.getNext().getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                add(\"for(\");\n                add(first);\n                add(\"in\");\n                add(first.getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            }\n            break;\n        case Token.DO:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"do\");\n            addNonEmptyStatement(first, Context.OTHER, false);\n            add(\"while(\");\n            add(last);\n            add(\")\");\n            cc.endStatement();\n            break;\n        case Token.WHILE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"while(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.EMPTY:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            break;\n        case Token.GETPROP:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                Preconditions.checkState(last.isString(), \"Bad GETPROP: RHS should be STRING\");\n                boolean needsParens \u003d (first.isNumber());\n                if (needsParens) {\n                    add(\"(\");\n                }\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n                if (needsParens) {\n                    add(\")\");\n                }\n                add(\".\");\n                addIdentifier(last.getString());\n                break;\n            }\n        case Token.GETELEM:\n            Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n            addLeftExpr(first, NodeUtil.precedence(type), context);\n            add(\"[\");\n            add(first.getNext());\n            add(\"]\");\n            break;\n        case Token.WITH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"with(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.INC:\n        case Token.DEC:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                if (postProp !\u003d 0) {\n                    addLeftExpr(first, NodeUtil.precedence(type), context);\n                    cc.addOp(o, false);\n                } else {\n                    cc.addOp(o, false);\n                    add(first);\n                }\n                break;\n            }\n        case Token.CALL:\n            if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) \u0026\u0026 NodeUtil.isGet(first)) {\n                add(\"(0,\");\n                addExpr(first, NodeUtil.precedence(Token.COMMA));\n                add(\")\");\n            } else {\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n            }\n            add(\"(\");\n            addList(first.getNext());\n            add(\")\");\n            break;\n        case Token.IF:\n            boolean hasElse \u003d childCount \u003d\u003d 3;\n            boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n            if (ambiguousElseClause) {\n                cc.beginBlock();\n            }\n            add(\"if(\");\n            add(first);\n            add(\")\");\n            if (hasElse) {\n                addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                add(\"else\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n                Preconditions.checkState(childCount \u003d\u003d 2);\n            }\n            if (ambiguousElseClause) {\n                cc.endBlock();\n            }\n            break;\n        case Token.NULL:\n        case Token.THIS:\n        case Token.FALSE:\n        case Token.TRUE:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(Node.tokenToName(type));\n            break;\n        case Token.CONTINUE:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"continue\");\n            if (childCount \u003d\u003d 1) {\n                if (first.getType() !\u003d Token.LABEL_NAME) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.DEBUGGER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"debugger\");\n            cc.endStatement();\n            break;\n        case Token.BREAK:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"break\");\n            if (childCount \u003d\u003d 1) {\n                if (first.getType() !\u003d Token.LABEL_NAME) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.EXPR_RESULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first, Context.START_OF_EXPR);\n            cc.endStatement();\n            break;\n        case Token.NEW:\n            add(\"new \");\n            int precedence \u003d NodeUtil.precedence(type);\n            if (NodeUtil.containsType(first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n                precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n            }\n            addExpr(first, precedence);\n            Node next \u003d first.getNext();\n            if (next !\u003d null) {\n                add(\"(\");\n                addList(next);\n                add(\")\");\n            }\n            break;\n        case Token.STRING:\n            if (childCount !\u003d ((n.getParent() !\u003d null \u0026\u0026 n.getParent().isObjectLit()) ? 1 : 0)) {\n                throw new IllegalStateException(\"Unexpected String children: \" + n.getParent().toStringTree());\n            }\n            addJsString(n.getString());\n            break;\n        case Token.DELPROP:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"delete \");\n            add(first);\n            break;\n        case Token.OBJECTLIT:\n            {\n                boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                add(\"{\");\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    if (c !\u003d first) {\n                        cc.listSeparator();\n                    }\n                    if (c.isGet() || c.isSet()) {\n                        add(c);\n                    } else {\n                        Preconditions.checkState(c.isString());\n                        String key \u003d c.getString();\n                        if (!c.isQuotedString() \u0026\u0026 !TokenStream.isKeyword(key) \u0026\u0026 TokenStream.isJSIdentifier(key) \u0026\u0026 NodeUtil.isLatin(key)) {\n                            add(key);\n                        } else {\n                            double d \u003d getSimpleNumber(key);\n                            if (!Double.isNaN(d)) {\n                                cc.addNumber(d);\n                            } else {\n                                addExpr(c, 1);\n                            }\n                        }\n                        add(\":\");\n                        addExpr(c.getFirstChild(), 1);\n                    }\n                }\n                add(\"}\");\n                if (needsParens) {\n                    add(\")\");\n                }\n                break;\n            }\n        case Token.SWITCH:\n            add(\"switch(\");\n            add(first);\n            add(\")\");\n            cc.beginBlock();\n            addAllSiblings(first.getNext());\n            cc.endBlock(context \u003d\u003d Context.STATEMENT);\n            break;\n        case Token.CASE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"case \");\n            add(first);\n            addCaseBody(last);\n            break;\n        case Token.DEFAULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"default\");\n            addCaseBody(first);\n            break;\n        case Token.LABEL:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            if (first.getType() !\u003d Token.LABEL_NAME) {\n                throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n            }\n            add(first);\n            add(\":\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\n            break;\n        default:\n            throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n    cc.endSourceMapping(n);\n}",
      "path": "src/com/google/javascript/jscomp/CodeGenerator.java",
      "functionStartLine": 85,
      "functionName": "add",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,483 +1,483 @@\n void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n         return;\n     }\n     int type \u003d n.getType();\n     String opstr \u003d NodeUtil.opToStr(type);\n     int childCount \u003d n.getChildCount();\n     Node first \u003d n.getFirstChild();\n     Node last \u003d n.getLastChild();\n     if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n         Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n         int p \u003d NodeUtil.precedence(type);\n         addLeftExpr(first, p, context);\n         cc.addOp(opstr, true);\n         Context rhsContext \u003d getContextForNoInOperator(context);\n         if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n             addExpr(last, p, rhsContext);\n         } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n             addExpr(last, p, rhsContext);\n         } else {\n             addExpr(last, p + 1, rhsContext);\n         }\n         return;\n     }\n     cc.startSourceMapping(n);\n     switch(type) {\n         case Token.TRY:\n             {\n-                Preconditions.checkState(first.getNext().getType() \u003d\u003d Token.BLOCK \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n+                Preconditions.checkState(first.getNext().isBlock() \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n                 Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                 add(\"try\");\n                 add(first, Context.PRESERVE_BLOCK);\n                 Node catchblock \u003d first.getNext().getFirstChild();\n                 if (catchblock !\u003d null) {\n                     add(catchblock);\n                 }\n                 if (childCount \u003d\u003d 3) {\n                     add(\"finally\");\n                     add(last, Context.PRESERVE_BLOCK);\n                 }\n                 break;\n             }\n         case Token.CATCH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"catch(\");\n             add(first);\n             add(\")\");\n             add(last, Context.PRESERVE_BLOCK);\n             break;\n         case Token.THROW:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"throw\");\n             add(first);\n             cc.endStatement(true);\n             break;\n         case Token.RETURN:\n             add(\"return\");\n             if (childCount \u003d\u003d 1) {\n                 add(first);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 0);\n             }\n             cc.endStatement();\n             break;\n         case Token.VAR:\n             if (first !\u003d null) {\n                 add(\"var \");\n                 addList(first, false, getContextForNoInOperator(context));\n             }\n             break;\n         case Token.LABEL_NAME:\n             Preconditions.checkState(!n.getString().isEmpty());\n             addIdentifier(n.getString());\n             break;\n         case Token.NAME:\n-            if (first \u003d\u003d null || first.getType() \u003d\u003d Token.EMPTY) {\n+            if (first \u003d\u003d null || first.isEmpty()) {\n                 addIdentifier(n.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 addIdentifier(n.getString());\n                 cc.addOp(\"\u003d\", true);\n-                if (first.getType() \u003d\u003d Token.COMMA) {\n+                if (first.isComma()) {\n                     addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                 } else {\n                     addExpr(first, 0, getContextForNoInOperator(context));\n                 }\n             }\n             break;\n         case Token.ARRAYLIT:\n             add(\"[\");\n             addArrayList(first);\n             add(\"]\");\n             break;\n         case Token.LP:\n             add(\"(\");\n             addList(first);\n             add(\")\");\n             break;\n         case Token.COMMA:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             addList(first, false, context);\n             break;\n         case Token.NUMBER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             cc.addNumber(n.getDouble());\n             break;\n         case Token.TYPEOF:\n         case Token.VOID:\n         case Token.NOT:\n         case Token.BITNOT:\n         case Token.POS:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                 addExpr(first, NodeUtil.precedence(type));\n                 break;\n             }\n         case Token.NEG:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n-                if (n.getFirstChild().getType() \u003d\u003d Token.NUMBER) {\n+                if (n.getFirstChild().isNumber()) {\n                     cc.addNumber(-n.getFirstChild().getDouble());\n                 } else {\n                     cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                     addExpr(first, NodeUtil.precedence(type));\n                 }\n                 break;\n             }\n         case Token.HOOK:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 int p \u003d NodeUtil.precedence(type);\n                 addLeftExpr(first, p + 1, context);\n                 cc.addOp(\"?\", true);\n                 addExpr(first.getNext(), 1);\n                 cc.addOp(\":\", true);\n                 addExpr(last, 1);\n                 break;\n             }\n         case Token.REGEXP:\n             if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                 throw new Error(\"Expected children to be strings\");\n             }\n             String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n             if (childCount \u003d\u003d 2) {\n                 add(regexp + last.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 add(regexp);\n             }\n             break;\n         case Token.FUNCTION:\n             if (n.getClass() !\u003d Node.class) {\n                 throw new Error(\"Unexpected Node subclass.\");\n             }\n             Preconditions.checkState(childCount \u003d\u003d 3);\n             boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n             if (funcNeedsParens) {\n                 add(\"(\");\n             }\n             add(\"function\");\n             add(first);\n             add(first.getNext());\n             add(last, Context.PRESERVE_BLOCK);\n             cc.endFunction(context \u003d\u003d Context.STATEMENT);\n             if (funcNeedsParens) {\n                 add(\")\");\n             }\n             break;\n         case Token.GET:\n         case Token.SET:\n-            Preconditions.checkState(n.getParent().getType() \u003d\u003d Token.OBJECTLIT);\n+            Preconditions.checkState(n.getParent().isObjectLit());\n             Preconditions.checkState(childCount \u003d\u003d 1);\n-            Preconditions.checkState(first.getType() \u003d\u003d Token.FUNCTION);\n+            Preconditions.checkState(first.isFunction());\n             Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n             if (type \u003d\u003d Token.GET) {\n                 Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n                 add(\"get \");\n             } else {\n                 Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n                 add(\"set \");\n             }\n             String name \u003d n.getString();\n             Node fn \u003d first;\n             Node parameters \u003d fn.getChildAtIndex(1);\n             Node body \u003d fn.getLastChild();\n             if (!n.isQuotedString() \u0026\u0026 TokenStream.isJSIdentifier(name) \u0026\u0026 NodeUtil.isLatin(name)) {\n                 add(name);\n             } else {\n                 double d \u003d getSimpleNumber(name);\n                 if (!Double.isNaN(d)) {\n                     cc.addNumber(d);\n                 } else {\n                     addJsString(n.getString());\n                 }\n             }\n             add(parameters);\n             add(body, Context.PRESERVE_BLOCK);\n             break;\n         case Token.SCRIPT:\n         case Token.BLOCK:\n             {\n                 if (n.getClass() !\u003d Node.class) {\n                     throw new Error(\"Unexpected Node subclass.\");\n                 }\n                 boolean preserveBlock \u003d context \u003d\u003d Context.PRESERVE_BLOCK;\n                 if (preserveBlock) {\n                     cc.beginBlock();\n                 }\n-                boolean preferLineBreaks \u003d type \u003d\u003d Token.SCRIPT || (type \u003d\u003d Token.BLOCK \u0026\u0026 !preserveBlock \u0026\u0026 n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.SCRIPT);\n+                boolean preferLineBreaks \u003d type \u003d\u003d Token.SCRIPT || (type \u003d\u003d Token.BLOCK \u0026\u0026 !preserveBlock \u0026\u0026 n.getParent() !\u003d null \u0026\u0026 n.getParent().isScript());\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     add(c, Context.STATEMENT);\n-                    if (c.getType() \u003d\u003d Token.VAR) {\n+                    if (c.isVar()) {\n                         cc.endStatement();\n                     }\n-                    if (c.getType() \u003d\u003d Token.FUNCTION) {\n+                    if (c.isFunction()) {\n                         cc.maybeLineBreak();\n                     }\n                     if (preferLineBreaks) {\n                         cc.notePreferredLineBreak();\n                     }\n                 }\n                 if (preserveBlock) {\n                     cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                 }\n                 break;\n             }\n         case Token.FOR:\n             if (childCount \u003d\u003d 4) {\n                 add(\"for(\");\n-                if (first.getType() \u003d\u003d Token.VAR) {\n+                if (first.isVar()) {\n                     add(first, Context.IN_FOR_INIT_CLAUSE);\n                 } else {\n                     addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                 }\n                 add(\";\");\n                 add(first.getNext());\n                 add(\";\");\n                 add(first.getNext().getNext());\n                 add(\")\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 add(\"for(\");\n                 add(first);\n                 add(\"in\");\n                 add(first.getNext());\n                 add(\")\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             }\n             break;\n         case Token.DO:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"do\");\n             addNonEmptyStatement(first, Context.OTHER, false);\n             add(\"while(\");\n             add(last);\n             add(\")\");\n             cc.endStatement();\n             break;\n         case Token.WHILE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"while(\");\n             add(first);\n             add(\")\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.EMPTY:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             break;\n         case Token.GETPROP:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n-                Preconditions.checkState(last.getType() \u003d\u003d Token.STRING, \"Bad GETPROP: RHS should be STRING\");\n-                boolean needsParens \u003d (first.getType() \u003d\u003d Token.NUMBER);\n+                Preconditions.checkState(last.isString(), \"Bad GETPROP: RHS should be STRING\");\n+                boolean needsParens \u003d (first.isNumber());\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 add(\".\");\n                 addIdentifier(last.getString());\n                 break;\n             }\n         case Token.GETELEM:\n             Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n             addLeftExpr(first, NodeUtil.precedence(type), context);\n             add(\"[\");\n             add(first.getNext());\n             add(\"]\");\n             break;\n         case Token.WITH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"with(\");\n             add(first);\n             add(\")\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.INC:\n         case Token.DEC:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                 int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                 if (postProp !\u003d 0) {\n                     addLeftExpr(first, NodeUtil.precedence(type), context);\n                     cc.addOp(o, false);\n                 } else {\n                     cc.addOp(o, false);\n                     add(first);\n                 }\n                 break;\n             }\n         case Token.CALL:\n             if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) \u0026\u0026 NodeUtil.isGet(first)) {\n                 add(\"(0,\");\n                 addExpr(first, NodeUtil.precedence(Token.COMMA));\n                 add(\")\");\n             } else {\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n             }\n             add(\"(\");\n             addList(first.getNext());\n             add(\")\");\n             break;\n         case Token.IF:\n             boolean hasElse \u003d childCount \u003d\u003d 3;\n             boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n             if (ambiguousElseClause) {\n                 cc.beginBlock();\n             }\n             add(\"if(\");\n             add(first);\n             add(\")\");\n             if (hasElse) {\n                 addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                 add(\"else\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n                 Preconditions.checkState(childCount \u003d\u003d 2);\n             }\n             if (ambiguousElseClause) {\n                 cc.endBlock();\n             }\n             break;\n         case Token.NULL:\n         case Token.THIS:\n         case Token.FALSE:\n         case Token.TRUE:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(Node.tokenToName(type));\n             break;\n         case Token.CONTINUE:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"continue\");\n             if (childCount \u003d\u003d 1) {\n                 if (first.getType() !\u003d Token.LABEL_NAME) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.DEBUGGER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(\"debugger\");\n             cc.endStatement();\n             break;\n         case Token.BREAK:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"break\");\n             if (childCount \u003d\u003d 1) {\n                 if (first.getType() !\u003d Token.LABEL_NAME) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.EXPR_RESULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first, Context.START_OF_EXPR);\n             cc.endStatement();\n             break;\n         case Token.NEW:\n             add(\"new \");\n             int precedence \u003d NodeUtil.precedence(type);\n             if (NodeUtil.containsType(first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n                 precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n             }\n             addExpr(first, precedence);\n             Node next \u003d first.getNext();\n             if (next !\u003d null) {\n                 add(\"(\");\n                 addList(next);\n                 add(\")\");\n             }\n             break;\n         case Token.STRING:\n-            if (childCount !\u003d ((n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.OBJECTLIT) ? 1 : 0)) {\n+            if (childCount !\u003d ((n.getParent() !\u003d null \u0026\u0026 n.getParent().isObjectLit()) ? 1 : 0)) {\n                 throw new IllegalStateException(\"Unexpected String children: \" + n.getParent().toStringTree());\n             }\n             addJsString(n.getString());\n             break;\n         case Token.DELPROP:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"delete \");\n             add(first);\n             break;\n         case Token.OBJECTLIT:\n             {\n                 boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 add(\"{\");\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     if (c !\u003d first) {\n                         cc.listSeparator();\n                     }\n-                    if (c.getType() \u003d\u003d Token.GET || c.getType() \u003d\u003d Token.SET) {\n+                    if (c.isGet() || c.isSet()) {\n                         add(c);\n                     } else {\n-                        Preconditions.checkState(c.getType() \u003d\u003d Token.STRING);\n+                        Preconditions.checkState(c.isString());\n                         String key \u003d c.getString();\n                         if (!c.isQuotedString() \u0026\u0026 !TokenStream.isKeyword(key) \u0026\u0026 TokenStream.isJSIdentifier(key) \u0026\u0026 NodeUtil.isLatin(key)) {\n                             add(key);\n                         } else {\n                             double d \u003d getSimpleNumber(key);\n                             if (!Double.isNaN(d)) {\n                                 cc.addNumber(d);\n                             } else {\n                                 addExpr(c, 1);\n                             }\n                         }\n                         add(\":\");\n                         addExpr(c.getFirstChild(), 1);\n                     }\n                 }\n                 add(\"}\");\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 break;\n             }\n         case Token.SWITCH:\n             add(\"switch(\");\n             add(first);\n             add(\")\");\n             cc.beginBlock();\n             addAllSiblings(first.getNext());\n             cc.endBlock(context \u003d\u003d Context.STATEMENT);\n             break;\n         case Token.CASE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"case \");\n             add(first);\n             addCaseBody(last);\n             break;\n         case Token.DEFAULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"default\");\n             addCaseBody(first);\n             break;\n         case Token.LABEL:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             if (first.getType() !\u003d Token.LABEL_NAME) {\n                 throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n             }\n             add(first);\n             add(\":\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\n             break;\n         default:\n             throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n     }\n     cc.endSourceMapping(n);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6641663fa9970c4d7bcdd96a6f31b83b18c3ee3d": {
      "type": "Ybodychange",
      "commitMessage": "\nRemove unused Token ids.\n\nR\u003dnicksantos\nDELTA\u003d1258  (4 added, 1244 deleted, 10 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3647\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1562 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/7/11, 2:21 PM",
      "commitName": "6641663fa9970c4d7bcdd96a6f31b83b18c3ee3d",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "10/5/11, 10:32 AM",
      "commitNameOld": "0a58c69ede8450419f6309bf8d97a00fe48c1b33",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 33.2,
      "commitsBetweenForRepo": 59,
      "commitsBetweenForFile": 1,
      "actualSource": "void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n        return;\n    }\n    int type \u003d n.getType();\n    String opstr \u003d NodeUtil.opToStr(type);\n    int childCount \u003d n.getChildCount();\n    Node first \u003d n.getFirstChild();\n    Node last \u003d n.getLastChild();\n    if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n        Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n        int p \u003d NodeUtil.precedence(type);\n        addLeftExpr(first, p, context);\n        cc.addOp(opstr, true);\n        Context rhsContext \u003d getContextForNoInOperator(context);\n        if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n            addExpr(last, p, rhsContext);\n        } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n            addExpr(last, p, rhsContext);\n        } else {\n            addExpr(last, p + 1, rhsContext);\n        }\n        return;\n    }\n    cc.startSourceMapping(n);\n    switch(type) {\n        case Token.TRY:\n            {\n                Preconditions.checkState(first.getNext().getType() \u003d\u003d Token.BLOCK \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n                Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                add(\"try\");\n                add(first, Context.PRESERVE_BLOCK);\n                Node catchblock \u003d first.getNext().getFirstChild();\n                if (catchblock !\u003d null) {\n                    add(catchblock);\n                }\n                if (childCount \u003d\u003d 3) {\n                    add(\"finally\");\n                    add(last, Context.PRESERVE_BLOCK);\n                }\n                break;\n            }\n        case Token.CATCH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"catch(\");\n            add(first);\n            add(\")\");\n            add(last, Context.PRESERVE_BLOCK);\n            break;\n        case Token.THROW:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"throw\");\n            add(first);\n            cc.endStatement(true);\n            break;\n        case Token.RETURN:\n            add(\"return\");\n            if (childCount \u003d\u003d 1) {\n                add(first);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 0);\n            }\n            cc.endStatement();\n            break;\n        case Token.VAR:\n            if (first !\u003d null) {\n                add(\"var \");\n                addList(first, false, getContextForNoInOperator(context));\n            }\n            break;\n        case Token.LABEL_NAME:\n            Preconditions.checkState(!n.getString().isEmpty());\n            addIdentifier(n.getString());\n            break;\n        case Token.NAME:\n            if (first \u003d\u003d null || first.getType() \u003d\u003d Token.EMPTY) {\n                addIdentifier(n.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                addIdentifier(n.getString());\n                cc.addOp(\"\u003d\", true);\n                if (first.getType() \u003d\u003d Token.COMMA) {\n                    addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                } else {\n                    addExpr(first, 0, getContextForNoInOperator(context));\n                }\n            }\n            break;\n        case Token.ARRAYLIT:\n            add(\"[\");\n            addArrayList(first);\n            add(\"]\");\n            break;\n        case Token.LP:\n            add(\"(\");\n            addList(first);\n            add(\")\");\n            break;\n        case Token.COMMA:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            addList(first, false, context);\n            break;\n        case Token.NUMBER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            cc.addNumber(n.getDouble());\n            break;\n        case Token.TYPEOF:\n        case Token.VOID:\n        case Token.NOT:\n        case Token.BITNOT:\n        case Token.POS:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                addExpr(first, NodeUtil.precedence(type));\n                break;\n            }\n        case Token.NEG:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                if (n.getFirstChild().getType() \u003d\u003d Token.NUMBER) {\n                    cc.addNumber(-n.getFirstChild().getDouble());\n                } else {\n                    cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                    addExpr(first, NodeUtil.precedence(type));\n                }\n                break;\n            }\n        case Token.HOOK:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                int p \u003d NodeUtil.precedence(type);\n                addLeftExpr(first, p + 1, context);\n                cc.addOp(\"?\", true);\n                addExpr(first.getNext(), 1);\n                cc.addOp(\":\", true);\n                addExpr(last, 1);\n                break;\n            }\n        case Token.REGEXP:\n            if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                throw new Error(\"Expected children to be strings\");\n            }\n            String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n            if (childCount \u003d\u003d 2) {\n                add(regexp + last.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                add(regexp);\n            }\n            break;\n        case Token.FUNCTION:\n            if (n.getClass() !\u003d Node.class) {\n                throw new Error(\"Unexpected Node subclass.\");\n            }\n            Preconditions.checkState(childCount \u003d\u003d 3);\n            boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n            if (funcNeedsParens) {\n                add(\"(\");\n            }\n            add(\"function\");\n            add(first);\n            add(first.getNext());\n            add(last, Context.PRESERVE_BLOCK);\n            cc.endFunction(context \u003d\u003d Context.STATEMENT);\n            if (funcNeedsParens) {\n                add(\")\");\n            }\n            break;\n        case Token.GET:\n        case Token.SET:\n            Preconditions.checkState(n.getParent().getType() \u003d\u003d Token.OBJECTLIT);\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            Preconditions.checkState(first.getType() \u003d\u003d Token.FUNCTION);\n            Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n            if (type \u003d\u003d Token.GET) {\n                Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n                add(\"get \");\n            } else {\n                Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n                add(\"set \");\n            }\n            String name \u003d n.getString();\n            Node fn \u003d first;\n            Node parameters \u003d fn.getChildAtIndex(1);\n            Node body \u003d fn.getLastChild();\n            if (!n.isQuotedString() \u0026\u0026 TokenStream.isJSIdentifier(name) \u0026\u0026 NodeUtil.isLatin(name)) {\n                add(name);\n            } else {\n                double d \u003d getSimpleNumber(name);\n                if (!Double.isNaN(d)) {\n                    cc.addNumber(d);\n                } else {\n                    addJsString(n.getString());\n                }\n            }\n            add(parameters);\n            add(body, Context.PRESERVE_BLOCK);\n            break;\n        case Token.SCRIPT:\n        case Token.BLOCK:\n            {\n                if (n.getClass() !\u003d Node.class) {\n                    throw new Error(\"Unexpected Node subclass.\");\n                }\n                boolean preserveBlock \u003d context \u003d\u003d Context.PRESERVE_BLOCK;\n                if (preserveBlock) {\n                    cc.beginBlock();\n                }\n                boolean preferLineBreaks \u003d type \u003d\u003d Token.SCRIPT || (type \u003d\u003d Token.BLOCK \u0026\u0026 !preserveBlock \u0026\u0026 n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.SCRIPT);\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    add(c, Context.STATEMENT);\n                    if (c.getType() \u003d\u003d Token.VAR) {\n                        cc.endStatement();\n                    }\n                    if (c.getType() \u003d\u003d Token.FUNCTION) {\n                        cc.maybeLineBreak();\n                    }\n                    if (preferLineBreaks) {\n                        cc.notePreferredLineBreak();\n                    }\n                }\n                if (preserveBlock) {\n                    cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                }\n                break;\n            }\n        case Token.FOR:\n            if (childCount \u003d\u003d 4) {\n                add(\"for(\");\n                if (first.getType() \u003d\u003d Token.VAR) {\n                    add(first, Context.IN_FOR_INIT_CLAUSE);\n                } else {\n                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                }\n                add(\";\");\n                add(first.getNext());\n                add(\";\");\n                add(first.getNext().getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                add(\"for(\");\n                add(first);\n                add(\"in\");\n                add(first.getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            }\n            break;\n        case Token.DO:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"do\");\n            addNonEmptyStatement(first, Context.OTHER, false);\n            add(\"while(\");\n            add(last);\n            add(\")\");\n            cc.endStatement();\n            break;\n        case Token.WHILE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"while(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.EMPTY:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            break;\n        case Token.GETPROP:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                Preconditions.checkState(last.getType() \u003d\u003d Token.STRING, \"Bad GETPROP: RHS should be STRING\");\n                boolean needsParens \u003d (first.getType() \u003d\u003d Token.NUMBER);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n                if (needsParens) {\n                    add(\")\");\n                }\n                add(\".\");\n                addIdentifier(last.getString());\n                break;\n            }\n        case Token.GETELEM:\n            Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n            addLeftExpr(first, NodeUtil.precedence(type), context);\n            add(\"[\");\n            add(first.getNext());\n            add(\"]\");\n            break;\n        case Token.WITH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"with(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.INC:\n        case Token.DEC:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                if (postProp !\u003d 0) {\n                    addLeftExpr(first, NodeUtil.precedence(type), context);\n                    cc.addOp(o, false);\n                } else {\n                    cc.addOp(o, false);\n                    add(first);\n                }\n                break;\n            }\n        case Token.CALL:\n            if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) \u0026\u0026 NodeUtil.isGet(first)) {\n                add(\"(0,\");\n                addExpr(first, NodeUtil.precedence(Token.COMMA));\n                add(\")\");\n            } else {\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n            }\n            add(\"(\");\n            addList(first.getNext());\n            add(\")\");\n            break;\n        case Token.IF:\n            boolean hasElse \u003d childCount \u003d\u003d 3;\n            boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n            if (ambiguousElseClause) {\n                cc.beginBlock();\n            }\n            add(\"if(\");\n            add(first);\n            add(\")\");\n            if (hasElse) {\n                addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                add(\"else\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n                Preconditions.checkState(childCount \u003d\u003d 2);\n            }\n            if (ambiguousElseClause) {\n                cc.endBlock();\n            }\n            break;\n        case Token.NULL:\n        case Token.THIS:\n        case Token.FALSE:\n        case Token.TRUE:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(Node.tokenToName(type));\n            break;\n        case Token.CONTINUE:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"continue\");\n            if (childCount \u003d\u003d 1) {\n                if (first.getType() !\u003d Token.LABEL_NAME) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.DEBUGGER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"debugger\");\n            cc.endStatement();\n            break;\n        case Token.BREAK:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"break\");\n            if (childCount \u003d\u003d 1) {\n                if (first.getType() !\u003d Token.LABEL_NAME) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.EXPR_RESULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first, Context.START_OF_EXPR);\n            cc.endStatement();\n            break;\n        case Token.NEW:\n            add(\"new \");\n            int precedence \u003d NodeUtil.precedence(type);\n            if (NodeUtil.containsType(first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n                precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n            }\n            addExpr(first, precedence);\n            Node next \u003d first.getNext();\n            if (next !\u003d null) {\n                add(\"(\");\n                addList(next);\n                add(\")\");\n            }\n            break;\n        case Token.STRING:\n            if (childCount !\u003d ((n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.OBJECTLIT) ? 1 : 0)) {\n                throw new IllegalStateException(\"Unexpected String children: \" + n.getParent().toStringTree());\n            }\n            addJsString(n.getString());\n            break;\n        case Token.DELPROP:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"delete \");\n            add(first);\n            break;\n        case Token.OBJECTLIT:\n            {\n                boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                add(\"{\");\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    if (c !\u003d first) {\n                        cc.listSeparator();\n                    }\n                    if (c.getType() \u003d\u003d Token.GET || c.getType() \u003d\u003d Token.SET) {\n                        add(c);\n                    } else {\n                        Preconditions.checkState(c.getType() \u003d\u003d Token.STRING);\n                        String key \u003d c.getString();\n                        if (!c.isQuotedString() \u0026\u0026 !TokenStream.isKeyword(key) \u0026\u0026 TokenStream.isJSIdentifier(key) \u0026\u0026 NodeUtil.isLatin(key)) {\n                            add(key);\n                        } else {\n                            double d \u003d getSimpleNumber(key);\n                            if (!Double.isNaN(d)) {\n                                cc.addNumber(d);\n                            } else {\n                                addExpr(c, 1);\n                            }\n                        }\n                        add(\":\");\n                        addExpr(c.getFirstChild(), 1);\n                    }\n                }\n                add(\"}\");\n                if (needsParens) {\n                    add(\")\");\n                }\n                break;\n            }\n        case Token.SWITCH:\n            add(\"switch(\");\n            add(first);\n            add(\")\");\n            cc.beginBlock();\n            addAllSiblings(first.getNext());\n            cc.endBlock(context \u003d\u003d Context.STATEMENT);\n            break;\n        case Token.CASE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"case \");\n            add(first);\n            addCaseBody(last);\n            break;\n        case Token.DEFAULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"default\");\n            addCaseBody(first);\n            break;\n        case Token.LABEL:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            if (first.getType() !\u003d Token.LABEL_NAME) {\n                throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n            }\n            add(first);\n            add(\":\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\n            break;\n        default:\n            throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n    cc.endSourceMapping(n);\n}",
      "path": "src/com/google/javascript/jscomp/CodeGenerator.java",
      "functionStartLine": 85,
      "functionName": "add",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,496 +1,483 @@\n void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n         return;\n     }\n     int type \u003d n.getType();\n     String opstr \u003d NodeUtil.opToStr(type);\n     int childCount \u003d n.getChildCount();\n     Node first \u003d n.getFirstChild();\n     Node last \u003d n.getLastChild();\n     if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n         Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n         int p \u003d NodeUtil.precedence(type);\n         addLeftExpr(first, p, context);\n         cc.addOp(opstr, true);\n         Context rhsContext \u003d getContextForNoInOperator(context);\n         if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n             addExpr(last, p, rhsContext);\n         } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n             addExpr(last, p, rhsContext);\n         } else {\n             addExpr(last, p + 1, rhsContext);\n         }\n         return;\n     }\n     cc.startSourceMapping(n);\n     switch(type) {\n         case Token.TRY:\n             {\n                 Preconditions.checkState(first.getNext().getType() \u003d\u003d Token.BLOCK \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n                 Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                 add(\"try\");\n                 add(first, Context.PRESERVE_BLOCK);\n                 Node catchblock \u003d first.getNext().getFirstChild();\n                 if (catchblock !\u003d null) {\n                     add(catchblock);\n                 }\n                 if (childCount \u003d\u003d 3) {\n                     add(\"finally\");\n                     add(last, Context.PRESERVE_BLOCK);\n                 }\n                 break;\n             }\n         case Token.CATCH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"catch(\");\n             add(first);\n             add(\")\");\n             add(last, Context.PRESERVE_BLOCK);\n             break;\n         case Token.THROW:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"throw\");\n             add(first);\n             cc.endStatement(true);\n             break;\n         case Token.RETURN:\n             add(\"return\");\n             if (childCount \u003d\u003d 1) {\n                 add(first);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 0);\n             }\n             cc.endStatement();\n             break;\n         case Token.VAR:\n             if (first !\u003d null) {\n                 add(\"var \");\n                 addList(first, false, getContextForNoInOperator(context));\n             }\n             break;\n         case Token.LABEL_NAME:\n             Preconditions.checkState(!n.getString().isEmpty());\n             addIdentifier(n.getString());\n             break;\n         case Token.NAME:\n             if (first \u003d\u003d null || first.getType() \u003d\u003d Token.EMPTY) {\n                 addIdentifier(n.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 addIdentifier(n.getString());\n                 cc.addOp(\"\u003d\", true);\n                 if (first.getType() \u003d\u003d Token.COMMA) {\n                     addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                 } else {\n                     addExpr(first, 0, getContextForNoInOperator(context));\n                 }\n             }\n             break;\n         case Token.ARRAYLIT:\n             add(\"[\");\n             addArrayList(first);\n             add(\"]\");\n             break;\n         case Token.LP:\n             add(\"(\");\n             addList(first);\n             add(\")\");\n             break;\n         case Token.COMMA:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             addList(first, false, context);\n             break;\n         case Token.NUMBER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             cc.addNumber(n.getDouble());\n             break;\n         case Token.TYPEOF:\n         case Token.VOID:\n         case Token.NOT:\n         case Token.BITNOT:\n         case Token.POS:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                 addExpr(first, NodeUtil.precedence(type));\n                 break;\n             }\n         case Token.NEG:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 if (n.getFirstChild().getType() \u003d\u003d Token.NUMBER) {\n                     cc.addNumber(-n.getFirstChild().getDouble());\n                 } else {\n                     cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                     addExpr(first, NodeUtil.precedence(type));\n                 }\n                 break;\n             }\n         case Token.HOOK:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 int p \u003d NodeUtil.precedence(type);\n                 addLeftExpr(first, p + 1, context);\n                 cc.addOp(\"?\", true);\n                 addExpr(first.getNext(), 1);\n                 cc.addOp(\":\", true);\n                 addExpr(last, 1);\n                 break;\n             }\n         case Token.REGEXP:\n             if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                 throw new Error(\"Expected children to be strings\");\n             }\n             String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n             if (childCount \u003d\u003d 2) {\n                 add(regexp + last.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 add(regexp);\n             }\n             break;\n-        case Token.GET_REF:\n-            add(first);\n-            break;\n-        case Token.REF_SPECIAL:\n-            Preconditions.checkState(childCount \u003d\u003d 1);\n-            add(first);\n-            add(\".\");\n-            add((String) n.getProp(Node.NAME_PROP));\n-            break;\n         case Token.FUNCTION:\n             if (n.getClass() !\u003d Node.class) {\n                 throw new Error(\"Unexpected Node subclass.\");\n             }\n             Preconditions.checkState(childCount \u003d\u003d 3);\n             boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n             if (funcNeedsParens) {\n                 add(\"(\");\n             }\n             add(\"function\");\n             add(first);\n             add(first.getNext());\n             add(last, Context.PRESERVE_BLOCK);\n             cc.endFunction(context \u003d\u003d Context.STATEMENT);\n             if (funcNeedsParens) {\n                 add(\")\");\n             }\n             break;\n         case Token.GET:\n         case Token.SET:\n             Preconditions.checkState(n.getParent().getType() \u003d\u003d Token.OBJECTLIT);\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             Preconditions.checkState(first.getType() \u003d\u003d Token.FUNCTION);\n             Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n             if (type \u003d\u003d Token.GET) {\n                 Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n                 add(\"get \");\n             } else {\n                 Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n                 add(\"set \");\n             }\n             String name \u003d n.getString();\n             Node fn \u003d first;\n             Node parameters \u003d fn.getChildAtIndex(1);\n             Node body \u003d fn.getLastChild();\n             if (!n.isQuotedString() \u0026\u0026 TokenStream.isJSIdentifier(name) \u0026\u0026 NodeUtil.isLatin(name)) {\n                 add(name);\n             } else {\n                 double d \u003d getSimpleNumber(name);\n                 if (!Double.isNaN(d)) {\n                     cc.addNumber(d);\n                 } else {\n                     addJsString(n.getString());\n                 }\n             }\n             add(parameters);\n             add(body, Context.PRESERVE_BLOCK);\n             break;\n         case Token.SCRIPT:\n         case Token.BLOCK:\n             {\n                 if (n.getClass() !\u003d Node.class) {\n                     throw new Error(\"Unexpected Node subclass.\");\n                 }\n                 boolean preserveBlock \u003d context \u003d\u003d Context.PRESERVE_BLOCK;\n                 if (preserveBlock) {\n                     cc.beginBlock();\n                 }\n                 boolean preferLineBreaks \u003d type \u003d\u003d Token.SCRIPT || (type \u003d\u003d Token.BLOCK \u0026\u0026 !preserveBlock \u0026\u0026 n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.SCRIPT);\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     add(c, Context.STATEMENT);\n                     if (c.getType() \u003d\u003d Token.VAR) {\n                         cc.endStatement();\n                     }\n                     if (c.getType() \u003d\u003d Token.FUNCTION) {\n                         cc.maybeLineBreak();\n                     }\n                     if (preferLineBreaks) {\n                         cc.notePreferredLineBreak();\n                     }\n                 }\n                 if (preserveBlock) {\n                     cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                 }\n                 break;\n             }\n         case Token.FOR:\n             if (childCount \u003d\u003d 4) {\n                 add(\"for(\");\n                 if (first.getType() \u003d\u003d Token.VAR) {\n                     add(first, Context.IN_FOR_INIT_CLAUSE);\n                 } else {\n                     addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                 }\n                 add(\";\");\n                 add(first.getNext());\n                 add(\";\");\n                 add(first.getNext().getNext());\n                 add(\")\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 add(\"for(\");\n                 add(first);\n                 add(\"in\");\n                 add(first.getNext());\n                 add(\")\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             }\n             break;\n         case Token.DO:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"do\");\n             addNonEmptyStatement(first, Context.OTHER, false);\n             add(\"while(\");\n             add(last);\n             add(\")\");\n             cc.endStatement();\n             break;\n         case Token.WHILE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"while(\");\n             add(first);\n             add(\")\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.EMPTY:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             break;\n         case Token.GETPROP:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                 Preconditions.checkState(last.getType() \u003d\u003d Token.STRING, \"Bad GETPROP: RHS should be STRING\");\n                 boolean needsParens \u003d (first.getType() \u003d\u003d Token.NUMBER);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 add(\".\");\n                 addIdentifier(last.getString());\n                 break;\n             }\n         case Token.GETELEM:\n             Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n             addLeftExpr(first, NodeUtil.precedence(type), context);\n             add(\"[\");\n             add(first.getNext());\n             add(\"]\");\n             break;\n         case Token.WITH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"with(\");\n             add(first);\n             add(\")\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.INC:\n         case Token.DEC:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                 int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                 if (postProp !\u003d 0) {\n                     addLeftExpr(first, NodeUtil.precedence(type), context);\n                     cc.addOp(o, false);\n                 } else {\n                     cc.addOp(o, false);\n                     add(first);\n                 }\n                 break;\n             }\n         case Token.CALL:\n             if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) \u0026\u0026 NodeUtil.isGet(first)) {\n                 add(\"(0,\");\n                 addExpr(first, NodeUtil.precedence(Token.COMMA));\n                 add(\")\");\n             } else {\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n             }\n             add(\"(\");\n             addList(first.getNext());\n             add(\")\");\n             break;\n         case Token.IF:\n             boolean hasElse \u003d childCount \u003d\u003d 3;\n             boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n             if (ambiguousElseClause) {\n                 cc.beginBlock();\n             }\n             add(\"if(\");\n             add(first);\n             add(\")\");\n             if (hasElse) {\n                 addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                 add(\"else\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n                 Preconditions.checkState(childCount \u003d\u003d 2);\n             }\n             if (ambiguousElseClause) {\n                 cc.endBlock();\n             }\n             break;\n         case Token.NULL:\n         case Token.THIS:\n         case Token.FALSE:\n         case Token.TRUE:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(Node.tokenToName(type));\n             break;\n         case Token.CONTINUE:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"continue\");\n             if (childCount \u003d\u003d 1) {\n                 if (first.getType() !\u003d Token.LABEL_NAME) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.DEBUGGER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(\"debugger\");\n             cc.endStatement();\n             break;\n         case Token.BREAK:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"break\");\n             if (childCount \u003d\u003d 1) {\n                 if (first.getType() !\u003d Token.LABEL_NAME) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n-        case Token.EXPR_VOID:\n-            throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n         case Token.EXPR_RESULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first, Context.START_OF_EXPR);\n             cc.endStatement();\n             break;\n         case Token.NEW:\n             add(\"new \");\n             int precedence \u003d NodeUtil.precedence(type);\n             if (NodeUtil.containsType(first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n                 precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n             }\n             addExpr(first, precedence);\n             Node next \u003d first.getNext();\n             if (next !\u003d null) {\n                 add(\"(\");\n                 addList(next);\n                 add(\")\");\n             }\n             break;\n         case Token.STRING:\n             if (childCount !\u003d ((n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.OBJECTLIT) ? 1 : 0)) {\n                 throw new IllegalStateException(\"Unexpected String children: \" + n.getParent().toStringTree());\n             }\n             addJsString(n.getString());\n             break;\n         case Token.DELPROP:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"delete \");\n             add(first);\n             break;\n         case Token.OBJECTLIT:\n             {\n                 boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 add(\"{\");\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     if (c !\u003d first) {\n                         cc.listSeparator();\n                     }\n                     if (c.getType() \u003d\u003d Token.GET || c.getType() \u003d\u003d Token.SET) {\n                         add(c);\n                     } else {\n                         Preconditions.checkState(c.getType() \u003d\u003d Token.STRING);\n                         String key \u003d c.getString();\n                         if (!c.isQuotedString() \u0026\u0026 !TokenStream.isKeyword(key) \u0026\u0026 TokenStream.isJSIdentifier(key) \u0026\u0026 NodeUtil.isLatin(key)) {\n                             add(key);\n                         } else {\n                             double d \u003d getSimpleNumber(key);\n                             if (!Double.isNaN(d)) {\n                                 cc.addNumber(d);\n                             } else {\n                                 addExpr(c, 1);\n                             }\n                         }\n                         add(\":\");\n                         addExpr(c.getFirstChild(), 1);\n                     }\n                 }\n                 add(\"}\");\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 break;\n             }\n         case Token.SWITCH:\n             add(\"switch(\");\n             add(first);\n             add(\")\");\n             cc.beginBlock();\n             addAllSiblings(first.getNext());\n             cc.endBlock(context \u003d\u003d Context.STATEMENT);\n             break;\n         case Token.CASE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"case \");\n             add(first);\n             addCaseBody(last);\n             break;\n         case Token.DEFAULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"default\");\n             addCaseBody(first);\n             break;\n         case Token.LABEL:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             if (first.getType() !\u003d Token.LABEL_NAME) {\n                 throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n             }\n             add(first);\n             add(\":\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\n             break;\n-        case Token.SETNAME:\n-            break;\n         default:\n             throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n     }\n     cc.endSourceMapping(n);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0a58c69ede8450419f6309bf8d97a00fe48c1b33": {
      "type": "Ybodychange",
      "commitMessage": "\nAvoid creating an unnecesary temporary object.\n\nR\u003dnicksantos\nDELTA\u003d5  (1 added, 1 deleted, 3 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3412\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1493 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "10/5/11, 10:32 AM",
      "commitName": "0a58c69ede8450419f6309bf8d97a00fe48c1b33",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "10/4/11, 6:25 PM",
      "commitNameOld": "5909c3db59b16886917456ab950ef9661a7fe6b1",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 0.67,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n        return;\n    }\n    int type \u003d n.getType();\n    String opstr \u003d NodeUtil.opToStr(type);\n    int childCount \u003d n.getChildCount();\n    Node first \u003d n.getFirstChild();\n    Node last \u003d n.getLastChild();\n    if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n        Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n        int p \u003d NodeUtil.precedence(type);\n        addLeftExpr(first, p, context);\n        cc.addOp(opstr, true);\n        Context rhsContext \u003d getContextForNoInOperator(context);\n        if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n            addExpr(last, p, rhsContext);\n        } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n            addExpr(last, p, rhsContext);\n        } else {\n            addExpr(last, p + 1, rhsContext);\n        }\n        return;\n    }\n    cc.startSourceMapping(n);\n    switch(type) {\n        case Token.TRY:\n            {\n                Preconditions.checkState(first.getNext().getType() \u003d\u003d Token.BLOCK \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n                Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                add(\"try\");\n                add(first, Context.PRESERVE_BLOCK);\n                Node catchblock \u003d first.getNext().getFirstChild();\n                if (catchblock !\u003d null) {\n                    add(catchblock);\n                }\n                if (childCount \u003d\u003d 3) {\n                    add(\"finally\");\n                    add(last, Context.PRESERVE_BLOCK);\n                }\n                break;\n            }\n        case Token.CATCH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"catch(\");\n            add(first);\n            add(\")\");\n            add(last, Context.PRESERVE_BLOCK);\n            break;\n        case Token.THROW:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"throw\");\n            add(first);\n            cc.endStatement(true);\n            break;\n        case Token.RETURN:\n            add(\"return\");\n            if (childCount \u003d\u003d 1) {\n                add(first);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 0);\n            }\n            cc.endStatement();\n            break;\n        case Token.VAR:\n            if (first !\u003d null) {\n                add(\"var \");\n                addList(first, false, getContextForNoInOperator(context));\n            }\n            break;\n        case Token.LABEL_NAME:\n            Preconditions.checkState(!n.getString().isEmpty());\n            addIdentifier(n.getString());\n            break;\n        case Token.NAME:\n            if (first \u003d\u003d null || first.getType() \u003d\u003d Token.EMPTY) {\n                addIdentifier(n.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                addIdentifier(n.getString());\n                cc.addOp(\"\u003d\", true);\n                if (first.getType() \u003d\u003d Token.COMMA) {\n                    addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                } else {\n                    addExpr(first, 0, getContextForNoInOperator(context));\n                }\n            }\n            break;\n        case Token.ARRAYLIT:\n            add(\"[\");\n            addArrayList(first);\n            add(\"]\");\n            break;\n        case Token.LP:\n            add(\"(\");\n            addList(first);\n            add(\")\");\n            break;\n        case Token.COMMA:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            addList(first, false, context);\n            break;\n        case Token.NUMBER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            cc.addNumber(n.getDouble());\n            break;\n        case Token.TYPEOF:\n        case Token.VOID:\n        case Token.NOT:\n        case Token.BITNOT:\n        case Token.POS:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                addExpr(first, NodeUtil.precedence(type));\n                break;\n            }\n        case Token.NEG:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                if (n.getFirstChild().getType() \u003d\u003d Token.NUMBER) {\n                    cc.addNumber(-n.getFirstChild().getDouble());\n                } else {\n                    cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                    addExpr(first, NodeUtil.precedence(type));\n                }\n                break;\n            }\n        case Token.HOOK:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                int p \u003d NodeUtil.precedence(type);\n                addLeftExpr(first, p + 1, context);\n                cc.addOp(\"?\", true);\n                addExpr(first.getNext(), 1);\n                cc.addOp(\":\", true);\n                addExpr(last, 1);\n                break;\n            }\n        case Token.REGEXP:\n            if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                throw new Error(\"Expected children to be strings\");\n            }\n            String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n            if (childCount \u003d\u003d 2) {\n                add(regexp + last.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                add(regexp);\n            }\n            break;\n        case Token.GET_REF:\n            add(first);\n            break;\n        case Token.REF_SPECIAL:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first);\n            add(\".\");\n            add((String) n.getProp(Node.NAME_PROP));\n            break;\n        case Token.FUNCTION:\n            if (n.getClass() !\u003d Node.class) {\n                throw new Error(\"Unexpected Node subclass.\");\n            }\n            Preconditions.checkState(childCount \u003d\u003d 3);\n            boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n            if (funcNeedsParens) {\n                add(\"(\");\n            }\n            add(\"function\");\n            add(first);\n            add(first.getNext());\n            add(last, Context.PRESERVE_BLOCK);\n            cc.endFunction(context \u003d\u003d Context.STATEMENT);\n            if (funcNeedsParens) {\n                add(\")\");\n            }\n            break;\n        case Token.GET:\n        case Token.SET:\n            Preconditions.checkState(n.getParent().getType() \u003d\u003d Token.OBJECTLIT);\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            Preconditions.checkState(first.getType() \u003d\u003d Token.FUNCTION);\n            Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n            if (type \u003d\u003d Token.GET) {\n                Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n                add(\"get \");\n            } else {\n                Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n                add(\"set \");\n            }\n            String name \u003d n.getString();\n            Node fn \u003d first;\n            Node parameters \u003d fn.getChildAtIndex(1);\n            Node body \u003d fn.getLastChild();\n            if (!n.isQuotedString() \u0026\u0026 TokenStream.isJSIdentifier(name) \u0026\u0026 NodeUtil.isLatin(name)) {\n                add(name);\n            } else {\n                double d \u003d getSimpleNumber(name);\n                if (!Double.isNaN(d)) {\n                    cc.addNumber(d);\n                } else {\n                    addJsString(n.getString());\n                }\n            }\n            add(parameters);\n            add(body, Context.PRESERVE_BLOCK);\n            break;\n        case Token.SCRIPT:\n        case Token.BLOCK:\n            {\n                if (n.getClass() !\u003d Node.class) {\n                    throw new Error(\"Unexpected Node subclass.\");\n                }\n                boolean preserveBlock \u003d context \u003d\u003d Context.PRESERVE_BLOCK;\n                if (preserveBlock) {\n                    cc.beginBlock();\n                }\n                boolean preferLineBreaks \u003d type \u003d\u003d Token.SCRIPT || (type \u003d\u003d Token.BLOCK \u0026\u0026 !preserveBlock \u0026\u0026 n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.SCRIPT);\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    add(c, Context.STATEMENT);\n                    if (c.getType() \u003d\u003d Token.VAR) {\n                        cc.endStatement();\n                    }\n                    if (c.getType() \u003d\u003d Token.FUNCTION) {\n                        cc.maybeLineBreak();\n                    }\n                    if (preferLineBreaks) {\n                        cc.notePreferredLineBreak();\n                    }\n                }\n                if (preserveBlock) {\n                    cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                }\n                break;\n            }\n        case Token.FOR:\n            if (childCount \u003d\u003d 4) {\n                add(\"for(\");\n                if (first.getType() \u003d\u003d Token.VAR) {\n                    add(first, Context.IN_FOR_INIT_CLAUSE);\n                } else {\n                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                }\n                add(\";\");\n                add(first.getNext());\n                add(\";\");\n                add(first.getNext().getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                add(\"for(\");\n                add(first);\n                add(\"in\");\n                add(first.getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            }\n            break;\n        case Token.DO:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"do\");\n            addNonEmptyStatement(first, Context.OTHER, false);\n            add(\"while(\");\n            add(last);\n            add(\")\");\n            cc.endStatement();\n            break;\n        case Token.WHILE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"while(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.EMPTY:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            break;\n        case Token.GETPROP:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                Preconditions.checkState(last.getType() \u003d\u003d Token.STRING, \"Bad GETPROP: RHS should be STRING\");\n                boolean needsParens \u003d (first.getType() \u003d\u003d Token.NUMBER);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n                if (needsParens) {\n                    add(\")\");\n                }\n                add(\".\");\n                addIdentifier(last.getString());\n                break;\n            }\n        case Token.GETELEM:\n            Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n            addLeftExpr(first, NodeUtil.precedence(type), context);\n            add(\"[\");\n            add(first.getNext());\n            add(\"]\");\n            break;\n        case Token.WITH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"with(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.INC:\n        case Token.DEC:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                if (postProp !\u003d 0) {\n                    addLeftExpr(first, NodeUtil.precedence(type), context);\n                    cc.addOp(o, false);\n                } else {\n                    cc.addOp(o, false);\n                    add(first);\n                }\n                break;\n            }\n        case Token.CALL:\n            if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) \u0026\u0026 NodeUtil.isGet(first)) {\n                add(\"(0,\");\n                addExpr(first, NodeUtil.precedence(Token.COMMA));\n                add(\")\");\n            } else {\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n            }\n            add(\"(\");\n            addList(first.getNext());\n            add(\")\");\n            break;\n        case Token.IF:\n            boolean hasElse \u003d childCount \u003d\u003d 3;\n            boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n            if (ambiguousElseClause) {\n                cc.beginBlock();\n            }\n            add(\"if(\");\n            add(first);\n            add(\")\");\n            if (hasElse) {\n                addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                add(\"else\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n                Preconditions.checkState(childCount \u003d\u003d 2);\n            }\n            if (ambiguousElseClause) {\n                cc.endBlock();\n            }\n            break;\n        case Token.NULL:\n        case Token.THIS:\n        case Token.FALSE:\n        case Token.TRUE:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(Node.tokenToName(type));\n            break;\n        case Token.CONTINUE:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"continue\");\n            if (childCount \u003d\u003d 1) {\n                if (first.getType() !\u003d Token.LABEL_NAME) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.DEBUGGER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"debugger\");\n            cc.endStatement();\n            break;\n        case Token.BREAK:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"break\");\n            if (childCount \u003d\u003d 1) {\n                if (first.getType() !\u003d Token.LABEL_NAME) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.EXPR_VOID:\n            throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n        case Token.EXPR_RESULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first, Context.START_OF_EXPR);\n            cc.endStatement();\n            break;\n        case Token.NEW:\n            add(\"new \");\n            int precedence \u003d NodeUtil.precedence(type);\n            if (NodeUtil.containsType(first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n                precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n            }\n            addExpr(first, precedence);\n            Node next \u003d first.getNext();\n            if (next !\u003d null) {\n                add(\"(\");\n                addList(next);\n                add(\")\");\n            }\n            break;\n        case Token.STRING:\n            if (childCount !\u003d ((n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.OBJECTLIT) ? 1 : 0)) {\n                throw new IllegalStateException(\"Unexpected String children: \" + n.getParent().toStringTree());\n            }\n            addJsString(n.getString());\n            break;\n        case Token.DELPROP:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"delete \");\n            add(first);\n            break;\n        case Token.OBJECTLIT:\n            {\n                boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                add(\"{\");\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    if (c !\u003d first) {\n                        cc.listSeparator();\n                    }\n                    if (c.getType() \u003d\u003d Token.GET || c.getType() \u003d\u003d Token.SET) {\n                        add(c);\n                    } else {\n                        Preconditions.checkState(c.getType() \u003d\u003d Token.STRING);\n                        String key \u003d c.getString();\n                        if (!c.isQuotedString() \u0026\u0026 !TokenStream.isKeyword(key) \u0026\u0026 TokenStream.isJSIdentifier(key) \u0026\u0026 NodeUtil.isLatin(key)) {\n                            add(key);\n                        } else {\n                            double d \u003d getSimpleNumber(key);\n                            if (!Double.isNaN(d)) {\n                                cc.addNumber(d);\n                            } else {\n                                addExpr(c, 1);\n                            }\n                        }\n                        add(\":\");\n                        addExpr(c.getFirstChild(), 1);\n                    }\n                }\n                add(\"}\");\n                if (needsParens) {\n                    add(\")\");\n                }\n                break;\n            }\n        case Token.SWITCH:\n            add(\"switch(\");\n            add(first);\n            add(\")\");\n            cc.beginBlock();\n            addAllSiblings(first.getNext());\n            cc.endBlock(context \u003d\u003d Context.STATEMENT);\n            break;\n        case Token.CASE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"case \");\n            add(first);\n            addCaseBody(last);\n            break;\n        case Token.DEFAULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"default\");\n            addCaseBody(first);\n            break;\n        case Token.LABEL:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            if (first.getType() !\u003d Token.LABEL_NAME) {\n                throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n            }\n            add(first);\n            add(\":\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\n            break;\n        case Token.SETNAME:\n            break;\n        default:\n            throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n    cc.endSourceMapping(n);\n}",
      "path": "src/com/google/javascript/jscomp/CodeGenerator.java",
      "functionStartLine": 85,
      "functionName": "add",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,496 +1,496 @@\n void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n         return;\n     }\n     int type \u003d n.getType();\n     String opstr \u003d NodeUtil.opToStr(type);\n     int childCount \u003d n.getChildCount();\n     Node first \u003d n.getFirstChild();\n     Node last \u003d n.getLastChild();\n     if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n         Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n         int p \u003d NodeUtil.precedence(type);\n         addLeftExpr(first, p, context);\n         cc.addOp(opstr, true);\n         Context rhsContext \u003d getContextForNoInOperator(context);\n         if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n             addExpr(last, p, rhsContext);\n         } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n             addExpr(last, p, rhsContext);\n         } else {\n             addExpr(last, p + 1, rhsContext);\n         }\n         return;\n     }\n     cc.startSourceMapping(n);\n     switch(type) {\n         case Token.TRY:\n             {\n                 Preconditions.checkState(first.getNext().getType() \u003d\u003d Token.BLOCK \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n                 Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                 add(\"try\");\n                 add(first, Context.PRESERVE_BLOCK);\n                 Node catchblock \u003d first.getNext().getFirstChild();\n                 if (catchblock !\u003d null) {\n                     add(catchblock);\n                 }\n                 if (childCount \u003d\u003d 3) {\n                     add(\"finally\");\n                     add(last, Context.PRESERVE_BLOCK);\n                 }\n                 break;\n             }\n         case Token.CATCH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"catch(\");\n             add(first);\n             add(\")\");\n             add(last, Context.PRESERVE_BLOCK);\n             break;\n         case Token.THROW:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"throw\");\n             add(first);\n             cc.endStatement(true);\n             break;\n         case Token.RETURN:\n             add(\"return\");\n             if (childCount \u003d\u003d 1) {\n                 add(first);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 0);\n             }\n             cc.endStatement();\n             break;\n         case Token.VAR:\n             if (first !\u003d null) {\n                 add(\"var \");\n                 addList(first, false, getContextForNoInOperator(context));\n             }\n             break;\n         case Token.LABEL_NAME:\n             Preconditions.checkState(!n.getString().isEmpty());\n             addIdentifier(n.getString());\n             break;\n         case Token.NAME:\n             if (first \u003d\u003d null || first.getType() \u003d\u003d Token.EMPTY) {\n                 addIdentifier(n.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 addIdentifier(n.getString());\n                 cc.addOp(\"\u003d\", true);\n                 if (first.getType() \u003d\u003d Token.COMMA) {\n                     addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                 } else {\n                     addExpr(first, 0, getContextForNoInOperator(context));\n                 }\n             }\n             break;\n         case Token.ARRAYLIT:\n             add(\"[\");\n             addArrayList(first);\n             add(\"]\");\n             break;\n         case Token.LP:\n             add(\"(\");\n             addList(first);\n             add(\")\");\n             break;\n         case Token.COMMA:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             addList(first, false, context);\n             break;\n         case Token.NUMBER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             cc.addNumber(n.getDouble());\n             break;\n         case Token.TYPEOF:\n         case Token.VOID:\n         case Token.NOT:\n         case Token.BITNOT:\n         case Token.POS:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                 addExpr(first, NodeUtil.precedence(type));\n                 break;\n             }\n         case Token.NEG:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 if (n.getFirstChild().getType() \u003d\u003d Token.NUMBER) {\n                     cc.addNumber(-n.getFirstChild().getDouble());\n                 } else {\n                     cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                     addExpr(first, NodeUtil.precedence(type));\n                 }\n                 break;\n             }\n         case Token.HOOK:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 int p \u003d NodeUtil.precedence(type);\n                 addLeftExpr(first, p + 1, context);\n                 cc.addOp(\"?\", true);\n                 addExpr(first.getNext(), 1);\n                 cc.addOp(\":\", true);\n                 addExpr(last, 1);\n                 break;\n             }\n         case Token.REGEXP:\n             if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                 throw new Error(\"Expected children to be strings\");\n             }\n             String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n             if (childCount \u003d\u003d 2) {\n                 add(regexp + last.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 add(regexp);\n             }\n             break;\n         case Token.GET_REF:\n             add(first);\n             break;\n         case Token.REF_SPECIAL:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first);\n             add(\".\");\n             add((String) n.getProp(Node.NAME_PROP));\n             break;\n         case Token.FUNCTION:\n             if (n.getClass() !\u003d Node.class) {\n                 throw new Error(\"Unexpected Node subclass.\");\n             }\n             Preconditions.checkState(childCount \u003d\u003d 3);\n             boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n             if (funcNeedsParens) {\n                 add(\"(\");\n             }\n             add(\"function\");\n             add(first);\n             add(first.getNext());\n             add(last, Context.PRESERVE_BLOCK);\n             cc.endFunction(context \u003d\u003d Context.STATEMENT);\n             if (funcNeedsParens) {\n                 add(\")\");\n             }\n             break;\n         case Token.GET:\n         case Token.SET:\n             Preconditions.checkState(n.getParent().getType() \u003d\u003d Token.OBJECTLIT);\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             Preconditions.checkState(first.getType() \u003d\u003d Token.FUNCTION);\n             Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n             if (type \u003d\u003d Token.GET) {\n                 Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n                 add(\"get \");\n             } else {\n                 Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n                 add(\"set \");\n             }\n             String name \u003d n.getString();\n             Node fn \u003d first;\n             Node parameters \u003d fn.getChildAtIndex(1);\n             Node body \u003d fn.getLastChild();\n             if (!n.isQuotedString() \u0026\u0026 TokenStream.isJSIdentifier(name) \u0026\u0026 NodeUtil.isLatin(name)) {\n                 add(name);\n             } else {\n                 double d \u003d getSimpleNumber(name);\n                 if (!Double.isNaN(d)) {\n                     cc.addNumber(d);\n                 } else {\n                     addJsString(n.getString());\n                 }\n             }\n             add(parameters);\n             add(body, Context.PRESERVE_BLOCK);\n             break;\n         case Token.SCRIPT:\n         case Token.BLOCK:\n             {\n                 if (n.getClass() !\u003d Node.class) {\n                     throw new Error(\"Unexpected Node subclass.\");\n                 }\n                 boolean preserveBlock \u003d context \u003d\u003d Context.PRESERVE_BLOCK;\n                 if (preserveBlock) {\n                     cc.beginBlock();\n                 }\n                 boolean preferLineBreaks \u003d type \u003d\u003d Token.SCRIPT || (type \u003d\u003d Token.BLOCK \u0026\u0026 !preserveBlock \u0026\u0026 n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.SCRIPT);\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     add(c, Context.STATEMENT);\n                     if (c.getType() \u003d\u003d Token.VAR) {\n                         cc.endStatement();\n                     }\n                     if (c.getType() \u003d\u003d Token.FUNCTION) {\n                         cc.maybeLineBreak();\n                     }\n                     if (preferLineBreaks) {\n                         cc.notePreferredLineBreak();\n                     }\n                 }\n                 if (preserveBlock) {\n                     cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                 }\n                 break;\n             }\n         case Token.FOR:\n             if (childCount \u003d\u003d 4) {\n                 add(\"for(\");\n                 if (first.getType() \u003d\u003d Token.VAR) {\n                     add(first, Context.IN_FOR_INIT_CLAUSE);\n                 } else {\n                     addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                 }\n                 add(\";\");\n                 add(first.getNext());\n                 add(\";\");\n                 add(first.getNext().getNext());\n                 add(\")\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 add(\"for(\");\n                 add(first);\n                 add(\"in\");\n                 add(first.getNext());\n                 add(\")\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             }\n             break;\n         case Token.DO:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"do\");\n             addNonEmptyStatement(first, Context.OTHER, false);\n             add(\"while(\");\n             add(last);\n             add(\")\");\n             cc.endStatement();\n             break;\n         case Token.WHILE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"while(\");\n             add(first);\n             add(\")\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.EMPTY:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             break;\n         case Token.GETPROP:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                 Preconditions.checkState(last.getType() \u003d\u003d Token.STRING, \"Bad GETPROP: RHS should be STRING\");\n                 boolean needsParens \u003d (first.getType() \u003d\u003d Token.NUMBER);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 add(\".\");\n                 addIdentifier(last.getString());\n                 break;\n             }\n         case Token.GETELEM:\n             Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n             addLeftExpr(first, NodeUtil.precedence(type), context);\n             add(\"[\");\n             add(first.getNext());\n             add(\"]\");\n             break;\n         case Token.WITH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"with(\");\n             add(first);\n             add(\")\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.INC:\n         case Token.DEC:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                 int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                 if (postProp !\u003d 0) {\n                     addLeftExpr(first, NodeUtil.precedence(type), context);\n                     cc.addOp(o, false);\n                 } else {\n                     cc.addOp(o, false);\n                     add(first);\n                 }\n                 break;\n             }\n         case Token.CALL:\n             if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) \u0026\u0026 NodeUtil.isGet(first)) {\n                 add(\"(0,\");\n                 addExpr(first, NodeUtil.precedence(Token.COMMA));\n                 add(\")\");\n             } else {\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n             }\n             add(\"(\");\n             addList(first.getNext());\n             add(\")\");\n             break;\n         case Token.IF:\n             boolean hasElse \u003d childCount \u003d\u003d 3;\n             boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n             if (ambiguousElseClause) {\n                 cc.beginBlock();\n             }\n             add(\"if(\");\n             add(first);\n             add(\")\");\n             if (hasElse) {\n                 addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                 add(\"else\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n                 Preconditions.checkState(childCount \u003d\u003d 2);\n             }\n             if (ambiguousElseClause) {\n                 cc.endBlock();\n             }\n             break;\n         case Token.NULL:\n         case Token.THIS:\n         case Token.FALSE:\n         case Token.TRUE:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(Node.tokenToName(type));\n             break;\n         case Token.CONTINUE:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"continue\");\n             if (childCount \u003d\u003d 1) {\n                 if (first.getType() !\u003d Token.LABEL_NAME) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.DEBUGGER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(\"debugger\");\n             cc.endStatement();\n             break;\n         case Token.BREAK:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"break\");\n             if (childCount \u003d\u003d 1) {\n                 if (first.getType() !\u003d Token.LABEL_NAME) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.EXPR_VOID:\n             throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n         case Token.EXPR_RESULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first, Context.START_OF_EXPR);\n             cc.endStatement();\n             break;\n         case Token.NEW:\n             add(\"new \");\n             int precedence \u003d NodeUtil.precedence(type);\n-            if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction())) {\n+            if (NodeUtil.containsType(first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n                 precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n             }\n             addExpr(first, precedence);\n             Node next \u003d first.getNext();\n             if (next !\u003d null) {\n                 add(\"(\");\n                 addList(next);\n                 add(\")\");\n             }\n             break;\n         case Token.STRING:\n             if (childCount !\u003d ((n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.OBJECTLIT) ? 1 : 0)) {\n                 throw new IllegalStateException(\"Unexpected String children: \" + n.getParent().toStringTree());\n             }\n             addJsString(n.getString());\n             break;\n         case Token.DELPROP:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"delete \");\n             add(first);\n             break;\n         case Token.OBJECTLIT:\n             {\n                 boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 add(\"{\");\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     if (c !\u003d first) {\n                         cc.listSeparator();\n                     }\n                     if (c.getType() \u003d\u003d Token.GET || c.getType() \u003d\u003d Token.SET) {\n                         add(c);\n                     } else {\n                         Preconditions.checkState(c.getType() \u003d\u003d Token.STRING);\n                         String key \u003d c.getString();\n                         if (!c.isQuotedString() \u0026\u0026 !TokenStream.isKeyword(key) \u0026\u0026 TokenStream.isJSIdentifier(key) \u0026\u0026 NodeUtil.isLatin(key)) {\n                             add(key);\n                         } else {\n                             double d \u003d getSimpleNumber(key);\n                             if (!Double.isNaN(d)) {\n                                 cc.addNumber(d);\n                             } else {\n                                 addExpr(c, 1);\n                             }\n                         }\n                         add(\":\");\n                         addExpr(c.getFirstChild(), 1);\n                     }\n                 }\n                 add(\"}\");\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 break;\n             }\n         case Token.SWITCH:\n             add(\"switch(\");\n             add(first);\n             add(\")\");\n             cc.beginBlock();\n             addAllSiblings(first.getNext());\n             cc.endBlock(context \u003d\u003d Context.STATEMENT);\n             break;\n         case Token.CASE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"case \");\n             add(first);\n             addCaseBody(last);\n             break;\n         case Token.DEFAULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"default\");\n             addCaseBody(first);\n             break;\n         case Token.LABEL:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             if (first.getType() !\u003d Token.LABEL_NAME) {\n                 throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n             }\n             add(first);\n             add(\":\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\n             break;\n         case Token.SETNAME:\n             break;\n         default:\n             throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n     }\n     cc.endSourceMapping(n);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f78951b324be6cb453ebbefcb30ab83328282590": {
      "type": "Ybodychange",
      "commitMessage": "\nspeed up code generation by about 10%\n\nR\u003djohnlenz\nDELTA\u003d29  (26 added, 0 deleted, 3 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d1914\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1102 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "5/16/11, 8:40 AM",
      "commitName": "f78951b324be6cb453ebbefcb30ab83328282590",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "4/18/11, 4:27 PM",
      "commitNameOld": "da36f250f9452743dbf0859af86312b844c0d0bd",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 27.68,
      "commitsBetweenForRepo": 81,
      "commitsBetweenForFile": 1,
      "actualSource": "void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n        return;\n    }\n    int type \u003d n.getType();\n    String opstr \u003d NodeUtil.opToStr(type);\n    int childCount \u003d n.getChildCount();\n    Node first \u003d n.getFirstChild();\n    Node last \u003d n.getLastChild();\n    if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n        Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n        int p \u003d NodeUtil.precedence(type);\n        addLeftExpr(first, p, context);\n        cc.addOp(opstr, true);\n        Context rhsContext \u003d getContextForNoInOperator(context);\n        if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n            addExpr(last, p, rhsContext);\n        } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n            addExpr(last, p, rhsContext);\n        } else {\n            addExpr(last, p + 1, rhsContext);\n        }\n        return;\n    }\n    cc.startSourceMapping(n);\n    switch(type) {\n        case Token.TRY:\n            {\n                Preconditions.checkState(first.getNext().getType() \u003d\u003d Token.BLOCK \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n                Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                add(\"try\");\n                add(first, Context.PRESERVE_BLOCK);\n                Node catchblock \u003d first.getNext().getFirstChild();\n                if (catchblock !\u003d null) {\n                    add(catchblock);\n                }\n                if (childCount \u003d\u003d 3) {\n                    add(\"finally\");\n                    add(last, Context.PRESERVE_BLOCK);\n                }\n                break;\n            }\n        case Token.CATCH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"catch(\");\n            add(first);\n            add(\")\");\n            add(last, Context.PRESERVE_BLOCK);\n            break;\n        case Token.THROW:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"throw\");\n            add(first);\n            cc.endStatement(true);\n            break;\n        case Token.RETURN:\n            add(\"return\");\n            if (childCount \u003d\u003d 1) {\n                add(first);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 0);\n            }\n            cc.endStatement();\n            break;\n        case Token.VAR:\n            if (first !\u003d null) {\n                add(\"var \");\n                addList(first, false, getContextForNoInOperator(context));\n            }\n            break;\n        case Token.LABEL_NAME:\n            Preconditions.checkState(!n.getString().isEmpty());\n            addIdentifier(n.getString());\n            break;\n        case Token.NAME:\n            if (first \u003d\u003d null || first.getType() \u003d\u003d Token.EMPTY) {\n                addIdentifier(n.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                addIdentifier(n.getString());\n                cc.addOp(\"\u003d\", true);\n                if (first.getType() \u003d\u003d Token.COMMA) {\n                    addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                } else {\n                    addExpr(first, 0, getContextForNoInOperator(context));\n                }\n            }\n            break;\n        case Token.ARRAYLIT:\n            add(\"[\");\n            addArrayList(first);\n            add(\"]\");\n            break;\n        case Token.LP:\n            add(\"(\");\n            addList(first);\n            add(\")\");\n            break;\n        case Token.COMMA:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            addList(first, false, context);\n            break;\n        case Token.NUMBER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            cc.addNumber(n.getDouble());\n            break;\n        case Token.TYPEOF:\n        case Token.VOID:\n        case Token.NOT:\n        case Token.BITNOT:\n        case Token.POS:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                addExpr(first, NodeUtil.precedence(type));\n                break;\n            }\n        case Token.NEG:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                if (n.getFirstChild().getType() \u003d\u003d Token.NUMBER) {\n                    cc.addNumber(-n.getFirstChild().getDouble());\n                } else {\n                    cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                    addExpr(first, NodeUtil.precedence(type));\n                }\n                break;\n            }\n        case Token.HOOK:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                int p \u003d NodeUtil.precedence(type);\n                addLeftExpr(first, p + 1, context);\n                cc.addOp(\"?\", true);\n                addExpr(first.getNext(), 1);\n                cc.addOp(\":\", true);\n                addExpr(last, 1);\n                break;\n            }\n        case Token.REGEXP:\n            if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                throw new Error(\"Expected children to be strings\");\n            }\n            String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n            if (childCount \u003d\u003d 2) {\n                add(regexp + last.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                add(regexp);\n            }\n            break;\n        case Token.GET_REF:\n            add(first);\n            break;\n        case Token.REF_SPECIAL:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first);\n            add(\".\");\n            add((String) n.getProp(Node.NAME_PROP));\n            break;\n        case Token.FUNCTION:\n            if (n.getClass() !\u003d Node.class) {\n                throw new Error(\"Unexpected Node subclass.\");\n            }\n            Preconditions.checkState(childCount \u003d\u003d 3);\n            boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n            if (funcNeedsParens) {\n                add(\"(\");\n            }\n            add(\"function\");\n            add(first);\n            add(first.getNext());\n            add(last, Context.PRESERVE_BLOCK);\n            cc.endFunction(context \u003d\u003d Context.STATEMENT);\n            if (funcNeedsParens) {\n                add(\")\");\n            }\n            break;\n        case Token.GET:\n        case Token.SET:\n            Preconditions.checkState(n.getParent().getType() \u003d\u003d Token.OBJECTLIT);\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            Preconditions.checkState(first.getType() \u003d\u003d Token.FUNCTION);\n            Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n            if (type \u003d\u003d Token.GET) {\n                Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n                add(\"get \");\n            } else {\n                Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n                add(\"set \");\n            }\n            String name \u003d n.getString();\n            Node fn \u003d first;\n            Node parameters \u003d fn.getChildAtIndex(1);\n            Node body \u003d fn.getLastChild();\n            if (!n.isQuotedString() \u0026\u0026 TokenStream.isJSIdentifier(name) \u0026\u0026 NodeUtil.isLatin(name)) {\n                add(name);\n            } else {\n                double d \u003d getSimpleNumber(name);\n                if (!Double.isNaN(d)) {\n                    cc.addNumber(d);\n                } else {\n                    addJsString(n.getString());\n                }\n            }\n            add(parameters);\n            add(body, Context.PRESERVE_BLOCK);\n            break;\n        case Token.SCRIPT:\n        case Token.BLOCK:\n            {\n                if (n.getClass() !\u003d Node.class) {\n                    throw new Error(\"Unexpected Node subclass.\");\n                }\n                boolean preserveBlock \u003d context \u003d\u003d Context.PRESERVE_BLOCK;\n                if (preserveBlock) {\n                    cc.beginBlock();\n                }\n                boolean preferLineBreaks \u003d type \u003d\u003d Token.SCRIPT || (type \u003d\u003d Token.BLOCK \u0026\u0026 !preserveBlock \u0026\u0026 n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.SCRIPT);\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    add(c, Context.STATEMENT);\n                    if (c.getType() \u003d\u003d Token.VAR) {\n                        cc.endStatement();\n                    }\n                    if (c.getType() \u003d\u003d Token.FUNCTION) {\n                        cc.maybeLineBreak();\n                    }\n                    if (preferLineBreaks) {\n                        cc.notePreferredLineBreak();\n                    }\n                }\n                if (preserveBlock) {\n                    cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                }\n                break;\n            }\n        case Token.FOR:\n            if (childCount \u003d\u003d 4) {\n                add(\"for(\");\n                if (first.getType() \u003d\u003d Token.VAR) {\n                    add(first, Context.IN_FOR_INIT_CLAUSE);\n                } else {\n                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                }\n                add(\";\");\n                add(first.getNext());\n                add(\";\");\n                add(first.getNext().getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                add(\"for(\");\n                add(first);\n                add(\"in\");\n                add(first.getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            }\n            break;\n        case Token.DO:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"do\");\n            addNonEmptyStatement(first, Context.OTHER, false);\n            add(\"while(\");\n            add(last);\n            add(\")\");\n            cc.endStatement();\n            break;\n        case Token.WHILE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"while(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.EMPTY:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            break;\n        case Token.GETPROP:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                Preconditions.checkState(last.getType() \u003d\u003d Token.STRING, \"Bad GETPROP: RHS should be STRING\");\n                boolean needsParens \u003d (first.getType() \u003d\u003d Token.NUMBER);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n                if (needsParens) {\n                    add(\")\");\n                }\n                add(\".\");\n                addIdentifier(last.getString());\n                break;\n            }\n        case Token.GETELEM:\n            Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n            addLeftExpr(first, NodeUtil.precedence(type), context);\n            add(\"[\");\n            add(first.getNext());\n            add(\"]\");\n            break;\n        case Token.WITH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"with(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.INC:\n        case Token.DEC:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                if (postProp !\u003d 0) {\n                    addLeftExpr(first, NodeUtil.precedence(type), context);\n                    cc.addOp(o, false);\n                } else {\n                    cc.addOp(o, false);\n                    add(first);\n                }\n                break;\n            }\n        case Token.CALL:\n            if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) \u0026\u0026 NodeUtil.isGet(first)) {\n                add(\"(0,\");\n                addExpr(first, NodeUtil.precedence(Token.COMMA));\n                add(\")\");\n            } else {\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n            }\n            add(\"(\");\n            addList(first.getNext());\n            add(\")\");\n            break;\n        case Token.IF:\n            boolean hasElse \u003d childCount \u003d\u003d 3;\n            boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n            if (ambiguousElseClause) {\n                cc.beginBlock();\n            }\n            add(\"if(\");\n            add(first);\n            add(\")\");\n            if (hasElse) {\n                addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                add(\"else\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n                Preconditions.checkState(childCount \u003d\u003d 2);\n            }\n            if (ambiguousElseClause) {\n                cc.endBlock();\n            }\n            break;\n        case Token.NULL:\n        case Token.THIS:\n        case Token.FALSE:\n        case Token.TRUE:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(Node.tokenToName(type));\n            break;\n        case Token.CONTINUE:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"continue\");\n            if (childCount \u003d\u003d 1) {\n                if (first.getType() !\u003d Token.LABEL_NAME) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.DEBUGGER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"debugger\");\n            cc.endStatement();\n            break;\n        case Token.BREAK:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"break\");\n            if (childCount \u003d\u003d 1) {\n                if (first.getType() !\u003d Token.LABEL_NAME) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.EXPR_VOID:\n            throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n        case Token.EXPR_RESULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first, Context.START_OF_EXPR);\n            cc.endStatement();\n            break;\n        case Token.NEW:\n            add(\"new \");\n            int precedence \u003d NodeUtil.precedence(type);\n            if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction())) {\n                precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n            }\n            addExpr(first, precedence);\n            Node next \u003d first.getNext();\n            if (next !\u003d null) {\n                add(\"(\");\n                addList(next);\n                add(\")\");\n            }\n            break;\n        case Token.STRING:\n            if (childCount !\u003d ((n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.OBJECTLIT) ? 1 : 0)) {\n                throw new IllegalStateException(\"Unexpected String children: \" + n.getParent().toStringTree());\n            }\n            addJsString(n.getString());\n            break;\n        case Token.DELPROP:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"delete \");\n            add(first);\n            break;\n        case Token.OBJECTLIT:\n            {\n                boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                add(\"{\");\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    if (c !\u003d first) {\n                        cc.listSeparator();\n                    }\n                    if (c.getType() \u003d\u003d Token.GET || c.getType() \u003d\u003d Token.SET) {\n                        add(c);\n                    } else {\n                        Preconditions.checkState(c.getType() \u003d\u003d Token.STRING);\n                        String key \u003d c.getString();\n                        if (!c.isQuotedString() \u0026\u0026 !TokenStream.isKeyword(key) \u0026\u0026 TokenStream.isJSIdentifier(key) \u0026\u0026 NodeUtil.isLatin(key)) {\n                            add(key);\n                        } else {\n                            double d \u003d getSimpleNumber(key);\n                            if (!Double.isNaN(d)) {\n                                cc.addNumber(d);\n                            } else {\n                                addExpr(c, 1);\n                            }\n                        }\n                        add(\":\");\n                        addExpr(c.getFirstChild(), 1);\n                    }\n                }\n                add(\"}\");\n                if (needsParens) {\n                    add(\")\");\n                }\n                break;\n            }\n        case Token.SWITCH:\n            add(\"switch(\");\n            add(first);\n            add(\")\");\n            cc.beginBlock();\n            addAllSiblings(first.getNext());\n            cc.endBlock(context \u003d\u003d Context.STATEMENT);\n            break;\n        case Token.CASE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"case \");\n            add(first);\n            addCaseBody(last);\n            break;\n        case Token.DEFAULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"default\");\n            addCaseBody(first);\n            break;\n        case Token.LABEL:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            if (first.getType() !\u003d Token.LABEL_NAME) {\n                throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n            }\n            add(first);\n            add(\":\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\n            break;\n        case Token.SETNAME:\n            break;\n        default:\n            throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n    cc.endSourceMapping(n);\n}",
      "path": "src/com/google/javascript/jscomp/CodeGenerator.java",
      "functionStartLine": 86,
      "functionName": "add",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,496 +1,496 @@\n void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n         return;\n     }\n     int type \u003d n.getType();\n     String opstr \u003d NodeUtil.opToStr(type);\n     int childCount \u003d n.getChildCount();\n     Node first \u003d n.getFirstChild();\n     Node last \u003d n.getLastChild();\n     if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n         Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n         int p \u003d NodeUtil.precedence(type);\n         addLeftExpr(first, p, context);\n         cc.addOp(opstr, true);\n         Context rhsContext \u003d getContextForNoInOperator(context);\n         if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n             addExpr(last, p, rhsContext);\n         } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n             addExpr(last, p, rhsContext);\n         } else {\n             addExpr(last, p + 1, rhsContext);\n         }\n         return;\n     }\n     cc.startSourceMapping(n);\n     switch(type) {\n         case Token.TRY:\n             {\n                 Preconditions.checkState(first.getNext().getType() \u003d\u003d Token.BLOCK \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n                 Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                 add(\"try\");\n                 add(first, Context.PRESERVE_BLOCK);\n                 Node catchblock \u003d first.getNext().getFirstChild();\n                 if (catchblock !\u003d null) {\n                     add(catchblock);\n                 }\n                 if (childCount \u003d\u003d 3) {\n                     add(\"finally\");\n                     add(last, Context.PRESERVE_BLOCK);\n                 }\n                 break;\n             }\n         case Token.CATCH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"catch(\");\n             add(first);\n             add(\")\");\n             add(last, Context.PRESERVE_BLOCK);\n             break;\n         case Token.THROW:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"throw\");\n             add(first);\n             cc.endStatement(true);\n             break;\n         case Token.RETURN:\n             add(\"return\");\n             if (childCount \u003d\u003d 1) {\n                 add(first);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 0);\n             }\n             cc.endStatement();\n             break;\n         case Token.VAR:\n             if (first !\u003d null) {\n                 add(\"var \");\n                 addList(first, false, getContextForNoInOperator(context));\n             }\n             break;\n         case Token.LABEL_NAME:\n             Preconditions.checkState(!n.getString().isEmpty());\n             addIdentifier(n.getString());\n             break;\n         case Token.NAME:\n             if (first \u003d\u003d null || first.getType() \u003d\u003d Token.EMPTY) {\n                 addIdentifier(n.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 addIdentifier(n.getString());\n                 cc.addOp(\"\u003d\", true);\n                 if (first.getType() \u003d\u003d Token.COMMA) {\n                     addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                 } else {\n                     addExpr(first, 0, getContextForNoInOperator(context));\n                 }\n             }\n             break;\n         case Token.ARRAYLIT:\n             add(\"[\");\n             addArrayList(first);\n             add(\"]\");\n             break;\n         case Token.LP:\n             add(\"(\");\n             addList(first);\n             add(\")\");\n             break;\n         case Token.COMMA:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             addList(first, false, context);\n             break;\n         case Token.NUMBER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             cc.addNumber(n.getDouble());\n             break;\n         case Token.TYPEOF:\n         case Token.VOID:\n         case Token.NOT:\n         case Token.BITNOT:\n         case Token.POS:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                 addExpr(first, NodeUtil.precedence(type));\n                 break;\n             }\n         case Token.NEG:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 if (n.getFirstChild().getType() \u003d\u003d Token.NUMBER) {\n                     cc.addNumber(-n.getFirstChild().getDouble());\n                 } else {\n                     cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                     addExpr(first, NodeUtil.precedence(type));\n                 }\n                 break;\n             }\n         case Token.HOOK:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 int p \u003d NodeUtil.precedence(type);\n                 addLeftExpr(first, p + 1, context);\n                 cc.addOp(\"?\", true);\n                 addExpr(first.getNext(), 1);\n                 cc.addOp(\":\", true);\n                 addExpr(last, 1);\n                 break;\n             }\n         case Token.REGEXP:\n             if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                 throw new Error(\"Expected children to be strings\");\n             }\n             String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n             if (childCount \u003d\u003d 2) {\n                 add(regexp + last.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 add(regexp);\n             }\n             break;\n         case Token.GET_REF:\n             add(first);\n             break;\n         case Token.REF_SPECIAL:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first);\n             add(\".\");\n             add((String) n.getProp(Node.NAME_PROP));\n             break;\n         case Token.FUNCTION:\n             if (n.getClass() !\u003d Node.class) {\n                 throw new Error(\"Unexpected Node subclass.\");\n             }\n             Preconditions.checkState(childCount \u003d\u003d 3);\n             boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n             if (funcNeedsParens) {\n                 add(\"(\");\n             }\n             add(\"function\");\n             add(first);\n             add(first.getNext());\n             add(last, Context.PRESERVE_BLOCK);\n             cc.endFunction(context \u003d\u003d Context.STATEMENT);\n             if (funcNeedsParens) {\n                 add(\")\");\n             }\n             break;\n         case Token.GET:\n         case Token.SET:\n             Preconditions.checkState(n.getParent().getType() \u003d\u003d Token.OBJECTLIT);\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             Preconditions.checkState(first.getType() \u003d\u003d Token.FUNCTION);\n             Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n             if (type \u003d\u003d Token.GET) {\n                 Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n                 add(\"get \");\n             } else {\n                 Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n                 add(\"set \");\n             }\n             String name \u003d n.getString();\n             Node fn \u003d first;\n             Node parameters \u003d fn.getChildAtIndex(1);\n             Node body \u003d fn.getLastChild();\n             if (!n.isQuotedString() \u0026\u0026 TokenStream.isJSIdentifier(name) \u0026\u0026 NodeUtil.isLatin(name)) {\n                 add(name);\n             } else {\n                 double d \u003d getSimpleNumber(name);\n                 if (!Double.isNaN(d)) {\n                     cc.addNumber(d);\n                 } else {\n-                    add(jsString(n.getString(), outputCharsetEncoder));\n+                    addJsString(n.getString());\n                 }\n             }\n             add(parameters);\n             add(body, Context.PRESERVE_BLOCK);\n             break;\n         case Token.SCRIPT:\n         case Token.BLOCK:\n             {\n                 if (n.getClass() !\u003d Node.class) {\n                     throw new Error(\"Unexpected Node subclass.\");\n                 }\n                 boolean preserveBlock \u003d context \u003d\u003d Context.PRESERVE_BLOCK;\n                 if (preserveBlock) {\n                     cc.beginBlock();\n                 }\n                 boolean preferLineBreaks \u003d type \u003d\u003d Token.SCRIPT || (type \u003d\u003d Token.BLOCK \u0026\u0026 !preserveBlock \u0026\u0026 n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.SCRIPT);\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     add(c, Context.STATEMENT);\n                     if (c.getType() \u003d\u003d Token.VAR) {\n                         cc.endStatement();\n                     }\n                     if (c.getType() \u003d\u003d Token.FUNCTION) {\n                         cc.maybeLineBreak();\n                     }\n                     if (preferLineBreaks) {\n                         cc.notePreferredLineBreak();\n                     }\n                 }\n                 if (preserveBlock) {\n                     cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                 }\n                 break;\n             }\n         case Token.FOR:\n             if (childCount \u003d\u003d 4) {\n                 add(\"for(\");\n                 if (first.getType() \u003d\u003d Token.VAR) {\n                     add(first, Context.IN_FOR_INIT_CLAUSE);\n                 } else {\n                     addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                 }\n                 add(\";\");\n                 add(first.getNext());\n                 add(\";\");\n                 add(first.getNext().getNext());\n                 add(\")\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 add(\"for(\");\n                 add(first);\n                 add(\"in\");\n                 add(first.getNext());\n                 add(\")\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             }\n             break;\n         case Token.DO:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"do\");\n             addNonEmptyStatement(first, Context.OTHER, false);\n             add(\"while(\");\n             add(last);\n             add(\")\");\n             cc.endStatement();\n             break;\n         case Token.WHILE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"while(\");\n             add(first);\n             add(\")\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.EMPTY:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             break;\n         case Token.GETPROP:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                 Preconditions.checkState(last.getType() \u003d\u003d Token.STRING, \"Bad GETPROP: RHS should be STRING\");\n                 boolean needsParens \u003d (first.getType() \u003d\u003d Token.NUMBER);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 add(\".\");\n                 addIdentifier(last.getString());\n                 break;\n             }\n         case Token.GETELEM:\n             Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n             addLeftExpr(first, NodeUtil.precedence(type), context);\n             add(\"[\");\n             add(first.getNext());\n             add(\"]\");\n             break;\n         case Token.WITH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"with(\");\n             add(first);\n             add(\")\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.INC:\n         case Token.DEC:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                 int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                 if (postProp !\u003d 0) {\n                     addLeftExpr(first, NodeUtil.precedence(type), context);\n                     cc.addOp(o, false);\n                 } else {\n                     cc.addOp(o, false);\n                     add(first);\n                 }\n                 break;\n             }\n         case Token.CALL:\n             if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) \u0026\u0026 NodeUtil.isGet(first)) {\n                 add(\"(0,\");\n                 addExpr(first, NodeUtil.precedence(Token.COMMA));\n                 add(\")\");\n             } else {\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n             }\n             add(\"(\");\n             addList(first.getNext());\n             add(\")\");\n             break;\n         case Token.IF:\n             boolean hasElse \u003d childCount \u003d\u003d 3;\n             boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n             if (ambiguousElseClause) {\n                 cc.beginBlock();\n             }\n             add(\"if(\");\n             add(first);\n             add(\")\");\n             if (hasElse) {\n                 addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                 add(\"else\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n                 Preconditions.checkState(childCount \u003d\u003d 2);\n             }\n             if (ambiguousElseClause) {\n                 cc.endBlock();\n             }\n             break;\n         case Token.NULL:\n         case Token.THIS:\n         case Token.FALSE:\n         case Token.TRUE:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(Node.tokenToName(type));\n             break;\n         case Token.CONTINUE:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"continue\");\n             if (childCount \u003d\u003d 1) {\n                 if (first.getType() !\u003d Token.LABEL_NAME) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.DEBUGGER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(\"debugger\");\n             cc.endStatement();\n             break;\n         case Token.BREAK:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"break\");\n             if (childCount \u003d\u003d 1) {\n                 if (first.getType() !\u003d Token.LABEL_NAME) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.EXPR_VOID:\n             throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n         case Token.EXPR_RESULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first, Context.START_OF_EXPR);\n             cc.endStatement();\n             break;\n         case Token.NEW:\n             add(\"new \");\n             int precedence \u003d NodeUtil.precedence(type);\n             if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction())) {\n                 precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n             }\n             addExpr(first, precedence);\n             Node next \u003d first.getNext();\n             if (next !\u003d null) {\n                 add(\"(\");\n                 addList(next);\n                 add(\")\");\n             }\n             break;\n         case Token.STRING:\n             if (childCount !\u003d ((n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.OBJECTLIT) ? 1 : 0)) {\n                 throw new IllegalStateException(\"Unexpected String children: \" + n.getParent().toStringTree());\n             }\n-            add(jsString(n.getString(), outputCharsetEncoder));\n+            addJsString(n.getString());\n             break;\n         case Token.DELPROP:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"delete \");\n             add(first);\n             break;\n         case Token.OBJECTLIT:\n             {\n                 boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 add(\"{\");\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     if (c !\u003d first) {\n                         cc.listSeparator();\n                     }\n                     if (c.getType() \u003d\u003d Token.GET || c.getType() \u003d\u003d Token.SET) {\n                         add(c);\n                     } else {\n                         Preconditions.checkState(c.getType() \u003d\u003d Token.STRING);\n                         String key \u003d c.getString();\n                         if (!c.isQuotedString() \u0026\u0026 !TokenStream.isKeyword(key) \u0026\u0026 TokenStream.isJSIdentifier(key) \u0026\u0026 NodeUtil.isLatin(key)) {\n                             add(key);\n                         } else {\n                             double d \u003d getSimpleNumber(key);\n                             if (!Double.isNaN(d)) {\n                                 cc.addNumber(d);\n                             } else {\n                                 addExpr(c, 1);\n                             }\n                         }\n                         add(\":\");\n                         addExpr(c.getFirstChild(), 1);\n                     }\n                 }\n                 add(\"}\");\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 break;\n             }\n         case Token.SWITCH:\n             add(\"switch(\");\n             add(first);\n             add(\")\");\n             cc.beginBlock();\n             addAllSiblings(first.getNext());\n             cc.endBlock(context \u003d\u003d Context.STATEMENT);\n             break;\n         case Token.CASE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"case \");\n             add(first);\n             addCaseBody(last);\n             break;\n         case Token.DEFAULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"default\");\n             addCaseBody(first);\n             break;\n         case Token.LABEL:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             if (first.getType() !\u003d Token.LABEL_NAME) {\n                 throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n             }\n             add(first);\n             add(\":\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\n             break;\n         case Token.SETNAME:\n             break;\n         default:\n             throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n     }\n     cc.endSourceMapping(n);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "75aa5f653b08995428743f6951a99ad101e73e37": {
      "type": "Ybodychange",
      "commitMessage": "\nCleanup obsolete handling of NUMBER keys of OBJECTLIT.\n\nR\u003dnicksantos\nDELTA\u003d109  (3 added, 48 deleted, 58 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d1253\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@967 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/4/11, 2:40 PM",
      "commitName": "75aa5f653b08995428743f6951a99ad101e73e37",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "4/4/11, 2:26 PM",
      "commitNameOld": "41acde3e8e5e8d37ade765b41d9fd29861f03e5e",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n        return;\n    }\n    int type \u003d n.getType();\n    String opstr \u003d NodeUtil.opToStr(type);\n    int childCount \u003d n.getChildCount();\n    Node first \u003d n.getFirstChild();\n    Node last \u003d n.getLastChild();\n    if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n        Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n        int p \u003d NodeUtil.precedence(type);\n        addLeftExpr(first, p, context);\n        cc.addOp(opstr, true);\n        Context rhsContext \u003d getContextForNoInOperator(context);\n        if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n            addExpr(last, p, rhsContext);\n        } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n            addExpr(last, p, rhsContext);\n        } else {\n            addExpr(last, p + 1, rhsContext);\n        }\n        return;\n    }\n    cc.startSourceMapping(n);\n    switch(type) {\n        case Token.TRY:\n            {\n                Preconditions.checkState(first.getNext().getType() \u003d\u003d Token.BLOCK \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n                Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                add(\"try\");\n                add(first, Context.PRESERVE_BLOCK);\n                Node catchblock \u003d first.getNext().getFirstChild();\n                if (catchblock !\u003d null) {\n                    add(catchblock);\n                }\n                if (childCount \u003d\u003d 3) {\n                    add(\"finally\");\n                    add(last, Context.PRESERVE_BLOCK);\n                }\n                break;\n            }\n        case Token.CATCH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"catch(\");\n            add(first);\n            add(\")\");\n            add(last, Context.PRESERVE_BLOCK);\n            break;\n        case Token.THROW:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"throw\");\n            add(first);\n            cc.endStatement(true);\n            break;\n        case Token.RETURN:\n            add(\"return\");\n            if (childCount \u003d\u003d 1) {\n                add(first);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 0);\n            }\n            cc.endStatement();\n            break;\n        case Token.VAR:\n            if (first !\u003d null) {\n                add(\"var \");\n                addList(first, false, getContextForNoInOperator(context));\n            }\n            break;\n        case Token.LABEL_NAME:\n            Preconditions.checkState(!n.getString().isEmpty());\n            addIdentifier(n.getString());\n            break;\n        case Token.NAME:\n            if (first \u003d\u003d null || first.getType() \u003d\u003d Token.EMPTY) {\n                addIdentifier(n.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                addIdentifier(n.getString());\n                cc.addOp(\"\u003d\", true);\n                if (first.getType() \u003d\u003d Token.COMMA) {\n                    addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                } else {\n                    addExpr(first, 0, getContextForNoInOperator(context));\n                }\n            }\n            break;\n        case Token.ARRAYLIT:\n            add(\"[\");\n            addArrayList(first);\n            add(\"]\");\n            break;\n        case Token.LP:\n            add(\"(\");\n            addList(first);\n            add(\")\");\n            break;\n        case Token.COMMA:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            addList(first, false, context);\n            break;\n        case Token.NUMBER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            cc.addNumber(n.getDouble());\n            break;\n        case Token.TYPEOF:\n        case Token.VOID:\n        case Token.NOT:\n        case Token.BITNOT:\n        case Token.POS:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                addExpr(first, NodeUtil.precedence(type));\n                break;\n            }\n        case Token.NEG:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                if (n.getFirstChild().getType() \u003d\u003d Token.NUMBER) {\n                    cc.addNumber(-n.getFirstChild().getDouble());\n                } else {\n                    cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                    addExpr(first, NodeUtil.precedence(type));\n                }\n                break;\n            }\n        case Token.HOOK:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                int p \u003d NodeUtil.precedence(type);\n                addLeftExpr(first, p + 1, context);\n                cc.addOp(\"?\", true);\n                addExpr(first.getNext(), 1);\n                cc.addOp(\":\", true);\n                addExpr(last, 1);\n                break;\n            }\n        case Token.REGEXP:\n            if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                throw new Error(\"Expected children to be strings\");\n            }\n            String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n            if (childCount \u003d\u003d 2) {\n                add(regexp + last.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                add(regexp);\n            }\n            break;\n        case Token.GET_REF:\n            add(first);\n            break;\n        case Token.REF_SPECIAL:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first);\n            add(\".\");\n            add((String) n.getProp(Node.NAME_PROP));\n            break;\n        case Token.FUNCTION:\n            if (n.getClass() !\u003d Node.class) {\n                throw new Error(\"Unexpected Node subclass.\");\n            }\n            Preconditions.checkState(childCount \u003d\u003d 3);\n            boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n            if (funcNeedsParens) {\n                add(\"(\");\n            }\n            add(\"function\");\n            add(first);\n            add(first.getNext());\n            add(last, Context.PRESERVE_BLOCK);\n            cc.endFunction(context \u003d\u003d Context.STATEMENT);\n            if (funcNeedsParens) {\n                add(\")\");\n            }\n            break;\n        case Token.GET:\n        case Token.SET:\n            Preconditions.checkState(n.getParent().getType() \u003d\u003d Token.OBJECTLIT);\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            Preconditions.checkState(first.getType() \u003d\u003d Token.FUNCTION);\n            Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n            if (type \u003d\u003d Token.GET) {\n                Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n                add(\"get \");\n            } else {\n                Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n                add(\"set \");\n            }\n            String name \u003d n.getString();\n            Node fn \u003d first;\n            Node parameters \u003d fn.getChildAtIndex(1);\n            Node body \u003d fn.getLastChild();\n            if (!n.isQuotedString() \u0026\u0026 TokenStream.isJSIdentifier(name) \u0026\u0026 NodeUtil.isLatin(name)) {\n                add(name);\n            } else {\n                double d \u003d getSimpleNumber(name);\n                if (!Double.isNaN(d)) {\n                    cc.addNumber(d);\n                } else {\n                    add(jsString(n.getString(), outputCharsetEncoder));\n                }\n            }\n            add(parameters);\n            add(body, Context.PRESERVE_BLOCK);\n            break;\n        case Token.SCRIPT:\n        case Token.BLOCK:\n            {\n                if (n.getClass() !\u003d Node.class) {\n                    throw new Error(\"Unexpected Node subclass.\");\n                }\n                boolean preserveBlock \u003d context \u003d\u003d Context.PRESERVE_BLOCK;\n                if (preserveBlock) {\n                    cc.beginBlock();\n                }\n                boolean preferLineBreaks \u003d type \u003d\u003d Token.SCRIPT || (type \u003d\u003d Token.BLOCK \u0026\u0026 !preserveBlock \u0026\u0026 n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.SCRIPT);\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    add(c, Context.STATEMENT);\n                    if (c.getType() \u003d\u003d Token.VAR) {\n                        cc.endStatement();\n                    }\n                    if (c.getType() \u003d\u003d Token.FUNCTION) {\n                        cc.maybeLineBreak();\n                    }\n                    if (preferLineBreaks) {\n                        cc.notePreferredLineBreak();\n                    }\n                }\n                if (preserveBlock) {\n                    cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                }\n                break;\n            }\n        case Token.FOR:\n            if (childCount \u003d\u003d 4) {\n                add(\"for(\");\n                if (first.getType() \u003d\u003d Token.VAR) {\n                    add(first, Context.IN_FOR_INIT_CLAUSE);\n                } else {\n                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                }\n                add(\";\");\n                add(first.getNext());\n                add(\";\");\n                add(first.getNext().getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                add(\"for(\");\n                add(first);\n                add(\"in\");\n                add(first.getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            }\n            break;\n        case Token.DO:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"do\");\n            addNonEmptyStatement(first, Context.OTHER, false);\n            add(\"while(\");\n            add(last);\n            add(\")\");\n            cc.endStatement();\n            break;\n        case Token.WHILE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"while(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.EMPTY:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            break;\n        case Token.GETPROP:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                Preconditions.checkState(last.getType() \u003d\u003d Token.STRING, \"Bad GETPROP: RHS should be STRING\");\n                boolean needsParens \u003d (first.getType() \u003d\u003d Token.NUMBER);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n                if (needsParens) {\n                    add(\")\");\n                }\n                add(\".\");\n                addIdentifier(last.getString());\n                break;\n            }\n        case Token.GETELEM:\n            Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n            addLeftExpr(first, NodeUtil.precedence(type), context);\n            add(\"[\");\n            add(first.getNext());\n            add(\"]\");\n            break;\n        case Token.WITH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"with(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.INC:\n        case Token.DEC:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                if (postProp !\u003d 0) {\n                    addLeftExpr(first, NodeUtil.precedence(type), context);\n                    cc.addOp(o, false);\n                } else {\n                    cc.addOp(o, false);\n                    add(first);\n                }\n                break;\n            }\n        case Token.CALL:\n            if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) \u0026\u0026 NodeUtil.isGet(first)) {\n                add(\"(0,\");\n                addExpr(first, NodeUtil.precedence(Token.COMMA));\n                add(\")\");\n            } else {\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n            }\n            add(\"(\");\n            addList(first.getNext());\n            add(\")\");\n            break;\n        case Token.IF:\n            boolean hasElse \u003d childCount \u003d\u003d 3;\n            boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n            if (ambiguousElseClause) {\n                cc.beginBlock();\n            }\n            add(\"if(\");\n            add(first);\n            add(\")\");\n            if (hasElse) {\n                addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                add(\"else\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n                Preconditions.checkState(childCount \u003d\u003d 2);\n            }\n            if (ambiguousElseClause) {\n                cc.endBlock();\n            }\n            break;\n        case Token.NULL:\n        case Token.THIS:\n        case Token.FALSE:\n        case Token.TRUE:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(Node.tokenToName(type));\n            break;\n        case Token.CONTINUE:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"continue\");\n            if (childCount \u003d\u003d 1) {\n                if (first.getType() !\u003d Token.LABEL_NAME) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.DEBUGGER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"debugger\");\n            cc.endStatement();\n            break;\n        case Token.BREAK:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"break\");\n            if (childCount \u003d\u003d 1) {\n                if (first.getType() !\u003d Token.LABEL_NAME) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.EXPR_VOID:\n            throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n        case Token.EXPR_RESULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first, Context.START_OF_EXPR);\n            cc.endStatement();\n            break;\n        case Token.NEW:\n            add(\"new \");\n            int precedence \u003d NodeUtil.precedence(type);\n            if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction())) {\n                precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n            }\n            addExpr(first, precedence);\n            Node next \u003d first.getNext();\n            if (next !\u003d null) {\n                add(\"(\");\n                addList(next);\n                add(\")\");\n            }\n            break;\n        case Token.STRING:\n            if (childCount !\u003d ((n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.OBJECTLIT) ? 1 : 0)) {\n                throw new IllegalStateException(\"Unexpected String children: \" + n.getParent().toStringTree());\n            }\n            add(jsString(n.getString(), outputCharsetEncoder));\n            break;\n        case Token.DELPROP:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"delete \");\n            add(first);\n            break;\n        case Token.OBJECTLIT:\n            {\n                boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                add(\"{\");\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    if (c !\u003d first) {\n                        cc.listSeparator();\n                    }\n                    if (c.getType() \u003d\u003d Token.GET || c.getType() \u003d\u003d Token.SET) {\n                        add(c);\n                    } else {\n                        Preconditions.checkState(c.getType() \u003d\u003d Token.STRING);\n                        String key \u003d c.getString();\n                        if (!c.isQuotedString() \u0026\u0026 !TokenStream.isKeyword(key) \u0026\u0026 TokenStream.isJSIdentifier(key) \u0026\u0026 NodeUtil.isLatin(key)) {\n                            add(key);\n                        } else {\n                            double d \u003d getSimpleNumber(key);\n                            if (!Double.isNaN(d)) {\n                                cc.addNumber(d);\n                            } else {\n                                addExpr(c, 1);\n                            }\n                        }\n                        add(\":\");\n                        addExpr(c.getFirstChild(), 1);\n                    }\n                }\n                add(\"}\");\n                if (needsParens) {\n                    add(\")\");\n                }\n                break;\n            }\n        case Token.SWITCH:\n            add(\"switch(\");\n            add(first);\n            add(\")\");\n            cc.beginBlock();\n            addAllSiblings(first.getNext());\n            cc.endBlock(context \u003d\u003d Context.STATEMENT);\n            break;\n        case Token.CASE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"case \");\n            add(first);\n            addCaseBody(last);\n            break;\n        case Token.DEFAULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"default\");\n            addCaseBody(first);\n            break;\n        case Token.LABEL:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            if (first.getType() !\u003d Token.LABEL_NAME) {\n                throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n            }\n            add(first);\n            add(\":\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\n            break;\n        case Token.SETNAME:\n            break;\n        default:\n            throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n    cc.endSourceMapping(n);\n}",
      "path": "src/com/google/javascript/jscomp/CodeGenerator.java",
      "functionStartLine": 82,
      "functionName": "add",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,496 +1,496 @@\n void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n         return;\n     }\n     int type \u003d n.getType();\n     String opstr \u003d NodeUtil.opToStr(type);\n     int childCount \u003d n.getChildCount();\n     Node first \u003d n.getFirstChild();\n     Node last \u003d n.getLastChild();\n     if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n         Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n         int p \u003d NodeUtil.precedence(type);\n         addLeftExpr(first, p, context);\n         cc.addOp(opstr, true);\n         Context rhsContext \u003d getContextForNoInOperator(context);\n         if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n             addExpr(last, p, rhsContext);\n         } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n             addExpr(last, p, rhsContext);\n         } else {\n             addExpr(last, p + 1, rhsContext);\n         }\n         return;\n     }\n     cc.startSourceMapping(n);\n     switch(type) {\n         case Token.TRY:\n             {\n                 Preconditions.checkState(first.getNext().getType() \u003d\u003d Token.BLOCK \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n                 Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                 add(\"try\");\n                 add(first, Context.PRESERVE_BLOCK);\n                 Node catchblock \u003d first.getNext().getFirstChild();\n                 if (catchblock !\u003d null) {\n                     add(catchblock);\n                 }\n                 if (childCount \u003d\u003d 3) {\n                     add(\"finally\");\n                     add(last, Context.PRESERVE_BLOCK);\n                 }\n                 break;\n             }\n         case Token.CATCH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"catch(\");\n             add(first);\n             add(\")\");\n             add(last, Context.PRESERVE_BLOCK);\n             break;\n         case Token.THROW:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"throw\");\n             add(first);\n             cc.endStatement(true);\n             break;\n         case Token.RETURN:\n             add(\"return\");\n             if (childCount \u003d\u003d 1) {\n                 add(first);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 0);\n             }\n             cc.endStatement();\n             break;\n         case Token.VAR:\n             if (first !\u003d null) {\n                 add(\"var \");\n                 addList(first, false, getContextForNoInOperator(context));\n             }\n             break;\n         case Token.LABEL_NAME:\n             Preconditions.checkState(!n.getString().isEmpty());\n             addIdentifier(n.getString());\n             break;\n         case Token.NAME:\n             if (first \u003d\u003d null || first.getType() \u003d\u003d Token.EMPTY) {\n                 addIdentifier(n.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 addIdentifier(n.getString());\n                 cc.addOp(\"\u003d\", true);\n                 if (first.getType() \u003d\u003d Token.COMMA) {\n                     addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                 } else {\n                     addExpr(first, 0, getContextForNoInOperator(context));\n                 }\n             }\n             break;\n         case Token.ARRAYLIT:\n             add(\"[\");\n             addArrayList(first);\n             add(\"]\");\n             break;\n         case Token.LP:\n             add(\"(\");\n             addList(first);\n             add(\")\");\n             break;\n         case Token.COMMA:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             addList(first, false, context);\n             break;\n         case Token.NUMBER:\n-            Preconditions.checkState(childCount \u003d\u003d ((n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.OBJECTLIT) ? 1 : 0));\n+            Preconditions.checkState(childCount \u003d\u003d 0);\n             cc.addNumber(n.getDouble());\n             break;\n         case Token.TYPEOF:\n         case Token.VOID:\n         case Token.NOT:\n         case Token.BITNOT:\n         case Token.POS:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                 addExpr(first, NodeUtil.precedence(type));\n                 break;\n             }\n         case Token.NEG:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 if (n.getFirstChild().getType() \u003d\u003d Token.NUMBER) {\n                     cc.addNumber(-n.getFirstChild().getDouble());\n                 } else {\n                     cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                     addExpr(first, NodeUtil.precedence(type));\n                 }\n                 break;\n             }\n         case Token.HOOK:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 int p \u003d NodeUtil.precedence(type);\n                 addLeftExpr(first, p + 1, context);\n                 cc.addOp(\"?\", true);\n                 addExpr(first.getNext(), 1);\n                 cc.addOp(\":\", true);\n                 addExpr(last, 1);\n                 break;\n             }\n         case Token.REGEXP:\n             if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                 throw new Error(\"Expected children to be strings\");\n             }\n             String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n             if (childCount \u003d\u003d 2) {\n                 add(regexp + last.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 add(regexp);\n             }\n             break;\n         case Token.GET_REF:\n             add(first);\n             break;\n         case Token.REF_SPECIAL:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first);\n             add(\".\");\n             add((String) n.getProp(Node.NAME_PROP));\n             break;\n         case Token.FUNCTION:\n             if (n.getClass() !\u003d Node.class) {\n                 throw new Error(\"Unexpected Node subclass.\");\n             }\n             Preconditions.checkState(childCount \u003d\u003d 3);\n             boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n             if (funcNeedsParens) {\n                 add(\"(\");\n             }\n             add(\"function\");\n             add(first);\n             add(first.getNext());\n             add(last, Context.PRESERVE_BLOCK);\n             cc.endFunction(context \u003d\u003d Context.STATEMENT);\n             if (funcNeedsParens) {\n                 add(\")\");\n             }\n             break;\n         case Token.GET:\n         case Token.SET:\n             Preconditions.checkState(n.getParent().getType() \u003d\u003d Token.OBJECTLIT);\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             Preconditions.checkState(first.getType() \u003d\u003d Token.FUNCTION);\n             Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n             if (type \u003d\u003d Token.GET) {\n                 Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n                 add(\"get \");\n             } else {\n                 Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n                 add(\"set \");\n             }\n             String name \u003d n.getString();\n             Node fn \u003d first;\n             Node parameters \u003d fn.getChildAtIndex(1);\n             Node body \u003d fn.getLastChild();\n             if (!n.isQuotedString() \u0026\u0026 TokenStream.isJSIdentifier(name) \u0026\u0026 NodeUtil.isLatin(name)) {\n                 add(name);\n             } else {\n                 double d \u003d getSimpleNumber(name);\n                 if (!Double.isNaN(d)) {\n                     cc.addNumber(d);\n                 } else {\n                     add(jsString(n.getString(), outputCharsetEncoder));\n                 }\n             }\n             add(parameters);\n             add(body, Context.PRESERVE_BLOCK);\n             break;\n         case Token.SCRIPT:\n         case Token.BLOCK:\n             {\n                 if (n.getClass() !\u003d Node.class) {\n                     throw new Error(\"Unexpected Node subclass.\");\n                 }\n                 boolean preserveBlock \u003d context \u003d\u003d Context.PRESERVE_BLOCK;\n                 if (preserveBlock) {\n                     cc.beginBlock();\n                 }\n                 boolean preferLineBreaks \u003d type \u003d\u003d Token.SCRIPT || (type \u003d\u003d Token.BLOCK \u0026\u0026 !preserveBlock \u0026\u0026 n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.SCRIPT);\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     add(c, Context.STATEMENT);\n                     if (c.getType() \u003d\u003d Token.VAR) {\n                         cc.endStatement();\n                     }\n                     if (c.getType() \u003d\u003d Token.FUNCTION) {\n                         cc.maybeLineBreak();\n                     }\n                     if (preferLineBreaks) {\n                         cc.notePreferredLineBreak();\n                     }\n                 }\n                 if (preserveBlock) {\n                     cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                 }\n                 break;\n             }\n         case Token.FOR:\n             if (childCount \u003d\u003d 4) {\n                 add(\"for(\");\n                 if (first.getType() \u003d\u003d Token.VAR) {\n                     add(first, Context.IN_FOR_INIT_CLAUSE);\n                 } else {\n                     addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                 }\n                 add(\";\");\n                 add(first.getNext());\n                 add(\";\");\n                 add(first.getNext().getNext());\n                 add(\")\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 add(\"for(\");\n                 add(first);\n                 add(\"in\");\n                 add(first.getNext());\n                 add(\")\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             }\n             break;\n         case Token.DO:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"do\");\n             addNonEmptyStatement(first, Context.OTHER, false);\n             add(\"while(\");\n             add(last);\n             add(\")\");\n             cc.endStatement();\n             break;\n         case Token.WHILE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"while(\");\n             add(first);\n             add(\")\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.EMPTY:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             break;\n         case Token.GETPROP:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                 Preconditions.checkState(last.getType() \u003d\u003d Token.STRING, \"Bad GETPROP: RHS should be STRING\");\n                 boolean needsParens \u003d (first.getType() \u003d\u003d Token.NUMBER);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 add(\".\");\n                 addIdentifier(last.getString());\n                 break;\n             }\n         case Token.GETELEM:\n             Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n             addLeftExpr(first, NodeUtil.precedence(type), context);\n             add(\"[\");\n             add(first.getNext());\n             add(\"]\");\n             break;\n         case Token.WITH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"with(\");\n             add(first);\n             add(\")\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.INC:\n         case Token.DEC:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                 int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                 if (postProp !\u003d 0) {\n                     addLeftExpr(first, NodeUtil.precedence(type), context);\n                     cc.addOp(o, false);\n                 } else {\n                     cc.addOp(o, false);\n                     add(first);\n                 }\n                 break;\n             }\n         case Token.CALL:\n             if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) \u0026\u0026 NodeUtil.isGet(first)) {\n                 add(\"(0,\");\n                 addExpr(first, NodeUtil.precedence(Token.COMMA));\n                 add(\")\");\n             } else {\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n             }\n             add(\"(\");\n             addList(first.getNext());\n             add(\")\");\n             break;\n         case Token.IF:\n             boolean hasElse \u003d childCount \u003d\u003d 3;\n             boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n             if (ambiguousElseClause) {\n                 cc.beginBlock();\n             }\n             add(\"if(\");\n             add(first);\n             add(\")\");\n             if (hasElse) {\n                 addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                 add(\"else\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n                 Preconditions.checkState(childCount \u003d\u003d 2);\n             }\n             if (ambiguousElseClause) {\n                 cc.endBlock();\n             }\n             break;\n         case Token.NULL:\n         case Token.THIS:\n         case Token.FALSE:\n         case Token.TRUE:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(Node.tokenToName(type));\n             break;\n         case Token.CONTINUE:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"continue\");\n             if (childCount \u003d\u003d 1) {\n                 if (first.getType() !\u003d Token.LABEL_NAME) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.DEBUGGER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(\"debugger\");\n             cc.endStatement();\n             break;\n         case Token.BREAK:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"break\");\n             if (childCount \u003d\u003d 1) {\n                 if (first.getType() !\u003d Token.LABEL_NAME) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.EXPR_VOID:\n             throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n         case Token.EXPR_RESULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first, Context.START_OF_EXPR);\n             cc.endStatement();\n             break;\n         case Token.NEW:\n             add(\"new \");\n             int precedence \u003d NodeUtil.precedence(type);\n             if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction())) {\n                 precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n             }\n             addExpr(first, precedence);\n             Node next \u003d first.getNext();\n             if (next !\u003d null) {\n                 add(\"(\");\n                 addList(next);\n                 add(\")\");\n             }\n             break;\n         case Token.STRING:\n             if (childCount !\u003d ((n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.OBJECTLIT) ? 1 : 0)) {\n                 throw new IllegalStateException(\"Unexpected String children: \" + n.getParent().toStringTree());\n             }\n             add(jsString(n.getString(), outputCharsetEncoder));\n             break;\n         case Token.DELPROP:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"delete \");\n             add(first);\n             break;\n         case Token.OBJECTLIT:\n             {\n                 boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 add(\"{\");\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     if (c !\u003d first) {\n                         cc.listSeparator();\n                     }\n                     if (c.getType() \u003d\u003d Token.GET || c.getType() \u003d\u003d Token.SET) {\n                         add(c);\n                     } else {\n                         Preconditions.checkState(c.getType() \u003d\u003d Token.STRING);\n                         String key \u003d c.getString();\n                         if (!c.isQuotedString() \u0026\u0026 !TokenStream.isKeyword(key) \u0026\u0026 TokenStream.isJSIdentifier(key) \u0026\u0026 NodeUtil.isLatin(key)) {\n                             add(key);\n                         } else {\n                             double d \u003d getSimpleNumber(key);\n                             if (!Double.isNaN(d)) {\n                                 cc.addNumber(d);\n                             } else {\n                                 addExpr(c, 1);\n                             }\n                         }\n                         add(\":\");\n                         addExpr(c.getFirstChild(), 1);\n                     }\n                 }\n                 add(\"}\");\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 break;\n             }\n         case Token.SWITCH:\n             add(\"switch(\");\n             add(first);\n             add(\")\");\n             cc.beginBlock();\n             addAllSiblings(first.getNext());\n             cc.endBlock(context \u003d\u003d Context.STATEMENT);\n             break;\n         case Token.CASE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"case \");\n             add(first);\n             addCaseBody(last);\n             break;\n         case Token.DEFAULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"default\");\n             addCaseBody(first);\n             break;\n         case Token.LABEL:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             if (first.getType() !\u003d Token.LABEL_NAME) {\n                 throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n             }\n             add(first);\n             add(\":\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\n             break;\n         case Token.SETNAME:\n             break;\n         default:\n             throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n     }\n     cc.endSourceMapping(n);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "41acde3e8e5e8d37ade765b41d9fd29861f03e5e": {
      "type": "Ybodychange",
      "commitMessage": "\nDefine number keys in object literals to be quoted string nodes. Tagged with NUMBER_PROP\nFixes issue 347\n\nR\u003dnicksantos\nDELTA\u003d229  (157 added, 19 deleted, 53 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d1252\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@966 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/4/11, 2:26 PM",
      "commitName": "41acde3e8e5e8d37ade765b41d9fd29861f03e5e",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "3/17/11, 5:03 PM",
      "commitNameOld": "b88400ce0e9c1a0dadfd3417c256b02a82f38fe1",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 17.89,
      "commitsBetweenForRepo": 56,
      "commitsBetweenForFile": 1,
      "actualSource": "void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n        return;\n    }\n    int type \u003d n.getType();\n    String opstr \u003d NodeUtil.opToStr(type);\n    int childCount \u003d n.getChildCount();\n    Node first \u003d n.getFirstChild();\n    Node last \u003d n.getLastChild();\n    if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n        Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n        int p \u003d NodeUtil.precedence(type);\n        addLeftExpr(first, p, context);\n        cc.addOp(opstr, true);\n        Context rhsContext \u003d getContextForNoInOperator(context);\n        if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n            addExpr(last, p, rhsContext);\n        } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n            addExpr(last, p, rhsContext);\n        } else {\n            addExpr(last, p + 1, rhsContext);\n        }\n        return;\n    }\n    cc.startSourceMapping(n);\n    switch(type) {\n        case Token.TRY:\n            {\n                Preconditions.checkState(first.getNext().getType() \u003d\u003d Token.BLOCK \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n                Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                add(\"try\");\n                add(first, Context.PRESERVE_BLOCK);\n                Node catchblock \u003d first.getNext().getFirstChild();\n                if (catchblock !\u003d null) {\n                    add(catchblock);\n                }\n                if (childCount \u003d\u003d 3) {\n                    add(\"finally\");\n                    add(last, Context.PRESERVE_BLOCK);\n                }\n                break;\n            }\n        case Token.CATCH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"catch(\");\n            add(first);\n            add(\")\");\n            add(last, Context.PRESERVE_BLOCK);\n            break;\n        case Token.THROW:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"throw\");\n            add(first);\n            cc.endStatement(true);\n            break;\n        case Token.RETURN:\n            add(\"return\");\n            if (childCount \u003d\u003d 1) {\n                add(first);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 0);\n            }\n            cc.endStatement();\n            break;\n        case Token.VAR:\n            if (first !\u003d null) {\n                add(\"var \");\n                addList(first, false, getContextForNoInOperator(context));\n            }\n            break;\n        case Token.LABEL_NAME:\n            Preconditions.checkState(!n.getString().isEmpty());\n            addIdentifier(n.getString());\n            break;\n        case Token.NAME:\n            if (first \u003d\u003d null || first.getType() \u003d\u003d Token.EMPTY) {\n                addIdentifier(n.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                addIdentifier(n.getString());\n                cc.addOp(\"\u003d\", true);\n                if (first.getType() \u003d\u003d Token.COMMA) {\n                    addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                } else {\n                    addExpr(first, 0, getContextForNoInOperator(context));\n                }\n            }\n            break;\n        case Token.ARRAYLIT:\n            add(\"[\");\n            addArrayList(first);\n            add(\"]\");\n            break;\n        case Token.LP:\n            add(\"(\");\n            addList(first);\n            add(\")\");\n            break;\n        case Token.COMMA:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            addList(first, false, context);\n            break;\n        case Token.NUMBER:\n            Preconditions.checkState(childCount \u003d\u003d ((n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.OBJECTLIT) ? 1 : 0));\n            cc.addNumber(n.getDouble());\n            break;\n        case Token.TYPEOF:\n        case Token.VOID:\n        case Token.NOT:\n        case Token.BITNOT:\n        case Token.POS:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                addExpr(first, NodeUtil.precedence(type));\n                break;\n            }\n        case Token.NEG:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                if (n.getFirstChild().getType() \u003d\u003d Token.NUMBER) {\n                    cc.addNumber(-n.getFirstChild().getDouble());\n                } else {\n                    cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                    addExpr(first, NodeUtil.precedence(type));\n                }\n                break;\n            }\n        case Token.HOOK:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                int p \u003d NodeUtil.precedence(type);\n                addLeftExpr(first, p + 1, context);\n                cc.addOp(\"?\", true);\n                addExpr(first.getNext(), 1);\n                cc.addOp(\":\", true);\n                addExpr(last, 1);\n                break;\n            }\n        case Token.REGEXP:\n            if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                throw new Error(\"Expected children to be strings\");\n            }\n            String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n            if (childCount \u003d\u003d 2) {\n                add(regexp + last.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                add(regexp);\n            }\n            break;\n        case Token.GET_REF:\n            add(first);\n            break;\n        case Token.REF_SPECIAL:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first);\n            add(\".\");\n            add((String) n.getProp(Node.NAME_PROP));\n            break;\n        case Token.FUNCTION:\n            if (n.getClass() !\u003d Node.class) {\n                throw new Error(\"Unexpected Node subclass.\");\n            }\n            Preconditions.checkState(childCount \u003d\u003d 3);\n            boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n            if (funcNeedsParens) {\n                add(\"(\");\n            }\n            add(\"function\");\n            add(first);\n            add(first.getNext());\n            add(last, Context.PRESERVE_BLOCK);\n            cc.endFunction(context \u003d\u003d Context.STATEMENT);\n            if (funcNeedsParens) {\n                add(\")\");\n            }\n            break;\n        case Token.GET:\n        case Token.SET:\n            Preconditions.checkState(n.getParent().getType() \u003d\u003d Token.OBJECTLIT);\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            Preconditions.checkState(first.getType() \u003d\u003d Token.FUNCTION);\n            Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n            if (type \u003d\u003d Token.GET) {\n                Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n                add(\"get \");\n            } else {\n                Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n                add(\"set \");\n            }\n            String name \u003d n.getString();\n            Node fn \u003d first;\n            Node parameters \u003d fn.getChildAtIndex(1);\n            Node body \u003d fn.getLastChild();\n            if (!n.isQuotedString() \u0026\u0026 TokenStream.isJSIdentifier(name) \u0026\u0026 NodeUtil.isLatin(name)) {\n                add(name);\n            } else {\n                double d \u003d getSimpleNumber(name);\n                if (!Double.isNaN(d)) {\n                    cc.addNumber(d);\n                } else {\n                    add(jsString(n.getString(), outputCharsetEncoder));\n                }\n            }\n            add(parameters);\n            add(body, Context.PRESERVE_BLOCK);\n            break;\n        case Token.SCRIPT:\n        case Token.BLOCK:\n            {\n                if (n.getClass() !\u003d Node.class) {\n                    throw new Error(\"Unexpected Node subclass.\");\n                }\n                boolean preserveBlock \u003d context \u003d\u003d Context.PRESERVE_BLOCK;\n                if (preserveBlock) {\n                    cc.beginBlock();\n                }\n                boolean preferLineBreaks \u003d type \u003d\u003d Token.SCRIPT || (type \u003d\u003d Token.BLOCK \u0026\u0026 !preserveBlock \u0026\u0026 n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.SCRIPT);\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    add(c, Context.STATEMENT);\n                    if (c.getType() \u003d\u003d Token.VAR) {\n                        cc.endStatement();\n                    }\n                    if (c.getType() \u003d\u003d Token.FUNCTION) {\n                        cc.maybeLineBreak();\n                    }\n                    if (preferLineBreaks) {\n                        cc.notePreferredLineBreak();\n                    }\n                }\n                if (preserveBlock) {\n                    cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                }\n                break;\n            }\n        case Token.FOR:\n            if (childCount \u003d\u003d 4) {\n                add(\"for(\");\n                if (first.getType() \u003d\u003d Token.VAR) {\n                    add(first, Context.IN_FOR_INIT_CLAUSE);\n                } else {\n                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                }\n                add(\";\");\n                add(first.getNext());\n                add(\";\");\n                add(first.getNext().getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                add(\"for(\");\n                add(first);\n                add(\"in\");\n                add(first.getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            }\n            break;\n        case Token.DO:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"do\");\n            addNonEmptyStatement(first, Context.OTHER, false);\n            add(\"while(\");\n            add(last);\n            add(\")\");\n            cc.endStatement();\n            break;\n        case Token.WHILE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"while(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.EMPTY:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            break;\n        case Token.GETPROP:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                Preconditions.checkState(last.getType() \u003d\u003d Token.STRING, \"Bad GETPROP: RHS should be STRING\");\n                boolean needsParens \u003d (first.getType() \u003d\u003d Token.NUMBER);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n                if (needsParens) {\n                    add(\")\");\n                }\n                add(\".\");\n                addIdentifier(last.getString());\n                break;\n            }\n        case Token.GETELEM:\n            Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n            addLeftExpr(first, NodeUtil.precedence(type), context);\n            add(\"[\");\n            add(first.getNext());\n            add(\"]\");\n            break;\n        case Token.WITH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"with(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.INC:\n        case Token.DEC:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                if (postProp !\u003d 0) {\n                    addLeftExpr(first, NodeUtil.precedence(type), context);\n                    cc.addOp(o, false);\n                } else {\n                    cc.addOp(o, false);\n                    add(first);\n                }\n                break;\n            }\n        case Token.CALL:\n            if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) \u0026\u0026 NodeUtil.isGet(first)) {\n                add(\"(0,\");\n                addExpr(first, NodeUtil.precedence(Token.COMMA));\n                add(\")\");\n            } else {\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n            }\n            add(\"(\");\n            addList(first.getNext());\n            add(\")\");\n            break;\n        case Token.IF:\n            boolean hasElse \u003d childCount \u003d\u003d 3;\n            boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n            if (ambiguousElseClause) {\n                cc.beginBlock();\n            }\n            add(\"if(\");\n            add(first);\n            add(\")\");\n            if (hasElse) {\n                addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                add(\"else\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n                Preconditions.checkState(childCount \u003d\u003d 2);\n            }\n            if (ambiguousElseClause) {\n                cc.endBlock();\n            }\n            break;\n        case Token.NULL:\n        case Token.THIS:\n        case Token.FALSE:\n        case Token.TRUE:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(Node.tokenToName(type));\n            break;\n        case Token.CONTINUE:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"continue\");\n            if (childCount \u003d\u003d 1) {\n                if (first.getType() !\u003d Token.LABEL_NAME) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.DEBUGGER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"debugger\");\n            cc.endStatement();\n            break;\n        case Token.BREAK:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"break\");\n            if (childCount \u003d\u003d 1) {\n                if (first.getType() !\u003d Token.LABEL_NAME) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.EXPR_VOID:\n            throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n        case Token.EXPR_RESULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first, Context.START_OF_EXPR);\n            cc.endStatement();\n            break;\n        case Token.NEW:\n            add(\"new \");\n            int precedence \u003d NodeUtil.precedence(type);\n            if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction())) {\n                precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n            }\n            addExpr(first, precedence);\n            Node next \u003d first.getNext();\n            if (next !\u003d null) {\n                add(\"(\");\n                addList(next);\n                add(\")\");\n            }\n            break;\n        case Token.STRING:\n            if (childCount !\u003d ((n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.OBJECTLIT) ? 1 : 0)) {\n                throw new IllegalStateException(\"Unexpected String children: \" + n.getParent().toStringTree());\n            }\n            add(jsString(n.getString(), outputCharsetEncoder));\n            break;\n        case Token.DELPROP:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"delete \");\n            add(first);\n            break;\n        case Token.OBJECTLIT:\n            {\n                boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                add(\"{\");\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    if (c !\u003d first) {\n                        cc.listSeparator();\n                    }\n                    if (c.getType() \u003d\u003d Token.GET || c.getType() \u003d\u003d Token.SET) {\n                        add(c);\n                    } else {\n                        Preconditions.checkState(c.getType() \u003d\u003d Token.STRING);\n                        String key \u003d c.getString();\n                        if (!c.isQuotedString() \u0026\u0026 !TokenStream.isKeyword(key) \u0026\u0026 TokenStream.isJSIdentifier(key) \u0026\u0026 NodeUtil.isLatin(key)) {\n                            add(key);\n                        } else {\n                            double d \u003d getSimpleNumber(key);\n                            if (!Double.isNaN(d)) {\n                                cc.addNumber(d);\n                            } else {\n                                addExpr(c, 1);\n                            }\n                        }\n                        add(\":\");\n                        addExpr(c.getFirstChild(), 1);\n                    }\n                }\n                add(\"}\");\n                if (needsParens) {\n                    add(\")\");\n                }\n                break;\n            }\n        case Token.SWITCH:\n            add(\"switch(\");\n            add(first);\n            add(\")\");\n            cc.beginBlock();\n            addAllSiblings(first.getNext());\n            cc.endBlock(context \u003d\u003d Context.STATEMENT);\n            break;\n        case Token.CASE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"case \");\n            add(first);\n            addCaseBody(last);\n            break;\n        case Token.DEFAULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"default\");\n            addCaseBody(first);\n            break;\n        case Token.LABEL:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            if (first.getType() !\u003d Token.LABEL_NAME) {\n                throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n            }\n            add(first);\n            add(\":\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\n            break;\n        case Token.SETNAME:\n            break;\n        default:\n            throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n    cc.endSourceMapping(n);\n}",
      "path": "src/com/google/javascript/jscomp/CodeGenerator.java",
      "functionStartLine": 82,
      "functionName": "add",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,484 +1,496 @@\n void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n         return;\n     }\n     int type \u003d n.getType();\n     String opstr \u003d NodeUtil.opToStr(type);\n     int childCount \u003d n.getChildCount();\n     Node first \u003d n.getFirstChild();\n     Node last \u003d n.getLastChild();\n     if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n         Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n         int p \u003d NodeUtil.precedence(type);\n         addLeftExpr(first, p, context);\n         cc.addOp(opstr, true);\n         Context rhsContext \u003d getContextForNoInOperator(context);\n         if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n             addExpr(last, p, rhsContext);\n         } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n             addExpr(last, p, rhsContext);\n         } else {\n             addExpr(last, p + 1, rhsContext);\n         }\n         return;\n     }\n     cc.startSourceMapping(n);\n     switch(type) {\n         case Token.TRY:\n             {\n                 Preconditions.checkState(first.getNext().getType() \u003d\u003d Token.BLOCK \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n                 Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                 add(\"try\");\n                 add(first, Context.PRESERVE_BLOCK);\n                 Node catchblock \u003d first.getNext().getFirstChild();\n                 if (catchblock !\u003d null) {\n                     add(catchblock);\n                 }\n                 if (childCount \u003d\u003d 3) {\n                     add(\"finally\");\n                     add(last, Context.PRESERVE_BLOCK);\n                 }\n                 break;\n             }\n         case Token.CATCH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"catch(\");\n             add(first);\n             add(\")\");\n             add(last, Context.PRESERVE_BLOCK);\n             break;\n         case Token.THROW:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"throw\");\n             add(first);\n             cc.endStatement(true);\n             break;\n         case Token.RETURN:\n             add(\"return\");\n             if (childCount \u003d\u003d 1) {\n                 add(first);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 0);\n             }\n             cc.endStatement();\n             break;\n         case Token.VAR:\n             if (first !\u003d null) {\n                 add(\"var \");\n                 addList(first, false, getContextForNoInOperator(context));\n             }\n             break;\n         case Token.LABEL_NAME:\n             Preconditions.checkState(!n.getString().isEmpty());\n             addIdentifier(n.getString());\n             break;\n         case Token.NAME:\n             if (first \u003d\u003d null || first.getType() \u003d\u003d Token.EMPTY) {\n                 addIdentifier(n.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 addIdentifier(n.getString());\n                 cc.addOp(\"\u003d\", true);\n                 if (first.getType() \u003d\u003d Token.COMMA) {\n                     addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                 } else {\n                     addExpr(first, 0, getContextForNoInOperator(context));\n                 }\n             }\n             break;\n         case Token.ARRAYLIT:\n             add(\"[\");\n             addArrayList(first);\n             add(\"]\");\n             break;\n         case Token.LP:\n             add(\"(\");\n             addList(first);\n             add(\")\");\n             break;\n         case Token.COMMA:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             addList(first, false, context);\n             break;\n         case Token.NUMBER:\n             Preconditions.checkState(childCount \u003d\u003d ((n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.OBJECTLIT) ? 1 : 0));\n             cc.addNumber(n.getDouble());\n             break;\n         case Token.TYPEOF:\n         case Token.VOID:\n         case Token.NOT:\n         case Token.BITNOT:\n         case Token.POS:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                 addExpr(first, NodeUtil.precedence(type));\n                 break;\n             }\n         case Token.NEG:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 if (n.getFirstChild().getType() \u003d\u003d Token.NUMBER) {\n                     cc.addNumber(-n.getFirstChild().getDouble());\n                 } else {\n                     cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                     addExpr(first, NodeUtil.precedence(type));\n                 }\n                 break;\n             }\n         case Token.HOOK:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 int p \u003d NodeUtil.precedence(type);\n                 addLeftExpr(first, p + 1, context);\n                 cc.addOp(\"?\", true);\n                 addExpr(first.getNext(), 1);\n                 cc.addOp(\":\", true);\n                 addExpr(last, 1);\n                 break;\n             }\n         case Token.REGEXP:\n             if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                 throw new Error(\"Expected children to be strings\");\n             }\n             String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n             if (childCount \u003d\u003d 2) {\n                 add(regexp + last.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 add(regexp);\n             }\n             break;\n         case Token.GET_REF:\n             add(first);\n             break;\n         case Token.REF_SPECIAL:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first);\n             add(\".\");\n             add((String) n.getProp(Node.NAME_PROP));\n             break;\n         case Token.FUNCTION:\n             if (n.getClass() !\u003d Node.class) {\n                 throw new Error(\"Unexpected Node subclass.\");\n             }\n             Preconditions.checkState(childCount \u003d\u003d 3);\n             boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n             if (funcNeedsParens) {\n                 add(\"(\");\n             }\n             add(\"function\");\n             add(first);\n             add(first.getNext());\n             add(last, Context.PRESERVE_BLOCK);\n             cc.endFunction(context \u003d\u003d Context.STATEMENT);\n             if (funcNeedsParens) {\n                 add(\")\");\n             }\n             break;\n         case Token.GET:\n         case Token.SET:\n             Preconditions.checkState(n.getParent().getType() \u003d\u003d Token.OBJECTLIT);\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             Preconditions.checkState(first.getType() \u003d\u003d Token.FUNCTION);\n             Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n             if (type \u003d\u003d Token.GET) {\n                 Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n                 add(\"get \");\n             } else {\n                 Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n                 add(\"set \");\n             }\n             String name \u003d n.getString();\n             Node fn \u003d first;\n             Node parameters \u003d fn.getChildAtIndex(1);\n             Node body \u003d fn.getLastChild();\n-            if (TokenStream.isJSIdentifier(name) \u0026\u0026 NodeUtil.isLatin(name)) {\n+            if (!n.isQuotedString() \u0026\u0026 TokenStream.isJSIdentifier(name) \u0026\u0026 NodeUtil.isLatin(name)) {\n                 add(name);\n             } else {\n-                add(jsString(n.getString(), outputCharsetEncoder));\n+                double d \u003d getSimpleNumber(name);\n+                if (!Double.isNaN(d)) {\n+                    cc.addNumber(d);\n+                } else {\n+                    add(jsString(n.getString(), outputCharsetEncoder));\n+                }\n             }\n             add(parameters);\n             add(body, Context.PRESERVE_BLOCK);\n             break;\n         case Token.SCRIPT:\n         case Token.BLOCK:\n             {\n                 if (n.getClass() !\u003d Node.class) {\n                     throw new Error(\"Unexpected Node subclass.\");\n                 }\n                 boolean preserveBlock \u003d context \u003d\u003d Context.PRESERVE_BLOCK;\n                 if (preserveBlock) {\n                     cc.beginBlock();\n                 }\n                 boolean preferLineBreaks \u003d type \u003d\u003d Token.SCRIPT || (type \u003d\u003d Token.BLOCK \u0026\u0026 !preserveBlock \u0026\u0026 n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.SCRIPT);\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     add(c, Context.STATEMENT);\n                     if (c.getType() \u003d\u003d Token.VAR) {\n                         cc.endStatement();\n                     }\n                     if (c.getType() \u003d\u003d Token.FUNCTION) {\n                         cc.maybeLineBreak();\n                     }\n                     if (preferLineBreaks) {\n                         cc.notePreferredLineBreak();\n                     }\n                 }\n                 if (preserveBlock) {\n                     cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                 }\n                 break;\n             }\n         case Token.FOR:\n             if (childCount \u003d\u003d 4) {\n                 add(\"for(\");\n                 if (first.getType() \u003d\u003d Token.VAR) {\n                     add(first, Context.IN_FOR_INIT_CLAUSE);\n                 } else {\n                     addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                 }\n                 add(\";\");\n                 add(first.getNext());\n                 add(\";\");\n                 add(first.getNext().getNext());\n                 add(\")\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 add(\"for(\");\n                 add(first);\n                 add(\"in\");\n                 add(first.getNext());\n                 add(\")\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             }\n             break;\n         case Token.DO:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"do\");\n             addNonEmptyStatement(first, Context.OTHER, false);\n             add(\"while(\");\n             add(last);\n             add(\")\");\n             cc.endStatement();\n             break;\n         case Token.WHILE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"while(\");\n             add(first);\n             add(\")\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.EMPTY:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             break;\n         case Token.GETPROP:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                 Preconditions.checkState(last.getType() \u003d\u003d Token.STRING, \"Bad GETPROP: RHS should be STRING\");\n                 boolean needsParens \u003d (first.getType() \u003d\u003d Token.NUMBER);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 add(\".\");\n                 addIdentifier(last.getString());\n                 break;\n             }\n         case Token.GETELEM:\n             Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n             addLeftExpr(first, NodeUtil.precedence(type), context);\n             add(\"[\");\n             add(first.getNext());\n             add(\"]\");\n             break;\n         case Token.WITH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"with(\");\n             add(first);\n             add(\")\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.INC:\n         case Token.DEC:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                 int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                 if (postProp !\u003d 0) {\n                     addLeftExpr(first, NodeUtil.precedence(type), context);\n                     cc.addOp(o, false);\n                 } else {\n                     cc.addOp(o, false);\n                     add(first);\n                 }\n                 break;\n             }\n         case Token.CALL:\n             if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) \u0026\u0026 NodeUtil.isGet(first)) {\n                 add(\"(0,\");\n                 addExpr(first, NodeUtil.precedence(Token.COMMA));\n                 add(\")\");\n             } else {\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n             }\n             add(\"(\");\n             addList(first.getNext());\n             add(\")\");\n             break;\n         case Token.IF:\n             boolean hasElse \u003d childCount \u003d\u003d 3;\n             boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n             if (ambiguousElseClause) {\n                 cc.beginBlock();\n             }\n             add(\"if(\");\n             add(first);\n             add(\")\");\n             if (hasElse) {\n                 addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                 add(\"else\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n                 Preconditions.checkState(childCount \u003d\u003d 2);\n             }\n             if (ambiguousElseClause) {\n                 cc.endBlock();\n             }\n             break;\n         case Token.NULL:\n         case Token.THIS:\n         case Token.FALSE:\n         case Token.TRUE:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(Node.tokenToName(type));\n             break;\n         case Token.CONTINUE:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"continue\");\n             if (childCount \u003d\u003d 1) {\n                 if (first.getType() !\u003d Token.LABEL_NAME) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.DEBUGGER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(\"debugger\");\n             cc.endStatement();\n             break;\n         case Token.BREAK:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"break\");\n             if (childCount \u003d\u003d 1) {\n                 if (first.getType() !\u003d Token.LABEL_NAME) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.EXPR_VOID:\n             throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n         case Token.EXPR_RESULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first, Context.START_OF_EXPR);\n             cc.endStatement();\n             break;\n         case Token.NEW:\n             add(\"new \");\n             int precedence \u003d NodeUtil.precedence(type);\n             if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction())) {\n                 precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n             }\n             addExpr(first, precedence);\n             Node next \u003d first.getNext();\n             if (next !\u003d null) {\n                 add(\"(\");\n                 addList(next);\n                 add(\")\");\n             }\n             break;\n         case Token.STRING:\n             if (childCount !\u003d ((n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.OBJECTLIT) ? 1 : 0)) {\n                 throw new IllegalStateException(\"Unexpected String children: \" + n.getParent().toStringTree());\n             }\n             add(jsString(n.getString(), outputCharsetEncoder));\n             break;\n         case Token.DELPROP:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"delete \");\n             add(first);\n             break;\n         case Token.OBJECTLIT:\n             {\n                 boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 add(\"{\");\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     if (c !\u003d first) {\n                         cc.listSeparator();\n                     }\n                     if (c.getType() \u003d\u003d Token.GET || c.getType() \u003d\u003d Token.SET) {\n                         add(c);\n                     } else {\n-                        if (c.getType() \u003d\u003d Token.STRING \u0026\u0026 !c.isQuotedString() \u0026\u0026 !TokenStream.isKeyword(c.getString()) \u0026\u0026 TokenStream.isJSIdentifier(c.getString()) \u0026\u0026 NodeUtil.isLatin(c.getString())) {\n-                            add(c.getString());\n+                        Preconditions.checkState(c.getType() \u003d\u003d Token.STRING);\n+                        String key \u003d c.getString();\n+                        if (!c.isQuotedString() \u0026\u0026 !TokenStream.isKeyword(key) \u0026\u0026 TokenStream.isJSIdentifier(key) \u0026\u0026 NodeUtil.isLatin(key)) {\n+                            add(key);\n                         } else {\n-                            addExpr(c, 1);\n+                            double d \u003d getSimpleNumber(key);\n+                            if (!Double.isNaN(d)) {\n+                                cc.addNumber(d);\n+                            } else {\n+                                addExpr(c, 1);\n+                            }\n                         }\n                         add(\":\");\n                         addExpr(c.getFirstChild(), 1);\n                     }\n                 }\n                 add(\"}\");\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 break;\n             }\n         case Token.SWITCH:\n             add(\"switch(\");\n             add(first);\n             add(\")\");\n             cc.beginBlock();\n             addAllSiblings(first.getNext());\n             cc.endBlock(context \u003d\u003d Context.STATEMENT);\n             break;\n         case Token.CASE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"case \");\n             add(first);\n             addCaseBody(last);\n             break;\n         case Token.DEFAULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"default\");\n             addCaseBody(first);\n             break;\n         case Token.LABEL:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             if (first.getType() !\u003d Token.LABEL_NAME) {\n                 throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n             }\n             add(first);\n             add(\":\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\n             break;\n         case Token.SETNAME:\n             break;\n         default:\n             throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n     }\n     cc.endSourceMapping(n);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "653599e7c3922059a78958ea32b216ff9c42800e": {
      "type": "Ybodychange",
      "commitMessage": "\nFixup sparse array handling.\n- Replace sparse array annotation with EMPTY nodes.\n- Fix handling of arrays ending with an EMPTY node\n- Fix handling of arrays that are completely empty\n- Support PeepFoldConstant folding of arrays containing EMPTY nodes.\n\nR\u003dacleung\nDELTA\u003d163  (53 added, 92 deleted, 18 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d879\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@887 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "3/15/11, 12:33 PM",
      "commitName": "653599e7c3922059a78958ea32b216ff9c42800e",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "3/10/11, 11:48 AM",
      "commitNameOld": "524c758183be741ff1519acfa8a4bf714dd2c4cd",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 4.99,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "actualSource": "void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n        return;\n    }\n    int type \u003d n.getType();\n    String opstr \u003d NodeUtil.opToStr(type);\n    int childCount \u003d n.getChildCount();\n    Node first \u003d n.getFirstChild();\n    Node last \u003d n.getLastChild();\n    if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n        Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n        int p \u003d NodeUtil.precedence(type);\n        addLeftExpr(first, p, context);\n        cc.addOp(opstr, true);\n        Context rhsContext \u003d getContextForNoInOperator(context);\n        if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n            addExpr(last, p, rhsContext);\n        } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n            addExpr(last, p, rhsContext);\n        } else {\n            addExpr(last, p + 1, rhsContext);\n        }\n        return;\n    }\n    cc.startSourceMapping(n);\n    switch(type) {\n        case Token.TRY:\n            {\n                Preconditions.checkState(first.getNext().getType() \u003d\u003d Token.BLOCK \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n                Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                add(\"try\");\n                add(first, Context.PRESERVE_BLOCK);\n                Node catchblock \u003d first.getNext().getFirstChild();\n                if (catchblock !\u003d null) {\n                    add(catchblock);\n                }\n                if (childCount \u003d\u003d 3) {\n                    add(\"finally\");\n                    add(last, Context.PRESERVE_BLOCK);\n                }\n                break;\n            }\n        case Token.CATCH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"catch(\");\n            add(first);\n            add(\")\");\n            add(last, Context.PRESERVE_BLOCK);\n            break;\n        case Token.THROW:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"throw\");\n            add(first);\n            cc.endStatement(true);\n            break;\n        case Token.RETURN:\n            add(\"return\");\n            if (childCount \u003d\u003d 1) {\n                add(first);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 0);\n            }\n            cc.endStatement();\n            break;\n        case Token.VAR:\n            if (first !\u003d null) {\n                add(\"var \");\n                addList(first, false, getContextForNoInOperator(context));\n            }\n            break;\n        case Token.LABEL_NAME:\n            Preconditions.checkState(!n.getString().isEmpty());\n            addIdentifier(n.getString());\n            break;\n        case Token.NAME:\n            if (first \u003d\u003d null || first.getType() \u003d\u003d Token.EMPTY) {\n                addIdentifier(n.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                addIdentifier(n.getString());\n                cc.addOp(\"\u003d\", true);\n                if (first.getType() \u003d\u003d Token.COMMA) {\n                    addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                } else {\n                    addExpr(first, 0, getContextForNoInOperator(context));\n                }\n            }\n            break;\n        case Token.ARRAYLIT:\n            add(\"[\");\n            addArrayList(first);\n            add(\"]\");\n            break;\n        case Token.LP:\n            add(\"(\");\n            addList(first);\n            add(\")\");\n            break;\n        case Token.COMMA:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            addList(first, false, context);\n            break;\n        case Token.NUMBER:\n            Preconditions.checkState(childCount \u003d\u003d ((n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.OBJECTLIT) ? 1 : 0));\n            cc.addNumber(n.getDouble());\n            break;\n        case Token.TYPEOF:\n        case Token.VOID:\n        case Token.NOT:\n        case Token.BITNOT:\n        case Token.POS:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                addExpr(first, NodeUtil.precedence(type));\n                break;\n            }\n        case Token.NEG:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                if (n.getFirstChild().getType() \u003d\u003d Token.NUMBER) {\n                    cc.addNumber(-n.getFirstChild().getDouble());\n                } else {\n                    cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                    addExpr(first, NodeUtil.precedence(type));\n                }\n                break;\n            }\n        case Token.HOOK:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                int p \u003d NodeUtil.precedence(type);\n                addLeftExpr(first, p + 1, context);\n                cc.addOp(\"?\", true);\n                addExpr(first.getNext(), 1);\n                cc.addOp(\":\", true);\n                addExpr(last, 1);\n                break;\n            }\n        case Token.REGEXP:\n            if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                throw new Error(\"Expected children to be strings\");\n            }\n            String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n            if (childCount \u003d\u003d 2) {\n                add(regexp + last.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                add(regexp);\n            }\n            break;\n        case Token.GET_REF:\n            add(first);\n            break;\n        case Token.REF_SPECIAL:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first);\n            add(\".\");\n            add((String) n.getProp(Node.NAME_PROP));\n            break;\n        case Token.FUNCTION:\n            if (n.getClass() !\u003d Node.class) {\n                throw new Error(\"Unexpected Node subclass.\");\n            }\n            Preconditions.checkState(childCount \u003d\u003d 3);\n            boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n            if (funcNeedsParens) {\n                add(\"(\");\n            }\n            add(\"function\");\n            add(first);\n            add(first.getNext());\n            add(last, Context.PRESERVE_BLOCK);\n            cc.endFunction(context \u003d\u003d Context.STATEMENT);\n            if (funcNeedsParens) {\n                add(\")\");\n            }\n            break;\n        case Token.GET:\n        case Token.SET:\n            Preconditions.checkState(n.getParent().getType() \u003d\u003d Token.OBJECTLIT);\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            Preconditions.checkState(first.getType() \u003d\u003d Token.FUNCTION);\n            Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n            if (type \u003d\u003d Token.GET) {\n                Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n                add(\"get \");\n            } else {\n                Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n                add(\"set \");\n            }\n            String name \u003d n.getString();\n            Node fn \u003d first;\n            Node parameters \u003d fn.getChildAtIndex(1);\n            Node body \u003d fn.getLastChild();\n            if (TokenStream.isJSIdentifier(name) \u0026\u0026 NodeUtil.isLatin(name)) {\n                add(name);\n            } else {\n                add(jsString(n.getString(), outputCharsetEncoder));\n            }\n            add(parameters);\n            add(body, Context.PRESERVE_BLOCK);\n            break;\n        case Token.SCRIPT:\n        case Token.BLOCK:\n            {\n                if (n.getClass() !\u003d Node.class) {\n                    throw new Error(\"Unexpected Node subclass.\");\n                }\n                boolean preserveBlock \u003d context \u003d\u003d Context.PRESERVE_BLOCK;\n                if (preserveBlock) {\n                    cc.beginBlock();\n                }\n                boolean preferLineBreaks \u003d type \u003d\u003d Token.SCRIPT || (type \u003d\u003d Token.BLOCK \u0026\u0026 !preserveBlock \u0026\u0026 n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.SCRIPT);\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    add(c, Context.STATEMENT);\n                    if (c.getType() \u003d\u003d Token.VAR) {\n                        cc.endStatement();\n                    }\n                    if (c.getType() \u003d\u003d Token.FUNCTION) {\n                        cc.maybeLineBreak();\n                    }\n                    if (preferLineBreaks) {\n                        cc.notePreferredLineBreak();\n                    }\n                }\n                if (preserveBlock) {\n                    cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                }\n                break;\n            }\n        case Token.FOR:\n            if (childCount \u003d\u003d 4) {\n                add(\"for(\");\n                if (first.getType() \u003d\u003d Token.VAR) {\n                    add(first, Context.IN_FOR_INIT_CLAUSE);\n                } else {\n                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                }\n                add(\";\");\n                add(first.getNext());\n                add(\";\");\n                add(first.getNext().getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                add(\"for(\");\n                add(first);\n                add(\"in\");\n                add(first.getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            }\n            break;\n        case Token.DO:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"do\");\n            addNonEmptyStatement(first, Context.OTHER, false);\n            add(\"while(\");\n            add(last);\n            add(\")\");\n            cc.endStatement();\n            break;\n        case Token.WHILE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"while(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.EMPTY:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            break;\n        case Token.GETPROP:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                Preconditions.checkState(last.getType() \u003d\u003d Token.STRING, \"Bad GETPROP: RHS should be STRING\");\n                boolean needsParens \u003d (first.getType() \u003d\u003d Token.NUMBER);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n                if (needsParens) {\n                    add(\")\");\n                }\n                add(\".\");\n                addIdentifier(last.getString());\n                break;\n            }\n        case Token.GETELEM:\n            Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n            addLeftExpr(first, NodeUtil.precedence(type), context);\n            add(\"[\");\n            add(first.getNext());\n            add(\"]\");\n            break;\n        case Token.WITH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"with(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.INC:\n        case Token.DEC:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                if (postProp !\u003d 0) {\n                    addLeftExpr(first, NodeUtil.precedence(type), context);\n                    cc.addOp(o, false);\n                } else {\n                    cc.addOp(o, false);\n                    add(first);\n                }\n                break;\n            }\n        case Token.CALL:\n            if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) \u0026\u0026 NodeUtil.isGet(first)) {\n                add(\"(0,\");\n                addExpr(first, NodeUtil.precedence(Token.COMMA));\n                add(\")\");\n            } else {\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n            }\n            add(\"(\");\n            addList(first.getNext());\n            add(\")\");\n            break;\n        case Token.IF:\n            boolean hasElse \u003d childCount \u003d\u003d 3;\n            boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n            if (ambiguousElseClause) {\n                cc.beginBlock();\n            }\n            add(\"if(\");\n            add(first);\n            add(\")\");\n            if (hasElse) {\n                addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                add(\"else\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n                Preconditions.checkState(childCount \u003d\u003d 2);\n            }\n            if (ambiguousElseClause) {\n                cc.endBlock();\n            }\n            break;\n        case Token.NULL:\n        case Token.THIS:\n        case Token.FALSE:\n        case Token.TRUE:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(Node.tokenToName(type));\n            break;\n        case Token.CONTINUE:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"continue\");\n            if (childCount \u003d\u003d 1) {\n                if (first.getType() !\u003d Token.LABEL_NAME) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.DEBUGGER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"debugger\");\n            cc.endStatement();\n            break;\n        case Token.BREAK:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"break\");\n            if (childCount \u003d\u003d 1) {\n                if (first.getType() !\u003d Token.LABEL_NAME) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.EXPR_VOID:\n            throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n        case Token.EXPR_RESULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first, Context.START_OF_EXPR);\n            cc.endStatement();\n            break;\n        case Token.NEW:\n            add(\"new \");\n            int precedence \u003d NodeUtil.precedence(type);\n            if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction())) {\n                precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n            }\n            addExpr(first, precedence);\n            Node next \u003d first.getNext();\n            if (next !\u003d null) {\n                add(\"(\");\n                addList(next);\n                add(\")\");\n            }\n            break;\n        case Token.STRING:\n            if (childCount !\u003d ((n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.OBJECTLIT) ? 1 : 0)) {\n                throw new IllegalStateException(\"Unexpected String children: \" + n.getParent().toStringTree());\n            }\n            add(jsString(n.getString(), outputCharsetEncoder));\n            break;\n        case Token.DELPROP:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"delete \");\n            add(first);\n            break;\n        case Token.OBJECTLIT:\n            {\n                boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                add(\"{\");\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    if (c !\u003d first) {\n                        cc.listSeparator();\n                    }\n                    if (c.getType() \u003d\u003d Token.GET || c.getType() \u003d\u003d Token.SET) {\n                        add(c);\n                    } else {\n                        if (c.getType() \u003d\u003d Token.STRING \u0026\u0026 !c.isQuotedString() \u0026\u0026 !TokenStream.isKeyword(c.getString()) \u0026\u0026 TokenStream.isJSIdentifier(c.getString()) \u0026\u0026 NodeUtil.isLatin(c.getString())) {\n                            add(c.getString());\n                        } else {\n                            addExpr(c, 1);\n                        }\n                        add(\":\");\n                        addExpr(c.getFirstChild(), 1);\n                    }\n                }\n                add(\"}\");\n                if (needsParens) {\n                    add(\")\");\n                }\n                break;\n            }\n        case Token.SWITCH:\n            add(\"switch(\");\n            add(first);\n            add(\")\");\n            cc.beginBlock();\n            addAllSiblings(first.getNext());\n            cc.endBlock(context \u003d\u003d Context.STATEMENT);\n            break;\n        case Token.CASE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"case \");\n            add(first);\n            addCaseBody(last);\n            break;\n        case Token.DEFAULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"default\");\n            addCaseBody(first);\n            break;\n        case Token.LABEL:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            if (first.getType() !\u003d Token.LABEL_NAME) {\n                throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n            }\n            add(first);\n            add(\":\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\n            break;\n        case Token.SETNAME:\n            break;\n        default:\n            throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n    cc.endSourceMapping(n);\n}",
      "path": "src/com/google/javascript/jscomp/CodeGenerator.java",
      "functionStartLine": 82,
      "functionName": "add",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,484 +1,484 @@\n void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n         return;\n     }\n     int type \u003d n.getType();\n     String opstr \u003d NodeUtil.opToStr(type);\n     int childCount \u003d n.getChildCount();\n     Node first \u003d n.getFirstChild();\n     Node last \u003d n.getLastChild();\n     if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n         Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n         int p \u003d NodeUtil.precedence(type);\n         addLeftExpr(first, p, context);\n         cc.addOp(opstr, true);\n         Context rhsContext \u003d getContextForNoInOperator(context);\n         if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n             addExpr(last, p, rhsContext);\n         } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n             addExpr(last, p, rhsContext);\n         } else {\n             addExpr(last, p + 1, rhsContext);\n         }\n         return;\n     }\n     cc.startSourceMapping(n);\n     switch(type) {\n         case Token.TRY:\n             {\n                 Preconditions.checkState(first.getNext().getType() \u003d\u003d Token.BLOCK \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n                 Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                 add(\"try\");\n                 add(first, Context.PRESERVE_BLOCK);\n                 Node catchblock \u003d first.getNext().getFirstChild();\n                 if (catchblock !\u003d null) {\n                     add(catchblock);\n                 }\n                 if (childCount \u003d\u003d 3) {\n                     add(\"finally\");\n                     add(last, Context.PRESERVE_BLOCK);\n                 }\n                 break;\n             }\n         case Token.CATCH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"catch(\");\n             add(first);\n             add(\")\");\n             add(last, Context.PRESERVE_BLOCK);\n             break;\n         case Token.THROW:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"throw\");\n             add(first);\n             cc.endStatement(true);\n             break;\n         case Token.RETURN:\n             add(\"return\");\n             if (childCount \u003d\u003d 1) {\n                 add(first);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 0);\n             }\n             cc.endStatement();\n             break;\n         case Token.VAR:\n             if (first !\u003d null) {\n                 add(\"var \");\n                 addList(first, false, getContextForNoInOperator(context));\n             }\n             break;\n         case Token.LABEL_NAME:\n             Preconditions.checkState(!n.getString().isEmpty());\n             addIdentifier(n.getString());\n             break;\n         case Token.NAME:\n             if (first \u003d\u003d null || first.getType() \u003d\u003d Token.EMPTY) {\n                 addIdentifier(n.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 addIdentifier(n.getString());\n                 cc.addOp(\"\u003d\", true);\n                 if (first.getType() \u003d\u003d Token.COMMA) {\n                     addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                 } else {\n                     addExpr(first, 0, getContextForNoInOperator(context));\n                 }\n             }\n             break;\n         case Token.ARRAYLIT:\n             add(\"[\");\n-            addArrayList(first, (int[]) n.getProp(Node.SKIP_INDEXES_PROP));\n+            addArrayList(first);\n             add(\"]\");\n             break;\n         case Token.LP:\n             add(\"(\");\n             addList(first);\n             add(\")\");\n             break;\n         case Token.COMMA:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             addList(first, false, context);\n             break;\n         case Token.NUMBER:\n             Preconditions.checkState(childCount \u003d\u003d ((n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.OBJECTLIT) ? 1 : 0));\n             cc.addNumber(n.getDouble());\n             break;\n         case Token.TYPEOF:\n         case Token.VOID:\n         case Token.NOT:\n         case Token.BITNOT:\n         case Token.POS:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                 addExpr(first, NodeUtil.precedence(type));\n                 break;\n             }\n         case Token.NEG:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 if (n.getFirstChild().getType() \u003d\u003d Token.NUMBER) {\n                     cc.addNumber(-n.getFirstChild().getDouble());\n                 } else {\n                     cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                     addExpr(first, NodeUtil.precedence(type));\n                 }\n                 break;\n             }\n         case Token.HOOK:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 int p \u003d NodeUtil.precedence(type);\n                 addLeftExpr(first, p + 1, context);\n                 cc.addOp(\"?\", true);\n                 addExpr(first.getNext(), 1);\n                 cc.addOp(\":\", true);\n                 addExpr(last, 1);\n                 break;\n             }\n         case Token.REGEXP:\n             if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                 throw new Error(\"Expected children to be strings\");\n             }\n             String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n             if (childCount \u003d\u003d 2) {\n                 add(regexp + last.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 add(regexp);\n             }\n             break;\n         case Token.GET_REF:\n             add(first);\n             break;\n         case Token.REF_SPECIAL:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first);\n             add(\".\");\n             add((String) n.getProp(Node.NAME_PROP));\n             break;\n         case Token.FUNCTION:\n             if (n.getClass() !\u003d Node.class) {\n                 throw new Error(\"Unexpected Node subclass.\");\n             }\n             Preconditions.checkState(childCount \u003d\u003d 3);\n             boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n             if (funcNeedsParens) {\n                 add(\"(\");\n             }\n             add(\"function\");\n             add(first);\n             add(first.getNext());\n             add(last, Context.PRESERVE_BLOCK);\n             cc.endFunction(context \u003d\u003d Context.STATEMENT);\n             if (funcNeedsParens) {\n                 add(\")\");\n             }\n             break;\n         case Token.GET:\n         case Token.SET:\n             Preconditions.checkState(n.getParent().getType() \u003d\u003d Token.OBJECTLIT);\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             Preconditions.checkState(first.getType() \u003d\u003d Token.FUNCTION);\n             Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n             if (type \u003d\u003d Token.GET) {\n                 Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n                 add(\"get \");\n             } else {\n                 Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n                 add(\"set \");\n             }\n             String name \u003d n.getString();\n             Node fn \u003d first;\n             Node parameters \u003d fn.getChildAtIndex(1);\n             Node body \u003d fn.getLastChild();\n             if (TokenStream.isJSIdentifier(name) \u0026\u0026 NodeUtil.isLatin(name)) {\n                 add(name);\n             } else {\n                 add(jsString(n.getString(), outputCharsetEncoder));\n             }\n             add(parameters);\n             add(body, Context.PRESERVE_BLOCK);\n             break;\n         case Token.SCRIPT:\n         case Token.BLOCK:\n             {\n                 if (n.getClass() !\u003d Node.class) {\n                     throw new Error(\"Unexpected Node subclass.\");\n                 }\n                 boolean preserveBlock \u003d context \u003d\u003d Context.PRESERVE_BLOCK;\n                 if (preserveBlock) {\n                     cc.beginBlock();\n                 }\n                 boolean preferLineBreaks \u003d type \u003d\u003d Token.SCRIPT || (type \u003d\u003d Token.BLOCK \u0026\u0026 !preserveBlock \u0026\u0026 n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.SCRIPT);\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     add(c, Context.STATEMENT);\n                     if (c.getType() \u003d\u003d Token.VAR) {\n                         cc.endStatement();\n                     }\n                     if (c.getType() \u003d\u003d Token.FUNCTION) {\n                         cc.maybeLineBreak();\n                     }\n                     if (preferLineBreaks) {\n                         cc.notePreferredLineBreak();\n                     }\n                 }\n                 if (preserveBlock) {\n                     cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                 }\n                 break;\n             }\n         case Token.FOR:\n             if (childCount \u003d\u003d 4) {\n                 add(\"for(\");\n                 if (first.getType() \u003d\u003d Token.VAR) {\n                     add(first, Context.IN_FOR_INIT_CLAUSE);\n                 } else {\n                     addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                 }\n                 add(\";\");\n                 add(first.getNext());\n                 add(\";\");\n                 add(first.getNext().getNext());\n                 add(\")\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 add(\"for(\");\n                 add(first);\n                 add(\"in\");\n                 add(first.getNext());\n                 add(\")\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             }\n             break;\n         case Token.DO:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"do\");\n             addNonEmptyStatement(first, Context.OTHER, false);\n             add(\"while(\");\n             add(last);\n             add(\")\");\n             cc.endStatement();\n             break;\n         case Token.WHILE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"while(\");\n             add(first);\n             add(\")\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.EMPTY:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             break;\n         case Token.GETPROP:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                 Preconditions.checkState(last.getType() \u003d\u003d Token.STRING, \"Bad GETPROP: RHS should be STRING\");\n                 boolean needsParens \u003d (first.getType() \u003d\u003d Token.NUMBER);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 add(\".\");\n                 addIdentifier(last.getString());\n                 break;\n             }\n         case Token.GETELEM:\n             Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n             addLeftExpr(first, NodeUtil.precedence(type), context);\n             add(\"[\");\n             add(first.getNext());\n             add(\"]\");\n             break;\n         case Token.WITH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"with(\");\n             add(first);\n             add(\")\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.INC:\n         case Token.DEC:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                 int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                 if (postProp !\u003d 0) {\n                     addLeftExpr(first, NodeUtil.precedence(type), context);\n                     cc.addOp(o, false);\n                 } else {\n                     cc.addOp(o, false);\n                     add(first);\n                 }\n                 break;\n             }\n         case Token.CALL:\n             if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) \u0026\u0026 NodeUtil.isGet(first)) {\n                 add(\"(0,\");\n                 addExpr(first, NodeUtil.precedence(Token.COMMA));\n                 add(\")\");\n             } else {\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n             }\n             add(\"(\");\n             addList(first.getNext());\n             add(\")\");\n             break;\n         case Token.IF:\n             boolean hasElse \u003d childCount \u003d\u003d 3;\n             boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n             if (ambiguousElseClause) {\n                 cc.beginBlock();\n             }\n             add(\"if(\");\n             add(first);\n             add(\")\");\n             if (hasElse) {\n                 addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                 add(\"else\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n                 Preconditions.checkState(childCount \u003d\u003d 2);\n             }\n             if (ambiguousElseClause) {\n                 cc.endBlock();\n             }\n             break;\n         case Token.NULL:\n         case Token.THIS:\n         case Token.FALSE:\n         case Token.TRUE:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(Node.tokenToName(type));\n             break;\n         case Token.CONTINUE:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"continue\");\n             if (childCount \u003d\u003d 1) {\n                 if (first.getType() !\u003d Token.LABEL_NAME) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.DEBUGGER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(\"debugger\");\n             cc.endStatement();\n             break;\n         case Token.BREAK:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"break\");\n             if (childCount \u003d\u003d 1) {\n                 if (first.getType() !\u003d Token.LABEL_NAME) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.EXPR_VOID:\n             throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n         case Token.EXPR_RESULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first, Context.START_OF_EXPR);\n             cc.endStatement();\n             break;\n         case Token.NEW:\n             add(\"new \");\n             int precedence \u003d NodeUtil.precedence(type);\n             if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction())) {\n                 precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n             }\n             addExpr(first, precedence);\n             Node next \u003d first.getNext();\n             if (next !\u003d null) {\n                 add(\"(\");\n                 addList(next);\n                 add(\")\");\n             }\n             break;\n         case Token.STRING:\n             if (childCount !\u003d ((n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.OBJECTLIT) ? 1 : 0)) {\n                 throw new IllegalStateException(\"Unexpected String children: \" + n.getParent().toStringTree());\n             }\n             add(jsString(n.getString(), outputCharsetEncoder));\n             break;\n         case Token.DELPROP:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"delete \");\n             add(first);\n             break;\n         case Token.OBJECTLIT:\n             {\n                 boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 add(\"{\");\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     if (c !\u003d first) {\n                         cc.listSeparator();\n                     }\n                     if (c.getType() \u003d\u003d Token.GET || c.getType() \u003d\u003d Token.SET) {\n                         add(c);\n                     } else {\n                         if (c.getType() \u003d\u003d Token.STRING \u0026\u0026 !c.isQuotedString() \u0026\u0026 !TokenStream.isKeyword(c.getString()) \u0026\u0026 TokenStream.isJSIdentifier(c.getString()) \u0026\u0026 NodeUtil.isLatin(c.getString())) {\n                             add(c.getString());\n                         } else {\n                             addExpr(c, 1);\n                         }\n                         add(\":\");\n                         addExpr(c.getFirstChild(), 1);\n                     }\n                 }\n                 add(\"}\");\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 break;\n             }\n         case Token.SWITCH:\n             add(\"switch(\");\n             add(first);\n             add(\")\");\n             cc.beginBlock();\n             addAllSiblings(first.getNext());\n             cc.endBlock(context \u003d\u003d Context.STATEMENT);\n             break;\n         case Token.CASE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"case \");\n             add(first);\n             addCaseBody(last);\n             break;\n         case Token.DEFAULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"default\");\n             addCaseBody(first);\n             break;\n         case Token.LABEL:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             if (first.getType() !\u003d Token.LABEL_NAME) {\n                 throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n             }\n             add(first);\n             add(\":\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\n             break;\n         case Token.SETNAME:\n             break;\n         default:\n             throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n     }\n     cc.endSourceMapping(n);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ae2eb35cc611443ce1e440c2006bbe52f8191b4c": {
      "type": "Ybodychange",
      "commitMessage": "\nSome array handling cleanup.\n\nR\u003dacleung\nDELTA\u003d18  (12 added, 0 deleted, 6 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d531\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@787 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "2/15/11, 3:53 PM",
      "commitName": "ae2eb35cc611443ce1e440c2006bbe52f8191b4c",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "1/25/11, 2:14 PM",
      "commitNameOld": "6ee4f24898632726e63ade4b42636b18e1df6aa7",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 21.07,
      "commitsBetweenForRepo": 56,
      "commitsBetweenForFile": 1,
      "actualSource": "void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n        return;\n    }\n    int type \u003d n.getType();\n    String opstr \u003d NodeUtil.opToStr(type);\n    int childCount \u003d n.getChildCount();\n    Node first \u003d n.getFirstChild();\n    Node last \u003d n.getLastChild();\n    if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n        Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n        int p \u003d NodeUtil.precedence(type);\n        addLeftExpr(first, p, context);\n        cc.addOp(opstr, true);\n        Context rhsContext \u003d getContextForNoInOperator(context);\n        if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n            addExpr(last, p, rhsContext);\n        } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n            addExpr(last, p, rhsContext);\n        } else {\n            addExpr(last, p + 1, rhsContext);\n        }\n        return;\n    }\n    cc.startSourceMapping(n);\n    switch(type) {\n        case Token.TRY:\n            {\n                Preconditions.checkState(first.getNext().getType() \u003d\u003d Token.BLOCK \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n                Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                add(\"try\");\n                add(first, Context.PRESERVE_BLOCK);\n                Node catchblock \u003d first.getNext().getFirstChild();\n                if (catchblock !\u003d null) {\n                    add(catchblock);\n                }\n                if (childCount \u003d\u003d 3) {\n                    add(\"finally\");\n                    add(last, Context.PRESERVE_BLOCK);\n                }\n                break;\n            }\n        case Token.CATCH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"catch(\");\n            add(first);\n            add(\")\");\n            add(last, Context.PRESERVE_BLOCK);\n            break;\n        case Token.THROW:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"throw\");\n            add(first);\n            cc.endStatement(true);\n            break;\n        case Token.RETURN:\n            add(\"return\");\n            if (childCount \u003d\u003d 1) {\n                add(first);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 0);\n            }\n            cc.endStatement();\n            break;\n        case Token.VAR:\n            if (first !\u003d null) {\n                add(\"var \");\n                addList(first, false, getContextForNoInOperator(context));\n            }\n            break;\n        case Token.LABEL_NAME:\n            Preconditions.checkState(!n.getString().isEmpty());\n            addIdentifier(n.getString());\n            break;\n        case Token.NAME:\n            if (first \u003d\u003d null || first.getType() \u003d\u003d Token.EMPTY) {\n                addIdentifier(n.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                addIdentifier(n.getString());\n                cc.addOp(\"\u003d\", true);\n                if (first.getType() \u003d\u003d Token.COMMA) {\n                    addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                } else {\n                    addExpr(first, 0, getContextForNoInOperator(context));\n                }\n            }\n            break;\n        case Token.ARRAYLIT:\n            add(\"[\");\n            addArrayList(first, (int[]) n.getProp(Node.SKIP_INDEXES_PROP));\n            add(\"]\");\n            break;\n        case Token.LP:\n            add(\"(\");\n            addList(first);\n            add(\")\");\n            break;\n        case Token.COMMA:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            addList(first, false, context);\n            break;\n        case Token.NUMBER:\n            Preconditions.checkState(childCount \u003d\u003d ((n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.OBJECTLIT) ? 1 : 0));\n            cc.addNumber(n.getDouble());\n            break;\n        case Token.TYPEOF:\n        case Token.VOID:\n        case Token.NOT:\n        case Token.BITNOT:\n        case Token.POS:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                addExpr(first, NodeUtil.precedence(type));\n                break;\n            }\n        case Token.NEG:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                if (n.getFirstChild().getType() \u003d\u003d Token.NUMBER) {\n                    cc.addNumber(-n.getFirstChild().getDouble());\n                } else {\n                    cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                    addExpr(first, NodeUtil.precedence(type));\n                }\n                break;\n            }\n        case Token.HOOK:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                int p \u003d NodeUtil.precedence(type);\n                addLeftExpr(first, p + 1, context);\n                cc.addOp(\"?\", true);\n                addExpr(first.getNext(), 1);\n                cc.addOp(\":\", true);\n                addExpr(last, 1);\n                break;\n            }\n        case Token.REGEXP:\n            if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                throw new Error(\"Expected children to be strings\");\n            }\n            String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n            if (childCount \u003d\u003d 2) {\n                add(regexp + last.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                add(regexp);\n            }\n            break;\n        case Token.GET_REF:\n            add(first);\n            break;\n        case Token.REF_SPECIAL:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first);\n            add(\".\");\n            add((String) n.getProp(Node.NAME_PROP));\n            break;\n        case Token.FUNCTION:\n            if (n.getClass() !\u003d Node.class) {\n                throw new Error(\"Unexpected Node subclass.\");\n            }\n            Preconditions.checkState(childCount \u003d\u003d 3);\n            boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n            if (funcNeedsParens) {\n                add(\"(\");\n            }\n            add(\"function\");\n            add(first);\n            add(first.getNext());\n            add(last, Context.PRESERVE_BLOCK);\n            cc.endFunction(context \u003d\u003d Context.STATEMENT);\n            if (funcNeedsParens) {\n                add(\")\");\n            }\n            break;\n        case Token.GET:\n        case Token.SET:\n            Preconditions.checkState(n.getParent().getType() \u003d\u003d Token.OBJECTLIT);\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            Preconditions.checkState(first.getType() \u003d\u003d Token.FUNCTION);\n            Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n            if (type \u003d\u003d Token.GET) {\n                Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n                add(\"get \");\n            } else {\n                Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n                add(\"set \");\n            }\n            String name \u003d n.getString();\n            Node fn \u003d first;\n            Node parameters \u003d fn.getChildAtIndex(1);\n            Node body \u003d fn.getLastChild();\n            if (TokenStream.isJSIdentifier(name) \u0026\u0026 NodeUtil.isLatin(name)) {\n                add(name);\n            } else {\n                add(jsString(n.getString(), outputCharsetEncoder));\n            }\n            add(parameters);\n            add(body, Context.PRESERVE_BLOCK);\n            break;\n        case Token.SCRIPT:\n        case Token.BLOCK:\n            {\n                if (n.getClass() !\u003d Node.class) {\n                    throw new Error(\"Unexpected Node subclass.\");\n                }\n                boolean preserveBlock \u003d context \u003d\u003d Context.PRESERVE_BLOCK;\n                if (preserveBlock) {\n                    cc.beginBlock();\n                }\n                boolean preferLineBreaks \u003d type \u003d\u003d Token.SCRIPT || (type \u003d\u003d Token.BLOCK \u0026\u0026 !preserveBlock \u0026\u0026 n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.SCRIPT);\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    add(c, Context.STATEMENT);\n                    if (c.getType() \u003d\u003d Token.VAR) {\n                        cc.endStatement();\n                    }\n                    if (c.getType() \u003d\u003d Token.FUNCTION) {\n                        cc.maybeLineBreak();\n                    }\n                    if (preferLineBreaks) {\n                        cc.notePreferredLineBreak();\n                    }\n                }\n                if (preserveBlock) {\n                    cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                }\n                break;\n            }\n        case Token.FOR:\n            if (childCount \u003d\u003d 4) {\n                add(\"for(\");\n                if (first.getType() \u003d\u003d Token.VAR) {\n                    add(first, Context.IN_FOR_INIT_CLAUSE);\n                } else {\n                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                }\n                add(\";\");\n                add(first.getNext());\n                add(\";\");\n                add(first.getNext().getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                add(\"for(\");\n                add(first);\n                add(\"in\");\n                add(first.getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            }\n            break;\n        case Token.DO:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"do\");\n            addNonEmptyStatement(first, Context.OTHER, false);\n            add(\"while(\");\n            add(last);\n            add(\")\");\n            cc.endStatement();\n            break;\n        case Token.WHILE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"while(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.EMPTY:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            break;\n        case Token.GETPROP:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                Preconditions.checkState(last.getType() \u003d\u003d Token.STRING, \"Bad GETPROP: RHS should be STRING\");\n                boolean needsParens \u003d (first.getType() \u003d\u003d Token.NUMBER);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n                if (needsParens) {\n                    add(\")\");\n                }\n                add(\".\");\n                addIdentifier(last.getString());\n                break;\n            }\n        case Token.GETELEM:\n            Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n            addLeftExpr(first, NodeUtil.precedence(type), context);\n            add(\"[\");\n            add(first.getNext());\n            add(\"]\");\n            break;\n        case Token.WITH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"with(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.INC:\n        case Token.DEC:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                if (postProp !\u003d 0) {\n                    addLeftExpr(first, NodeUtil.precedence(type), context);\n                    cc.addOp(o, false);\n                } else {\n                    cc.addOp(o, false);\n                    add(first);\n                }\n                break;\n            }\n        case Token.CALL:\n            if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) \u0026\u0026 NodeUtil.isGet(first)) {\n                add(\"(0,\");\n                addExpr(first, NodeUtil.precedence(Token.COMMA));\n                add(\")\");\n            } else {\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n            }\n            add(\"(\");\n            addList(first.getNext());\n            add(\")\");\n            break;\n        case Token.IF:\n            boolean hasElse \u003d childCount \u003d\u003d 3;\n            boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n            if (ambiguousElseClause) {\n                cc.beginBlock();\n            }\n            add(\"if(\");\n            add(first);\n            add(\")\");\n            if (hasElse) {\n                addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                add(\"else\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n                Preconditions.checkState(childCount \u003d\u003d 2);\n            }\n            if (ambiguousElseClause) {\n                cc.endBlock();\n            }\n            break;\n        case Token.NULL:\n        case Token.THIS:\n        case Token.FALSE:\n        case Token.TRUE:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(Node.tokenToName(type));\n            break;\n        case Token.CONTINUE:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"continue\");\n            if (childCount \u003d\u003d 1) {\n                if (first.getType() !\u003d Token.LABEL_NAME) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.DEBUGGER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"debugger\");\n            cc.endStatement();\n            break;\n        case Token.BREAK:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"break\");\n            if (childCount \u003d\u003d 1) {\n                if (first.getType() !\u003d Token.LABEL_NAME) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.EXPR_VOID:\n            throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n        case Token.EXPR_RESULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first, Context.START_OF_EXPR);\n            cc.endStatement();\n            break;\n        case Token.NEW:\n            add(\"new \");\n            int precedence \u003d NodeUtil.precedence(type);\n            if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction())) {\n                precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n            }\n            addExpr(first, precedence);\n            Node next \u003d first.getNext();\n            if (next !\u003d null) {\n                add(\"(\");\n                addList(next);\n                add(\")\");\n            }\n            break;\n        case Token.STRING:\n            if (childCount !\u003d ((n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.OBJECTLIT) ? 1 : 0)) {\n                throw new IllegalStateException(\"Unexpected String children: \" + n.getParent().toStringTree());\n            }\n            add(jsString(n.getString(), outputCharsetEncoder));\n            break;\n        case Token.DELPROP:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"delete \");\n            add(first);\n            break;\n        case Token.OBJECTLIT:\n            {\n                boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                add(\"{\");\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    if (c !\u003d first) {\n                        cc.listSeparator();\n                    }\n                    if (c.getType() \u003d\u003d Token.GET || c.getType() \u003d\u003d Token.SET) {\n                        add(c);\n                    } else {\n                        if (c.getType() \u003d\u003d Token.STRING \u0026\u0026 !c.isQuotedString() \u0026\u0026 !TokenStream.isKeyword(c.getString()) \u0026\u0026 TokenStream.isJSIdentifier(c.getString()) \u0026\u0026 NodeUtil.isLatin(c.getString())) {\n                            add(c.getString());\n                        } else {\n                            addExpr(c, 1);\n                        }\n                        add(\":\");\n                        addExpr(c.getFirstChild(), 1);\n                    }\n                }\n                add(\"}\");\n                if (needsParens) {\n                    add(\")\");\n                }\n                break;\n            }\n        case Token.SWITCH:\n            add(\"switch(\");\n            add(first);\n            add(\")\");\n            cc.beginBlock();\n            addAllSiblings(first.getNext());\n            cc.endBlock(context \u003d\u003d Context.STATEMENT);\n            break;\n        case Token.CASE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"case \");\n            add(first);\n            addCaseBody(last);\n            break;\n        case Token.DEFAULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"default\");\n            addCaseBody(first);\n            break;\n        case Token.LABEL:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            if (first.getType() !\u003d Token.LABEL_NAME) {\n                throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n            }\n            add(first);\n            add(\":\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\n            break;\n        case Token.SETNAME:\n            break;\n        default:\n            throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n    cc.endSourceMapping(n);\n}",
      "path": "src/com/google/javascript/jscomp/CodeGenerator.java",
      "functionStartLine": 75,
      "functionName": "add",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,484 +1,484 @@\n void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n         return;\n     }\n     int type \u003d n.getType();\n     String opstr \u003d NodeUtil.opToStr(type);\n     int childCount \u003d n.getChildCount();\n     Node first \u003d n.getFirstChild();\n     Node last \u003d n.getLastChild();\n     if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n         Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n         int p \u003d NodeUtil.precedence(type);\n         addLeftExpr(first, p, context);\n         cc.addOp(opstr, true);\n         Context rhsContext \u003d getContextForNoInOperator(context);\n         if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n             addExpr(last, p, rhsContext);\n         } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n             addExpr(last, p, rhsContext);\n         } else {\n             addExpr(last, p + 1, rhsContext);\n         }\n         return;\n     }\n     cc.startSourceMapping(n);\n     switch(type) {\n         case Token.TRY:\n             {\n                 Preconditions.checkState(first.getNext().getType() \u003d\u003d Token.BLOCK \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n                 Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                 add(\"try\");\n                 add(first, Context.PRESERVE_BLOCK);\n                 Node catchblock \u003d first.getNext().getFirstChild();\n                 if (catchblock !\u003d null) {\n                     add(catchblock);\n                 }\n                 if (childCount \u003d\u003d 3) {\n                     add(\"finally\");\n                     add(last, Context.PRESERVE_BLOCK);\n                 }\n                 break;\n             }\n         case Token.CATCH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"catch(\");\n             add(first);\n             add(\")\");\n             add(last, Context.PRESERVE_BLOCK);\n             break;\n         case Token.THROW:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"throw\");\n             add(first);\n             cc.endStatement(true);\n             break;\n         case Token.RETURN:\n             add(\"return\");\n             if (childCount \u003d\u003d 1) {\n                 add(first);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 0);\n             }\n             cc.endStatement();\n             break;\n         case Token.VAR:\n             if (first !\u003d null) {\n                 add(\"var \");\n                 addList(first, false, getContextForNoInOperator(context));\n             }\n             break;\n         case Token.LABEL_NAME:\n             Preconditions.checkState(!n.getString().isEmpty());\n             addIdentifier(n.getString());\n             break;\n         case Token.NAME:\n             if (first \u003d\u003d null || first.getType() \u003d\u003d Token.EMPTY) {\n                 addIdentifier(n.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 addIdentifier(n.getString());\n                 cc.addOp(\"\u003d\", true);\n                 if (first.getType() \u003d\u003d Token.COMMA) {\n                     addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                 } else {\n                     addExpr(first, 0, getContextForNoInOperator(context));\n                 }\n             }\n             break;\n         case Token.ARRAYLIT:\n             add(\"[\");\n-            addList(first, (int[]) n.getProp(Node.SKIP_INDEXES_PROP));\n+            addArrayList(first, (int[]) n.getProp(Node.SKIP_INDEXES_PROP));\n             add(\"]\");\n             break;\n         case Token.LP:\n             add(\"(\");\n             addList(first);\n             add(\")\");\n             break;\n         case Token.COMMA:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             addList(first, false, context);\n             break;\n         case Token.NUMBER:\n             Preconditions.checkState(childCount \u003d\u003d ((n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.OBJECTLIT) ? 1 : 0));\n             cc.addNumber(n.getDouble());\n             break;\n         case Token.TYPEOF:\n         case Token.VOID:\n         case Token.NOT:\n         case Token.BITNOT:\n         case Token.POS:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                 addExpr(first, NodeUtil.precedence(type));\n                 break;\n             }\n         case Token.NEG:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 if (n.getFirstChild().getType() \u003d\u003d Token.NUMBER) {\n                     cc.addNumber(-n.getFirstChild().getDouble());\n                 } else {\n                     cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                     addExpr(first, NodeUtil.precedence(type));\n                 }\n                 break;\n             }\n         case Token.HOOK:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 int p \u003d NodeUtil.precedence(type);\n                 addLeftExpr(first, p + 1, context);\n                 cc.addOp(\"?\", true);\n                 addExpr(first.getNext(), 1);\n                 cc.addOp(\":\", true);\n                 addExpr(last, 1);\n                 break;\n             }\n         case Token.REGEXP:\n             if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                 throw new Error(\"Expected children to be strings\");\n             }\n             String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n             if (childCount \u003d\u003d 2) {\n                 add(regexp + last.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 add(regexp);\n             }\n             break;\n         case Token.GET_REF:\n             add(first);\n             break;\n         case Token.REF_SPECIAL:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first);\n             add(\".\");\n             add((String) n.getProp(Node.NAME_PROP));\n             break;\n         case Token.FUNCTION:\n             if (n.getClass() !\u003d Node.class) {\n                 throw new Error(\"Unexpected Node subclass.\");\n             }\n             Preconditions.checkState(childCount \u003d\u003d 3);\n             boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n             if (funcNeedsParens) {\n                 add(\"(\");\n             }\n             add(\"function\");\n             add(first);\n             add(first.getNext());\n             add(last, Context.PRESERVE_BLOCK);\n             cc.endFunction(context \u003d\u003d Context.STATEMENT);\n             if (funcNeedsParens) {\n                 add(\")\");\n             }\n             break;\n         case Token.GET:\n         case Token.SET:\n             Preconditions.checkState(n.getParent().getType() \u003d\u003d Token.OBJECTLIT);\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             Preconditions.checkState(first.getType() \u003d\u003d Token.FUNCTION);\n             Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n             if (type \u003d\u003d Token.GET) {\n                 Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n                 add(\"get \");\n             } else {\n                 Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n                 add(\"set \");\n             }\n             String name \u003d n.getString();\n             Node fn \u003d first;\n             Node parameters \u003d fn.getChildAtIndex(1);\n             Node body \u003d fn.getLastChild();\n             if (TokenStream.isJSIdentifier(name) \u0026\u0026 NodeUtil.isLatin(name)) {\n                 add(name);\n             } else {\n                 add(jsString(n.getString(), outputCharsetEncoder));\n             }\n             add(parameters);\n             add(body, Context.PRESERVE_BLOCK);\n             break;\n         case Token.SCRIPT:\n         case Token.BLOCK:\n             {\n                 if (n.getClass() !\u003d Node.class) {\n                     throw new Error(\"Unexpected Node subclass.\");\n                 }\n                 boolean preserveBlock \u003d context \u003d\u003d Context.PRESERVE_BLOCK;\n                 if (preserveBlock) {\n                     cc.beginBlock();\n                 }\n                 boolean preferLineBreaks \u003d type \u003d\u003d Token.SCRIPT || (type \u003d\u003d Token.BLOCK \u0026\u0026 !preserveBlock \u0026\u0026 n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.SCRIPT);\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     add(c, Context.STATEMENT);\n                     if (c.getType() \u003d\u003d Token.VAR) {\n                         cc.endStatement();\n                     }\n                     if (c.getType() \u003d\u003d Token.FUNCTION) {\n                         cc.maybeLineBreak();\n                     }\n                     if (preferLineBreaks) {\n                         cc.notePreferredLineBreak();\n                     }\n                 }\n                 if (preserveBlock) {\n                     cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                 }\n                 break;\n             }\n         case Token.FOR:\n             if (childCount \u003d\u003d 4) {\n                 add(\"for(\");\n                 if (first.getType() \u003d\u003d Token.VAR) {\n                     add(first, Context.IN_FOR_INIT_CLAUSE);\n                 } else {\n                     addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                 }\n                 add(\";\");\n                 add(first.getNext());\n                 add(\";\");\n                 add(first.getNext().getNext());\n                 add(\")\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 add(\"for(\");\n                 add(first);\n                 add(\"in\");\n                 add(first.getNext());\n                 add(\")\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             }\n             break;\n         case Token.DO:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"do\");\n             addNonEmptyStatement(first, Context.OTHER, false);\n             add(\"while(\");\n             add(last);\n             add(\")\");\n             cc.endStatement();\n             break;\n         case Token.WHILE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"while(\");\n             add(first);\n             add(\")\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.EMPTY:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             break;\n         case Token.GETPROP:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                 Preconditions.checkState(last.getType() \u003d\u003d Token.STRING, \"Bad GETPROP: RHS should be STRING\");\n                 boolean needsParens \u003d (first.getType() \u003d\u003d Token.NUMBER);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 add(\".\");\n                 addIdentifier(last.getString());\n                 break;\n             }\n         case Token.GETELEM:\n             Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n             addLeftExpr(first, NodeUtil.precedence(type), context);\n             add(\"[\");\n             add(first.getNext());\n             add(\"]\");\n             break;\n         case Token.WITH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"with(\");\n             add(first);\n             add(\")\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.INC:\n         case Token.DEC:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                 int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                 if (postProp !\u003d 0) {\n                     addLeftExpr(first, NodeUtil.precedence(type), context);\n                     cc.addOp(o, false);\n                 } else {\n                     cc.addOp(o, false);\n                     add(first);\n                 }\n                 break;\n             }\n         case Token.CALL:\n             if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) \u0026\u0026 NodeUtil.isGet(first)) {\n                 add(\"(0,\");\n                 addExpr(first, NodeUtil.precedence(Token.COMMA));\n                 add(\")\");\n             } else {\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n             }\n             add(\"(\");\n             addList(first.getNext());\n             add(\")\");\n             break;\n         case Token.IF:\n             boolean hasElse \u003d childCount \u003d\u003d 3;\n             boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n             if (ambiguousElseClause) {\n                 cc.beginBlock();\n             }\n             add(\"if(\");\n             add(first);\n             add(\")\");\n             if (hasElse) {\n                 addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                 add(\"else\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n                 Preconditions.checkState(childCount \u003d\u003d 2);\n             }\n             if (ambiguousElseClause) {\n                 cc.endBlock();\n             }\n             break;\n         case Token.NULL:\n         case Token.THIS:\n         case Token.FALSE:\n         case Token.TRUE:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(Node.tokenToName(type));\n             break;\n         case Token.CONTINUE:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"continue\");\n             if (childCount \u003d\u003d 1) {\n                 if (first.getType() !\u003d Token.LABEL_NAME) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.DEBUGGER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(\"debugger\");\n             cc.endStatement();\n             break;\n         case Token.BREAK:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"break\");\n             if (childCount \u003d\u003d 1) {\n                 if (first.getType() !\u003d Token.LABEL_NAME) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.EXPR_VOID:\n             throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n         case Token.EXPR_RESULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first, Context.START_OF_EXPR);\n             cc.endStatement();\n             break;\n         case Token.NEW:\n             add(\"new \");\n             int precedence \u003d NodeUtil.precedence(type);\n             if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction())) {\n                 precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n             }\n             addExpr(first, precedence);\n             Node next \u003d first.getNext();\n             if (next !\u003d null) {\n                 add(\"(\");\n                 addList(next);\n                 add(\")\");\n             }\n             break;\n         case Token.STRING:\n             if (childCount !\u003d ((n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.OBJECTLIT) ? 1 : 0)) {\n                 throw new IllegalStateException(\"Unexpected String children: \" + n.getParent().toStringTree());\n             }\n             add(jsString(n.getString(), outputCharsetEncoder));\n             break;\n         case Token.DELPROP:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"delete \");\n             add(first);\n             break;\n         case Token.OBJECTLIT:\n             {\n                 boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 add(\"{\");\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     if (c !\u003d first) {\n                         cc.listSeparator();\n                     }\n                     if (c.getType() \u003d\u003d Token.GET || c.getType() \u003d\u003d Token.SET) {\n                         add(c);\n                     } else {\n                         if (c.getType() \u003d\u003d Token.STRING \u0026\u0026 !c.isQuotedString() \u0026\u0026 !TokenStream.isKeyword(c.getString()) \u0026\u0026 TokenStream.isJSIdentifier(c.getString()) \u0026\u0026 NodeUtil.isLatin(c.getString())) {\n                             add(c.getString());\n                         } else {\n                             addExpr(c, 1);\n                         }\n                         add(\":\");\n                         addExpr(c.getFirstChild(), 1);\n                     }\n                 }\n                 add(\"}\");\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 break;\n             }\n         case Token.SWITCH:\n             add(\"switch(\");\n             add(first);\n             add(\")\");\n             cc.beginBlock();\n             addAllSiblings(first.getNext());\n             cc.endBlock(context \u003d\u003d Context.STATEMENT);\n             break;\n         case Token.CASE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"case \");\n             add(first);\n             addCaseBody(last);\n             break;\n         case Token.DEFAULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"default\");\n             addCaseBody(first);\n             break;\n         case Token.LABEL:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             if (first.getType() !\u003d Token.LABEL_NAME) {\n                 throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n             }\n             add(first);\n             add(\":\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\n             break;\n         case Token.SETNAME:\n             break;\n         default:\n             throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n     }\n     cc.endSourceMapping(n);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6ee4f24898632726e63ade4b42636b18e1df6aa7": {
      "type": "Ybodychange",
      "commitMessage": "\nPreserve quotes on object literals unless they are explicitly removed.\n\nR\u003dacleung\nDELTA\u003d22  (18 added, 0 deleted, 4 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d347\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@730 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "1/25/11, 2:14 PM",
      "commitName": "6ee4f24898632726e63ade4b42636b18e1df6aa7",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "1/11/11, 8:36 AM",
      "commitNameOld": "9f8345afa4e5eaa24e3ff6a84d16691764698799",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 14.23,
      "commitsBetweenForRepo": 42,
      "commitsBetweenForFile": 1,
      "actualSource": "void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n        return;\n    }\n    int type \u003d n.getType();\n    String opstr \u003d NodeUtil.opToStr(type);\n    int childCount \u003d n.getChildCount();\n    Node first \u003d n.getFirstChild();\n    Node last \u003d n.getLastChild();\n    if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n        Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n        int p \u003d NodeUtil.precedence(type);\n        addLeftExpr(first, p, context);\n        cc.addOp(opstr, true);\n        Context rhsContext \u003d getContextForNoInOperator(context);\n        if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n            addExpr(last, p, rhsContext);\n        } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n            addExpr(last, p, rhsContext);\n        } else {\n            addExpr(last, p + 1, rhsContext);\n        }\n        return;\n    }\n    cc.startSourceMapping(n);\n    switch(type) {\n        case Token.TRY:\n            {\n                Preconditions.checkState(first.getNext().getType() \u003d\u003d Token.BLOCK \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n                Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                add(\"try\");\n                add(first, Context.PRESERVE_BLOCK);\n                Node catchblock \u003d first.getNext().getFirstChild();\n                if (catchblock !\u003d null) {\n                    add(catchblock);\n                }\n                if (childCount \u003d\u003d 3) {\n                    add(\"finally\");\n                    add(last, Context.PRESERVE_BLOCK);\n                }\n                break;\n            }\n        case Token.CATCH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"catch(\");\n            add(first);\n            add(\")\");\n            add(last, Context.PRESERVE_BLOCK);\n            break;\n        case Token.THROW:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"throw\");\n            add(first);\n            cc.endStatement(true);\n            break;\n        case Token.RETURN:\n            add(\"return\");\n            if (childCount \u003d\u003d 1) {\n                add(first);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 0);\n            }\n            cc.endStatement();\n            break;\n        case Token.VAR:\n            if (first !\u003d null) {\n                add(\"var \");\n                addList(first, false, getContextForNoInOperator(context));\n            }\n            break;\n        case Token.LABEL_NAME:\n            Preconditions.checkState(!n.getString().isEmpty());\n            addIdentifier(n.getString());\n            break;\n        case Token.NAME:\n            if (first \u003d\u003d null || first.getType() \u003d\u003d Token.EMPTY) {\n                addIdentifier(n.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                addIdentifier(n.getString());\n                cc.addOp(\"\u003d\", true);\n                if (first.getType() \u003d\u003d Token.COMMA) {\n                    addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                } else {\n                    addExpr(first, 0, getContextForNoInOperator(context));\n                }\n            }\n            break;\n        case Token.ARRAYLIT:\n            add(\"[\");\n            addList(first, (int[]) n.getProp(Node.SKIP_INDEXES_PROP));\n            add(\"]\");\n            break;\n        case Token.LP:\n            add(\"(\");\n            addList(first);\n            add(\")\");\n            break;\n        case Token.COMMA:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            addList(first, false, context);\n            break;\n        case Token.NUMBER:\n            Preconditions.checkState(childCount \u003d\u003d ((n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.OBJECTLIT) ? 1 : 0));\n            cc.addNumber(n.getDouble());\n            break;\n        case Token.TYPEOF:\n        case Token.VOID:\n        case Token.NOT:\n        case Token.BITNOT:\n        case Token.POS:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                addExpr(first, NodeUtil.precedence(type));\n                break;\n            }\n        case Token.NEG:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                if (n.getFirstChild().getType() \u003d\u003d Token.NUMBER) {\n                    cc.addNumber(-n.getFirstChild().getDouble());\n                } else {\n                    cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                    addExpr(first, NodeUtil.precedence(type));\n                }\n                break;\n            }\n        case Token.HOOK:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                int p \u003d NodeUtil.precedence(type);\n                addLeftExpr(first, p + 1, context);\n                cc.addOp(\"?\", true);\n                addExpr(first.getNext(), 1);\n                cc.addOp(\":\", true);\n                addExpr(last, 1);\n                break;\n            }\n        case Token.REGEXP:\n            if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                throw new Error(\"Expected children to be strings\");\n            }\n            String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n            if (childCount \u003d\u003d 2) {\n                add(regexp + last.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                add(regexp);\n            }\n            break;\n        case Token.GET_REF:\n            add(first);\n            break;\n        case Token.REF_SPECIAL:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first);\n            add(\".\");\n            add((String) n.getProp(Node.NAME_PROP));\n            break;\n        case Token.FUNCTION:\n            if (n.getClass() !\u003d Node.class) {\n                throw new Error(\"Unexpected Node subclass.\");\n            }\n            Preconditions.checkState(childCount \u003d\u003d 3);\n            boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n            if (funcNeedsParens) {\n                add(\"(\");\n            }\n            add(\"function\");\n            add(first);\n            add(first.getNext());\n            add(last, Context.PRESERVE_BLOCK);\n            cc.endFunction(context \u003d\u003d Context.STATEMENT);\n            if (funcNeedsParens) {\n                add(\")\");\n            }\n            break;\n        case Token.GET:\n        case Token.SET:\n            Preconditions.checkState(n.getParent().getType() \u003d\u003d Token.OBJECTLIT);\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            Preconditions.checkState(first.getType() \u003d\u003d Token.FUNCTION);\n            Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n            if (type \u003d\u003d Token.GET) {\n                Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n                add(\"get \");\n            } else {\n                Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n                add(\"set \");\n            }\n            String name \u003d n.getString();\n            Node fn \u003d first;\n            Node parameters \u003d fn.getChildAtIndex(1);\n            Node body \u003d fn.getLastChild();\n            if (TokenStream.isJSIdentifier(name) \u0026\u0026 NodeUtil.isLatin(name)) {\n                add(name);\n            } else {\n                add(jsString(n.getString(), outputCharsetEncoder));\n            }\n            add(parameters);\n            add(body, Context.PRESERVE_BLOCK);\n            break;\n        case Token.SCRIPT:\n        case Token.BLOCK:\n            {\n                if (n.getClass() !\u003d Node.class) {\n                    throw new Error(\"Unexpected Node subclass.\");\n                }\n                boolean preserveBlock \u003d context \u003d\u003d Context.PRESERVE_BLOCK;\n                if (preserveBlock) {\n                    cc.beginBlock();\n                }\n                boolean preferLineBreaks \u003d type \u003d\u003d Token.SCRIPT || (type \u003d\u003d Token.BLOCK \u0026\u0026 !preserveBlock \u0026\u0026 n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.SCRIPT);\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    add(c, Context.STATEMENT);\n                    if (c.getType() \u003d\u003d Token.VAR) {\n                        cc.endStatement();\n                    }\n                    if (c.getType() \u003d\u003d Token.FUNCTION) {\n                        cc.maybeLineBreak();\n                    }\n                    if (preferLineBreaks) {\n                        cc.notePreferredLineBreak();\n                    }\n                }\n                if (preserveBlock) {\n                    cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                }\n                break;\n            }\n        case Token.FOR:\n            if (childCount \u003d\u003d 4) {\n                add(\"for(\");\n                if (first.getType() \u003d\u003d Token.VAR) {\n                    add(first, Context.IN_FOR_INIT_CLAUSE);\n                } else {\n                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                }\n                add(\";\");\n                add(first.getNext());\n                add(\";\");\n                add(first.getNext().getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                add(\"for(\");\n                add(first);\n                add(\"in\");\n                add(first.getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            }\n            break;\n        case Token.DO:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"do\");\n            addNonEmptyStatement(first, Context.OTHER, false);\n            add(\"while(\");\n            add(last);\n            add(\")\");\n            cc.endStatement();\n            break;\n        case Token.WHILE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"while(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.EMPTY:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            break;\n        case Token.GETPROP:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                Preconditions.checkState(last.getType() \u003d\u003d Token.STRING, \"Bad GETPROP: RHS should be STRING\");\n                boolean needsParens \u003d (first.getType() \u003d\u003d Token.NUMBER);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n                if (needsParens) {\n                    add(\")\");\n                }\n                add(\".\");\n                addIdentifier(last.getString());\n                break;\n            }\n        case Token.GETELEM:\n            Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n            addLeftExpr(first, NodeUtil.precedence(type), context);\n            add(\"[\");\n            add(first.getNext());\n            add(\"]\");\n            break;\n        case Token.WITH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"with(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.INC:\n        case Token.DEC:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                if (postProp !\u003d 0) {\n                    addLeftExpr(first, NodeUtil.precedence(type), context);\n                    cc.addOp(o, false);\n                } else {\n                    cc.addOp(o, false);\n                    add(first);\n                }\n                break;\n            }\n        case Token.CALL:\n            if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) \u0026\u0026 NodeUtil.isGet(first)) {\n                add(\"(0,\");\n                addExpr(first, NodeUtil.precedence(Token.COMMA));\n                add(\")\");\n            } else {\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n            }\n            add(\"(\");\n            addList(first.getNext());\n            add(\")\");\n            break;\n        case Token.IF:\n            boolean hasElse \u003d childCount \u003d\u003d 3;\n            boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n            if (ambiguousElseClause) {\n                cc.beginBlock();\n            }\n            add(\"if(\");\n            add(first);\n            add(\")\");\n            if (hasElse) {\n                addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                add(\"else\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n                Preconditions.checkState(childCount \u003d\u003d 2);\n            }\n            if (ambiguousElseClause) {\n                cc.endBlock();\n            }\n            break;\n        case Token.NULL:\n        case Token.THIS:\n        case Token.FALSE:\n        case Token.TRUE:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(Node.tokenToName(type));\n            break;\n        case Token.CONTINUE:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"continue\");\n            if (childCount \u003d\u003d 1) {\n                if (first.getType() !\u003d Token.LABEL_NAME) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.DEBUGGER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"debugger\");\n            cc.endStatement();\n            break;\n        case Token.BREAK:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"break\");\n            if (childCount \u003d\u003d 1) {\n                if (first.getType() !\u003d Token.LABEL_NAME) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.EXPR_VOID:\n            throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n        case Token.EXPR_RESULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first, Context.START_OF_EXPR);\n            cc.endStatement();\n            break;\n        case Token.NEW:\n            add(\"new \");\n            int precedence \u003d NodeUtil.precedence(type);\n            if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction())) {\n                precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n            }\n            addExpr(first, precedence);\n            Node next \u003d first.getNext();\n            if (next !\u003d null) {\n                add(\"(\");\n                addList(next);\n                add(\")\");\n            }\n            break;\n        case Token.STRING:\n            if (childCount !\u003d ((n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.OBJECTLIT) ? 1 : 0)) {\n                throw new IllegalStateException(\"Unexpected String children: \" + n.getParent().toStringTree());\n            }\n            add(jsString(n.getString(), outputCharsetEncoder));\n            break;\n        case Token.DELPROP:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"delete \");\n            add(first);\n            break;\n        case Token.OBJECTLIT:\n            {\n                boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                add(\"{\");\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    if (c !\u003d first) {\n                        cc.listSeparator();\n                    }\n                    if (c.getType() \u003d\u003d Token.GET || c.getType() \u003d\u003d Token.SET) {\n                        add(c);\n                    } else {\n                        if (c.getType() \u003d\u003d Token.STRING \u0026\u0026 !c.isQuotedString() \u0026\u0026 !TokenStream.isKeyword(c.getString()) \u0026\u0026 TokenStream.isJSIdentifier(c.getString()) \u0026\u0026 NodeUtil.isLatin(c.getString())) {\n                            add(c.getString());\n                        } else {\n                            addExpr(c, 1);\n                        }\n                        add(\":\");\n                        addExpr(c.getFirstChild(), 1);\n                    }\n                }\n                add(\"}\");\n                if (needsParens) {\n                    add(\")\");\n                }\n                break;\n            }\n        case Token.SWITCH:\n            add(\"switch(\");\n            add(first);\n            add(\")\");\n            cc.beginBlock();\n            addAllSiblings(first.getNext());\n            cc.endBlock(context \u003d\u003d Context.STATEMENT);\n            break;\n        case Token.CASE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"case \");\n            add(first);\n            addCaseBody(last);\n            break;\n        case Token.DEFAULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"default\");\n            addCaseBody(first);\n            break;\n        case Token.LABEL:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            if (first.getType() !\u003d Token.LABEL_NAME) {\n                throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n            }\n            add(first);\n            add(\":\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\n            break;\n        case Token.SETNAME:\n            break;\n        default:\n            throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n    cc.endSourceMapping(n);\n}",
      "path": "src/com/google/javascript/jscomp/CodeGenerator.java",
      "functionStartLine": 75,
      "functionName": "add",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,484 +1,484 @@\n void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n         return;\n     }\n     int type \u003d n.getType();\n     String opstr \u003d NodeUtil.opToStr(type);\n     int childCount \u003d n.getChildCount();\n     Node first \u003d n.getFirstChild();\n     Node last \u003d n.getLastChild();\n     if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n         Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n         int p \u003d NodeUtil.precedence(type);\n         addLeftExpr(first, p, context);\n         cc.addOp(opstr, true);\n         Context rhsContext \u003d getContextForNoInOperator(context);\n         if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n             addExpr(last, p, rhsContext);\n         } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n             addExpr(last, p, rhsContext);\n         } else {\n             addExpr(last, p + 1, rhsContext);\n         }\n         return;\n     }\n     cc.startSourceMapping(n);\n     switch(type) {\n         case Token.TRY:\n             {\n                 Preconditions.checkState(first.getNext().getType() \u003d\u003d Token.BLOCK \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n                 Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                 add(\"try\");\n                 add(first, Context.PRESERVE_BLOCK);\n                 Node catchblock \u003d first.getNext().getFirstChild();\n                 if (catchblock !\u003d null) {\n                     add(catchblock);\n                 }\n                 if (childCount \u003d\u003d 3) {\n                     add(\"finally\");\n                     add(last, Context.PRESERVE_BLOCK);\n                 }\n                 break;\n             }\n         case Token.CATCH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"catch(\");\n             add(first);\n             add(\")\");\n             add(last, Context.PRESERVE_BLOCK);\n             break;\n         case Token.THROW:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"throw\");\n             add(first);\n             cc.endStatement(true);\n             break;\n         case Token.RETURN:\n             add(\"return\");\n             if (childCount \u003d\u003d 1) {\n                 add(first);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 0);\n             }\n             cc.endStatement();\n             break;\n         case Token.VAR:\n             if (first !\u003d null) {\n                 add(\"var \");\n                 addList(first, false, getContextForNoInOperator(context));\n             }\n             break;\n         case Token.LABEL_NAME:\n             Preconditions.checkState(!n.getString().isEmpty());\n             addIdentifier(n.getString());\n             break;\n         case Token.NAME:\n             if (first \u003d\u003d null || first.getType() \u003d\u003d Token.EMPTY) {\n                 addIdentifier(n.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 addIdentifier(n.getString());\n                 cc.addOp(\"\u003d\", true);\n                 if (first.getType() \u003d\u003d Token.COMMA) {\n                     addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                 } else {\n                     addExpr(first, 0, getContextForNoInOperator(context));\n                 }\n             }\n             break;\n         case Token.ARRAYLIT:\n             add(\"[\");\n             addList(first, (int[]) n.getProp(Node.SKIP_INDEXES_PROP));\n             add(\"]\");\n             break;\n         case Token.LP:\n             add(\"(\");\n             addList(first);\n             add(\")\");\n             break;\n         case Token.COMMA:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             addList(first, false, context);\n             break;\n         case Token.NUMBER:\n             Preconditions.checkState(childCount \u003d\u003d ((n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.OBJECTLIT) ? 1 : 0));\n             cc.addNumber(n.getDouble());\n             break;\n         case Token.TYPEOF:\n         case Token.VOID:\n         case Token.NOT:\n         case Token.BITNOT:\n         case Token.POS:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                 addExpr(first, NodeUtil.precedence(type));\n                 break;\n             }\n         case Token.NEG:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 if (n.getFirstChild().getType() \u003d\u003d Token.NUMBER) {\n                     cc.addNumber(-n.getFirstChild().getDouble());\n                 } else {\n                     cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                     addExpr(first, NodeUtil.precedence(type));\n                 }\n                 break;\n             }\n         case Token.HOOK:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 int p \u003d NodeUtil.precedence(type);\n                 addLeftExpr(first, p + 1, context);\n                 cc.addOp(\"?\", true);\n                 addExpr(first.getNext(), 1);\n                 cc.addOp(\":\", true);\n                 addExpr(last, 1);\n                 break;\n             }\n         case Token.REGEXP:\n             if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                 throw new Error(\"Expected children to be strings\");\n             }\n             String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n             if (childCount \u003d\u003d 2) {\n                 add(regexp + last.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 add(regexp);\n             }\n             break;\n         case Token.GET_REF:\n             add(first);\n             break;\n         case Token.REF_SPECIAL:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first);\n             add(\".\");\n             add((String) n.getProp(Node.NAME_PROP));\n             break;\n         case Token.FUNCTION:\n             if (n.getClass() !\u003d Node.class) {\n                 throw new Error(\"Unexpected Node subclass.\");\n             }\n             Preconditions.checkState(childCount \u003d\u003d 3);\n             boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n             if (funcNeedsParens) {\n                 add(\"(\");\n             }\n             add(\"function\");\n             add(first);\n             add(first.getNext());\n             add(last, Context.PRESERVE_BLOCK);\n             cc.endFunction(context \u003d\u003d Context.STATEMENT);\n             if (funcNeedsParens) {\n                 add(\")\");\n             }\n             break;\n         case Token.GET:\n         case Token.SET:\n             Preconditions.checkState(n.getParent().getType() \u003d\u003d Token.OBJECTLIT);\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             Preconditions.checkState(first.getType() \u003d\u003d Token.FUNCTION);\n             Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n             if (type \u003d\u003d Token.GET) {\n                 Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n                 add(\"get \");\n             } else {\n                 Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n                 add(\"set \");\n             }\n             String name \u003d n.getString();\n             Node fn \u003d first;\n             Node parameters \u003d fn.getChildAtIndex(1);\n             Node body \u003d fn.getLastChild();\n             if (TokenStream.isJSIdentifier(name) \u0026\u0026 NodeUtil.isLatin(name)) {\n                 add(name);\n             } else {\n                 add(jsString(n.getString(), outputCharsetEncoder));\n             }\n             add(parameters);\n             add(body, Context.PRESERVE_BLOCK);\n             break;\n         case Token.SCRIPT:\n         case Token.BLOCK:\n             {\n                 if (n.getClass() !\u003d Node.class) {\n                     throw new Error(\"Unexpected Node subclass.\");\n                 }\n                 boolean preserveBlock \u003d context \u003d\u003d Context.PRESERVE_BLOCK;\n                 if (preserveBlock) {\n                     cc.beginBlock();\n                 }\n                 boolean preferLineBreaks \u003d type \u003d\u003d Token.SCRIPT || (type \u003d\u003d Token.BLOCK \u0026\u0026 !preserveBlock \u0026\u0026 n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.SCRIPT);\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     add(c, Context.STATEMENT);\n                     if (c.getType() \u003d\u003d Token.VAR) {\n                         cc.endStatement();\n                     }\n                     if (c.getType() \u003d\u003d Token.FUNCTION) {\n                         cc.maybeLineBreak();\n                     }\n                     if (preferLineBreaks) {\n                         cc.notePreferredLineBreak();\n                     }\n                 }\n                 if (preserveBlock) {\n                     cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                 }\n                 break;\n             }\n         case Token.FOR:\n             if (childCount \u003d\u003d 4) {\n                 add(\"for(\");\n                 if (first.getType() \u003d\u003d Token.VAR) {\n                     add(first, Context.IN_FOR_INIT_CLAUSE);\n                 } else {\n                     addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                 }\n                 add(\";\");\n                 add(first.getNext());\n                 add(\";\");\n                 add(first.getNext().getNext());\n                 add(\")\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 add(\"for(\");\n                 add(first);\n                 add(\"in\");\n                 add(first.getNext());\n                 add(\")\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             }\n             break;\n         case Token.DO:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"do\");\n             addNonEmptyStatement(first, Context.OTHER, false);\n             add(\"while(\");\n             add(last);\n             add(\")\");\n             cc.endStatement();\n             break;\n         case Token.WHILE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"while(\");\n             add(first);\n             add(\")\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.EMPTY:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             break;\n         case Token.GETPROP:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                 Preconditions.checkState(last.getType() \u003d\u003d Token.STRING, \"Bad GETPROP: RHS should be STRING\");\n                 boolean needsParens \u003d (first.getType() \u003d\u003d Token.NUMBER);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 add(\".\");\n                 addIdentifier(last.getString());\n                 break;\n             }\n         case Token.GETELEM:\n             Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n             addLeftExpr(first, NodeUtil.precedence(type), context);\n             add(\"[\");\n             add(first.getNext());\n             add(\"]\");\n             break;\n         case Token.WITH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"with(\");\n             add(first);\n             add(\")\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.INC:\n         case Token.DEC:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                 int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                 if (postProp !\u003d 0) {\n                     addLeftExpr(first, NodeUtil.precedence(type), context);\n                     cc.addOp(o, false);\n                 } else {\n                     cc.addOp(o, false);\n                     add(first);\n                 }\n                 break;\n             }\n         case Token.CALL:\n             if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) \u0026\u0026 NodeUtil.isGet(first)) {\n                 add(\"(0,\");\n                 addExpr(first, NodeUtil.precedence(Token.COMMA));\n                 add(\")\");\n             } else {\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n             }\n             add(\"(\");\n             addList(first.getNext());\n             add(\")\");\n             break;\n         case Token.IF:\n             boolean hasElse \u003d childCount \u003d\u003d 3;\n             boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n             if (ambiguousElseClause) {\n                 cc.beginBlock();\n             }\n             add(\"if(\");\n             add(first);\n             add(\")\");\n             if (hasElse) {\n                 addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                 add(\"else\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n                 Preconditions.checkState(childCount \u003d\u003d 2);\n             }\n             if (ambiguousElseClause) {\n                 cc.endBlock();\n             }\n             break;\n         case Token.NULL:\n         case Token.THIS:\n         case Token.FALSE:\n         case Token.TRUE:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(Node.tokenToName(type));\n             break;\n         case Token.CONTINUE:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"continue\");\n             if (childCount \u003d\u003d 1) {\n                 if (first.getType() !\u003d Token.LABEL_NAME) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.DEBUGGER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(\"debugger\");\n             cc.endStatement();\n             break;\n         case Token.BREAK:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"break\");\n             if (childCount \u003d\u003d 1) {\n                 if (first.getType() !\u003d Token.LABEL_NAME) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.EXPR_VOID:\n             throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n         case Token.EXPR_RESULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first, Context.START_OF_EXPR);\n             cc.endStatement();\n             break;\n         case Token.NEW:\n             add(\"new \");\n             int precedence \u003d NodeUtil.precedence(type);\n             if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction())) {\n                 precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n             }\n             addExpr(first, precedence);\n             Node next \u003d first.getNext();\n             if (next !\u003d null) {\n                 add(\"(\");\n                 addList(next);\n                 add(\")\");\n             }\n             break;\n         case Token.STRING:\n             if (childCount !\u003d ((n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.OBJECTLIT) ? 1 : 0)) {\n                 throw new IllegalStateException(\"Unexpected String children: \" + n.getParent().toStringTree());\n             }\n             add(jsString(n.getString(), outputCharsetEncoder));\n             break;\n         case Token.DELPROP:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"delete \");\n             add(first);\n             break;\n         case Token.OBJECTLIT:\n             {\n                 boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 add(\"{\");\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     if (c !\u003d first) {\n                         cc.listSeparator();\n                     }\n                     if (c.getType() \u003d\u003d Token.GET || c.getType() \u003d\u003d Token.SET) {\n                         add(c);\n                     } else {\n-                        if (c.getType() \u003d\u003d Token.STRING \u0026\u0026 !TokenStream.isKeyword(c.getString()) \u0026\u0026 TokenStream.isJSIdentifier(c.getString()) \u0026\u0026 NodeUtil.isLatin(c.getString())) {\n+                        if (c.getType() \u003d\u003d Token.STRING \u0026\u0026 !c.isQuotedString() \u0026\u0026 !TokenStream.isKeyword(c.getString()) \u0026\u0026 TokenStream.isJSIdentifier(c.getString()) \u0026\u0026 NodeUtil.isLatin(c.getString())) {\n                             add(c.getString());\n                         } else {\n                             addExpr(c, 1);\n                         }\n                         add(\":\");\n                         addExpr(c.getFirstChild(), 1);\n                     }\n                 }\n                 add(\"}\");\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 break;\n             }\n         case Token.SWITCH:\n             add(\"switch(\");\n             add(first);\n             add(\")\");\n             cc.beginBlock();\n             addAllSiblings(first.getNext());\n             cc.endBlock(context \u003d\u003d Context.STATEMENT);\n             break;\n         case Token.CASE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"case \");\n             add(first);\n             addCaseBody(last);\n             break;\n         case Token.DEFAULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"default\");\n             addCaseBody(first);\n             break;\n         case Token.LABEL:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             if (first.getType() !\u003d Token.LABEL_NAME) {\n                 throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n             }\n             add(first);\n             add(\":\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\n             break;\n         case Token.SETNAME:\n             break;\n         default:\n             throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n     }\n     cc.endSourceMapping(n);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7437e9b626c812301e3fe9449e4ee71506da9efb": {
      "type": "Ybodychange",
      "commitMessage": "\nFold NEG a bit at code-generation time, to match the parsing that\nRhino does at parse-time. Makes SanityCheck a bit happier.\n\nR\u003djohnlenz\nDELTA\u003d25  (23 added, 1 deleted, 1 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d159\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@645 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "12/16/10, 4:02 PM",
      "commitName": "7437e9b626c812301e3fe9449e4ee71506da9efb",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "12/7/10, 12:48 PM",
      "commitNameOld": "be0104009f06fafdb7428398d2c8299d13a1df12",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 9.13,
      "commitsBetweenForRepo": 39,
      "commitsBetweenForFile": 1,
      "actualSource": "void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n        return;\n    }\n    int type \u003d n.getType();\n    String opstr \u003d NodeUtil.opToStr(type);\n    int childCount \u003d n.getChildCount();\n    Node first \u003d n.getFirstChild();\n    Node last \u003d n.getLastChild();\n    if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n        Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n        int p \u003d NodeUtil.precedence(type);\n        addLeftExpr(first, p, context);\n        cc.addOp(opstr, true);\n        Context rhsContext \u003d getContextForNoInOperator(context);\n        if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n            addExpr(last, p, rhsContext);\n        } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n            addExpr(last, p, rhsContext);\n        } else {\n            addExpr(last, p + 1, rhsContext);\n        }\n        return;\n    }\n    cc.startSourceMapping(n);\n    switch(type) {\n        case Token.TRY:\n            {\n                Preconditions.checkState(first.getNext().getType() \u003d\u003d Token.BLOCK \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n                Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                add(\"try\");\n                add(first, Context.PRESERVE_BLOCK);\n                Node catchblock \u003d first.getNext().getFirstChild();\n                if (catchblock !\u003d null) {\n                    add(catchblock);\n                }\n                if (childCount \u003d\u003d 3) {\n                    add(\"finally\");\n                    add(last, Context.PRESERVE_BLOCK);\n                }\n                break;\n            }\n        case Token.CATCH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"catch(\");\n            add(first);\n            add(\")\");\n            add(last, Context.PRESERVE_BLOCK);\n            break;\n        case Token.THROW:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"throw\");\n            add(first);\n            cc.endStatement(true);\n            break;\n        case Token.RETURN:\n            add(\"return\");\n            if (childCount \u003d\u003d 1) {\n                add(first);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 0);\n            }\n            cc.endStatement();\n            break;\n        case Token.VAR:\n            if (first !\u003d null) {\n                add(\"var \");\n                addList(first, false, getContextForNoInOperator(context));\n            }\n            break;\n        case Token.LABEL_NAME:\n            Preconditions.checkState(!n.getString().isEmpty());\n            addIdentifier(n.getString());\n            break;\n        case Token.NAME:\n            if (first \u003d\u003d null || first.getType() \u003d\u003d Token.EMPTY) {\n                addIdentifier(n.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                addIdentifier(n.getString());\n                cc.addOp(\"\u003d\", true);\n                if (first.getType() \u003d\u003d Token.COMMA) {\n                    addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                } else {\n                    addExpr(first, 0, getContextForNoInOperator(context));\n                }\n            }\n            break;\n        case Token.ARRAYLIT:\n            add(\"[\");\n            addList(first, (int[]) n.getProp(Node.SKIP_INDEXES_PROP));\n            add(\"]\");\n            break;\n        case Token.LP:\n            add(\"(\");\n            addList(first);\n            add(\")\");\n            break;\n        case Token.COMMA:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            addList(first, false, context);\n            break;\n        case Token.NUMBER:\n            Preconditions.checkState(childCount \u003d\u003d ((n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.OBJECTLIT) ? 1 : 0));\n            cc.addNumber(n.getDouble());\n            break;\n        case Token.TYPEOF:\n        case Token.VOID:\n        case Token.NOT:\n        case Token.BITNOT:\n        case Token.POS:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                addExpr(first, NodeUtil.precedence(type));\n                break;\n            }\n        case Token.NEG:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                if (n.getFirstChild().getType() \u003d\u003d Token.NUMBER) {\n                    cc.addNumber(-n.getFirstChild().getDouble());\n                } else {\n                    cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                    addExpr(first, NodeUtil.precedence(type));\n                }\n                break;\n            }\n        case Token.HOOK:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                int p \u003d NodeUtil.precedence(type);\n                addLeftExpr(first, p + 1, context);\n                cc.addOp(\"?\", true);\n                addExpr(first.getNext(), 1);\n                cc.addOp(\":\", true);\n                addExpr(last, 1);\n                break;\n            }\n        case Token.REGEXP:\n            if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                throw new Error(\"Expected children to be strings\");\n            }\n            String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n            if (childCount \u003d\u003d 2) {\n                add(regexp + last.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                add(regexp);\n            }\n            break;\n        case Token.GET_REF:\n            add(first);\n            break;\n        case Token.REF_SPECIAL:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first);\n            add(\".\");\n            add((String) n.getProp(Node.NAME_PROP));\n            break;\n        case Token.FUNCTION:\n            if (n.getClass() !\u003d Node.class) {\n                throw new Error(\"Unexpected Node subclass.\");\n            }\n            Preconditions.checkState(childCount \u003d\u003d 3);\n            boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n            if (funcNeedsParens) {\n                add(\"(\");\n            }\n            add(\"function\");\n            add(first);\n            add(first.getNext());\n            add(last, Context.PRESERVE_BLOCK);\n            cc.endFunction(context \u003d\u003d Context.STATEMENT);\n            if (funcNeedsParens) {\n                add(\")\");\n            }\n            break;\n        case Token.GET:\n        case Token.SET:\n            Preconditions.checkState(n.getParent().getType() \u003d\u003d Token.OBJECTLIT);\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            Preconditions.checkState(first.getType() \u003d\u003d Token.FUNCTION);\n            Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n            if (type \u003d\u003d Token.GET) {\n                Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n                add(\"get \");\n            } else {\n                Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n                add(\"set \");\n            }\n            String name \u003d n.getString();\n            Node fn \u003d first;\n            Node parameters \u003d fn.getChildAtIndex(1);\n            Node body \u003d fn.getLastChild();\n            if (TokenStream.isJSIdentifier(name) \u0026\u0026 NodeUtil.isLatin(name)) {\n                add(name);\n            } else {\n                add(jsString(n.getString(), outputCharsetEncoder));\n            }\n            add(parameters);\n            add(body, Context.PRESERVE_BLOCK);\n            break;\n        case Token.SCRIPT:\n        case Token.BLOCK:\n            {\n                if (n.getClass() !\u003d Node.class) {\n                    throw new Error(\"Unexpected Node subclass.\");\n                }\n                boolean preserveBlock \u003d context \u003d\u003d Context.PRESERVE_BLOCK;\n                if (preserveBlock) {\n                    cc.beginBlock();\n                }\n                boolean preferLineBreaks \u003d type \u003d\u003d Token.SCRIPT || (type \u003d\u003d Token.BLOCK \u0026\u0026 !preserveBlock \u0026\u0026 n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.SCRIPT);\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    add(c, Context.STATEMENT);\n                    if (c.getType() \u003d\u003d Token.VAR) {\n                        cc.endStatement();\n                    }\n                    if (c.getType() \u003d\u003d Token.FUNCTION) {\n                        cc.maybeLineBreak();\n                    }\n                    if (preferLineBreaks) {\n                        cc.notePreferredLineBreak();\n                    }\n                }\n                if (preserveBlock) {\n                    cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                }\n                break;\n            }\n        case Token.FOR:\n            if (childCount \u003d\u003d 4) {\n                add(\"for(\");\n                if (first.getType() \u003d\u003d Token.VAR) {\n                    add(first, Context.IN_FOR_INIT_CLAUSE);\n                } else {\n                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                }\n                add(\";\");\n                add(first.getNext());\n                add(\";\");\n                add(first.getNext().getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                add(\"for(\");\n                add(first);\n                add(\"in\");\n                add(first.getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            }\n            break;\n        case Token.DO:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"do\");\n            addNonEmptyStatement(first, Context.OTHER, false);\n            add(\"while(\");\n            add(last);\n            add(\")\");\n            cc.endStatement();\n            break;\n        case Token.WHILE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"while(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.EMPTY:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            break;\n        case Token.GETPROP:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                Preconditions.checkState(last.getType() \u003d\u003d Token.STRING, \"Bad GETPROP: RHS should be STRING\");\n                boolean needsParens \u003d (first.getType() \u003d\u003d Token.NUMBER);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n                if (needsParens) {\n                    add(\")\");\n                }\n                add(\".\");\n                addIdentifier(last.getString());\n                break;\n            }\n        case Token.GETELEM:\n            Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n            addLeftExpr(first, NodeUtil.precedence(type), context);\n            add(\"[\");\n            add(first.getNext());\n            add(\"]\");\n            break;\n        case Token.WITH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"with(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.INC:\n        case Token.DEC:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                if (postProp !\u003d 0) {\n                    addLeftExpr(first, NodeUtil.precedence(type), context);\n                    cc.addOp(o, false);\n                } else {\n                    cc.addOp(o, false);\n                    add(first);\n                }\n                break;\n            }\n        case Token.CALL:\n            if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) \u0026\u0026 NodeUtil.isGet(first)) {\n                add(\"(0,\");\n                addExpr(first, NodeUtil.precedence(Token.COMMA));\n                add(\")\");\n            } else {\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n            }\n            add(\"(\");\n            addList(first.getNext());\n            add(\")\");\n            break;\n        case Token.IF:\n            boolean hasElse \u003d childCount \u003d\u003d 3;\n            boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n            if (ambiguousElseClause) {\n                cc.beginBlock();\n            }\n            add(\"if(\");\n            add(first);\n            add(\")\");\n            if (hasElse) {\n                addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                add(\"else\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n                Preconditions.checkState(childCount \u003d\u003d 2);\n            }\n            if (ambiguousElseClause) {\n                cc.endBlock();\n            }\n            break;\n        case Token.NULL:\n        case Token.THIS:\n        case Token.FALSE:\n        case Token.TRUE:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(Node.tokenToName(type));\n            break;\n        case Token.CONTINUE:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"continue\");\n            if (childCount \u003d\u003d 1) {\n                if (first.getType() !\u003d Token.LABEL_NAME) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.DEBUGGER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"debugger\");\n            cc.endStatement();\n            break;\n        case Token.BREAK:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"break\");\n            if (childCount \u003d\u003d 1) {\n                if (first.getType() !\u003d Token.LABEL_NAME) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.EXPR_VOID:\n            throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n        case Token.EXPR_RESULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first, Context.START_OF_EXPR);\n            cc.endStatement();\n            break;\n        case Token.NEW:\n            add(\"new \");\n            int precedence \u003d NodeUtil.precedence(type);\n            if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction())) {\n                precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n            }\n            addExpr(first, precedence);\n            Node next \u003d first.getNext();\n            if (next !\u003d null) {\n                add(\"(\");\n                addList(next);\n                add(\")\");\n            }\n            break;\n        case Token.STRING:\n            if (childCount !\u003d ((n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.OBJECTLIT) ? 1 : 0)) {\n                throw new IllegalStateException(\"Unexpected String children: \" + n.getParent().toStringTree());\n            }\n            add(jsString(n.getString(), outputCharsetEncoder));\n            break;\n        case Token.DELPROP:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"delete \");\n            add(first);\n            break;\n        case Token.OBJECTLIT:\n            {\n                boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                add(\"{\");\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    if (c !\u003d first) {\n                        cc.listSeparator();\n                    }\n                    if (c.getType() \u003d\u003d Token.GET || c.getType() \u003d\u003d Token.SET) {\n                        add(c);\n                    } else {\n                        if (c.getType() \u003d\u003d Token.STRING \u0026\u0026 !TokenStream.isKeyword(c.getString()) \u0026\u0026 TokenStream.isJSIdentifier(c.getString()) \u0026\u0026 NodeUtil.isLatin(c.getString())) {\n                            add(c.getString());\n                        } else {\n                            addExpr(c, 1);\n                        }\n                        add(\":\");\n                        addExpr(c.getFirstChild(), 1);\n                    }\n                }\n                add(\"}\");\n                if (needsParens) {\n                    add(\")\");\n                }\n                break;\n            }\n        case Token.SWITCH:\n            add(\"switch(\");\n            add(first);\n            add(\")\");\n            cc.beginBlock();\n            addAllSiblings(first.getNext());\n            cc.endBlock(context \u003d\u003d Context.STATEMENT);\n            break;\n        case Token.CASE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"case \");\n            add(first);\n            addCaseBody(last);\n            break;\n        case Token.DEFAULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"default\");\n            addCaseBody(first);\n            break;\n        case Token.LABEL:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            if (first.getType() !\u003d Token.LABEL_NAME) {\n                throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n            }\n            add(first);\n            add(\":\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\n            break;\n        case Token.SETNAME:\n            break;\n        default:\n            throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n    cc.endSourceMapping(n);\n}",
      "path": "src/com/google/javascript/jscomp/CodeGenerator.java",
      "functionStartLine": 75,
      "functionName": "add",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,474 +1,484 @@\n void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n         return;\n     }\n     int type \u003d n.getType();\n     String opstr \u003d NodeUtil.opToStr(type);\n     int childCount \u003d n.getChildCount();\n     Node first \u003d n.getFirstChild();\n     Node last \u003d n.getLastChild();\n     if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n         Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n         int p \u003d NodeUtil.precedence(type);\n         addLeftExpr(first, p, context);\n         cc.addOp(opstr, true);\n         Context rhsContext \u003d getContextForNoInOperator(context);\n         if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n             addExpr(last, p, rhsContext);\n         } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n             addExpr(last, p, rhsContext);\n         } else {\n             addExpr(last, p + 1, rhsContext);\n         }\n         return;\n     }\n     cc.startSourceMapping(n);\n     switch(type) {\n         case Token.TRY:\n             {\n                 Preconditions.checkState(first.getNext().getType() \u003d\u003d Token.BLOCK \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n                 Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                 add(\"try\");\n                 add(first, Context.PRESERVE_BLOCK);\n                 Node catchblock \u003d first.getNext().getFirstChild();\n                 if (catchblock !\u003d null) {\n                     add(catchblock);\n                 }\n                 if (childCount \u003d\u003d 3) {\n                     add(\"finally\");\n                     add(last, Context.PRESERVE_BLOCK);\n                 }\n                 break;\n             }\n         case Token.CATCH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"catch(\");\n             add(first);\n             add(\")\");\n             add(last, Context.PRESERVE_BLOCK);\n             break;\n         case Token.THROW:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"throw\");\n             add(first);\n             cc.endStatement(true);\n             break;\n         case Token.RETURN:\n             add(\"return\");\n             if (childCount \u003d\u003d 1) {\n                 add(first);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 0);\n             }\n             cc.endStatement();\n             break;\n         case Token.VAR:\n             if (first !\u003d null) {\n                 add(\"var \");\n                 addList(first, false, getContextForNoInOperator(context));\n             }\n             break;\n         case Token.LABEL_NAME:\n             Preconditions.checkState(!n.getString().isEmpty());\n             addIdentifier(n.getString());\n             break;\n         case Token.NAME:\n             if (first \u003d\u003d null || first.getType() \u003d\u003d Token.EMPTY) {\n                 addIdentifier(n.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 addIdentifier(n.getString());\n                 cc.addOp(\"\u003d\", true);\n                 if (first.getType() \u003d\u003d Token.COMMA) {\n                     addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                 } else {\n                     addExpr(first, 0, getContextForNoInOperator(context));\n                 }\n             }\n             break;\n         case Token.ARRAYLIT:\n             add(\"[\");\n             addList(first, (int[]) n.getProp(Node.SKIP_INDEXES_PROP));\n             add(\"]\");\n             break;\n         case Token.LP:\n             add(\"(\");\n             addList(first);\n             add(\")\");\n             break;\n         case Token.COMMA:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             addList(first, false, context);\n             break;\n         case Token.NUMBER:\n             Preconditions.checkState(childCount \u003d\u003d ((n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.OBJECTLIT) ? 1 : 0));\n             cc.addNumber(n.getDouble());\n             break;\n         case Token.TYPEOF:\n         case Token.VOID:\n         case Token.NOT:\n         case Token.BITNOT:\n         case Token.POS:\n-        case Token.NEG:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                 addExpr(first, NodeUtil.precedence(type));\n                 break;\n             }\n+        case Token.NEG:\n+            {\n+                Preconditions.checkState(childCount \u003d\u003d 1);\n+                if (n.getFirstChild().getType() \u003d\u003d Token.NUMBER) {\n+                    cc.addNumber(-n.getFirstChild().getDouble());\n+                } else {\n+                    cc.addOp(NodeUtil.opToStrNoFail(type), false);\n+                    addExpr(first, NodeUtil.precedence(type));\n+                }\n+                break;\n+            }\n         case Token.HOOK:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 int p \u003d NodeUtil.precedence(type);\n                 addLeftExpr(first, p + 1, context);\n                 cc.addOp(\"?\", true);\n                 addExpr(first.getNext(), 1);\n                 cc.addOp(\":\", true);\n                 addExpr(last, 1);\n                 break;\n             }\n         case Token.REGEXP:\n             if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                 throw new Error(\"Expected children to be strings\");\n             }\n             String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n             if (childCount \u003d\u003d 2) {\n                 add(regexp + last.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 add(regexp);\n             }\n             break;\n         case Token.GET_REF:\n             add(first);\n             break;\n         case Token.REF_SPECIAL:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first);\n             add(\".\");\n             add((String) n.getProp(Node.NAME_PROP));\n             break;\n         case Token.FUNCTION:\n             if (n.getClass() !\u003d Node.class) {\n                 throw new Error(\"Unexpected Node subclass.\");\n             }\n             Preconditions.checkState(childCount \u003d\u003d 3);\n             boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n             if (funcNeedsParens) {\n                 add(\"(\");\n             }\n             add(\"function\");\n             add(first);\n             add(first.getNext());\n             add(last, Context.PRESERVE_BLOCK);\n             cc.endFunction(context \u003d\u003d Context.STATEMENT);\n             if (funcNeedsParens) {\n                 add(\")\");\n             }\n             break;\n         case Token.GET:\n         case Token.SET:\n             Preconditions.checkState(n.getParent().getType() \u003d\u003d Token.OBJECTLIT);\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             Preconditions.checkState(first.getType() \u003d\u003d Token.FUNCTION);\n             Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n             if (type \u003d\u003d Token.GET) {\n                 Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n                 add(\"get \");\n             } else {\n                 Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n                 add(\"set \");\n             }\n             String name \u003d n.getString();\n             Node fn \u003d first;\n             Node parameters \u003d fn.getChildAtIndex(1);\n             Node body \u003d fn.getLastChild();\n             if (TokenStream.isJSIdentifier(name) \u0026\u0026 NodeUtil.isLatin(name)) {\n                 add(name);\n             } else {\n                 add(jsString(n.getString(), outputCharsetEncoder));\n             }\n             add(parameters);\n             add(body, Context.PRESERVE_BLOCK);\n             break;\n         case Token.SCRIPT:\n         case Token.BLOCK:\n             {\n                 if (n.getClass() !\u003d Node.class) {\n                     throw new Error(\"Unexpected Node subclass.\");\n                 }\n                 boolean preserveBlock \u003d context \u003d\u003d Context.PRESERVE_BLOCK;\n                 if (preserveBlock) {\n                     cc.beginBlock();\n                 }\n                 boolean preferLineBreaks \u003d type \u003d\u003d Token.SCRIPT || (type \u003d\u003d Token.BLOCK \u0026\u0026 !preserveBlock \u0026\u0026 n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.SCRIPT);\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     add(c, Context.STATEMENT);\n                     if (c.getType() \u003d\u003d Token.VAR) {\n                         cc.endStatement();\n                     }\n                     if (c.getType() \u003d\u003d Token.FUNCTION) {\n                         cc.maybeLineBreak();\n                     }\n                     if (preferLineBreaks) {\n                         cc.notePreferredLineBreak();\n                     }\n                 }\n                 if (preserveBlock) {\n                     cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                 }\n                 break;\n             }\n         case Token.FOR:\n             if (childCount \u003d\u003d 4) {\n                 add(\"for(\");\n                 if (first.getType() \u003d\u003d Token.VAR) {\n                     add(first, Context.IN_FOR_INIT_CLAUSE);\n                 } else {\n                     addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                 }\n                 add(\";\");\n                 add(first.getNext());\n                 add(\";\");\n                 add(first.getNext().getNext());\n                 add(\")\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 add(\"for(\");\n                 add(first);\n                 add(\"in\");\n                 add(first.getNext());\n                 add(\")\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             }\n             break;\n         case Token.DO:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"do\");\n             addNonEmptyStatement(first, Context.OTHER, false);\n             add(\"while(\");\n             add(last);\n             add(\")\");\n             cc.endStatement();\n             break;\n         case Token.WHILE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"while(\");\n             add(first);\n             add(\")\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.EMPTY:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             break;\n         case Token.GETPROP:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                 Preconditions.checkState(last.getType() \u003d\u003d Token.STRING, \"Bad GETPROP: RHS should be STRING\");\n                 boolean needsParens \u003d (first.getType() \u003d\u003d Token.NUMBER);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 add(\".\");\n                 addIdentifier(last.getString());\n                 break;\n             }\n         case Token.GETELEM:\n             Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n             addLeftExpr(first, NodeUtil.precedence(type), context);\n             add(\"[\");\n             add(first.getNext());\n             add(\"]\");\n             break;\n         case Token.WITH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"with(\");\n             add(first);\n             add(\")\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.INC:\n         case Token.DEC:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                 int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                 if (postProp !\u003d 0) {\n                     addLeftExpr(first, NodeUtil.precedence(type), context);\n                     cc.addOp(o, false);\n                 } else {\n                     cc.addOp(o, false);\n                     add(first);\n                 }\n                 break;\n             }\n         case Token.CALL:\n             if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) \u0026\u0026 NodeUtil.isGet(first)) {\n                 add(\"(0,\");\n                 addExpr(first, NodeUtil.precedence(Token.COMMA));\n                 add(\")\");\n             } else {\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n             }\n             add(\"(\");\n             addList(first.getNext());\n             add(\")\");\n             break;\n         case Token.IF:\n             boolean hasElse \u003d childCount \u003d\u003d 3;\n             boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n             if (ambiguousElseClause) {\n                 cc.beginBlock();\n             }\n             add(\"if(\");\n             add(first);\n             add(\")\");\n             if (hasElse) {\n                 addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                 add(\"else\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n                 Preconditions.checkState(childCount \u003d\u003d 2);\n             }\n             if (ambiguousElseClause) {\n                 cc.endBlock();\n             }\n             break;\n         case Token.NULL:\n         case Token.THIS:\n         case Token.FALSE:\n         case Token.TRUE:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(Node.tokenToName(type));\n             break;\n         case Token.CONTINUE:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"continue\");\n             if (childCount \u003d\u003d 1) {\n                 if (first.getType() !\u003d Token.LABEL_NAME) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.DEBUGGER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(\"debugger\");\n             cc.endStatement();\n             break;\n         case Token.BREAK:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"break\");\n             if (childCount \u003d\u003d 1) {\n                 if (first.getType() !\u003d Token.LABEL_NAME) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.EXPR_VOID:\n             throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n         case Token.EXPR_RESULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first, Context.START_OF_EXPR);\n             cc.endStatement();\n             break;\n         case Token.NEW:\n             add(\"new \");\n             int precedence \u003d NodeUtil.precedence(type);\n             if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction())) {\n                 precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n             }\n             addExpr(first, precedence);\n             Node next \u003d first.getNext();\n             if (next !\u003d null) {\n                 add(\"(\");\n                 addList(next);\n                 add(\")\");\n             }\n             break;\n         case Token.STRING:\n             if (childCount !\u003d ((n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.OBJECTLIT) ? 1 : 0)) {\n                 throw new IllegalStateException(\"Unexpected String children: \" + n.getParent().toStringTree());\n             }\n             add(jsString(n.getString(), outputCharsetEncoder));\n             break;\n         case Token.DELPROP:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"delete \");\n             add(first);\n             break;\n         case Token.OBJECTLIT:\n             {\n                 boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 add(\"{\");\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     if (c !\u003d first) {\n                         cc.listSeparator();\n                     }\n                     if (c.getType() \u003d\u003d Token.GET || c.getType() \u003d\u003d Token.SET) {\n                         add(c);\n                     } else {\n                         if (c.getType() \u003d\u003d Token.STRING \u0026\u0026 !TokenStream.isKeyword(c.getString()) \u0026\u0026 TokenStream.isJSIdentifier(c.getString()) \u0026\u0026 NodeUtil.isLatin(c.getString())) {\n                             add(c.getString());\n                         } else {\n                             addExpr(c, 1);\n                         }\n                         add(\":\");\n                         addExpr(c.getFirstChild(), 1);\n                     }\n                 }\n                 add(\"}\");\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 break;\n             }\n         case Token.SWITCH:\n             add(\"switch(\");\n             add(first);\n             add(\")\");\n             cc.beginBlock();\n             addAllSiblings(first.getNext());\n             cc.endBlock(context \u003d\u003d Context.STATEMENT);\n             break;\n         case Token.CASE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"case \");\n             add(first);\n             addCaseBody(last);\n             break;\n         case Token.DEFAULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"default\");\n             addCaseBody(first);\n             break;\n         case Token.LABEL:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             if (first.getType() !\u003d Token.LABEL_NAME) {\n                 throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n             }\n             add(first);\n             add(\":\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\n             break;\n         case Token.SETNAME:\n             break;\n         default:\n             throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n     }\n     cc.endSourceMapping(n);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "be0104009f06fafdb7428398d2c8299d13a1df12": {
      "type": "Ybodychange",
      "commitMessage": "\nAutomated g4 rollback.\n\n*** Reason for rollback ***\n\nFixed a stack size issue.\n\n*** Original change description ***\n\nAutomated g4 rollback.\n\n*** Reason for rollback ***\n\nTo investigate why this breaks builds.\n\n*** Original change description ***\n\nAdd whitespace only mode support for ES5 getters and setters.\n\nR\u003dacleung\nDELTA\u003d318  (263 added, 31 deleted, 24 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d87\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@605 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "12/7/10, 12:48 PM",
      "commitName": "be0104009f06fafdb7428398d2c8299d13a1df12",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "12/6/10, 1:39 PM",
      "commitNameOld": "28982c32f367108886311969e01d69156230fd35",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 0.96,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n        return;\n    }\n    int type \u003d n.getType();\n    String opstr \u003d NodeUtil.opToStr(type);\n    int childCount \u003d n.getChildCount();\n    Node first \u003d n.getFirstChild();\n    Node last \u003d n.getLastChild();\n    if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n        Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n        int p \u003d NodeUtil.precedence(type);\n        addLeftExpr(first, p, context);\n        cc.addOp(opstr, true);\n        Context rhsContext \u003d getContextForNoInOperator(context);\n        if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n            addExpr(last, p, rhsContext);\n        } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n            addExpr(last, p, rhsContext);\n        } else {\n            addExpr(last, p + 1, rhsContext);\n        }\n        return;\n    }\n    cc.startSourceMapping(n);\n    switch(type) {\n        case Token.TRY:\n            {\n                Preconditions.checkState(first.getNext().getType() \u003d\u003d Token.BLOCK \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n                Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                add(\"try\");\n                add(first, Context.PRESERVE_BLOCK);\n                Node catchblock \u003d first.getNext().getFirstChild();\n                if (catchblock !\u003d null) {\n                    add(catchblock);\n                }\n                if (childCount \u003d\u003d 3) {\n                    add(\"finally\");\n                    add(last, Context.PRESERVE_BLOCK);\n                }\n                break;\n            }\n        case Token.CATCH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"catch(\");\n            add(first);\n            add(\")\");\n            add(last, Context.PRESERVE_BLOCK);\n            break;\n        case Token.THROW:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"throw\");\n            add(first);\n            cc.endStatement(true);\n            break;\n        case Token.RETURN:\n            add(\"return\");\n            if (childCount \u003d\u003d 1) {\n                add(first);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 0);\n            }\n            cc.endStatement();\n            break;\n        case Token.VAR:\n            if (first !\u003d null) {\n                add(\"var \");\n                addList(first, false, getContextForNoInOperator(context));\n            }\n            break;\n        case Token.LABEL_NAME:\n            Preconditions.checkState(!n.getString().isEmpty());\n            addIdentifier(n.getString());\n            break;\n        case Token.NAME:\n            if (first \u003d\u003d null || first.getType() \u003d\u003d Token.EMPTY) {\n                addIdentifier(n.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                addIdentifier(n.getString());\n                cc.addOp(\"\u003d\", true);\n                if (first.getType() \u003d\u003d Token.COMMA) {\n                    addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                } else {\n                    addExpr(first, 0, getContextForNoInOperator(context));\n                }\n            }\n            break;\n        case Token.ARRAYLIT:\n            add(\"[\");\n            addList(first, (int[]) n.getProp(Node.SKIP_INDEXES_PROP));\n            add(\"]\");\n            break;\n        case Token.LP:\n            add(\"(\");\n            addList(first);\n            add(\")\");\n            break;\n        case Token.COMMA:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            addList(first, false, context);\n            break;\n        case Token.NUMBER:\n            Preconditions.checkState(childCount \u003d\u003d ((n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.OBJECTLIT) ? 1 : 0));\n            cc.addNumber(n.getDouble());\n            break;\n        case Token.TYPEOF:\n        case Token.VOID:\n        case Token.NOT:\n        case Token.BITNOT:\n        case Token.POS:\n        case Token.NEG:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                addExpr(first, NodeUtil.precedence(type));\n                break;\n            }\n        case Token.HOOK:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                int p \u003d NodeUtil.precedence(type);\n                addLeftExpr(first, p + 1, context);\n                cc.addOp(\"?\", true);\n                addExpr(first.getNext(), 1);\n                cc.addOp(\":\", true);\n                addExpr(last, 1);\n                break;\n            }\n        case Token.REGEXP:\n            if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                throw new Error(\"Expected children to be strings\");\n            }\n            String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n            if (childCount \u003d\u003d 2) {\n                add(regexp + last.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                add(regexp);\n            }\n            break;\n        case Token.GET_REF:\n            add(first);\n            break;\n        case Token.REF_SPECIAL:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first);\n            add(\".\");\n            add((String) n.getProp(Node.NAME_PROP));\n            break;\n        case Token.FUNCTION:\n            if (n.getClass() !\u003d Node.class) {\n                throw new Error(\"Unexpected Node subclass.\");\n            }\n            Preconditions.checkState(childCount \u003d\u003d 3);\n            boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n            if (funcNeedsParens) {\n                add(\"(\");\n            }\n            add(\"function\");\n            add(first);\n            add(first.getNext());\n            add(last, Context.PRESERVE_BLOCK);\n            cc.endFunction(context \u003d\u003d Context.STATEMENT);\n            if (funcNeedsParens) {\n                add(\")\");\n            }\n            break;\n        case Token.GET:\n        case Token.SET:\n            Preconditions.checkState(n.getParent().getType() \u003d\u003d Token.OBJECTLIT);\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            Preconditions.checkState(first.getType() \u003d\u003d Token.FUNCTION);\n            Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n            if (type \u003d\u003d Token.GET) {\n                Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n                add(\"get \");\n            } else {\n                Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n                add(\"set \");\n            }\n            String name \u003d n.getString();\n            Node fn \u003d first;\n            Node parameters \u003d fn.getChildAtIndex(1);\n            Node body \u003d fn.getLastChild();\n            if (TokenStream.isJSIdentifier(name) \u0026\u0026 NodeUtil.isLatin(name)) {\n                add(name);\n            } else {\n                add(jsString(n.getString(), outputCharsetEncoder));\n            }\n            add(parameters);\n            add(body, Context.PRESERVE_BLOCK);\n            break;\n        case Token.SCRIPT:\n        case Token.BLOCK:\n            {\n                if (n.getClass() !\u003d Node.class) {\n                    throw new Error(\"Unexpected Node subclass.\");\n                }\n                boolean preserveBlock \u003d context \u003d\u003d Context.PRESERVE_BLOCK;\n                if (preserveBlock) {\n                    cc.beginBlock();\n                }\n                boolean preferLineBreaks \u003d type \u003d\u003d Token.SCRIPT || (type \u003d\u003d Token.BLOCK \u0026\u0026 !preserveBlock \u0026\u0026 n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.SCRIPT);\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    add(c, Context.STATEMENT);\n                    if (c.getType() \u003d\u003d Token.VAR) {\n                        cc.endStatement();\n                    }\n                    if (c.getType() \u003d\u003d Token.FUNCTION) {\n                        cc.maybeLineBreak();\n                    }\n                    if (preferLineBreaks) {\n                        cc.notePreferredLineBreak();\n                    }\n                }\n                if (preserveBlock) {\n                    cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                }\n                break;\n            }\n        case Token.FOR:\n            if (childCount \u003d\u003d 4) {\n                add(\"for(\");\n                if (first.getType() \u003d\u003d Token.VAR) {\n                    add(first, Context.IN_FOR_INIT_CLAUSE);\n                } else {\n                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                }\n                add(\";\");\n                add(first.getNext());\n                add(\";\");\n                add(first.getNext().getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                add(\"for(\");\n                add(first);\n                add(\"in\");\n                add(first.getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            }\n            break;\n        case Token.DO:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"do\");\n            addNonEmptyStatement(first, Context.OTHER, false);\n            add(\"while(\");\n            add(last);\n            add(\")\");\n            cc.endStatement();\n            break;\n        case Token.WHILE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"while(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.EMPTY:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            break;\n        case Token.GETPROP:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                Preconditions.checkState(last.getType() \u003d\u003d Token.STRING, \"Bad GETPROP: RHS should be STRING\");\n                boolean needsParens \u003d (first.getType() \u003d\u003d Token.NUMBER);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n                if (needsParens) {\n                    add(\")\");\n                }\n                add(\".\");\n                addIdentifier(last.getString());\n                break;\n            }\n        case Token.GETELEM:\n            Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n            addLeftExpr(first, NodeUtil.precedence(type), context);\n            add(\"[\");\n            add(first.getNext());\n            add(\"]\");\n            break;\n        case Token.WITH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"with(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.INC:\n        case Token.DEC:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                if (postProp !\u003d 0) {\n                    addLeftExpr(first, NodeUtil.precedence(type), context);\n                    cc.addOp(o, false);\n                } else {\n                    cc.addOp(o, false);\n                    add(first);\n                }\n                break;\n            }\n        case Token.CALL:\n            if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) \u0026\u0026 NodeUtil.isGet(first)) {\n                add(\"(0,\");\n                addExpr(first, NodeUtil.precedence(Token.COMMA));\n                add(\")\");\n            } else {\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n            }\n            add(\"(\");\n            addList(first.getNext());\n            add(\")\");\n            break;\n        case Token.IF:\n            boolean hasElse \u003d childCount \u003d\u003d 3;\n            boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n            if (ambiguousElseClause) {\n                cc.beginBlock();\n            }\n            add(\"if(\");\n            add(first);\n            add(\")\");\n            if (hasElse) {\n                addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                add(\"else\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n                Preconditions.checkState(childCount \u003d\u003d 2);\n            }\n            if (ambiguousElseClause) {\n                cc.endBlock();\n            }\n            break;\n        case Token.NULL:\n        case Token.THIS:\n        case Token.FALSE:\n        case Token.TRUE:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(Node.tokenToName(type));\n            break;\n        case Token.CONTINUE:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"continue\");\n            if (childCount \u003d\u003d 1) {\n                if (first.getType() !\u003d Token.LABEL_NAME) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.DEBUGGER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"debugger\");\n            cc.endStatement();\n            break;\n        case Token.BREAK:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"break\");\n            if (childCount \u003d\u003d 1) {\n                if (first.getType() !\u003d Token.LABEL_NAME) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.EXPR_VOID:\n            throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n        case Token.EXPR_RESULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first, Context.START_OF_EXPR);\n            cc.endStatement();\n            break;\n        case Token.NEW:\n            add(\"new \");\n            int precedence \u003d NodeUtil.precedence(type);\n            if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction())) {\n                precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n            }\n            addExpr(first, precedence);\n            Node next \u003d first.getNext();\n            if (next !\u003d null) {\n                add(\"(\");\n                addList(next);\n                add(\")\");\n            }\n            break;\n        case Token.STRING:\n            if (childCount !\u003d ((n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.OBJECTLIT) ? 1 : 0)) {\n                throw new IllegalStateException(\"Unexpected String children: \" + n.getParent().toStringTree());\n            }\n            add(jsString(n.getString(), outputCharsetEncoder));\n            break;\n        case Token.DELPROP:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"delete \");\n            add(first);\n            break;\n        case Token.OBJECTLIT:\n            {\n                boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                add(\"{\");\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    if (c !\u003d first) {\n                        cc.listSeparator();\n                    }\n                    if (c.getType() \u003d\u003d Token.GET || c.getType() \u003d\u003d Token.SET) {\n                        add(c);\n                    } else {\n                        if (c.getType() \u003d\u003d Token.STRING \u0026\u0026 !TokenStream.isKeyword(c.getString()) \u0026\u0026 TokenStream.isJSIdentifier(c.getString()) \u0026\u0026 NodeUtil.isLatin(c.getString())) {\n                            add(c.getString());\n                        } else {\n                            addExpr(c, 1);\n                        }\n                        add(\":\");\n                        addExpr(c.getFirstChild(), 1);\n                    }\n                }\n                add(\"}\");\n                if (needsParens) {\n                    add(\")\");\n                }\n                break;\n            }\n        case Token.SWITCH:\n            add(\"switch(\");\n            add(first);\n            add(\")\");\n            cc.beginBlock();\n            addAllSiblings(first.getNext());\n            cc.endBlock(context \u003d\u003d Context.STATEMENT);\n            break;\n        case Token.CASE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"case \");\n            add(first);\n            addCaseBody(last);\n            break;\n        case Token.DEFAULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"default\");\n            addCaseBody(first);\n            break;\n        case Token.LABEL:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            if (first.getType() !\u003d Token.LABEL_NAME) {\n                throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n            }\n            add(first);\n            add(\":\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\n            break;\n        case Token.SETNAME:\n            break;\n        default:\n            throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n    cc.endSourceMapping(n);\n}",
      "path": "src/com/google/javascript/jscomp/CodeGenerator.java",
      "functionStartLine": 75,
      "functionName": "add",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,445 +1,474 @@\n void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n         return;\n     }\n     int type \u003d n.getType();\n     String opstr \u003d NodeUtil.opToStr(type);\n     int childCount \u003d n.getChildCount();\n     Node first \u003d n.getFirstChild();\n     Node last \u003d n.getLastChild();\n     if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n         Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n         int p \u003d NodeUtil.precedence(type);\n         addLeftExpr(first, p, context);\n         cc.addOp(opstr, true);\n         Context rhsContext \u003d getContextForNoInOperator(context);\n         if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n             addExpr(last, p, rhsContext);\n         } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n             addExpr(last, p, rhsContext);\n         } else {\n             addExpr(last, p + 1, rhsContext);\n         }\n         return;\n     }\n     cc.startSourceMapping(n);\n     switch(type) {\n         case Token.TRY:\n             {\n                 Preconditions.checkState(first.getNext().getType() \u003d\u003d Token.BLOCK \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n                 Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                 add(\"try\");\n                 add(first, Context.PRESERVE_BLOCK);\n                 Node catchblock \u003d first.getNext().getFirstChild();\n                 if (catchblock !\u003d null) {\n                     add(catchblock);\n                 }\n                 if (childCount \u003d\u003d 3) {\n                     add(\"finally\");\n                     add(last, Context.PRESERVE_BLOCK);\n                 }\n                 break;\n             }\n         case Token.CATCH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"catch(\");\n             add(first);\n             add(\")\");\n             add(last, Context.PRESERVE_BLOCK);\n             break;\n         case Token.THROW:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"throw\");\n             add(first);\n             cc.endStatement(true);\n             break;\n         case Token.RETURN:\n             add(\"return\");\n             if (childCount \u003d\u003d 1) {\n                 add(first);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 0);\n             }\n             cc.endStatement();\n             break;\n         case Token.VAR:\n             if (first !\u003d null) {\n                 add(\"var \");\n                 addList(first, false, getContextForNoInOperator(context));\n             }\n             break;\n         case Token.LABEL_NAME:\n             Preconditions.checkState(!n.getString().isEmpty());\n             addIdentifier(n.getString());\n             break;\n         case Token.NAME:\n             if (first \u003d\u003d null || first.getType() \u003d\u003d Token.EMPTY) {\n                 addIdentifier(n.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 addIdentifier(n.getString());\n                 cc.addOp(\"\u003d\", true);\n                 if (first.getType() \u003d\u003d Token.COMMA) {\n                     addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                 } else {\n                     addExpr(first, 0, getContextForNoInOperator(context));\n                 }\n             }\n             break;\n         case Token.ARRAYLIT:\n             add(\"[\");\n             addList(first, (int[]) n.getProp(Node.SKIP_INDEXES_PROP));\n             add(\"]\");\n             break;\n         case Token.LP:\n             add(\"(\");\n             addList(first);\n             add(\")\");\n             break;\n         case Token.COMMA:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             addList(first, false, context);\n             break;\n         case Token.NUMBER:\n             Preconditions.checkState(childCount \u003d\u003d ((n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.OBJECTLIT) ? 1 : 0));\n             cc.addNumber(n.getDouble());\n             break;\n         case Token.TYPEOF:\n         case Token.VOID:\n         case Token.NOT:\n         case Token.BITNOT:\n         case Token.POS:\n         case Token.NEG:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                 addExpr(first, NodeUtil.precedence(type));\n                 break;\n             }\n         case Token.HOOK:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 int p \u003d NodeUtil.precedence(type);\n                 addLeftExpr(first, p + 1, context);\n                 cc.addOp(\"?\", true);\n                 addExpr(first.getNext(), 1);\n                 cc.addOp(\":\", true);\n                 addExpr(last, 1);\n                 break;\n             }\n         case Token.REGEXP:\n             if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                 throw new Error(\"Expected children to be strings\");\n             }\n             String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n             if (childCount \u003d\u003d 2) {\n                 add(regexp + last.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 add(regexp);\n             }\n             break;\n         case Token.GET_REF:\n             add(first);\n             break;\n         case Token.REF_SPECIAL:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first);\n             add(\".\");\n             add((String) n.getProp(Node.NAME_PROP));\n             break;\n         case Token.FUNCTION:\n             if (n.getClass() !\u003d Node.class) {\n                 throw new Error(\"Unexpected Node subclass.\");\n             }\n             Preconditions.checkState(childCount \u003d\u003d 3);\n             boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n             if (funcNeedsParens) {\n                 add(\"(\");\n             }\n             add(\"function\");\n             add(first);\n             add(first.getNext());\n             add(last, Context.PRESERVE_BLOCK);\n             cc.endFunction(context \u003d\u003d Context.STATEMENT);\n             if (funcNeedsParens) {\n                 add(\")\");\n             }\n             break;\n+        case Token.GET:\n+        case Token.SET:\n+            Preconditions.checkState(n.getParent().getType() \u003d\u003d Token.OBJECTLIT);\n+            Preconditions.checkState(childCount \u003d\u003d 1);\n+            Preconditions.checkState(first.getType() \u003d\u003d Token.FUNCTION);\n+            Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n+            if (type \u003d\u003d Token.GET) {\n+                Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n+                add(\"get \");\n+            } else {\n+                Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n+                add(\"set \");\n+            }\n+            String name \u003d n.getString();\n+            Node fn \u003d first;\n+            Node parameters \u003d fn.getChildAtIndex(1);\n+            Node body \u003d fn.getLastChild();\n+            if (TokenStream.isJSIdentifier(name) \u0026\u0026 NodeUtil.isLatin(name)) {\n+                add(name);\n+            } else {\n+                add(jsString(n.getString(), outputCharsetEncoder));\n+            }\n+            add(parameters);\n+            add(body, Context.PRESERVE_BLOCK);\n+            break;\n         case Token.SCRIPT:\n         case Token.BLOCK:\n             {\n                 if (n.getClass() !\u003d Node.class) {\n                     throw new Error(\"Unexpected Node subclass.\");\n                 }\n                 boolean preserveBlock \u003d context \u003d\u003d Context.PRESERVE_BLOCK;\n                 if (preserveBlock) {\n                     cc.beginBlock();\n                 }\n                 boolean preferLineBreaks \u003d type \u003d\u003d Token.SCRIPT || (type \u003d\u003d Token.BLOCK \u0026\u0026 !preserveBlock \u0026\u0026 n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.SCRIPT);\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     add(c, Context.STATEMENT);\n                     if (c.getType() \u003d\u003d Token.VAR) {\n                         cc.endStatement();\n                     }\n                     if (c.getType() \u003d\u003d Token.FUNCTION) {\n                         cc.maybeLineBreak();\n                     }\n                     if (preferLineBreaks) {\n                         cc.notePreferredLineBreak();\n                     }\n                 }\n                 if (preserveBlock) {\n                     cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                 }\n                 break;\n             }\n         case Token.FOR:\n             if (childCount \u003d\u003d 4) {\n                 add(\"for(\");\n                 if (first.getType() \u003d\u003d Token.VAR) {\n                     add(first, Context.IN_FOR_INIT_CLAUSE);\n                 } else {\n                     addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                 }\n                 add(\";\");\n                 add(first.getNext());\n                 add(\";\");\n                 add(first.getNext().getNext());\n                 add(\")\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 add(\"for(\");\n                 add(first);\n                 add(\"in\");\n                 add(first.getNext());\n                 add(\")\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             }\n             break;\n         case Token.DO:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"do\");\n             addNonEmptyStatement(first, Context.OTHER, false);\n             add(\"while(\");\n             add(last);\n             add(\")\");\n             cc.endStatement();\n             break;\n         case Token.WHILE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"while(\");\n             add(first);\n             add(\")\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.EMPTY:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             break;\n         case Token.GETPROP:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                 Preconditions.checkState(last.getType() \u003d\u003d Token.STRING, \"Bad GETPROP: RHS should be STRING\");\n                 boolean needsParens \u003d (first.getType() \u003d\u003d Token.NUMBER);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 add(\".\");\n                 addIdentifier(last.getString());\n                 break;\n             }\n         case Token.GETELEM:\n             Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n             addLeftExpr(first, NodeUtil.precedence(type), context);\n             add(\"[\");\n             add(first.getNext());\n             add(\"]\");\n             break;\n         case Token.WITH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"with(\");\n             add(first);\n             add(\")\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.INC:\n         case Token.DEC:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                 int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                 if (postProp !\u003d 0) {\n                     addLeftExpr(first, NodeUtil.precedence(type), context);\n                     cc.addOp(o, false);\n                 } else {\n                     cc.addOp(o, false);\n                     add(first);\n                 }\n                 break;\n             }\n         case Token.CALL:\n             if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) \u0026\u0026 NodeUtil.isGet(first)) {\n                 add(\"(0,\");\n                 addExpr(first, NodeUtil.precedence(Token.COMMA));\n                 add(\")\");\n             } else {\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n             }\n             add(\"(\");\n             addList(first.getNext());\n             add(\")\");\n             break;\n         case Token.IF:\n             boolean hasElse \u003d childCount \u003d\u003d 3;\n             boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n             if (ambiguousElseClause) {\n                 cc.beginBlock();\n             }\n             add(\"if(\");\n             add(first);\n             add(\")\");\n             if (hasElse) {\n                 addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                 add(\"else\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n                 Preconditions.checkState(childCount \u003d\u003d 2);\n             }\n             if (ambiguousElseClause) {\n                 cc.endBlock();\n             }\n             break;\n         case Token.NULL:\n         case Token.THIS:\n         case Token.FALSE:\n         case Token.TRUE:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(Node.tokenToName(type));\n             break;\n         case Token.CONTINUE:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"continue\");\n             if (childCount \u003d\u003d 1) {\n                 if (first.getType() !\u003d Token.LABEL_NAME) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.DEBUGGER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(\"debugger\");\n             cc.endStatement();\n             break;\n         case Token.BREAK:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"break\");\n             if (childCount \u003d\u003d 1) {\n                 if (first.getType() !\u003d Token.LABEL_NAME) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.EXPR_VOID:\n             throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n         case Token.EXPR_RESULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first, Context.START_OF_EXPR);\n             cc.endStatement();\n             break;\n         case Token.NEW:\n             add(\"new \");\n             int precedence \u003d NodeUtil.precedence(type);\n             if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction())) {\n                 precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n             }\n             addExpr(first, precedence);\n             Node next \u003d first.getNext();\n             if (next !\u003d null) {\n                 add(\"(\");\n                 addList(next);\n                 add(\")\");\n             }\n             break;\n         case Token.STRING:\n             if (childCount !\u003d ((n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.OBJECTLIT) ? 1 : 0)) {\n                 throw new IllegalStateException(\"Unexpected String children: \" + n.getParent().toStringTree());\n             }\n             add(jsString(n.getString(), outputCharsetEncoder));\n             break;\n         case Token.DELPROP:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"delete \");\n             add(first);\n             break;\n         case Token.OBJECTLIT:\n             {\n                 boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 add(\"{\");\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     if (c !\u003d first) {\n                         cc.listSeparator();\n                     }\n-                    if (c.getType() \u003d\u003d Token.STRING \u0026\u0026 !TokenStream.isKeyword(c.getString()) \u0026\u0026 TokenStream.isJSIdentifier(c.getString()) \u0026\u0026 NodeUtil.isLatin(c.getString())) {\n-                        add(c.getString());\n+                    if (c.getType() \u003d\u003d Token.GET || c.getType() \u003d\u003d Token.SET) {\n+                        add(c);\n                     } else {\n-                        addExpr(c, 1);\n+                        if (c.getType() \u003d\u003d Token.STRING \u0026\u0026 !TokenStream.isKeyword(c.getString()) \u0026\u0026 TokenStream.isJSIdentifier(c.getString()) \u0026\u0026 NodeUtil.isLatin(c.getString())) {\n+                            add(c.getString());\n+                        } else {\n+                            addExpr(c, 1);\n+                        }\n+                        add(\":\");\n+                        addExpr(c.getFirstChild(), 1);\n                     }\n-                    add(\":\");\n-                    addExpr(c.getFirstChild(), 1);\n                 }\n                 add(\"}\");\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 break;\n             }\n         case Token.SWITCH:\n             add(\"switch(\");\n             add(first);\n             add(\")\");\n             cc.beginBlock();\n             addAllSiblings(first.getNext());\n             cc.endBlock(context \u003d\u003d Context.STATEMENT);\n             break;\n         case Token.CASE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"case \");\n             add(first);\n             addCaseBody(last);\n             break;\n         case Token.DEFAULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"default\");\n             addCaseBody(first);\n             break;\n         case Token.LABEL:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             if (first.getType() !\u003d Token.LABEL_NAME) {\n                 throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n             }\n             add(first);\n             add(\":\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\n             break;\n         case Token.SETNAME:\n             break;\n         default:\n             throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n     }\n     cc.endSourceMapping(n);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "28982c32f367108886311969e01d69156230fd35": {
      "type": "Ybodychange",
      "commitMessage": "\nAutomated g4 rollback.\n\n*** Reason for rollback ***\n\nTo investigate why this breaks builds.\n\n*** Original change description ***\n\nAdd whitespace only mode support for ES5 getters and setters.\n\nR\u003dacleung\nDELTA\u003d302  (19 added, 251 deleted, 32 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d70\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@599 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "12/6/10, 1:39 PM",
      "commitName": "28982c32f367108886311969e01d69156230fd35",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "12/6/10, 12:03 PM",
      "commitNameOld": "1c92a5447451e3d6e663d4bf508237a6eaeccf90",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 0.07,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n        return;\n    }\n    int type \u003d n.getType();\n    String opstr \u003d NodeUtil.opToStr(type);\n    int childCount \u003d n.getChildCount();\n    Node first \u003d n.getFirstChild();\n    Node last \u003d n.getLastChild();\n    if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n        Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n        int p \u003d NodeUtil.precedence(type);\n        addLeftExpr(first, p, context);\n        cc.addOp(opstr, true);\n        Context rhsContext \u003d getContextForNoInOperator(context);\n        if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n            addExpr(last, p, rhsContext);\n        } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n            addExpr(last, p, rhsContext);\n        } else {\n            addExpr(last, p + 1, rhsContext);\n        }\n        return;\n    }\n    cc.startSourceMapping(n);\n    switch(type) {\n        case Token.TRY:\n            {\n                Preconditions.checkState(first.getNext().getType() \u003d\u003d Token.BLOCK \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n                Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                add(\"try\");\n                add(first, Context.PRESERVE_BLOCK);\n                Node catchblock \u003d first.getNext().getFirstChild();\n                if (catchblock !\u003d null) {\n                    add(catchblock);\n                }\n                if (childCount \u003d\u003d 3) {\n                    add(\"finally\");\n                    add(last, Context.PRESERVE_BLOCK);\n                }\n                break;\n            }\n        case Token.CATCH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"catch(\");\n            add(first);\n            add(\")\");\n            add(last, Context.PRESERVE_BLOCK);\n            break;\n        case Token.THROW:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"throw\");\n            add(first);\n            cc.endStatement(true);\n            break;\n        case Token.RETURN:\n            add(\"return\");\n            if (childCount \u003d\u003d 1) {\n                add(first);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 0);\n            }\n            cc.endStatement();\n            break;\n        case Token.VAR:\n            if (first !\u003d null) {\n                add(\"var \");\n                addList(first, false, getContextForNoInOperator(context));\n            }\n            break;\n        case Token.LABEL_NAME:\n            Preconditions.checkState(!n.getString().isEmpty());\n            addIdentifier(n.getString());\n            break;\n        case Token.NAME:\n            if (first \u003d\u003d null || first.getType() \u003d\u003d Token.EMPTY) {\n                addIdentifier(n.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                addIdentifier(n.getString());\n                cc.addOp(\"\u003d\", true);\n                if (first.getType() \u003d\u003d Token.COMMA) {\n                    addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                } else {\n                    addExpr(first, 0, getContextForNoInOperator(context));\n                }\n            }\n            break;\n        case Token.ARRAYLIT:\n            add(\"[\");\n            addList(first, (int[]) n.getProp(Node.SKIP_INDEXES_PROP));\n            add(\"]\");\n            break;\n        case Token.LP:\n            add(\"(\");\n            addList(first);\n            add(\")\");\n            break;\n        case Token.COMMA:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            addList(first, false, context);\n            break;\n        case Token.NUMBER:\n            Preconditions.checkState(childCount \u003d\u003d ((n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.OBJECTLIT) ? 1 : 0));\n            cc.addNumber(n.getDouble());\n            break;\n        case Token.TYPEOF:\n        case Token.VOID:\n        case Token.NOT:\n        case Token.BITNOT:\n        case Token.POS:\n        case Token.NEG:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                addExpr(first, NodeUtil.precedence(type));\n                break;\n            }\n        case Token.HOOK:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                int p \u003d NodeUtil.precedence(type);\n                addLeftExpr(first, p + 1, context);\n                cc.addOp(\"?\", true);\n                addExpr(first.getNext(), 1);\n                cc.addOp(\":\", true);\n                addExpr(last, 1);\n                break;\n            }\n        case Token.REGEXP:\n            if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                throw new Error(\"Expected children to be strings\");\n            }\n            String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n            if (childCount \u003d\u003d 2) {\n                add(regexp + last.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                add(regexp);\n            }\n            break;\n        case Token.GET_REF:\n            add(first);\n            break;\n        case Token.REF_SPECIAL:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first);\n            add(\".\");\n            add((String) n.getProp(Node.NAME_PROP));\n            break;\n        case Token.FUNCTION:\n            if (n.getClass() !\u003d Node.class) {\n                throw new Error(\"Unexpected Node subclass.\");\n            }\n            Preconditions.checkState(childCount \u003d\u003d 3);\n            boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n            if (funcNeedsParens) {\n                add(\"(\");\n            }\n            add(\"function\");\n            add(first);\n            add(first.getNext());\n            add(last, Context.PRESERVE_BLOCK);\n            cc.endFunction(context \u003d\u003d Context.STATEMENT);\n            if (funcNeedsParens) {\n                add(\")\");\n            }\n            break;\n        case Token.SCRIPT:\n        case Token.BLOCK:\n            {\n                if (n.getClass() !\u003d Node.class) {\n                    throw new Error(\"Unexpected Node subclass.\");\n                }\n                boolean preserveBlock \u003d context \u003d\u003d Context.PRESERVE_BLOCK;\n                if (preserveBlock) {\n                    cc.beginBlock();\n                }\n                boolean preferLineBreaks \u003d type \u003d\u003d Token.SCRIPT || (type \u003d\u003d Token.BLOCK \u0026\u0026 !preserveBlock \u0026\u0026 n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.SCRIPT);\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    add(c, Context.STATEMENT);\n                    if (c.getType() \u003d\u003d Token.VAR) {\n                        cc.endStatement();\n                    }\n                    if (c.getType() \u003d\u003d Token.FUNCTION) {\n                        cc.maybeLineBreak();\n                    }\n                    if (preferLineBreaks) {\n                        cc.notePreferredLineBreak();\n                    }\n                }\n                if (preserveBlock) {\n                    cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                }\n                break;\n            }\n        case Token.FOR:\n            if (childCount \u003d\u003d 4) {\n                add(\"for(\");\n                if (first.getType() \u003d\u003d Token.VAR) {\n                    add(first, Context.IN_FOR_INIT_CLAUSE);\n                } else {\n                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                }\n                add(\";\");\n                add(first.getNext());\n                add(\";\");\n                add(first.getNext().getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                add(\"for(\");\n                add(first);\n                add(\"in\");\n                add(first.getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            }\n            break;\n        case Token.DO:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"do\");\n            addNonEmptyStatement(first, Context.OTHER, false);\n            add(\"while(\");\n            add(last);\n            add(\")\");\n            cc.endStatement();\n            break;\n        case Token.WHILE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"while(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.EMPTY:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            break;\n        case Token.GETPROP:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                Preconditions.checkState(last.getType() \u003d\u003d Token.STRING, \"Bad GETPROP: RHS should be STRING\");\n                boolean needsParens \u003d (first.getType() \u003d\u003d Token.NUMBER);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n                if (needsParens) {\n                    add(\")\");\n                }\n                add(\".\");\n                addIdentifier(last.getString());\n                break;\n            }\n        case Token.GETELEM:\n            Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n            addLeftExpr(first, NodeUtil.precedence(type), context);\n            add(\"[\");\n            add(first.getNext());\n            add(\"]\");\n            break;\n        case Token.WITH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"with(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.INC:\n        case Token.DEC:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                if (postProp !\u003d 0) {\n                    addLeftExpr(first, NodeUtil.precedence(type), context);\n                    cc.addOp(o, false);\n                } else {\n                    cc.addOp(o, false);\n                    add(first);\n                }\n                break;\n            }\n        case Token.CALL:\n            if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) \u0026\u0026 NodeUtil.isGet(first)) {\n                add(\"(0,\");\n                addExpr(first, NodeUtil.precedence(Token.COMMA));\n                add(\")\");\n            } else {\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n            }\n            add(\"(\");\n            addList(first.getNext());\n            add(\")\");\n            break;\n        case Token.IF:\n            boolean hasElse \u003d childCount \u003d\u003d 3;\n            boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n            if (ambiguousElseClause) {\n                cc.beginBlock();\n            }\n            add(\"if(\");\n            add(first);\n            add(\")\");\n            if (hasElse) {\n                addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                add(\"else\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n                Preconditions.checkState(childCount \u003d\u003d 2);\n            }\n            if (ambiguousElseClause) {\n                cc.endBlock();\n            }\n            break;\n        case Token.NULL:\n        case Token.THIS:\n        case Token.FALSE:\n        case Token.TRUE:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(Node.tokenToName(type));\n            break;\n        case Token.CONTINUE:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"continue\");\n            if (childCount \u003d\u003d 1) {\n                if (first.getType() !\u003d Token.LABEL_NAME) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.DEBUGGER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"debugger\");\n            cc.endStatement();\n            break;\n        case Token.BREAK:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"break\");\n            if (childCount \u003d\u003d 1) {\n                if (first.getType() !\u003d Token.LABEL_NAME) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.EXPR_VOID:\n            throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n        case Token.EXPR_RESULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first, Context.START_OF_EXPR);\n            cc.endStatement();\n            break;\n        case Token.NEW:\n            add(\"new \");\n            int precedence \u003d NodeUtil.precedence(type);\n            if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction())) {\n                precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n            }\n            addExpr(first, precedence);\n            Node next \u003d first.getNext();\n            if (next !\u003d null) {\n                add(\"(\");\n                addList(next);\n                add(\")\");\n            }\n            break;\n        case Token.STRING:\n            if (childCount !\u003d ((n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.OBJECTLIT) ? 1 : 0)) {\n                throw new IllegalStateException(\"Unexpected String children: \" + n.getParent().toStringTree());\n            }\n            add(jsString(n.getString(), outputCharsetEncoder));\n            break;\n        case Token.DELPROP:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"delete \");\n            add(first);\n            break;\n        case Token.OBJECTLIT:\n            {\n                boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                add(\"{\");\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    if (c !\u003d first) {\n                        cc.listSeparator();\n                    }\n                    if (c.getType() \u003d\u003d Token.STRING \u0026\u0026 !TokenStream.isKeyword(c.getString()) \u0026\u0026 TokenStream.isJSIdentifier(c.getString()) \u0026\u0026 NodeUtil.isLatin(c.getString())) {\n                        add(c.getString());\n                    } else {\n                        addExpr(c, 1);\n                    }\n                    add(\":\");\n                    addExpr(c.getFirstChild(), 1);\n                }\n                add(\"}\");\n                if (needsParens) {\n                    add(\")\");\n                }\n                break;\n            }\n        case Token.SWITCH:\n            add(\"switch(\");\n            add(first);\n            add(\")\");\n            cc.beginBlock();\n            addAllSiblings(first.getNext());\n            cc.endBlock(context \u003d\u003d Context.STATEMENT);\n            break;\n        case Token.CASE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"case \");\n            add(first);\n            addCaseBody(last);\n            break;\n        case Token.DEFAULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"default\");\n            addCaseBody(first);\n            break;\n        case Token.LABEL:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            if (first.getType() !\u003d Token.LABEL_NAME) {\n                throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n            }\n            add(first);\n            add(\":\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\n            break;\n        case Token.SETNAME:\n            break;\n        default:\n            throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n    cc.endSourceMapping(n);\n}",
      "path": "src/com/google/javascript/jscomp/CodeGenerator.java",
      "functionStartLine": 75,
      "functionName": "add",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,474 +1,445 @@\n void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n         return;\n     }\n     int type \u003d n.getType();\n     String opstr \u003d NodeUtil.opToStr(type);\n     int childCount \u003d n.getChildCount();\n     Node first \u003d n.getFirstChild();\n     Node last \u003d n.getLastChild();\n     if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n         Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n         int p \u003d NodeUtil.precedence(type);\n         addLeftExpr(first, p, context);\n         cc.addOp(opstr, true);\n         Context rhsContext \u003d getContextForNoInOperator(context);\n         if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n             addExpr(last, p, rhsContext);\n         } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n             addExpr(last, p, rhsContext);\n         } else {\n             addExpr(last, p + 1, rhsContext);\n         }\n         return;\n     }\n     cc.startSourceMapping(n);\n     switch(type) {\n         case Token.TRY:\n             {\n                 Preconditions.checkState(first.getNext().getType() \u003d\u003d Token.BLOCK \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n                 Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                 add(\"try\");\n                 add(first, Context.PRESERVE_BLOCK);\n                 Node catchblock \u003d first.getNext().getFirstChild();\n                 if (catchblock !\u003d null) {\n                     add(catchblock);\n                 }\n                 if (childCount \u003d\u003d 3) {\n                     add(\"finally\");\n                     add(last, Context.PRESERVE_BLOCK);\n                 }\n                 break;\n             }\n         case Token.CATCH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"catch(\");\n             add(first);\n             add(\")\");\n             add(last, Context.PRESERVE_BLOCK);\n             break;\n         case Token.THROW:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"throw\");\n             add(first);\n             cc.endStatement(true);\n             break;\n         case Token.RETURN:\n             add(\"return\");\n             if (childCount \u003d\u003d 1) {\n                 add(first);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 0);\n             }\n             cc.endStatement();\n             break;\n         case Token.VAR:\n             if (first !\u003d null) {\n                 add(\"var \");\n                 addList(first, false, getContextForNoInOperator(context));\n             }\n             break;\n         case Token.LABEL_NAME:\n             Preconditions.checkState(!n.getString().isEmpty());\n             addIdentifier(n.getString());\n             break;\n         case Token.NAME:\n             if (first \u003d\u003d null || first.getType() \u003d\u003d Token.EMPTY) {\n                 addIdentifier(n.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 addIdentifier(n.getString());\n                 cc.addOp(\"\u003d\", true);\n                 if (first.getType() \u003d\u003d Token.COMMA) {\n                     addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                 } else {\n                     addExpr(first, 0, getContextForNoInOperator(context));\n                 }\n             }\n             break;\n         case Token.ARRAYLIT:\n             add(\"[\");\n             addList(first, (int[]) n.getProp(Node.SKIP_INDEXES_PROP));\n             add(\"]\");\n             break;\n         case Token.LP:\n             add(\"(\");\n             addList(first);\n             add(\")\");\n             break;\n         case Token.COMMA:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             addList(first, false, context);\n             break;\n         case Token.NUMBER:\n             Preconditions.checkState(childCount \u003d\u003d ((n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.OBJECTLIT) ? 1 : 0));\n             cc.addNumber(n.getDouble());\n             break;\n         case Token.TYPEOF:\n         case Token.VOID:\n         case Token.NOT:\n         case Token.BITNOT:\n         case Token.POS:\n         case Token.NEG:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                 addExpr(first, NodeUtil.precedence(type));\n                 break;\n             }\n         case Token.HOOK:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 int p \u003d NodeUtil.precedence(type);\n                 addLeftExpr(first, p + 1, context);\n                 cc.addOp(\"?\", true);\n                 addExpr(first.getNext(), 1);\n                 cc.addOp(\":\", true);\n                 addExpr(last, 1);\n                 break;\n             }\n         case Token.REGEXP:\n             if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                 throw new Error(\"Expected children to be strings\");\n             }\n             String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n             if (childCount \u003d\u003d 2) {\n                 add(regexp + last.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 add(regexp);\n             }\n             break;\n         case Token.GET_REF:\n             add(first);\n             break;\n         case Token.REF_SPECIAL:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first);\n             add(\".\");\n             add((String) n.getProp(Node.NAME_PROP));\n             break;\n         case Token.FUNCTION:\n             if (n.getClass() !\u003d Node.class) {\n                 throw new Error(\"Unexpected Node subclass.\");\n             }\n             Preconditions.checkState(childCount \u003d\u003d 3);\n             boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n             if (funcNeedsParens) {\n                 add(\"(\");\n             }\n             add(\"function\");\n             add(first);\n             add(first.getNext());\n             add(last, Context.PRESERVE_BLOCK);\n             cc.endFunction(context \u003d\u003d Context.STATEMENT);\n             if (funcNeedsParens) {\n                 add(\")\");\n             }\n             break;\n-        case Token.GET:\n-        case Token.SET:\n-            Preconditions.checkState(n.getParent().getType() \u003d\u003d Token.OBJECTLIT);\n-            Preconditions.checkState(childCount \u003d\u003d 1);\n-            Preconditions.checkState(first.getType() \u003d\u003d Token.FUNCTION);\n-            Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n-            if (type \u003d\u003d Token.GET) {\n-                Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n-                add(\"get \");\n-            } else {\n-                Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n-                add(\"set \");\n-            }\n-            String name \u003d n.getString();\n-            Node fn \u003d first;\n-            Node parameters \u003d fn.getChildAtIndex(1);\n-            Node body \u003d fn.getLastChild();\n-            if (TokenStream.isJSIdentifier(name) \u0026\u0026 NodeUtil.isLatin(name)) {\n-                add(name);\n-            } else {\n-                add(jsString(n.getString(), outputCharsetEncoder));\n-            }\n-            add(parameters);\n-            add(body, Context.PRESERVE_BLOCK);\n-            break;\n         case Token.SCRIPT:\n         case Token.BLOCK:\n             {\n                 if (n.getClass() !\u003d Node.class) {\n                     throw new Error(\"Unexpected Node subclass.\");\n                 }\n                 boolean preserveBlock \u003d context \u003d\u003d Context.PRESERVE_BLOCK;\n                 if (preserveBlock) {\n                     cc.beginBlock();\n                 }\n                 boolean preferLineBreaks \u003d type \u003d\u003d Token.SCRIPT || (type \u003d\u003d Token.BLOCK \u0026\u0026 !preserveBlock \u0026\u0026 n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.SCRIPT);\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     add(c, Context.STATEMENT);\n                     if (c.getType() \u003d\u003d Token.VAR) {\n                         cc.endStatement();\n                     }\n                     if (c.getType() \u003d\u003d Token.FUNCTION) {\n                         cc.maybeLineBreak();\n                     }\n                     if (preferLineBreaks) {\n                         cc.notePreferredLineBreak();\n                     }\n                 }\n                 if (preserveBlock) {\n                     cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                 }\n                 break;\n             }\n         case Token.FOR:\n             if (childCount \u003d\u003d 4) {\n                 add(\"for(\");\n                 if (first.getType() \u003d\u003d Token.VAR) {\n                     add(first, Context.IN_FOR_INIT_CLAUSE);\n                 } else {\n                     addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                 }\n                 add(\";\");\n                 add(first.getNext());\n                 add(\";\");\n                 add(first.getNext().getNext());\n                 add(\")\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 add(\"for(\");\n                 add(first);\n                 add(\"in\");\n                 add(first.getNext());\n                 add(\")\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             }\n             break;\n         case Token.DO:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"do\");\n             addNonEmptyStatement(first, Context.OTHER, false);\n             add(\"while(\");\n             add(last);\n             add(\")\");\n             cc.endStatement();\n             break;\n         case Token.WHILE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"while(\");\n             add(first);\n             add(\")\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.EMPTY:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             break;\n         case Token.GETPROP:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                 Preconditions.checkState(last.getType() \u003d\u003d Token.STRING, \"Bad GETPROP: RHS should be STRING\");\n                 boolean needsParens \u003d (first.getType() \u003d\u003d Token.NUMBER);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 add(\".\");\n                 addIdentifier(last.getString());\n                 break;\n             }\n         case Token.GETELEM:\n             Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n             addLeftExpr(first, NodeUtil.precedence(type), context);\n             add(\"[\");\n             add(first.getNext());\n             add(\"]\");\n             break;\n         case Token.WITH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"with(\");\n             add(first);\n             add(\")\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.INC:\n         case Token.DEC:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                 int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                 if (postProp !\u003d 0) {\n                     addLeftExpr(first, NodeUtil.precedence(type), context);\n                     cc.addOp(o, false);\n                 } else {\n                     cc.addOp(o, false);\n                     add(first);\n                 }\n                 break;\n             }\n         case Token.CALL:\n             if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) \u0026\u0026 NodeUtil.isGet(first)) {\n                 add(\"(0,\");\n                 addExpr(first, NodeUtil.precedence(Token.COMMA));\n                 add(\")\");\n             } else {\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n             }\n             add(\"(\");\n             addList(first.getNext());\n             add(\")\");\n             break;\n         case Token.IF:\n             boolean hasElse \u003d childCount \u003d\u003d 3;\n             boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n             if (ambiguousElseClause) {\n                 cc.beginBlock();\n             }\n             add(\"if(\");\n             add(first);\n             add(\")\");\n             if (hasElse) {\n                 addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                 add(\"else\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n                 Preconditions.checkState(childCount \u003d\u003d 2);\n             }\n             if (ambiguousElseClause) {\n                 cc.endBlock();\n             }\n             break;\n         case Token.NULL:\n         case Token.THIS:\n         case Token.FALSE:\n         case Token.TRUE:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(Node.tokenToName(type));\n             break;\n         case Token.CONTINUE:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"continue\");\n             if (childCount \u003d\u003d 1) {\n                 if (first.getType() !\u003d Token.LABEL_NAME) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.DEBUGGER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(\"debugger\");\n             cc.endStatement();\n             break;\n         case Token.BREAK:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"break\");\n             if (childCount \u003d\u003d 1) {\n                 if (first.getType() !\u003d Token.LABEL_NAME) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.EXPR_VOID:\n             throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n         case Token.EXPR_RESULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first, Context.START_OF_EXPR);\n             cc.endStatement();\n             break;\n         case Token.NEW:\n             add(\"new \");\n             int precedence \u003d NodeUtil.precedence(type);\n             if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction())) {\n                 precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n             }\n             addExpr(first, precedence);\n             Node next \u003d first.getNext();\n             if (next !\u003d null) {\n                 add(\"(\");\n                 addList(next);\n                 add(\")\");\n             }\n             break;\n         case Token.STRING:\n             if (childCount !\u003d ((n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.OBJECTLIT) ? 1 : 0)) {\n                 throw new IllegalStateException(\"Unexpected String children: \" + n.getParent().toStringTree());\n             }\n             add(jsString(n.getString(), outputCharsetEncoder));\n             break;\n         case Token.DELPROP:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"delete \");\n             add(first);\n             break;\n         case Token.OBJECTLIT:\n             {\n                 boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 add(\"{\");\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     if (c !\u003d first) {\n                         cc.listSeparator();\n                     }\n-                    if (c.getType() \u003d\u003d Token.GET || c.getType() \u003d\u003d Token.SET) {\n-                        add(c);\n+                    if (c.getType() \u003d\u003d Token.STRING \u0026\u0026 !TokenStream.isKeyword(c.getString()) \u0026\u0026 TokenStream.isJSIdentifier(c.getString()) \u0026\u0026 NodeUtil.isLatin(c.getString())) {\n+                        add(c.getString());\n                     } else {\n-                        if (c.getType() \u003d\u003d Token.STRING \u0026\u0026 !TokenStream.isKeyword(c.getString()) \u0026\u0026 TokenStream.isJSIdentifier(c.getString()) \u0026\u0026 NodeUtil.isLatin(c.getString())) {\n-                            add(c.getString());\n-                        } else {\n-                            addExpr(c, 1);\n-                        }\n-                        add(\":\");\n-                        addExpr(c.getFirstChild(), 1);\n+                        addExpr(c, 1);\n                     }\n+                    add(\":\");\n+                    addExpr(c.getFirstChild(), 1);\n                 }\n                 add(\"}\");\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 break;\n             }\n         case Token.SWITCH:\n             add(\"switch(\");\n             add(first);\n             add(\")\");\n             cc.beginBlock();\n             addAllSiblings(first.getNext());\n             cc.endBlock(context \u003d\u003d Context.STATEMENT);\n             break;\n         case Token.CASE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"case \");\n             add(first);\n             addCaseBody(last);\n             break;\n         case Token.DEFAULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"default\");\n             addCaseBody(first);\n             break;\n         case Token.LABEL:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             if (first.getType() !\u003d Token.LABEL_NAME) {\n                 throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n             }\n             add(first);\n             add(\":\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\n             break;\n         case Token.SETNAME:\n             break;\n         default:\n             throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n     }\n     cc.endSourceMapping(n);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1c92a5447451e3d6e663d4bf508237a6eaeccf90": {
      "type": "Ybodychange",
      "commitMessage": "\nAdd whitespace only mode support for ES5 getters and setters.\n\nR\u003dacleung\nDELTA\u003d318  (263 added, 31 deleted, 24 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d67\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@596 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "12/6/10, 12:03 PM",
      "commitName": "1c92a5447451e3d6e663d4bf508237a6eaeccf90",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "11/11/10, 9:42 PM",
      "commitNameOld": "df223efd38c514d584f00d076488ab9a02011492",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 24.6,
      "commitsBetweenForRepo": 51,
      "commitsBetweenForFile": 1,
      "actualSource": "void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n        return;\n    }\n    int type \u003d n.getType();\n    String opstr \u003d NodeUtil.opToStr(type);\n    int childCount \u003d n.getChildCount();\n    Node first \u003d n.getFirstChild();\n    Node last \u003d n.getLastChild();\n    if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n        Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n        int p \u003d NodeUtil.precedence(type);\n        addLeftExpr(first, p, context);\n        cc.addOp(opstr, true);\n        Context rhsContext \u003d getContextForNoInOperator(context);\n        if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n            addExpr(last, p, rhsContext);\n        } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n            addExpr(last, p, rhsContext);\n        } else {\n            addExpr(last, p + 1, rhsContext);\n        }\n        return;\n    }\n    cc.startSourceMapping(n);\n    switch(type) {\n        case Token.TRY:\n            {\n                Preconditions.checkState(first.getNext().getType() \u003d\u003d Token.BLOCK \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n                Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                add(\"try\");\n                add(first, Context.PRESERVE_BLOCK);\n                Node catchblock \u003d first.getNext().getFirstChild();\n                if (catchblock !\u003d null) {\n                    add(catchblock);\n                }\n                if (childCount \u003d\u003d 3) {\n                    add(\"finally\");\n                    add(last, Context.PRESERVE_BLOCK);\n                }\n                break;\n            }\n        case Token.CATCH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"catch(\");\n            add(first);\n            add(\")\");\n            add(last, Context.PRESERVE_BLOCK);\n            break;\n        case Token.THROW:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"throw\");\n            add(first);\n            cc.endStatement(true);\n            break;\n        case Token.RETURN:\n            add(\"return\");\n            if (childCount \u003d\u003d 1) {\n                add(first);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 0);\n            }\n            cc.endStatement();\n            break;\n        case Token.VAR:\n            if (first !\u003d null) {\n                add(\"var \");\n                addList(first, false, getContextForNoInOperator(context));\n            }\n            break;\n        case Token.LABEL_NAME:\n            Preconditions.checkState(!n.getString().isEmpty());\n            addIdentifier(n.getString());\n            break;\n        case Token.NAME:\n            if (first \u003d\u003d null || first.getType() \u003d\u003d Token.EMPTY) {\n                addIdentifier(n.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                addIdentifier(n.getString());\n                cc.addOp(\"\u003d\", true);\n                if (first.getType() \u003d\u003d Token.COMMA) {\n                    addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                } else {\n                    addExpr(first, 0, getContextForNoInOperator(context));\n                }\n            }\n            break;\n        case Token.ARRAYLIT:\n            add(\"[\");\n            addList(first, (int[]) n.getProp(Node.SKIP_INDEXES_PROP));\n            add(\"]\");\n            break;\n        case Token.LP:\n            add(\"(\");\n            addList(first);\n            add(\")\");\n            break;\n        case Token.COMMA:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            addList(first, false, context);\n            break;\n        case Token.NUMBER:\n            Preconditions.checkState(childCount \u003d\u003d ((n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.OBJECTLIT) ? 1 : 0));\n            cc.addNumber(n.getDouble());\n            break;\n        case Token.TYPEOF:\n        case Token.VOID:\n        case Token.NOT:\n        case Token.BITNOT:\n        case Token.POS:\n        case Token.NEG:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                addExpr(first, NodeUtil.precedence(type));\n                break;\n            }\n        case Token.HOOK:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                int p \u003d NodeUtil.precedence(type);\n                addLeftExpr(first, p + 1, context);\n                cc.addOp(\"?\", true);\n                addExpr(first.getNext(), 1);\n                cc.addOp(\":\", true);\n                addExpr(last, 1);\n                break;\n            }\n        case Token.REGEXP:\n            if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                throw new Error(\"Expected children to be strings\");\n            }\n            String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n            if (childCount \u003d\u003d 2) {\n                add(regexp + last.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                add(regexp);\n            }\n            break;\n        case Token.GET_REF:\n            add(first);\n            break;\n        case Token.REF_SPECIAL:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first);\n            add(\".\");\n            add((String) n.getProp(Node.NAME_PROP));\n            break;\n        case Token.FUNCTION:\n            if (n.getClass() !\u003d Node.class) {\n                throw new Error(\"Unexpected Node subclass.\");\n            }\n            Preconditions.checkState(childCount \u003d\u003d 3);\n            boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n            if (funcNeedsParens) {\n                add(\"(\");\n            }\n            add(\"function\");\n            add(first);\n            add(first.getNext());\n            add(last, Context.PRESERVE_BLOCK);\n            cc.endFunction(context \u003d\u003d Context.STATEMENT);\n            if (funcNeedsParens) {\n                add(\")\");\n            }\n            break;\n        case Token.GET:\n        case Token.SET:\n            Preconditions.checkState(n.getParent().getType() \u003d\u003d Token.OBJECTLIT);\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            Preconditions.checkState(first.getType() \u003d\u003d Token.FUNCTION);\n            Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n            if (type \u003d\u003d Token.GET) {\n                Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n                add(\"get \");\n            } else {\n                Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n                add(\"set \");\n            }\n            String name \u003d n.getString();\n            Node fn \u003d first;\n            Node parameters \u003d fn.getChildAtIndex(1);\n            Node body \u003d fn.getLastChild();\n            if (TokenStream.isJSIdentifier(name) \u0026\u0026 NodeUtil.isLatin(name)) {\n                add(name);\n            } else {\n                add(jsString(n.getString(), outputCharsetEncoder));\n            }\n            add(parameters);\n            add(body, Context.PRESERVE_BLOCK);\n            break;\n        case Token.SCRIPT:\n        case Token.BLOCK:\n            {\n                if (n.getClass() !\u003d Node.class) {\n                    throw new Error(\"Unexpected Node subclass.\");\n                }\n                boolean preserveBlock \u003d context \u003d\u003d Context.PRESERVE_BLOCK;\n                if (preserveBlock) {\n                    cc.beginBlock();\n                }\n                boolean preferLineBreaks \u003d type \u003d\u003d Token.SCRIPT || (type \u003d\u003d Token.BLOCK \u0026\u0026 !preserveBlock \u0026\u0026 n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.SCRIPT);\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    add(c, Context.STATEMENT);\n                    if (c.getType() \u003d\u003d Token.VAR) {\n                        cc.endStatement();\n                    }\n                    if (c.getType() \u003d\u003d Token.FUNCTION) {\n                        cc.maybeLineBreak();\n                    }\n                    if (preferLineBreaks) {\n                        cc.notePreferredLineBreak();\n                    }\n                }\n                if (preserveBlock) {\n                    cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                }\n                break;\n            }\n        case Token.FOR:\n            if (childCount \u003d\u003d 4) {\n                add(\"for(\");\n                if (first.getType() \u003d\u003d Token.VAR) {\n                    add(first, Context.IN_FOR_INIT_CLAUSE);\n                } else {\n                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                }\n                add(\";\");\n                add(first.getNext());\n                add(\";\");\n                add(first.getNext().getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                add(\"for(\");\n                add(first);\n                add(\"in\");\n                add(first.getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            }\n            break;\n        case Token.DO:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"do\");\n            addNonEmptyStatement(first, Context.OTHER, false);\n            add(\"while(\");\n            add(last);\n            add(\")\");\n            cc.endStatement();\n            break;\n        case Token.WHILE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"while(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.EMPTY:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            break;\n        case Token.GETPROP:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                Preconditions.checkState(last.getType() \u003d\u003d Token.STRING, \"Bad GETPROP: RHS should be STRING\");\n                boolean needsParens \u003d (first.getType() \u003d\u003d Token.NUMBER);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n                if (needsParens) {\n                    add(\")\");\n                }\n                add(\".\");\n                addIdentifier(last.getString());\n                break;\n            }\n        case Token.GETELEM:\n            Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n            addLeftExpr(first, NodeUtil.precedence(type), context);\n            add(\"[\");\n            add(first.getNext());\n            add(\"]\");\n            break;\n        case Token.WITH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"with(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.INC:\n        case Token.DEC:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                if (postProp !\u003d 0) {\n                    addLeftExpr(first, NodeUtil.precedence(type), context);\n                    cc.addOp(o, false);\n                } else {\n                    cc.addOp(o, false);\n                    add(first);\n                }\n                break;\n            }\n        case Token.CALL:\n            if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) \u0026\u0026 NodeUtil.isGet(first)) {\n                add(\"(0,\");\n                addExpr(first, NodeUtil.precedence(Token.COMMA));\n                add(\")\");\n            } else {\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n            }\n            add(\"(\");\n            addList(first.getNext());\n            add(\")\");\n            break;\n        case Token.IF:\n            boolean hasElse \u003d childCount \u003d\u003d 3;\n            boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n            if (ambiguousElseClause) {\n                cc.beginBlock();\n            }\n            add(\"if(\");\n            add(first);\n            add(\")\");\n            if (hasElse) {\n                addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                add(\"else\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n                Preconditions.checkState(childCount \u003d\u003d 2);\n            }\n            if (ambiguousElseClause) {\n                cc.endBlock();\n            }\n            break;\n        case Token.NULL:\n        case Token.THIS:\n        case Token.FALSE:\n        case Token.TRUE:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(Node.tokenToName(type));\n            break;\n        case Token.CONTINUE:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"continue\");\n            if (childCount \u003d\u003d 1) {\n                if (first.getType() !\u003d Token.LABEL_NAME) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.DEBUGGER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"debugger\");\n            cc.endStatement();\n            break;\n        case Token.BREAK:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"break\");\n            if (childCount \u003d\u003d 1) {\n                if (first.getType() !\u003d Token.LABEL_NAME) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.EXPR_VOID:\n            throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n        case Token.EXPR_RESULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first, Context.START_OF_EXPR);\n            cc.endStatement();\n            break;\n        case Token.NEW:\n            add(\"new \");\n            int precedence \u003d NodeUtil.precedence(type);\n            if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction())) {\n                precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n            }\n            addExpr(first, precedence);\n            Node next \u003d first.getNext();\n            if (next !\u003d null) {\n                add(\"(\");\n                addList(next);\n                add(\")\");\n            }\n            break;\n        case Token.STRING:\n            if (childCount !\u003d ((n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.OBJECTLIT) ? 1 : 0)) {\n                throw new IllegalStateException(\"Unexpected String children: \" + n.getParent().toStringTree());\n            }\n            add(jsString(n.getString(), outputCharsetEncoder));\n            break;\n        case Token.DELPROP:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"delete \");\n            add(first);\n            break;\n        case Token.OBJECTLIT:\n            {\n                boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                add(\"{\");\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    if (c !\u003d first) {\n                        cc.listSeparator();\n                    }\n                    if (c.getType() \u003d\u003d Token.GET || c.getType() \u003d\u003d Token.SET) {\n                        add(c);\n                    } else {\n                        if (c.getType() \u003d\u003d Token.STRING \u0026\u0026 !TokenStream.isKeyword(c.getString()) \u0026\u0026 TokenStream.isJSIdentifier(c.getString()) \u0026\u0026 NodeUtil.isLatin(c.getString())) {\n                            add(c.getString());\n                        } else {\n                            addExpr(c, 1);\n                        }\n                        add(\":\");\n                        addExpr(c.getFirstChild(), 1);\n                    }\n                }\n                add(\"}\");\n                if (needsParens) {\n                    add(\")\");\n                }\n                break;\n            }\n        case Token.SWITCH:\n            add(\"switch(\");\n            add(first);\n            add(\")\");\n            cc.beginBlock();\n            addAllSiblings(first.getNext());\n            cc.endBlock(context \u003d\u003d Context.STATEMENT);\n            break;\n        case Token.CASE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"case \");\n            add(first);\n            addCaseBody(last);\n            break;\n        case Token.DEFAULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"default\");\n            addCaseBody(first);\n            break;\n        case Token.LABEL:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            if (first.getType() !\u003d Token.LABEL_NAME) {\n                throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n            }\n            add(first);\n            add(\":\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\n            break;\n        case Token.SETNAME:\n            break;\n        default:\n            throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n    cc.endSourceMapping(n);\n}",
      "path": "src/com/google/javascript/jscomp/CodeGenerator.java",
      "functionStartLine": 75,
      "functionName": "add",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,445 +1,474 @@\n void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n         return;\n     }\n     int type \u003d n.getType();\n     String opstr \u003d NodeUtil.opToStr(type);\n     int childCount \u003d n.getChildCount();\n     Node first \u003d n.getFirstChild();\n     Node last \u003d n.getLastChild();\n     if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n         Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n         int p \u003d NodeUtil.precedence(type);\n         addLeftExpr(first, p, context);\n         cc.addOp(opstr, true);\n         Context rhsContext \u003d getContextForNoInOperator(context);\n         if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n             addExpr(last, p, rhsContext);\n         } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n             addExpr(last, p, rhsContext);\n         } else {\n             addExpr(last, p + 1, rhsContext);\n         }\n         return;\n     }\n     cc.startSourceMapping(n);\n     switch(type) {\n         case Token.TRY:\n             {\n                 Preconditions.checkState(first.getNext().getType() \u003d\u003d Token.BLOCK \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n                 Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                 add(\"try\");\n                 add(first, Context.PRESERVE_BLOCK);\n                 Node catchblock \u003d first.getNext().getFirstChild();\n                 if (catchblock !\u003d null) {\n                     add(catchblock);\n                 }\n                 if (childCount \u003d\u003d 3) {\n                     add(\"finally\");\n                     add(last, Context.PRESERVE_BLOCK);\n                 }\n                 break;\n             }\n         case Token.CATCH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"catch(\");\n             add(first);\n             add(\")\");\n             add(last, Context.PRESERVE_BLOCK);\n             break;\n         case Token.THROW:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"throw\");\n             add(first);\n             cc.endStatement(true);\n             break;\n         case Token.RETURN:\n             add(\"return\");\n             if (childCount \u003d\u003d 1) {\n                 add(first);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 0);\n             }\n             cc.endStatement();\n             break;\n         case Token.VAR:\n             if (first !\u003d null) {\n                 add(\"var \");\n                 addList(first, false, getContextForNoInOperator(context));\n             }\n             break;\n         case Token.LABEL_NAME:\n             Preconditions.checkState(!n.getString().isEmpty());\n             addIdentifier(n.getString());\n             break;\n         case Token.NAME:\n             if (first \u003d\u003d null || first.getType() \u003d\u003d Token.EMPTY) {\n                 addIdentifier(n.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 addIdentifier(n.getString());\n                 cc.addOp(\"\u003d\", true);\n                 if (first.getType() \u003d\u003d Token.COMMA) {\n                     addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                 } else {\n                     addExpr(first, 0, getContextForNoInOperator(context));\n                 }\n             }\n             break;\n         case Token.ARRAYLIT:\n             add(\"[\");\n             addList(first, (int[]) n.getProp(Node.SKIP_INDEXES_PROP));\n             add(\"]\");\n             break;\n         case Token.LP:\n             add(\"(\");\n             addList(first);\n             add(\")\");\n             break;\n         case Token.COMMA:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             addList(first, false, context);\n             break;\n         case Token.NUMBER:\n             Preconditions.checkState(childCount \u003d\u003d ((n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.OBJECTLIT) ? 1 : 0));\n             cc.addNumber(n.getDouble());\n             break;\n         case Token.TYPEOF:\n         case Token.VOID:\n         case Token.NOT:\n         case Token.BITNOT:\n         case Token.POS:\n         case Token.NEG:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                 addExpr(first, NodeUtil.precedence(type));\n                 break;\n             }\n         case Token.HOOK:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 int p \u003d NodeUtil.precedence(type);\n                 addLeftExpr(first, p + 1, context);\n                 cc.addOp(\"?\", true);\n                 addExpr(first.getNext(), 1);\n                 cc.addOp(\":\", true);\n                 addExpr(last, 1);\n                 break;\n             }\n         case Token.REGEXP:\n             if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                 throw new Error(\"Expected children to be strings\");\n             }\n             String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n             if (childCount \u003d\u003d 2) {\n                 add(regexp + last.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 add(regexp);\n             }\n             break;\n         case Token.GET_REF:\n             add(first);\n             break;\n         case Token.REF_SPECIAL:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first);\n             add(\".\");\n             add((String) n.getProp(Node.NAME_PROP));\n             break;\n         case Token.FUNCTION:\n             if (n.getClass() !\u003d Node.class) {\n                 throw new Error(\"Unexpected Node subclass.\");\n             }\n             Preconditions.checkState(childCount \u003d\u003d 3);\n             boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n             if (funcNeedsParens) {\n                 add(\"(\");\n             }\n             add(\"function\");\n             add(first);\n             add(first.getNext());\n             add(last, Context.PRESERVE_BLOCK);\n             cc.endFunction(context \u003d\u003d Context.STATEMENT);\n             if (funcNeedsParens) {\n                 add(\")\");\n             }\n             break;\n+        case Token.GET:\n+        case Token.SET:\n+            Preconditions.checkState(n.getParent().getType() \u003d\u003d Token.OBJECTLIT);\n+            Preconditions.checkState(childCount \u003d\u003d 1);\n+            Preconditions.checkState(first.getType() \u003d\u003d Token.FUNCTION);\n+            Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n+            if (type \u003d\u003d Token.GET) {\n+                Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n+                add(\"get \");\n+            } else {\n+                Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n+                add(\"set \");\n+            }\n+            String name \u003d n.getString();\n+            Node fn \u003d first;\n+            Node parameters \u003d fn.getChildAtIndex(1);\n+            Node body \u003d fn.getLastChild();\n+            if (TokenStream.isJSIdentifier(name) \u0026\u0026 NodeUtil.isLatin(name)) {\n+                add(name);\n+            } else {\n+                add(jsString(n.getString(), outputCharsetEncoder));\n+            }\n+            add(parameters);\n+            add(body, Context.PRESERVE_BLOCK);\n+            break;\n         case Token.SCRIPT:\n         case Token.BLOCK:\n             {\n                 if (n.getClass() !\u003d Node.class) {\n                     throw new Error(\"Unexpected Node subclass.\");\n                 }\n                 boolean preserveBlock \u003d context \u003d\u003d Context.PRESERVE_BLOCK;\n                 if (preserveBlock) {\n                     cc.beginBlock();\n                 }\n                 boolean preferLineBreaks \u003d type \u003d\u003d Token.SCRIPT || (type \u003d\u003d Token.BLOCK \u0026\u0026 !preserveBlock \u0026\u0026 n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.SCRIPT);\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     add(c, Context.STATEMENT);\n                     if (c.getType() \u003d\u003d Token.VAR) {\n                         cc.endStatement();\n                     }\n                     if (c.getType() \u003d\u003d Token.FUNCTION) {\n                         cc.maybeLineBreak();\n                     }\n                     if (preferLineBreaks) {\n                         cc.notePreferredLineBreak();\n                     }\n                 }\n                 if (preserveBlock) {\n                     cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                 }\n                 break;\n             }\n         case Token.FOR:\n             if (childCount \u003d\u003d 4) {\n                 add(\"for(\");\n                 if (first.getType() \u003d\u003d Token.VAR) {\n                     add(first, Context.IN_FOR_INIT_CLAUSE);\n                 } else {\n                     addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                 }\n                 add(\";\");\n                 add(first.getNext());\n                 add(\";\");\n                 add(first.getNext().getNext());\n                 add(\")\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 add(\"for(\");\n                 add(first);\n                 add(\"in\");\n                 add(first.getNext());\n                 add(\")\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             }\n             break;\n         case Token.DO:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"do\");\n             addNonEmptyStatement(first, Context.OTHER, false);\n             add(\"while(\");\n             add(last);\n             add(\")\");\n             cc.endStatement();\n             break;\n         case Token.WHILE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"while(\");\n             add(first);\n             add(\")\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.EMPTY:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             break;\n         case Token.GETPROP:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                 Preconditions.checkState(last.getType() \u003d\u003d Token.STRING, \"Bad GETPROP: RHS should be STRING\");\n                 boolean needsParens \u003d (first.getType() \u003d\u003d Token.NUMBER);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 add(\".\");\n                 addIdentifier(last.getString());\n                 break;\n             }\n         case Token.GETELEM:\n             Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n             addLeftExpr(first, NodeUtil.precedence(type), context);\n             add(\"[\");\n             add(first.getNext());\n             add(\"]\");\n             break;\n         case Token.WITH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"with(\");\n             add(first);\n             add(\")\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.INC:\n         case Token.DEC:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                 int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                 if (postProp !\u003d 0) {\n                     addLeftExpr(first, NodeUtil.precedence(type), context);\n                     cc.addOp(o, false);\n                 } else {\n                     cc.addOp(o, false);\n                     add(first);\n                 }\n                 break;\n             }\n         case Token.CALL:\n             if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) \u0026\u0026 NodeUtil.isGet(first)) {\n                 add(\"(0,\");\n                 addExpr(first, NodeUtil.precedence(Token.COMMA));\n                 add(\")\");\n             } else {\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n             }\n             add(\"(\");\n             addList(first.getNext());\n             add(\")\");\n             break;\n         case Token.IF:\n             boolean hasElse \u003d childCount \u003d\u003d 3;\n             boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n             if (ambiguousElseClause) {\n                 cc.beginBlock();\n             }\n             add(\"if(\");\n             add(first);\n             add(\")\");\n             if (hasElse) {\n                 addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                 add(\"else\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n                 Preconditions.checkState(childCount \u003d\u003d 2);\n             }\n             if (ambiguousElseClause) {\n                 cc.endBlock();\n             }\n             break;\n         case Token.NULL:\n         case Token.THIS:\n         case Token.FALSE:\n         case Token.TRUE:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(Node.tokenToName(type));\n             break;\n         case Token.CONTINUE:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"continue\");\n             if (childCount \u003d\u003d 1) {\n                 if (first.getType() !\u003d Token.LABEL_NAME) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.DEBUGGER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(\"debugger\");\n             cc.endStatement();\n             break;\n         case Token.BREAK:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"break\");\n             if (childCount \u003d\u003d 1) {\n                 if (first.getType() !\u003d Token.LABEL_NAME) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.EXPR_VOID:\n             throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n         case Token.EXPR_RESULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first, Context.START_OF_EXPR);\n             cc.endStatement();\n             break;\n         case Token.NEW:\n             add(\"new \");\n             int precedence \u003d NodeUtil.precedence(type);\n             if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction())) {\n                 precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n             }\n             addExpr(first, precedence);\n             Node next \u003d first.getNext();\n             if (next !\u003d null) {\n                 add(\"(\");\n                 addList(next);\n                 add(\")\");\n             }\n             break;\n         case Token.STRING:\n             if (childCount !\u003d ((n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.OBJECTLIT) ? 1 : 0)) {\n                 throw new IllegalStateException(\"Unexpected String children: \" + n.getParent().toStringTree());\n             }\n             add(jsString(n.getString(), outputCharsetEncoder));\n             break;\n         case Token.DELPROP:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"delete \");\n             add(first);\n             break;\n         case Token.OBJECTLIT:\n             {\n                 boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 add(\"{\");\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     if (c !\u003d first) {\n                         cc.listSeparator();\n                     }\n-                    if (c.getType() \u003d\u003d Token.STRING \u0026\u0026 !TokenStream.isKeyword(c.getString()) \u0026\u0026 TokenStream.isJSIdentifier(c.getString()) \u0026\u0026 NodeUtil.isLatin(c.getString())) {\n-                        add(c.getString());\n+                    if (c.getType() \u003d\u003d Token.GET || c.getType() \u003d\u003d Token.SET) {\n+                        add(c);\n                     } else {\n-                        addExpr(c, 1);\n+                        if (c.getType() \u003d\u003d Token.STRING \u0026\u0026 !TokenStream.isKeyword(c.getString()) \u0026\u0026 TokenStream.isJSIdentifier(c.getString()) \u0026\u0026 NodeUtil.isLatin(c.getString())) {\n+                            add(c.getString());\n+                        } else {\n+                            addExpr(c, 1);\n+                        }\n+                        add(\":\");\n+                        addExpr(c.getFirstChild(), 1);\n                     }\n-                    add(\":\");\n-                    addExpr(c.getFirstChild(), 1);\n                 }\n                 add(\"}\");\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 break;\n             }\n         case Token.SWITCH:\n             add(\"switch(\");\n             add(first);\n             add(\")\");\n             cc.beginBlock();\n             addAllSiblings(first.getNext());\n             cc.endBlock(context \u003d\u003d Context.STATEMENT);\n             break;\n         case Token.CASE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"case \");\n             add(first);\n             addCaseBody(last);\n             break;\n         case Token.DEFAULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"default\");\n             addCaseBody(first);\n             break;\n         case Token.LABEL:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             if (first.getType() !\u003d Token.LABEL_NAME) {\n                 throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n             }\n             add(first);\n             add(\":\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\n             break;\n         case Token.SETNAME:\n             break;\n         default:\n             throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n     }\n     cc.endSourceMapping(n);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5b4d241bf1caf69e32bb55bc076ed70ce5cb3d4e": {
      "type": "Ybodychange",
      "commitMessage": "\nRemove Node.toStringTree exectuted when printing every String.\n\nR\u003dnicksantos\nDELTA\u003d6  (2 added, 1 deleted, 3 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d868002\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@524 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "10/29/10, 12:37 PM",
      "commitName": "5b4d241bf1caf69e32bb55bc076ed70ce5cb3d4e",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "10/18/10, 2:55 PM",
      "commitNameOld": "34fd5f8275ae69fc772c2283a3c5fd13b93a7c42",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 10.9,
      "commitsBetweenForRepo": 30,
      "commitsBetweenForFile": 1,
      "actualSource": "void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n        return;\n    }\n    int type \u003d n.getType();\n    String opstr \u003d NodeUtil.opToStr(type);\n    int childCount \u003d n.getChildCount();\n    Node first \u003d n.getFirstChild();\n    Node last \u003d n.getLastChild();\n    if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n        Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n        int p \u003d NodeUtil.precedence(type);\n        addLeftExpr(first, p, context);\n        cc.addOp(opstr, true);\n        Context rhsContext \u003d getContextForNoInOperator(context);\n        if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n            addExpr(last, p, rhsContext);\n        } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n            addExpr(last, p, rhsContext);\n        } else {\n            addExpr(last, p + 1, rhsContext);\n        }\n        return;\n    }\n    cc.startSourceMapping(n);\n    switch(type) {\n        case Token.TRY:\n            {\n                Preconditions.checkState(first.getNext().getType() \u003d\u003d Token.BLOCK \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n                Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                add(\"try\");\n                add(first, Context.PRESERVE_BLOCK);\n                Node catchblock \u003d first.getNext().getFirstChild();\n                if (catchblock !\u003d null) {\n                    add(catchblock);\n                }\n                if (childCount \u003d\u003d 3) {\n                    add(\"finally\");\n                    add(last, Context.PRESERVE_BLOCK);\n                }\n                break;\n            }\n        case Token.CATCH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"catch(\");\n            add(first);\n            add(\")\");\n            add(last, Context.PRESERVE_BLOCK);\n            break;\n        case Token.THROW:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"throw\");\n            add(first);\n            cc.endStatement(true);\n            break;\n        case Token.RETURN:\n            add(\"return\");\n            if (childCount \u003d\u003d 1) {\n                add(first);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 0);\n            }\n            cc.endStatement();\n            break;\n        case Token.VAR:\n            if (first !\u003d null) {\n                add(\"var \");\n                addList(first, false, getContextForNoInOperator(context));\n            }\n            break;\n        case Token.LABEL_NAME:\n            Preconditions.checkState(!n.getString().isEmpty());\n            addIdentifier(n.getString());\n            break;\n        case Token.NAME:\n            if (first \u003d\u003d null || first.getType() \u003d\u003d Token.EMPTY) {\n                addIdentifier(n.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                addIdentifier(n.getString());\n                cc.addOp(\"\u003d\", true);\n                if (first.getType() \u003d\u003d Token.COMMA) {\n                    addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                } else {\n                    addExpr(first, 0, getContextForNoInOperator(context));\n                }\n            }\n            break;\n        case Token.ARRAYLIT:\n            add(\"[\");\n            addList(first, (int[]) n.getProp(Node.SKIP_INDEXES_PROP));\n            add(\"]\");\n            break;\n        case Token.LP:\n            add(\"(\");\n            addList(first);\n            add(\")\");\n            break;\n        case Token.COMMA:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            addList(first, false, context);\n            break;\n        case Token.NUMBER:\n            Preconditions.checkState(childCount \u003d\u003d ((n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.OBJECTLIT) ? 1 : 0));\n            cc.addNumber(n.getDouble());\n            break;\n        case Token.TYPEOF:\n        case Token.VOID:\n        case Token.NOT:\n        case Token.BITNOT:\n        case Token.POS:\n        case Token.NEG:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                addExpr(first, NodeUtil.precedence(type));\n                break;\n            }\n        case Token.HOOK:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                int p \u003d NodeUtil.precedence(type);\n                addLeftExpr(first, p + 1, context);\n                cc.addOp(\"?\", true);\n                addExpr(first.getNext(), 1);\n                cc.addOp(\":\", true);\n                addExpr(last, 1);\n                break;\n            }\n        case Token.REGEXP:\n            if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                throw new Error(\"Expected children to be strings\");\n            }\n            String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n            if (childCount \u003d\u003d 2) {\n                add(regexp + last.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                add(regexp);\n            }\n            break;\n        case Token.GET_REF:\n            add(first);\n            break;\n        case Token.REF_SPECIAL:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first);\n            add(\".\");\n            add((String) n.getProp(Node.NAME_PROP));\n            break;\n        case Token.FUNCTION:\n            if (n.getClass() !\u003d Node.class) {\n                throw new Error(\"Unexpected Node subclass.\");\n            }\n            Preconditions.checkState(childCount \u003d\u003d 3);\n            boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n            if (funcNeedsParens) {\n                add(\"(\");\n            }\n            add(\"function\");\n            add(first);\n            add(first.getNext());\n            add(last, Context.PRESERVE_BLOCK);\n            cc.endFunction(context \u003d\u003d Context.STATEMENT);\n            if (funcNeedsParens) {\n                add(\")\");\n            }\n            break;\n        case Token.SCRIPT:\n        case Token.BLOCK:\n            {\n                if (n.getClass() !\u003d Node.class) {\n                    throw new Error(\"Unexpected Node subclass.\");\n                }\n                boolean preserveBlock \u003d context \u003d\u003d Context.PRESERVE_BLOCK;\n                if (preserveBlock) {\n                    cc.beginBlock();\n                }\n                boolean preferLineBreaks \u003d type \u003d\u003d Token.SCRIPT || (type \u003d\u003d Token.BLOCK \u0026\u0026 !preserveBlock \u0026\u0026 n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.SCRIPT);\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    add(c, Context.STATEMENT);\n                    if (c.getType() \u003d\u003d Token.VAR) {\n                        cc.endStatement();\n                    }\n                    if (c.getType() \u003d\u003d Token.FUNCTION) {\n                        cc.maybeLineBreak();\n                    }\n                    if (preferLineBreaks) {\n                        cc.notePreferredLineBreak();\n                    }\n                }\n                if (preserveBlock) {\n                    cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                }\n                break;\n            }\n        case Token.FOR:\n            if (childCount \u003d\u003d 4) {\n                add(\"for(\");\n                if (first.getType() \u003d\u003d Token.VAR) {\n                    add(first, Context.IN_FOR_INIT_CLAUSE);\n                } else {\n                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                }\n                add(\";\");\n                add(first.getNext());\n                add(\";\");\n                add(first.getNext().getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                add(\"for(\");\n                add(first);\n                add(\"in\");\n                add(first.getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            }\n            break;\n        case Token.DO:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"do\");\n            addNonEmptyStatement(first, Context.OTHER, false);\n            add(\"while(\");\n            add(last);\n            add(\")\");\n            cc.endStatement();\n            break;\n        case Token.WHILE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"while(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.EMPTY:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            break;\n        case Token.GETPROP:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                Preconditions.checkState(last.getType() \u003d\u003d Token.STRING, \"Bad GETPROP: RHS should be STRING\");\n                boolean needsParens \u003d (first.getType() \u003d\u003d Token.NUMBER);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n                if (needsParens) {\n                    add(\")\");\n                }\n                add(\".\");\n                addIdentifier(last.getString());\n                break;\n            }\n        case Token.GETELEM:\n            Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n            addLeftExpr(first, NodeUtil.precedence(type), context);\n            add(\"[\");\n            add(first.getNext());\n            add(\"]\");\n            break;\n        case Token.WITH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"with(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.INC:\n        case Token.DEC:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                if (postProp !\u003d 0) {\n                    addLeftExpr(first, NodeUtil.precedence(type), context);\n                    cc.addOp(o, false);\n                } else {\n                    cc.addOp(o, false);\n                    add(first);\n                }\n                break;\n            }\n        case Token.CALL:\n            if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) \u0026\u0026 NodeUtil.isGet(first)) {\n                add(\"(0,\");\n                addExpr(first, NodeUtil.precedence(Token.COMMA));\n                add(\")\");\n            } else {\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n            }\n            add(\"(\");\n            addList(first.getNext());\n            add(\")\");\n            break;\n        case Token.IF:\n            boolean hasElse \u003d childCount \u003d\u003d 3;\n            boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n            if (ambiguousElseClause) {\n                cc.beginBlock();\n            }\n            add(\"if(\");\n            add(first);\n            add(\")\");\n            if (hasElse) {\n                addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                add(\"else\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n                Preconditions.checkState(childCount \u003d\u003d 2);\n            }\n            if (ambiguousElseClause) {\n                cc.endBlock();\n            }\n            break;\n        case Token.NULL:\n        case Token.THIS:\n        case Token.FALSE:\n        case Token.TRUE:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(Node.tokenToName(type));\n            break;\n        case Token.CONTINUE:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"continue\");\n            if (childCount \u003d\u003d 1) {\n                if (first.getType() !\u003d Token.LABEL_NAME) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.DEBUGGER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"debugger\");\n            cc.endStatement();\n            break;\n        case Token.BREAK:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"break\");\n            if (childCount \u003d\u003d 1) {\n                if (first.getType() !\u003d Token.LABEL_NAME) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.EXPR_VOID:\n            throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n        case Token.EXPR_RESULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first, Context.START_OF_EXPR);\n            cc.endStatement();\n            break;\n        case Token.NEW:\n            add(\"new \");\n            int precedence \u003d NodeUtil.precedence(type);\n            if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction())) {\n                precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n            }\n            addExpr(first, precedence);\n            Node next \u003d first.getNext();\n            if (next !\u003d null) {\n                add(\"(\");\n                addList(next);\n                add(\")\");\n            }\n            break;\n        case Token.STRING:\n            if (childCount !\u003d ((n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.OBJECTLIT) ? 1 : 0)) {\n                throw new IllegalStateException(\"Unexpected String children: \" + n.getParent().toStringTree());\n            }\n            add(jsString(n.getString(), outputCharsetEncoder));\n            break;\n        case Token.DELPROP:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"delete \");\n            add(first);\n            break;\n        case Token.OBJECTLIT:\n            {\n                boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                add(\"{\");\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    if (c !\u003d first) {\n                        cc.listSeparator();\n                    }\n                    if (c.getType() \u003d\u003d Token.STRING \u0026\u0026 !TokenStream.isKeyword(c.getString()) \u0026\u0026 TokenStream.isJSIdentifier(c.getString()) \u0026\u0026 NodeUtil.isLatin(c.getString())) {\n                        add(c.getString());\n                    } else {\n                        addExpr(c, 1);\n                    }\n                    add(\":\");\n                    addExpr(c.getFirstChild(), 1);\n                }\n                add(\"}\");\n                if (needsParens) {\n                    add(\")\");\n                }\n                break;\n            }\n        case Token.SWITCH:\n            add(\"switch(\");\n            add(first);\n            add(\")\");\n            cc.beginBlock();\n            addAllSiblings(first.getNext());\n            cc.endBlock(context \u003d\u003d Context.STATEMENT);\n            break;\n        case Token.CASE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"case \");\n            add(first);\n            addCaseBody(last);\n            break;\n        case Token.DEFAULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"default\");\n            addCaseBody(first);\n            break;\n        case Token.LABEL:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            if (first.getType() !\u003d Token.LABEL_NAME) {\n                throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n            }\n            add(first);\n            add(\":\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\n            break;\n        case Token.SETNAME:\n            break;\n        default:\n            throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n    cc.endSourceMapping(n);\n}",
      "path": "src/com/google/javascript/jscomp/CodeGenerator.java",
      "functionStartLine": 75,
      "functionName": "add",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,443 +1,445 @@\n void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n         return;\n     }\n     int type \u003d n.getType();\n     String opstr \u003d NodeUtil.opToStr(type);\n     int childCount \u003d n.getChildCount();\n     Node first \u003d n.getFirstChild();\n     Node last \u003d n.getLastChild();\n     if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n         Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n         int p \u003d NodeUtil.precedence(type);\n         addLeftExpr(first, p, context);\n         cc.addOp(opstr, true);\n         Context rhsContext \u003d getContextForNoInOperator(context);\n         if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n             addExpr(last, p, rhsContext);\n         } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n             addExpr(last, p, rhsContext);\n         } else {\n             addExpr(last, p + 1, rhsContext);\n         }\n         return;\n     }\n     cc.startSourceMapping(n);\n     switch(type) {\n         case Token.TRY:\n             {\n                 Preconditions.checkState(first.getNext().getType() \u003d\u003d Token.BLOCK \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n                 Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                 add(\"try\");\n                 add(first, Context.PRESERVE_BLOCK);\n                 Node catchblock \u003d first.getNext().getFirstChild();\n                 if (catchblock !\u003d null) {\n                     add(catchblock);\n                 }\n                 if (childCount \u003d\u003d 3) {\n                     add(\"finally\");\n                     add(last, Context.PRESERVE_BLOCK);\n                 }\n                 break;\n             }\n         case Token.CATCH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"catch(\");\n             add(first);\n             add(\")\");\n             add(last, Context.PRESERVE_BLOCK);\n             break;\n         case Token.THROW:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"throw\");\n             add(first);\n             cc.endStatement(true);\n             break;\n         case Token.RETURN:\n             add(\"return\");\n             if (childCount \u003d\u003d 1) {\n                 add(first);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 0);\n             }\n             cc.endStatement();\n             break;\n         case Token.VAR:\n             if (first !\u003d null) {\n                 add(\"var \");\n                 addList(first, false, getContextForNoInOperator(context));\n             }\n             break;\n         case Token.LABEL_NAME:\n             Preconditions.checkState(!n.getString().isEmpty());\n             addIdentifier(n.getString());\n             break;\n         case Token.NAME:\n             if (first \u003d\u003d null || first.getType() \u003d\u003d Token.EMPTY) {\n                 addIdentifier(n.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 addIdentifier(n.getString());\n                 cc.addOp(\"\u003d\", true);\n                 if (first.getType() \u003d\u003d Token.COMMA) {\n                     addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                 } else {\n                     addExpr(first, 0, getContextForNoInOperator(context));\n                 }\n             }\n             break;\n         case Token.ARRAYLIT:\n             add(\"[\");\n             addList(first, (int[]) n.getProp(Node.SKIP_INDEXES_PROP));\n             add(\"]\");\n             break;\n         case Token.LP:\n             add(\"(\");\n             addList(first);\n             add(\")\");\n             break;\n         case Token.COMMA:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             addList(first, false, context);\n             break;\n         case Token.NUMBER:\n             Preconditions.checkState(childCount \u003d\u003d ((n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.OBJECTLIT) ? 1 : 0));\n             cc.addNumber(n.getDouble());\n             break;\n         case Token.TYPEOF:\n         case Token.VOID:\n         case Token.NOT:\n         case Token.BITNOT:\n         case Token.POS:\n         case Token.NEG:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                 addExpr(first, NodeUtil.precedence(type));\n                 break;\n             }\n         case Token.HOOK:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 int p \u003d NodeUtil.precedence(type);\n                 addLeftExpr(first, p + 1, context);\n                 cc.addOp(\"?\", true);\n                 addExpr(first.getNext(), 1);\n                 cc.addOp(\":\", true);\n                 addExpr(last, 1);\n                 break;\n             }\n         case Token.REGEXP:\n             if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                 throw new Error(\"Expected children to be strings\");\n             }\n             String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n             if (childCount \u003d\u003d 2) {\n                 add(regexp + last.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 add(regexp);\n             }\n             break;\n         case Token.GET_REF:\n             add(first);\n             break;\n         case Token.REF_SPECIAL:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first);\n             add(\".\");\n             add((String) n.getProp(Node.NAME_PROP));\n             break;\n         case Token.FUNCTION:\n             if (n.getClass() !\u003d Node.class) {\n                 throw new Error(\"Unexpected Node subclass.\");\n             }\n             Preconditions.checkState(childCount \u003d\u003d 3);\n             boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n             if (funcNeedsParens) {\n                 add(\"(\");\n             }\n             add(\"function\");\n             add(first);\n             add(first.getNext());\n             add(last, Context.PRESERVE_BLOCK);\n             cc.endFunction(context \u003d\u003d Context.STATEMENT);\n             if (funcNeedsParens) {\n                 add(\")\");\n             }\n             break;\n         case Token.SCRIPT:\n         case Token.BLOCK:\n             {\n                 if (n.getClass() !\u003d Node.class) {\n                     throw new Error(\"Unexpected Node subclass.\");\n                 }\n                 boolean preserveBlock \u003d context \u003d\u003d Context.PRESERVE_BLOCK;\n                 if (preserveBlock) {\n                     cc.beginBlock();\n                 }\n                 boolean preferLineBreaks \u003d type \u003d\u003d Token.SCRIPT || (type \u003d\u003d Token.BLOCK \u0026\u0026 !preserveBlock \u0026\u0026 n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.SCRIPT);\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     add(c, Context.STATEMENT);\n                     if (c.getType() \u003d\u003d Token.VAR) {\n                         cc.endStatement();\n                     }\n                     if (c.getType() \u003d\u003d Token.FUNCTION) {\n                         cc.maybeLineBreak();\n                     }\n                     if (preferLineBreaks) {\n                         cc.notePreferredLineBreak();\n                     }\n                 }\n                 if (preserveBlock) {\n                     cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                 }\n                 break;\n             }\n         case Token.FOR:\n             if (childCount \u003d\u003d 4) {\n                 add(\"for(\");\n                 if (first.getType() \u003d\u003d Token.VAR) {\n                     add(first, Context.IN_FOR_INIT_CLAUSE);\n                 } else {\n                     addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                 }\n                 add(\";\");\n                 add(first.getNext());\n                 add(\";\");\n                 add(first.getNext().getNext());\n                 add(\")\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 add(\"for(\");\n                 add(first);\n                 add(\"in\");\n                 add(first.getNext());\n                 add(\")\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             }\n             break;\n         case Token.DO:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"do\");\n             addNonEmptyStatement(first, Context.OTHER, false);\n             add(\"while(\");\n             add(last);\n             add(\")\");\n             cc.endStatement();\n             break;\n         case Token.WHILE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"while(\");\n             add(first);\n             add(\")\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.EMPTY:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             break;\n         case Token.GETPROP:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                 Preconditions.checkState(last.getType() \u003d\u003d Token.STRING, \"Bad GETPROP: RHS should be STRING\");\n                 boolean needsParens \u003d (first.getType() \u003d\u003d Token.NUMBER);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 add(\".\");\n                 addIdentifier(last.getString());\n                 break;\n             }\n         case Token.GETELEM:\n             Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n             addLeftExpr(first, NodeUtil.precedence(type), context);\n             add(\"[\");\n             add(first.getNext());\n             add(\"]\");\n             break;\n         case Token.WITH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"with(\");\n             add(first);\n             add(\")\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.INC:\n         case Token.DEC:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                 int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                 if (postProp !\u003d 0) {\n                     addLeftExpr(first, NodeUtil.precedence(type), context);\n                     cc.addOp(o, false);\n                 } else {\n                     cc.addOp(o, false);\n                     add(first);\n                 }\n                 break;\n             }\n         case Token.CALL:\n             if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) \u0026\u0026 NodeUtil.isGet(first)) {\n                 add(\"(0,\");\n                 addExpr(first, NodeUtil.precedence(Token.COMMA));\n                 add(\")\");\n             } else {\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n             }\n             add(\"(\");\n             addList(first.getNext());\n             add(\")\");\n             break;\n         case Token.IF:\n             boolean hasElse \u003d childCount \u003d\u003d 3;\n             boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n             if (ambiguousElseClause) {\n                 cc.beginBlock();\n             }\n             add(\"if(\");\n             add(first);\n             add(\")\");\n             if (hasElse) {\n                 addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                 add(\"else\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n                 Preconditions.checkState(childCount \u003d\u003d 2);\n             }\n             if (ambiguousElseClause) {\n                 cc.endBlock();\n             }\n             break;\n         case Token.NULL:\n         case Token.THIS:\n         case Token.FALSE:\n         case Token.TRUE:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(Node.tokenToName(type));\n             break;\n         case Token.CONTINUE:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"continue\");\n             if (childCount \u003d\u003d 1) {\n                 if (first.getType() !\u003d Token.LABEL_NAME) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.DEBUGGER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(\"debugger\");\n             cc.endStatement();\n             break;\n         case Token.BREAK:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"break\");\n             if (childCount \u003d\u003d 1) {\n                 if (first.getType() !\u003d Token.LABEL_NAME) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.EXPR_VOID:\n             throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n         case Token.EXPR_RESULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first, Context.START_OF_EXPR);\n             cc.endStatement();\n             break;\n         case Token.NEW:\n             add(\"new \");\n             int precedence \u003d NodeUtil.precedence(type);\n             if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction())) {\n                 precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n             }\n             addExpr(first, precedence);\n             Node next \u003d first.getNext();\n             if (next !\u003d null) {\n                 add(\"(\");\n                 addList(next);\n                 add(\")\");\n             }\n             break;\n         case Token.STRING:\n-            Preconditions.checkState(childCount \u003d\u003d ((n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.OBJECTLIT) ? 1 : 0), n.getParent().toStringTree());\n+            if (childCount !\u003d ((n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.OBJECTLIT) ? 1 : 0)) {\n+                throw new IllegalStateException(\"Unexpected String children: \" + n.getParent().toStringTree());\n+            }\n             add(jsString(n.getString(), outputCharsetEncoder));\n             break;\n         case Token.DELPROP:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"delete \");\n             add(first);\n             break;\n         case Token.OBJECTLIT:\n             {\n                 boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 add(\"{\");\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     if (c !\u003d first) {\n                         cc.listSeparator();\n                     }\n                     if (c.getType() \u003d\u003d Token.STRING \u0026\u0026 !TokenStream.isKeyword(c.getString()) \u0026\u0026 TokenStream.isJSIdentifier(c.getString()) \u0026\u0026 NodeUtil.isLatin(c.getString())) {\n                         add(c.getString());\n                     } else {\n                         addExpr(c, 1);\n                     }\n                     add(\":\");\n                     addExpr(c.getFirstChild(), 1);\n                 }\n                 add(\"}\");\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 break;\n             }\n         case Token.SWITCH:\n             add(\"switch(\");\n             add(first);\n             add(\")\");\n             cc.beginBlock();\n             addAllSiblings(first.getNext());\n             cc.endBlock(context \u003d\u003d Context.STATEMENT);\n             break;\n         case Token.CASE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"case \");\n             add(first);\n             addCaseBody(last);\n             break;\n         case Token.DEFAULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"default\");\n             addCaseBody(first);\n             break;\n         case Token.LABEL:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             if (first.getType() !\u003d Token.LABEL_NAME) {\n                 throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n             }\n             add(first);\n             add(\":\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\n             break;\n         case Token.SETNAME:\n             break;\n         default:\n             throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n     }\n     cc.endSourceMapping(n);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "34fd5f8275ae69fc772c2283a3c5fd13b93a7c42": {
      "type": "Ybodychange",
      "commitMessage": "\nChange the OBJECTLIT AST structure from:\n\nOBJECTLIT\n  KEY1\n  VALUE1\n\nto\n\nOBJECTLIT\n  KEY1\n    VALUE1\n\nFixes issue 241\n\nR\u003dacleung,johnlenz,stevey\nDELTA\u003d268  (101 added, 51 deleted, 116 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d356416\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@494 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "10/18/10, 2:55 PM",
      "commitName": "34fd5f8275ae69fc772c2283a3c5fd13b93a7c42",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "10/12/10, 1:13 PM",
      "commitNameOld": "cc4824cb0e1ebc3f4fc6a8fe78f90e6bd8db6c0c",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 6.07,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "actualSource": "void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n        return;\n    }\n    int type \u003d n.getType();\n    String opstr \u003d NodeUtil.opToStr(type);\n    int childCount \u003d n.getChildCount();\n    Node first \u003d n.getFirstChild();\n    Node last \u003d n.getLastChild();\n    if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n        Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n        int p \u003d NodeUtil.precedence(type);\n        addLeftExpr(first, p, context);\n        cc.addOp(opstr, true);\n        Context rhsContext \u003d getContextForNoInOperator(context);\n        if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n            addExpr(last, p, rhsContext);\n        } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n            addExpr(last, p, rhsContext);\n        } else {\n            addExpr(last, p + 1, rhsContext);\n        }\n        return;\n    }\n    cc.startSourceMapping(n);\n    switch(type) {\n        case Token.TRY:\n            {\n                Preconditions.checkState(first.getNext().getType() \u003d\u003d Token.BLOCK \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n                Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                add(\"try\");\n                add(first, Context.PRESERVE_BLOCK);\n                Node catchblock \u003d first.getNext().getFirstChild();\n                if (catchblock !\u003d null) {\n                    add(catchblock);\n                }\n                if (childCount \u003d\u003d 3) {\n                    add(\"finally\");\n                    add(last, Context.PRESERVE_BLOCK);\n                }\n                break;\n            }\n        case Token.CATCH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"catch(\");\n            add(first);\n            add(\")\");\n            add(last, Context.PRESERVE_BLOCK);\n            break;\n        case Token.THROW:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"throw\");\n            add(first);\n            cc.endStatement(true);\n            break;\n        case Token.RETURN:\n            add(\"return\");\n            if (childCount \u003d\u003d 1) {\n                add(first);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 0);\n            }\n            cc.endStatement();\n            break;\n        case Token.VAR:\n            if (first !\u003d null) {\n                add(\"var \");\n                addList(first, false, getContextForNoInOperator(context));\n            }\n            break;\n        case Token.LABEL_NAME:\n            Preconditions.checkState(!n.getString().isEmpty());\n            addIdentifier(n.getString());\n            break;\n        case Token.NAME:\n            if (first \u003d\u003d null || first.getType() \u003d\u003d Token.EMPTY) {\n                addIdentifier(n.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                addIdentifier(n.getString());\n                cc.addOp(\"\u003d\", true);\n                if (first.getType() \u003d\u003d Token.COMMA) {\n                    addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                } else {\n                    addExpr(first, 0, getContextForNoInOperator(context));\n                }\n            }\n            break;\n        case Token.ARRAYLIT:\n            add(\"[\");\n            addList(first, (int[]) n.getProp(Node.SKIP_INDEXES_PROP));\n            add(\"]\");\n            break;\n        case Token.LP:\n            add(\"(\");\n            addList(first);\n            add(\")\");\n            break;\n        case Token.COMMA:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            addList(first, false, context);\n            break;\n        case Token.NUMBER:\n            Preconditions.checkState(childCount \u003d\u003d ((n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.OBJECTLIT) ? 1 : 0));\n            cc.addNumber(n.getDouble());\n            break;\n        case Token.TYPEOF:\n        case Token.VOID:\n        case Token.NOT:\n        case Token.BITNOT:\n        case Token.POS:\n        case Token.NEG:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                addExpr(first, NodeUtil.precedence(type));\n                break;\n            }\n        case Token.HOOK:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                int p \u003d NodeUtil.precedence(type);\n                addLeftExpr(first, p + 1, context);\n                cc.addOp(\"?\", true);\n                addExpr(first.getNext(), 1);\n                cc.addOp(\":\", true);\n                addExpr(last, 1);\n                break;\n            }\n        case Token.REGEXP:\n            if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                throw new Error(\"Expected children to be strings\");\n            }\n            String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n            if (childCount \u003d\u003d 2) {\n                add(regexp + last.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                add(regexp);\n            }\n            break;\n        case Token.GET_REF:\n            add(first);\n            break;\n        case Token.REF_SPECIAL:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first);\n            add(\".\");\n            add((String) n.getProp(Node.NAME_PROP));\n            break;\n        case Token.FUNCTION:\n            if (n.getClass() !\u003d Node.class) {\n                throw new Error(\"Unexpected Node subclass.\");\n            }\n            Preconditions.checkState(childCount \u003d\u003d 3);\n            boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n            if (funcNeedsParens) {\n                add(\"(\");\n            }\n            add(\"function\");\n            add(first);\n            add(first.getNext());\n            add(last, Context.PRESERVE_BLOCK);\n            cc.endFunction(context \u003d\u003d Context.STATEMENT);\n            if (funcNeedsParens) {\n                add(\")\");\n            }\n            break;\n        case Token.SCRIPT:\n        case Token.BLOCK:\n            {\n                if (n.getClass() !\u003d Node.class) {\n                    throw new Error(\"Unexpected Node subclass.\");\n                }\n                boolean preserveBlock \u003d context \u003d\u003d Context.PRESERVE_BLOCK;\n                if (preserveBlock) {\n                    cc.beginBlock();\n                }\n                boolean preferLineBreaks \u003d type \u003d\u003d Token.SCRIPT || (type \u003d\u003d Token.BLOCK \u0026\u0026 !preserveBlock \u0026\u0026 n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.SCRIPT);\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    add(c, Context.STATEMENT);\n                    if (c.getType() \u003d\u003d Token.VAR) {\n                        cc.endStatement();\n                    }\n                    if (c.getType() \u003d\u003d Token.FUNCTION) {\n                        cc.maybeLineBreak();\n                    }\n                    if (preferLineBreaks) {\n                        cc.notePreferredLineBreak();\n                    }\n                }\n                if (preserveBlock) {\n                    cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                }\n                break;\n            }\n        case Token.FOR:\n            if (childCount \u003d\u003d 4) {\n                add(\"for(\");\n                if (first.getType() \u003d\u003d Token.VAR) {\n                    add(first, Context.IN_FOR_INIT_CLAUSE);\n                } else {\n                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                }\n                add(\";\");\n                add(first.getNext());\n                add(\";\");\n                add(first.getNext().getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                add(\"for(\");\n                add(first);\n                add(\"in\");\n                add(first.getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            }\n            break;\n        case Token.DO:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"do\");\n            addNonEmptyStatement(first, Context.OTHER, false);\n            add(\"while(\");\n            add(last);\n            add(\")\");\n            cc.endStatement();\n            break;\n        case Token.WHILE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"while(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.EMPTY:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            break;\n        case Token.GETPROP:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                Preconditions.checkState(last.getType() \u003d\u003d Token.STRING, \"Bad GETPROP: RHS should be STRING\");\n                boolean needsParens \u003d (first.getType() \u003d\u003d Token.NUMBER);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n                if (needsParens) {\n                    add(\")\");\n                }\n                add(\".\");\n                addIdentifier(last.getString());\n                break;\n            }\n        case Token.GETELEM:\n            Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n            addLeftExpr(first, NodeUtil.precedence(type), context);\n            add(\"[\");\n            add(first.getNext());\n            add(\"]\");\n            break;\n        case Token.WITH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"with(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.INC:\n        case Token.DEC:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                if (postProp !\u003d 0) {\n                    addLeftExpr(first, NodeUtil.precedence(type), context);\n                    cc.addOp(o, false);\n                } else {\n                    cc.addOp(o, false);\n                    add(first);\n                }\n                break;\n            }\n        case Token.CALL:\n            if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) \u0026\u0026 NodeUtil.isGet(first)) {\n                add(\"(0,\");\n                addExpr(first, NodeUtil.precedence(Token.COMMA));\n                add(\")\");\n            } else {\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n            }\n            add(\"(\");\n            addList(first.getNext());\n            add(\")\");\n            break;\n        case Token.IF:\n            boolean hasElse \u003d childCount \u003d\u003d 3;\n            boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n            if (ambiguousElseClause) {\n                cc.beginBlock();\n            }\n            add(\"if(\");\n            add(first);\n            add(\")\");\n            if (hasElse) {\n                addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                add(\"else\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n                Preconditions.checkState(childCount \u003d\u003d 2);\n            }\n            if (ambiguousElseClause) {\n                cc.endBlock();\n            }\n            break;\n        case Token.NULL:\n        case Token.THIS:\n        case Token.FALSE:\n        case Token.TRUE:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(Node.tokenToName(type));\n            break;\n        case Token.CONTINUE:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"continue\");\n            if (childCount \u003d\u003d 1) {\n                if (first.getType() !\u003d Token.LABEL_NAME) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.DEBUGGER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"debugger\");\n            cc.endStatement();\n            break;\n        case Token.BREAK:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"break\");\n            if (childCount \u003d\u003d 1) {\n                if (first.getType() !\u003d Token.LABEL_NAME) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.EXPR_VOID:\n            throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n        case Token.EXPR_RESULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first, Context.START_OF_EXPR);\n            cc.endStatement();\n            break;\n        case Token.NEW:\n            add(\"new \");\n            int precedence \u003d NodeUtil.precedence(type);\n            if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction())) {\n                precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n            }\n            addExpr(first, precedence);\n            Node next \u003d first.getNext();\n            if (next !\u003d null) {\n                add(\"(\");\n                addList(next);\n                add(\")\");\n            }\n            break;\n        case Token.STRING:\n            Preconditions.checkState(childCount \u003d\u003d ((n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.OBJECTLIT) ? 1 : 0), n.getParent().toStringTree());\n            add(jsString(n.getString(), outputCharsetEncoder));\n            break;\n        case Token.DELPROP:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"delete \");\n            add(first);\n            break;\n        case Token.OBJECTLIT:\n            {\n                boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                add(\"{\");\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    if (c !\u003d first) {\n                        cc.listSeparator();\n                    }\n                    if (c.getType() \u003d\u003d Token.STRING \u0026\u0026 !TokenStream.isKeyword(c.getString()) \u0026\u0026 TokenStream.isJSIdentifier(c.getString()) \u0026\u0026 NodeUtil.isLatin(c.getString())) {\n                        add(c.getString());\n                    } else {\n                        addExpr(c, 1);\n                    }\n                    add(\":\");\n                    addExpr(c.getFirstChild(), 1);\n                }\n                add(\"}\");\n                if (needsParens) {\n                    add(\")\");\n                }\n                break;\n            }\n        case Token.SWITCH:\n            add(\"switch(\");\n            add(first);\n            add(\")\");\n            cc.beginBlock();\n            addAllSiblings(first.getNext());\n            cc.endBlock(context \u003d\u003d Context.STATEMENT);\n            break;\n        case Token.CASE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"case \");\n            add(first);\n            addCaseBody(last);\n            break;\n        case Token.DEFAULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"default\");\n            addCaseBody(first);\n            break;\n        case Token.LABEL:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            if (first.getType() !\u003d Token.LABEL_NAME) {\n                throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n            }\n            add(first);\n            add(\":\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\n            break;\n        case Token.SETNAME:\n            break;\n        default:\n            throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n    cc.endSourceMapping(n);\n}",
      "path": "src/com/google/javascript/jscomp/CodeGenerator.java",
      "functionStartLine": 75,
      "functionName": "add",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,444 +1,443 @@\n void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n         return;\n     }\n     int type \u003d n.getType();\n     String opstr \u003d NodeUtil.opToStr(type);\n     int childCount \u003d n.getChildCount();\n     Node first \u003d n.getFirstChild();\n     Node last \u003d n.getLastChild();\n     if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n         Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n         int p \u003d NodeUtil.precedence(type);\n         addLeftExpr(first, p, context);\n         cc.addOp(opstr, true);\n         Context rhsContext \u003d getContextForNoInOperator(context);\n         if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n             addExpr(last, p, rhsContext);\n         } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n             addExpr(last, p, rhsContext);\n         } else {\n             addExpr(last, p + 1, rhsContext);\n         }\n         return;\n     }\n     cc.startSourceMapping(n);\n     switch(type) {\n         case Token.TRY:\n             {\n                 Preconditions.checkState(first.getNext().getType() \u003d\u003d Token.BLOCK \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n                 Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                 add(\"try\");\n                 add(first, Context.PRESERVE_BLOCK);\n                 Node catchblock \u003d first.getNext().getFirstChild();\n                 if (catchblock !\u003d null) {\n                     add(catchblock);\n                 }\n                 if (childCount \u003d\u003d 3) {\n                     add(\"finally\");\n                     add(last, Context.PRESERVE_BLOCK);\n                 }\n                 break;\n             }\n         case Token.CATCH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"catch(\");\n             add(first);\n             add(\")\");\n             add(last, Context.PRESERVE_BLOCK);\n             break;\n         case Token.THROW:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"throw\");\n             add(first);\n             cc.endStatement(true);\n             break;\n         case Token.RETURN:\n             add(\"return\");\n             if (childCount \u003d\u003d 1) {\n                 add(first);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 0);\n             }\n             cc.endStatement();\n             break;\n         case Token.VAR:\n             if (first !\u003d null) {\n                 add(\"var \");\n                 addList(first, false, getContextForNoInOperator(context));\n             }\n             break;\n         case Token.LABEL_NAME:\n             Preconditions.checkState(!n.getString().isEmpty());\n             addIdentifier(n.getString());\n             break;\n         case Token.NAME:\n             if (first \u003d\u003d null || first.getType() \u003d\u003d Token.EMPTY) {\n                 addIdentifier(n.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 addIdentifier(n.getString());\n                 cc.addOp(\"\u003d\", true);\n                 if (first.getType() \u003d\u003d Token.COMMA) {\n                     addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                 } else {\n                     addExpr(first, 0, getContextForNoInOperator(context));\n                 }\n             }\n             break;\n         case Token.ARRAYLIT:\n             add(\"[\");\n             addList(first, (int[]) n.getProp(Node.SKIP_INDEXES_PROP));\n             add(\"]\");\n             break;\n         case Token.LP:\n             add(\"(\");\n             addList(first);\n             add(\")\");\n             break;\n         case Token.COMMA:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             addList(first, false, context);\n             break;\n         case Token.NUMBER:\n-            Preconditions.checkState(childCount \u003d\u003d 0);\n+            Preconditions.checkState(childCount \u003d\u003d ((n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.OBJECTLIT) ? 1 : 0));\n             cc.addNumber(n.getDouble());\n             break;\n         case Token.TYPEOF:\n         case Token.VOID:\n         case Token.NOT:\n         case Token.BITNOT:\n         case Token.POS:\n         case Token.NEG:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                 addExpr(first, NodeUtil.precedence(type));\n                 break;\n             }\n         case Token.HOOK:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 int p \u003d NodeUtil.precedence(type);\n                 addLeftExpr(first, p + 1, context);\n                 cc.addOp(\"?\", true);\n                 addExpr(first.getNext(), 1);\n                 cc.addOp(\":\", true);\n                 addExpr(last, 1);\n                 break;\n             }\n         case Token.REGEXP:\n             if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                 throw new Error(\"Expected children to be strings\");\n             }\n             String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n             if (childCount \u003d\u003d 2) {\n                 add(regexp + last.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 add(regexp);\n             }\n             break;\n         case Token.GET_REF:\n             add(first);\n             break;\n         case Token.REF_SPECIAL:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first);\n             add(\".\");\n             add((String) n.getProp(Node.NAME_PROP));\n             break;\n         case Token.FUNCTION:\n             if (n.getClass() !\u003d Node.class) {\n                 throw new Error(\"Unexpected Node subclass.\");\n             }\n             Preconditions.checkState(childCount \u003d\u003d 3);\n             boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n             if (funcNeedsParens) {\n                 add(\"(\");\n             }\n             add(\"function\");\n             add(first);\n             add(first.getNext());\n             add(last, Context.PRESERVE_BLOCK);\n             cc.endFunction(context \u003d\u003d Context.STATEMENT);\n             if (funcNeedsParens) {\n                 add(\")\");\n             }\n             break;\n         case Token.SCRIPT:\n         case Token.BLOCK:\n             {\n                 if (n.getClass() !\u003d Node.class) {\n                     throw new Error(\"Unexpected Node subclass.\");\n                 }\n                 boolean preserveBlock \u003d context \u003d\u003d Context.PRESERVE_BLOCK;\n                 if (preserveBlock) {\n                     cc.beginBlock();\n                 }\n                 boolean preferLineBreaks \u003d type \u003d\u003d Token.SCRIPT || (type \u003d\u003d Token.BLOCK \u0026\u0026 !preserveBlock \u0026\u0026 n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.SCRIPT);\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     add(c, Context.STATEMENT);\n                     if (c.getType() \u003d\u003d Token.VAR) {\n                         cc.endStatement();\n                     }\n                     if (c.getType() \u003d\u003d Token.FUNCTION) {\n                         cc.maybeLineBreak();\n                     }\n                     if (preferLineBreaks) {\n                         cc.notePreferredLineBreak();\n                     }\n                 }\n                 if (preserveBlock) {\n                     cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                 }\n                 break;\n             }\n         case Token.FOR:\n             if (childCount \u003d\u003d 4) {\n                 add(\"for(\");\n                 if (first.getType() \u003d\u003d Token.VAR) {\n                     add(first, Context.IN_FOR_INIT_CLAUSE);\n                 } else {\n                     addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                 }\n                 add(\";\");\n                 add(first.getNext());\n                 add(\";\");\n                 add(first.getNext().getNext());\n                 add(\")\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 add(\"for(\");\n                 add(first);\n                 add(\"in\");\n                 add(first.getNext());\n                 add(\")\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             }\n             break;\n         case Token.DO:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"do\");\n             addNonEmptyStatement(first, Context.OTHER, false);\n             add(\"while(\");\n             add(last);\n             add(\")\");\n             cc.endStatement();\n             break;\n         case Token.WHILE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"while(\");\n             add(first);\n             add(\")\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.EMPTY:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             break;\n         case Token.GETPROP:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                 Preconditions.checkState(last.getType() \u003d\u003d Token.STRING, \"Bad GETPROP: RHS should be STRING\");\n                 boolean needsParens \u003d (first.getType() \u003d\u003d Token.NUMBER);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 add(\".\");\n                 addIdentifier(last.getString());\n                 break;\n             }\n         case Token.GETELEM:\n             Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n             addLeftExpr(first, NodeUtil.precedence(type), context);\n             add(\"[\");\n             add(first.getNext());\n             add(\"]\");\n             break;\n         case Token.WITH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"with(\");\n             add(first);\n             add(\")\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.INC:\n         case Token.DEC:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                 int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                 if (postProp !\u003d 0) {\n                     addLeftExpr(first, NodeUtil.precedence(type), context);\n                     cc.addOp(o, false);\n                 } else {\n                     cc.addOp(o, false);\n                     add(first);\n                 }\n                 break;\n             }\n         case Token.CALL:\n             if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) \u0026\u0026 NodeUtil.isGet(first)) {\n                 add(\"(0,\");\n                 addExpr(first, NodeUtil.precedence(Token.COMMA));\n                 add(\")\");\n             } else {\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n             }\n             add(\"(\");\n             addList(first.getNext());\n             add(\")\");\n             break;\n         case Token.IF:\n             boolean hasElse \u003d childCount \u003d\u003d 3;\n             boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n             if (ambiguousElseClause) {\n                 cc.beginBlock();\n             }\n             add(\"if(\");\n             add(first);\n             add(\")\");\n             if (hasElse) {\n                 addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                 add(\"else\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n                 Preconditions.checkState(childCount \u003d\u003d 2);\n             }\n             if (ambiguousElseClause) {\n                 cc.endBlock();\n             }\n             break;\n         case Token.NULL:\n         case Token.THIS:\n         case Token.FALSE:\n         case Token.TRUE:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(Node.tokenToName(type));\n             break;\n         case Token.CONTINUE:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"continue\");\n             if (childCount \u003d\u003d 1) {\n                 if (first.getType() !\u003d Token.LABEL_NAME) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.DEBUGGER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(\"debugger\");\n             cc.endStatement();\n             break;\n         case Token.BREAK:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"break\");\n             if (childCount \u003d\u003d 1) {\n                 if (first.getType() !\u003d Token.LABEL_NAME) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.EXPR_VOID:\n             throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n         case Token.EXPR_RESULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first, Context.START_OF_EXPR);\n             cc.endStatement();\n             break;\n         case Token.NEW:\n             add(\"new \");\n             int precedence \u003d NodeUtil.precedence(type);\n             if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction())) {\n                 precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n             }\n             addExpr(first, precedence);\n             Node next \u003d first.getNext();\n             if (next !\u003d null) {\n                 add(\"(\");\n                 addList(next);\n                 add(\")\");\n             }\n             break;\n         case Token.STRING:\n-            Preconditions.checkState(childCount \u003d\u003d 0);\n+            Preconditions.checkState(childCount \u003d\u003d ((n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.OBJECTLIT) ? 1 : 0), n.getParent().toStringTree());\n             add(jsString(n.getString(), outputCharsetEncoder));\n             break;\n         case Token.DELPROP:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"delete \");\n             add(first);\n             break;\n         case Token.OBJECTLIT:\n             {\n-                Preconditions.checkState(childCount % 2 \u003d\u003d 0);\n                 boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 add(\"{\");\n-                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext().getNext()) {\n+                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     if (c !\u003d first) {\n                         cc.listSeparator();\n                     }\n                     if (c.getType() \u003d\u003d Token.STRING \u0026\u0026 !TokenStream.isKeyword(c.getString()) \u0026\u0026 TokenStream.isJSIdentifier(c.getString()) \u0026\u0026 NodeUtil.isLatin(c.getString())) {\n                         add(c.getString());\n                     } else {\n                         addExpr(c, 1);\n                     }\n                     add(\":\");\n-                    addExpr(c.getNext(), 1);\n+                    addExpr(c.getFirstChild(), 1);\n                 }\n                 add(\"}\");\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 break;\n             }\n         case Token.SWITCH:\n             add(\"switch(\");\n             add(first);\n             add(\")\");\n             cc.beginBlock();\n             addAllSiblings(first.getNext());\n             cc.endBlock(context \u003d\u003d Context.STATEMENT);\n             break;\n         case Token.CASE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"case \");\n             add(first);\n             addCaseBody(last);\n             break;\n         case Token.DEFAULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"default\");\n             addCaseBody(first);\n             break;\n         case Token.LABEL:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             if (first.getType() !\u003d Token.LABEL_NAME) {\n                 throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n             }\n             add(first);\n             add(\":\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\n             break;\n         case Token.SETNAME:\n             break;\n         default:\n             throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n     }\n     cc.endSourceMapping(n);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "cc4824cb0e1ebc3f4fc6a8fe78f90e6bd8db6c0c": {
      "type": "Ybodychange",
      "commitMessage": "\nbreak lines in top-level non-preserved blocks with the same\nfrequency as top-level scripts.\ni don\u0027t particularly like this change, but it makes\nthe compiler more deterministic. open to other suggestions.\n\nR\u003djohnlenz\nDELTA\u003d8  (7 added, 0 deleted, 1 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d324212\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@483 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "10/12/10, 1:13 PM",
      "commitName": "cc4824cb0e1ebc3f4fc6a8fe78f90e6bd8db6c0c",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "9/13/10, 11:12 AM",
      "commitNameOld": "4c6e1039b80859f17de5f3cbcfeba61ed8ea0485",
      "commitAuthorOld": "elbaum@google.com",
      "daysBetweenCommits": 29.08,
      "commitsBetweenForRepo": 58,
      "commitsBetweenForFile": 1,
      "actualSource": "void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n        return;\n    }\n    int type \u003d n.getType();\n    String opstr \u003d NodeUtil.opToStr(type);\n    int childCount \u003d n.getChildCount();\n    Node first \u003d n.getFirstChild();\n    Node last \u003d n.getLastChild();\n    if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n        Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n        int p \u003d NodeUtil.precedence(type);\n        addLeftExpr(first, p, context);\n        cc.addOp(opstr, true);\n        Context rhsContext \u003d getContextForNoInOperator(context);\n        if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n            addExpr(last, p, rhsContext);\n        } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n            addExpr(last, p, rhsContext);\n        } else {\n            addExpr(last, p + 1, rhsContext);\n        }\n        return;\n    }\n    cc.startSourceMapping(n);\n    switch(type) {\n        case Token.TRY:\n            {\n                Preconditions.checkState(first.getNext().getType() \u003d\u003d Token.BLOCK \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n                Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                add(\"try\");\n                add(first, Context.PRESERVE_BLOCK);\n                Node catchblock \u003d first.getNext().getFirstChild();\n                if (catchblock !\u003d null) {\n                    add(catchblock);\n                }\n                if (childCount \u003d\u003d 3) {\n                    add(\"finally\");\n                    add(last, Context.PRESERVE_BLOCK);\n                }\n                break;\n            }\n        case Token.CATCH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"catch(\");\n            add(first);\n            add(\")\");\n            add(last, Context.PRESERVE_BLOCK);\n            break;\n        case Token.THROW:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"throw\");\n            add(first);\n            cc.endStatement(true);\n            break;\n        case Token.RETURN:\n            add(\"return\");\n            if (childCount \u003d\u003d 1) {\n                add(first);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 0);\n            }\n            cc.endStatement();\n            break;\n        case Token.VAR:\n            if (first !\u003d null) {\n                add(\"var \");\n                addList(first, false, getContextForNoInOperator(context));\n            }\n            break;\n        case Token.LABEL_NAME:\n            Preconditions.checkState(!n.getString().isEmpty());\n            addIdentifier(n.getString());\n            break;\n        case Token.NAME:\n            if (first \u003d\u003d null || first.getType() \u003d\u003d Token.EMPTY) {\n                addIdentifier(n.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                addIdentifier(n.getString());\n                cc.addOp(\"\u003d\", true);\n                if (first.getType() \u003d\u003d Token.COMMA) {\n                    addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                } else {\n                    addExpr(first, 0, getContextForNoInOperator(context));\n                }\n            }\n            break;\n        case Token.ARRAYLIT:\n            add(\"[\");\n            addList(first, (int[]) n.getProp(Node.SKIP_INDEXES_PROP));\n            add(\"]\");\n            break;\n        case Token.LP:\n            add(\"(\");\n            addList(first);\n            add(\")\");\n            break;\n        case Token.COMMA:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            addList(first, false, context);\n            break;\n        case Token.NUMBER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            cc.addNumber(n.getDouble());\n            break;\n        case Token.TYPEOF:\n        case Token.VOID:\n        case Token.NOT:\n        case Token.BITNOT:\n        case Token.POS:\n        case Token.NEG:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                addExpr(first, NodeUtil.precedence(type));\n                break;\n            }\n        case Token.HOOK:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                int p \u003d NodeUtil.precedence(type);\n                addLeftExpr(first, p + 1, context);\n                cc.addOp(\"?\", true);\n                addExpr(first.getNext(), 1);\n                cc.addOp(\":\", true);\n                addExpr(last, 1);\n                break;\n            }\n        case Token.REGEXP:\n            if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                throw new Error(\"Expected children to be strings\");\n            }\n            String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n            if (childCount \u003d\u003d 2) {\n                add(regexp + last.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                add(regexp);\n            }\n            break;\n        case Token.GET_REF:\n            add(first);\n            break;\n        case Token.REF_SPECIAL:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first);\n            add(\".\");\n            add((String) n.getProp(Node.NAME_PROP));\n            break;\n        case Token.FUNCTION:\n            if (n.getClass() !\u003d Node.class) {\n                throw new Error(\"Unexpected Node subclass.\");\n            }\n            Preconditions.checkState(childCount \u003d\u003d 3);\n            boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n            if (funcNeedsParens) {\n                add(\"(\");\n            }\n            add(\"function\");\n            add(first);\n            add(first.getNext());\n            add(last, Context.PRESERVE_BLOCK);\n            cc.endFunction(context \u003d\u003d Context.STATEMENT);\n            if (funcNeedsParens) {\n                add(\")\");\n            }\n            break;\n        case Token.SCRIPT:\n        case Token.BLOCK:\n            {\n                if (n.getClass() !\u003d Node.class) {\n                    throw new Error(\"Unexpected Node subclass.\");\n                }\n                boolean preserveBlock \u003d context \u003d\u003d Context.PRESERVE_BLOCK;\n                if (preserveBlock) {\n                    cc.beginBlock();\n                }\n                boolean preferLineBreaks \u003d type \u003d\u003d Token.SCRIPT || (type \u003d\u003d Token.BLOCK \u0026\u0026 !preserveBlock \u0026\u0026 n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.SCRIPT);\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    add(c, Context.STATEMENT);\n                    if (c.getType() \u003d\u003d Token.VAR) {\n                        cc.endStatement();\n                    }\n                    if (c.getType() \u003d\u003d Token.FUNCTION) {\n                        cc.maybeLineBreak();\n                    }\n                    if (preferLineBreaks) {\n                        cc.notePreferredLineBreak();\n                    }\n                }\n                if (preserveBlock) {\n                    cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                }\n                break;\n            }\n        case Token.FOR:\n            if (childCount \u003d\u003d 4) {\n                add(\"for(\");\n                if (first.getType() \u003d\u003d Token.VAR) {\n                    add(first, Context.IN_FOR_INIT_CLAUSE);\n                } else {\n                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                }\n                add(\";\");\n                add(first.getNext());\n                add(\";\");\n                add(first.getNext().getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                add(\"for(\");\n                add(first);\n                add(\"in\");\n                add(first.getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            }\n            break;\n        case Token.DO:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"do\");\n            addNonEmptyStatement(first, Context.OTHER, false);\n            add(\"while(\");\n            add(last);\n            add(\")\");\n            cc.endStatement();\n            break;\n        case Token.WHILE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"while(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.EMPTY:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            break;\n        case Token.GETPROP:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                Preconditions.checkState(last.getType() \u003d\u003d Token.STRING, \"Bad GETPROP: RHS should be STRING\");\n                boolean needsParens \u003d (first.getType() \u003d\u003d Token.NUMBER);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n                if (needsParens) {\n                    add(\")\");\n                }\n                add(\".\");\n                addIdentifier(last.getString());\n                break;\n            }\n        case Token.GETELEM:\n            Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n            addLeftExpr(first, NodeUtil.precedence(type), context);\n            add(\"[\");\n            add(first.getNext());\n            add(\"]\");\n            break;\n        case Token.WITH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"with(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.INC:\n        case Token.DEC:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                if (postProp !\u003d 0) {\n                    addLeftExpr(first, NodeUtil.precedence(type), context);\n                    cc.addOp(o, false);\n                } else {\n                    cc.addOp(o, false);\n                    add(first);\n                }\n                break;\n            }\n        case Token.CALL:\n            if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) \u0026\u0026 NodeUtil.isGet(first)) {\n                add(\"(0,\");\n                addExpr(first, NodeUtil.precedence(Token.COMMA));\n                add(\")\");\n            } else {\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n            }\n            add(\"(\");\n            addList(first.getNext());\n            add(\")\");\n            break;\n        case Token.IF:\n            boolean hasElse \u003d childCount \u003d\u003d 3;\n            boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n            if (ambiguousElseClause) {\n                cc.beginBlock();\n            }\n            add(\"if(\");\n            add(first);\n            add(\")\");\n            if (hasElse) {\n                addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                add(\"else\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n                Preconditions.checkState(childCount \u003d\u003d 2);\n            }\n            if (ambiguousElseClause) {\n                cc.endBlock();\n            }\n            break;\n        case Token.NULL:\n        case Token.THIS:\n        case Token.FALSE:\n        case Token.TRUE:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(Node.tokenToName(type));\n            break;\n        case Token.CONTINUE:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"continue\");\n            if (childCount \u003d\u003d 1) {\n                if (first.getType() !\u003d Token.LABEL_NAME) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.DEBUGGER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"debugger\");\n            cc.endStatement();\n            break;\n        case Token.BREAK:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"break\");\n            if (childCount \u003d\u003d 1) {\n                if (first.getType() !\u003d Token.LABEL_NAME) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.EXPR_VOID:\n            throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n        case Token.EXPR_RESULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first, Context.START_OF_EXPR);\n            cc.endStatement();\n            break;\n        case Token.NEW:\n            add(\"new \");\n            int precedence \u003d NodeUtil.precedence(type);\n            if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction())) {\n                precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n            }\n            addExpr(first, precedence);\n            Node next \u003d first.getNext();\n            if (next !\u003d null) {\n                add(\"(\");\n                addList(next);\n                add(\")\");\n            }\n            break;\n        case Token.STRING:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(jsString(n.getString(), outputCharsetEncoder));\n            break;\n        case Token.DELPROP:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"delete \");\n            add(first);\n            break;\n        case Token.OBJECTLIT:\n            {\n                Preconditions.checkState(childCount % 2 \u003d\u003d 0);\n                boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                add(\"{\");\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext().getNext()) {\n                    if (c !\u003d first) {\n                        cc.listSeparator();\n                    }\n                    if (c.getType() \u003d\u003d Token.STRING \u0026\u0026 !TokenStream.isKeyword(c.getString()) \u0026\u0026 TokenStream.isJSIdentifier(c.getString()) \u0026\u0026 NodeUtil.isLatin(c.getString())) {\n                        add(c.getString());\n                    } else {\n                        addExpr(c, 1);\n                    }\n                    add(\":\");\n                    addExpr(c.getNext(), 1);\n                }\n                add(\"}\");\n                if (needsParens) {\n                    add(\")\");\n                }\n                break;\n            }\n        case Token.SWITCH:\n            add(\"switch(\");\n            add(first);\n            add(\")\");\n            cc.beginBlock();\n            addAllSiblings(first.getNext());\n            cc.endBlock(context \u003d\u003d Context.STATEMENT);\n            break;\n        case Token.CASE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"case \");\n            add(first);\n            addCaseBody(last);\n            break;\n        case Token.DEFAULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"default\");\n            addCaseBody(first);\n            break;\n        case Token.LABEL:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            if (first.getType() !\u003d Token.LABEL_NAME) {\n                throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n            }\n            add(first);\n            add(\":\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\n            break;\n        case Token.SETNAME:\n            break;\n        default:\n            throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n    cc.endSourceMapping(n);\n}",
      "path": "src/com/google/javascript/jscomp/CodeGenerator.java",
      "functionStartLine": 75,
      "functionName": "add",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,443 +1,444 @@\n void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n         return;\n     }\n     int type \u003d n.getType();\n     String opstr \u003d NodeUtil.opToStr(type);\n     int childCount \u003d n.getChildCount();\n     Node first \u003d n.getFirstChild();\n     Node last \u003d n.getLastChild();\n     if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n         Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n         int p \u003d NodeUtil.precedence(type);\n         addLeftExpr(first, p, context);\n         cc.addOp(opstr, true);\n         Context rhsContext \u003d getContextForNoInOperator(context);\n         if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n             addExpr(last, p, rhsContext);\n         } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n             addExpr(last, p, rhsContext);\n         } else {\n             addExpr(last, p + 1, rhsContext);\n         }\n         return;\n     }\n     cc.startSourceMapping(n);\n     switch(type) {\n         case Token.TRY:\n             {\n                 Preconditions.checkState(first.getNext().getType() \u003d\u003d Token.BLOCK \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n                 Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                 add(\"try\");\n                 add(first, Context.PRESERVE_BLOCK);\n                 Node catchblock \u003d first.getNext().getFirstChild();\n                 if (catchblock !\u003d null) {\n                     add(catchblock);\n                 }\n                 if (childCount \u003d\u003d 3) {\n                     add(\"finally\");\n                     add(last, Context.PRESERVE_BLOCK);\n                 }\n                 break;\n             }\n         case Token.CATCH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"catch(\");\n             add(first);\n             add(\")\");\n             add(last, Context.PRESERVE_BLOCK);\n             break;\n         case Token.THROW:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"throw\");\n             add(first);\n             cc.endStatement(true);\n             break;\n         case Token.RETURN:\n             add(\"return\");\n             if (childCount \u003d\u003d 1) {\n                 add(first);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 0);\n             }\n             cc.endStatement();\n             break;\n         case Token.VAR:\n             if (first !\u003d null) {\n                 add(\"var \");\n                 addList(first, false, getContextForNoInOperator(context));\n             }\n             break;\n         case Token.LABEL_NAME:\n             Preconditions.checkState(!n.getString().isEmpty());\n             addIdentifier(n.getString());\n             break;\n         case Token.NAME:\n             if (first \u003d\u003d null || first.getType() \u003d\u003d Token.EMPTY) {\n                 addIdentifier(n.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 addIdentifier(n.getString());\n                 cc.addOp(\"\u003d\", true);\n                 if (first.getType() \u003d\u003d Token.COMMA) {\n                     addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                 } else {\n                     addExpr(first, 0, getContextForNoInOperator(context));\n                 }\n             }\n             break;\n         case Token.ARRAYLIT:\n             add(\"[\");\n             addList(first, (int[]) n.getProp(Node.SKIP_INDEXES_PROP));\n             add(\"]\");\n             break;\n         case Token.LP:\n             add(\"(\");\n             addList(first);\n             add(\")\");\n             break;\n         case Token.COMMA:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             addList(first, false, context);\n             break;\n         case Token.NUMBER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             cc.addNumber(n.getDouble());\n             break;\n         case Token.TYPEOF:\n         case Token.VOID:\n         case Token.NOT:\n         case Token.BITNOT:\n         case Token.POS:\n         case Token.NEG:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                 addExpr(first, NodeUtil.precedence(type));\n                 break;\n             }\n         case Token.HOOK:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 int p \u003d NodeUtil.precedence(type);\n                 addLeftExpr(first, p + 1, context);\n                 cc.addOp(\"?\", true);\n                 addExpr(first.getNext(), 1);\n                 cc.addOp(\":\", true);\n                 addExpr(last, 1);\n                 break;\n             }\n         case Token.REGEXP:\n             if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                 throw new Error(\"Expected children to be strings\");\n             }\n             String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n             if (childCount \u003d\u003d 2) {\n                 add(regexp + last.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 add(regexp);\n             }\n             break;\n         case Token.GET_REF:\n             add(first);\n             break;\n         case Token.REF_SPECIAL:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first);\n             add(\".\");\n             add((String) n.getProp(Node.NAME_PROP));\n             break;\n         case Token.FUNCTION:\n             if (n.getClass() !\u003d Node.class) {\n                 throw new Error(\"Unexpected Node subclass.\");\n             }\n             Preconditions.checkState(childCount \u003d\u003d 3);\n             boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n             if (funcNeedsParens) {\n                 add(\"(\");\n             }\n             add(\"function\");\n             add(first);\n             add(first.getNext());\n             add(last, Context.PRESERVE_BLOCK);\n             cc.endFunction(context \u003d\u003d Context.STATEMENT);\n             if (funcNeedsParens) {\n                 add(\")\");\n             }\n             break;\n         case Token.SCRIPT:\n         case Token.BLOCK:\n             {\n                 if (n.getClass() !\u003d Node.class) {\n                     throw new Error(\"Unexpected Node subclass.\");\n                 }\n                 boolean preserveBlock \u003d context \u003d\u003d Context.PRESERVE_BLOCK;\n                 if (preserveBlock) {\n                     cc.beginBlock();\n                 }\n+                boolean preferLineBreaks \u003d type \u003d\u003d Token.SCRIPT || (type \u003d\u003d Token.BLOCK \u0026\u0026 !preserveBlock \u0026\u0026 n.getParent() !\u003d null \u0026\u0026 n.getParent().getType() \u003d\u003d Token.SCRIPT);\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     add(c, Context.STATEMENT);\n                     if (c.getType() \u003d\u003d Token.VAR) {\n                         cc.endStatement();\n                     }\n                     if (c.getType() \u003d\u003d Token.FUNCTION) {\n                         cc.maybeLineBreak();\n                     }\n-                    if (type \u003d\u003d Token.SCRIPT) {\n+                    if (preferLineBreaks) {\n                         cc.notePreferredLineBreak();\n                     }\n                 }\n                 if (preserveBlock) {\n                     cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                 }\n                 break;\n             }\n         case Token.FOR:\n             if (childCount \u003d\u003d 4) {\n                 add(\"for(\");\n                 if (first.getType() \u003d\u003d Token.VAR) {\n                     add(first, Context.IN_FOR_INIT_CLAUSE);\n                 } else {\n                     addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                 }\n                 add(\";\");\n                 add(first.getNext());\n                 add(\";\");\n                 add(first.getNext().getNext());\n                 add(\")\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 add(\"for(\");\n                 add(first);\n                 add(\"in\");\n                 add(first.getNext());\n                 add(\")\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             }\n             break;\n         case Token.DO:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"do\");\n             addNonEmptyStatement(first, Context.OTHER, false);\n             add(\"while(\");\n             add(last);\n             add(\")\");\n             cc.endStatement();\n             break;\n         case Token.WHILE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"while(\");\n             add(first);\n             add(\")\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.EMPTY:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             break;\n         case Token.GETPROP:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                 Preconditions.checkState(last.getType() \u003d\u003d Token.STRING, \"Bad GETPROP: RHS should be STRING\");\n                 boolean needsParens \u003d (first.getType() \u003d\u003d Token.NUMBER);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 add(\".\");\n                 addIdentifier(last.getString());\n                 break;\n             }\n         case Token.GETELEM:\n             Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n             addLeftExpr(first, NodeUtil.precedence(type), context);\n             add(\"[\");\n             add(first.getNext());\n             add(\"]\");\n             break;\n         case Token.WITH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"with(\");\n             add(first);\n             add(\")\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.INC:\n         case Token.DEC:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                 int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                 if (postProp !\u003d 0) {\n                     addLeftExpr(first, NodeUtil.precedence(type), context);\n                     cc.addOp(o, false);\n                 } else {\n                     cc.addOp(o, false);\n                     add(first);\n                 }\n                 break;\n             }\n         case Token.CALL:\n             if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) \u0026\u0026 NodeUtil.isGet(first)) {\n                 add(\"(0,\");\n                 addExpr(first, NodeUtil.precedence(Token.COMMA));\n                 add(\")\");\n             } else {\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n             }\n             add(\"(\");\n             addList(first.getNext());\n             add(\")\");\n             break;\n         case Token.IF:\n             boolean hasElse \u003d childCount \u003d\u003d 3;\n             boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n             if (ambiguousElseClause) {\n                 cc.beginBlock();\n             }\n             add(\"if(\");\n             add(first);\n             add(\")\");\n             if (hasElse) {\n                 addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                 add(\"else\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n                 Preconditions.checkState(childCount \u003d\u003d 2);\n             }\n             if (ambiguousElseClause) {\n                 cc.endBlock();\n             }\n             break;\n         case Token.NULL:\n         case Token.THIS:\n         case Token.FALSE:\n         case Token.TRUE:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(Node.tokenToName(type));\n             break;\n         case Token.CONTINUE:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"continue\");\n             if (childCount \u003d\u003d 1) {\n                 if (first.getType() !\u003d Token.LABEL_NAME) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.DEBUGGER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(\"debugger\");\n             cc.endStatement();\n             break;\n         case Token.BREAK:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"break\");\n             if (childCount \u003d\u003d 1) {\n                 if (first.getType() !\u003d Token.LABEL_NAME) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.EXPR_VOID:\n             throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n         case Token.EXPR_RESULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first, Context.START_OF_EXPR);\n             cc.endStatement();\n             break;\n         case Token.NEW:\n             add(\"new \");\n             int precedence \u003d NodeUtil.precedence(type);\n             if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction())) {\n                 precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n             }\n             addExpr(first, precedence);\n             Node next \u003d first.getNext();\n             if (next !\u003d null) {\n                 add(\"(\");\n                 addList(next);\n                 add(\")\");\n             }\n             break;\n         case Token.STRING:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(jsString(n.getString(), outputCharsetEncoder));\n             break;\n         case Token.DELPROP:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"delete \");\n             add(first);\n             break;\n         case Token.OBJECTLIT:\n             {\n                 Preconditions.checkState(childCount % 2 \u003d\u003d 0);\n                 boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 add(\"{\");\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext().getNext()) {\n                     if (c !\u003d first) {\n                         cc.listSeparator();\n                     }\n                     if (c.getType() \u003d\u003d Token.STRING \u0026\u0026 !TokenStream.isKeyword(c.getString()) \u0026\u0026 TokenStream.isJSIdentifier(c.getString()) \u0026\u0026 NodeUtil.isLatin(c.getString())) {\n                         add(c.getString());\n                     } else {\n                         addExpr(c, 1);\n                     }\n                     add(\":\");\n                     addExpr(c.getNext(), 1);\n                 }\n                 add(\"}\");\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 break;\n             }\n         case Token.SWITCH:\n             add(\"switch(\");\n             add(first);\n             add(\")\");\n             cc.beginBlock();\n             addAllSiblings(first.getNext());\n             cc.endBlock(context \u003d\u003d Context.STATEMENT);\n             break;\n         case Token.CASE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"case \");\n             add(first);\n             addCaseBody(last);\n             break;\n         case Token.DEFAULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"default\");\n             addCaseBody(first);\n             break;\n         case Token.LABEL:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             if (first.getType() !\u003d Token.LABEL_NAME) {\n                 throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n             }\n             add(first);\n             add(\":\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\n             break;\n         case Token.SETNAME:\n             break;\n         default:\n             throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n     }\n     cc.endSourceMapping(n);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6d8fd424925b186d720112e4f14e6898386a66b0": {
      "type": "Ybodychange",
      "commitMessage": "\nFix the CATCH tree structure.\n\nR\u003djohnlenz,dhans\nDELTA\u003d341  (5 added, 116 deleted, 220 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d211729\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@415 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "9/9/10, 2:49 PM",
      "commitName": "6d8fd424925b186d720112e4f14e6898386a66b0",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "9/8/10, 11:48 AM",
      "commitNameOld": "f0e3cbc250fd9536ff92119bdf5e1a62120a7fac",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 1.13,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n        return;\n    }\n    int type \u003d n.getType();\n    String opstr \u003d NodeUtil.opToStr(type);\n    int childCount \u003d n.getChildCount();\n    Node first \u003d n.getFirstChild();\n    Node last \u003d n.getLastChild();\n    if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n        Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n        int p \u003d NodeUtil.precedence(type);\n        addLeftExpr(first, p, context);\n        cc.addOp(opstr, true);\n        Context rhsContext \u003d getContextForNoInOperator(context);\n        if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n            addExpr(last, p, rhsContext);\n        } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n            addExpr(last, p, rhsContext);\n        } else {\n            addExpr(last, p + 1, rhsContext);\n        }\n        return;\n    }\n    cc.startSourceMapping(n);\n    switch(type) {\n        case Token.TRY:\n            {\n                Preconditions.checkState(first.getNext().getType() \u003d\u003d Token.BLOCK \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n                Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                add(\"try\");\n                add(first, Context.PRESERVE_BLOCK);\n                Node catchblock \u003d first.getNext().getFirstChild();\n                if (catchblock !\u003d null) {\n                    add(catchblock);\n                }\n                if (childCount \u003d\u003d 3) {\n                    add(\"finally\");\n                    add(last, Context.PRESERVE_BLOCK);\n                }\n                break;\n            }\n        case Token.CATCH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"catch(\");\n            add(first);\n            add(\")\");\n            add(last, Context.PRESERVE_BLOCK);\n            break;\n        case Token.THROW:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"throw\");\n            add(first);\n            cc.endStatement(true);\n            break;\n        case Token.RETURN:\n            add(\"return\");\n            if (childCount \u003d\u003d 1) {\n                add(first);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 0);\n            }\n            cc.endStatement();\n            break;\n        case Token.VAR:\n            if (first !\u003d null) {\n                add(\"var \");\n                addList(first, false, getContextForNoInOperator(context));\n            }\n            break;\n        case Token.LABEL_NAME:\n            Preconditions.checkState(!n.getString().isEmpty());\n            addIdentifier(n.getString());\n            break;\n        case Token.NAME:\n            if (first \u003d\u003d null || first.getType() \u003d\u003d Token.EMPTY) {\n                addIdentifier(n.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                addIdentifier(n.getString());\n                cc.addOp(\"\u003d\", true);\n                if (first.getType() \u003d\u003d Token.COMMA) {\n                    addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                } else {\n                    addExpr(first, 0, getContextForNoInOperator(context));\n                }\n            }\n            break;\n        case Token.ARRAYLIT:\n            add(\"[\");\n            addList(first, (int[]) n.getProp(Node.SKIP_INDEXES_PROP));\n            add(\"]\");\n            break;\n        case Token.LP:\n            add(\"(\");\n            addList(first);\n            add(\")\");\n            break;\n        case Token.COMMA:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            addList(first, false, context);\n            break;\n        case Token.NUMBER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            cc.addNumber(n.getDouble());\n            break;\n        case Token.TYPEOF:\n        case Token.VOID:\n        case Token.NOT:\n        case Token.BITNOT:\n        case Token.POS:\n        case Token.NEG:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                addExpr(first, NodeUtil.precedence(type));\n                break;\n            }\n        case Token.HOOK:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                int p \u003d NodeUtil.precedence(type);\n                addLeftExpr(first, p + 1, context);\n                cc.addOp(\"?\", true);\n                addExpr(first.getNext(), 1);\n                cc.addOp(\":\", true);\n                addExpr(last, 1);\n                break;\n            }\n        case Token.REGEXP:\n            if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                throw new Error(\"Expected children to be strings\");\n            }\n            String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n            if (childCount \u003d\u003d 2) {\n                add(regexp + last.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                add(regexp);\n            }\n            break;\n        case Token.GET_REF:\n            add(first);\n            break;\n        case Token.REF_SPECIAL:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first);\n            add(\".\");\n            add((String) n.getProp(Node.NAME_PROP));\n            break;\n        case Token.FUNCTION:\n            if (n.getClass() !\u003d Node.class) {\n                throw new Error(\"Unexpected Node subclass.\");\n            }\n            Preconditions.checkState(childCount \u003d\u003d 3);\n            boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n            if (funcNeedsParens) {\n                add(\"(\");\n            }\n            add(\"function\");\n            add(first);\n            add(first.getNext());\n            add(last, Context.PRESERVE_BLOCK);\n            cc.endFunction(context \u003d\u003d Context.STATEMENT);\n            if (funcNeedsParens) {\n                add(\")\");\n            }\n            break;\n        case Token.SCRIPT:\n        case Token.BLOCK:\n            {\n                if (n.getClass() !\u003d Node.class) {\n                    throw new Error(\"Unexpected Node subclass.\");\n                }\n                boolean preserveBlock \u003d context \u003d\u003d Context.PRESERVE_BLOCK;\n                if (preserveBlock) {\n                    cc.beginBlock();\n                }\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    add(c, Context.STATEMENT);\n                    if (c.getType() \u003d\u003d Token.VAR) {\n                        cc.endStatement();\n                    }\n                    if (c.getType() \u003d\u003d Token.FUNCTION) {\n                        cc.maybeLineBreak();\n                    }\n                    if (type \u003d\u003d Token.SCRIPT) {\n                        cc.notePreferredLineBreak();\n                    }\n                }\n                if (preserveBlock) {\n                    cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                }\n                break;\n            }\n        case Token.FOR:\n            if (childCount \u003d\u003d 4) {\n                add(\"for(\");\n                if (first.getType() \u003d\u003d Token.VAR) {\n                    add(first, Context.IN_FOR_INIT_CLAUSE);\n                } else {\n                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                }\n                add(\";\");\n                add(first.getNext());\n                add(\";\");\n                add(first.getNext().getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                add(\"for(\");\n                add(first);\n                add(\"in\");\n                add(first.getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            }\n            break;\n        case Token.DO:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"do\");\n            addNonEmptyStatement(first, Context.OTHER, false);\n            add(\"while(\");\n            add(last);\n            add(\")\");\n            cc.endStatement();\n            break;\n        case Token.WHILE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"while(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.EMPTY:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            break;\n        case Token.GETPROP:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                Preconditions.checkState(last.getType() \u003d\u003d Token.STRING, \"Bad GETPROP: RHS should be STRING\");\n                boolean needsParens \u003d (first.getType() \u003d\u003d Token.NUMBER);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n                if (needsParens) {\n                    add(\")\");\n                }\n                add(\".\");\n                addIdentifier(last.getString());\n                break;\n            }\n        case Token.GETELEM:\n            Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n            addLeftExpr(first, NodeUtil.precedence(type), context);\n            add(\"[\");\n            add(first.getNext());\n            add(\"]\");\n            break;\n        case Token.WITH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"with(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.INC:\n        case Token.DEC:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                if (postProp !\u003d 0) {\n                    addLeftExpr(first, NodeUtil.precedence(type), context);\n                    cc.addOp(o, false);\n                } else {\n                    cc.addOp(o, false);\n                    add(first);\n                }\n                break;\n            }\n        case Token.CALL:\n            if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) \u0026\u0026 NodeUtil.isGet(first)) {\n                add(\"(0,\");\n                addExpr(first, NodeUtil.precedence(Token.COMMA));\n                add(\")\");\n            } else {\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n            }\n            add(\"(\");\n            addList(first.getNext());\n            add(\")\");\n            break;\n        case Token.IF:\n            boolean hasElse \u003d childCount \u003d\u003d 3;\n            boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n            if (ambiguousElseClause) {\n                cc.beginBlock();\n            }\n            add(\"if(\");\n            add(first);\n            add(\")\");\n            if (hasElse) {\n                addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                add(\"else\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n                Preconditions.checkState(childCount \u003d\u003d 2);\n            }\n            if (ambiguousElseClause) {\n                cc.endBlock();\n            }\n            break;\n        case Token.NULL:\n        case Token.THIS:\n        case Token.FALSE:\n        case Token.TRUE:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(Node.tokenToName(type));\n            break;\n        case Token.CONTINUE:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"continue\");\n            if (childCount \u003d\u003d 1) {\n                if (first.getType() !\u003d Token.LABEL_NAME) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.DEBUGGER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"debugger\");\n            cc.endStatement();\n            break;\n        case Token.BREAK:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"break\");\n            if (childCount \u003d\u003d 1) {\n                if (first.getType() !\u003d Token.LABEL_NAME) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.EXPR_VOID:\n            throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n        case Token.EXPR_RESULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first, Context.START_OF_EXPR);\n            cc.endStatement();\n            break;\n        case Token.NEW:\n            add(\"new \");\n            int precedence \u003d NodeUtil.precedence(type);\n            if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction())) {\n                precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n            }\n            addExpr(first, precedence);\n            Node next \u003d first.getNext();\n            if (next !\u003d null) {\n                add(\"(\");\n                addList(next);\n                add(\")\");\n            }\n            break;\n        case Token.STRING:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(jsString(n.getString(), outputCharsetEncoder));\n            break;\n        case Token.DELPROP:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"delete \");\n            add(first);\n            break;\n        case Token.OBJECTLIT:\n            {\n                Preconditions.checkState(childCount % 2 \u003d\u003d 0);\n                boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                add(\"{\");\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext().getNext()) {\n                    if (c !\u003d first) {\n                        cc.listSeparator();\n                    }\n                    if (c.getType() \u003d\u003d Token.STRING \u0026\u0026 !TokenStream.isKeyword(c.getString()) \u0026\u0026 TokenStream.isJSIdentifier(c.getString()) \u0026\u0026 NodeUtil.isLatin(c.getString())) {\n                        add(c.getString());\n                    } else {\n                        addExpr(c, 1);\n                    }\n                    add(\":\");\n                    addExpr(c.getNext(), 1);\n                }\n                add(\"}\");\n                if (needsParens) {\n                    add(\")\");\n                }\n                break;\n            }\n        case Token.SWITCH:\n            add(\"switch(\");\n            add(first);\n            add(\")\");\n            cc.beginBlock();\n            addAllSiblings(first.getNext());\n            cc.endBlock(context \u003d\u003d Context.STATEMENT);\n            break;\n        case Token.CASE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"case \");\n            add(first);\n            addCaseBody(last);\n            break;\n        case Token.DEFAULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"default\");\n            addCaseBody(first);\n            break;\n        case Token.LABEL:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            if (first.getType() !\u003d Token.LABEL_NAME) {\n                throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n            }\n            add(first);\n            add(\":\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\n            break;\n        case Token.SETNAME:\n            break;\n        default:\n            throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n    cc.endSourceMapping(n);\n}",
      "path": "src/com/google/javascript/jscomp/CodeGenerator.java",
      "functionStartLine": 77,
      "functionName": "add",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,446 +1,443 @@\n void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n         return;\n     }\n     int type \u003d n.getType();\n     String opstr \u003d NodeUtil.opToStr(type);\n     int childCount \u003d n.getChildCount();\n     Node first \u003d n.getFirstChild();\n     Node last \u003d n.getLastChild();\n     if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n         Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n         int p \u003d NodeUtil.precedence(type);\n         addLeftExpr(first, p, context);\n         cc.addOp(opstr, true);\n         Context rhsContext \u003d getContextForNoInOperator(context);\n         if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n             addExpr(last, p, rhsContext);\n         } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n             addExpr(last, p, rhsContext);\n         } else {\n             addExpr(last, p + 1, rhsContext);\n         }\n         return;\n     }\n     cc.startSourceMapping(n);\n     switch(type) {\n         case Token.TRY:\n             {\n                 Preconditions.checkState(first.getNext().getType() \u003d\u003d Token.BLOCK \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n                 Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                 add(\"try\");\n                 add(first, Context.PRESERVE_BLOCK);\n                 Node catchblock \u003d first.getNext().getFirstChild();\n                 if (catchblock !\u003d null) {\n                     add(catchblock);\n                 }\n                 if (childCount \u003d\u003d 3) {\n                     add(\"finally\");\n                     add(last, Context.PRESERVE_BLOCK);\n                 }\n                 break;\n             }\n         case Token.CATCH:\n-            Preconditions.checkState(childCount \u003d\u003d 3);\n-            if (first.getNext().getType() !\u003d Token.EMPTY) {\n-                throw new Error(\"Catch conditions not suppored because I think\" + \" that it may be a netscape only feature.\");\n-            }\n+            Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"catch(\");\n             add(first);\n             add(\")\");\n             add(last, Context.PRESERVE_BLOCK);\n             break;\n         case Token.THROW:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"throw\");\n             add(first);\n             cc.endStatement(true);\n             break;\n         case Token.RETURN:\n             add(\"return\");\n             if (childCount \u003d\u003d 1) {\n                 add(first);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 0);\n             }\n             cc.endStatement();\n             break;\n         case Token.VAR:\n             if (first !\u003d null) {\n                 add(\"var \");\n                 addList(first, false, getContextForNoInOperator(context));\n             }\n             break;\n         case Token.LABEL_NAME:\n             Preconditions.checkState(!n.getString().isEmpty());\n             addIdentifier(n.getString());\n             break;\n         case Token.NAME:\n             if (first \u003d\u003d null || first.getType() \u003d\u003d Token.EMPTY) {\n                 addIdentifier(n.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 addIdentifier(n.getString());\n                 cc.addOp(\"\u003d\", true);\n                 if (first.getType() \u003d\u003d Token.COMMA) {\n                     addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                 } else {\n                     addExpr(first, 0, getContextForNoInOperator(context));\n                 }\n             }\n             break;\n         case Token.ARRAYLIT:\n             add(\"[\");\n             addList(first, (int[]) n.getProp(Node.SKIP_INDEXES_PROP));\n             add(\"]\");\n             break;\n         case Token.LP:\n             add(\"(\");\n             addList(first);\n             add(\")\");\n             break;\n         case Token.COMMA:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             addList(first, false, context);\n             break;\n         case Token.NUMBER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             cc.addNumber(n.getDouble());\n             break;\n         case Token.TYPEOF:\n         case Token.VOID:\n         case Token.NOT:\n         case Token.BITNOT:\n         case Token.POS:\n         case Token.NEG:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                 addExpr(first, NodeUtil.precedence(type));\n                 break;\n             }\n         case Token.HOOK:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 int p \u003d NodeUtil.precedence(type);\n                 addLeftExpr(first, p + 1, context);\n                 cc.addOp(\"?\", true);\n                 addExpr(first.getNext(), 1);\n                 cc.addOp(\":\", true);\n                 addExpr(last, 1);\n                 break;\n             }\n         case Token.REGEXP:\n             if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                 throw new Error(\"Expected children to be strings\");\n             }\n             String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n             if (childCount \u003d\u003d 2) {\n                 add(regexp + last.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 add(regexp);\n             }\n             break;\n         case Token.GET_REF:\n             add(first);\n             break;\n         case Token.REF_SPECIAL:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first);\n             add(\".\");\n             add((String) n.getProp(Node.NAME_PROP));\n             break;\n         case Token.FUNCTION:\n             if (n.getClass() !\u003d Node.class) {\n                 throw new Error(\"Unexpected Node subclass.\");\n             }\n             Preconditions.checkState(childCount \u003d\u003d 3);\n             boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n             if (funcNeedsParens) {\n                 add(\"(\");\n             }\n             add(\"function\");\n             add(first);\n             add(first.getNext());\n             add(last, Context.PRESERVE_BLOCK);\n             cc.endFunction(context \u003d\u003d Context.STATEMENT);\n             if (funcNeedsParens) {\n                 add(\")\");\n             }\n             break;\n         case Token.SCRIPT:\n         case Token.BLOCK:\n             {\n                 if (n.getClass() !\u003d Node.class) {\n                     throw new Error(\"Unexpected Node subclass.\");\n                 }\n                 boolean preserveBlock \u003d context \u003d\u003d Context.PRESERVE_BLOCK;\n                 if (preserveBlock) {\n                     cc.beginBlock();\n                 }\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     add(c, Context.STATEMENT);\n                     if (c.getType() \u003d\u003d Token.VAR) {\n                         cc.endStatement();\n                     }\n                     if (c.getType() \u003d\u003d Token.FUNCTION) {\n                         cc.maybeLineBreak();\n                     }\n                     if (type \u003d\u003d Token.SCRIPT) {\n                         cc.notePreferredLineBreak();\n                     }\n                 }\n                 if (preserveBlock) {\n                     cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                 }\n                 break;\n             }\n         case Token.FOR:\n             if (childCount \u003d\u003d 4) {\n                 add(\"for(\");\n                 if (first.getType() \u003d\u003d Token.VAR) {\n                     add(first, Context.IN_FOR_INIT_CLAUSE);\n                 } else {\n                     addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                 }\n                 add(\";\");\n                 add(first.getNext());\n                 add(\";\");\n                 add(first.getNext().getNext());\n                 add(\")\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 add(\"for(\");\n                 add(first);\n                 add(\"in\");\n                 add(first.getNext());\n                 add(\")\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             }\n             break;\n         case Token.DO:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"do\");\n             addNonEmptyStatement(first, Context.OTHER, false);\n             add(\"while(\");\n             add(last);\n             add(\")\");\n             cc.endStatement();\n             break;\n         case Token.WHILE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"while(\");\n             add(first);\n             add(\")\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.EMPTY:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             break;\n         case Token.GETPROP:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                 Preconditions.checkState(last.getType() \u003d\u003d Token.STRING, \"Bad GETPROP: RHS should be STRING\");\n                 boolean needsParens \u003d (first.getType() \u003d\u003d Token.NUMBER);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 add(\".\");\n                 addIdentifier(last.getString());\n                 break;\n             }\n         case Token.GETELEM:\n             Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n             addLeftExpr(first, NodeUtil.precedence(type), context);\n             add(\"[\");\n             add(first.getNext());\n             add(\"]\");\n             break;\n         case Token.WITH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"with(\");\n             add(first);\n             add(\")\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.INC:\n         case Token.DEC:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                 int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                 if (postProp !\u003d 0) {\n                     addLeftExpr(first, NodeUtil.precedence(type), context);\n                     cc.addOp(o, false);\n                 } else {\n                     cc.addOp(o, false);\n                     add(first);\n                 }\n                 break;\n             }\n         case Token.CALL:\n             if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) \u0026\u0026 NodeUtil.isGet(first)) {\n                 add(\"(0,\");\n                 addExpr(first, NodeUtil.precedence(Token.COMMA));\n                 add(\")\");\n             } else {\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n             }\n             add(\"(\");\n             addList(first.getNext());\n             add(\")\");\n             break;\n         case Token.IF:\n             boolean hasElse \u003d childCount \u003d\u003d 3;\n             boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n             if (ambiguousElseClause) {\n                 cc.beginBlock();\n             }\n             add(\"if(\");\n             add(first);\n             add(\")\");\n             if (hasElse) {\n                 addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                 add(\"else\");\n                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n                 Preconditions.checkState(childCount \u003d\u003d 2);\n             }\n             if (ambiguousElseClause) {\n                 cc.endBlock();\n             }\n             break;\n         case Token.NULL:\n         case Token.THIS:\n         case Token.FALSE:\n         case Token.TRUE:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(Node.tokenToName(type));\n             break;\n         case Token.CONTINUE:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"continue\");\n             if (childCount \u003d\u003d 1) {\n                 if (first.getType() !\u003d Token.LABEL_NAME) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.DEBUGGER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(\"debugger\");\n             cc.endStatement();\n             break;\n         case Token.BREAK:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"break\");\n             if (childCount \u003d\u003d 1) {\n                 if (first.getType() !\u003d Token.LABEL_NAME) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.EXPR_VOID:\n             throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n         case Token.EXPR_RESULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first, Context.START_OF_EXPR);\n             cc.endStatement();\n             break;\n         case Token.NEW:\n             add(\"new \");\n             int precedence \u003d NodeUtil.precedence(type);\n             if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction())) {\n                 precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n             }\n             addExpr(first, precedence);\n             Node next \u003d first.getNext();\n             if (next !\u003d null) {\n                 add(\"(\");\n                 addList(next);\n                 add(\")\");\n             }\n             break;\n         case Token.STRING:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(jsString(n.getString(), outputCharsetEncoder));\n             break;\n         case Token.DELPROP:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"delete \");\n             add(first);\n             break;\n         case Token.OBJECTLIT:\n             {\n                 Preconditions.checkState(childCount % 2 \u003d\u003d 0);\n                 boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 add(\"{\");\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext().getNext()) {\n                     if (c !\u003d first) {\n                         cc.listSeparator();\n                     }\n                     if (c.getType() \u003d\u003d Token.STRING \u0026\u0026 !TokenStream.isKeyword(c.getString()) \u0026\u0026 TokenStream.isJSIdentifier(c.getString()) \u0026\u0026 NodeUtil.isLatin(c.getString())) {\n                         add(c.getString());\n                     } else {\n                         addExpr(c, 1);\n                     }\n                     add(\":\");\n                     addExpr(c.getNext(), 1);\n                 }\n                 add(\"}\");\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 break;\n             }\n         case Token.SWITCH:\n             add(\"switch(\");\n             add(first);\n             add(\")\");\n             cc.beginBlock();\n             addAllSiblings(first.getNext());\n             cc.endBlock(context \u003d\u003d Context.STATEMENT);\n             break;\n         case Token.CASE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"case \");\n             add(first);\n             addCaseBody(last);\n             break;\n         case Token.DEFAULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"default\");\n             addCaseBody(first);\n             break;\n         case Token.LABEL:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             if (first.getType() !\u003d Token.LABEL_NAME) {\n                 throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n             }\n             add(first);\n             add(\":\");\n             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\n             break;\n         case Token.SETNAME:\n             break;\n         default:\n             throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n     }\n     cc.endSourceMapping(n);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f0e3cbc250fd9536ff92119bdf5e1a62120a7fac": {
      "type": "Ybodychange",
      "commitMessage": "\nFix handling of blocks containing synthetic blocks in control\nstructures.\n\nR\u003dnicksantos\nDELTA\u003d43  (19 added, 2 deleted, 22 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d209648\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@410 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "9/8/10, 11:48 AM",
      "commitName": "f0e3cbc250fd9536ff92119bdf5e1a62120a7fac",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "8/27/10, 3:51 PM",
      "commitNameOld": "9390e7889e85aca41bdf98fb38a19bd69f6fdb87",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 11.83,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "actualSource": "void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n        return;\n    }\n    int type \u003d n.getType();\n    String opstr \u003d NodeUtil.opToStr(type);\n    int childCount \u003d n.getChildCount();\n    Node first \u003d n.getFirstChild();\n    Node last \u003d n.getLastChild();\n    if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n        Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n        int p \u003d NodeUtil.precedence(type);\n        addLeftExpr(first, p, context);\n        cc.addOp(opstr, true);\n        Context rhsContext \u003d getContextForNoInOperator(context);\n        if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n            addExpr(last, p, rhsContext);\n        } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n            addExpr(last, p, rhsContext);\n        } else {\n            addExpr(last, p + 1, rhsContext);\n        }\n        return;\n    }\n    cc.startSourceMapping(n);\n    switch(type) {\n        case Token.TRY:\n            {\n                Preconditions.checkState(first.getNext().getType() \u003d\u003d Token.BLOCK \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n                Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                add(\"try\");\n                add(first, Context.PRESERVE_BLOCK);\n                Node catchblock \u003d first.getNext().getFirstChild();\n                if (catchblock !\u003d null) {\n                    add(catchblock);\n                }\n                if (childCount \u003d\u003d 3) {\n                    add(\"finally\");\n                    add(last, Context.PRESERVE_BLOCK);\n                }\n                break;\n            }\n        case Token.CATCH:\n            Preconditions.checkState(childCount \u003d\u003d 3);\n            if (first.getNext().getType() !\u003d Token.EMPTY) {\n                throw new Error(\"Catch conditions not suppored because I think\" + \" that it may be a netscape only feature.\");\n            }\n            add(\"catch(\");\n            add(first);\n            add(\")\");\n            add(last, Context.PRESERVE_BLOCK);\n            break;\n        case Token.THROW:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"throw\");\n            add(first);\n            cc.endStatement(true);\n            break;\n        case Token.RETURN:\n            add(\"return\");\n            if (childCount \u003d\u003d 1) {\n                add(first);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 0);\n            }\n            cc.endStatement();\n            break;\n        case Token.VAR:\n            if (first !\u003d null) {\n                add(\"var \");\n                addList(first, false, getContextForNoInOperator(context));\n            }\n            break;\n        case Token.LABEL_NAME:\n            Preconditions.checkState(!n.getString().isEmpty());\n            addIdentifier(n.getString());\n            break;\n        case Token.NAME:\n            if (first \u003d\u003d null || first.getType() \u003d\u003d Token.EMPTY) {\n                addIdentifier(n.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                addIdentifier(n.getString());\n                cc.addOp(\"\u003d\", true);\n                if (first.getType() \u003d\u003d Token.COMMA) {\n                    addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                } else {\n                    addExpr(first, 0, getContextForNoInOperator(context));\n                }\n            }\n            break;\n        case Token.ARRAYLIT:\n            add(\"[\");\n            addList(first, (int[]) n.getProp(Node.SKIP_INDEXES_PROP));\n            add(\"]\");\n            break;\n        case Token.LP:\n            add(\"(\");\n            addList(first);\n            add(\")\");\n            break;\n        case Token.COMMA:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            addList(first, false, context);\n            break;\n        case Token.NUMBER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            cc.addNumber(n.getDouble());\n            break;\n        case Token.TYPEOF:\n        case Token.VOID:\n        case Token.NOT:\n        case Token.BITNOT:\n        case Token.POS:\n        case Token.NEG:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                addExpr(first, NodeUtil.precedence(type));\n                break;\n            }\n        case Token.HOOK:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                int p \u003d NodeUtil.precedence(type);\n                addLeftExpr(first, p + 1, context);\n                cc.addOp(\"?\", true);\n                addExpr(first.getNext(), 1);\n                cc.addOp(\":\", true);\n                addExpr(last, 1);\n                break;\n            }\n        case Token.REGEXP:\n            if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                throw new Error(\"Expected children to be strings\");\n            }\n            String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n            if (childCount \u003d\u003d 2) {\n                add(regexp + last.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                add(regexp);\n            }\n            break;\n        case Token.GET_REF:\n            add(first);\n            break;\n        case Token.REF_SPECIAL:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first);\n            add(\".\");\n            add((String) n.getProp(Node.NAME_PROP));\n            break;\n        case Token.FUNCTION:\n            if (n.getClass() !\u003d Node.class) {\n                throw new Error(\"Unexpected Node subclass.\");\n            }\n            Preconditions.checkState(childCount \u003d\u003d 3);\n            boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n            if (funcNeedsParens) {\n                add(\"(\");\n            }\n            add(\"function\");\n            add(first);\n            add(first.getNext());\n            add(last, Context.PRESERVE_BLOCK);\n            cc.endFunction(context \u003d\u003d Context.STATEMENT);\n            if (funcNeedsParens) {\n                add(\")\");\n            }\n            break;\n        case Token.SCRIPT:\n        case Token.BLOCK:\n            {\n                if (n.getClass() !\u003d Node.class) {\n                    throw new Error(\"Unexpected Node subclass.\");\n                }\n                boolean preserveBlock \u003d context \u003d\u003d Context.PRESERVE_BLOCK;\n                if (preserveBlock) {\n                    cc.beginBlock();\n                }\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    add(c, Context.STATEMENT);\n                    if (c.getType() \u003d\u003d Token.VAR) {\n                        cc.endStatement();\n                    }\n                    if (c.getType() \u003d\u003d Token.FUNCTION) {\n                        cc.maybeLineBreak();\n                    }\n                    if (type \u003d\u003d Token.SCRIPT) {\n                        cc.notePreferredLineBreak();\n                    }\n                }\n                if (preserveBlock) {\n                    cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                }\n                break;\n            }\n        case Token.FOR:\n            if (childCount \u003d\u003d 4) {\n                add(\"for(\");\n                if (first.getType() \u003d\u003d Token.VAR) {\n                    add(first, Context.IN_FOR_INIT_CLAUSE);\n                } else {\n                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                }\n                add(\";\");\n                add(first.getNext());\n                add(\";\");\n                add(first.getNext().getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                add(\"for(\");\n                add(first);\n                add(\"in\");\n                add(first.getNext());\n                add(\")\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            }\n            break;\n        case Token.DO:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"do\");\n            addNonEmptyStatement(first, Context.OTHER, false);\n            add(\"while(\");\n            add(last);\n            add(\")\");\n            cc.endStatement();\n            break;\n        case Token.WHILE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"while(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.EMPTY:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            break;\n        case Token.GETPROP:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                Preconditions.checkState(last.getType() \u003d\u003d Token.STRING, \"Bad GETPROP: RHS should be STRING\");\n                boolean needsParens \u003d (first.getType() \u003d\u003d Token.NUMBER);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n                if (needsParens) {\n                    add(\")\");\n                }\n                add(\".\");\n                addIdentifier(last.getString());\n                break;\n            }\n        case Token.GETELEM:\n            Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n            addLeftExpr(first, NodeUtil.precedence(type), context);\n            add(\"[\");\n            add(first.getNext());\n            add(\"]\");\n            break;\n        case Token.WITH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"with(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.INC:\n        case Token.DEC:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                if (postProp !\u003d 0) {\n                    addLeftExpr(first, NodeUtil.precedence(type), context);\n                    cc.addOp(o, false);\n                } else {\n                    cc.addOp(o, false);\n                    add(first);\n                }\n                break;\n            }\n        case Token.CALL:\n            if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) \u0026\u0026 NodeUtil.isGet(first)) {\n                add(\"(0,\");\n                addExpr(first, NodeUtil.precedence(Token.COMMA));\n                add(\")\");\n            } else {\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n            }\n            add(\"(\");\n            addList(first.getNext());\n            add(\")\");\n            break;\n        case Token.IF:\n            boolean hasElse \u003d childCount \u003d\u003d 3;\n            boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n            if (ambiguousElseClause) {\n                cc.beginBlock();\n            }\n            add(\"if(\");\n            add(first);\n            add(\")\");\n            if (hasElse) {\n                addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                add(\"else\");\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n                Preconditions.checkState(childCount \u003d\u003d 2);\n            }\n            if (ambiguousElseClause) {\n                cc.endBlock();\n            }\n            break;\n        case Token.NULL:\n        case Token.THIS:\n        case Token.FALSE:\n        case Token.TRUE:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(Node.tokenToName(type));\n            break;\n        case Token.CONTINUE:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"continue\");\n            if (childCount \u003d\u003d 1) {\n                if (first.getType() !\u003d Token.LABEL_NAME) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.DEBUGGER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"debugger\");\n            cc.endStatement();\n            break;\n        case Token.BREAK:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"break\");\n            if (childCount \u003d\u003d 1) {\n                if (first.getType() !\u003d Token.LABEL_NAME) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.EXPR_VOID:\n            throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n        case Token.EXPR_RESULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first, Context.START_OF_EXPR);\n            cc.endStatement();\n            break;\n        case Token.NEW:\n            add(\"new \");\n            int precedence \u003d NodeUtil.precedence(type);\n            if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction())) {\n                precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n            }\n            addExpr(first, precedence);\n            Node next \u003d first.getNext();\n            if (next !\u003d null) {\n                add(\"(\");\n                addList(next);\n                add(\")\");\n            }\n            break;\n        case Token.STRING:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(jsString(n.getString(), outputCharsetEncoder));\n            break;\n        case Token.DELPROP:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"delete \");\n            add(first);\n            break;\n        case Token.OBJECTLIT:\n            {\n                Preconditions.checkState(childCount % 2 \u003d\u003d 0);\n                boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                add(\"{\");\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext().getNext()) {\n                    if (c !\u003d first) {\n                        cc.listSeparator();\n                    }\n                    if (c.getType() \u003d\u003d Token.STRING \u0026\u0026 !TokenStream.isKeyword(c.getString()) \u0026\u0026 TokenStream.isJSIdentifier(c.getString()) \u0026\u0026 NodeUtil.isLatin(c.getString())) {\n                        add(c.getString());\n                    } else {\n                        addExpr(c, 1);\n                    }\n                    add(\":\");\n                    addExpr(c.getNext(), 1);\n                }\n                add(\"}\");\n                if (needsParens) {\n                    add(\")\");\n                }\n                break;\n            }\n        case Token.SWITCH:\n            add(\"switch(\");\n            add(first);\n            add(\")\");\n            cc.beginBlock();\n            addAllSiblings(first.getNext());\n            cc.endBlock(context \u003d\u003d Context.STATEMENT);\n            break;\n        case Token.CASE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"case \");\n            add(first);\n            addCaseBody(last);\n            break;\n        case Token.DEFAULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"default\");\n            addCaseBody(first);\n            break;\n        case Token.LABEL:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            if (first.getType() !\u003d Token.LABEL_NAME) {\n                throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n            }\n            add(first);\n            add(\":\");\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\n            break;\n        case Token.SETNAME:\n            break;\n        default:\n            throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n    cc.endSourceMapping(n);\n}",
      "path": "src/com/google/javascript/jscomp/CodeGenerator.java",
      "functionStartLine": 77,
      "functionName": "add",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,446 +1,446 @@\n void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n         return;\n     }\n     int type \u003d n.getType();\n     String opstr \u003d NodeUtil.opToStr(type);\n     int childCount \u003d n.getChildCount();\n     Node first \u003d n.getFirstChild();\n     Node last \u003d n.getLastChild();\n     if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n         Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n         int p \u003d NodeUtil.precedence(type);\n         addLeftExpr(first, p, context);\n         cc.addOp(opstr, true);\n         Context rhsContext \u003d getContextForNoInOperator(context);\n         if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n             addExpr(last, p, rhsContext);\n         } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n             addExpr(last, p, rhsContext);\n         } else {\n             addExpr(last, p + 1, rhsContext);\n         }\n         return;\n     }\n     cc.startSourceMapping(n);\n     switch(type) {\n         case Token.TRY:\n             {\n                 Preconditions.checkState(first.getNext().getType() \u003d\u003d Token.BLOCK \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n                 Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                 add(\"try\");\n                 add(first, Context.PRESERVE_BLOCK);\n                 Node catchblock \u003d first.getNext().getFirstChild();\n                 if (catchblock !\u003d null) {\n                     add(catchblock);\n                 }\n                 if (childCount \u003d\u003d 3) {\n                     add(\"finally\");\n                     add(last, Context.PRESERVE_BLOCK);\n                 }\n                 break;\n             }\n         case Token.CATCH:\n             Preconditions.checkState(childCount \u003d\u003d 3);\n             if (first.getNext().getType() !\u003d Token.EMPTY) {\n                 throw new Error(\"Catch conditions not suppored because I think\" + \" that it may be a netscape only feature.\");\n             }\n             add(\"catch(\");\n             add(first);\n             add(\")\");\n             add(last, Context.PRESERVE_BLOCK);\n             break;\n         case Token.THROW:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"throw\");\n             add(first);\n             cc.endStatement(true);\n             break;\n         case Token.RETURN:\n             add(\"return\");\n             if (childCount \u003d\u003d 1) {\n                 add(first);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 0);\n             }\n             cc.endStatement();\n             break;\n         case Token.VAR:\n             if (first !\u003d null) {\n                 add(\"var \");\n                 addList(first, false, getContextForNoInOperator(context));\n             }\n             break;\n         case Token.LABEL_NAME:\n             Preconditions.checkState(!n.getString().isEmpty());\n             addIdentifier(n.getString());\n             break;\n         case Token.NAME:\n             if (first \u003d\u003d null || first.getType() \u003d\u003d Token.EMPTY) {\n                 addIdentifier(n.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 addIdentifier(n.getString());\n                 cc.addOp(\"\u003d\", true);\n                 if (first.getType() \u003d\u003d Token.COMMA) {\n                     addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                 } else {\n                     addExpr(first, 0, getContextForNoInOperator(context));\n                 }\n             }\n             break;\n         case Token.ARRAYLIT:\n             add(\"[\");\n             addList(first, (int[]) n.getProp(Node.SKIP_INDEXES_PROP));\n             add(\"]\");\n             break;\n         case Token.LP:\n             add(\"(\");\n             addList(first);\n             add(\")\");\n             break;\n         case Token.COMMA:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             addList(first, false, context);\n             break;\n         case Token.NUMBER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             cc.addNumber(n.getDouble());\n             break;\n         case Token.TYPEOF:\n         case Token.VOID:\n         case Token.NOT:\n         case Token.BITNOT:\n         case Token.POS:\n         case Token.NEG:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                 addExpr(first, NodeUtil.precedence(type));\n                 break;\n             }\n         case Token.HOOK:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 int p \u003d NodeUtil.precedence(type);\n                 addLeftExpr(first, p + 1, context);\n                 cc.addOp(\"?\", true);\n                 addExpr(first.getNext(), 1);\n                 cc.addOp(\":\", true);\n                 addExpr(last, 1);\n                 break;\n             }\n         case Token.REGEXP:\n             if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                 throw new Error(\"Expected children to be strings\");\n             }\n             String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n             if (childCount \u003d\u003d 2) {\n                 add(regexp + last.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 add(regexp);\n             }\n             break;\n         case Token.GET_REF:\n             add(first);\n             break;\n         case Token.REF_SPECIAL:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first);\n             add(\".\");\n             add((String) n.getProp(Node.NAME_PROP));\n             break;\n         case Token.FUNCTION:\n             if (n.getClass() !\u003d Node.class) {\n                 throw new Error(\"Unexpected Node subclass.\");\n             }\n             Preconditions.checkState(childCount \u003d\u003d 3);\n             boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n             if (funcNeedsParens) {\n                 add(\"(\");\n             }\n             add(\"function\");\n             add(first);\n             add(first.getNext());\n             add(last, Context.PRESERVE_BLOCK);\n             cc.endFunction(context \u003d\u003d Context.STATEMENT);\n             if (funcNeedsParens) {\n                 add(\")\");\n             }\n             break;\n         case Token.SCRIPT:\n         case Token.BLOCK:\n             {\n                 if (n.getClass() !\u003d Node.class) {\n                     throw new Error(\"Unexpected Node subclass.\");\n                 }\n-                boolean stripBlock \u003d n.isSyntheticBlock() || n.getType() \u003d\u003d Token.SCRIPT || ((context !\u003d Context.PRESERVE_BLOCK) \u0026\u0026 (n.getChildCount() \u003c 2));\n-                if (!stripBlock) {\n+                boolean preserveBlock \u003d context \u003d\u003d Context.PRESERVE_BLOCK;\n+                if (preserveBlock) {\n                     cc.beginBlock();\n                 }\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     add(c, Context.STATEMENT);\n                     if (c.getType() \u003d\u003d Token.VAR) {\n                         cc.endStatement();\n                     }\n                     if (c.getType() \u003d\u003d Token.FUNCTION) {\n                         cc.maybeLineBreak();\n                     }\n                     if (type \u003d\u003d Token.SCRIPT) {\n                         cc.notePreferredLineBreak();\n                     }\n                 }\n-                if (!stripBlock) {\n+                if (preserveBlock) {\n                     cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                 }\n                 break;\n             }\n         case Token.FOR:\n             if (childCount \u003d\u003d 4) {\n                 add(\"for(\");\n                 if (first.getType() \u003d\u003d Token.VAR) {\n                     add(first, Context.IN_FOR_INIT_CLAUSE);\n                 } else {\n                     addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                 }\n                 add(\";\");\n                 add(first.getNext());\n                 add(\";\");\n                 add(first.getNext().getNext());\n                 add(\")\");\n-                addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n+                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 add(\"for(\");\n                 add(first);\n                 add(\"in\");\n                 add(first.getNext());\n                 add(\")\");\n-                addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n+                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             }\n             break;\n         case Token.DO:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"do\");\n-            addNonEmptyExpression(first, Context.OTHER, false);\n+            addNonEmptyStatement(first, Context.OTHER, false);\n             add(\"while(\");\n             add(last);\n             add(\")\");\n             cc.endStatement();\n             break;\n         case Token.WHILE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"while(\");\n             add(first);\n             add(\")\");\n-            addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n+            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.EMPTY:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             break;\n         case Token.GETPROP:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                 Preconditions.checkState(last.getType() \u003d\u003d Token.STRING, \"Bad GETPROP: RHS should be STRING\");\n                 boolean needsParens \u003d (first.getType() \u003d\u003d Token.NUMBER);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 add(\".\");\n                 addIdentifier(last.getString());\n                 break;\n             }\n         case Token.GETELEM:\n             Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n             addLeftExpr(first, NodeUtil.precedence(type), context);\n             add(\"[\");\n             add(first.getNext());\n             add(\"]\");\n             break;\n         case Token.WITH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"with(\");\n             add(first);\n             add(\")\");\n-            addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n+            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.INC:\n         case Token.DEC:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                 int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                 if (postProp !\u003d 0) {\n                     addLeftExpr(first, NodeUtil.precedence(type), context);\n                     cc.addOp(o, false);\n                 } else {\n                     cc.addOp(o, false);\n                     add(first);\n                 }\n                 break;\n             }\n         case Token.CALL:\n             if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) \u0026\u0026 NodeUtil.isGet(first)) {\n                 add(\"(0,\");\n                 addExpr(first, NodeUtil.precedence(Token.COMMA));\n                 add(\")\");\n             } else {\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n             }\n             add(\"(\");\n             addList(first.getNext());\n             add(\")\");\n             break;\n         case Token.IF:\n             boolean hasElse \u003d childCount \u003d\u003d 3;\n             boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n             if (ambiguousElseClause) {\n                 cc.beginBlock();\n             }\n             add(\"if(\");\n             add(first);\n             add(\")\");\n             if (hasElse) {\n-                addNonEmptyExpression(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n+                addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                 add(\"else\");\n-                addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n+                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\n             } else {\n-                addNonEmptyExpression(first.getNext(), Context.OTHER, false);\n+                addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n                 Preconditions.checkState(childCount \u003d\u003d 2);\n             }\n             if (ambiguousElseClause) {\n                 cc.endBlock();\n             }\n             break;\n         case Token.NULL:\n         case Token.THIS:\n         case Token.FALSE:\n         case Token.TRUE:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(Node.tokenToName(type));\n             break;\n         case Token.CONTINUE:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"continue\");\n             if (childCount \u003d\u003d 1) {\n                 if (first.getType() !\u003d Token.LABEL_NAME) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.DEBUGGER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(\"debugger\");\n             cc.endStatement();\n             break;\n         case Token.BREAK:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"break\");\n             if (childCount \u003d\u003d 1) {\n                 if (first.getType() !\u003d Token.LABEL_NAME) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.EXPR_VOID:\n             throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n         case Token.EXPR_RESULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first, Context.START_OF_EXPR);\n             cc.endStatement();\n             break;\n         case Token.NEW:\n             add(\"new \");\n             int precedence \u003d NodeUtil.precedence(type);\n             if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction())) {\n                 precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n             }\n             addExpr(first, precedence);\n             Node next \u003d first.getNext();\n             if (next !\u003d null) {\n                 add(\"(\");\n                 addList(next);\n                 add(\")\");\n             }\n             break;\n         case Token.STRING:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(jsString(n.getString(), outputCharsetEncoder));\n             break;\n         case Token.DELPROP:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"delete \");\n             add(first);\n             break;\n         case Token.OBJECTLIT:\n             {\n                 Preconditions.checkState(childCount % 2 \u003d\u003d 0);\n                 boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 add(\"{\");\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext().getNext()) {\n                     if (c !\u003d first) {\n                         cc.listSeparator();\n                     }\n                     if (c.getType() \u003d\u003d Token.STRING \u0026\u0026 !TokenStream.isKeyword(c.getString()) \u0026\u0026 TokenStream.isJSIdentifier(c.getString()) \u0026\u0026 NodeUtil.isLatin(c.getString())) {\n                         add(c.getString());\n                     } else {\n                         addExpr(c, 1);\n                     }\n                     add(\":\");\n                     addExpr(c.getNext(), 1);\n                 }\n                 add(\"}\");\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 break;\n             }\n         case Token.SWITCH:\n             add(\"switch(\");\n             add(first);\n             add(\")\");\n             cc.beginBlock();\n             addAllSiblings(first.getNext());\n             cc.endBlock(context \u003d\u003d Context.STATEMENT);\n             break;\n         case Token.CASE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"case \");\n             add(first);\n             addCaseBody(last);\n             break;\n         case Token.DEFAULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"default\");\n             addCaseBody(first);\n             break;\n         case Token.LABEL:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             if (first.getType() !\u003d Token.LABEL_NAME) {\n                 throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n             }\n             add(first);\n             add(\":\");\n-            addNonEmptyExpression(last, getContextForNonEmptyExpression(context), true);\n+            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\n             break;\n         case Token.SETNAME:\n             break;\n         default:\n             throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n     }\n     cc.endSourceMapping(n);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9390e7889e85aca41bdf98fb38a19bd69f6fdb87": {
      "type": "Ybodychange",
      "commitMessage": "\nFix handling of SCRIPT nodes that are not marked as synthetic.\n\nR\u003dacleung\nDELTA\u003d11  (11 added, 0 deleted, 0 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d198224\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@391 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "8/27/10, 3:51 PM",
      "commitName": "9390e7889e85aca41bdf98fb38a19bd69f6fdb87",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "8/12/10, 6:02 PM",
      "commitNameOld": "15acafb00636f99295b394145b9b60a5e624ddfa",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 14.91,
      "commitsBetweenForRepo": 34,
      "commitsBetweenForFile": 1,
      "actualSource": "void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n        return;\n    }\n    int type \u003d n.getType();\n    String opstr \u003d NodeUtil.opToStr(type);\n    int childCount \u003d n.getChildCount();\n    Node first \u003d n.getFirstChild();\n    Node last \u003d n.getLastChild();\n    if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n        Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n        int p \u003d NodeUtil.precedence(type);\n        addLeftExpr(first, p, context);\n        cc.addOp(opstr, true);\n        Context rhsContext \u003d getContextForNoInOperator(context);\n        if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n            addExpr(last, p, rhsContext);\n        } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n            addExpr(last, p, rhsContext);\n        } else {\n            addExpr(last, p + 1, rhsContext);\n        }\n        return;\n    }\n    cc.startSourceMapping(n);\n    switch(type) {\n        case Token.TRY:\n            {\n                Preconditions.checkState(first.getNext().getType() \u003d\u003d Token.BLOCK \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n                Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                add(\"try\");\n                add(first, Context.PRESERVE_BLOCK);\n                Node catchblock \u003d first.getNext().getFirstChild();\n                if (catchblock !\u003d null) {\n                    add(catchblock);\n                }\n                if (childCount \u003d\u003d 3) {\n                    add(\"finally\");\n                    add(last, Context.PRESERVE_BLOCK);\n                }\n                break;\n            }\n        case Token.CATCH:\n            Preconditions.checkState(childCount \u003d\u003d 3);\n            if (first.getNext().getType() !\u003d Token.EMPTY) {\n                throw new Error(\"Catch conditions not suppored because I think\" + \" that it may be a netscape only feature.\");\n            }\n            add(\"catch(\");\n            add(first);\n            add(\")\");\n            add(last, Context.PRESERVE_BLOCK);\n            break;\n        case Token.THROW:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"throw\");\n            add(first);\n            cc.endStatement(true);\n            break;\n        case Token.RETURN:\n            add(\"return\");\n            if (childCount \u003d\u003d 1) {\n                add(first);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 0);\n            }\n            cc.endStatement();\n            break;\n        case Token.VAR:\n            if (first !\u003d null) {\n                add(\"var \");\n                addList(first, false, getContextForNoInOperator(context));\n            }\n            break;\n        case Token.LABEL_NAME:\n            Preconditions.checkState(!n.getString().isEmpty());\n            addIdentifier(n.getString());\n            break;\n        case Token.NAME:\n            if (first \u003d\u003d null || first.getType() \u003d\u003d Token.EMPTY) {\n                addIdentifier(n.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                addIdentifier(n.getString());\n                cc.addOp(\"\u003d\", true);\n                if (first.getType() \u003d\u003d Token.COMMA) {\n                    addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                } else {\n                    addExpr(first, 0, getContextForNoInOperator(context));\n                }\n            }\n            break;\n        case Token.ARRAYLIT:\n            add(\"[\");\n            addList(first, (int[]) n.getProp(Node.SKIP_INDEXES_PROP));\n            add(\"]\");\n            break;\n        case Token.LP:\n            add(\"(\");\n            addList(first);\n            add(\")\");\n            break;\n        case Token.COMMA:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            addList(first, false, context);\n            break;\n        case Token.NUMBER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            cc.addNumber(n.getDouble());\n            break;\n        case Token.TYPEOF:\n        case Token.VOID:\n        case Token.NOT:\n        case Token.BITNOT:\n        case Token.POS:\n        case Token.NEG:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                addExpr(first, NodeUtil.precedence(type));\n                break;\n            }\n        case Token.HOOK:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                int p \u003d NodeUtil.precedence(type);\n                addLeftExpr(first, p + 1, context);\n                cc.addOp(\"?\", true);\n                addExpr(first.getNext(), 1);\n                cc.addOp(\":\", true);\n                addExpr(last, 1);\n                break;\n            }\n        case Token.REGEXP:\n            if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                throw new Error(\"Expected children to be strings\");\n            }\n            String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n            if (childCount \u003d\u003d 2) {\n                add(regexp + last.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                add(regexp);\n            }\n            break;\n        case Token.GET_REF:\n            add(first);\n            break;\n        case Token.REF_SPECIAL:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first);\n            add(\".\");\n            add((String) n.getProp(Node.NAME_PROP));\n            break;\n        case Token.FUNCTION:\n            if (n.getClass() !\u003d Node.class) {\n                throw new Error(\"Unexpected Node subclass.\");\n            }\n            Preconditions.checkState(childCount \u003d\u003d 3);\n            boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n            if (funcNeedsParens) {\n                add(\"(\");\n            }\n            add(\"function\");\n            add(first);\n            add(first.getNext());\n            add(last, Context.PRESERVE_BLOCK);\n            cc.endFunction(context \u003d\u003d Context.STATEMENT);\n            if (funcNeedsParens) {\n                add(\")\");\n            }\n            break;\n        case Token.SCRIPT:\n        case Token.BLOCK:\n            {\n                if (n.getClass() !\u003d Node.class) {\n                    throw new Error(\"Unexpected Node subclass.\");\n                }\n                boolean stripBlock \u003d n.isSyntheticBlock() || n.getType() \u003d\u003d Token.SCRIPT || ((context !\u003d Context.PRESERVE_BLOCK) \u0026\u0026 (n.getChildCount() \u003c 2));\n                if (!stripBlock) {\n                    cc.beginBlock();\n                }\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    add(c, Context.STATEMENT);\n                    if (c.getType() \u003d\u003d Token.VAR) {\n                        cc.endStatement();\n                    }\n                    if (c.getType() \u003d\u003d Token.FUNCTION) {\n                        cc.maybeLineBreak();\n                    }\n                    if (type \u003d\u003d Token.SCRIPT) {\n                        cc.notePreferredLineBreak();\n                    }\n                }\n                if (!stripBlock) {\n                    cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                }\n                break;\n            }\n        case Token.FOR:\n            if (childCount \u003d\u003d 4) {\n                add(\"for(\");\n                if (first.getType() \u003d\u003d Token.VAR) {\n                    add(first, Context.IN_FOR_INIT_CLAUSE);\n                } else {\n                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                }\n                add(\";\");\n                add(first.getNext());\n                add(\";\");\n                add(first.getNext().getNext());\n                add(\")\");\n                addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                add(\"for(\");\n                add(first);\n                add(\"in\");\n                add(first.getNext());\n                add(\")\");\n                addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            }\n            break;\n        case Token.DO:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"do\");\n            addNonEmptyExpression(first, Context.OTHER, false);\n            add(\"while(\");\n            add(last);\n            add(\")\");\n            cc.endStatement();\n            break;\n        case Token.WHILE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"while(\");\n            add(first);\n            add(\")\");\n            addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.EMPTY:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            break;\n        case Token.GETPROP:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                Preconditions.checkState(last.getType() \u003d\u003d Token.STRING, \"Bad GETPROP: RHS should be STRING\");\n                boolean needsParens \u003d (first.getType() \u003d\u003d Token.NUMBER);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n                if (needsParens) {\n                    add(\")\");\n                }\n                add(\".\");\n                addIdentifier(last.getString());\n                break;\n            }\n        case Token.GETELEM:\n            Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n            addLeftExpr(first, NodeUtil.precedence(type), context);\n            add(\"[\");\n            add(first.getNext());\n            add(\"]\");\n            break;\n        case Token.WITH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"with(\");\n            add(first);\n            add(\")\");\n            addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.INC:\n        case Token.DEC:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                if (postProp !\u003d 0) {\n                    addLeftExpr(first, NodeUtil.precedence(type), context);\n                    cc.addOp(o, false);\n                } else {\n                    cc.addOp(o, false);\n                    add(first);\n                }\n                break;\n            }\n        case Token.CALL:\n            if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) \u0026\u0026 NodeUtil.isGet(first)) {\n                add(\"(0,\");\n                addExpr(first, NodeUtil.precedence(Token.COMMA));\n                add(\")\");\n            } else {\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n            }\n            add(\"(\");\n            addList(first.getNext());\n            add(\")\");\n            break;\n        case Token.IF:\n            boolean hasElse \u003d childCount \u003d\u003d 3;\n            boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n            if (ambiguousElseClause) {\n                cc.beginBlock();\n            }\n            add(\"if(\");\n            add(first);\n            add(\")\");\n            if (hasElse) {\n                addNonEmptyExpression(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                add(\"else\");\n                addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                addNonEmptyExpression(first.getNext(), Context.OTHER, false);\n                Preconditions.checkState(childCount \u003d\u003d 2);\n            }\n            if (ambiguousElseClause) {\n                cc.endBlock();\n            }\n            break;\n        case Token.NULL:\n        case Token.THIS:\n        case Token.FALSE:\n        case Token.TRUE:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(Node.tokenToName(type));\n            break;\n        case Token.CONTINUE:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"continue\");\n            if (childCount \u003d\u003d 1) {\n                if (first.getType() !\u003d Token.LABEL_NAME) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.DEBUGGER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"debugger\");\n            cc.endStatement();\n            break;\n        case Token.BREAK:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"break\");\n            if (childCount \u003d\u003d 1) {\n                if (first.getType() !\u003d Token.LABEL_NAME) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.EXPR_VOID:\n            throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n        case Token.EXPR_RESULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first, Context.START_OF_EXPR);\n            cc.endStatement();\n            break;\n        case Token.NEW:\n            add(\"new \");\n            int precedence \u003d NodeUtil.precedence(type);\n            if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction())) {\n                precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n            }\n            addExpr(first, precedence);\n            Node next \u003d first.getNext();\n            if (next !\u003d null) {\n                add(\"(\");\n                addList(next);\n                add(\")\");\n            }\n            break;\n        case Token.STRING:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(jsString(n.getString(), outputCharsetEncoder));\n            break;\n        case Token.DELPROP:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"delete \");\n            add(first);\n            break;\n        case Token.OBJECTLIT:\n            {\n                Preconditions.checkState(childCount % 2 \u003d\u003d 0);\n                boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                add(\"{\");\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext().getNext()) {\n                    if (c !\u003d first) {\n                        cc.listSeparator();\n                    }\n                    if (c.getType() \u003d\u003d Token.STRING \u0026\u0026 !TokenStream.isKeyword(c.getString()) \u0026\u0026 TokenStream.isJSIdentifier(c.getString()) \u0026\u0026 NodeUtil.isLatin(c.getString())) {\n                        add(c.getString());\n                    } else {\n                        addExpr(c, 1);\n                    }\n                    add(\":\");\n                    addExpr(c.getNext(), 1);\n                }\n                add(\"}\");\n                if (needsParens) {\n                    add(\")\");\n                }\n                break;\n            }\n        case Token.SWITCH:\n            add(\"switch(\");\n            add(first);\n            add(\")\");\n            cc.beginBlock();\n            addAllSiblings(first.getNext());\n            cc.endBlock(context \u003d\u003d Context.STATEMENT);\n            break;\n        case Token.CASE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"case \");\n            add(first);\n            addCaseBody(last);\n            break;\n        case Token.DEFAULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"default\");\n            addCaseBody(first);\n            break;\n        case Token.LABEL:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            if (first.getType() !\u003d Token.LABEL_NAME) {\n                throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n            }\n            add(first);\n            add(\":\");\n            addNonEmptyExpression(last, getContextForNonEmptyExpression(context), true);\n            break;\n        case Token.SETNAME:\n            break;\n        default:\n            throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n    cc.endSourceMapping(n);\n}",
      "path": "src/com/google/javascript/jscomp/CodeGenerator.java",
      "functionStartLine": 77,
      "functionName": "add",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,446 +1,446 @@\n void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n         return;\n     }\n     int type \u003d n.getType();\n     String opstr \u003d NodeUtil.opToStr(type);\n     int childCount \u003d n.getChildCount();\n     Node first \u003d n.getFirstChild();\n     Node last \u003d n.getLastChild();\n     if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n         Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n         int p \u003d NodeUtil.precedence(type);\n         addLeftExpr(first, p, context);\n         cc.addOp(opstr, true);\n         Context rhsContext \u003d getContextForNoInOperator(context);\n         if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n             addExpr(last, p, rhsContext);\n         } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n             addExpr(last, p, rhsContext);\n         } else {\n             addExpr(last, p + 1, rhsContext);\n         }\n         return;\n     }\n     cc.startSourceMapping(n);\n     switch(type) {\n         case Token.TRY:\n             {\n                 Preconditions.checkState(first.getNext().getType() \u003d\u003d Token.BLOCK \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n                 Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                 add(\"try\");\n                 add(first, Context.PRESERVE_BLOCK);\n                 Node catchblock \u003d first.getNext().getFirstChild();\n                 if (catchblock !\u003d null) {\n                     add(catchblock);\n                 }\n                 if (childCount \u003d\u003d 3) {\n                     add(\"finally\");\n                     add(last, Context.PRESERVE_BLOCK);\n                 }\n                 break;\n             }\n         case Token.CATCH:\n             Preconditions.checkState(childCount \u003d\u003d 3);\n             if (first.getNext().getType() !\u003d Token.EMPTY) {\n                 throw new Error(\"Catch conditions not suppored because I think\" + \" that it may be a netscape only feature.\");\n             }\n             add(\"catch(\");\n             add(first);\n             add(\")\");\n             add(last, Context.PRESERVE_BLOCK);\n             break;\n         case Token.THROW:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"throw\");\n             add(first);\n             cc.endStatement(true);\n             break;\n         case Token.RETURN:\n             add(\"return\");\n             if (childCount \u003d\u003d 1) {\n                 add(first);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 0);\n             }\n             cc.endStatement();\n             break;\n         case Token.VAR:\n             if (first !\u003d null) {\n                 add(\"var \");\n                 addList(first, false, getContextForNoInOperator(context));\n             }\n             break;\n         case Token.LABEL_NAME:\n             Preconditions.checkState(!n.getString().isEmpty());\n             addIdentifier(n.getString());\n             break;\n         case Token.NAME:\n             if (first \u003d\u003d null || first.getType() \u003d\u003d Token.EMPTY) {\n                 addIdentifier(n.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 addIdentifier(n.getString());\n                 cc.addOp(\"\u003d\", true);\n                 if (first.getType() \u003d\u003d Token.COMMA) {\n                     addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                 } else {\n                     addExpr(first, 0, getContextForNoInOperator(context));\n                 }\n             }\n             break;\n         case Token.ARRAYLIT:\n             add(\"[\");\n             addList(first, (int[]) n.getProp(Node.SKIP_INDEXES_PROP));\n             add(\"]\");\n             break;\n         case Token.LP:\n             add(\"(\");\n             addList(first);\n             add(\")\");\n             break;\n         case Token.COMMA:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             addList(first, false, context);\n             break;\n         case Token.NUMBER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             cc.addNumber(n.getDouble());\n             break;\n         case Token.TYPEOF:\n         case Token.VOID:\n         case Token.NOT:\n         case Token.BITNOT:\n         case Token.POS:\n         case Token.NEG:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                 addExpr(first, NodeUtil.precedence(type));\n                 break;\n             }\n         case Token.HOOK:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 int p \u003d NodeUtil.precedence(type);\n                 addLeftExpr(first, p + 1, context);\n                 cc.addOp(\"?\", true);\n                 addExpr(first.getNext(), 1);\n                 cc.addOp(\":\", true);\n                 addExpr(last, 1);\n                 break;\n             }\n         case Token.REGEXP:\n             if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                 throw new Error(\"Expected children to be strings\");\n             }\n             String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n             if (childCount \u003d\u003d 2) {\n                 add(regexp + last.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 add(regexp);\n             }\n             break;\n         case Token.GET_REF:\n             add(first);\n             break;\n         case Token.REF_SPECIAL:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first);\n             add(\".\");\n             add((String) n.getProp(Node.NAME_PROP));\n             break;\n         case Token.FUNCTION:\n             if (n.getClass() !\u003d Node.class) {\n                 throw new Error(\"Unexpected Node subclass.\");\n             }\n             Preconditions.checkState(childCount \u003d\u003d 3);\n             boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n             if (funcNeedsParens) {\n                 add(\"(\");\n             }\n             add(\"function\");\n             add(first);\n             add(first.getNext());\n             add(last, Context.PRESERVE_BLOCK);\n             cc.endFunction(context \u003d\u003d Context.STATEMENT);\n             if (funcNeedsParens) {\n                 add(\")\");\n             }\n             break;\n         case Token.SCRIPT:\n         case Token.BLOCK:\n             {\n                 if (n.getClass() !\u003d Node.class) {\n                     throw new Error(\"Unexpected Node subclass.\");\n                 }\n-                boolean stripBlock \u003d n.isSyntheticBlock() || ((context !\u003d Context.PRESERVE_BLOCK) \u0026\u0026 (n.getChildCount() \u003c 2));\n+                boolean stripBlock \u003d n.isSyntheticBlock() || n.getType() \u003d\u003d Token.SCRIPT || ((context !\u003d Context.PRESERVE_BLOCK) \u0026\u0026 (n.getChildCount() \u003c 2));\n                 if (!stripBlock) {\n                     cc.beginBlock();\n                 }\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     add(c, Context.STATEMENT);\n                     if (c.getType() \u003d\u003d Token.VAR) {\n                         cc.endStatement();\n                     }\n                     if (c.getType() \u003d\u003d Token.FUNCTION) {\n                         cc.maybeLineBreak();\n                     }\n                     if (type \u003d\u003d Token.SCRIPT) {\n                         cc.notePreferredLineBreak();\n                     }\n                 }\n                 if (!stripBlock) {\n                     cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                 }\n                 break;\n             }\n         case Token.FOR:\n             if (childCount \u003d\u003d 4) {\n                 add(\"for(\");\n                 if (first.getType() \u003d\u003d Token.VAR) {\n                     add(first, Context.IN_FOR_INIT_CLAUSE);\n                 } else {\n                     addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                 }\n                 add(\";\");\n                 add(first.getNext());\n                 add(\";\");\n                 add(first.getNext().getNext());\n                 add(\")\");\n                 addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 add(\"for(\");\n                 add(first);\n                 add(\"in\");\n                 add(first.getNext());\n                 add(\")\");\n                 addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             }\n             break;\n         case Token.DO:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"do\");\n             addNonEmptyExpression(first, Context.OTHER, false);\n             add(\"while(\");\n             add(last);\n             add(\")\");\n             cc.endStatement();\n             break;\n         case Token.WHILE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"while(\");\n             add(first);\n             add(\")\");\n             addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.EMPTY:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             break;\n         case Token.GETPROP:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                 Preconditions.checkState(last.getType() \u003d\u003d Token.STRING, \"Bad GETPROP: RHS should be STRING\");\n                 boolean needsParens \u003d (first.getType() \u003d\u003d Token.NUMBER);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 add(\".\");\n                 addIdentifier(last.getString());\n                 break;\n             }\n         case Token.GETELEM:\n             Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n             addLeftExpr(first, NodeUtil.precedence(type), context);\n             add(\"[\");\n             add(first.getNext());\n             add(\"]\");\n             break;\n         case Token.WITH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"with(\");\n             add(first);\n             add(\")\");\n             addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.INC:\n         case Token.DEC:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                 int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                 if (postProp !\u003d 0) {\n                     addLeftExpr(first, NodeUtil.precedence(type), context);\n                     cc.addOp(o, false);\n                 } else {\n                     cc.addOp(o, false);\n                     add(first);\n                 }\n                 break;\n             }\n         case Token.CALL:\n             if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) \u0026\u0026 NodeUtil.isGet(first)) {\n                 add(\"(0,\");\n                 addExpr(first, NodeUtil.precedence(Token.COMMA));\n                 add(\")\");\n             } else {\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n             }\n             add(\"(\");\n             addList(first.getNext());\n             add(\")\");\n             break;\n         case Token.IF:\n             boolean hasElse \u003d childCount \u003d\u003d 3;\n             boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n             if (ambiguousElseClause) {\n                 cc.beginBlock();\n             }\n             add(\"if(\");\n             add(first);\n             add(\")\");\n             if (hasElse) {\n                 addNonEmptyExpression(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                 add(\"else\");\n                 addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 addNonEmptyExpression(first.getNext(), Context.OTHER, false);\n                 Preconditions.checkState(childCount \u003d\u003d 2);\n             }\n             if (ambiguousElseClause) {\n                 cc.endBlock();\n             }\n             break;\n         case Token.NULL:\n         case Token.THIS:\n         case Token.FALSE:\n         case Token.TRUE:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(Node.tokenToName(type));\n             break;\n         case Token.CONTINUE:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"continue\");\n             if (childCount \u003d\u003d 1) {\n                 if (first.getType() !\u003d Token.LABEL_NAME) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.DEBUGGER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(\"debugger\");\n             cc.endStatement();\n             break;\n         case Token.BREAK:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"break\");\n             if (childCount \u003d\u003d 1) {\n                 if (first.getType() !\u003d Token.LABEL_NAME) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.EXPR_VOID:\n             throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n         case Token.EXPR_RESULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first, Context.START_OF_EXPR);\n             cc.endStatement();\n             break;\n         case Token.NEW:\n             add(\"new \");\n             int precedence \u003d NodeUtil.precedence(type);\n             if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction())) {\n                 precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n             }\n             addExpr(first, precedence);\n             Node next \u003d first.getNext();\n             if (next !\u003d null) {\n                 add(\"(\");\n                 addList(next);\n                 add(\")\");\n             }\n             break;\n         case Token.STRING:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(jsString(n.getString(), outputCharsetEncoder));\n             break;\n         case Token.DELPROP:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"delete \");\n             add(first);\n             break;\n         case Token.OBJECTLIT:\n             {\n                 Preconditions.checkState(childCount % 2 \u003d\u003d 0);\n                 boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 add(\"{\");\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext().getNext()) {\n                     if (c !\u003d first) {\n                         cc.listSeparator();\n                     }\n                     if (c.getType() \u003d\u003d Token.STRING \u0026\u0026 !TokenStream.isKeyword(c.getString()) \u0026\u0026 TokenStream.isJSIdentifier(c.getString()) \u0026\u0026 NodeUtil.isLatin(c.getString())) {\n                         add(c.getString());\n                     } else {\n                         addExpr(c, 1);\n                     }\n                     add(\":\");\n                     addExpr(c.getNext(), 1);\n                 }\n                 add(\"}\");\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 break;\n             }\n         case Token.SWITCH:\n             add(\"switch(\");\n             add(first);\n             add(\")\");\n             cc.beginBlock();\n             addAllSiblings(first.getNext());\n             cc.endBlock(context \u003d\u003d Context.STATEMENT);\n             break;\n         case Token.CASE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"case \");\n             add(first);\n             addCaseBody(last);\n             break;\n         case Token.DEFAULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"default\");\n             addCaseBody(first);\n             break;\n         case Token.LABEL:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             if (first.getType() !\u003d Token.LABEL_NAME) {\n                 throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n             }\n             add(first);\n             add(\":\");\n             addNonEmptyExpression(last, getContextForNonEmptyExpression(context), true);\n             break;\n         case Token.SETNAME:\n             break;\n         default:\n             throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n     }\n     cc.endSourceMapping(n);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "17296982d8892d972412352289c307a4d60d2c50": {
      "type": "Ybodychange",
      "commitMessage": "\nDon\u0027t looked into functions when trying to determine if a Token.NEW\nneeds parenthese around it argument.\n\nR\u003dbowdidge\nDELTA\u003d19  (16 added, 0 deleted, 3 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d58002\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@302 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "7/21/10, 3:02 PM",
      "commitName": "17296982d8892d972412352289c307a4d60d2c50",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "7/15/10, 2:34 PM",
      "commitNameOld": "d7e85b0997ebb3d920c977de7a4a3f8ede5ba2d8",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 6.02,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "actualSource": "void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n        return;\n    }\n    int type \u003d n.getType();\n    String opstr \u003d NodeUtil.opToStr(type);\n    int childCount \u003d n.getChildCount();\n    Node first \u003d n.getFirstChild();\n    Node last \u003d n.getLastChild();\n    if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n        Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n        int p \u003d NodeUtil.precedence(type);\n        addLeftExpr(first, p, context);\n        cc.addOp(opstr, true);\n        Context rhsContext \u003d getContextForNoInOperator(context);\n        if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n            addExpr(last, p, rhsContext);\n        } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n            addExpr(last, p, rhsContext);\n        } else {\n            addExpr(last, p + 1, rhsContext);\n        }\n        return;\n    }\n    cc.startSourceMapping(n);\n    switch(type) {\n        case Token.TRY:\n            {\n                Preconditions.checkState(first.getNext().getType() \u003d\u003d Token.BLOCK \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n                Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                add(\"try\");\n                add(first, Context.PRESERVE_BLOCK);\n                Node catchblock \u003d first.getNext().getFirstChild();\n                if (catchblock !\u003d null) {\n                    add(catchblock);\n                }\n                if (childCount \u003d\u003d 3) {\n                    add(\"finally\");\n                    add(last, Context.PRESERVE_BLOCK);\n                }\n                break;\n            }\n        case Token.CATCH:\n            Preconditions.checkState(childCount \u003d\u003d 3);\n            if (first.getNext().getType() !\u003d Token.EMPTY) {\n                throw new Error(\"Catch conditions not suppored because I think\" + \" that it may be a netscape only feature.\");\n            }\n            add(\"catch(\");\n            add(first);\n            add(\")\");\n            add(last, Context.PRESERVE_BLOCK);\n            break;\n        case Token.THROW:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"throw\");\n            add(first);\n            cc.endStatement(true);\n            break;\n        case Token.RETURN:\n            add(\"return\");\n            if (childCount \u003d\u003d 1) {\n                add(first);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 0);\n            }\n            cc.endStatement();\n            break;\n        case Token.VAR:\n            if (first !\u003d null) {\n                add(\"var \");\n                addList(first, false, getContextForNoInOperator(context));\n            }\n            break;\n        case Token.LABEL_NAME:\n            Preconditions.checkState(!n.getString().isEmpty());\n            addIdentifier(n.getString());\n            break;\n        case Token.NAME:\n            if (first \u003d\u003d null || first.getType() \u003d\u003d Token.EMPTY) {\n                addIdentifier(n.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                addIdentifier(n.getString());\n                cc.addOp(\"\u003d\", true);\n                if (first.getType() \u003d\u003d Token.COMMA) {\n                    addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                } else {\n                    addExpr(first, 0, getContextForNoInOperator(context));\n                }\n            }\n            break;\n        case Token.ARRAYLIT:\n            add(\"[\");\n            addList(first, (int[]) n.getProp(Node.SKIP_INDEXES_PROP));\n            add(\"]\");\n            break;\n        case Token.LP:\n            add(\"(\");\n            addList(first);\n            add(\")\");\n            break;\n        case Token.COMMA:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            addList(first, false, context);\n            break;\n        case Token.NUMBER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            cc.addNumber(n.getDouble());\n            break;\n        case Token.TYPEOF:\n        case Token.VOID:\n        case Token.NOT:\n        case Token.BITNOT:\n        case Token.POS:\n        case Token.NEG:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                addExpr(first, NodeUtil.precedence(type));\n                break;\n            }\n        case Token.HOOK:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                int p \u003d NodeUtil.precedence(type);\n                addLeftExpr(first, p + 1, context);\n                cc.addOp(\"?\", true);\n                addExpr(first.getNext(), 1);\n                cc.addOp(\":\", true);\n                addExpr(last, 1);\n                break;\n            }\n        case Token.REGEXP:\n            if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                throw new Error(\"Expected children to be strings\");\n            }\n            String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n            if (childCount \u003d\u003d 2) {\n                add(regexp + last.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                add(regexp);\n            }\n            break;\n        case Token.GET_REF:\n            add(first);\n            break;\n        case Token.REF_SPECIAL:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first);\n            add(\".\");\n            add((String) n.getProp(Node.NAME_PROP));\n            break;\n        case Token.FUNCTION:\n            if (n.getClass() !\u003d Node.class) {\n                throw new Error(\"Unexpected Node subclass.\");\n            }\n            Preconditions.checkState(childCount \u003d\u003d 3);\n            boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n            if (funcNeedsParens) {\n                add(\"(\");\n            }\n            add(\"function\");\n            add(first);\n            add(first.getNext());\n            add(last, Context.PRESERVE_BLOCK);\n            cc.endFunction(context \u003d\u003d Context.STATEMENT);\n            if (funcNeedsParens) {\n                add(\")\");\n            }\n            break;\n        case Token.SCRIPT:\n        case Token.BLOCK:\n            {\n                if (n.getClass() !\u003d Node.class) {\n                    throw new Error(\"Unexpected Node subclass.\");\n                }\n                boolean stripBlock \u003d n.isSyntheticBlock() || ((context !\u003d Context.PRESERVE_BLOCK) \u0026\u0026 (n.getChildCount() \u003c 2));\n                if (!stripBlock) {\n                    cc.beginBlock();\n                }\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    add(c, Context.STATEMENT);\n                    if (c.getType() \u003d\u003d Token.VAR) {\n                        cc.endStatement();\n                    }\n                    if (c.getType() \u003d\u003d Token.FUNCTION) {\n                        cc.maybeLineBreak();\n                    }\n                    if (type \u003d\u003d Token.SCRIPT) {\n                        cc.notePreferredLineBreak();\n                    }\n                }\n                if (!stripBlock) {\n                    cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                }\n                break;\n            }\n        case Token.FOR:\n            if (childCount \u003d\u003d 4) {\n                add(\"for(\");\n                if (first.getType() \u003d\u003d Token.VAR) {\n                    add(first, Context.IN_FOR_INIT_CLAUSE);\n                } else {\n                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                }\n                add(\";\");\n                add(first.getNext());\n                add(\";\");\n                add(first.getNext().getNext());\n                add(\")\");\n                addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                add(\"for(\");\n                add(first);\n                add(\"in\");\n                add(first.getNext());\n                add(\")\");\n                addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            }\n            break;\n        case Token.DO:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"do\");\n            addNonEmptyExpression(first, Context.OTHER, false);\n            add(\"while(\");\n            add(last);\n            add(\")\");\n            cc.endStatement();\n            break;\n        case Token.WHILE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"while(\");\n            add(first);\n            add(\")\");\n            addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.EMPTY:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            break;\n        case Token.GETPROP:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                Preconditions.checkState(last.getType() \u003d\u003d Token.STRING, \"Bad GETPROP: RHS should be STRING\");\n                boolean needsParens \u003d (first.getType() \u003d\u003d Token.NUMBER);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n                if (needsParens) {\n                    add(\")\");\n                }\n                add(\".\");\n                addIdentifier(last.getString());\n                break;\n            }\n        case Token.GETELEM:\n            Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n            addLeftExpr(first, NodeUtil.precedence(type), context);\n            add(\"[\");\n            add(first.getNext());\n            add(\"]\");\n            break;\n        case Token.WITH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"with(\");\n            add(first);\n            add(\")\");\n            addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.INC:\n        case Token.DEC:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                if (postProp !\u003d 0) {\n                    addLeftExpr(first, NodeUtil.precedence(type), context);\n                    cc.addOp(o, false);\n                } else {\n                    cc.addOp(o, false);\n                    add(first);\n                }\n                break;\n            }\n        case Token.CALL:\n            if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) \u0026\u0026 NodeUtil.isGet(first)) {\n                add(\"(0,\");\n                addExpr(first, NodeUtil.precedence(Token.COMMA));\n                add(\")\");\n            } else {\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n            }\n            add(\"(\");\n            addList(first.getNext());\n            add(\")\");\n            break;\n        case Token.IF:\n            boolean hasElse \u003d childCount \u003d\u003d 3;\n            boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n            if (ambiguousElseClause) {\n                cc.beginBlock();\n            }\n            add(\"if(\");\n            add(first);\n            add(\")\");\n            if (hasElse) {\n                addNonEmptyExpression(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                add(\"else\");\n                addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                addNonEmptyExpression(first.getNext(), Context.OTHER, false);\n                Preconditions.checkState(childCount \u003d\u003d 2);\n            }\n            if (ambiguousElseClause) {\n                cc.endBlock();\n            }\n            break;\n        case Token.NULL:\n        case Token.THIS:\n        case Token.FALSE:\n        case Token.TRUE:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(Node.tokenToName(type));\n            break;\n        case Token.CONTINUE:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"continue\");\n            if (childCount \u003d\u003d 1) {\n                if (first.getType() !\u003d Token.LABEL_NAME) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.DEBUGGER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"debugger\");\n            cc.endStatement();\n            break;\n        case Token.BREAK:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"break\");\n            if (childCount \u003d\u003d 1) {\n                if (first.getType() !\u003d Token.LABEL_NAME) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.EXPR_VOID:\n            throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n        case Token.EXPR_RESULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first, Context.START_OF_EXPR);\n            cc.endStatement();\n            break;\n        case Token.NEW:\n            add(\"new \");\n            int precedence \u003d NodeUtil.precedence(type);\n            if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction())) {\n                precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n            }\n            addExpr(first, precedence);\n            Node next \u003d first.getNext();\n            if (next !\u003d null) {\n                add(\"(\");\n                addList(next);\n                add(\")\");\n            }\n            break;\n        case Token.STRING:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(jsString(n.getString(), outputCharsetEncoder));\n            break;\n        case Token.DELPROP:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"delete \");\n            add(first);\n            break;\n        case Token.OBJECTLIT:\n            {\n                Preconditions.checkState(childCount % 2 \u003d\u003d 0);\n                boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                add(\"{\");\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext().getNext()) {\n                    if (c !\u003d first) {\n                        cc.listSeparator();\n                    }\n                    if (c.getType() \u003d\u003d Token.STRING \u0026\u0026 !TokenStream.isKeyword(c.getString()) \u0026\u0026 TokenStream.isJSIdentifier(c.getString()) \u0026\u0026 NodeUtil.isLatin(c.getString())) {\n                        add(c.getString());\n                    } else {\n                        addExpr(c, 1);\n                    }\n                    add(\":\");\n                    addExpr(c.getNext(), 1);\n                }\n                add(\"}\");\n                if (needsParens) {\n                    add(\")\");\n                }\n                break;\n            }\n        case Token.SWITCH:\n            add(\"switch(\");\n            add(first);\n            add(\")\");\n            cc.beginBlock();\n            addAllSiblings(first.getNext());\n            cc.endBlock(context \u003d\u003d Context.STATEMENT);\n            break;\n        case Token.CASE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"case \");\n            add(first);\n            addCaseBody(last);\n            break;\n        case Token.DEFAULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"default\");\n            addCaseBody(first);\n            break;\n        case Token.LABEL:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            if (first.getType() !\u003d Token.LABEL_NAME) {\n                throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n            }\n            add(first);\n            add(\":\");\n            addNonEmptyExpression(last, getContextForNonEmptyExpression(context), true);\n            break;\n        case Token.SETNAME:\n            break;\n        default:\n            throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n    cc.endSourceMapping(n);\n}",
      "path": "src/com/google/javascript/jscomp/CodeGenerator.java",
      "functionStartLine": 77,
      "functionName": "add",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,446 +1,446 @@\n void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n         return;\n     }\n     int type \u003d n.getType();\n     String opstr \u003d NodeUtil.opToStr(type);\n     int childCount \u003d n.getChildCount();\n     Node first \u003d n.getFirstChild();\n     Node last \u003d n.getLastChild();\n     if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n         Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n         int p \u003d NodeUtil.precedence(type);\n         addLeftExpr(first, p, context);\n         cc.addOp(opstr, true);\n         Context rhsContext \u003d getContextForNoInOperator(context);\n         if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n             addExpr(last, p, rhsContext);\n         } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n             addExpr(last, p, rhsContext);\n         } else {\n             addExpr(last, p + 1, rhsContext);\n         }\n         return;\n     }\n     cc.startSourceMapping(n);\n     switch(type) {\n         case Token.TRY:\n             {\n                 Preconditions.checkState(first.getNext().getType() \u003d\u003d Token.BLOCK \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n                 Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                 add(\"try\");\n                 add(first, Context.PRESERVE_BLOCK);\n                 Node catchblock \u003d first.getNext().getFirstChild();\n                 if (catchblock !\u003d null) {\n                     add(catchblock);\n                 }\n                 if (childCount \u003d\u003d 3) {\n                     add(\"finally\");\n                     add(last, Context.PRESERVE_BLOCK);\n                 }\n                 break;\n             }\n         case Token.CATCH:\n             Preconditions.checkState(childCount \u003d\u003d 3);\n             if (first.getNext().getType() !\u003d Token.EMPTY) {\n                 throw new Error(\"Catch conditions not suppored because I think\" + \" that it may be a netscape only feature.\");\n             }\n             add(\"catch(\");\n             add(first);\n             add(\")\");\n             add(last, Context.PRESERVE_BLOCK);\n             break;\n         case Token.THROW:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"throw\");\n             add(first);\n             cc.endStatement(true);\n             break;\n         case Token.RETURN:\n             add(\"return\");\n             if (childCount \u003d\u003d 1) {\n                 add(first);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 0);\n             }\n             cc.endStatement();\n             break;\n         case Token.VAR:\n             if (first !\u003d null) {\n                 add(\"var \");\n                 addList(first, false, getContextForNoInOperator(context));\n             }\n             break;\n         case Token.LABEL_NAME:\n             Preconditions.checkState(!n.getString().isEmpty());\n             addIdentifier(n.getString());\n             break;\n         case Token.NAME:\n             if (first \u003d\u003d null || first.getType() \u003d\u003d Token.EMPTY) {\n                 addIdentifier(n.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 addIdentifier(n.getString());\n                 cc.addOp(\"\u003d\", true);\n                 if (first.getType() \u003d\u003d Token.COMMA) {\n                     addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                 } else {\n                     addExpr(first, 0, getContextForNoInOperator(context));\n                 }\n             }\n             break;\n         case Token.ARRAYLIT:\n             add(\"[\");\n             addList(first, (int[]) n.getProp(Node.SKIP_INDEXES_PROP));\n             add(\"]\");\n             break;\n         case Token.LP:\n             add(\"(\");\n             addList(first);\n             add(\")\");\n             break;\n         case Token.COMMA:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             addList(first, false, context);\n             break;\n         case Token.NUMBER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             cc.addNumber(n.getDouble());\n             break;\n         case Token.TYPEOF:\n         case Token.VOID:\n         case Token.NOT:\n         case Token.BITNOT:\n         case Token.POS:\n         case Token.NEG:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                 addExpr(first, NodeUtil.precedence(type));\n                 break;\n             }\n         case Token.HOOK:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 int p \u003d NodeUtil.precedence(type);\n                 addLeftExpr(first, p + 1, context);\n                 cc.addOp(\"?\", true);\n                 addExpr(first.getNext(), 1);\n                 cc.addOp(\":\", true);\n                 addExpr(last, 1);\n                 break;\n             }\n         case Token.REGEXP:\n             if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                 throw new Error(\"Expected children to be strings\");\n             }\n             String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n             if (childCount \u003d\u003d 2) {\n                 add(regexp + last.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 add(regexp);\n             }\n             break;\n         case Token.GET_REF:\n             add(first);\n             break;\n         case Token.REF_SPECIAL:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first);\n             add(\".\");\n             add((String) n.getProp(Node.NAME_PROP));\n             break;\n         case Token.FUNCTION:\n             if (n.getClass() !\u003d Node.class) {\n                 throw new Error(\"Unexpected Node subclass.\");\n             }\n             Preconditions.checkState(childCount \u003d\u003d 3);\n             boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n             if (funcNeedsParens) {\n                 add(\"(\");\n             }\n             add(\"function\");\n             add(first);\n             add(first.getNext());\n             add(last, Context.PRESERVE_BLOCK);\n             cc.endFunction(context \u003d\u003d Context.STATEMENT);\n             if (funcNeedsParens) {\n                 add(\")\");\n             }\n             break;\n         case Token.SCRIPT:\n         case Token.BLOCK:\n             {\n                 if (n.getClass() !\u003d Node.class) {\n                     throw new Error(\"Unexpected Node subclass.\");\n                 }\n                 boolean stripBlock \u003d n.isSyntheticBlock() || ((context !\u003d Context.PRESERVE_BLOCK) \u0026\u0026 (n.getChildCount() \u003c 2));\n                 if (!stripBlock) {\n                     cc.beginBlock();\n                 }\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     add(c, Context.STATEMENT);\n                     if (c.getType() \u003d\u003d Token.VAR) {\n                         cc.endStatement();\n                     }\n                     if (c.getType() \u003d\u003d Token.FUNCTION) {\n                         cc.maybeLineBreak();\n                     }\n                     if (type \u003d\u003d Token.SCRIPT) {\n                         cc.notePreferredLineBreak();\n                     }\n                 }\n                 if (!stripBlock) {\n                     cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                 }\n                 break;\n             }\n         case Token.FOR:\n             if (childCount \u003d\u003d 4) {\n                 add(\"for(\");\n                 if (first.getType() \u003d\u003d Token.VAR) {\n                     add(first, Context.IN_FOR_INIT_CLAUSE);\n                 } else {\n                     addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                 }\n                 add(\";\");\n                 add(first.getNext());\n                 add(\";\");\n                 add(first.getNext().getNext());\n                 add(\")\");\n                 addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 add(\"for(\");\n                 add(first);\n                 add(\"in\");\n                 add(first.getNext());\n                 add(\")\");\n                 addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             }\n             break;\n         case Token.DO:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"do\");\n             addNonEmptyExpression(first, Context.OTHER, false);\n             add(\"while(\");\n             add(last);\n             add(\")\");\n             cc.endStatement();\n             break;\n         case Token.WHILE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"while(\");\n             add(first);\n             add(\")\");\n             addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.EMPTY:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             break;\n         case Token.GETPROP:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                 Preconditions.checkState(last.getType() \u003d\u003d Token.STRING, \"Bad GETPROP: RHS should be STRING\");\n                 boolean needsParens \u003d (first.getType() \u003d\u003d Token.NUMBER);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 add(\".\");\n                 addIdentifier(last.getString());\n                 break;\n             }\n         case Token.GETELEM:\n             Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n             addLeftExpr(first, NodeUtil.precedence(type), context);\n             add(\"[\");\n             add(first.getNext());\n             add(\"]\");\n             break;\n         case Token.WITH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"with(\");\n             add(first);\n             add(\")\");\n             addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.INC:\n         case Token.DEC:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                 int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                 if (postProp !\u003d 0) {\n                     addLeftExpr(first, NodeUtil.precedence(type), context);\n                     cc.addOp(o, false);\n                 } else {\n                     cc.addOp(o, false);\n                     add(first);\n                 }\n                 break;\n             }\n         case Token.CALL:\n             if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) \u0026\u0026 NodeUtil.isGet(first)) {\n                 add(\"(0,\");\n                 addExpr(first, NodeUtil.precedence(Token.COMMA));\n                 add(\")\");\n             } else {\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n             }\n             add(\"(\");\n             addList(first.getNext());\n             add(\")\");\n             break;\n         case Token.IF:\n             boolean hasElse \u003d childCount \u003d\u003d 3;\n             boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n             if (ambiguousElseClause) {\n                 cc.beginBlock();\n             }\n             add(\"if(\");\n             add(first);\n             add(\")\");\n             if (hasElse) {\n                 addNonEmptyExpression(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                 add(\"else\");\n                 addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 addNonEmptyExpression(first.getNext(), Context.OTHER, false);\n                 Preconditions.checkState(childCount \u003d\u003d 2);\n             }\n             if (ambiguousElseClause) {\n                 cc.endBlock();\n             }\n             break;\n         case Token.NULL:\n         case Token.THIS:\n         case Token.FALSE:\n         case Token.TRUE:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(Node.tokenToName(type));\n             break;\n         case Token.CONTINUE:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"continue\");\n             if (childCount \u003d\u003d 1) {\n                 if (first.getType() !\u003d Token.LABEL_NAME) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.DEBUGGER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(\"debugger\");\n             cc.endStatement();\n             break;\n         case Token.BREAK:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"break\");\n             if (childCount \u003d\u003d 1) {\n                 if (first.getType() !\u003d Token.LABEL_NAME) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.EXPR_VOID:\n             throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n         case Token.EXPR_RESULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first, Context.START_OF_EXPR);\n             cc.endStatement();\n             break;\n         case Token.NEW:\n             add(\"new \");\n             int precedence \u003d NodeUtil.precedence(type);\n-            if (NodeUtil.containsCall(first)) {\n+            if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction())) {\n                 precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n             }\n             addExpr(first, precedence);\n             Node next \u003d first.getNext();\n             if (next !\u003d null) {\n                 add(\"(\");\n                 addList(next);\n                 add(\")\");\n             }\n             break;\n         case Token.STRING:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(jsString(n.getString(), outputCharsetEncoder));\n             break;\n         case Token.DELPROP:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"delete \");\n             add(first);\n             break;\n         case Token.OBJECTLIT:\n             {\n                 Preconditions.checkState(childCount % 2 \u003d\u003d 0);\n                 boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 add(\"{\");\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext().getNext()) {\n                     if (c !\u003d first) {\n                         cc.listSeparator();\n                     }\n                     if (c.getType() \u003d\u003d Token.STRING \u0026\u0026 !TokenStream.isKeyword(c.getString()) \u0026\u0026 TokenStream.isJSIdentifier(c.getString()) \u0026\u0026 NodeUtil.isLatin(c.getString())) {\n                         add(c.getString());\n                     } else {\n                         addExpr(c, 1);\n                     }\n                     add(\":\");\n                     addExpr(c.getNext(), 1);\n                 }\n                 add(\"}\");\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 break;\n             }\n         case Token.SWITCH:\n             add(\"switch(\");\n             add(first);\n             add(\")\");\n             cc.beginBlock();\n             addAllSiblings(first.getNext());\n             cc.endBlock(context \u003d\u003d Context.STATEMENT);\n             break;\n         case Token.CASE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"case \");\n             add(first);\n             addCaseBody(last);\n             break;\n         case Token.DEFAULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"default\");\n             addCaseBody(first);\n             break;\n         case Token.LABEL:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             if (first.getType() !\u003d Token.LABEL_NAME) {\n                 throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n             }\n             add(first);\n             add(\":\");\n             addNonEmptyExpression(last, getContextForNonEmptyExpression(context), true);\n             break;\n         case Token.SETNAME:\n             break;\n         default:\n             throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n     }\n     cc.endSourceMapping(n);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d7e85b0997ebb3d920c977de7a4a3f8ede5ba2d8": {
      "type": "Ybodychange",
      "commitMessage": "\nAdd basic \"free call\" annotation and support for issue 180.  Additional\ntesting is required to validate that new CALL nodes are not\ninappropriately introduced.\n\nAlso, refactored PrepareAst to make the different actions being taken\neasier to follow.\n\nR\u003dnicksantos\nDELTA\u003d215  (120 added, 18 deleted, 77 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d52003\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@282 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "7/15/10, 2:34 PM",
      "commitName": "d7e85b0997ebb3d920c977de7a4a3f8ede5ba2d8",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "7/15/10, 1:03 PM",
      "commitNameOld": "4d09ce45270187fa65a891e56081960a0ae449e5",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 0.06,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n        return;\n    }\n    int type \u003d n.getType();\n    String opstr \u003d NodeUtil.opToStr(type);\n    int childCount \u003d n.getChildCount();\n    Node first \u003d n.getFirstChild();\n    Node last \u003d n.getLastChild();\n    if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n        Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n        int p \u003d NodeUtil.precedence(type);\n        addLeftExpr(first, p, context);\n        cc.addOp(opstr, true);\n        Context rhsContext \u003d getContextForNoInOperator(context);\n        if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n            addExpr(last, p, rhsContext);\n        } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n            addExpr(last, p, rhsContext);\n        } else {\n            addExpr(last, p + 1, rhsContext);\n        }\n        return;\n    }\n    cc.startSourceMapping(n);\n    switch(type) {\n        case Token.TRY:\n            {\n                Preconditions.checkState(first.getNext().getType() \u003d\u003d Token.BLOCK \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n                Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                add(\"try\");\n                add(first, Context.PRESERVE_BLOCK);\n                Node catchblock \u003d first.getNext().getFirstChild();\n                if (catchblock !\u003d null) {\n                    add(catchblock);\n                }\n                if (childCount \u003d\u003d 3) {\n                    add(\"finally\");\n                    add(last, Context.PRESERVE_BLOCK);\n                }\n                break;\n            }\n        case Token.CATCH:\n            Preconditions.checkState(childCount \u003d\u003d 3);\n            if (first.getNext().getType() !\u003d Token.EMPTY) {\n                throw new Error(\"Catch conditions not suppored because I think\" + \" that it may be a netscape only feature.\");\n            }\n            add(\"catch(\");\n            add(first);\n            add(\")\");\n            add(last, Context.PRESERVE_BLOCK);\n            break;\n        case Token.THROW:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"throw\");\n            add(first);\n            cc.endStatement(true);\n            break;\n        case Token.RETURN:\n            add(\"return\");\n            if (childCount \u003d\u003d 1) {\n                add(first);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 0);\n            }\n            cc.endStatement();\n            break;\n        case Token.VAR:\n            if (first !\u003d null) {\n                add(\"var \");\n                addList(first, false, getContextForNoInOperator(context));\n            }\n            break;\n        case Token.LABEL_NAME:\n            Preconditions.checkState(!n.getString().isEmpty());\n            addIdentifier(n.getString());\n            break;\n        case Token.NAME:\n            if (first \u003d\u003d null || first.getType() \u003d\u003d Token.EMPTY) {\n                addIdentifier(n.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                addIdentifier(n.getString());\n                cc.addOp(\"\u003d\", true);\n                if (first.getType() \u003d\u003d Token.COMMA) {\n                    addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                } else {\n                    addExpr(first, 0, getContextForNoInOperator(context));\n                }\n            }\n            break;\n        case Token.ARRAYLIT:\n            add(\"[\");\n            addList(first, (int[]) n.getProp(Node.SKIP_INDEXES_PROP));\n            add(\"]\");\n            break;\n        case Token.LP:\n            add(\"(\");\n            addList(first);\n            add(\")\");\n            break;\n        case Token.COMMA:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            addList(first, false, context);\n            break;\n        case Token.NUMBER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            cc.addNumber(n.getDouble());\n            break;\n        case Token.TYPEOF:\n        case Token.VOID:\n        case Token.NOT:\n        case Token.BITNOT:\n        case Token.POS:\n        case Token.NEG:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                addExpr(first, NodeUtil.precedence(type));\n                break;\n            }\n        case Token.HOOK:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                int p \u003d NodeUtil.precedence(type);\n                addLeftExpr(first, p + 1, context);\n                cc.addOp(\"?\", true);\n                addExpr(first.getNext(), 1);\n                cc.addOp(\":\", true);\n                addExpr(last, 1);\n                break;\n            }\n        case Token.REGEXP:\n            if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                throw new Error(\"Expected children to be strings\");\n            }\n            String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n            if (childCount \u003d\u003d 2) {\n                add(regexp + last.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                add(regexp);\n            }\n            break;\n        case Token.GET_REF:\n            add(first);\n            break;\n        case Token.REF_SPECIAL:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first);\n            add(\".\");\n            add((String) n.getProp(Node.NAME_PROP));\n            break;\n        case Token.FUNCTION:\n            if (n.getClass() !\u003d Node.class) {\n                throw new Error(\"Unexpected Node subclass.\");\n            }\n            Preconditions.checkState(childCount \u003d\u003d 3);\n            boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n            if (funcNeedsParens) {\n                add(\"(\");\n            }\n            add(\"function\");\n            add(first);\n            add(first.getNext());\n            add(last, Context.PRESERVE_BLOCK);\n            cc.endFunction(context \u003d\u003d Context.STATEMENT);\n            if (funcNeedsParens) {\n                add(\")\");\n            }\n            break;\n        case Token.SCRIPT:\n        case Token.BLOCK:\n            {\n                if (n.getClass() !\u003d Node.class) {\n                    throw new Error(\"Unexpected Node subclass.\");\n                }\n                boolean stripBlock \u003d n.isSyntheticBlock() || ((context !\u003d Context.PRESERVE_BLOCK) \u0026\u0026 (n.getChildCount() \u003c 2));\n                if (!stripBlock) {\n                    cc.beginBlock();\n                }\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    add(c, Context.STATEMENT);\n                    if (c.getType() \u003d\u003d Token.VAR) {\n                        cc.endStatement();\n                    }\n                    if (c.getType() \u003d\u003d Token.FUNCTION) {\n                        cc.maybeLineBreak();\n                    }\n                    if (type \u003d\u003d Token.SCRIPT) {\n                        cc.notePreferredLineBreak();\n                    }\n                }\n                if (!stripBlock) {\n                    cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                }\n                break;\n            }\n        case Token.FOR:\n            if (childCount \u003d\u003d 4) {\n                add(\"for(\");\n                if (first.getType() \u003d\u003d Token.VAR) {\n                    add(first, Context.IN_FOR_INIT_CLAUSE);\n                } else {\n                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                }\n                add(\";\");\n                add(first.getNext());\n                add(\";\");\n                add(first.getNext().getNext());\n                add(\")\");\n                addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                add(\"for(\");\n                add(first);\n                add(\"in\");\n                add(first.getNext());\n                add(\")\");\n                addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            }\n            break;\n        case Token.DO:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"do\");\n            addNonEmptyExpression(first, Context.OTHER, false);\n            add(\"while(\");\n            add(last);\n            add(\")\");\n            cc.endStatement();\n            break;\n        case Token.WHILE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"while(\");\n            add(first);\n            add(\")\");\n            addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.EMPTY:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            break;\n        case Token.GETPROP:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                Preconditions.checkState(last.getType() \u003d\u003d Token.STRING, \"Bad GETPROP: RHS should be STRING\");\n                boolean needsParens \u003d (first.getType() \u003d\u003d Token.NUMBER);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n                if (needsParens) {\n                    add(\")\");\n                }\n                add(\".\");\n                addIdentifier(last.getString());\n                break;\n            }\n        case Token.GETELEM:\n            Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n            addLeftExpr(first, NodeUtil.precedence(type), context);\n            add(\"[\");\n            add(first.getNext());\n            add(\"]\");\n            break;\n        case Token.WITH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"with(\");\n            add(first);\n            add(\")\");\n            addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.INC:\n        case Token.DEC:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                if (postProp !\u003d 0) {\n                    addLeftExpr(first, NodeUtil.precedence(type), context);\n                    cc.addOp(o, false);\n                } else {\n                    cc.addOp(o, false);\n                    add(first);\n                }\n                break;\n            }\n        case Token.CALL:\n            if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) \u0026\u0026 NodeUtil.isGet(first)) {\n                add(\"(0,\");\n                addExpr(first, NodeUtil.precedence(Token.COMMA));\n                add(\")\");\n            } else {\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n            }\n            add(\"(\");\n            addList(first.getNext());\n            add(\")\");\n            break;\n        case Token.IF:\n            boolean hasElse \u003d childCount \u003d\u003d 3;\n            boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n            if (ambiguousElseClause) {\n                cc.beginBlock();\n            }\n            add(\"if(\");\n            add(first);\n            add(\")\");\n            if (hasElse) {\n                addNonEmptyExpression(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                add(\"else\");\n                addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                addNonEmptyExpression(first.getNext(), Context.OTHER, false);\n                Preconditions.checkState(childCount \u003d\u003d 2);\n            }\n            if (ambiguousElseClause) {\n                cc.endBlock();\n            }\n            break;\n        case Token.NULL:\n        case Token.THIS:\n        case Token.FALSE:\n        case Token.TRUE:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(Node.tokenToName(type));\n            break;\n        case Token.CONTINUE:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"continue\");\n            if (childCount \u003d\u003d 1) {\n                if (first.getType() !\u003d Token.LABEL_NAME) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.DEBUGGER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"debugger\");\n            cc.endStatement();\n            break;\n        case Token.BREAK:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"break\");\n            if (childCount \u003d\u003d 1) {\n                if (first.getType() !\u003d Token.LABEL_NAME) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.EXPR_VOID:\n            throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n        case Token.EXPR_RESULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first, Context.START_OF_EXPR);\n            cc.endStatement();\n            break;\n        case Token.NEW:\n            add(\"new \");\n            int precedence \u003d NodeUtil.precedence(type);\n            if (NodeUtil.containsCall(first)) {\n                precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n            }\n            addExpr(first, precedence);\n            Node next \u003d first.getNext();\n            if (next !\u003d null) {\n                add(\"(\");\n                addList(next);\n                add(\")\");\n            }\n            break;\n        case Token.STRING:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(jsString(n.getString(), outputCharsetEncoder));\n            break;\n        case Token.DELPROP:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"delete \");\n            add(first);\n            break;\n        case Token.OBJECTLIT:\n            {\n                Preconditions.checkState(childCount % 2 \u003d\u003d 0);\n                boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                add(\"{\");\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext().getNext()) {\n                    if (c !\u003d first) {\n                        cc.listSeparator();\n                    }\n                    if (c.getType() \u003d\u003d Token.STRING \u0026\u0026 !TokenStream.isKeyword(c.getString()) \u0026\u0026 TokenStream.isJSIdentifier(c.getString()) \u0026\u0026 NodeUtil.isLatin(c.getString())) {\n                        add(c.getString());\n                    } else {\n                        addExpr(c, 1);\n                    }\n                    add(\":\");\n                    addExpr(c.getNext(), 1);\n                }\n                add(\"}\");\n                if (needsParens) {\n                    add(\")\");\n                }\n                break;\n            }\n        case Token.SWITCH:\n            add(\"switch(\");\n            add(first);\n            add(\")\");\n            cc.beginBlock();\n            addAllSiblings(first.getNext());\n            cc.endBlock(context \u003d\u003d Context.STATEMENT);\n            break;\n        case Token.CASE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"case \");\n            add(first);\n            addCaseBody(last);\n            break;\n        case Token.DEFAULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"default\");\n            addCaseBody(first);\n            break;\n        case Token.LABEL:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            if (first.getType() !\u003d Token.LABEL_NAME) {\n                throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n            }\n            add(first);\n            add(\":\");\n            addNonEmptyExpression(last, getContextForNonEmptyExpression(context), true);\n            break;\n        case Token.SETNAME:\n            break;\n        default:\n            throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n    cc.endSourceMapping(n);\n}",
      "path": "src/com/google/javascript/jscomp/CodeGenerator.java",
      "functionStartLine": 76,
      "functionName": "add",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,444 +1,446 @@\n void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n         return;\n     }\n     int type \u003d n.getType();\n     String opstr \u003d NodeUtil.opToStr(type);\n     int childCount \u003d n.getChildCount();\n     Node first \u003d n.getFirstChild();\n     Node last \u003d n.getLastChild();\n     if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n         Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n         int p \u003d NodeUtil.precedence(type);\n         addLeftExpr(first, p, context);\n         cc.addOp(opstr, true);\n         Context rhsContext \u003d getContextForNoInOperator(context);\n         if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n             addExpr(last, p, rhsContext);\n         } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n             addExpr(last, p, rhsContext);\n         } else {\n             addExpr(last, p + 1, rhsContext);\n         }\n         return;\n     }\n     cc.startSourceMapping(n);\n     switch(type) {\n         case Token.TRY:\n             {\n                 Preconditions.checkState(first.getNext().getType() \u003d\u003d Token.BLOCK \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n                 Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                 add(\"try\");\n                 add(first, Context.PRESERVE_BLOCK);\n                 Node catchblock \u003d first.getNext().getFirstChild();\n                 if (catchblock !\u003d null) {\n                     add(catchblock);\n                 }\n                 if (childCount \u003d\u003d 3) {\n                     add(\"finally\");\n                     add(last, Context.PRESERVE_BLOCK);\n                 }\n                 break;\n             }\n         case Token.CATCH:\n             Preconditions.checkState(childCount \u003d\u003d 3);\n             if (first.getNext().getType() !\u003d Token.EMPTY) {\n                 throw new Error(\"Catch conditions not suppored because I think\" + \" that it may be a netscape only feature.\");\n             }\n             add(\"catch(\");\n             add(first);\n             add(\")\");\n             add(last, Context.PRESERVE_BLOCK);\n             break;\n         case Token.THROW:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"throw\");\n             add(first);\n             cc.endStatement(true);\n             break;\n         case Token.RETURN:\n             add(\"return\");\n             if (childCount \u003d\u003d 1) {\n                 add(first);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 0);\n             }\n             cc.endStatement();\n             break;\n         case Token.VAR:\n             if (first !\u003d null) {\n                 add(\"var \");\n                 addList(first, false, getContextForNoInOperator(context));\n             }\n             break;\n         case Token.LABEL_NAME:\n             Preconditions.checkState(!n.getString().isEmpty());\n             addIdentifier(n.getString());\n             break;\n         case Token.NAME:\n             if (first \u003d\u003d null || first.getType() \u003d\u003d Token.EMPTY) {\n                 addIdentifier(n.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 addIdentifier(n.getString());\n                 cc.addOp(\"\u003d\", true);\n                 if (first.getType() \u003d\u003d Token.COMMA) {\n                     addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                 } else {\n                     addExpr(first, 0, getContextForNoInOperator(context));\n                 }\n             }\n             break;\n         case Token.ARRAYLIT:\n             add(\"[\");\n             addList(first, (int[]) n.getProp(Node.SKIP_INDEXES_PROP));\n             add(\"]\");\n             break;\n         case Token.LP:\n             add(\"(\");\n             addList(first);\n             add(\")\");\n             break;\n         case Token.COMMA:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             addList(first, false, context);\n             break;\n         case Token.NUMBER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             cc.addNumber(n.getDouble());\n             break;\n         case Token.TYPEOF:\n         case Token.VOID:\n         case Token.NOT:\n         case Token.BITNOT:\n         case Token.POS:\n         case Token.NEG:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                 addExpr(first, NodeUtil.precedence(type));\n                 break;\n             }\n         case Token.HOOK:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 int p \u003d NodeUtil.precedence(type);\n                 addLeftExpr(first, p + 1, context);\n                 cc.addOp(\"?\", true);\n                 addExpr(first.getNext(), 1);\n                 cc.addOp(\":\", true);\n                 addExpr(last, 1);\n                 break;\n             }\n         case Token.REGEXP:\n             if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                 throw new Error(\"Expected children to be strings\");\n             }\n             String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n             if (childCount \u003d\u003d 2) {\n                 add(regexp + last.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 add(regexp);\n             }\n             break;\n         case Token.GET_REF:\n             add(first);\n             break;\n         case Token.REF_SPECIAL:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first);\n             add(\".\");\n             add((String) n.getProp(Node.NAME_PROP));\n             break;\n         case Token.FUNCTION:\n             if (n.getClass() !\u003d Node.class) {\n                 throw new Error(\"Unexpected Node subclass.\");\n             }\n             Preconditions.checkState(childCount \u003d\u003d 3);\n             boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n             if (funcNeedsParens) {\n                 add(\"(\");\n             }\n             add(\"function\");\n             add(first);\n             add(first.getNext());\n             add(last, Context.PRESERVE_BLOCK);\n             cc.endFunction(context \u003d\u003d Context.STATEMENT);\n             if (funcNeedsParens) {\n                 add(\")\");\n             }\n             break;\n         case Token.SCRIPT:\n         case Token.BLOCK:\n             {\n                 if (n.getClass() !\u003d Node.class) {\n                     throw new Error(\"Unexpected Node subclass.\");\n                 }\n                 boolean stripBlock \u003d n.isSyntheticBlock() || ((context !\u003d Context.PRESERVE_BLOCK) \u0026\u0026 (n.getChildCount() \u003c 2));\n                 if (!stripBlock) {\n                     cc.beginBlock();\n                 }\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     add(c, Context.STATEMENT);\n                     if (c.getType() \u003d\u003d Token.VAR) {\n                         cc.endStatement();\n                     }\n                     if (c.getType() \u003d\u003d Token.FUNCTION) {\n                         cc.maybeLineBreak();\n                     }\n                     if (type \u003d\u003d Token.SCRIPT) {\n                         cc.notePreferredLineBreak();\n                     }\n                 }\n                 if (!stripBlock) {\n                     cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                 }\n                 break;\n             }\n         case Token.FOR:\n             if (childCount \u003d\u003d 4) {\n                 add(\"for(\");\n                 if (first.getType() \u003d\u003d Token.VAR) {\n                     add(first, Context.IN_FOR_INIT_CLAUSE);\n                 } else {\n                     addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                 }\n                 add(\";\");\n                 add(first.getNext());\n                 add(\";\");\n                 add(first.getNext().getNext());\n                 add(\")\");\n                 addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 add(\"for(\");\n                 add(first);\n                 add(\"in\");\n                 add(first.getNext());\n                 add(\")\");\n                 addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             }\n             break;\n         case Token.DO:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"do\");\n             addNonEmptyExpression(first, Context.OTHER, false);\n             add(\"while(\");\n             add(last);\n             add(\")\");\n             cc.endStatement();\n             break;\n         case Token.WHILE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"while(\");\n             add(first);\n             add(\")\");\n             addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.EMPTY:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             break;\n         case Token.GETPROP:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                 Preconditions.checkState(last.getType() \u003d\u003d Token.STRING, \"Bad GETPROP: RHS should be STRING\");\n                 boolean needsParens \u003d (first.getType() \u003d\u003d Token.NUMBER);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 add(\".\");\n                 addIdentifier(last.getString());\n                 break;\n             }\n         case Token.GETELEM:\n             Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n             addLeftExpr(first, NodeUtil.precedence(type), context);\n             add(\"[\");\n             add(first.getNext());\n             add(\"]\");\n             break;\n         case Token.WITH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"with(\");\n             add(first);\n             add(\")\");\n             addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.INC:\n         case Token.DEC:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                 int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                 if (postProp !\u003d 0) {\n                     addLeftExpr(first, NodeUtil.precedence(type), context);\n                     cc.addOp(o, false);\n                 } else {\n                     cc.addOp(o, false);\n                     add(first);\n                 }\n                 break;\n             }\n         case Token.CALL:\n-            if (first.getType() \u003d\u003d Token.NAME \u0026\u0026 \"eval\".equals(first.getString()) \u0026\u0026 !first.getBooleanProp(Node.DIRECT_EVAL)) {\n-                add(\"(0,eval)\");\n+            if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) \u0026\u0026 NodeUtil.isGet(first)) {\n+                add(\"(0,\");\n+                addExpr(first, NodeUtil.precedence(Token.COMMA));\n+                add(\")\");\n             } else {\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n             }\n             add(\"(\");\n             addList(first.getNext());\n             add(\")\");\n             break;\n         case Token.IF:\n             boolean hasElse \u003d childCount \u003d\u003d 3;\n             boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n             if (ambiguousElseClause) {\n                 cc.beginBlock();\n             }\n             add(\"if(\");\n             add(first);\n             add(\")\");\n             if (hasElse) {\n                 addNonEmptyExpression(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                 add(\"else\");\n                 addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 addNonEmptyExpression(first.getNext(), Context.OTHER, false);\n                 Preconditions.checkState(childCount \u003d\u003d 2);\n             }\n             if (ambiguousElseClause) {\n                 cc.endBlock();\n             }\n             break;\n         case Token.NULL:\n         case Token.THIS:\n         case Token.FALSE:\n         case Token.TRUE:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(Node.tokenToName(type));\n             break;\n         case Token.CONTINUE:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"continue\");\n             if (childCount \u003d\u003d 1) {\n                 if (first.getType() !\u003d Token.LABEL_NAME) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.DEBUGGER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(\"debugger\");\n             cc.endStatement();\n             break;\n         case Token.BREAK:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"break\");\n             if (childCount \u003d\u003d 1) {\n                 if (first.getType() !\u003d Token.LABEL_NAME) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.EXPR_VOID:\n             throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n         case Token.EXPR_RESULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first, Context.START_OF_EXPR);\n             cc.endStatement();\n             break;\n         case Token.NEW:\n             add(\"new \");\n             int precedence \u003d NodeUtil.precedence(type);\n             if (NodeUtil.containsCall(first)) {\n                 precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n             }\n             addExpr(first, precedence);\n             Node next \u003d first.getNext();\n             if (next !\u003d null) {\n                 add(\"(\");\n                 addList(next);\n                 add(\")\");\n             }\n             break;\n         case Token.STRING:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(jsString(n.getString(), outputCharsetEncoder));\n             break;\n         case Token.DELPROP:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"delete \");\n             add(first);\n             break;\n         case Token.OBJECTLIT:\n             {\n                 Preconditions.checkState(childCount % 2 \u003d\u003d 0);\n                 boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 add(\"{\");\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext().getNext()) {\n                     if (c !\u003d first) {\n                         cc.listSeparator();\n                     }\n                     if (c.getType() \u003d\u003d Token.STRING \u0026\u0026 !TokenStream.isKeyword(c.getString()) \u0026\u0026 TokenStream.isJSIdentifier(c.getString()) \u0026\u0026 NodeUtil.isLatin(c.getString())) {\n                         add(c.getString());\n                     } else {\n                         addExpr(c, 1);\n                     }\n                     add(\":\");\n                     addExpr(c.getNext(), 1);\n                 }\n                 add(\"}\");\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 break;\n             }\n         case Token.SWITCH:\n             add(\"switch(\");\n             add(first);\n             add(\")\");\n             cc.beginBlock();\n             addAllSiblings(first.getNext());\n             cc.endBlock(context \u003d\u003d Context.STATEMENT);\n             break;\n         case Token.CASE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"case \");\n             add(first);\n             addCaseBody(last);\n             break;\n         case Token.DEFAULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"default\");\n             addCaseBody(first);\n             break;\n         case Token.LABEL:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             if (first.getType() !\u003d Token.LABEL_NAME) {\n                 throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n             }\n             add(first);\n             add(\":\");\n             addNonEmptyExpression(last, getContextForNonEmptyExpression(context), true);\n             break;\n         case Token.SETNAME:\n             break;\n         default:\n             throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n     }\n     cc.endSourceMapping(n);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3c4504a78a84e4715439cddb4028c25be2ce308f": {
      "type": "Ybodychange",
      "commitMessage": "\nChange on 2010/07/13 17:21:32 by dhans\n\n        A few optimizations which replace getChildCount with more efficient functions for Node class.\n\n        R\u003djohnlenz\n        DELTA\u003d13  (2 added, 0 deleted, 11 changed)\n\nChange on 2010/07/13 18:08:42 by johnlenz\n\n        Add info for newly json.jar to README\n\n        R\u003dnicksantos\n        DELTA\u003d13  (13 added, 0 deleted, 0 changed)\n\nChange on 2010/07/14 08:51:02 by johnlenz\n\n        Attempt to add \"@nosideeffects\" to appropriate dom methods.\n\n        R\u003dgboyer\n        DELTA\u003d93  (91 added, 0 deleted, 2 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d48012\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@276 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "7/14/10, 10:45 AM",
      "commitName": "3c4504a78a84e4715439cddb4028c25be2ce308f",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "7/1/10, 7:38 AM",
      "commitNameOld": "9de5e9b4671773bb3f2d5932e57c1b4186b9b777",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 13.13,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "actualSource": "void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n        return;\n    }\n    int type \u003d n.getType();\n    String opstr \u003d NodeUtil.opToStr(type);\n    int childCount \u003d n.getChildCount();\n    Node first \u003d n.getFirstChild();\n    Node last \u003d n.getLastChild();\n    if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n        Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n        int p \u003d NodeUtil.precedence(type);\n        addLeftExpr(first, p, context);\n        cc.addOp(opstr, true);\n        Context rhsContext \u003d getContextForNoInOperator(context);\n        if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n            addExpr(last, p, rhsContext);\n        } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n            addExpr(last, p, rhsContext);\n        } else {\n            addExpr(last, p + 1, rhsContext);\n        }\n        return;\n    }\n    cc.startSourceMapping(n);\n    switch(type) {\n        case Token.TRY:\n            {\n                Preconditions.checkState(first.getNext().getType() \u003d\u003d Token.BLOCK \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n                Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                add(\"try\");\n                add(first, Context.PRESERVE_BLOCK);\n                Node catchblock \u003d first.getNext().getFirstChild();\n                if (catchblock !\u003d null) {\n                    add(catchblock);\n                }\n                if (childCount \u003d\u003d 3) {\n                    add(\"finally\");\n                    add(last, Context.PRESERVE_BLOCK);\n                }\n                break;\n            }\n        case Token.CATCH:\n            Preconditions.checkState(childCount \u003d\u003d 3);\n            if (first.getNext().getType() !\u003d Token.EMPTY) {\n                throw new Error(\"Catch conditions not suppored because I think\" + \" that it may be a netscape only feature.\");\n            }\n            add(\"catch(\");\n            add(first);\n            add(\")\");\n            add(last, Context.PRESERVE_BLOCK);\n            break;\n        case Token.THROW:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"throw\");\n            add(first);\n            cc.endStatement(true);\n            break;\n        case Token.RETURN:\n            add(\"return\");\n            if (childCount \u003d\u003d 1) {\n                add(first);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 0);\n            }\n            cc.endStatement();\n            break;\n        case Token.VAR:\n            if (first !\u003d null) {\n                add(\"var \");\n                addList(first, false, getContextForNoInOperator(context));\n            }\n            break;\n        case Token.LABEL_NAME:\n            Preconditions.checkState(!n.getString().isEmpty());\n            addIdentifier(n.getString());\n            break;\n        case Token.NAME:\n            if (first \u003d\u003d null || first.getType() \u003d\u003d Token.EMPTY) {\n                addIdentifier(n.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                addIdentifier(n.getString());\n                cc.addOp(\"\u003d\", true);\n                if (first.getType() \u003d\u003d Token.COMMA) {\n                    addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                } else {\n                    addExpr(first, 0, getContextForNoInOperator(context));\n                }\n            }\n            break;\n        case Token.ARRAYLIT:\n            add(\"[\");\n            addList(first, (int[]) n.getProp(Node.SKIP_INDEXES_PROP));\n            add(\"]\");\n            break;\n        case Token.LP:\n            add(\"(\");\n            addList(first);\n            add(\")\");\n            break;\n        case Token.COMMA:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            addList(first, false, context);\n            break;\n        case Token.NUMBER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            cc.addNumber(n.getDouble());\n            break;\n        case Token.TYPEOF:\n        case Token.VOID:\n        case Token.NOT:\n        case Token.BITNOT:\n        case Token.POS:\n        case Token.NEG:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                addExpr(first, NodeUtil.precedence(type));\n                break;\n            }\n        case Token.HOOK:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                int p \u003d NodeUtil.precedence(type);\n                addLeftExpr(first, p + 1, context);\n                cc.addOp(\"?\", true);\n                addExpr(first.getNext(), 1);\n                cc.addOp(\":\", true);\n                addExpr(last, 1);\n                break;\n            }\n        case Token.REGEXP:\n            if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                throw new Error(\"Expected children to be strings\");\n            }\n            String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n            if (childCount \u003d\u003d 2) {\n                add(regexp + last.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                add(regexp);\n            }\n            break;\n        case Token.GET_REF:\n            add(first);\n            break;\n        case Token.REF_SPECIAL:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first);\n            add(\".\");\n            add((String) n.getProp(Node.NAME_PROP));\n            break;\n        case Token.FUNCTION:\n            if (n.getClass() !\u003d Node.class) {\n                throw new Error(\"Unexpected Node subclass.\");\n            }\n            Preconditions.checkState(childCount \u003d\u003d 3);\n            boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n            if (funcNeedsParens) {\n                add(\"(\");\n            }\n            add(\"function\");\n            add(first);\n            add(first.getNext());\n            add(last, Context.PRESERVE_BLOCK);\n            cc.endFunction(context \u003d\u003d Context.STATEMENT);\n            if (funcNeedsParens) {\n                add(\")\");\n            }\n            break;\n        case Token.SCRIPT:\n        case Token.BLOCK:\n            {\n                if (n.getClass() !\u003d Node.class) {\n                    throw new Error(\"Unexpected Node subclass.\");\n                }\n                boolean stripBlock \u003d n.isSyntheticBlock() || ((context !\u003d Context.PRESERVE_BLOCK) \u0026\u0026 (n.getChildCount() \u003c 2));\n                if (!stripBlock) {\n                    cc.beginBlock();\n                }\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    add(c, Context.STATEMENT);\n                    if (c.getType() \u003d\u003d Token.VAR) {\n                        cc.endStatement();\n                    }\n                    if (c.getType() \u003d\u003d Token.FUNCTION) {\n                        cc.maybeLineBreak();\n                    }\n                    if (type \u003d\u003d Token.SCRIPT) {\n                        cc.notePreferredLineBreak();\n                    }\n                }\n                if (!stripBlock) {\n                    cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                }\n                break;\n            }\n        case Token.FOR:\n            if (childCount \u003d\u003d 4) {\n                add(\"for(\");\n                if (first.getType() \u003d\u003d Token.VAR) {\n                    add(first, Context.IN_FOR_INIT_CLAUSE);\n                } else {\n                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                }\n                add(\";\");\n                add(first.getNext());\n                add(\";\");\n                add(first.getNext().getNext());\n                add(\")\");\n                addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                add(\"for(\");\n                add(first);\n                add(\"in\");\n                add(first.getNext());\n                add(\")\");\n                addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            }\n            break;\n        case Token.DO:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"do\");\n            addNonEmptyExpression(first, Context.OTHER, false);\n            add(\"while(\");\n            add(last);\n            add(\")\");\n            cc.endStatement();\n            break;\n        case Token.WHILE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"while(\");\n            add(first);\n            add(\")\");\n            addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.EMPTY:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            break;\n        case Token.GETPROP:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                Preconditions.checkState(last.getType() \u003d\u003d Token.STRING, \"Bad GETPROP: RHS should be STRING\");\n                boolean needsParens \u003d (first.getType() \u003d\u003d Token.NUMBER);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n                if (needsParens) {\n                    add(\")\");\n                }\n                add(\".\");\n                addIdentifier(last.getString());\n                break;\n            }\n        case Token.GETELEM:\n            Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n            addLeftExpr(first, NodeUtil.precedence(type), context);\n            add(\"[\");\n            add(first.getNext());\n            add(\"]\");\n            break;\n        case Token.WITH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"with(\");\n            add(first);\n            add(\")\");\n            addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.INC:\n        case Token.DEC:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                if (postProp !\u003d 0) {\n                    addLeftExpr(first, NodeUtil.precedence(type), context);\n                    cc.addOp(o, false);\n                } else {\n                    cc.addOp(o, false);\n                    add(first);\n                }\n                break;\n            }\n        case Token.CALL:\n            if (first.getType() \u003d\u003d Token.NAME \u0026\u0026 \"eval\".equals(first.getString()) \u0026\u0026 !first.getBooleanProp(Node.DIRECT_EVAL)) {\n                add(\"(0,eval)\");\n            } else {\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n            }\n            add(\"(\");\n            addList(first.getNext());\n            add(\")\");\n            break;\n        case Token.IF:\n            boolean hasElse \u003d childCount \u003d\u003d 3;\n            boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n            if (ambiguousElseClause) {\n                cc.beginBlock();\n            }\n            add(\"if(\");\n            add(first);\n            add(\")\");\n            if (hasElse) {\n                addNonEmptyExpression(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                add(\"else\");\n                addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                addNonEmptyExpression(first.getNext(), Context.OTHER, false);\n                Preconditions.checkState(childCount \u003d\u003d 2);\n            }\n            if (ambiguousElseClause) {\n                cc.endBlock();\n            }\n            break;\n        case Token.NULL:\n        case Token.THIS:\n        case Token.FALSE:\n        case Token.TRUE:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(Node.tokenToName(type));\n            break;\n        case Token.CONTINUE:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"continue\");\n            if (childCount \u003d\u003d 1) {\n                if (first.getType() !\u003d Token.LABEL_NAME) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.DEBUGGER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"debugger\");\n            cc.endStatement();\n            break;\n        case Token.BREAK:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"break\");\n            if (childCount \u003d\u003d 1) {\n                if (first.getType() !\u003d Token.LABEL_NAME) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.EXPR_VOID:\n            throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n        case Token.EXPR_RESULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first, Context.START_OF_EXPR);\n            cc.endStatement();\n            break;\n        case Token.NEW:\n            add(\"new \");\n            int precedence \u003d NodeUtil.precedence(type);\n            if (NodeUtil.containsCall(first)) {\n                precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n            }\n            addExpr(first, precedence);\n            Node next \u003d first.getNext();\n            if (next !\u003d null) {\n                add(\"(\");\n                addList(next);\n                add(\")\");\n            }\n            break;\n        case Token.STRING:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(jsString(n.getString(), outputCharsetEncoder));\n            break;\n        case Token.DELPROP:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"delete \");\n            add(first);\n            break;\n        case Token.OBJECTLIT:\n            {\n                Preconditions.checkState(childCount % 2 \u003d\u003d 0);\n                boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                add(\"{\");\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext().getNext()) {\n                    if (c !\u003d first) {\n                        cc.listSeparator();\n                    }\n                    if (c.getType() \u003d\u003d Token.STRING \u0026\u0026 !TokenStream.isKeyword(c.getString()) \u0026\u0026 TokenStream.isJSIdentifier(c.getString()) \u0026\u0026 NodeUtil.isLatin(c.getString())) {\n                        add(c.getString());\n                    } else {\n                        addExpr(c, 1);\n                    }\n                    add(\":\");\n                    addExpr(c.getNext(), 1);\n                }\n                add(\"}\");\n                if (needsParens) {\n                    add(\")\");\n                }\n                break;\n            }\n        case Token.SWITCH:\n            add(\"switch(\");\n            add(first);\n            add(\")\");\n            cc.beginBlock();\n            addAllSiblings(first.getNext());\n            cc.endBlock(context \u003d\u003d Context.STATEMENT);\n            break;\n        case Token.CASE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"case \");\n            add(first);\n            addCaseBody(last);\n            break;\n        case Token.DEFAULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"default\");\n            addCaseBody(first);\n            break;\n        case Token.LABEL:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            if (first.getType() !\u003d Token.LABEL_NAME) {\n                throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n            }\n            add(first);\n            add(\":\");\n            addNonEmptyExpression(last, getContextForNonEmptyExpression(context), true);\n            break;\n        case Token.SETNAME:\n            break;\n        default:\n            throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n    cc.endSourceMapping(n);\n}",
      "path": "src/com/google/javascript/jscomp/CodeGenerator.java",
      "functionStartLine": 76,
      "functionName": "add",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,444 +1,444 @@\n void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n         return;\n     }\n     int type \u003d n.getType();\n     String opstr \u003d NodeUtil.opToStr(type);\n     int childCount \u003d n.getChildCount();\n     Node first \u003d n.getFirstChild();\n     Node last \u003d n.getLastChild();\n     if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n         Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n         int p \u003d NodeUtil.precedence(type);\n         addLeftExpr(first, p, context);\n         cc.addOp(opstr, true);\n         Context rhsContext \u003d getContextForNoInOperator(context);\n         if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n             addExpr(last, p, rhsContext);\n         } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n             addExpr(last, p, rhsContext);\n         } else {\n             addExpr(last, p + 1, rhsContext);\n         }\n         return;\n     }\n     cc.startSourceMapping(n);\n     switch(type) {\n         case Token.TRY:\n             {\n-                Preconditions.checkState(first.getNext().getType() \u003d\u003d Token.BLOCK \u0026\u0026 first.getNext().getChildCount() \u003c\u003d 1);\n+                Preconditions.checkState(first.getNext().getType() \u003d\u003d Token.BLOCK \u0026\u0026 !first.getNext().hasMoreThanOneChild());\n                 Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                 add(\"try\");\n                 add(first, Context.PRESERVE_BLOCK);\n                 Node catchblock \u003d first.getNext().getFirstChild();\n                 if (catchblock !\u003d null) {\n                     add(catchblock);\n                 }\n                 if (childCount \u003d\u003d 3) {\n                     add(\"finally\");\n                     add(last, Context.PRESERVE_BLOCK);\n                 }\n                 break;\n             }\n         case Token.CATCH:\n             Preconditions.checkState(childCount \u003d\u003d 3);\n             if (first.getNext().getType() !\u003d Token.EMPTY) {\n                 throw new Error(\"Catch conditions not suppored because I think\" + \" that it may be a netscape only feature.\");\n             }\n             add(\"catch(\");\n             add(first);\n             add(\")\");\n             add(last, Context.PRESERVE_BLOCK);\n             break;\n         case Token.THROW:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"throw\");\n             add(first);\n             cc.endStatement(true);\n             break;\n         case Token.RETURN:\n             add(\"return\");\n             if (childCount \u003d\u003d 1) {\n                 add(first);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 0);\n             }\n             cc.endStatement();\n             break;\n         case Token.VAR:\n             if (first !\u003d null) {\n                 add(\"var \");\n                 addList(first, false, getContextForNoInOperator(context));\n             }\n             break;\n         case Token.LABEL_NAME:\n             Preconditions.checkState(!n.getString().isEmpty());\n             addIdentifier(n.getString());\n             break;\n         case Token.NAME:\n             if (first \u003d\u003d null || first.getType() \u003d\u003d Token.EMPTY) {\n                 addIdentifier(n.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 addIdentifier(n.getString());\n                 cc.addOp(\"\u003d\", true);\n                 if (first.getType() \u003d\u003d Token.COMMA) {\n                     addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                 } else {\n                     addExpr(first, 0, getContextForNoInOperator(context));\n                 }\n             }\n             break;\n         case Token.ARRAYLIT:\n             add(\"[\");\n             addList(first, (int[]) n.getProp(Node.SKIP_INDEXES_PROP));\n             add(\"]\");\n             break;\n         case Token.LP:\n             add(\"(\");\n             addList(first);\n             add(\")\");\n             break;\n         case Token.COMMA:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             addList(first, false, context);\n             break;\n         case Token.NUMBER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             cc.addNumber(n.getDouble());\n             break;\n         case Token.TYPEOF:\n         case Token.VOID:\n         case Token.NOT:\n         case Token.BITNOT:\n         case Token.POS:\n         case Token.NEG:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                 addExpr(first, NodeUtil.precedence(type));\n                 break;\n             }\n         case Token.HOOK:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 int p \u003d NodeUtil.precedence(type);\n                 addLeftExpr(first, p + 1, context);\n                 cc.addOp(\"?\", true);\n                 addExpr(first.getNext(), 1);\n                 cc.addOp(\":\", true);\n                 addExpr(last, 1);\n                 break;\n             }\n         case Token.REGEXP:\n             if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                 throw new Error(\"Expected children to be strings\");\n             }\n             String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n             if (childCount \u003d\u003d 2) {\n                 add(regexp + last.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 add(regexp);\n             }\n             break;\n         case Token.GET_REF:\n             add(first);\n             break;\n         case Token.REF_SPECIAL:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first);\n             add(\".\");\n             add((String) n.getProp(Node.NAME_PROP));\n             break;\n         case Token.FUNCTION:\n             if (n.getClass() !\u003d Node.class) {\n                 throw new Error(\"Unexpected Node subclass.\");\n             }\n             Preconditions.checkState(childCount \u003d\u003d 3);\n             boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n             if (funcNeedsParens) {\n                 add(\"(\");\n             }\n             add(\"function\");\n             add(first);\n             add(first.getNext());\n             add(last, Context.PRESERVE_BLOCK);\n             cc.endFunction(context \u003d\u003d Context.STATEMENT);\n             if (funcNeedsParens) {\n                 add(\")\");\n             }\n             break;\n         case Token.SCRIPT:\n         case Token.BLOCK:\n             {\n                 if (n.getClass() !\u003d Node.class) {\n                     throw new Error(\"Unexpected Node subclass.\");\n                 }\n                 boolean stripBlock \u003d n.isSyntheticBlock() || ((context !\u003d Context.PRESERVE_BLOCK) \u0026\u0026 (n.getChildCount() \u003c 2));\n                 if (!stripBlock) {\n                     cc.beginBlock();\n                 }\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     add(c, Context.STATEMENT);\n                     if (c.getType() \u003d\u003d Token.VAR) {\n                         cc.endStatement();\n                     }\n                     if (c.getType() \u003d\u003d Token.FUNCTION) {\n                         cc.maybeLineBreak();\n                     }\n                     if (type \u003d\u003d Token.SCRIPT) {\n                         cc.notePreferredLineBreak();\n                     }\n                 }\n                 if (!stripBlock) {\n                     cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                 }\n                 break;\n             }\n         case Token.FOR:\n             if (childCount \u003d\u003d 4) {\n                 add(\"for(\");\n                 if (first.getType() \u003d\u003d Token.VAR) {\n                     add(first, Context.IN_FOR_INIT_CLAUSE);\n                 } else {\n                     addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                 }\n                 add(\";\");\n                 add(first.getNext());\n                 add(\";\");\n                 add(first.getNext().getNext());\n                 add(\")\");\n                 addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 add(\"for(\");\n                 add(first);\n                 add(\"in\");\n                 add(first.getNext());\n                 add(\")\");\n                 addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             }\n             break;\n         case Token.DO:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"do\");\n             addNonEmptyExpression(first, Context.OTHER, false);\n             add(\"while(\");\n             add(last);\n             add(\")\");\n             cc.endStatement();\n             break;\n         case Token.WHILE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"while(\");\n             add(first);\n             add(\")\");\n             addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.EMPTY:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             break;\n         case Token.GETPROP:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                 Preconditions.checkState(last.getType() \u003d\u003d Token.STRING, \"Bad GETPROP: RHS should be STRING\");\n                 boolean needsParens \u003d (first.getType() \u003d\u003d Token.NUMBER);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 add(\".\");\n                 addIdentifier(last.getString());\n                 break;\n             }\n         case Token.GETELEM:\n             Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n             addLeftExpr(first, NodeUtil.precedence(type), context);\n             add(\"[\");\n             add(first.getNext());\n             add(\"]\");\n             break;\n         case Token.WITH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"with(\");\n             add(first);\n             add(\")\");\n             addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.INC:\n         case Token.DEC:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                 int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                 if (postProp !\u003d 0) {\n                     addLeftExpr(first, NodeUtil.precedence(type), context);\n                     cc.addOp(o, false);\n                 } else {\n                     cc.addOp(o, false);\n                     add(first);\n                 }\n                 break;\n             }\n         case Token.CALL:\n             if (first.getType() \u003d\u003d Token.NAME \u0026\u0026 \"eval\".equals(first.getString()) \u0026\u0026 !first.getBooleanProp(Node.DIRECT_EVAL)) {\n                 add(\"(0,eval)\");\n             } else {\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n             }\n             add(\"(\");\n             addList(first.getNext());\n             add(\")\");\n             break;\n         case Token.IF:\n             boolean hasElse \u003d childCount \u003d\u003d 3;\n             boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n             if (ambiguousElseClause) {\n                 cc.beginBlock();\n             }\n             add(\"if(\");\n             add(first);\n             add(\")\");\n             if (hasElse) {\n                 addNonEmptyExpression(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                 add(\"else\");\n                 addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 addNonEmptyExpression(first.getNext(), Context.OTHER, false);\n                 Preconditions.checkState(childCount \u003d\u003d 2);\n             }\n             if (ambiguousElseClause) {\n                 cc.endBlock();\n             }\n             break;\n         case Token.NULL:\n         case Token.THIS:\n         case Token.FALSE:\n         case Token.TRUE:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(Node.tokenToName(type));\n             break;\n         case Token.CONTINUE:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"continue\");\n             if (childCount \u003d\u003d 1) {\n                 if (first.getType() !\u003d Token.LABEL_NAME) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.DEBUGGER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(\"debugger\");\n             cc.endStatement();\n             break;\n         case Token.BREAK:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"break\");\n             if (childCount \u003d\u003d 1) {\n                 if (first.getType() !\u003d Token.LABEL_NAME) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.EXPR_VOID:\n             throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n         case Token.EXPR_RESULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first, Context.START_OF_EXPR);\n             cc.endStatement();\n             break;\n         case Token.NEW:\n             add(\"new \");\n             int precedence \u003d NodeUtil.precedence(type);\n             if (NodeUtil.containsCall(first)) {\n                 precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n             }\n             addExpr(first, precedence);\n             Node next \u003d first.getNext();\n             if (next !\u003d null) {\n                 add(\"(\");\n                 addList(next);\n                 add(\")\");\n             }\n             break;\n         case Token.STRING:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(jsString(n.getString(), outputCharsetEncoder));\n             break;\n         case Token.DELPROP:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"delete \");\n             add(first);\n             break;\n         case Token.OBJECTLIT:\n             {\n                 Preconditions.checkState(childCount % 2 \u003d\u003d 0);\n                 boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 add(\"{\");\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext().getNext()) {\n                     if (c !\u003d first) {\n                         cc.listSeparator();\n                     }\n                     if (c.getType() \u003d\u003d Token.STRING \u0026\u0026 !TokenStream.isKeyword(c.getString()) \u0026\u0026 TokenStream.isJSIdentifier(c.getString()) \u0026\u0026 NodeUtil.isLatin(c.getString())) {\n                         add(c.getString());\n                     } else {\n                         addExpr(c, 1);\n                     }\n                     add(\":\");\n                     addExpr(c.getNext(), 1);\n                 }\n                 add(\"}\");\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 break;\n             }\n         case Token.SWITCH:\n             add(\"switch(\");\n             add(first);\n             add(\")\");\n             cc.beginBlock();\n             addAllSiblings(first.getNext());\n             cc.endBlock(context \u003d\u003d Context.STATEMENT);\n             break;\n         case Token.CASE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"case \");\n             add(first);\n             addCaseBody(last);\n             break;\n         case Token.DEFAULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"default\");\n             addCaseBody(first);\n             break;\n         case Token.LABEL:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             if (first.getType() !\u003d Token.LABEL_NAME) {\n                 throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n             }\n             add(first);\n             add(\":\");\n             addNonEmptyExpression(last, getContextForNonEmptyExpression(context), true);\n             break;\n         case Token.SETNAME:\n             break;\n         default:\n             throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n     }\n     cc.endSourceMapping(n);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9925370292834ea846727f1f9db76af0d40261df": {
      "type": "Ybodychange",
      "commitMessage": "\nChange on 2010/06/28 12:25:08 by dcc\n\n        Split up FoldConstants unit tests.\n\n        R\u003dacleung\n        DELTA\u003d2778  (1508 added, 1270 deleted, 0 changed)\n\nChange on 2010/06/28 15:47:46 by johnlenz\n\n        Prevent COMMAs with more than two children.\n\n        R\u003dacleung\n        DELTA\u003d1  (1 added, 0 deleted, 0 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d44002\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@257 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "6/28/10, 5:30 PM",
      "commitName": "9925370292834ea846727f1f9db76af0d40261df",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "6/25/10, 4:56 PM",
      "commitNameOld": "dff6e0114f19c20aeb63393d67aa0880ff5745b5",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 3.02,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n        return;\n    }\n    int type \u003d n.getType();\n    String opstr \u003d NodeUtil.opToStr(type);\n    int childCount \u003d n.getChildCount();\n    Node first \u003d n.getFirstChild();\n    Node last \u003d n.getLastChild();\n    if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n        Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n        int p \u003d NodeUtil.precedence(type);\n        addLeftExpr(first, p, context);\n        cc.addOp(opstr, true);\n        Context rhsContext \u003d getContextForNoInOperator(context);\n        if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n            addExpr(last, p, rhsContext);\n        } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n            addExpr(last, p, rhsContext);\n        } else {\n            addExpr(last, p + 1, rhsContext);\n        }\n        return;\n    }\n    cc.startSourceMapping(n);\n    switch(type) {\n        case Token.TRY:\n            {\n                Preconditions.checkState(first.getNext().getType() \u003d\u003d Token.BLOCK \u0026\u0026 first.getNext().getChildCount() \u003c\u003d 1);\n                Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                add(\"try\");\n                add(first, Context.PRESERVE_BLOCK);\n                Node catchblock \u003d first.getNext().getFirstChild();\n                if (catchblock !\u003d null) {\n                    add(catchblock);\n                }\n                if (childCount \u003d\u003d 3) {\n                    add(\"finally\");\n                    add(last, Context.PRESERVE_BLOCK);\n                }\n                break;\n            }\n        case Token.CATCH:\n            Preconditions.checkState(childCount \u003d\u003d 3);\n            if (first.getNext().getType() !\u003d Token.EMPTY) {\n                throw new Error(\"Catch conditions not suppored because I think\" + \" that it may be a netscape only feature.\");\n            }\n            add(\"catch(\");\n            add(first);\n            add(\")\");\n            add(last, Context.PRESERVE_BLOCK);\n            break;\n        case Token.THROW:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"throw\");\n            add(first);\n            cc.endStatement(true);\n            break;\n        case Token.RETURN:\n            add(\"return\");\n            if (childCount \u003d\u003d 1) {\n                add(first);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 0);\n            }\n            cc.endStatement();\n            break;\n        case Token.VAR:\n            if (first !\u003d null) {\n                add(\"var \");\n                addList(first, false, getContextForNoInOperator(context));\n            }\n            break;\n        case Token.LABEL_NAME:\n            Preconditions.checkState(!n.getString().isEmpty());\n            addIdentifier(n.getString());\n            break;\n        case Token.NAME:\n            if (first \u003d\u003d null || first.getType() \u003d\u003d Token.EMPTY) {\n                addIdentifier(n.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                addIdentifier(n.getString());\n                cc.addOp(\"\u003d\", true);\n                if (first.getType() \u003d\u003d Token.COMMA) {\n                    addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                } else {\n                    addExpr(first, 0, getContextForNoInOperator(context));\n                }\n            }\n            break;\n        case Token.ARRAYLIT:\n            add(\"[\");\n            addList(first, (int[]) n.getProp(Node.SKIP_INDEXES_PROP));\n            add(\"]\");\n            break;\n        case Token.LP:\n            add(\"(\");\n            addList(first);\n            add(\")\");\n            break;\n        case Token.COMMA:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            addList(first, false, context);\n            break;\n        case Token.NUMBER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            cc.addNumber(n.getDouble());\n            break;\n        case Token.TYPEOF:\n        case Token.VOID:\n        case Token.NOT:\n        case Token.BITNOT:\n        case Token.POS:\n        case Token.NEG:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                addExpr(first, NodeUtil.precedence(type));\n                break;\n            }\n        case Token.HOOK:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                int p \u003d NodeUtil.precedence(type);\n                addLeftExpr(first, p + 1, context);\n                cc.addOp(\"?\", true);\n                addExpr(first.getNext(), 1);\n                cc.addOp(\":\", true);\n                addExpr(last, 1);\n                break;\n            }\n        case Token.REGEXP:\n            if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                throw new Error(\"Expected children to be strings\");\n            }\n            String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n            if (childCount \u003d\u003d 2) {\n                add(regexp + last.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                add(regexp);\n            }\n            break;\n        case Token.GET_REF:\n            add(first);\n            break;\n        case Token.REF_SPECIAL:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first);\n            add(\".\");\n            add((String) n.getProp(Node.NAME_PROP));\n            break;\n        case Token.FUNCTION:\n            if (n.getClass() !\u003d Node.class) {\n                throw new Error(\"Unexpected Node subclass.\");\n            }\n            Preconditions.checkState(childCount \u003d\u003d 3);\n            boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n            if (funcNeedsParens) {\n                add(\"(\");\n            }\n            add(\"function\");\n            add(first);\n            add(first.getNext());\n            add(last, Context.PRESERVE_BLOCK);\n            cc.endFunction(context \u003d\u003d Context.STATEMENT);\n            if (funcNeedsParens) {\n                add(\")\");\n            }\n            break;\n        case Token.SCRIPT:\n        case Token.BLOCK:\n            {\n                if (n.getClass() !\u003d Node.class) {\n                    throw new Error(\"Unexpected Node subclass.\");\n                }\n                boolean stripBlock \u003d n.isSyntheticBlock() || ((context !\u003d Context.PRESERVE_BLOCK) \u0026\u0026 (n.getChildCount() \u003c 2));\n                if (!stripBlock) {\n                    cc.beginBlock();\n                }\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    add(c, Context.STATEMENT);\n                    if (c.getType() \u003d\u003d Token.VAR) {\n                        cc.endStatement();\n                    }\n                    if (c.getType() \u003d\u003d Token.FUNCTION) {\n                        cc.maybeLineBreak();\n                    }\n                    if (type \u003d\u003d Token.SCRIPT) {\n                        cc.notePreferredLineBreak();\n                    }\n                }\n                if (!stripBlock) {\n                    cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                }\n                break;\n            }\n        case Token.FOR:\n            if (childCount \u003d\u003d 4) {\n                add(\"for(\");\n                if (first.getType() \u003d\u003d Token.VAR) {\n                    add(first, Context.IN_FOR_INIT_CLAUSE);\n                } else {\n                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                }\n                add(\";\");\n                add(first.getNext());\n                add(\";\");\n                add(first.getNext().getNext());\n                add(\")\");\n                addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                add(\"for(\");\n                add(first);\n                add(\"in\");\n                add(first.getNext());\n                add(\")\");\n                addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            }\n            break;\n        case Token.DO:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"do\");\n            addNonEmptyExpression(first, Context.OTHER, false);\n            add(\"while(\");\n            add(last);\n            add(\")\");\n            cc.endStatement();\n            break;\n        case Token.WHILE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"while(\");\n            add(first);\n            add(\")\");\n            addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.EMPTY:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            break;\n        case Token.GETPROP:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                Preconditions.checkState(last.getType() \u003d\u003d Token.STRING, \"Bad GETPROP: RHS should be STRING\");\n                boolean needsParens \u003d (first.getType() \u003d\u003d Token.NUMBER);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n                if (needsParens) {\n                    add(\")\");\n                }\n                add(\".\");\n                addIdentifier(last.getString());\n                break;\n            }\n        case Token.GETELEM:\n            Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n            addLeftExpr(first, NodeUtil.precedence(type), context);\n            add(\"[\");\n            add(first.getNext());\n            add(\"]\");\n            break;\n        case Token.WITH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"with(\");\n            add(first);\n            add(\")\");\n            addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.INC:\n        case Token.DEC:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                if (postProp !\u003d 0) {\n                    addLeftExpr(first, NodeUtil.precedence(type), context);\n                    cc.addOp(o, false);\n                } else {\n                    cc.addOp(o, false);\n                    add(first);\n                }\n                break;\n            }\n        case Token.CALL:\n            if (first.getType() \u003d\u003d Token.NAME \u0026\u0026 \"eval\".equals(first.getString()) \u0026\u0026 !first.getBooleanProp(Node.DIRECT_EVAL)) {\n                add(\"(0,eval)\");\n            } else {\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n            }\n            add(\"(\");\n            addList(first.getNext());\n            add(\")\");\n            break;\n        case Token.IF:\n            boolean hasElse \u003d childCount \u003d\u003d 3;\n            boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n            if (ambiguousElseClause) {\n                cc.beginBlock();\n            }\n            add(\"if(\");\n            add(first);\n            add(\")\");\n            if (hasElse) {\n                addNonEmptyExpression(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                add(\"else\");\n                addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                addNonEmptyExpression(first.getNext(), Context.OTHER, false);\n                Preconditions.checkState(childCount \u003d\u003d 2);\n            }\n            if (ambiguousElseClause) {\n                cc.endBlock();\n            }\n            break;\n        case Token.NULL:\n        case Token.THIS:\n        case Token.FALSE:\n        case Token.TRUE:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(Node.tokenToName(type));\n            break;\n        case Token.CONTINUE:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"continue\");\n            if (childCount \u003d\u003d 1) {\n                if (first.getType() !\u003d Token.LABEL_NAME) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.DEBUGGER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"debugger\");\n            cc.endStatement();\n            break;\n        case Token.BREAK:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"break\");\n            if (childCount \u003d\u003d 1) {\n                if (first.getType() !\u003d Token.LABEL_NAME) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.EXPR_VOID:\n            throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n        case Token.EXPR_RESULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first, Context.START_OF_EXPR);\n            cc.endStatement();\n            break;\n        case Token.NEW:\n            add(\"new \");\n            int precedence \u003d NodeUtil.precedence(type);\n            if (NodeUtil.containsCall(first)) {\n                precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n            }\n            addExpr(first, precedence);\n            Node next \u003d first.getNext();\n            if (next !\u003d null) {\n                add(\"(\");\n                addList(next);\n                add(\")\");\n            }\n            break;\n        case Token.STRING:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(jsString(n.getString(), outputCharsetEncoder));\n            break;\n        case Token.DELPROP:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"delete \");\n            add(first);\n            break;\n        case Token.OBJECTLIT:\n            {\n                Preconditions.checkState(childCount % 2 \u003d\u003d 0);\n                boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                add(\"{\");\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext().getNext()) {\n                    if (c !\u003d first) {\n                        cc.listSeparator();\n                    }\n                    if (c.getType() \u003d\u003d Token.STRING \u0026\u0026 !TokenStream.isKeyword(c.getString()) \u0026\u0026 TokenStream.isJSIdentifier(c.getString()) \u0026\u0026 NodeUtil.isLatin(c.getString())) {\n                        add(c.getString());\n                    } else {\n                        addExpr(c, 1);\n                    }\n                    add(\":\");\n                    addExpr(c.getNext(), 1);\n                }\n                add(\"}\");\n                if (needsParens) {\n                    add(\")\");\n                }\n                break;\n            }\n        case Token.SWITCH:\n            add(\"switch(\");\n            add(first);\n            add(\")\");\n            cc.beginBlock();\n            addAllSiblings(first.getNext());\n            cc.endBlock(context \u003d\u003d Context.STATEMENT);\n            break;\n        case Token.CASE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"case \");\n            add(first);\n            addCaseBody(last);\n            break;\n        case Token.DEFAULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"default\");\n            addCaseBody(first);\n            break;\n        case Token.LABEL:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            if (first.getType() !\u003d Token.LABEL_NAME) {\n                throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n            }\n            add(first);\n            add(\":\");\n            addNonEmptyExpression(last, getContextForNonEmptyExpression(context), true);\n            break;\n        case Token.SETNAME:\n            break;\n        default:\n            throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n    cc.endSourceMapping(n);\n}",
      "path": "src/com/google/javascript/jscomp/CodeGenerator.java",
      "functionStartLine": 76,
      "functionName": "add",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,443 +1,444 @@\n void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n         return;\n     }\n     int type \u003d n.getType();\n     String opstr \u003d NodeUtil.opToStr(type);\n     int childCount \u003d n.getChildCount();\n     Node first \u003d n.getFirstChild();\n     Node last \u003d n.getLastChild();\n     if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n         Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n         int p \u003d NodeUtil.precedence(type);\n         addLeftExpr(first, p, context);\n         cc.addOp(opstr, true);\n         Context rhsContext \u003d getContextForNoInOperator(context);\n         if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n             addExpr(last, p, rhsContext);\n         } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n             addExpr(last, p, rhsContext);\n         } else {\n             addExpr(last, p + 1, rhsContext);\n         }\n         return;\n     }\n     cc.startSourceMapping(n);\n     switch(type) {\n         case Token.TRY:\n             {\n                 Preconditions.checkState(first.getNext().getType() \u003d\u003d Token.BLOCK \u0026\u0026 first.getNext().getChildCount() \u003c\u003d 1);\n                 Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                 add(\"try\");\n                 add(first, Context.PRESERVE_BLOCK);\n                 Node catchblock \u003d first.getNext().getFirstChild();\n                 if (catchblock !\u003d null) {\n                     add(catchblock);\n                 }\n                 if (childCount \u003d\u003d 3) {\n                     add(\"finally\");\n                     add(last, Context.PRESERVE_BLOCK);\n                 }\n                 break;\n             }\n         case Token.CATCH:\n             Preconditions.checkState(childCount \u003d\u003d 3);\n             if (first.getNext().getType() !\u003d Token.EMPTY) {\n                 throw new Error(\"Catch conditions not suppored because I think\" + \" that it may be a netscape only feature.\");\n             }\n             add(\"catch(\");\n             add(first);\n             add(\")\");\n             add(last, Context.PRESERVE_BLOCK);\n             break;\n         case Token.THROW:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"throw\");\n             add(first);\n             cc.endStatement(true);\n             break;\n         case Token.RETURN:\n             add(\"return\");\n             if (childCount \u003d\u003d 1) {\n                 add(first);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 0);\n             }\n             cc.endStatement();\n             break;\n         case Token.VAR:\n             if (first !\u003d null) {\n                 add(\"var \");\n                 addList(first, false, getContextForNoInOperator(context));\n             }\n             break;\n         case Token.LABEL_NAME:\n             Preconditions.checkState(!n.getString().isEmpty());\n             addIdentifier(n.getString());\n             break;\n         case Token.NAME:\n             if (first \u003d\u003d null || first.getType() \u003d\u003d Token.EMPTY) {\n                 addIdentifier(n.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 addIdentifier(n.getString());\n                 cc.addOp(\"\u003d\", true);\n                 if (first.getType() \u003d\u003d Token.COMMA) {\n                     addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                 } else {\n                     addExpr(first, 0, getContextForNoInOperator(context));\n                 }\n             }\n             break;\n         case Token.ARRAYLIT:\n             add(\"[\");\n             addList(first, (int[]) n.getProp(Node.SKIP_INDEXES_PROP));\n             add(\"]\");\n             break;\n         case Token.LP:\n             add(\"(\");\n             addList(first);\n             add(\")\");\n             break;\n         case Token.COMMA:\n+            Preconditions.checkState(childCount \u003d\u003d 2);\n             addList(first, false, context);\n             break;\n         case Token.NUMBER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             cc.addNumber(n.getDouble());\n             break;\n         case Token.TYPEOF:\n         case Token.VOID:\n         case Token.NOT:\n         case Token.BITNOT:\n         case Token.POS:\n         case Token.NEG:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                 addExpr(first, NodeUtil.precedence(type));\n                 break;\n             }\n         case Token.HOOK:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 int p \u003d NodeUtil.precedence(type);\n                 addLeftExpr(first, p + 1, context);\n                 cc.addOp(\"?\", true);\n                 addExpr(first.getNext(), 1);\n                 cc.addOp(\":\", true);\n                 addExpr(last, 1);\n                 break;\n             }\n         case Token.REGEXP:\n             if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                 throw new Error(\"Expected children to be strings\");\n             }\n             String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n             if (childCount \u003d\u003d 2) {\n                 add(regexp + last.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 add(regexp);\n             }\n             break;\n         case Token.GET_REF:\n             add(first);\n             break;\n         case Token.REF_SPECIAL:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first);\n             add(\".\");\n             add((String) n.getProp(Node.NAME_PROP));\n             break;\n         case Token.FUNCTION:\n             if (n.getClass() !\u003d Node.class) {\n                 throw new Error(\"Unexpected Node subclass.\");\n             }\n             Preconditions.checkState(childCount \u003d\u003d 3);\n             boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n             if (funcNeedsParens) {\n                 add(\"(\");\n             }\n             add(\"function\");\n             add(first);\n             add(first.getNext());\n             add(last, Context.PRESERVE_BLOCK);\n             cc.endFunction(context \u003d\u003d Context.STATEMENT);\n             if (funcNeedsParens) {\n                 add(\")\");\n             }\n             break;\n         case Token.SCRIPT:\n         case Token.BLOCK:\n             {\n                 if (n.getClass() !\u003d Node.class) {\n                     throw new Error(\"Unexpected Node subclass.\");\n                 }\n                 boolean stripBlock \u003d n.isSyntheticBlock() || ((context !\u003d Context.PRESERVE_BLOCK) \u0026\u0026 (n.getChildCount() \u003c 2));\n                 if (!stripBlock) {\n                     cc.beginBlock();\n                 }\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     add(c, Context.STATEMENT);\n                     if (c.getType() \u003d\u003d Token.VAR) {\n                         cc.endStatement();\n                     }\n                     if (c.getType() \u003d\u003d Token.FUNCTION) {\n                         cc.maybeLineBreak();\n                     }\n                     if (type \u003d\u003d Token.SCRIPT) {\n                         cc.notePreferredLineBreak();\n                     }\n                 }\n                 if (!stripBlock) {\n                     cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                 }\n                 break;\n             }\n         case Token.FOR:\n             if (childCount \u003d\u003d 4) {\n                 add(\"for(\");\n                 if (first.getType() \u003d\u003d Token.VAR) {\n                     add(first, Context.IN_FOR_INIT_CLAUSE);\n                 } else {\n                     addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                 }\n                 add(\";\");\n                 add(first.getNext());\n                 add(\";\");\n                 add(first.getNext().getNext());\n                 add(\")\");\n                 addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 add(\"for(\");\n                 add(first);\n                 add(\"in\");\n                 add(first.getNext());\n                 add(\")\");\n                 addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             }\n             break;\n         case Token.DO:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"do\");\n             addNonEmptyExpression(first, Context.OTHER, false);\n             add(\"while(\");\n             add(last);\n             add(\")\");\n             cc.endStatement();\n             break;\n         case Token.WHILE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"while(\");\n             add(first);\n             add(\")\");\n             addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.EMPTY:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             break;\n         case Token.GETPROP:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                 Preconditions.checkState(last.getType() \u003d\u003d Token.STRING, \"Bad GETPROP: RHS should be STRING\");\n                 boolean needsParens \u003d (first.getType() \u003d\u003d Token.NUMBER);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 add(\".\");\n                 addIdentifier(last.getString());\n                 break;\n             }\n         case Token.GETELEM:\n             Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n             addLeftExpr(first, NodeUtil.precedence(type), context);\n             add(\"[\");\n             add(first.getNext());\n             add(\"]\");\n             break;\n         case Token.WITH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"with(\");\n             add(first);\n             add(\")\");\n             addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.INC:\n         case Token.DEC:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                 int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                 if (postProp !\u003d 0) {\n                     addLeftExpr(first, NodeUtil.precedence(type), context);\n                     cc.addOp(o, false);\n                 } else {\n                     cc.addOp(o, false);\n                     add(first);\n                 }\n                 break;\n             }\n         case Token.CALL:\n             if (first.getType() \u003d\u003d Token.NAME \u0026\u0026 \"eval\".equals(first.getString()) \u0026\u0026 !first.getBooleanProp(Node.DIRECT_EVAL)) {\n                 add(\"(0,eval)\");\n             } else {\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n             }\n             add(\"(\");\n             addList(first.getNext());\n             add(\")\");\n             break;\n         case Token.IF:\n             boolean hasElse \u003d childCount \u003d\u003d 3;\n             boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n             if (ambiguousElseClause) {\n                 cc.beginBlock();\n             }\n             add(\"if(\");\n             add(first);\n             add(\")\");\n             if (hasElse) {\n                 addNonEmptyExpression(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                 add(\"else\");\n                 addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 addNonEmptyExpression(first.getNext(), Context.OTHER, false);\n                 Preconditions.checkState(childCount \u003d\u003d 2);\n             }\n             if (ambiguousElseClause) {\n                 cc.endBlock();\n             }\n             break;\n         case Token.NULL:\n         case Token.THIS:\n         case Token.FALSE:\n         case Token.TRUE:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(Node.tokenToName(type));\n             break;\n         case Token.CONTINUE:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"continue\");\n             if (childCount \u003d\u003d 1) {\n                 if (first.getType() !\u003d Token.LABEL_NAME) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.DEBUGGER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(\"debugger\");\n             cc.endStatement();\n             break;\n         case Token.BREAK:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"break\");\n             if (childCount \u003d\u003d 1) {\n                 if (first.getType() !\u003d Token.LABEL_NAME) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.EXPR_VOID:\n             throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n         case Token.EXPR_RESULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first, Context.START_OF_EXPR);\n             cc.endStatement();\n             break;\n         case Token.NEW:\n             add(\"new \");\n             int precedence \u003d NodeUtil.precedence(type);\n             if (NodeUtil.containsCall(first)) {\n                 precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n             }\n             addExpr(first, precedence);\n             Node next \u003d first.getNext();\n             if (next !\u003d null) {\n                 add(\"(\");\n                 addList(next);\n                 add(\")\");\n             }\n             break;\n         case Token.STRING:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(jsString(n.getString(), outputCharsetEncoder));\n             break;\n         case Token.DELPROP:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"delete \");\n             add(first);\n             break;\n         case Token.OBJECTLIT:\n             {\n                 Preconditions.checkState(childCount % 2 \u003d\u003d 0);\n                 boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 add(\"{\");\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext().getNext()) {\n                     if (c !\u003d first) {\n                         cc.listSeparator();\n                     }\n                     if (c.getType() \u003d\u003d Token.STRING \u0026\u0026 !TokenStream.isKeyword(c.getString()) \u0026\u0026 TokenStream.isJSIdentifier(c.getString()) \u0026\u0026 NodeUtil.isLatin(c.getString())) {\n                         add(c.getString());\n                     } else {\n                         addExpr(c, 1);\n                     }\n                     add(\":\");\n                     addExpr(c.getNext(), 1);\n                 }\n                 add(\"}\");\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 break;\n             }\n         case Token.SWITCH:\n             add(\"switch(\");\n             add(first);\n             add(\")\");\n             cc.beginBlock();\n             addAllSiblings(first.getNext());\n             cc.endBlock(context \u003d\u003d Context.STATEMENT);\n             break;\n         case Token.CASE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"case \");\n             add(first);\n             addCaseBody(last);\n             break;\n         case Token.DEFAULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"default\");\n             addCaseBody(first);\n             break;\n         case Token.LABEL:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             if (first.getType() !\u003d Token.LABEL_NAME) {\n                 throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n             }\n             add(first);\n             add(\":\");\n             addNonEmptyExpression(last, getContextForNonEmptyExpression(context), true);\n             break;\n         case Token.SETNAME:\n             break;\n         default:\n             throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n     }\n     cc.endSourceMapping(n);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "dff6e0114f19c20aeb63393d67aa0880ff5745b5": {
      "type": "Yformatchange",
      "commitMessage": "\nChange on 2010/06/25 by johnlenz\n\n\tPreserve blocks around problematic labelled statements.\n\tFixes issue 190\n\n\tR\u003dnicksantos\n\tDELTA\u003d95  (86 added, 2 deleted, 7 changed)\n\nChange on 2010/06/25 by nicksantos\n\n\tmore descriptive error messaging for CheckReturns.\n\n\n\tR\u003dacleung\n\tDELTA\u003d59  (21 added, 2 deleted, 36 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d42001\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@255 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "6/25/10, 4:56 PM",
      "commitName": "dff6e0114f19c20aeb63393d67aa0880ff5745b5",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "6/25/10, 2:35 PM",
      "commitNameOld": "b1ffe42efdaaf0266b4ba10e05de124a885cf979",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n        return;\n    }\n    int type \u003d n.getType();\n    String opstr \u003d NodeUtil.opToStr(type);\n    int childCount \u003d n.getChildCount();\n    Node first \u003d n.getFirstChild();\n    Node last \u003d n.getLastChild();\n    if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n        Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n        int p \u003d NodeUtil.precedence(type);\n        addLeftExpr(first, p, context);\n        cc.addOp(opstr, true);\n        Context rhsContext \u003d getContextForNoInOperator(context);\n        if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n            addExpr(last, p, rhsContext);\n        } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n            addExpr(last, p, rhsContext);\n        } else {\n            addExpr(last, p + 1, rhsContext);\n        }\n        return;\n    }\n    cc.startSourceMapping(n);\n    switch(type) {\n        case Token.TRY:\n            {\n                Preconditions.checkState(first.getNext().getType() \u003d\u003d Token.BLOCK \u0026\u0026 first.getNext().getChildCount() \u003c\u003d 1);\n                Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                add(\"try\");\n                add(first, Context.PRESERVE_BLOCK);\n                Node catchblock \u003d first.getNext().getFirstChild();\n                if (catchblock !\u003d null) {\n                    add(catchblock);\n                }\n                if (childCount \u003d\u003d 3) {\n                    add(\"finally\");\n                    add(last, Context.PRESERVE_BLOCK);\n                }\n                break;\n            }\n        case Token.CATCH:\n            Preconditions.checkState(childCount \u003d\u003d 3);\n            if (first.getNext().getType() !\u003d Token.EMPTY) {\n                throw new Error(\"Catch conditions not suppored because I think\" + \" that it may be a netscape only feature.\");\n            }\n            add(\"catch(\");\n            add(first);\n            add(\")\");\n            add(last, Context.PRESERVE_BLOCK);\n            break;\n        case Token.THROW:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"throw\");\n            add(first);\n            cc.endStatement(true);\n            break;\n        case Token.RETURN:\n            add(\"return\");\n            if (childCount \u003d\u003d 1) {\n                add(first);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 0);\n            }\n            cc.endStatement();\n            break;\n        case Token.VAR:\n            if (first !\u003d null) {\n                add(\"var \");\n                addList(first, false, getContextForNoInOperator(context));\n            }\n            break;\n        case Token.LABEL_NAME:\n            Preconditions.checkState(!n.getString().isEmpty());\n            addIdentifier(n.getString());\n            break;\n        case Token.NAME:\n            if (first \u003d\u003d null || first.getType() \u003d\u003d Token.EMPTY) {\n                addIdentifier(n.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                addIdentifier(n.getString());\n                cc.addOp(\"\u003d\", true);\n                if (first.getType() \u003d\u003d Token.COMMA) {\n                    addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                } else {\n                    addExpr(first, 0, getContextForNoInOperator(context));\n                }\n            }\n            break;\n        case Token.ARRAYLIT:\n            add(\"[\");\n            addList(first, (int[]) n.getProp(Node.SKIP_INDEXES_PROP));\n            add(\"]\");\n            break;\n        case Token.LP:\n            add(\"(\");\n            addList(first);\n            add(\")\");\n            break;\n        case Token.COMMA:\n            addList(first, false, context);\n            break;\n        case Token.NUMBER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            cc.addNumber(n.getDouble());\n            break;\n        case Token.TYPEOF:\n        case Token.VOID:\n        case Token.NOT:\n        case Token.BITNOT:\n        case Token.POS:\n        case Token.NEG:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                addExpr(first, NodeUtil.precedence(type));\n                break;\n            }\n        case Token.HOOK:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                int p \u003d NodeUtil.precedence(type);\n                addLeftExpr(first, p + 1, context);\n                cc.addOp(\"?\", true);\n                addExpr(first.getNext(), 1);\n                cc.addOp(\":\", true);\n                addExpr(last, 1);\n                break;\n            }\n        case Token.REGEXP:\n            if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                throw new Error(\"Expected children to be strings\");\n            }\n            String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n            if (childCount \u003d\u003d 2) {\n                add(regexp + last.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                add(regexp);\n            }\n            break;\n        case Token.GET_REF:\n            add(first);\n            break;\n        case Token.REF_SPECIAL:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first);\n            add(\".\");\n            add((String) n.getProp(Node.NAME_PROP));\n            break;\n        case Token.FUNCTION:\n            if (n.getClass() !\u003d Node.class) {\n                throw new Error(\"Unexpected Node subclass.\");\n            }\n            Preconditions.checkState(childCount \u003d\u003d 3);\n            boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n            if (funcNeedsParens) {\n                add(\"(\");\n            }\n            add(\"function\");\n            add(first);\n            add(first.getNext());\n            add(last, Context.PRESERVE_BLOCK);\n            cc.endFunction(context \u003d\u003d Context.STATEMENT);\n            if (funcNeedsParens) {\n                add(\")\");\n            }\n            break;\n        case Token.SCRIPT:\n        case Token.BLOCK:\n            {\n                if (n.getClass() !\u003d Node.class) {\n                    throw new Error(\"Unexpected Node subclass.\");\n                }\n                boolean stripBlock \u003d n.isSyntheticBlock() || ((context !\u003d Context.PRESERVE_BLOCK) \u0026\u0026 (n.getChildCount() \u003c 2));\n                if (!stripBlock) {\n                    cc.beginBlock();\n                }\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    add(c, Context.STATEMENT);\n                    if (c.getType() \u003d\u003d Token.VAR) {\n                        cc.endStatement();\n                    }\n                    if (c.getType() \u003d\u003d Token.FUNCTION) {\n                        cc.maybeLineBreak();\n                    }\n                    if (type \u003d\u003d Token.SCRIPT) {\n                        cc.notePreferredLineBreak();\n                    }\n                }\n                if (!stripBlock) {\n                    cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                }\n                break;\n            }\n        case Token.FOR:\n            if (childCount \u003d\u003d 4) {\n                add(\"for(\");\n                if (first.getType() \u003d\u003d Token.VAR) {\n                    add(first, Context.IN_FOR_INIT_CLAUSE);\n                } else {\n                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                }\n                add(\";\");\n                add(first.getNext());\n                add(\";\");\n                add(first.getNext().getNext());\n                add(\")\");\n                addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                add(\"for(\");\n                add(first);\n                add(\"in\");\n                add(first.getNext());\n                add(\")\");\n                addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            }\n            break;\n        case Token.DO:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"do\");\n            addNonEmptyExpression(first, Context.OTHER, false);\n            add(\"while(\");\n            add(last);\n            add(\")\");\n            cc.endStatement();\n            break;\n        case Token.WHILE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"while(\");\n            add(first);\n            add(\")\");\n            addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.EMPTY:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            break;\n        case Token.GETPROP:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                Preconditions.checkState(last.getType() \u003d\u003d Token.STRING, \"Bad GETPROP: RHS should be STRING\");\n                boolean needsParens \u003d (first.getType() \u003d\u003d Token.NUMBER);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n                if (needsParens) {\n                    add(\")\");\n                }\n                add(\".\");\n                addIdentifier(last.getString());\n                break;\n            }\n        case Token.GETELEM:\n            Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n            addLeftExpr(first, NodeUtil.precedence(type), context);\n            add(\"[\");\n            add(first.getNext());\n            add(\"]\");\n            break;\n        case Token.WITH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"with(\");\n            add(first);\n            add(\")\");\n            addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.INC:\n        case Token.DEC:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                if (postProp !\u003d 0) {\n                    addLeftExpr(first, NodeUtil.precedence(type), context);\n                    cc.addOp(o, false);\n                } else {\n                    cc.addOp(o, false);\n                    add(first);\n                }\n                break;\n            }\n        case Token.CALL:\n            if (first.getType() \u003d\u003d Token.NAME \u0026\u0026 \"eval\".equals(first.getString()) \u0026\u0026 !first.getBooleanProp(Node.DIRECT_EVAL)) {\n                add(\"(0,eval)\");\n            } else {\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n            }\n            add(\"(\");\n            addList(first.getNext());\n            add(\")\");\n            break;\n        case Token.IF:\n            boolean hasElse \u003d childCount \u003d\u003d 3;\n            boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n            if (ambiguousElseClause) {\n                cc.beginBlock();\n            }\n            add(\"if(\");\n            add(first);\n            add(\")\");\n            if (hasElse) {\n                addNonEmptyExpression(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                add(\"else\");\n                addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                addNonEmptyExpression(first.getNext(), Context.OTHER, false);\n                Preconditions.checkState(childCount \u003d\u003d 2);\n            }\n            if (ambiguousElseClause) {\n                cc.endBlock();\n            }\n            break;\n        case Token.NULL:\n        case Token.THIS:\n        case Token.FALSE:\n        case Token.TRUE:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(Node.tokenToName(type));\n            break;\n        case Token.CONTINUE:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"continue\");\n            if (childCount \u003d\u003d 1) {\n                if (first.getType() !\u003d Token.LABEL_NAME) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.DEBUGGER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"debugger\");\n            cc.endStatement();\n            break;\n        case Token.BREAK:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"break\");\n            if (childCount \u003d\u003d 1) {\n                if (first.getType() !\u003d Token.LABEL_NAME) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.EXPR_VOID:\n            throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n        case Token.EXPR_RESULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first, Context.START_OF_EXPR);\n            cc.endStatement();\n            break;\n        case Token.NEW:\n            add(\"new \");\n            int precedence \u003d NodeUtil.precedence(type);\n            if (NodeUtil.containsCall(first)) {\n                precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n            }\n            addExpr(first, precedence);\n            Node next \u003d first.getNext();\n            if (next !\u003d null) {\n                add(\"(\");\n                addList(next);\n                add(\")\");\n            }\n            break;\n        case Token.STRING:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(jsString(n.getString(), outputCharsetEncoder));\n            break;\n        case Token.DELPROP:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"delete \");\n            add(first);\n            break;\n        case Token.OBJECTLIT:\n            {\n                Preconditions.checkState(childCount % 2 \u003d\u003d 0);\n                boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                add(\"{\");\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext().getNext()) {\n                    if (c !\u003d first) {\n                        cc.listSeparator();\n                    }\n                    if (c.getType() \u003d\u003d Token.STRING \u0026\u0026 !TokenStream.isKeyword(c.getString()) \u0026\u0026 TokenStream.isJSIdentifier(c.getString()) \u0026\u0026 NodeUtil.isLatin(c.getString())) {\n                        add(c.getString());\n                    } else {\n                        addExpr(c, 1);\n                    }\n                    add(\":\");\n                    addExpr(c.getNext(), 1);\n                }\n                add(\"}\");\n                if (needsParens) {\n                    add(\")\");\n                }\n                break;\n            }\n        case Token.SWITCH:\n            add(\"switch(\");\n            add(first);\n            add(\")\");\n            cc.beginBlock();\n            addAllSiblings(first.getNext());\n            cc.endBlock(context \u003d\u003d Context.STATEMENT);\n            break;\n        case Token.CASE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"case \");\n            add(first);\n            addCaseBody(last);\n            break;\n        case Token.DEFAULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"default\");\n            addCaseBody(first);\n            break;\n        case Token.LABEL:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            if (first.getType() !\u003d Token.LABEL_NAME) {\n                throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n            }\n            add(first);\n            add(\":\");\n            addNonEmptyExpression(last, getContextForNonEmptyExpression(context), true);\n            break;\n        case Token.SETNAME:\n            break;\n        default:\n            throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n    cc.endSourceMapping(n);\n}",
      "path": "src/com/google/javascript/jscomp/CodeGenerator.java",
      "functionStartLine": 76,
      "functionName": "add",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {}
    },
    "b1ffe42efdaaf0266b4ba10e05de124a885cf979": {
      "type": "Ybodychange",
      "commitMessage": "\n\nChange on 2010/06/25 by elnatan\n\n        Putting in a few informative error messages\n\n        R\u003djohnlenz\n        DELTA\u003d13  (9 added, 0 deleted, 4 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d40001\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@254 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "6/25/10, 2:35 PM",
      "commitName": "b1ffe42efdaaf0266b4ba10e05de124a885cf979",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "6/23/10, 12:21 PM",
      "commitNameOld": "07663b6946caa097ad92b5375e333936351e3256",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 2.09,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n        return;\n    }\n    int type \u003d n.getType();\n    String opstr \u003d NodeUtil.opToStr(type);\n    int childCount \u003d n.getChildCount();\n    Node first \u003d n.getFirstChild();\n    Node last \u003d n.getLastChild();\n    if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n        Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n        int p \u003d NodeUtil.precedence(type);\n        addLeftExpr(first, p, context);\n        cc.addOp(opstr, true);\n        Context rhsContext \u003d getContextForNoInOperator(context);\n        if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n            addExpr(last, p, rhsContext);\n        } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n            addExpr(last, p, rhsContext);\n        } else {\n            addExpr(last, p + 1, rhsContext);\n        }\n        return;\n    }\n    cc.startSourceMapping(n);\n    switch(type) {\n        case Token.TRY:\n            {\n                Preconditions.checkState(first.getNext().getType() \u003d\u003d Token.BLOCK \u0026\u0026 first.getNext().getChildCount() \u003c\u003d 1);\n                Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                add(\"try\");\n                add(first, Context.PRESERVE_BLOCK);\n                Node catchblock \u003d first.getNext().getFirstChild();\n                if (catchblock !\u003d null) {\n                    add(catchblock);\n                }\n                if (childCount \u003d\u003d 3) {\n                    add(\"finally\");\n                    add(last, Context.PRESERVE_BLOCK);\n                }\n                break;\n            }\n        case Token.CATCH:\n            Preconditions.checkState(childCount \u003d\u003d 3);\n            if (first.getNext().getType() !\u003d Token.EMPTY) {\n                throw new Error(\"Catch conditions not suppored because I think\" + \" that it may be a netscape only feature.\");\n            }\n            add(\"catch(\");\n            add(first);\n            add(\")\");\n            add(last, Context.PRESERVE_BLOCK);\n            break;\n        case Token.THROW:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"throw\");\n            add(first);\n            cc.endStatement(true);\n            break;\n        case Token.RETURN:\n            add(\"return\");\n            if (childCount \u003d\u003d 1) {\n                add(first);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 0);\n            }\n            cc.endStatement();\n            break;\n        case Token.VAR:\n            if (first !\u003d null) {\n                add(\"var \");\n                addList(first, false, getContextForNoInOperator(context));\n            }\n            break;\n        case Token.LABEL_NAME:\n            Preconditions.checkState(!n.getString().isEmpty());\n            addIdentifier(n.getString());\n            break;\n        case Token.NAME:\n            if (first \u003d\u003d null || first.getType() \u003d\u003d Token.EMPTY) {\n                addIdentifier(n.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                addIdentifier(n.getString());\n                cc.addOp(\"\u003d\", true);\n                if (first.getType() \u003d\u003d Token.COMMA) {\n                    addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                } else {\n                    addExpr(first, 0, getContextForNoInOperator(context));\n                }\n            }\n            break;\n        case Token.ARRAYLIT:\n            add(\"[\");\n            addList(first, (int[]) n.getProp(Node.SKIP_INDEXES_PROP));\n            add(\"]\");\n            break;\n        case Token.LP:\n            add(\"(\");\n            addList(first);\n            add(\")\");\n            break;\n        case Token.COMMA:\n            addList(first, false, context);\n            break;\n        case Token.NUMBER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            cc.addNumber(n.getDouble());\n            break;\n        case Token.TYPEOF:\n        case Token.VOID:\n        case Token.NOT:\n        case Token.BITNOT:\n        case Token.POS:\n        case Token.NEG:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                addExpr(first, NodeUtil.precedence(type));\n                break;\n            }\n        case Token.HOOK:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                int p \u003d NodeUtil.precedence(type);\n                addLeftExpr(first, p + 1, context);\n                cc.addOp(\"?\", true);\n                addExpr(first.getNext(), 1);\n                cc.addOp(\":\", true);\n                addExpr(last, 1);\n                break;\n            }\n        case Token.REGEXP:\n            if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                throw new Error(\"Expected children to be strings\");\n            }\n            String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n            if (childCount \u003d\u003d 2) {\n                add(regexp + last.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                add(regexp);\n            }\n            break;\n        case Token.GET_REF:\n            add(first);\n            break;\n        case Token.REF_SPECIAL:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first);\n            add(\".\");\n            add((String) n.getProp(Node.NAME_PROP));\n            break;\n        case Token.FUNCTION:\n            if (n.getClass() !\u003d Node.class) {\n                throw new Error(\"Unexpected Node subclass.\");\n            }\n            Preconditions.checkState(childCount \u003d\u003d 3);\n            boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n            if (funcNeedsParens) {\n                add(\"(\");\n            }\n            add(\"function\");\n            add(first);\n            add(first.getNext());\n            add(last, Context.PRESERVE_BLOCK);\n            cc.endFunction(context \u003d\u003d Context.STATEMENT);\n            if (funcNeedsParens) {\n                add(\")\");\n            }\n            break;\n        case Token.SCRIPT:\n        case Token.BLOCK:\n            {\n                if (n.getClass() !\u003d Node.class) {\n                    throw new Error(\"Unexpected Node subclass.\");\n                }\n                boolean stripBlock \u003d n.isSyntheticBlock() || ((context !\u003d Context.PRESERVE_BLOCK) \u0026\u0026 (n.getChildCount() \u003c 2));\n                if (!stripBlock) {\n                    cc.beginBlock();\n                }\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    add(c, Context.STATEMENT);\n                    if (c.getType() \u003d\u003d Token.VAR) {\n                        cc.endStatement();\n                    }\n                    if (c.getType() \u003d\u003d Token.FUNCTION) {\n                        cc.maybeLineBreak();\n                    }\n                    if (type \u003d\u003d Token.SCRIPT) {\n                        cc.notePreferredLineBreak();\n                    }\n                }\n                if (!stripBlock) {\n                    cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                }\n                break;\n            }\n        case Token.FOR:\n            if (childCount \u003d\u003d 4) {\n                add(\"for(\");\n                if (first.getType() \u003d\u003d Token.VAR) {\n                    add(first, Context.IN_FOR_INIT_CLAUSE);\n                } else {\n                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                }\n                add(\";\");\n                add(first.getNext());\n                add(\";\");\n                add(first.getNext().getNext());\n                add(\")\");\n                addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                add(\"for(\");\n                add(first);\n                add(\"in\");\n                add(first.getNext());\n                add(\")\");\n                addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            }\n            break;\n        case Token.DO:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"do\");\n            addNonEmptyExpression(first, Context.OTHER, false);\n            add(\"while(\");\n            add(last);\n            add(\")\");\n            cc.endStatement();\n            break;\n        case Token.WHILE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"while(\");\n            add(first);\n            add(\")\");\n            addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.EMPTY:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            break;\n        case Token.GETPROP:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n                Preconditions.checkState(last.getType() \u003d\u003d Token.STRING, \"Bad GETPROP: RHS should be STRING\");\n                boolean needsParens \u003d (first.getType() \u003d\u003d Token.NUMBER);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n                if (needsParens) {\n                    add(\")\");\n                }\n                add(\".\");\n                addIdentifier(last.getString());\n                break;\n            }\n        case Token.GETELEM:\n            Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n            addLeftExpr(first, NodeUtil.precedence(type), context);\n            add(\"[\");\n            add(first.getNext());\n            add(\"]\");\n            break;\n        case Token.WITH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"with(\");\n            add(first);\n            add(\")\");\n            addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.INC:\n        case Token.DEC:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                if (postProp !\u003d 0) {\n                    addLeftExpr(first, NodeUtil.precedence(type), context);\n                    cc.addOp(o, false);\n                } else {\n                    cc.addOp(o, false);\n                    add(first);\n                }\n                break;\n            }\n        case Token.CALL:\n            if (first.getType() \u003d\u003d Token.NAME \u0026\u0026 \"eval\".equals(first.getString()) \u0026\u0026 !first.getBooleanProp(Node.DIRECT_EVAL)) {\n                add(\"(0,eval)\");\n            } else {\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n            }\n            add(\"(\");\n            addList(first.getNext());\n            add(\")\");\n            break;\n        case Token.IF:\n            boolean hasElse \u003d childCount \u003d\u003d 3;\n            boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n            if (ambiguousElseClause) {\n                cc.beginBlock();\n            }\n            add(\"if(\");\n            add(first);\n            add(\")\");\n            if (hasElse) {\n                addNonEmptyExpression(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                add(\"else\");\n                addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                addNonEmptyExpression(first.getNext(), Context.OTHER, false);\n                Preconditions.checkState(childCount \u003d\u003d 2);\n            }\n            if (ambiguousElseClause) {\n                cc.endBlock();\n            }\n            break;\n        case Token.NULL:\n        case Token.THIS:\n        case Token.FALSE:\n        case Token.TRUE:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(Node.tokenToName(type));\n            break;\n        case Token.CONTINUE:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"continue\");\n            if (childCount \u003d\u003d 1) {\n                if (first.getType() !\u003d Token.LABEL_NAME) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.DEBUGGER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"debugger\");\n            cc.endStatement();\n            break;\n        case Token.BREAK:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"break\");\n            if (childCount \u003d\u003d 1) {\n                if (first.getType() !\u003d Token.LABEL_NAME) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.EXPR_VOID:\n            throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n        case Token.EXPR_RESULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first, Context.START_OF_EXPR);\n            cc.endStatement();\n            break;\n        case Token.NEW:\n            add(\"new \");\n            int precedence \u003d NodeUtil.precedence(type);\n            if (NodeUtil.containsCall(first)) {\n                precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n            }\n            addExpr(first, precedence);\n            Node next \u003d first.getNext();\n            if (next !\u003d null) {\n                add(\"(\");\n                addList(next);\n                add(\")\");\n            }\n            break;\n        case Token.STRING:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(jsString(n.getString(), outputCharsetEncoder));\n            break;\n        case Token.DELPROP:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"delete \");\n            add(first);\n            break;\n        case Token.OBJECTLIT:\n            {\n                Preconditions.checkState(childCount % 2 \u003d\u003d 0);\n                boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                add(\"{\");\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext().getNext()) {\n                    if (c !\u003d first) {\n                        cc.listSeparator();\n                    }\n                    if (c.getType() \u003d\u003d Token.STRING \u0026\u0026 !TokenStream.isKeyword(c.getString()) \u0026\u0026 TokenStream.isJSIdentifier(c.getString()) \u0026\u0026 NodeUtil.isLatin(c.getString())) {\n                        add(c.getString());\n                    } else {\n                        addExpr(c, 1);\n                    }\n                    add(\":\");\n                    addExpr(c.getNext(), 1);\n                }\n                add(\"}\");\n                if (needsParens) {\n                    add(\")\");\n                }\n                break;\n            }\n        case Token.SWITCH:\n            add(\"switch(\");\n            add(first);\n            add(\")\");\n            cc.beginBlock();\n            addAllSiblings(first.getNext());\n            cc.endBlock(context \u003d\u003d Context.STATEMENT);\n            break;\n        case Token.CASE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"case \");\n            add(first);\n            addCaseBody(last);\n            break;\n        case Token.DEFAULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"default\");\n            addCaseBody(first);\n            break;\n        case Token.LABEL:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            if (first.getType() !\u003d Token.LABEL_NAME) {\n                throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n            }\n            add(first);\n            add(\":\");\n            addNonEmptyExpression(last, getContextForNonEmptyExpression(context), true);\n            break;\n        case Token.SETNAME:\n            break;\n        default:\n            throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n    cc.endSourceMapping(n);\n}",
      "path": "src/com/google/javascript/jscomp/CodeGenerator.java",
      "functionStartLine": 76,
      "functionName": "add",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,443 +1,443 @@\n void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n         return;\n     }\n     int type \u003d n.getType();\n     String opstr \u003d NodeUtil.opToStr(type);\n     int childCount \u003d n.getChildCount();\n     Node first \u003d n.getFirstChild();\n     Node last \u003d n.getLastChild();\n     if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n-        Preconditions.checkState(childCount \u003d\u003d 2);\n+        Preconditions.checkState(childCount \u003d\u003d 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\n         int p \u003d NodeUtil.precedence(type);\n         addLeftExpr(first, p, context);\n         cc.addOp(opstr, true);\n         Context rhsContext \u003d getContextForNoInOperator(context);\n         if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n             addExpr(last, p, rhsContext);\n         } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n             addExpr(last, p, rhsContext);\n         } else {\n             addExpr(last, p + 1, rhsContext);\n         }\n         return;\n     }\n     cc.startSourceMapping(n);\n     switch(type) {\n         case Token.TRY:\n             {\n                 Preconditions.checkState(first.getNext().getType() \u003d\u003d Token.BLOCK \u0026\u0026 first.getNext().getChildCount() \u003c\u003d 1);\n                 Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                 add(\"try\");\n                 add(first, Context.PRESERVE_BLOCK);\n                 Node catchblock \u003d first.getNext().getFirstChild();\n                 if (catchblock !\u003d null) {\n                     add(catchblock);\n                 }\n                 if (childCount \u003d\u003d 3) {\n                     add(\"finally\");\n                     add(last, Context.PRESERVE_BLOCK);\n                 }\n                 break;\n             }\n         case Token.CATCH:\n             Preconditions.checkState(childCount \u003d\u003d 3);\n             if (first.getNext().getType() !\u003d Token.EMPTY) {\n                 throw new Error(\"Catch conditions not suppored because I think\" + \" that it may be a netscape only feature.\");\n             }\n             add(\"catch(\");\n             add(first);\n             add(\")\");\n             add(last, Context.PRESERVE_BLOCK);\n             break;\n         case Token.THROW:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"throw\");\n             add(first);\n             cc.endStatement(true);\n             break;\n         case Token.RETURN:\n             add(\"return\");\n             if (childCount \u003d\u003d 1) {\n                 add(first);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 0);\n             }\n             cc.endStatement();\n             break;\n         case Token.VAR:\n             if (first !\u003d null) {\n                 add(\"var \");\n                 addList(first, false, getContextForNoInOperator(context));\n             }\n             break;\n         case Token.LABEL_NAME:\n             Preconditions.checkState(!n.getString().isEmpty());\n             addIdentifier(n.getString());\n             break;\n         case Token.NAME:\n             if (first \u003d\u003d null || first.getType() \u003d\u003d Token.EMPTY) {\n                 addIdentifier(n.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 addIdentifier(n.getString());\n                 cc.addOp(\"\u003d\", true);\n                 if (first.getType() \u003d\u003d Token.COMMA) {\n                     addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                 } else {\n                     addExpr(first, 0, getContextForNoInOperator(context));\n                 }\n             }\n             break;\n         case Token.ARRAYLIT:\n             add(\"[\");\n             addList(first, (int[]) n.getProp(Node.SKIP_INDEXES_PROP));\n             add(\"]\");\n             break;\n         case Token.LP:\n             add(\"(\");\n             addList(first);\n             add(\")\");\n             break;\n         case Token.COMMA:\n             addList(first, false, context);\n             break;\n         case Token.NUMBER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             cc.addNumber(n.getDouble());\n             break;\n         case Token.TYPEOF:\n         case Token.VOID:\n         case Token.NOT:\n         case Token.BITNOT:\n         case Token.POS:\n         case Token.NEG:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                 addExpr(first, NodeUtil.precedence(type));\n                 break;\n             }\n         case Token.HOOK:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 int p \u003d NodeUtil.precedence(type);\n                 addLeftExpr(first, p + 1, context);\n                 cc.addOp(\"?\", true);\n                 addExpr(first.getNext(), 1);\n                 cc.addOp(\":\", true);\n                 addExpr(last, 1);\n                 break;\n             }\n         case Token.REGEXP:\n             if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                 throw new Error(\"Expected children to be strings\");\n             }\n             String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n             if (childCount \u003d\u003d 2) {\n                 add(regexp + last.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 add(regexp);\n             }\n             break;\n         case Token.GET_REF:\n             add(first);\n             break;\n         case Token.REF_SPECIAL:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first);\n             add(\".\");\n             add((String) n.getProp(Node.NAME_PROP));\n             break;\n         case Token.FUNCTION:\n             if (n.getClass() !\u003d Node.class) {\n                 throw new Error(\"Unexpected Node subclass.\");\n             }\n             Preconditions.checkState(childCount \u003d\u003d 3);\n             boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n             if (funcNeedsParens) {\n                 add(\"(\");\n             }\n             add(\"function\");\n             add(first);\n             add(first.getNext());\n             add(last, Context.PRESERVE_BLOCK);\n             cc.endFunction(context \u003d\u003d Context.STATEMENT);\n             if (funcNeedsParens) {\n                 add(\")\");\n             }\n             break;\n         case Token.SCRIPT:\n         case Token.BLOCK:\n             {\n                 if (n.getClass() !\u003d Node.class) {\n                     throw new Error(\"Unexpected Node subclass.\");\n                 }\n                 boolean stripBlock \u003d n.isSyntheticBlock() || ((context !\u003d Context.PRESERVE_BLOCK) \u0026\u0026 (n.getChildCount() \u003c 2));\n                 if (!stripBlock) {\n                     cc.beginBlock();\n                 }\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     add(c, Context.STATEMENT);\n                     if (c.getType() \u003d\u003d Token.VAR) {\n                         cc.endStatement();\n                     }\n                     if (c.getType() \u003d\u003d Token.FUNCTION) {\n                         cc.maybeLineBreak();\n                     }\n                     if (type \u003d\u003d Token.SCRIPT) {\n                         cc.notePreferredLineBreak();\n                     }\n                 }\n                 if (!stripBlock) {\n                     cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                 }\n                 break;\n             }\n         case Token.FOR:\n             if (childCount \u003d\u003d 4) {\n                 add(\"for(\");\n                 if (first.getType() \u003d\u003d Token.VAR) {\n                     add(first, Context.IN_FOR_INIT_CLAUSE);\n                 } else {\n                     addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                 }\n                 add(\";\");\n                 add(first.getNext());\n                 add(\";\");\n                 add(first.getNext().getNext());\n                 add(\")\");\n                 addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 add(\"for(\");\n                 add(first);\n                 add(\"in\");\n                 add(first.getNext());\n                 add(\")\");\n                 addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             }\n             break;\n         case Token.DO:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"do\");\n             addNonEmptyExpression(first, Context.OTHER, false);\n             add(\"while(\");\n             add(last);\n             add(\")\");\n             cc.endStatement();\n             break;\n         case Token.WHILE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"while(\");\n             add(first);\n             add(\")\");\n             addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.EMPTY:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             break;\n         case Token.GETPROP:\n             {\n-                Preconditions.checkState(childCount \u003d\u003d 2);\n-                Preconditions.checkState(last.getType() \u003d\u003d Token.STRING);\n+                Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n+                Preconditions.checkState(last.getType() \u003d\u003d Token.STRING, \"Bad GETPROP: RHS should be STRING\");\n                 boolean needsParens \u003d (first.getType() \u003d\u003d Token.NUMBER);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 add(\".\");\n                 addIdentifier(last.getString());\n                 break;\n             }\n         case Token.GETELEM:\n-            Preconditions.checkState(childCount \u003d\u003d 2);\n+            Preconditions.checkState(childCount \u003d\u003d 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\n             addLeftExpr(first, NodeUtil.precedence(type), context);\n             add(\"[\");\n             add(first.getNext());\n             add(\"]\");\n             break;\n         case Token.WITH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"with(\");\n             add(first);\n             add(\")\");\n             addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.INC:\n         case Token.DEC:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                 int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                 if (postProp !\u003d 0) {\n                     addLeftExpr(first, NodeUtil.precedence(type), context);\n                     cc.addOp(o, false);\n                 } else {\n                     cc.addOp(o, false);\n                     add(first);\n                 }\n                 break;\n             }\n         case Token.CALL:\n             if (first.getType() \u003d\u003d Token.NAME \u0026\u0026 \"eval\".equals(first.getString()) \u0026\u0026 !first.getBooleanProp(Node.DIRECT_EVAL)) {\n                 add(\"(0,eval)\");\n             } else {\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n             }\n             add(\"(\");\n             addList(first.getNext());\n             add(\")\");\n             break;\n         case Token.IF:\n             boolean hasElse \u003d childCount \u003d\u003d 3;\n             boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n             if (ambiguousElseClause) {\n                 cc.beginBlock();\n             }\n             add(\"if(\");\n             add(first);\n             add(\")\");\n             if (hasElse) {\n                 addNonEmptyExpression(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                 add(\"else\");\n                 addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 addNonEmptyExpression(first.getNext(), Context.OTHER, false);\n                 Preconditions.checkState(childCount \u003d\u003d 2);\n             }\n             if (ambiguousElseClause) {\n                 cc.endBlock();\n             }\n             break;\n         case Token.NULL:\n         case Token.THIS:\n         case Token.FALSE:\n         case Token.TRUE:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(Node.tokenToName(type));\n             break;\n         case Token.CONTINUE:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"continue\");\n             if (childCount \u003d\u003d 1) {\n                 if (first.getType() !\u003d Token.LABEL_NAME) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.DEBUGGER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(\"debugger\");\n             cc.endStatement();\n             break;\n         case Token.BREAK:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"break\");\n             if (childCount \u003d\u003d 1) {\n                 if (first.getType() !\u003d Token.LABEL_NAME) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.EXPR_VOID:\n             throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n         case Token.EXPR_RESULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first, Context.START_OF_EXPR);\n             cc.endStatement();\n             break;\n         case Token.NEW:\n             add(\"new \");\n             int precedence \u003d NodeUtil.precedence(type);\n             if (NodeUtil.containsCall(first)) {\n                 precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n             }\n             addExpr(first, precedence);\n             Node next \u003d first.getNext();\n             if (next !\u003d null) {\n                 add(\"(\");\n                 addList(next);\n                 add(\")\");\n             }\n             break;\n         case Token.STRING:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(jsString(n.getString(), outputCharsetEncoder));\n             break;\n         case Token.DELPROP:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"delete \");\n             add(first);\n             break;\n         case Token.OBJECTLIT:\n             {\n                 Preconditions.checkState(childCount % 2 \u003d\u003d 0);\n                 boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 add(\"{\");\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext().getNext()) {\n                     if (c !\u003d first) {\n                         cc.listSeparator();\n                     }\n                     if (c.getType() \u003d\u003d Token.STRING \u0026\u0026 !TokenStream.isKeyword(c.getString()) \u0026\u0026 TokenStream.isJSIdentifier(c.getString()) \u0026\u0026 NodeUtil.isLatin(c.getString())) {\n                         add(c.getString());\n                     } else {\n                         addExpr(c, 1);\n                     }\n                     add(\":\");\n                     addExpr(c.getNext(), 1);\n                 }\n                 add(\"}\");\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 break;\n             }\n         case Token.SWITCH:\n             add(\"switch(\");\n             add(first);\n             add(\")\");\n             cc.beginBlock();\n             addAllSiblings(first.getNext());\n             cc.endBlock(context \u003d\u003d Context.STATEMENT);\n             break;\n         case Token.CASE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"case \");\n             add(first);\n             addCaseBody(last);\n             break;\n         case Token.DEFAULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"default\");\n             addCaseBody(first);\n             break;\n         case Token.LABEL:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             if (first.getType() !\u003d Token.LABEL_NAME) {\n                 throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n             }\n             add(first);\n             add(\":\");\n             addNonEmptyExpression(last, getContextForNonEmptyExpression(context), true);\n             break;\n         case Token.SETNAME:\n             break;\n         default:\n             throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n     }\n     cc.endSourceMapping(n);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "07663b6946caa097ad92b5375e333936351e3256": {
      "type": "Ybodychange",
      "commitMessage": "\nChange on 2010/06/23 by elnatan\n\n\tSeparate two switch cases that shouldn\u0027t be combined\n\n\tR\u003djohnlenz\n\tDELTA\u003d5  (2 added, 3 deleted, 0 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d36001\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@250 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "6/23/10, 12:21 PM",
      "commitName": "07663b6946caa097ad92b5375e333936351e3256",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "6/22/10, 4:00 PM",
      "commitNameOld": "c9e89727dc8063d087d28e42629606f4fd74a6e5",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 0.85,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n        return;\n    }\n    int type \u003d n.getType();\n    String opstr \u003d NodeUtil.opToStr(type);\n    int childCount \u003d n.getChildCount();\n    Node first \u003d n.getFirstChild();\n    Node last \u003d n.getLastChild();\n    if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n        Preconditions.checkState(childCount \u003d\u003d 2);\n        int p \u003d NodeUtil.precedence(type);\n        addLeftExpr(first, p, context);\n        cc.addOp(opstr, true);\n        Context rhsContext \u003d getContextForNoInOperator(context);\n        if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n            addExpr(last, p, rhsContext);\n        } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n            addExpr(last, p, rhsContext);\n        } else {\n            addExpr(last, p + 1, rhsContext);\n        }\n        return;\n    }\n    cc.startSourceMapping(n);\n    switch(type) {\n        case Token.TRY:\n            {\n                Preconditions.checkState(first.getNext().getType() \u003d\u003d Token.BLOCK \u0026\u0026 first.getNext().getChildCount() \u003c\u003d 1);\n                Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                add(\"try\");\n                add(first, Context.PRESERVE_BLOCK);\n                Node catchblock \u003d first.getNext().getFirstChild();\n                if (catchblock !\u003d null) {\n                    add(catchblock);\n                }\n                if (childCount \u003d\u003d 3) {\n                    add(\"finally\");\n                    add(last, Context.PRESERVE_BLOCK);\n                }\n                break;\n            }\n        case Token.CATCH:\n            Preconditions.checkState(childCount \u003d\u003d 3);\n            if (first.getNext().getType() !\u003d Token.EMPTY) {\n                throw new Error(\"Catch conditions not suppored because I think\" + \" that it may be a netscape only feature.\");\n            }\n            add(\"catch(\");\n            add(first);\n            add(\")\");\n            add(last, Context.PRESERVE_BLOCK);\n            break;\n        case Token.THROW:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"throw\");\n            add(first);\n            cc.endStatement(true);\n            break;\n        case Token.RETURN:\n            add(\"return\");\n            if (childCount \u003d\u003d 1) {\n                add(first);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 0);\n            }\n            cc.endStatement();\n            break;\n        case Token.VAR:\n            if (first !\u003d null) {\n                add(\"var \");\n                addList(first, false, getContextForNoInOperator(context));\n            }\n            break;\n        case Token.LABEL_NAME:\n            Preconditions.checkState(!n.getString().isEmpty());\n            addIdentifier(n.getString());\n            break;\n        case Token.NAME:\n            if (first \u003d\u003d null || first.getType() \u003d\u003d Token.EMPTY) {\n                addIdentifier(n.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                addIdentifier(n.getString());\n                cc.addOp(\"\u003d\", true);\n                if (first.getType() \u003d\u003d Token.COMMA) {\n                    addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                } else {\n                    addExpr(first, 0, getContextForNoInOperator(context));\n                }\n            }\n            break;\n        case Token.ARRAYLIT:\n            add(\"[\");\n            addList(first, (int[]) n.getProp(Node.SKIP_INDEXES_PROP));\n            add(\"]\");\n            break;\n        case Token.LP:\n            add(\"(\");\n            addList(first);\n            add(\")\");\n            break;\n        case Token.COMMA:\n            addList(first, false, context);\n            break;\n        case Token.NUMBER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            cc.addNumber(n.getDouble());\n            break;\n        case Token.TYPEOF:\n        case Token.VOID:\n        case Token.NOT:\n        case Token.BITNOT:\n        case Token.POS:\n        case Token.NEG:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                addExpr(first, NodeUtil.precedence(type));\n                break;\n            }\n        case Token.HOOK:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                int p \u003d NodeUtil.precedence(type);\n                addLeftExpr(first, p + 1, context);\n                cc.addOp(\"?\", true);\n                addExpr(first.getNext(), 1);\n                cc.addOp(\":\", true);\n                addExpr(last, 1);\n                break;\n            }\n        case Token.REGEXP:\n            if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                throw new Error(\"Expected children to be strings\");\n            }\n            String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n            if (childCount \u003d\u003d 2) {\n                add(regexp + last.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                add(regexp);\n            }\n            break;\n        case Token.GET_REF:\n            add(first);\n            break;\n        case Token.REF_SPECIAL:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first);\n            add(\".\");\n            add((String) n.getProp(Node.NAME_PROP));\n            break;\n        case Token.FUNCTION:\n            if (n.getClass() !\u003d Node.class) {\n                throw new Error(\"Unexpected Node subclass.\");\n            }\n            Preconditions.checkState(childCount \u003d\u003d 3);\n            boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n            if (funcNeedsParens) {\n                add(\"(\");\n            }\n            add(\"function\");\n            add(first);\n            add(first.getNext());\n            add(last, Context.PRESERVE_BLOCK);\n            cc.endFunction(context \u003d\u003d Context.STATEMENT);\n            if (funcNeedsParens) {\n                add(\")\");\n            }\n            break;\n        case Token.SCRIPT:\n        case Token.BLOCK:\n            {\n                if (n.getClass() !\u003d Node.class) {\n                    throw new Error(\"Unexpected Node subclass.\");\n                }\n                boolean stripBlock \u003d n.isSyntheticBlock() || ((context !\u003d Context.PRESERVE_BLOCK) \u0026\u0026 (n.getChildCount() \u003c 2));\n                if (!stripBlock) {\n                    cc.beginBlock();\n                }\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    add(c, Context.STATEMENT);\n                    if (c.getType() \u003d\u003d Token.VAR) {\n                        cc.endStatement();\n                    }\n                    if (c.getType() \u003d\u003d Token.FUNCTION) {\n                        cc.maybeLineBreak();\n                    }\n                    if (type \u003d\u003d Token.SCRIPT) {\n                        cc.notePreferredLineBreak();\n                    }\n                }\n                if (!stripBlock) {\n                    cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                }\n                break;\n            }\n        case Token.FOR:\n            if (childCount \u003d\u003d 4) {\n                add(\"for(\");\n                if (first.getType() \u003d\u003d Token.VAR) {\n                    add(first, Context.IN_FOR_INIT_CLAUSE);\n                } else {\n                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                }\n                add(\";\");\n                add(first.getNext());\n                add(\";\");\n                add(first.getNext().getNext());\n                add(\")\");\n                addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                add(\"for(\");\n                add(first);\n                add(\"in\");\n                add(first.getNext());\n                add(\")\");\n                addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            }\n            break;\n        case Token.DO:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"do\");\n            addNonEmptyExpression(first, Context.OTHER, false);\n            add(\"while(\");\n            add(last);\n            add(\")\");\n            cc.endStatement();\n            break;\n        case Token.WHILE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"while(\");\n            add(first);\n            add(\")\");\n            addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.EMPTY:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            break;\n        case Token.GETPROP:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 2);\n                Preconditions.checkState(last.getType() \u003d\u003d Token.STRING);\n                boolean needsParens \u003d (first.getType() \u003d\u003d Token.NUMBER);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n                if (needsParens) {\n                    add(\")\");\n                }\n                add(\".\");\n                addIdentifier(last.getString());\n                break;\n            }\n        case Token.GETELEM:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            addLeftExpr(first, NodeUtil.precedence(type), context);\n            add(\"[\");\n            add(first.getNext());\n            add(\"]\");\n            break;\n        case Token.WITH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"with(\");\n            add(first);\n            add(\")\");\n            addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.INC:\n        case Token.DEC:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                if (postProp !\u003d 0) {\n                    addLeftExpr(first, NodeUtil.precedence(type), context);\n                    cc.addOp(o, false);\n                } else {\n                    cc.addOp(o, false);\n                    add(first);\n                }\n                break;\n            }\n        case Token.CALL:\n            if (first.getType() \u003d\u003d Token.NAME \u0026\u0026 \"eval\".equals(first.getString()) \u0026\u0026 !first.getBooleanProp(Node.DIRECT_EVAL)) {\n                add(\"(0,eval)\");\n            } else {\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n            }\n            add(\"(\");\n            addList(first.getNext());\n            add(\")\");\n            break;\n        case Token.IF:\n            boolean hasElse \u003d childCount \u003d\u003d 3;\n            boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n            if (ambiguousElseClause) {\n                cc.beginBlock();\n            }\n            add(\"if(\");\n            add(first);\n            add(\")\");\n            if (hasElse) {\n                addNonEmptyExpression(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                add(\"else\");\n                addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                addNonEmptyExpression(first.getNext(), Context.OTHER, false);\n                Preconditions.checkState(childCount \u003d\u003d 2);\n            }\n            if (ambiguousElseClause) {\n                cc.endBlock();\n            }\n            break;\n        case Token.NULL:\n        case Token.THIS:\n        case Token.FALSE:\n        case Token.TRUE:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(Node.tokenToName(type));\n            break;\n        case Token.CONTINUE:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"continue\");\n            if (childCount \u003d\u003d 1) {\n                if (first.getType() !\u003d Token.LABEL_NAME) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.DEBUGGER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"debugger\");\n            cc.endStatement();\n            break;\n        case Token.BREAK:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"break\");\n            if (childCount \u003d\u003d 1) {\n                if (first.getType() !\u003d Token.LABEL_NAME) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.EXPR_VOID:\n            throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n        case Token.EXPR_RESULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first, Context.START_OF_EXPR);\n            cc.endStatement();\n            break;\n        case Token.NEW:\n            add(\"new \");\n            int precedence \u003d NodeUtil.precedence(type);\n            if (NodeUtil.containsCall(first)) {\n                precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n            }\n            addExpr(first, precedence);\n            Node next \u003d first.getNext();\n            if (next !\u003d null) {\n                add(\"(\");\n                addList(next);\n                add(\")\");\n            }\n            break;\n        case Token.STRING:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(jsString(n.getString(), outputCharsetEncoder));\n            break;\n        case Token.DELPROP:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"delete \");\n            add(first);\n            break;\n        case Token.OBJECTLIT:\n            {\n                Preconditions.checkState(childCount % 2 \u003d\u003d 0);\n                boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                add(\"{\");\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext().getNext()) {\n                    if (c !\u003d first) {\n                        cc.listSeparator();\n                    }\n                    if (c.getType() \u003d\u003d Token.STRING \u0026\u0026 !TokenStream.isKeyword(c.getString()) \u0026\u0026 TokenStream.isJSIdentifier(c.getString()) \u0026\u0026 NodeUtil.isLatin(c.getString())) {\n                        add(c.getString());\n                    } else {\n                        addExpr(c, 1);\n                    }\n                    add(\":\");\n                    addExpr(c.getNext(), 1);\n                }\n                add(\"}\");\n                if (needsParens) {\n                    add(\")\");\n                }\n                break;\n            }\n        case Token.SWITCH:\n            add(\"switch(\");\n            add(first);\n            add(\")\");\n            cc.beginBlock();\n            addAllSiblings(first.getNext());\n            cc.endBlock(context \u003d\u003d Context.STATEMENT);\n            break;\n        case Token.CASE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"case \");\n            add(first);\n            addCaseBody(last);\n            break;\n        case Token.DEFAULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"default\");\n            addCaseBody(first);\n            break;\n        case Token.LABEL:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            if (first.getType() !\u003d Token.LABEL_NAME) {\n                throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n            }\n            add(first);\n            add(\":\");\n            addNonEmptyExpression(last, getContextForNonEmptyExpression(context), true);\n            break;\n        case Token.SETNAME:\n            break;\n        default:\n            throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n    cc.endSourceMapping(n);\n}",
      "path": "src/com/google/javascript/jscomp/CodeGenerator.java",
      "functionStartLine": 76,
      "functionName": "add",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,445 +1,443 @@\n void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n         return;\n     }\n     int type \u003d n.getType();\n     String opstr \u003d NodeUtil.opToStr(type);\n     int childCount \u003d n.getChildCount();\n     Node first \u003d n.getFirstChild();\n     Node last \u003d n.getLastChild();\n     if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n         Preconditions.checkState(childCount \u003d\u003d 2);\n         int p \u003d NodeUtil.precedence(type);\n         addLeftExpr(first, p, context);\n         cc.addOp(opstr, true);\n         Context rhsContext \u003d getContextForNoInOperator(context);\n         if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n             addExpr(last, p, rhsContext);\n         } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n             addExpr(last, p, rhsContext);\n         } else {\n             addExpr(last, p + 1, rhsContext);\n         }\n         return;\n     }\n     cc.startSourceMapping(n);\n     switch(type) {\n         case Token.TRY:\n             {\n                 Preconditions.checkState(first.getNext().getType() \u003d\u003d Token.BLOCK \u0026\u0026 first.getNext().getChildCount() \u003c\u003d 1);\n                 Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                 add(\"try\");\n                 add(first, Context.PRESERVE_BLOCK);\n                 Node catchblock \u003d first.getNext().getFirstChild();\n                 if (catchblock !\u003d null) {\n                     add(catchblock);\n                 }\n                 if (childCount \u003d\u003d 3) {\n                     add(\"finally\");\n                     add(last, Context.PRESERVE_BLOCK);\n                 }\n                 break;\n             }\n         case Token.CATCH:\n             Preconditions.checkState(childCount \u003d\u003d 3);\n             if (first.getNext().getType() !\u003d Token.EMPTY) {\n                 throw new Error(\"Catch conditions not suppored because I think\" + \" that it may be a netscape only feature.\");\n             }\n             add(\"catch(\");\n             add(first);\n             add(\")\");\n             add(last, Context.PRESERVE_BLOCK);\n             break;\n         case Token.THROW:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"throw\");\n             add(first);\n             cc.endStatement(true);\n             break;\n         case Token.RETURN:\n             add(\"return\");\n             if (childCount \u003d\u003d 1) {\n                 add(first);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 0);\n             }\n             cc.endStatement();\n             break;\n         case Token.VAR:\n             if (first !\u003d null) {\n                 add(\"var \");\n                 addList(first, false, getContextForNoInOperator(context));\n             }\n             break;\n         case Token.LABEL_NAME:\n             Preconditions.checkState(!n.getString().isEmpty());\n             addIdentifier(n.getString());\n             break;\n         case Token.NAME:\n             if (first \u003d\u003d null || first.getType() \u003d\u003d Token.EMPTY) {\n                 addIdentifier(n.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 addIdentifier(n.getString());\n                 cc.addOp(\"\u003d\", true);\n                 if (first.getType() \u003d\u003d Token.COMMA) {\n                     addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                 } else {\n                     addExpr(first, 0, getContextForNoInOperator(context));\n                 }\n             }\n             break;\n         case Token.ARRAYLIT:\n             add(\"[\");\n             addList(first, (int[]) n.getProp(Node.SKIP_INDEXES_PROP));\n             add(\"]\");\n             break;\n         case Token.LP:\n             add(\"(\");\n             addList(first);\n             add(\")\");\n             break;\n         case Token.COMMA:\n             addList(first, false, context);\n             break;\n         case Token.NUMBER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             cc.addNumber(n.getDouble());\n             break;\n         case Token.TYPEOF:\n         case Token.VOID:\n         case Token.NOT:\n         case Token.BITNOT:\n         case Token.POS:\n         case Token.NEG:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                 addExpr(first, NodeUtil.precedence(type));\n                 break;\n             }\n         case Token.HOOK:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 int p \u003d NodeUtil.precedence(type);\n                 addLeftExpr(first, p + 1, context);\n                 cc.addOp(\"?\", true);\n                 addExpr(first.getNext(), 1);\n                 cc.addOp(\":\", true);\n                 addExpr(last, 1);\n                 break;\n             }\n         case Token.REGEXP:\n             if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                 throw new Error(\"Expected children to be strings\");\n             }\n             String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n             if (childCount \u003d\u003d 2) {\n                 add(regexp + last.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 add(regexp);\n             }\n             break;\n         case Token.GET_REF:\n             add(first);\n             break;\n         case Token.REF_SPECIAL:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first);\n             add(\".\");\n             add((String) n.getProp(Node.NAME_PROP));\n             break;\n         case Token.FUNCTION:\n             if (n.getClass() !\u003d Node.class) {\n                 throw new Error(\"Unexpected Node subclass.\");\n             }\n             Preconditions.checkState(childCount \u003d\u003d 3);\n             boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n             if (funcNeedsParens) {\n                 add(\"(\");\n             }\n             add(\"function\");\n             add(first);\n             add(first.getNext());\n             add(last, Context.PRESERVE_BLOCK);\n             cc.endFunction(context \u003d\u003d Context.STATEMENT);\n             if (funcNeedsParens) {\n                 add(\")\");\n             }\n             break;\n         case Token.SCRIPT:\n         case Token.BLOCK:\n             {\n                 if (n.getClass() !\u003d Node.class) {\n                     throw new Error(\"Unexpected Node subclass.\");\n                 }\n                 boolean stripBlock \u003d n.isSyntheticBlock() || ((context !\u003d Context.PRESERVE_BLOCK) \u0026\u0026 (n.getChildCount() \u003c 2));\n                 if (!stripBlock) {\n                     cc.beginBlock();\n                 }\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     add(c, Context.STATEMENT);\n                     if (c.getType() \u003d\u003d Token.VAR) {\n                         cc.endStatement();\n                     }\n                     if (c.getType() \u003d\u003d Token.FUNCTION) {\n                         cc.maybeLineBreak();\n                     }\n                     if (type \u003d\u003d Token.SCRIPT) {\n                         cc.notePreferredLineBreak();\n                     }\n                 }\n                 if (!stripBlock) {\n                     cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                 }\n                 break;\n             }\n         case Token.FOR:\n             if (childCount \u003d\u003d 4) {\n                 add(\"for(\");\n                 if (first.getType() \u003d\u003d Token.VAR) {\n                     add(first, Context.IN_FOR_INIT_CLAUSE);\n                 } else {\n                     addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                 }\n                 add(\";\");\n                 add(first.getNext());\n                 add(\";\");\n                 add(first.getNext().getNext());\n                 add(\")\");\n                 addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 add(\"for(\");\n                 add(first);\n                 add(\"in\");\n                 add(first.getNext());\n                 add(\")\");\n                 addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             }\n             break;\n         case Token.DO:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"do\");\n             addNonEmptyExpression(first, Context.OTHER, false);\n             add(\"while(\");\n             add(last);\n             add(\")\");\n             cc.endStatement();\n             break;\n         case Token.WHILE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"while(\");\n             add(first);\n             add(\")\");\n             addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.EMPTY:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             break;\n         case Token.GETPROP:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 2);\n                 Preconditions.checkState(last.getType() \u003d\u003d Token.STRING);\n                 boolean needsParens \u003d (first.getType() \u003d\u003d Token.NUMBER);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 add(\".\");\n                 addIdentifier(last.getString());\n                 break;\n             }\n         case Token.GETELEM:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             addLeftExpr(first, NodeUtil.precedence(type), context);\n             add(\"[\");\n             add(first.getNext());\n             add(\"]\");\n             break;\n         case Token.WITH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"with(\");\n             add(first);\n             add(\")\");\n             addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.INC:\n         case Token.DEC:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                 int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                 if (postProp !\u003d 0) {\n                     addLeftExpr(first, NodeUtil.precedence(type), context);\n                     cc.addOp(o, false);\n                 } else {\n                     cc.addOp(o, false);\n                     add(first);\n                 }\n                 break;\n             }\n         case Token.CALL:\n             if (first.getType() \u003d\u003d Token.NAME \u0026\u0026 \"eval\".equals(first.getString()) \u0026\u0026 !first.getBooleanProp(Node.DIRECT_EVAL)) {\n                 add(\"(0,eval)\");\n             } else {\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n             }\n             add(\"(\");\n             addList(first.getNext());\n             add(\")\");\n             break;\n         case Token.IF:\n             boolean hasElse \u003d childCount \u003d\u003d 3;\n             boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n             if (ambiguousElseClause) {\n                 cc.beginBlock();\n             }\n             add(\"if(\");\n             add(first);\n             add(\")\");\n             if (hasElse) {\n                 addNonEmptyExpression(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                 add(\"else\");\n                 addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 addNonEmptyExpression(first.getNext(), Context.OTHER, false);\n                 Preconditions.checkState(childCount \u003d\u003d 2);\n             }\n             if (ambiguousElseClause) {\n                 cc.endBlock();\n             }\n             break;\n         case Token.NULL:\n         case Token.THIS:\n         case Token.FALSE:\n         case Token.TRUE:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(Node.tokenToName(type));\n             break;\n         case Token.CONTINUE:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"continue\");\n             if (childCount \u003d\u003d 1) {\n                 if (first.getType() !\u003d Token.LABEL_NAME) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.DEBUGGER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(\"debugger\");\n             cc.endStatement();\n             break;\n         case Token.BREAK:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"break\");\n             if (childCount \u003d\u003d 1) {\n                 if (first.getType() !\u003d Token.LABEL_NAME) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.EXPR_VOID:\n+            throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n         case Token.EXPR_RESULT:\n-            if (type \u003d\u003d Token.EXPR_VOID) {\n-                throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n-            }\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first, Context.START_OF_EXPR);\n             cc.endStatement();\n             break;\n         case Token.NEW:\n             add(\"new \");\n             int precedence \u003d NodeUtil.precedence(type);\n             if (NodeUtil.containsCall(first)) {\n                 precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n             }\n             addExpr(first, precedence);\n             Node next \u003d first.getNext();\n             if (next !\u003d null) {\n                 add(\"(\");\n                 addList(next);\n                 add(\")\");\n             }\n             break;\n         case Token.STRING:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(jsString(n.getString(), outputCharsetEncoder));\n             break;\n         case Token.DELPROP:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"delete \");\n             add(first);\n             break;\n         case Token.OBJECTLIT:\n             {\n                 Preconditions.checkState(childCount % 2 \u003d\u003d 0);\n                 boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 add(\"{\");\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext().getNext()) {\n                     if (c !\u003d first) {\n                         cc.listSeparator();\n                     }\n                     if (c.getType() \u003d\u003d Token.STRING \u0026\u0026 !TokenStream.isKeyword(c.getString()) \u0026\u0026 TokenStream.isJSIdentifier(c.getString()) \u0026\u0026 NodeUtil.isLatin(c.getString())) {\n                         add(c.getString());\n                     } else {\n                         addExpr(c, 1);\n                     }\n                     add(\":\");\n                     addExpr(c.getNext(), 1);\n                 }\n                 add(\"}\");\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 break;\n             }\n         case Token.SWITCH:\n             add(\"switch(\");\n             add(first);\n             add(\")\");\n             cc.beginBlock();\n             addAllSiblings(first.getNext());\n             cc.endBlock(context \u003d\u003d Context.STATEMENT);\n             break;\n         case Token.CASE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"case \");\n             add(first);\n             addCaseBody(last);\n             break;\n         case Token.DEFAULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"default\");\n             addCaseBody(first);\n             break;\n         case Token.LABEL:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             if (first.getType() !\u003d Token.LABEL_NAME) {\n                 throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n             }\n             add(first);\n             add(\":\");\n             addNonEmptyExpression(last, getContextForNonEmptyExpression(context), true);\n             break;\n         case Token.SETNAME:\n             break;\n         default:\n             throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n     }\n     cc.endSourceMapping(n);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c9e89727dc8063d087d28e42629606f4fd74a6e5": {
      "type": "Ybodychange",
      "commitMessage": "\nChange on 2010/06/22 by nicksantos\n\n\tvariable coalescing better be run AFTER ambiguate properties, and\n\tafter denormalization.\n\n\tR\u003djohnlenz\n\tDELTA\u003d36  (20 added, 16 deleted, 0 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d34005\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@248 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "6/22/10, 4:00 PM",
      "commitName": "c9e89727dc8063d087d28e42629606f4fd74a6e5",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "6/16/10, 12:33 PM",
      "commitNameOld": "e33e925eea3a8e4de958864e531e1adc4da62e18",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 6.14,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n        return;\n    }\n    int type \u003d n.getType();\n    String opstr \u003d NodeUtil.opToStr(type);\n    int childCount \u003d n.getChildCount();\n    Node first \u003d n.getFirstChild();\n    Node last \u003d n.getLastChild();\n    if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n        Preconditions.checkState(childCount \u003d\u003d 2);\n        int p \u003d NodeUtil.precedence(type);\n        addLeftExpr(first, p, context);\n        cc.addOp(opstr, true);\n        Context rhsContext \u003d getContextForNoInOperator(context);\n        if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n            addExpr(last, p, rhsContext);\n        } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n            addExpr(last, p, rhsContext);\n        } else {\n            addExpr(last, p + 1, rhsContext);\n        }\n        return;\n    }\n    cc.startSourceMapping(n);\n    switch(type) {\n        case Token.TRY:\n            {\n                Preconditions.checkState(first.getNext().getType() \u003d\u003d Token.BLOCK \u0026\u0026 first.getNext().getChildCount() \u003c\u003d 1);\n                Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                add(\"try\");\n                add(first, Context.PRESERVE_BLOCK);\n                Node catchblock \u003d first.getNext().getFirstChild();\n                if (catchblock !\u003d null) {\n                    add(catchblock);\n                }\n                if (childCount \u003d\u003d 3) {\n                    add(\"finally\");\n                    add(last, Context.PRESERVE_BLOCK);\n                }\n                break;\n            }\n        case Token.CATCH:\n            Preconditions.checkState(childCount \u003d\u003d 3);\n            if (first.getNext().getType() !\u003d Token.EMPTY) {\n                throw new Error(\"Catch conditions not suppored because I think\" + \" that it may be a netscape only feature.\");\n            }\n            add(\"catch(\");\n            add(first);\n            add(\")\");\n            add(last, Context.PRESERVE_BLOCK);\n            break;\n        case Token.THROW:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"throw\");\n            add(first);\n            cc.endStatement(true);\n            break;\n        case Token.RETURN:\n            add(\"return\");\n            if (childCount \u003d\u003d 1) {\n                add(first);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 0);\n            }\n            cc.endStatement();\n            break;\n        case Token.VAR:\n            if (first !\u003d null) {\n                add(\"var \");\n                addList(first, false, getContextForNoInOperator(context));\n            }\n            break;\n        case Token.LABEL_NAME:\n            Preconditions.checkState(!n.getString().isEmpty());\n            addIdentifier(n.getString());\n            break;\n        case Token.NAME:\n            if (first \u003d\u003d null || first.getType() \u003d\u003d Token.EMPTY) {\n                addIdentifier(n.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                addIdentifier(n.getString());\n                cc.addOp(\"\u003d\", true);\n                if (first.getType() \u003d\u003d Token.COMMA) {\n                    addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                } else {\n                    addExpr(first, 0, getContextForNoInOperator(context));\n                }\n            }\n            break;\n        case Token.ARRAYLIT:\n            add(\"[\");\n            addList(first, (int[]) n.getProp(Node.SKIP_INDEXES_PROP));\n            add(\"]\");\n            break;\n        case Token.LP:\n            add(\"(\");\n            addList(first);\n            add(\")\");\n            break;\n        case Token.COMMA:\n            addList(first, false, context);\n            break;\n        case Token.NUMBER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            cc.addNumber(n.getDouble());\n            break;\n        case Token.TYPEOF:\n        case Token.VOID:\n        case Token.NOT:\n        case Token.BITNOT:\n        case Token.POS:\n        case Token.NEG:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                addExpr(first, NodeUtil.precedence(type));\n                break;\n            }\n        case Token.HOOK:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                int p \u003d NodeUtil.precedence(type);\n                addLeftExpr(first, p + 1, context);\n                cc.addOp(\"?\", true);\n                addExpr(first.getNext(), 1);\n                cc.addOp(\":\", true);\n                addExpr(last, 1);\n                break;\n            }\n        case Token.REGEXP:\n            if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                throw new Error(\"Expected children to be strings\");\n            }\n            String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n            if (childCount \u003d\u003d 2) {\n                add(regexp + last.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                add(regexp);\n            }\n            break;\n        case Token.GET_REF:\n            add(first);\n            break;\n        case Token.REF_SPECIAL:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first);\n            add(\".\");\n            add((String) n.getProp(Node.NAME_PROP));\n            break;\n        case Token.FUNCTION:\n            if (n.getClass() !\u003d Node.class) {\n                throw new Error(\"Unexpected Node subclass.\");\n            }\n            Preconditions.checkState(childCount \u003d\u003d 3);\n            boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n            if (funcNeedsParens) {\n                add(\"(\");\n            }\n            add(\"function\");\n            add(first);\n            add(first.getNext());\n            add(last, Context.PRESERVE_BLOCK);\n            cc.endFunction(context \u003d\u003d Context.STATEMENT);\n            if (funcNeedsParens) {\n                add(\")\");\n            }\n            break;\n        case Token.SCRIPT:\n        case Token.BLOCK:\n            {\n                if (n.getClass() !\u003d Node.class) {\n                    throw new Error(\"Unexpected Node subclass.\");\n                }\n                boolean stripBlock \u003d n.isSyntheticBlock() || ((context !\u003d Context.PRESERVE_BLOCK) \u0026\u0026 (n.getChildCount() \u003c 2));\n                if (!stripBlock) {\n                    cc.beginBlock();\n                }\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    add(c, Context.STATEMENT);\n                    if (c.getType() \u003d\u003d Token.VAR) {\n                        cc.endStatement();\n                    }\n                    if (c.getType() \u003d\u003d Token.FUNCTION) {\n                        cc.maybeLineBreak();\n                    }\n                    if (type \u003d\u003d Token.SCRIPT) {\n                        cc.notePreferredLineBreak();\n                    }\n                }\n                if (!stripBlock) {\n                    cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                }\n                break;\n            }\n        case Token.FOR:\n            if (childCount \u003d\u003d 4) {\n                add(\"for(\");\n                if (first.getType() \u003d\u003d Token.VAR) {\n                    add(first, Context.IN_FOR_INIT_CLAUSE);\n                } else {\n                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                }\n                add(\";\");\n                add(first.getNext());\n                add(\";\");\n                add(first.getNext().getNext());\n                add(\")\");\n                addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                add(\"for(\");\n                add(first);\n                add(\"in\");\n                add(first.getNext());\n                add(\")\");\n                addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            }\n            break;\n        case Token.DO:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"do\");\n            addNonEmptyExpression(first, Context.OTHER, false);\n            add(\"while(\");\n            add(last);\n            add(\")\");\n            cc.endStatement();\n            break;\n        case Token.WHILE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"while(\");\n            add(first);\n            add(\")\");\n            addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.EMPTY:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            break;\n        case Token.GETPROP:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 2);\n                Preconditions.checkState(last.getType() \u003d\u003d Token.STRING);\n                boolean needsParens \u003d (first.getType() \u003d\u003d Token.NUMBER);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n                if (needsParens) {\n                    add(\")\");\n                }\n                add(\".\");\n                addIdentifier(last.getString());\n                break;\n            }\n        case Token.GETELEM:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            addLeftExpr(first, NodeUtil.precedence(type), context);\n            add(\"[\");\n            add(first.getNext());\n            add(\"]\");\n            break;\n        case Token.WITH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"with(\");\n            add(first);\n            add(\")\");\n            addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.INC:\n        case Token.DEC:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                if (postProp !\u003d 0) {\n                    addLeftExpr(first, NodeUtil.precedence(type), context);\n                    cc.addOp(o, false);\n                } else {\n                    cc.addOp(o, false);\n                    add(first);\n                }\n                break;\n            }\n        case Token.CALL:\n            if (first.getType() \u003d\u003d Token.NAME \u0026\u0026 \"eval\".equals(first.getString()) \u0026\u0026 !first.getBooleanProp(Node.DIRECT_EVAL)) {\n                add(\"(0,eval)\");\n            } else {\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n            }\n            add(\"(\");\n            addList(first.getNext());\n            add(\")\");\n            break;\n        case Token.IF:\n            boolean hasElse \u003d childCount \u003d\u003d 3;\n            boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n            if (ambiguousElseClause) {\n                cc.beginBlock();\n            }\n            add(\"if(\");\n            add(first);\n            add(\")\");\n            if (hasElse) {\n                addNonEmptyExpression(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                add(\"else\");\n                addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                addNonEmptyExpression(first.getNext(), Context.OTHER, false);\n                Preconditions.checkState(childCount \u003d\u003d 2);\n            }\n            if (ambiguousElseClause) {\n                cc.endBlock();\n            }\n            break;\n        case Token.NULL:\n        case Token.THIS:\n        case Token.FALSE:\n        case Token.TRUE:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(Node.tokenToName(type));\n            break;\n        case Token.CONTINUE:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"continue\");\n            if (childCount \u003d\u003d 1) {\n                if (first.getType() !\u003d Token.LABEL_NAME) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.DEBUGGER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"debugger\");\n            cc.endStatement();\n            break;\n        case Token.BREAK:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"break\");\n            if (childCount \u003d\u003d 1) {\n                if (first.getType() !\u003d Token.LABEL_NAME) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.EXPR_VOID:\n        case Token.EXPR_RESULT:\n            if (type \u003d\u003d Token.EXPR_VOID) {\n                throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n            }\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first, Context.START_OF_EXPR);\n            cc.endStatement();\n            break;\n        case Token.NEW:\n            add(\"new \");\n            int precedence \u003d NodeUtil.precedence(type);\n            if (NodeUtil.containsCall(first)) {\n                precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n            }\n            addExpr(first, precedence);\n            Node next \u003d first.getNext();\n            if (next !\u003d null) {\n                add(\"(\");\n                addList(next);\n                add(\")\");\n            }\n            break;\n        case Token.STRING:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(jsString(n.getString(), outputCharsetEncoder));\n            break;\n        case Token.DELPROP:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"delete \");\n            add(first);\n            break;\n        case Token.OBJECTLIT:\n            {\n                Preconditions.checkState(childCount % 2 \u003d\u003d 0);\n                boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                add(\"{\");\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext().getNext()) {\n                    if (c !\u003d first) {\n                        cc.listSeparator();\n                    }\n                    if (c.getType() \u003d\u003d Token.STRING \u0026\u0026 !TokenStream.isKeyword(c.getString()) \u0026\u0026 TokenStream.isJSIdentifier(c.getString()) \u0026\u0026 NodeUtil.isLatin(c.getString())) {\n                        add(c.getString());\n                    } else {\n                        addExpr(c, 1);\n                    }\n                    add(\":\");\n                    addExpr(c.getNext(), 1);\n                }\n                add(\"}\");\n                if (needsParens) {\n                    add(\")\");\n                }\n                break;\n            }\n        case Token.SWITCH:\n            add(\"switch(\");\n            add(first);\n            add(\")\");\n            cc.beginBlock();\n            addAllSiblings(first.getNext());\n            cc.endBlock(context \u003d\u003d Context.STATEMENT);\n            break;\n        case Token.CASE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"case \");\n            add(first);\n            addCaseBody(last);\n            break;\n        case Token.DEFAULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"default\");\n            addCaseBody(first);\n            break;\n        case Token.LABEL:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            if (first.getType() !\u003d Token.LABEL_NAME) {\n                throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n            }\n            add(first);\n            add(\":\");\n            addNonEmptyExpression(last, getContextForNonEmptyExpression(context), true);\n            break;\n        case Token.SETNAME:\n            break;\n        default:\n            throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n    cc.endSourceMapping(n);\n}",
      "path": "src/com/google/javascript/jscomp/CodeGenerator.java",
      "functionStartLine": 76,
      "functionName": "add",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,445 +1,445 @@\n void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n         return;\n     }\n     int type \u003d n.getType();\n     String opstr \u003d NodeUtil.opToStr(type);\n     int childCount \u003d n.getChildCount();\n     Node first \u003d n.getFirstChild();\n     Node last \u003d n.getLastChild();\n     if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n         Preconditions.checkState(childCount \u003d\u003d 2);\n         int p \u003d NodeUtil.precedence(type);\n         addLeftExpr(first, p, context);\n         cc.addOp(opstr, true);\n         Context rhsContext \u003d getContextForNoInOperator(context);\n         if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n             addExpr(last, p, rhsContext);\n         } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n             addExpr(last, p, rhsContext);\n         } else {\n             addExpr(last, p + 1, rhsContext);\n         }\n         return;\n     }\n     cc.startSourceMapping(n);\n     switch(type) {\n         case Token.TRY:\n             {\n                 Preconditions.checkState(first.getNext().getType() \u003d\u003d Token.BLOCK \u0026\u0026 first.getNext().getChildCount() \u003c\u003d 1);\n                 Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                 add(\"try\");\n                 add(first, Context.PRESERVE_BLOCK);\n                 Node catchblock \u003d first.getNext().getFirstChild();\n                 if (catchblock !\u003d null) {\n                     add(catchblock);\n                 }\n                 if (childCount \u003d\u003d 3) {\n                     add(\"finally\");\n                     add(last, Context.PRESERVE_BLOCK);\n                 }\n                 break;\n             }\n         case Token.CATCH:\n             Preconditions.checkState(childCount \u003d\u003d 3);\n             if (first.getNext().getType() !\u003d Token.EMPTY) {\n                 throw new Error(\"Catch conditions not suppored because I think\" + \" that it may be a netscape only feature.\");\n             }\n             add(\"catch(\");\n             add(first);\n             add(\")\");\n             add(last, Context.PRESERVE_BLOCK);\n             break;\n         case Token.THROW:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"throw\");\n             add(first);\n             cc.endStatement(true);\n             break;\n         case Token.RETURN:\n             add(\"return\");\n             if (childCount \u003d\u003d 1) {\n                 add(first);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 0);\n             }\n             cc.endStatement();\n             break;\n         case Token.VAR:\n             if (first !\u003d null) {\n                 add(\"var \");\n                 addList(first, false, getContextForNoInOperator(context));\n             }\n             break;\n         case Token.LABEL_NAME:\n             Preconditions.checkState(!n.getString().isEmpty());\n             addIdentifier(n.getString());\n             break;\n         case Token.NAME:\n             if (first \u003d\u003d null || first.getType() \u003d\u003d Token.EMPTY) {\n                 addIdentifier(n.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 addIdentifier(n.getString());\n                 cc.addOp(\"\u003d\", true);\n                 if (first.getType() \u003d\u003d Token.COMMA) {\n                     addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                 } else {\n                     addExpr(first, 0, getContextForNoInOperator(context));\n                 }\n             }\n             break;\n         case Token.ARRAYLIT:\n             add(\"[\");\n             addList(first, (int[]) n.getProp(Node.SKIP_INDEXES_PROP));\n             add(\"]\");\n             break;\n         case Token.LP:\n             add(\"(\");\n             addList(first);\n             add(\")\");\n             break;\n         case Token.COMMA:\n             addList(first, false, context);\n             break;\n         case Token.NUMBER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             cc.addNumber(n.getDouble());\n             break;\n         case Token.TYPEOF:\n         case Token.VOID:\n         case Token.NOT:\n         case Token.BITNOT:\n         case Token.POS:\n         case Token.NEG:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                 addExpr(first, NodeUtil.precedence(type));\n                 break;\n             }\n         case Token.HOOK:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 int p \u003d NodeUtil.precedence(type);\n                 addLeftExpr(first, p + 1, context);\n                 cc.addOp(\"?\", true);\n                 addExpr(first.getNext(), 1);\n                 cc.addOp(\":\", true);\n                 addExpr(last, 1);\n                 break;\n             }\n         case Token.REGEXP:\n             if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                 throw new Error(\"Expected children to be strings\");\n             }\n             String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n             if (childCount \u003d\u003d 2) {\n                 add(regexp + last.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 add(regexp);\n             }\n             break;\n         case Token.GET_REF:\n             add(first);\n             break;\n         case Token.REF_SPECIAL:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first);\n             add(\".\");\n             add((String) n.getProp(Node.NAME_PROP));\n             break;\n         case Token.FUNCTION:\n             if (n.getClass() !\u003d Node.class) {\n                 throw new Error(\"Unexpected Node subclass.\");\n             }\n             Preconditions.checkState(childCount \u003d\u003d 3);\n             boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n             if (funcNeedsParens) {\n                 add(\"(\");\n             }\n             add(\"function\");\n             add(first);\n             add(first.getNext());\n             add(last, Context.PRESERVE_BLOCK);\n             cc.endFunction(context \u003d\u003d Context.STATEMENT);\n             if (funcNeedsParens) {\n                 add(\")\");\n             }\n             break;\n         case Token.SCRIPT:\n         case Token.BLOCK:\n             {\n                 if (n.getClass() !\u003d Node.class) {\n                     throw new Error(\"Unexpected Node subclass.\");\n                 }\n                 boolean stripBlock \u003d n.isSyntheticBlock() || ((context !\u003d Context.PRESERVE_BLOCK) \u0026\u0026 (n.getChildCount() \u003c 2));\n                 if (!stripBlock) {\n                     cc.beginBlock();\n                 }\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     add(c, Context.STATEMENT);\n                     if (c.getType() \u003d\u003d Token.VAR) {\n                         cc.endStatement();\n                     }\n                     if (c.getType() \u003d\u003d Token.FUNCTION) {\n                         cc.maybeLineBreak();\n                     }\n                     if (type \u003d\u003d Token.SCRIPT) {\n                         cc.notePreferredLineBreak();\n                     }\n                 }\n                 if (!stripBlock) {\n                     cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                 }\n                 break;\n             }\n         case Token.FOR:\n             if (childCount \u003d\u003d 4) {\n                 add(\"for(\");\n                 if (first.getType() \u003d\u003d Token.VAR) {\n                     add(first, Context.IN_FOR_INIT_CLAUSE);\n                 } else {\n                     addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                 }\n                 add(\";\");\n                 add(first.getNext());\n                 add(\";\");\n                 add(first.getNext().getNext());\n                 add(\")\");\n                 addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 add(\"for(\");\n                 add(first);\n                 add(\"in\");\n                 add(first.getNext());\n                 add(\")\");\n                 addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             }\n             break;\n         case Token.DO:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"do\");\n             addNonEmptyExpression(first, Context.OTHER, false);\n             add(\"while(\");\n             add(last);\n             add(\")\");\n             cc.endStatement();\n             break;\n         case Token.WHILE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"while(\");\n             add(first);\n             add(\")\");\n             addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.EMPTY:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             break;\n         case Token.GETPROP:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 2);\n                 Preconditions.checkState(last.getType() \u003d\u003d Token.STRING);\n                 boolean needsParens \u003d (first.getType() \u003d\u003d Token.NUMBER);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 add(\".\");\n                 addIdentifier(last.getString());\n                 break;\n             }\n         case Token.GETELEM:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             addLeftExpr(first, NodeUtil.precedence(type), context);\n             add(\"[\");\n             add(first.getNext());\n             add(\"]\");\n             break;\n         case Token.WITH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"with(\");\n             add(first);\n             add(\")\");\n             addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.INC:\n         case Token.DEC:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n-                int postProp \u003d n.getIntProp(Node.INCRDECR_PROP, 0);\n+                int postProp \u003d n.getIntProp(Node.INCRDECR_PROP);\n                 if (postProp !\u003d 0) {\n                     addLeftExpr(first, NodeUtil.precedence(type), context);\n                     cc.addOp(o, false);\n                 } else {\n                     cc.addOp(o, false);\n                     add(first);\n                 }\n                 break;\n             }\n         case Token.CALL:\n             if (first.getType() \u003d\u003d Token.NAME \u0026\u0026 \"eval\".equals(first.getString()) \u0026\u0026 !first.getBooleanProp(Node.DIRECT_EVAL)) {\n                 add(\"(0,eval)\");\n             } else {\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n             }\n             add(\"(\");\n             addList(first.getNext());\n             add(\")\");\n             break;\n         case Token.IF:\n             boolean hasElse \u003d childCount \u003d\u003d 3;\n             boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n             if (ambiguousElseClause) {\n                 cc.beginBlock();\n             }\n             add(\"if(\");\n             add(first);\n             add(\")\");\n             if (hasElse) {\n                 addNonEmptyExpression(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                 add(\"else\");\n                 addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 addNonEmptyExpression(first.getNext(), Context.OTHER, false);\n                 Preconditions.checkState(childCount \u003d\u003d 2);\n             }\n             if (ambiguousElseClause) {\n                 cc.endBlock();\n             }\n             break;\n         case Token.NULL:\n         case Token.THIS:\n         case Token.FALSE:\n         case Token.TRUE:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(Node.tokenToName(type));\n             break;\n         case Token.CONTINUE:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"continue\");\n             if (childCount \u003d\u003d 1) {\n                 if (first.getType() !\u003d Token.LABEL_NAME) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.DEBUGGER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(\"debugger\");\n             cc.endStatement();\n             break;\n         case Token.BREAK:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"break\");\n             if (childCount \u003d\u003d 1) {\n                 if (first.getType() !\u003d Token.LABEL_NAME) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.EXPR_VOID:\n         case Token.EXPR_RESULT:\n             if (type \u003d\u003d Token.EXPR_VOID) {\n                 throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n             }\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first, Context.START_OF_EXPR);\n             cc.endStatement();\n             break;\n         case Token.NEW:\n             add(\"new \");\n             int precedence \u003d NodeUtil.precedence(type);\n             if (NodeUtil.containsCall(first)) {\n                 precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n             }\n             addExpr(first, precedence);\n             Node next \u003d first.getNext();\n             if (next !\u003d null) {\n                 add(\"(\");\n                 addList(next);\n                 add(\")\");\n             }\n             break;\n         case Token.STRING:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(jsString(n.getString(), outputCharsetEncoder));\n             break;\n         case Token.DELPROP:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"delete \");\n             add(first);\n             break;\n         case Token.OBJECTLIT:\n             {\n                 Preconditions.checkState(childCount % 2 \u003d\u003d 0);\n                 boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 add(\"{\");\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext().getNext()) {\n                     if (c !\u003d first) {\n                         cc.listSeparator();\n                     }\n                     if (c.getType() \u003d\u003d Token.STRING \u0026\u0026 !TokenStream.isKeyword(c.getString()) \u0026\u0026 TokenStream.isJSIdentifier(c.getString()) \u0026\u0026 NodeUtil.isLatin(c.getString())) {\n                         add(c.getString());\n                     } else {\n                         addExpr(c, 1);\n                     }\n                     add(\":\");\n                     addExpr(c.getNext(), 1);\n                 }\n                 add(\"}\");\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 break;\n             }\n         case Token.SWITCH:\n             add(\"switch(\");\n             add(first);\n             add(\")\");\n             cc.beginBlock();\n             addAllSiblings(first.getNext());\n             cc.endBlock(context \u003d\u003d Context.STATEMENT);\n             break;\n         case Token.CASE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"case \");\n             add(first);\n             addCaseBody(last);\n             break;\n         case Token.DEFAULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"default\");\n             addCaseBody(first);\n             break;\n         case Token.LABEL:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             if (first.getType() !\u003d Token.LABEL_NAME) {\n                 throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n             }\n             add(first);\n             add(\":\");\n             addNonEmptyExpression(last, getContextForNonEmptyExpression(context), true);\n             break;\n         case Token.SETNAME:\n             break;\n         default:\n             throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n     }\n     cc.endSourceMapping(n);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e33e925eea3a8e4de958864e531e1adc4da62e18": {
      "type": "Ybodychange",
      "commitMessage": "\nChange on 2010/06/14 by johnlenz\n\n        Remove unneed parenthese from hook expressions.\n\n        R\u003dacleung\n        DELTA\u003d76  (20 added, 4 deleted, 52 changed)\n\nChange on 2010/06/14 by johnlenz\n\n        Fix non-determinisim.\n\n        R\u003djschorr\n        DELTA\u003d5  (3 added, 0 deleted, 2 changed)\n\nChange on 2010/06/15 by nicksantos\n\n        fix a regression caused by a change in the ordering in which\n        constant folding is done.\n        parts of PeepholeSubstituteAlternateSyntax will crash if they\n        see a NEG node with a NUMBER child.\n        They were assuming that FoldConstants would fold these into one node.\n\n        R\u003ddcc,acleung\n        DELTA\u003d153  (70 added, 6 deleted, 77 changed)\n\nChange on 2010/06/15 by johnlenz\n\n        More debug diffing improvements: convert unique globally unique names\n        to locally unique names for reproduciblity.\n\n        R\u003dacleung\n        DELTA\u003d222  (44 added, 7 deleted, 171 changed)\n\nChange on 2010/06/15 by nicksantos\n\n        Add the @nocompile annotation as a signal that this file should\n        be dropped silently if it gets pulled into a --manage_closure_dependencies\n        build.\n\n        R\u003dbowdidge,gboyer\n        DELTA\u003d82  (60 added, 1 deleted, 21 changed)\n\nChange on 2010/06/15 by dcc\n\n        Refactor FoldConstants dead code removal into PeepholeRemoveDeadCode.\n\n        R\u003dacleung\n        DELTA\u003d744  (403 added, 307 deleted, 34 changed)\n\nChange on 2010/06/15 by dcc\n\n        ExternExports test now emits type annotation for exported externs.\n                - Changed ExternExportsPass to generate the externs as an AST and then print\n        to a String rather than ad hoc with a StringBuilder.\n                - Changed TypedCodeGenerator to generate \u0027*\u0027 (AllType) for parameters with unknown types rather than \u0027?\u0027 (UnknownType) since \u0027?\u0027 is not valid JSDoc.\n\n        R\u003dacleung\n        DELTA\u003d643  (496 added, 66 deleted, 81 changed)\n\nChange on 2010/06/16 by johnlenz\n\n        Tweak to PureFunctionIndentifier to propagate the side-effects for\n        anonymous function expressions like: (Date.now||function(){return\n        +new Date})()\n\n        R\u003davd\n        DELTA\u003d42  (39 added, 0 deleted, 3 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d29010\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@243 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "6/16/10, 12:33 PM",
      "commitName": "e33e925eea3a8e4de958864e531e1adc4da62e18",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "4/20/10, 2:39 PM",
      "commitNameOld": "0c3fdb92840718de9f9da085b818efb419cfb927",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 56.91,
      "commitsBetweenForRepo": 39,
      "commitsBetweenForFile": 1,
      "actualSource": "void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n        return;\n    }\n    int type \u003d n.getType();\n    String opstr \u003d NodeUtil.opToStr(type);\n    int childCount \u003d n.getChildCount();\n    Node first \u003d n.getFirstChild();\n    Node last \u003d n.getLastChild();\n    if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n        Preconditions.checkState(childCount \u003d\u003d 2);\n        int p \u003d NodeUtil.precedence(type);\n        addLeftExpr(first, p, context);\n        cc.addOp(opstr, true);\n        Context rhsContext \u003d getContextForNoInOperator(context);\n        if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n            addExpr(last, p, rhsContext);\n        } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n            addExpr(last, p, rhsContext);\n        } else {\n            addExpr(last, p + 1, rhsContext);\n        }\n        return;\n    }\n    cc.startSourceMapping(n);\n    switch(type) {\n        case Token.TRY:\n            {\n                Preconditions.checkState(first.getNext().getType() \u003d\u003d Token.BLOCK \u0026\u0026 first.getNext().getChildCount() \u003c\u003d 1);\n                Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                add(\"try\");\n                add(first, Context.PRESERVE_BLOCK);\n                Node catchblock \u003d first.getNext().getFirstChild();\n                if (catchblock !\u003d null) {\n                    add(catchblock);\n                }\n                if (childCount \u003d\u003d 3) {\n                    add(\"finally\");\n                    add(last, Context.PRESERVE_BLOCK);\n                }\n                break;\n            }\n        case Token.CATCH:\n            Preconditions.checkState(childCount \u003d\u003d 3);\n            if (first.getNext().getType() !\u003d Token.EMPTY) {\n                throw new Error(\"Catch conditions not suppored because I think\" + \" that it may be a netscape only feature.\");\n            }\n            add(\"catch(\");\n            add(first);\n            add(\")\");\n            add(last, Context.PRESERVE_BLOCK);\n            break;\n        case Token.THROW:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"throw\");\n            add(first);\n            cc.endStatement(true);\n            break;\n        case Token.RETURN:\n            add(\"return\");\n            if (childCount \u003d\u003d 1) {\n                add(first);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 0);\n            }\n            cc.endStatement();\n            break;\n        case Token.VAR:\n            if (first !\u003d null) {\n                add(\"var \");\n                addList(first, false, getContextForNoInOperator(context));\n            }\n            break;\n        case Token.LABEL_NAME:\n            Preconditions.checkState(!n.getString().isEmpty());\n            addIdentifier(n.getString());\n            break;\n        case Token.NAME:\n            if (first \u003d\u003d null || first.getType() \u003d\u003d Token.EMPTY) {\n                addIdentifier(n.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                addIdentifier(n.getString());\n                cc.addOp(\"\u003d\", true);\n                if (first.getType() \u003d\u003d Token.COMMA) {\n                    addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                } else {\n                    addExpr(first, 0, getContextForNoInOperator(context));\n                }\n            }\n            break;\n        case Token.ARRAYLIT:\n            add(\"[\");\n            addList(first, (int[]) n.getProp(Node.SKIP_INDEXES_PROP));\n            add(\"]\");\n            break;\n        case Token.LP:\n            add(\"(\");\n            addList(first);\n            add(\")\");\n            break;\n        case Token.COMMA:\n            addList(first, false, context);\n            break;\n        case Token.NUMBER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            cc.addNumber(n.getDouble());\n            break;\n        case Token.TYPEOF:\n        case Token.VOID:\n        case Token.NOT:\n        case Token.BITNOT:\n        case Token.POS:\n        case Token.NEG:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                addExpr(first, NodeUtil.precedence(type));\n                break;\n            }\n        case Token.HOOK:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                int p \u003d NodeUtil.precedence(type);\n                addLeftExpr(first, p + 1, context);\n                cc.addOp(\"?\", true);\n                addExpr(first.getNext(), 1);\n                cc.addOp(\":\", true);\n                addExpr(last, 1);\n                break;\n            }\n        case Token.REGEXP:\n            if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                throw new Error(\"Expected children to be strings\");\n            }\n            String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n            if (childCount \u003d\u003d 2) {\n                add(regexp + last.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                add(regexp);\n            }\n            break;\n        case Token.GET_REF:\n            add(first);\n            break;\n        case Token.REF_SPECIAL:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first);\n            add(\".\");\n            add((String) n.getProp(Node.NAME_PROP));\n            break;\n        case Token.FUNCTION:\n            if (n.getClass() !\u003d Node.class) {\n                throw new Error(\"Unexpected Node subclass.\");\n            }\n            Preconditions.checkState(childCount \u003d\u003d 3);\n            boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n            if (funcNeedsParens) {\n                add(\"(\");\n            }\n            add(\"function\");\n            add(first);\n            add(first.getNext());\n            add(last, Context.PRESERVE_BLOCK);\n            cc.endFunction(context \u003d\u003d Context.STATEMENT);\n            if (funcNeedsParens) {\n                add(\")\");\n            }\n            break;\n        case Token.SCRIPT:\n        case Token.BLOCK:\n            {\n                if (n.getClass() !\u003d Node.class) {\n                    throw new Error(\"Unexpected Node subclass.\");\n                }\n                boolean stripBlock \u003d n.isSyntheticBlock() || ((context !\u003d Context.PRESERVE_BLOCK) \u0026\u0026 (n.getChildCount() \u003c 2));\n                if (!stripBlock) {\n                    cc.beginBlock();\n                }\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    add(c, Context.STATEMENT);\n                    if (c.getType() \u003d\u003d Token.VAR) {\n                        cc.endStatement();\n                    }\n                    if (c.getType() \u003d\u003d Token.FUNCTION) {\n                        cc.maybeLineBreak();\n                    }\n                    if (type \u003d\u003d Token.SCRIPT) {\n                        cc.notePreferredLineBreak();\n                    }\n                }\n                if (!stripBlock) {\n                    cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                }\n                break;\n            }\n        case Token.FOR:\n            if (childCount \u003d\u003d 4) {\n                add(\"for(\");\n                if (first.getType() \u003d\u003d Token.VAR) {\n                    add(first, Context.IN_FOR_INIT_CLAUSE);\n                } else {\n                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                }\n                add(\";\");\n                add(first.getNext());\n                add(\";\");\n                add(first.getNext().getNext());\n                add(\")\");\n                addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                add(\"for(\");\n                add(first);\n                add(\"in\");\n                add(first.getNext());\n                add(\")\");\n                addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            }\n            break;\n        case Token.DO:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"do\");\n            addNonEmptyExpression(first, Context.OTHER, false);\n            add(\"while(\");\n            add(last);\n            add(\")\");\n            cc.endStatement();\n            break;\n        case Token.WHILE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"while(\");\n            add(first);\n            add(\")\");\n            addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.EMPTY:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            break;\n        case Token.GETPROP:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 2);\n                Preconditions.checkState(last.getType() \u003d\u003d Token.STRING);\n                boolean needsParens \u003d (first.getType() \u003d\u003d Token.NUMBER);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n                if (needsParens) {\n                    add(\")\");\n                }\n                add(\".\");\n                addIdentifier(last.getString());\n                break;\n            }\n        case Token.GETELEM:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            addLeftExpr(first, NodeUtil.precedence(type), context);\n            add(\"[\");\n            add(first.getNext());\n            add(\"]\");\n            break;\n        case Token.WITH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"with(\");\n            add(first);\n            add(\")\");\n            addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.INC:\n        case Token.DEC:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                int postProp \u003d n.getIntProp(Node.INCRDECR_PROP, 0);\n                if (postProp !\u003d 0) {\n                    addLeftExpr(first, NodeUtil.precedence(type), context);\n                    cc.addOp(o, false);\n                } else {\n                    cc.addOp(o, false);\n                    add(first);\n                }\n                break;\n            }\n        case Token.CALL:\n            if (first.getType() \u003d\u003d Token.NAME \u0026\u0026 \"eval\".equals(first.getString()) \u0026\u0026 !first.getBooleanProp(Node.DIRECT_EVAL)) {\n                add(\"(0,eval)\");\n            } else {\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n            }\n            add(\"(\");\n            addList(first.getNext());\n            add(\")\");\n            break;\n        case Token.IF:\n            boolean hasElse \u003d childCount \u003d\u003d 3;\n            boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n            if (ambiguousElseClause) {\n                cc.beginBlock();\n            }\n            add(\"if(\");\n            add(first);\n            add(\")\");\n            if (hasElse) {\n                addNonEmptyExpression(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                add(\"else\");\n                addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                addNonEmptyExpression(first.getNext(), Context.OTHER, false);\n                Preconditions.checkState(childCount \u003d\u003d 2);\n            }\n            if (ambiguousElseClause) {\n                cc.endBlock();\n            }\n            break;\n        case Token.NULL:\n        case Token.THIS:\n        case Token.FALSE:\n        case Token.TRUE:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(Node.tokenToName(type));\n            break;\n        case Token.CONTINUE:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"continue\");\n            if (childCount \u003d\u003d 1) {\n                if (first.getType() !\u003d Token.LABEL_NAME) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.DEBUGGER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"debugger\");\n            cc.endStatement();\n            break;\n        case Token.BREAK:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"break\");\n            if (childCount \u003d\u003d 1) {\n                if (first.getType() !\u003d Token.LABEL_NAME) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.EXPR_VOID:\n        case Token.EXPR_RESULT:\n            if (type \u003d\u003d Token.EXPR_VOID) {\n                throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n            }\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first, Context.START_OF_EXPR);\n            cc.endStatement();\n            break;\n        case Token.NEW:\n            add(\"new \");\n            int precedence \u003d NodeUtil.precedence(type);\n            if (NodeUtil.containsCall(first)) {\n                precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n            }\n            addExpr(first, precedence);\n            Node next \u003d first.getNext();\n            if (next !\u003d null) {\n                add(\"(\");\n                addList(next);\n                add(\")\");\n            }\n            break;\n        case Token.STRING:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(jsString(n.getString(), outputCharsetEncoder));\n            break;\n        case Token.DELPROP:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"delete \");\n            add(first);\n            break;\n        case Token.OBJECTLIT:\n            {\n                Preconditions.checkState(childCount % 2 \u003d\u003d 0);\n                boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                add(\"{\");\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext().getNext()) {\n                    if (c !\u003d first) {\n                        cc.listSeparator();\n                    }\n                    if (c.getType() \u003d\u003d Token.STRING \u0026\u0026 !TokenStream.isKeyword(c.getString()) \u0026\u0026 TokenStream.isJSIdentifier(c.getString()) \u0026\u0026 NodeUtil.isLatin(c.getString())) {\n                        add(c.getString());\n                    } else {\n                        addExpr(c, 1);\n                    }\n                    add(\":\");\n                    addExpr(c.getNext(), 1);\n                }\n                add(\"}\");\n                if (needsParens) {\n                    add(\")\");\n                }\n                break;\n            }\n        case Token.SWITCH:\n            add(\"switch(\");\n            add(first);\n            add(\")\");\n            cc.beginBlock();\n            addAllSiblings(first.getNext());\n            cc.endBlock(context \u003d\u003d Context.STATEMENT);\n            break;\n        case Token.CASE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"case \");\n            add(first);\n            addCaseBody(last);\n            break;\n        case Token.DEFAULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"default\");\n            addCaseBody(first);\n            break;\n        case Token.LABEL:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            if (first.getType() !\u003d Token.LABEL_NAME) {\n                throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n            }\n            add(first);\n            add(\":\");\n            addNonEmptyExpression(last, getContextForNonEmptyExpression(context), true);\n            break;\n        case Token.SETNAME:\n            break;\n        default:\n            throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n    cc.endSourceMapping(n);\n}",
      "path": "src/com/google/javascript/jscomp/CodeGenerator.java",
      "functionStartLine": 76,
      "functionName": "add",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,445 +1,445 @@\n void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n         return;\n     }\n     int type \u003d n.getType();\n     String opstr \u003d NodeUtil.opToStr(type);\n     int childCount \u003d n.getChildCount();\n     Node first \u003d n.getFirstChild();\n     Node last \u003d n.getLastChild();\n     if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n         Preconditions.checkState(childCount \u003d\u003d 2);\n         int p \u003d NodeUtil.precedence(type);\n         addLeftExpr(first, p, context);\n         cc.addOp(opstr, true);\n         Context rhsContext \u003d getContextForNoInOperator(context);\n         if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n             addExpr(last, p, rhsContext);\n         } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n             addExpr(last, p, rhsContext);\n         } else {\n             addExpr(last, p + 1, rhsContext);\n         }\n         return;\n     }\n     cc.startSourceMapping(n);\n     switch(type) {\n         case Token.TRY:\n             {\n                 Preconditions.checkState(first.getNext().getType() \u003d\u003d Token.BLOCK \u0026\u0026 first.getNext().getChildCount() \u003c\u003d 1);\n                 Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                 add(\"try\");\n                 add(first, Context.PRESERVE_BLOCK);\n                 Node catchblock \u003d first.getNext().getFirstChild();\n                 if (catchblock !\u003d null) {\n                     add(catchblock);\n                 }\n                 if (childCount \u003d\u003d 3) {\n                     add(\"finally\");\n                     add(last, Context.PRESERVE_BLOCK);\n                 }\n                 break;\n             }\n         case Token.CATCH:\n             Preconditions.checkState(childCount \u003d\u003d 3);\n             if (first.getNext().getType() !\u003d Token.EMPTY) {\n                 throw new Error(\"Catch conditions not suppored because I think\" + \" that it may be a netscape only feature.\");\n             }\n             add(\"catch(\");\n             add(first);\n             add(\")\");\n             add(last, Context.PRESERVE_BLOCK);\n             break;\n         case Token.THROW:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"throw\");\n             add(first);\n             cc.endStatement(true);\n             break;\n         case Token.RETURN:\n             add(\"return\");\n             if (childCount \u003d\u003d 1) {\n                 add(first);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 0);\n             }\n             cc.endStatement();\n             break;\n         case Token.VAR:\n             if (first !\u003d null) {\n                 add(\"var \");\n                 addList(first, false, getContextForNoInOperator(context));\n             }\n             break;\n         case Token.LABEL_NAME:\n             Preconditions.checkState(!n.getString().isEmpty());\n             addIdentifier(n.getString());\n             break;\n         case Token.NAME:\n             if (first \u003d\u003d null || first.getType() \u003d\u003d Token.EMPTY) {\n                 addIdentifier(n.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 addIdentifier(n.getString());\n                 cc.addOp(\"\u003d\", true);\n                 if (first.getType() \u003d\u003d Token.COMMA) {\n                     addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                 } else {\n                     addExpr(first, 0, getContextForNoInOperator(context));\n                 }\n             }\n             break;\n         case Token.ARRAYLIT:\n             add(\"[\");\n             addList(first, (int[]) n.getProp(Node.SKIP_INDEXES_PROP));\n             add(\"]\");\n             break;\n         case Token.LP:\n             add(\"(\");\n             addList(first);\n             add(\")\");\n             break;\n         case Token.COMMA:\n             addList(first, false, context);\n             break;\n         case Token.NUMBER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             cc.addNumber(n.getDouble());\n             break;\n         case Token.TYPEOF:\n         case Token.VOID:\n         case Token.NOT:\n         case Token.BITNOT:\n         case Token.POS:\n         case Token.NEG:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                 addExpr(first, NodeUtil.precedence(type));\n                 break;\n             }\n         case Token.HOOK:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 int p \u003d NodeUtil.precedence(type);\n                 addLeftExpr(first, p + 1, context);\n                 cc.addOp(\"?\", true);\n-                addExpr(first.getNext(), p);\n+                addExpr(first.getNext(), 1);\n                 cc.addOp(\":\", true);\n-                addExpr(last, p);\n+                addExpr(last, 1);\n                 break;\n             }\n         case Token.REGEXP:\n             if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                 throw new Error(\"Expected children to be strings\");\n             }\n             String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n             if (childCount \u003d\u003d 2) {\n                 add(regexp + last.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 add(regexp);\n             }\n             break;\n         case Token.GET_REF:\n             add(first);\n             break;\n         case Token.REF_SPECIAL:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first);\n             add(\".\");\n             add((String) n.getProp(Node.NAME_PROP));\n             break;\n         case Token.FUNCTION:\n             if (n.getClass() !\u003d Node.class) {\n                 throw new Error(\"Unexpected Node subclass.\");\n             }\n             Preconditions.checkState(childCount \u003d\u003d 3);\n             boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n             if (funcNeedsParens) {\n                 add(\"(\");\n             }\n             add(\"function\");\n             add(first);\n             add(first.getNext());\n             add(last, Context.PRESERVE_BLOCK);\n             cc.endFunction(context \u003d\u003d Context.STATEMENT);\n             if (funcNeedsParens) {\n                 add(\")\");\n             }\n             break;\n         case Token.SCRIPT:\n         case Token.BLOCK:\n             {\n                 if (n.getClass() !\u003d Node.class) {\n                     throw new Error(\"Unexpected Node subclass.\");\n                 }\n                 boolean stripBlock \u003d n.isSyntheticBlock() || ((context !\u003d Context.PRESERVE_BLOCK) \u0026\u0026 (n.getChildCount() \u003c 2));\n                 if (!stripBlock) {\n                     cc.beginBlock();\n                 }\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     add(c, Context.STATEMENT);\n                     if (c.getType() \u003d\u003d Token.VAR) {\n                         cc.endStatement();\n                     }\n                     if (c.getType() \u003d\u003d Token.FUNCTION) {\n                         cc.maybeLineBreak();\n                     }\n                     if (type \u003d\u003d Token.SCRIPT) {\n                         cc.notePreferredLineBreak();\n                     }\n                 }\n                 if (!stripBlock) {\n                     cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                 }\n                 break;\n             }\n         case Token.FOR:\n             if (childCount \u003d\u003d 4) {\n                 add(\"for(\");\n                 if (first.getType() \u003d\u003d Token.VAR) {\n                     add(first, Context.IN_FOR_INIT_CLAUSE);\n                 } else {\n                     addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                 }\n                 add(\";\");\n                 add(first.getNext());\n                 add(\";\");\n                 add(first.getNext().getNext());\n                 add(\")\");\n                 addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 add(\"for(\");\n                 add(first);\n                 add(\"in\");\n                 add(first.getNext());\n                 add(\")\");\n                 addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             }\n             break;\n         case Token.DO:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"do\");\n             addNonEmptyExpression(first, Context.OTHER, false);\n             add(\"while(\");\n             add(last);\n             add(\")\");\n             cc.endStatement();\n             break;\n         case Token.WHILE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"while(\");\n             add(first);\n             add(\")\");\n             addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.EMPTY:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             break;\n         case Token.GETPROP:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 2);\n                 Preconditions.checkState(last.getType() \u003d\u003d Token.STRING);\n                 boolean needsParens \u003d (first.getType() \u003d\u003d Token.NUMBER);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 add(\".\");\n                 addIdentifier(last.getString());\n                 break;\n             }\n         case Token.GETELEM:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             addLeftExpr(first, NodeUtil.precedence(type), context);\n             add(\"[\");\n             add(first.getNext());\n             add(\"]\");\n             break;\n         case Token.WITH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"with(\");\n             add(first);\n             add(\")\");\n             addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.INC:\n         case Token.DEC:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                 int postProp \u003d n.getIntProp(Node.INCRDECR_PROP, 0);\n                 if (postProp !\u003d 0) {\n                     addLeftExpr(first, NodeUtil.precedence(type), context);\n                     cc.addOp(o, false);\n                 } else {\n                     cc.addOp(o, false);\n                     add(first);\n                 }\n                 break;\n             }\n         case Token.CALL:\n             if (first.getType() \u003d\u003d Token.NAME \u0026\u0026 \"eval\".equals(first.getString()) \u0026\u0026 !first.getBooleanProp(Node.DIRECT_EVAL)) {\n                 add(\"(0,eval)\");\n             } else {\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n             }\n             add(\"(\");\n             addList(first.getNext());\n             add(\")\");\n             break;\n         case Token.IF:\n             boolean hasElse \u003d childCount \u003d\u003d 3;\n             boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n             if (ambiguousElseClause) {\n                 cc.beginBlock();\n             }\n             add(\"if(\");\n             add(first);\n             add(\")\");\n             if (hasElse) {\n                 addNonEmptyExpression(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                 add(\"else\");\n                 addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 addNonEmptyExpression(first.getNext(), Context.OTHER, false);\n                 Preconditions.checkState(childCount \u003d\u003d 2);\n             }\n             if (ambiguousElseClause) {\n                 cc.endBlock();\n             }\n             break;\n         case Token.NULL:\n         case Token.THIS:\n         case Token.FALSE:\n         case Token.TRUE:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(Node.tokenToName(type));\n             break;\n         case Token.CONTINUE:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"continue\");\n             if (childCount \u003d\u003d 1) {\n                 if (first.getType() !\u003d Token.LABEL_NAME) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.DEBUGGER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(\"debugger\");\n             cc.endStatement();\n             break;\n         case Token.BREAK:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"break\");\n             if (childCount \u003d\u003d 1) {\n                 if (first.getType() !\u003d Token.LABEL_NAME) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.EXPR_VOID:\n         case Token.EXPR_RESULT:\n             if (type \u003d\u003d Token.EXPR_VOID) {\n                 throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n             }\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first, Context.START_OF_EXPR);\n             cc.endStatement();\n             break;\n         case Token.NEW:\n             add(\"new \");\n             int precedence \u003d NodeUtil.precedence(type);\n             if (NodeUtil.containsCall(first)) {\n                 precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n             }\n             addExpr(first, precedence);\n             Node next \u003d first.getNext();\n             if (next !\u003d null) {\n                 add(\"(\");\n                 addList(next);\n                 add(\")\");\n             }\n             break;\n         case Token.STRING:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(jsString(n.getString(), outputCharsetEncoder));\n             break;\n         case Token.DELPROP:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"delete \");\n             add(first);\n             break;\n         case Token.OBJECTLIT:\n             {\n                 Preconditions.checkState(childCount % 2 \u003d\u003d 0);\n                 boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 add(\"{\");\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext().getNext()) {\n                     if (c !\u003d first) {\n                         cc.listSeparator();\n                     }\n                     if (c.getType() \u003d\u003d Token.STRING \u0026\u0026 !TokenStream.isKeyword(c.getString()) \u0026\u0026 TokenStream.isJSIdentifier(c.getString()) \u0026\u0026 NodeUtil.isLatin(c.getString())) {\n                         add(c.getString());\n                     } else {\n                         addExpr(c, 1);\n                     }\n                     add(\":\");\n                     addExpr(c.getNext(), 1);\n                 }\n                 add(\"}\");\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 break;\n             }\n         case Token.SWITCH:\n             add(\"switch(\");\n             add(first);\n             add(\")\");\n             cc.beginBlock();\n             addAllSiblings(first.getNext());\n             cc.endBlock(context \u003d\u003d Context.STATEMENT);\n             break;\n         case Token.CASE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"case \");\n             add(first);\n             addCaseBody(last);\n             break;\n         case Token.DEFAULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"default\");\n             addCaseBody(first);\n             break;\n         case Token.LABEL:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             if (first.getType() !\u003d Token.LABEL_NAME) {\n                 throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n             }\n             add(first);\n             add(\":\");\n             addNonEmptyExpression(last, getContextForNonEmptyExpression(context), true);\n             break;\n         case Token.SETNAME:\n             break;\n         default:\n             throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n     }\n     cc.endSourceMapping(n);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "43859717972907dd1ecebd8dca6e05036386e28b": {
      "type": "Ybodychange",
      "commitMessage": "\nChange on 2010/04/14 by john\n\n        Stop creating specialized Node types for FUNCTION and SCRIPT as the added functionality isn\u0027t used anywhere.\n\n        Also correct some formatting issue with Node (as it won\u0027t need to be merged with anything else anymore).\n\n        R\u003dsteve,robert\n        DELTA\u003d3969  (1913 added, 1925 deleted, 131 changed)\n\nChange on 2010/04/14 by john\n\n        Fix source information in MinimizeExitPoints.\n\n        R\u003drobert\n        DELTA\u003d10  (5 added, 2 deleted, 3 changed)\n\nChange on 2010/04/14 by john\n\n        Maintain source information.\n\n        R\u003dantonio\n        DELTA\u003d17  (11 added, 0 deleted, 6 changed)\n\nChange on 2010/04/14 by john\n\n        Maintain source information through FoldConstants.\n\n        R\u003drobert\n        DELTA\u003d42  (22 added, 0 deleted, 20 changed)\n\nChange on 2010/04/14 by nick\n\n        lock down function type construction\n\n        R\u003djohn\n        DELTA\u003d111  (83 added, 9 deleted, 19 changed)\n\nChange on 2010/04/14 by john\n\n        Fix source info in CollapseProperties.\n\n        R\u003dnick\n        DELTA\u003d17  (8 added, 3 deleted, 6 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003dmbevwz\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@184 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/14/10, 4:53 PM",
      "commitName": "43859717972907dd1ecebd8dca6e05036386e28b",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "4/13/10, 2:39 PM",
      "commitNameOld": "de13c3313c05f4449c50c560324389d6905a214d",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 1.09,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n        return;\n    }\n    int type \u003d n.getType();\n    String opstr \u003d NodeUtil.opToStr(type);\n    int childCount \u003d n.getChildCount();\n    Node first \u003d n.getFirstChild();\n    Node last \u003d n.getLastChild();\n    if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n        Preconditions.checkState(childCount \u003d\u003d 2);\n        int p \u003d NodeUtil.precedence(type);\n        addLeftExpr(first, p, context);\n        cc.addOp(opstr, true);\n        Context rhsContext \u003d getContextForNoInOperator(context);\n        if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n            addExpr(last, p, rhsContext);\n        } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n            addExpr(last, p, rhsContext);\n        } else {\n            addExpr(last, p + 1, rhsContext);\n        }\n        return;\n    }\n    cc.startSourceMapping(n);\n    switch(type) {\n        case Token.TRY:\n            {\n                Preconditions.checkState(first.getNext().getType() \u003d\u003d Token.BLOCK \u0026\u0026 first.getNext().getChildCount() \u003c\u003d 1);\n                Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                add(\"try\");\n                add(first, Context.PRESERVE_BLOCK);\n                Node catchblock \u003d first.getNext().getFirstChild();\n                if (catchblock !\u003d null) {\n                    add(catchblock);\n                }\n                if (childCount \u003d\u003d 3) {\n                    add(\"finally\");\n                    add(last, Context.PRESERVE_BLOCK);\n                }\n                break;\n            }\n        case Token.CATCH:\n            Preconditions.checkState(childCount \u003d\u003d 3);\n            if (first.getNext().getType() !\u003d Token.EMPTY) {\n                throw new Error(\"Catch conditions not suppored because I think\" + \" that it may be a netscape only feature.\");\n            }\n            add(\"catch(\");\n            add(first);\n            add(\")\");\n            add(last, Context.PRESERVE_BLOCK);\n            break;\n        case Token.THROW:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"throw\");\n            add(first);\n            cc.endStatement(true);\n            break;\n        case Token.RETURN:\n            add(\"return\");\n            if (childCount \u003d\u003d 1) {\n                add(first);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 0);\n            }\n            cc.endStatement();\n            break;\n        case Token.VAR:\n            if (first !\u003d null) {\n                add(\"var \");\n                addList(first, false, getContextForNoInOperator(context));\n            }\n            break;\n        case Token.LABEL_NAME:\n            Preconditions.checkState(!n.getString().isEmpty());\n            addIdentifier(n.getString());\n            break;\n        case Token.NAME:\n            if (first \u003d\u003d null || first.getType() \u003d\u003d Token.EMPTY) {\n                addIdentifier(n.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                addIdentifier(n.getString());\n                cc.addOp(\"\u003d\", true);\n                if (first.getType() \u003d\u003d Token.COMMA) {\n                    addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                } else {\n                    addExpr(first, 0, getContextForNoInOperator(context));\n                }\n            }\n            break;\n        case Token.ARRAYLIT:\n            add(\"[\");\n            addList(first, (int[]) n.getProp(Node.SKIP_INDEXES_PROP));\n            add(\"]\");\n            break;\n        case Token.LP:\n            add(\"(\");\n            addList(first);\n            add(\")\");\n            break;\n        case Token.COMMA:\n            addList(first, false, context);\n            break;\n        case Token.NUMBER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            cc.addNumber(n.getDouble());\n            break;\n        case Token.TYPEOF:\n        case Token.VOID:\n        case Token.NOT:\n        case Token.BITNOT:\n        case Token.POS:\n        case Token.NEG:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                addExpr(first, NodeUtil.precedence(type));\n                break;\n            }\n        case Token.HOOK:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                int p \u003d NodeUtil.precedence(type);\n                addLeftExpr(first, p + 1, context);\n                cc.addOp(\"?\", true);\n                addExpr(first.getNext(), p);\n                cc.addOp(\":\", true);\n                addExpr(last, p);\n                break;\n            }\n        case Token.REGEXP:\n            if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                throw new Error(\"Expected children to be strings\");\n            }\n            String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n            if (childCount \u003d\u003d 2) {\n                add(regexp + last.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                add(regexp);\n            }\n            break;\n        case Token.GET_REF:\n            add(first);\n            break;\n        case Token.REF_SPECIAL:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first);\n            add(\".\");\n            add((String) n.getProp(Node.NAME_PROP));\n            break;\n        case Token.FUNCTION:\n            if (n.getClass() !\u003d Node.class) {\n                throw new Error(\"Unexpected Node subclass.\");\n            }\n            Preconditions.checkState(childCount \u003d\u003d 3);\n            boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n            if (funcNeedsParens) {\n                add(\"(\");\n            }\n            add(\"function\");\n            add(first);\n            add(first.getNext());\n            add(last, Context.PRESERVE_BLOCK);\n            cc.endFunction(context \u003d\u003d Context.STATEMENT);\n            if (funcNeedsParens) {\n                add(\")\");\n            }\n            break;\n        case Token.SCRIPT:\n        case Token.BLOCK:\n            {\n                if (n.getClass() !\u003d Node.class) {\n                    throw new Error(\"Unexpected Node subclass.\");\n                }\n                boolean stripBlock \u003d n.isSyntheticBlock() || ((context !\u003d Context.PRESERVE_BLOCK) \u0026\u0026 (n.getChildCount() \u003c 2));\n                if (!stripBlock) {\n                    cc.beginBlock();\n                }\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    add(c, Context.STATEMENT);\n                    if (c.getType() \u003d\u003d Token.VAR) {\n                        cc.endStatement();\n                    }\n                    if (c.getType() \u003d\u003d Token.FUNCTION) {\n                        cc.maybeLineBreak();\n                    }\n                    if (type \u003d\u003d Token.SCRIPT) {\n                        cc.notePreferredLineBreak();\n                    }\n                }\n                if (!stripBlock) {\n                    cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                }\n                break;\n            }\n        case Token.FOR:\n            if (childCount \u003d\u003d 4) {\n                add(\"for(\");\n                if (first.getType() \u003d\u003d Token.VAR) {\n                    add(first, Context.IN_FOR_INIT_CLAUSE);\n                } else {\n                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                }\n                add(\";\");\n                add(first.getNext());\n                add(\";\");\n                add(first.getNext().getNext());\n                add(\")\");\n                addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                add(\"for(\");\n                add(first);\n                add(\"in\");\n                add(first.getNext());\n                add(\")\");\n                addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            }\n            break;\n        case Token.DO:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"do\");\n            addNonEmptyExpression(first, Context.OTHER, false);\n            add(\"while(\");\n            add(last);\n            add(\")\");\n            cc.endStatement();\n            break;\n        case Token.WHILE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"while(\");\n            add(first);\n            add(\")\");\n            addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.EMPTY:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            break;\n        case Token.GETPROP:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 2);\n                Preconditions.checkState(last.getType() \u003d\u003d Token.STRING);\n                boolean needsParens \u003d (first.getType() \u003d\u003d Token.NUMBER);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n                if (needsParens) {\n                    add(\")\");\n                }\n                add(\".\");\n                addIdentifier(last.getString());\n                break;\n            }\n        case Token.GETELEM:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            addLeftExpr(first, NodeUtil.precedence(type), context);\n            add(\"[\");\n            add(first.getNext());\n            add(\"]\");\n            break;\n        case Token.WITH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"with(\");\n            add(first);\n            add(\")\");\n            addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.INC:\n        case Token.DEC:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                int postProp \u003d n.getIntProp(Node.INCRDECR_PROP, 0);\n                if (postProp !\u003d 0) {\n                    addLeftExpr(first, NodeUtil.precedence(type), context);\n                    cc.addOp(o, false);\n                } else {\n                    cc.addOp(o, false);\n                    add(first);\n                }\n                break;\n            }\n        case Token.CALL:\n            if (first.getType() \u003d\u003d Token.NAME \u0026\u0026 \"eval\".equals(first.getString()) \u0026\u0026 !first.getBooleanProp(Node.DIRECT_EVAL)) {\n                add(\"(0,eval)\");\n            } else {\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n            }\n            add(\"(\");\n            addList(first.getNext());\n            add(\")\");\n            break;\n        case Token.IF:\n            boolean hasElse \u003d childCount \u003d\u003d 3;\n            boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n            if (ambiguousElseClause) {\n                cc.beginBlock();\n            }\n            add(\"if(\");\n            add(first);\n            add(\")\");\n            if (hasElse) {\n                addNonEmptyExpression(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                add(\"else\");\n                addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                addNonEmptyExpression(first.getNext(), Context.OTHER, false);\n                Preconditions.checkState(childCount \u003d\u003d 2);\n            }\n            if (ambiguousElseClause) {\n                cc.endBlock();\n            }\n            break;\n        case Token.NULL:\n        case Token.THIS:\n        case Token.FALSE:\n        case Token.TRUE:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(Node.tokenToName(type));\n            break;\n        case Token.CONTINUE:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"continue\");\n            if (childCount \u003d\u003d 1) {\n                if (first.getType() !\u003d Token.LABEL_NAME) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.DEBUGGER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"debugger\");\n            cc.endStatement();\n            break;\n        case Token.BREAK:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"break\");\n            if (childCount \u003d\u003d 1) {\n                if (first.getType() !\u003d Token.LABEL_NAME) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.EXPR_VOID:\n        case Token.EXPR_RESULT:\n            if (type \u003d\u003d Token.EXPR_VOID) {\n                throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n            }\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first, Context.START_OF_EXPR);\n            cc.endStatement();\n            break;\n        case Token.NEW:\n            add(\"new \");\n            int precedence \u003d NodeUtil.precedence(type);\n            if (NodeUtil.containsCall(first)) {\n                precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n            }\n            addExpr(first, precedence);\n            Node next \u003d first.getNext();\n            if (next !\u003d null) {\n                add(\"(\");\n                addList(next);\n                add(\")\");\n            }\n            break;\n        case Token.STRING:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(jsString(n.getString(), outputCharsetEncoder));\n            break;\n        case Token.DELPROP:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"delete \");\n            add(first);\n            break;\n        case Token.OBJECTLIT:\n            {\n                Preconditions.checkState(childCount % 2 \u003d\u003d 0);\n                boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                add(\"{\");\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext().getNext()) {\n                    if (c !\u003d first) {\n                        cc.listSeparator();\n                    }\n                    if (c.getType() \u003d\u003d Token.STRING \u0026\u0026 !TokenStream.isKeyword(c.getString()) \u0026\u0026 TokenStream.isJSIdentifier(c.getString()) \u0026\u0026 NodeUtil.isLatin(c.getString())) {\n                        add(c.getString());\n                    } else {\n                        addExpr(c, 1);\n                    }\n                    add(\":\");\n                    addExpr(c.getNext(), 1);\n                }\n                add(\"}\");\n                if (needsParens) {\n                    add(\")\");\n                }\n                break;\n            }\n        case Token.SWITCH:\n            add(\"switch(\");\n            add(first);\n            add(\")\");\n            cc.beginBlock();\n            addAllSiblings(first.getNext());\n            cc.endBlock(context \u003d\u003d Context.STATEMENT);\n            break;\n        case Token.CASE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"case \");\n            add(first);\n            addCaseBody(last);\n            break;\n        case Token.DEFAULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"default\");\n            addCaseBody(first);\n            break;\n        case Token.LABEL:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            if (first.getType() !\u003d Token.LABEL_NAME) {\n                throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n            }\n            add(first);\n            add(\":\");\n            addNonEmptyExpression(last, getContextForNonEmptyExpression(context), true);\n            break;\n        case Token.SETNAME:\n            break;\n        default:\n            throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n    cc.endSourceMapping(n);\n}",
      "path": "src/com/google/javascript/jscomp/CodeGenerator.java",
      "functionStartLine": 76,
      "functionName": "add",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,439 +1,445 @@\n void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n         return;\n     }\n     int type \u003d n.getType();\n     String opstr \u003d NodeUtil.opToStr(type);\n     int childCount \u003d n.getChildCount();\n     Node first \u003d n.getFirstChild();\n     Node last \u003d n.getLastChild();\n     if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n         Preconditions.checkState(childCount \u003d\u003d 2);\n         int p \u003d NodeUtil.precedence(type);\n         addLeftExpr(first, p, context);\n         cc.addOp(opstr, true);\n         Context rhsContext \u003d getContextForNoInOperator(context);\n         if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n             addExpr(last, p, rhsContext);\n         } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n             addExpr(last, p, rhsContext);\n         } else {\n             addExpr(last, p + 1, rhsContext);\n         }\n         return;\n     }\n     cc.startSourceMapping(n);\n     switch(type) {\n         case Token.TRY:\n             {\n                 Preconditions.checkState(first.getNext().getType() \u003d\u003d Token.BLOCK \u0026\u0026 first.getNext().getChildCount() \u003c\u003d 1);\n                 Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                 add(\"try\");\n                 add(first, Context.PRESERVE_BLOCK);\n                 Node catchblock \u003d first.getNext().getFirstChild();\n                 if (catchblock !\u003d null) {\n                     add(catchblock);\n                 }\n                 if (childCount \u003d\u003d 3) {\n                     add(\"finally\");\n                     add(last, Context.PRESERVE_BLOCK);\n                 }\n                 break;\n             }\n         case Token.CATCH:\n             Preconditions.checkState(childCount \u003d\u003d 3);\n             if (first.getNext().getType() !\u003d Token.EMPTY) {\n                 throw new Error(\"Catch conditions not suppored because I think\" + \" that it may be a netscape only feature.\");\n             }\n             add(\"catch(\");\n             add(first);\n             add(\")\");\n             add(last, Context.PRESERVE_BLOCK);\n             break;\n         case Token.THROW:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"throw\");\n             add(first);\n             cc.endStatement(true);\n             break;\n         case Token.RETURN:\n             add(\"return\");\n             if (childCount \u003d\u003d 1) {\n                 add(first);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 0);\n             }\n             cc.endStatement();\n             break;\n         case Token.VAR:\n             if (first !\u003d null) {\n                 add(\"var \");\n                 addList(first, false, getContextForNoInOperator(context));\n             }\n             break;\n         case Token.LABEL_NAME:\n             Preconditions.checkState(!n.getString().isEmpty());\n             addIdentifier(n.getString());\n             break;\n         case Token.NAME:\n             if (first \u003d\u003d null || first.getType() \u003d\u003d Token.EMPTY) {\n                 addIdentifier(n.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 addIdentifier(n.getString());\n                 cc.addOp(\"\u003d\", true);\n                 if (first.getType() \u003d\u003d Token.COMMA) {\n                     addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                 } else {\n                     addExpr(first, 0, getContextForNoInOperator(context));\n                 }\n             }\n             break;\n         case Token.ARRAYLIT:\n             add(\"[\");\n             addList(first, (int[]) n.getProp(Node.SKIP_INDEXES_PROP));\n             add(\"]\");\n             break;\n         case Token.LP:\n             add(\"(\");\n             addList(first);\n             add(\")\");\n             break;\n         case Token.COMMA:\n             addList(first, false, context);\n             break;\n         case Token.NUMBER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             cc.addNumber(n.getDouble());\n             break;\n         case Token.TYPEOF:\n         case Token.VOID:\n         case Token.NOT:\n         case Token.BITNOT:\n         case Token.POS:\n         case Token.NEG:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                 addExpr(first, NodeUtil.precedence(type));\n                 break;\n             }\n         case Token.HOOK:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 int p \u003d NodeUtil.precedence(type);\n                 addLeftExpr(first, p + 1, context);\n                 cc.addOp(\"?\", true);\n                 addExpr(first.getNext(), p);\n                 cc.addOp(\":\", true);\n                 addExpr(last, p);\n                 break;\n             }\n         case Token.REGEXP:\n             if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                 throw new Error(\"Expected children to be strings\");\n             }\n             String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n             if (childCount \u003d\u003d 2) {\n                 add(regexp + last.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 add(regexp);\n             }\n             break;\n         case Token.GET_REF:\n             add(first);\n             break;\n         case Token.REF_SPECIAL:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first);\n             add(\".\");\n             add((String) n.getProp(Node.NAME_PROP));\n             break;\n         case Token.FUNCTION:\n+            if (n.getClass() !\u003d Node.class) {\n+                throw new Error(\"Unexpected Node subclass.\");\n+            }\n             Preconditions.checkState(childCount \u003d\u003d 3);\n             boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n             if (funcNeedsParens) {\n                 add(\"(\");\n             }\n             add(\"function\");\n             add(first);\n             add(first.getNext());\n             add(last, Context.PRESERVE_BLOCK);\n             cc.endFunction(context \u003d\u003d Context.STATEMENT);\n             if (funcNeedsParens) {\n                 add(\")\");\n             }\n             break;\n         case Token.SCRIPT:\n         case Token.BLOCK:\n             {\n+                if (n.getClass() !\u003d Node.class) {\n+                    throw new Error(\"Unexpected Node subclass.\");\n+                }\n                 boolean stripBlock \u003d n.isSyntheticBlock() || ((context !\u003d Context.PRESERVE_BLOCK) \u0026\u0026 (n.getChildCount() \u003c 2));\n                 if (!stripBlock) {\n                     cc.beginBlock();\n                 }\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     add(c, Context.STATEMENT);\n                     if (c.getType() \u003d\u003d Token.VAR) {\n                         cc.endStatement();\n                     }\n                     if (c.getType() \u003d\u003d Token.FUNCTION) {\n                         cc.maybeLineBreak();\n                     }\n                     if (type \u003d\u003d Token.SCRIPT) {\n                         cc.notePreferredLineBreak();\n                     }\n                 }\n                 if (!stripBlock) {\n                     cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                 }\n                 break;\n             }\n         case Token.FOR:\n             if (childCount \u003d\u003d 4) {\n                 add(\"for(\");\n                 if (first.getType() \u003d\u003d Token.VAR) {\n                     add(first, Context.IN_FOR_INIT_CLAUSE);\n                 } else {\n                     addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                 }\n                 add(\";\");\n                 add(first.getNext());\n                 add(\";\");\n                 add(first.getNext().getNext());\n                 add(\")\");\n                 addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 add(\"for(\");\n                 add(first);\n                 add(\"in\");\n                 add(first.getNext());\n                 add(\")\");\n                 addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             }\n             break;\n         case Token.DO:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"do\");\n             addNonEmptyExpression(first, Context.OTHER, false);\n             add(\"while(\");\n             add(last);\n             add(\")\");\n             cc.endStatement();\n             break;\n         case Token.WHILE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"while(\");\n             add(first);\n             add(\")\");\n             addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.EMPTY:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             break;\n         case Token.GETPROP:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 2);\n                 Preconditions.checkState(last.getType() \u003d\u003d Token.STRING);\n                 boolean needsParens \u003d (first.getType() \u003d\u003d Token.NUMBER);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 add(\".\");\n                 addIdentifier(last.getString());\n                 break;\n             }\n         case Token.GETELEM:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             addLeftExpr(first, NodeUtil.precedence(type), context);\n             add(\"[\");\n             add(first.getNext());\n             add(\"]\");\n             break;\n         case Token.WITH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"with(\");\n             add(first);\n             add(\")\");\n             addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.INC:\n         case Token.DEC:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                 int postProp \u003d n.getIntProp(Node.INCRDECR_PROP, 0);\n                 if (postProp !\u003d 0) {\n                     addLeftExpr(first, NodeUtil.precedence(type), context);\n                     cc.addOp(o, false);\n                 } else {\n                     cc.addOp(o, false);\n                     add(first);\n                 }\n                 break;\n             }\n         case Token.CALL:\n             if (first.getType() \u003d\u003d Token.NAME \u0026\u0026 \"eval\".equals(first.getString()) \u0026\u0026 !first.getBooleanProp(Node.DIRECT_EVAL)) {\n                 add(\"(0,eval)\");\n             } else {\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n             }\n             add(\"(\");\n             addList(first.getNext());\n             add(\")\");\n             break;\n         case Token.IF:\n             boolean hasElse \u003d childCount \u003d\u003d 3;\n             boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n             if (ambiguousElseClause) {\n                 cc.beginBlock();\n             }\n             add(\"if(\");\n             add(first);\n             add(\")\");\n             if (hasElse) {\n                 addNonEmptyExpression(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                 add(\"else\");\n                 addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 addNonEmptyExpression(first.getNext(), Context.OTHER, false);\n                 Preconditions.checkState(childCount \u003d\u003d 2);\n             }\n             if (ambiguousElseClause) {\n                 cc.endBlock();\n             }\n             break;\n         case Token.NULL:\n         case Token.THIS:\n         case Token.FALSE:\n         case Token.TRUE:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(Node.tokenToName(type));\n             break;\n         case Token.CONTINUE:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"continue\");\n             if (childCount \u003d\u003d 1) {\n                 if (first.getType() !\u003d Token.LABEL_NAME) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.DEBUGGER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(\"debugger\");\n             cc.endStatement();\n             break;\n         case Token.BREAK:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"break\");\n             if (childCount \u003d\u003d 1) {\n                 if (first.getType() !\u003d Token.LABEL_NAME) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.EXPR_VOID:\n         case Token.EXPR_RESULT:\n             if (type \u003d\u003d Token.EXPR_VOID) {\n                 throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n             }\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first, Context.START_OF_EXPR);\n             cc.endStatement();\n             break;\n         case Token.NEW:\n             add(\"new \");\n             int precedence \u003d NodeUtil.precedence(type);\n             if (NodeUtil.containsCall(first)) {\n                 precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n             }\n             addExpr(first, precedence);\n             Node next \u003d first.getNext();\n             if (next !\u003d null) {\n                 add(\"(\");\n                 addList(next);\n                 add(\")\");\n             }\n             break;\n         case Token.STRING:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(jsString(n.getString(), outputCharsetEncoder));\n             break;\n         case Token.DELPROP:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"delete \");\n             add(first);\n             break;\n         case Token.OBJECTLIT:\n             {\n                 Preconditions.checkState(childCount % 2 \u003d\u003d 0);\n                 boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 add(\"{\");\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext().getNext()) {\n                     if (c !\u003d first) {\n                         cc.listSeparator();\n                     }\n                     if (c.getType() \u003d\u003d Token.STRING \u0026\u0026 !TokenStream.isKeyword(c.getString()) \u0026\u0026 TokenStream.isJSIdentifier(c.getString()) \u0026\u0026 NodeUtil.isLatin(c.getString())) {\n                         add(c.getString());\n                     } else {\n                         addExpr(c, 1);\n                     }\n                     add(\":\");\n                     addExpr(c.getNext(), 1);\n                 }\n                 add(\"}\");\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 break;\n             }\n         case Token.SWITCH:\n             add(\"switch(\");\n             add(first);\n             add(\")\");\n             cc.beginBlock();\n             addAllSiblings(first.getNext());\n             cc.endBlock(context \u003d\u003d Context.STATEMENT);\n             break;\n         case Token.CASE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"case \");\n             add(first);\n             addCaseBody(last);\n             break;\n         case Token.DEFAULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"default\");\n             addCaseBody(first);\n             break;\n         case Token.LABEL:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             if (first.getType() !\u003d Token.LABEL_NAME) {\n                 throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n             }\n             add(first);\n             add(\":\");\n             addNonEmptyExpression(last, getContextForNonEmptyExpression(context), true);\n             break;\n         case Token.SETNAME:\n             break;\n         default:\n             throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n     }\n     cc.endSourceMapping(n);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "de13c3313c05f4449c50c560324389d6905a214d": {
      "type": "Ybodychange",
      "commitMessage": "\nChange on 2010/04/13 by john\n\n        Experimental option: Flag to change named object references from \"Object|null\" to \"Object|null|undefined\".\n\n        R\u003dalan,nick\n        DELTA\u003d7144  (7131 added, 5 deleted, 8 changed)\n\nChange on 2010/04/13 by nicksantos\n\n        get rid of some backdoor gmail apis.\n\n        R\u003djohn\n        DELTA\u003d44  (0 added, 33 deleted, 11 changed)\n\nChange on 2010/04/13 by nicksantos\n\n        fix TypeCheckTest to parse externs files properly.\n        i still need to merge the TypeCheckTest-forking cl into this one.\n\n        R\u003djohn\n        DELTA\u003d42  (12 added, 0 deleted, 30 changed)\n\nChange on 2010/04/13 by john\n\n        Enable expression decomposition for function inlining by default.\n\n        R\u003dnick\n        DELTA\u003d1  (0 added, 0 deleted, 1 changed)\n\nChange on 2010/04/13 by john\n\n        Move ReplaceCssNames to allow type checking of goog.getCssName.\n\n        R\u003dmark\n        DELTA\u003d39  (35 added, 4 deleted, 0 changed)\n\nChange on 2010/04/13 by john\n\n        Maintain source and type information during ReplaceCssNames.\n\n        R\u003dmark\n        DELTA\u003d31  (30 added, 0 deleted, 1 changed)\n\nChange on 2010/04/13 by nick\n\n        fix up type information on event listener functions.\n\n        R\u003dalan\n        DELTA\u003d2  (0 added, 0 deleted, 2 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003dwescxy\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@182 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/13/10, 2:39 PM",
      "commitName": "de13c3313c05f4449c50c560324389d6905a214d",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "4/5/10, 12:30 PM",
      "commitNameOld": "222eafd303155b3eac5cd244584b2cb3c4c11975",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 8.09,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "actualSource": "void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n        return;\n    }\n    int type \u003d n.getType();\n    String opstr \u003d NodeUtil.opToStr(type);\n    int childCount \u003d n.getChildCount();\n    Node first \u003d n.getFirstChild();\n    Node last \u003d n.getLastChild();\n    if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n        Preconditions.checkState(childCount \u003d\u003d 2);\n        int p \u003d NodeUtil.precedence(type);\n        addLeftExpr(first, p, context);\n        cc.addOp(opstr, true);\n        Context rhsContext \u003d getContextForNoInOperator(context);\n        if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n            addExpr(last, p, rhsContext);\n        } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n            addExpr(last, p, rhsContext);\n        } else {\n            addExpr(last, p + 1, rhsContext);\n        }\n        return;\n    }\n    cc.startSourceMapping(n);\n    switch(type) {\n        case Token.TRY:\n            {\n                Preconditions.checkState(first.getNext().getType() \u003d\u003d Token.BLOCK \u0026\u0026 first.getNext().getChildCount() \u003c\u003d 1);\n                Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                add(\"try\");\n                add(first, Context.PRESERVE_BLOCK);\n                Node catchblock \u003d first.getNext().getFirstChild();\n                if (catchblock !\u003d null) {\n                    add(catchblock);\n                }\n                if (childCount \u003d\u003d 3) {\n                    add(\"finally\");\n                    add(last, Context.PRESERVE_BLOCK);\n                }\n                break;\n            }\n        case Token.CATCH:\n            Preconditions.checkState(childCount \u003d\u003d 3);\n            if (first.getNext().getType() !\u003d Token.EMPTY) {\n                throw new Error(\"Catch conditions not suppored because I think\" + \" that it may be a netscape only feature.\");\n            }\n            add(\"catch(\");\n            add(first);\n            add(\")\");\n            add(last, Context.PRESERVE_BLOCK);\n            break;\n        case Token.THROW:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"throw\");\n            add(first);\n            cc.endStatement(true);\n            break;\n        case Token.RETURN:\n            add(\"return\");\n            if (childCount \u003d\u003d 1) {\n                add(first);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 0);\n            }\n            cc.endStatement();\n            break;\n        case Token.VAR:\n            if (first !\u003d null) {\n                add(\"var \");\n                addList(first, false, getContextForNoInOperator(context));\n            }\n            break;\n        case Token.LABEL_NAME:\n            Preconditions.checkState(!n.getString().isEmpty());\n            addIdentifier(n.getString());\n            break;\n        case Token.NAME:\n            if (first \u003d\u003d null || first.getType() \u003d\u003d Token.EMPTY) {\n                addIdentifier(n.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                addIdentifier(n.getString());\n                cc.addOp(\"\u003d\", true);\n                if (first.getType() \u003d\u003d Token.COMMA) {\n                    addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                } else {\n                    addExpr(first, 0, getContextForNoInOperator(context));\n                }\n            }\n            break;\n        case Token.ARRAYLIT:\n            add(\"[\");\n            addList(first, (int[]) n.getProp(Node.SKIP_INDEXES_PROP));\n            add(\"]\");\n            break;\n        case Token.LP:\n            add(\"(\");\n            addList(first);\n            add(\")\");\n            break;\n        case Token.COMMA:\n            addList(first, false, context);\n            break;\n        case Token.NUMBER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            cc.addNumber(n.getDouble());\n            break;\n        case Token.TYPEOF:\n        case Token.VOID:\n        case Token.NOT:\n        case Token.BITNOT:\n        case Token.POS:\n        case Token.NEG:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                addExpr(first, NodeUtil.precedence(type));\n                break;\n            }\n        case Token.HOOK:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                int p \u003d NodeUtil.precedence(type);\n                addLeftExpr(first, p + 1, context);\n                cc.addOp(\"?\", true);\n                addExpr(first.getNext(), p);\n                cc.addOp(\":\", true);\n                addExpr(last, p);\n                break;\n            }\n        case Token.REGEXP:\n            if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                throw new Error(\"Expected children to be strings\");\n            }\n            String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n            if (childCount \u003d\u003d 2) {\n                add(regexp + last.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                add(regexp);\n            }\n            break;\n        case Token.GET_REF:\n            add(first);\n            break;\n        case Token.REF_SPECIAL:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first);\n            add(\".\");\n            add((String) n.getProp(Node.NAME_PROP));\n            break;\n        case Token.FUNCTION:\n            Preconditions.checkState(childCount \u003d\u003d 3);\n            boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n            if (funcNeedsParens) {\n                add(\"(\");\n            }\n            add(\"function\");\n            add(first);\n            add(first.getNext());\n            add(last, Context.PRESERVE_BLOCK);\n            cc.endFunction(context \u003d\u003d Context.STATEMENT);\n            if (funcNeedsParens) {\n                add(\")\");\n            }\n            break;\n        case Token.SCRIPT:\n        case Token.BLOCK:\n            {\n                boolean stripBlock \u003d n.isSyntheticBlock() || ((context !\u003d Context.PRESERVE_BLOCK) \u0026\u0026 (n.getChildCount() \u003c 2));\n                if (!stripBlock) {\n                    cc.beginBlock();\n                }\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    add(c, Context.STATEMENT);\n                    if (c.getType() \u003d\u003d Token.VAR) {\n                        cc.endStatement();\n                    }\n                    if (c.getType() \u003d\u003d Token.FUNCTION) {\n                        cc.maybeLineBreak();\n                    }\n                    if (type \u003d\u003d Token.SCRIPT) {\n                        cc.notePreferredLineBreak();\n                    }\n                }\n                if (!stripBlock) {\n                    cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                }\n                break;\n            }\n        case Token.FOR:\n            if (childCount \u003d\u003d 4) {\n                add(\"for(\");\n                if (first.getType() \u003d\u003d Token.VAR) {\n                    add(first, Context.IN_FOR_INIT_CLAUSE);\n                } else {\n                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                }\n                add(\";\");\n                add(first.getNext());\n                add(\";\");\n                add(first.getNext().getNext());\n                add(\")\");\n                addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                add(\"for(\");\n                add(first);\n                add(\"in\");\n                add(first.getNext());\n                add(\")\");\n                addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            }\n            break;\n        case Token.DO:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"do\");\n            addNonEmptyExpression(first, Context.OTHER, false);\n            add(\"while(\");\n            add(last);\n            add(\")\");\n            cc.endStatement();\n            break;\n        case Token.WHILE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"while(\");\n            add(first);\n            add(\")\");\n            addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.EMPTY:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            break;\n        case Token.GETPROP:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 2);\n                Preconditions.checkState(last.getType() \u003d\u003d Token.STRING);\n                boolean needsParens \u003d (first.getType() \u003d\u003d Token.NUMBER);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n                if (needsParens) {\n                    add(\")\");\n                }\n                add(\".\");\n                addIdentifier(last.getString());\n                break;\n            }\n        case Token.GETELEM:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            addLeftExpr(first, NodeUtil.precedence(type), context);\n            add(\"[\");\n            add(first.getNext());\n            add(\"]\");\n            break;\n        case Token.WITH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"with(\");\n            add(first);\n            add(\")\");\n            addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.INC:\n        case Token.DEC:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                int postProp \u003d n.getIntProp(Node.INCRDECR_PROP, 0);\n                if (postProp !\u003d 0) {\n                    addLeftExpr(first, NodeUtil.precedence(type), context);\n                    cc.addOp(o, false);\n                } else {\n                    cc.addOp(o, false);\n                    add(first);\n                }\n                break;\n            }\n        case Token.CALL:\n            if (first.getType() \u003d\u003d Token.NAME \u0026\u0026 \"eval\".equals(first.getString()) \u0026\u0026 !first.getBooleanProp(Node.DIRECT_EVAL)) {\n                add(\"(0,eval)\");\n            } else {\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n            }\n            add(\"(\");\n            addList(first.getNext());\n            add(\")\");\n            break;\n        case Token.IF:\n            boolean hasElse \u003d childCount \u003d\u003d 3;\n            boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n            if (ambiguousElseClause) {\n                cc.beginBlock();\n            }\n            add(\"if(\");\n            add(first);\n            add(\")\");\n            if (hasElse) {\n                addNonEmptyExpression(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                add(\"else\");\n                addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                addNonEmptyExpression(first.getNext(), Context.OTHER, false);\n                Preconditions.checkState(childCount \u003d\u003d 2);\n            }\n            if (ambiguousElseClause) {\n                cc.endBlock();\n            }\n            break;\n        case Token.NULL:\n        case Token.THIS:\n        case Token.FALSE:\n        case Token.TRUE:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(Node.tokenToName(type));\n            break;\n        case Token.CONTINUE:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"continue\");\n            if (childCount \u003d\u003d 1) {\n                if (first.getType() !\u003d Token.LABEL_NAME) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.DEBUGGER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"debugger\");\n            cc.endStatement();\n            break;\n        case Token.BREAK:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"break\");\n            if (childCount \u003d\u003d 1) {\n                if (first.getType() !\u003d Token.LABEL_NAME) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.EXPR_VOID:\n        case Token.EXPR_RESULT:\n            if (type \u003d\u003d Token.EXPR_VOID) {\n                throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n            }\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first, Context.START_OF_EXPR);\n            cc.endStatement();\n            break;\n        case Token.NEW:\n            add(\"new \");\n            int precedence \u003d NodeUtil.precedence(type);\n            if (NodeUtil.containsCall(first)) {\n                precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n            }\n            addExpr(first, precedence);\n            Node next \u003d first.getNext();\n            if (next !\u003d null) {\n                add(\"(\");\n                addList(next);\n                add(\")\");\n            }\n            break;\n        case Token.STRING:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(jsString(n.getString(), outputCharsetEncoder));\n            break;\n        case Token.DELPROP:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"delete \");\n            add(first);\n            break;\n        case Token.OBJECTLIT:\n            {\n                Preconditions.checkState(childCount % 2 \u003d\u003d 0);\n                boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                add(\"{\");\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext().getNext()) {\n                    if (c !\u003d first) {\n                        cc.listSeparator();\n                    }\n                    if (c.getType() \u003d\u003d Token.STRING \u0026\u0026 !TokenStream.isKeyword(c.getString()) \u0026\u0026 TokenStream.isJSIdentifier(c.getString()) \u0026\u0026 NodeUtil.isLatin(c.getString())) {\n                        add(c.getString());\n                    } else {\n                        addExpr(c, 1);\n                    }\n                    add(\":\");\n                    addExpr(c.getNext(), 1);\n                }\n                add(\"}\");\n                if (needsParens) {\n                    add(\")\");\n                }\n                break;\n            }\n        case Token.SWITCH:\n            add(\"switch(\");\n            add(first);\n            add(\")\");\n            cc.beginBlock();\n            addAllSiblings(first.getNext());\n            cc.endBlock(context \u003d\u003d Context.STATEMENT);\n            break;\n        case Token.CASE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"case \");\n            add(first);\n            addCaseBody(last);\n            break;\n        case Token.DEFAULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"default\");\n            addCaseBody(first);\n            break;\n        case Token.LABEL:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            if (first.getType() !\u003d Token.LABEL_NAME) {\n                throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n            }\n            add(first);\n            add(\":\");\n            addNonEmptyExpression(last, getContextForNonEmptyExpression(context), true);\n            break;\n        case Token.SETNAME:\n            break;\n        default:\n            throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n    cc.endSourceMapping(n);\n}",
      "path": "src/com/google/javascript/jscomp/CodeGenerator.java",
      "functionStartLine": 76,
      "functionName": "add",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,439 +1,439 @@\n void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n         return;\n     }\n     int type \u003d n.getType();\n     String opstr \u003d NodeUtil.opToStr(type);\n     int childCount \u003d n.getChildCount();\n     Node first \u003d n.getFirstChild();\n     Node last \u003d n.getLastChild();\n     if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n         Preconditions.checkState(childCount \u003d\u003d 2);\n         int p \u003d NodeUtil.precedence(type);\n         addLeftExpr(first, p, context);\n         cc.addOp(opstr, true);\n         Context rhsContext \u003d getContextForNoInOperator(context);\n         if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n             addExpr(last, p, rhsContext);\n         } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n             addExpr(last, p, rhsContext);\n         } else {\n             addExpr(last, p + 1, rhsContext);\n         }\n         return;\n     }\n     cc.startSourceMapping(n);\n     switch(type) {\n         case Token.TRY:\n             {\n                 Preconditions.checkState(first.getNext().getType() \u003d\u003d Token.BLOCK \u0026\u0026 first.getNext().getChildCount() \u003c\u003d 1);\n                 Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                 add(\"try\");\n                 add(first, Context.PRESERVE_BLOCK);\n                 Node catchblock \u003d first.getNext().getFirstChild();\n                 if (catchblock !\u003d null) {\n                     add(catchblock);\n                 }\n                 if (childCount \u003d\u003d 3) {\n                     add(\"finally\");\n                     add(last, Context.PRESERVE_BLOCK);\n                 }\n                 break;\n             }\n         case Token.CATCH:\n             Preconditions.checkState(childCount \u003d\u003d 3);\n             if (first.getNext().getType() !\u003d Token.EMPTY) {\n                 throw new Error(\"Catch conditions not suppored because I think\" + \" that it may be a netscape only feature.\");\n             }\n             add(\"catch(\");\n             add(first);\n             add(\")\");\n             add(last, Context.PRESERVE_BLOCK);\n             break;\n         case Token.THROW:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"throw\");\n             add(first);\n             cc.endStatement(true);\n             break;\n         case Token.RETURN:\n             add(\"return\");\n             if (childCount \u003d\u003d 1) {\n                 add(first);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 0);\n             }\n             cc.endStatement();\n             break;\n         case Token.VAR:\n             if (first !\u003d null) {\n                 add(\"var \");\n                 addList(first, false, getContextForNoInOperator(context));\n             }\n             break;\n         case Token.LABEL_NAME:\n             Preconditions.checkState(!n.getString().isEmpty());\n             addIdentifier(n.getString());\n             break;\n         case Token.NAME:\n             if (first \u003d\u003d null || first.getType() \u003d\u003d Token.EMPTY) {\n                 addIdentifier(n.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 addIdentifier(n.getString());\n                 cc.addOp(\"\u003d\", true);\n                 if (first.getType() \u003d\u003d Token.COMMA) {\n                     addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                 } else {\n                     addExpr(first, 0, getContextForNoInOperator(context));\n                 }\n             }\n             break;\n         case Token.ARRAYLIT:\n             add(\"[\");\n             addList(first, (int[]) n.getProp(Node.SKIP_INDEXES_PROP));\n             add(\"]\");\n             break;\n         case Token.LP:\n             add(\"(\");\n             addList(first);\n             add(\")\");\n             break;\n         case Token.COMMA:\n             addList(first, false, context);\n             break;\n         case Token.NUMBER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             cc.addNumber(n.getDouble());\n             break;\n         case Token.TYPEOF:\n         case Token.VOID:\n         case Token.NOT:\n         case Token.BITNOT:\n         case Token.POS:\n         case Token.NEG:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                 addExpr(first, NodeUtil.precedence(type));\n                 break;\n             }\n         case Token.HOOK:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 int p \u003d NodeUtil.precedence(type);\n                 addLeftExpr(first, p + 1, context);\n                 cc.addOp(\"?\", true);\n                 addExpr(first.getNext(), p);\n                 cc.addOp(\":\", true);\n                 addExpr(last, p);\n                 break;\n             }\n         case Token.REGEXP:\n             if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                 throw new Error(\"Expected children to be strings\");\n             }\n             String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n             if (childCount \u003d\u003d 2) {\n                 add(regexp + last.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 add(regexp);\n             }\n             break;\n         case Token.GET_REF:\n             add(first);\n             break;\n         case Token.REF_SPECIAL:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first);\n             add(\".\");\n             add((String) n.getProp(Node.NAME_PROP));\n             break;\n         case Token.FUNCTION:\n             Preconditions.checkState(childCount \u003d\u003d 3);\n             boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n             if (funcNeedsParens) {\n                 add(\"(\");\n             }\n             add(\"function\");\n             add(first);\n             add(first.getNext());\n             add(last, Context.PRESERVE_BLOCK);\n             cc.endFunction(context \u003d\u003d Context.STATEMENT);\n             if (funcNeedsParens) {\n                 add(\")\");\n             }\n             break;\n         case Token.SCRIPT:\n         case Token.BLOCK:\n             {\n                 boolean stripBlock \u003d n.isSyntheticBlock() || ((context !\u003d Context.PRESERVE_BLOCK) \u0026\u0026 (n.getChildCount() \u003c 2));\n                 if (!stripBlock) {\n                     cc.beginBlock();\n                 }\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     add(c, Context.STATEMENT);\n                     if (c.getType() \u003d\u003d Token.VAR) {\n                         cc.endStatement();\n                     }\n                     if (c.getType() \u003d\u003d Token.FUNCTION) {\n                         cc.maybeLineBreak();\n                     }\n                     if (type \u003d\u003d Token.SCRIPT) {\n                         cc.notePreferredLineBreak();\n                     }\n                 }\n                 if (!stripBlock) {\n                     cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                 }\n                 break;\n             }\n         case Token.FOR:\n             if (childCount \u003d\u003d 4) {\n                 add(\"for(\");\n                 if (first.getType() \u003d\u003d Token.VAR) {\n                     add(first, Context.IN_FOR_INIT_CLAUSE);\n                 } else {\n                     addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                 }\n                 add(\";\");\n                 add(first.getNext());\n                 add(\";\");\n                 add(first.getNext().getNext());\n                 add(\")\");\n                 addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 add(\"for(\");\n                 add(first);\n                 add(\"in\");\n                 add(first.getNext());\n                 add(\")\");\n                 addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             }\n             break;\n         case Token.DO:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"do\");\n             addNonEmptyExpression(first, Context.OTHER, false);\n             add(\"while(\");\n             add(last);\n             add(\")\");\n             cc.endStatement();\n             break;\n         case Token.WHILE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"while(\");\n             add(first);\n             add(\")\");\n             addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.EMPTY:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             break;\n         case Token.GETPROP:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 2);\n                 Preconditions.checkState(last.getType() \u003d\u003d Token.STRING);\n                 boolean needsParens \u003d (first.getType() \u003d\u003d Token.NUMBER);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 add(\".\");\n                 addIdentifier(last.getString());\n                 break;\n             }\n         case Token.GETELEM:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             addLeftExpr(first, NodeUtil.precedence(type), context);\n             add(\"[\");\n             add(first.getNext());\n             add(\"]\");\n             break;\n         case Token.WITH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"with(\");\n             add(first);\n             add(\")\");\n             addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.INC:\n         case Token.DEC:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                 int postProp \u003d n.getIntProp(Node.INCRDECR_PROP, 0);\n                 if (postProp !\u003d 0) {\n                     addLeftExpr(first, NodeUtil.precedence(type), context);\n                     cc.addOp(o, false);\n                 } else {\n                     cc.addOp(o, false);\n                     add(first);\n                 }\n                 break;\n             }\n         case Token.CALL:\n             if (first.getType() \u003d\u003d Token.NAME \u0026\u0026 \"eval\".equals(first.getString()) \u0026\u0026 !first.getBooleanProp(Node.DIRECT_EVAL)) {\n                 add(\"(0,eval)\");\n             } else {\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n             }\n             add(\"(\");\n             addList(first.getNext());\n             add(\")\");\n             break;\n         case Token.IF:\n             boolean hasElse \u003d childCount \u003d\u003d 3;\n             boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n             if (ambiguousElseClause) {\n                 cc.beginBlock();\n             }\n             add(\"if(\");\n             add(first);\n             add(\")\");\n             if (hasElse) {\n                 addNonEmptyExpression(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                 add(\"else\");\n                 addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 addNonEmptyExpression(first.getNext(), Context.OTHER, false);\n                 Preconditions.checkState(childCount \u003d\u003d 2);\n             }\n             if (ambiguousElseClause) {\n                 cc.endBlock();\n             }\n             break;\n         case Token.NULL:\n         case Token.THIS:\n         case Token.FALSE:\n         case Token.TRUE:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(Node.tokenToName(type));\n             break;\n         case Token.CONTINUE:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"continue\");\n             if (childCount \u003d\u003d 1) {\n-                if (first.getType() !\u003d Token.LABEL_NAME \u0026\u0026 validation) {\n+                if (first.getType() !\u003d Token.LABEL_NAME) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.DEBUGGER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(\"debugger\");\n             cc.endStatement();\n             break;\n         case Token.BREAK:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"break\");\n             if (childCount \u003d\u003d 1) {\n-                if (first.getType() !\u003d Token.LABEL_NAME \u0026\u0026 validation) {\n+                if (first.getType() !\u003d Token.LABEL_NAME) {\n                     throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                 }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.EXPR_VOID:\n         case Token.EXPR_RESULT:\n-            if (type \u003d\u003d Token.EXPR_VOID \u0026\u0026 validation) {\n+            if (type \u003d\u003d Token.EXPR_VOID) {\n                 throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n             }\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first, Context.START_OF_EXPR);\n             cc.endStatement();\n             break;\n         case Token.NEW:\n             add(\"new \");\n             int precedence \u003d NodeUtil.precedence(type);\n             if (NodeUtil.containsCall(first)) {\n                 precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n             }\n             addExpr(first, precedence);\n             Node next \u003d first.getNext();\n             if (next !\u003d null) {\n                 add(\"(\");\n                 addList(next);\n                 add(\")\");\n             }\n             break;\n         case Token.STRING:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(jsString(n.getString(), outputCharsetEncoder));\n             break;\n         case Token.DELPROP:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"delete \");\n             add(first);\n             break;\n         case Token.OBJECTLIT:\n             {\n                 Preconditions.checkState(childCount % 2 \u003d\u003d 0);\n                 boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 add(\"{\");\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext().getNext()) {\n                     if (c !\u003d first) {\n                         cc.listSeparator();\n                     }\n                     if (c.getType() \u003d\u003d Token.STRING \u0026\u0026 !TokenStream.isKeyword(c.getString()) \u0026\u0026 TokenStream.isJSIdentifier(c.getString()) \u0026\u0026 NodeUtil.isLatin(c.getString())) {\n                         add(c.getString());\n                     } else {\n                         addExpr(c, 1);\n                     }\n                     add(\":\");\n                     addExpr(c.getNext(), 1);\n                 }\n                 add(\"}\");\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 break;\n             }\n         case Token.SWITCH:\n             add(\"switch(\");\n             add(first);\n             add(\")\");\n             cc.beginBlock();\n             addAllSiblings(first.getNext());\n             cc.endBlock(context \u003d\u003d Context.STATEMENT);\n             break;\n         case Token.CASE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"case \");\n             add(first);\n             addCaseBody(last);\n             break;\n         case Token.DEFAULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"default\");\n             addCaseBody(first);\n             break;\n         case Token.LABEL:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n-            if (first.getType() !\u003d Token.LABEL_NAME \u0026\u0026 validation) {\n+            if (first.getType() !\u003d Token.LABEL_NAME) {\n                 throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n             }\n             add(first);\n             add(\":\");\n             addNonEmptyExpression(last, getContextForNonEmptyExpression(context), true);\n             break;\n         case Token.SETNAME:\n             break;\n         default:\n             throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n     }\n     cc.endSourceMapping(n);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "222eafd303155b3eac5cd244584b2cb3c4c11975": {
      "type": "Ybodychange",
      "commitMessage": "tighten up some types. (Nick)\nR\u003dalan\nDELTA\u003d4  (2 added, 0 deleted, 2 changed)\n\nDon\u0027t use NAME for label names, introduce LABEL_NAME. This improves the correctness of the compiler as many passes don\u0027t distinguish between label names and variable names appropriately. (John)\nR\u003drobert\n\nRemove now unneeded checks for label names when inspecting NAME nodes. (John)\nR\u003drobert\n\nTweak code generator to break after blocks for better pretty printing. (John)\nR\u003drobert\nDELTA\u003d196  (160 added, 0 deleted, 36 changed)\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003dktmses\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@170 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/5/10, 12:30 PM",
      "commitName": "222eafd303155b3eac5cd244584b2cb3c4c11975",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "4/1/10, 7:32 PM",
      "commitNameOld": "f01925cbf7a39a885e51865208368e861d25a0c1",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 3.71,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n        return;\n    }\n    int type \u003d n.getType();\n    String opstr \u003d NodeUtil.opToStr(type);\n    int childCount \u003d n.getChildCount();\n    Node first \u003d n.getFirstChild();\n    Node last \u003d n.getLastChild();\n    if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n        Preconditions.checkState(childCount \u003d\u003d 2);\n        int p \u003d NodeUtil.precedence(type);\n        addLeftExpr(first, p, context);\n        cc.addOp(opstr, true);\n        Context rhsContext \u003d getContextForNoInOperator(context);\n        if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n            addExpr(last, p, rhsContext);\n        } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n            addExpr(last, p, rhsContext);\n        } else {\n            addExpr(last, p + 1, rhsContext);\n        }\n        return;\n    }\n    cc.startSourceMapping(n);\n    switch(type) {\n        case Token.TRY:\n            {\n                Preconditions.checkState(first.getNext().getType() \u003d\u003d Token.BLOCK \u0026\u0026 first.getNext().getChildCount() \u003c\u003d 1);\n                Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                add(\"try\");\n                add(first, Context.PRESERVE_BLOCK);\n                Node catchblock \u003d first.getNext().getFirstChild();\n                if (catchblock !\u003d null) {\n                    add(catchblock);\n                }\n                if (childCount \u003d\u003d 3) {\n                    add(\"finally\");\n                    add(last, Context.PRESERVE_BLOCK);\n                }\n                break;\n            }\n        case Token.CATCH:\n            Preconditions.checkState(childCount \u003d\u003d 3);\n            if (first.getNext().getType() !\u003d Token.EMPTY) {\n                throw new Error(\"Catch conditions not suppored because I think\" + \" that it may be a netscape only feature.\");\n            }\n            add(\"catch(\");\n            add(first);\n            add(\")\");\n            add(last, Context.PRESERVE_BLOCK);\n            break;\n        case Token.THROW:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"throw\");\n            add(first);\n            cc.endStatement(true);\n            break;\n        case Token.RETURN:\n            add(\"return\");\n            if (childCount \u003d\u003d 1) {\n                add(first);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 0);\n            }\n            cc.endStatement();\n            break;\n        case Token.VAR:\n            if (first !\u003d null) {\n                add(\"var \");\n                addList(first, false, getContextForNoInOperator(context));\n            }\n            break;\n        case Token.LABEL_NAME:\n            Preconditions.checkState(!n.getString().isEmpty());\n            addIdentifier(n.getString());\n            break;\n        case Token.NAME:\n            if (first \u003d\u003d null || first.getType() \u003d\u003d Token.EMPTY) {\n                addIdentifier(n.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                addIdentifier(n.getString());\n                cc.addOp(\"\u003d\", true);\n                if (first.getType() \u003d\u003d Token.COMMA) {\n                    addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                } else {\n                    addExpr(first, 0, getContextForNoInOperator(context));\n                }\n            }\n            break;\n        case Token.ARRAYLIT:\n            add(\"[\");\n            addList(first, (int[]) n.getProp(Node.SKIP_INDEXES_PROP));\n            add(\"]\");\n            break;\n        case Token.LP:\n            add(\"(\");\n            addList(first);\n            add(\")\");\n            break;\n        case Token.COMMA:\n            addList(first, false, context);\n            break;\n        case Token.NUMBER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            cc.addNumber(n.getDouble());\n            break;\n        case Token.TYPEOF:\n        case Token.VOID:\n        case Token.NOT:\n        case Token.BITNOT:\n        case Token.POS:\n        case Token.NEG:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                addExpr(first, NodeUtil.precedence(type));\n                break;\n            }\n        case Token.HOOK:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                int p \u003d NodeUtil.precedence(type);\n                addLeftExpr(first, p + 1, context);\n                cc.addOp(\"?\", true);\n                addExpr(first.getNext(), p);\n                cc.addOp(\":\", true);\n                addExpr(last, p);\n                break;\n            }\n        case Token.REGEXP:\n            if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                throw new Error(\"Expected children to be strings\");\n            }\n            String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n            if (childCount \u003d\u003d 2) {\n                add(regexp + last.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                add(regexp);\n            }\n            break;\n        case Token.GET_REF:\n            add(first);\n            break;\n        case Token.REF_SPECIAL:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first);\n            add(\".\");\n            add((String) n.getProp(Node.NAME_PROP));\n            break;\n        case Token.FUNCTION:\n            Preconditions.checkState(childCount \u003d\u003d 3);\n            boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n            if (funcNeedsParens) {\n                add(\"(\");\n            }\n            add(\"function\");\n            add(first);\n            add(first.getNext());\n            add(last, Context.PRESERVE_BLOCK);\n            cc.endFunction(context \u003d\u003d Context.STATEMENT);\n            if (funcNeedsParens) {\n                add(\")\");\n            }\n            break;\n        case Token.SCRIPT:\n        case Token.BLOCK:\n            {\n                boolean stripBlock \u003d n.isSyntheticBlock() || ((context !\u003d Context.PRESERVE_BLOCK) \u0026\u0026 (n.getChildCount() \u003c 2));\n                if (!stripBlock) {\n                    cc.beginBlock();\n                }\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    add(c, Context.STATEMENT);\n                    if (c.getType() \u003d\u003d Token.VAR) {\n                        cc.endStatement();\n                    }\n                    if (c.getType() \u003d\u003d Token.FUNCTION) {\n                        cc.maybeLineBreak();\n                    }\n                    if (type \u003d\u003d Token.SCRIPT) {\n                        cc.notePreferredLineBreak();\n                    }\n                }\n                if (!stripBlock) {\n                    cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                }\n                break;\n            }\n        case Token.FOR:\n            if (childCount \u003d\u003d 4) {\n                add(\"for(\");\n                if (first.getType() \u003d\u003d Token.VAR) {\n                    add(first, Context.IN_FOR_INIT_CLAUSE);\n                } else {\n                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                }\n                add(\";\");\n                add(first.getNext());\n                add(\";\");\n                add(first.getNext().getNext());\n                add(\")\");\n                addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                add(\"for(\");\n                add(first);\n                add(\"in\");\n                add(first.getNext());\n                add(\")\");\n                addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            }\n            break;\n        case Token.DO:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"do\");\n            addNonEmptyExpression(first, Context.OTHER, false);\n            add(\"while(\");\n            add(last);\n            add(\")\");\n            cc.endStatement();\n            break;\n        case Token.WHILE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"while(\");\n            add(first);\n            add(\")\");\n            addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.EMPTY:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            break;\n        case Token.GETPROP:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 2);\n                Preconditions.checkState(last.getType() \u003d\u003d Token.STRING);\n                boolean needsParens \u003d (first.getType() \u003d\u003d Token.NUMBER);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n                if (needsParens) {\n                    add(\")\");\n                }\n                add(\".\");\n                addIdentifier(last.getString());\n                break;\n            }\n        case Token.GETELEM:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            addLeftExpr(first, NodeUtil.precedence(type), context);\n            add(\"[\");\n            add(first.getNext());\n            add(\"]\");\n            break;\n        case Token.WITH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"with(\");\n            add(first);\n            add(\")\");\n            addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.INC:\n        case Token.DEC:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                int postProp \u003d n.getIntProp(Node.INCRDECR_PROP, 0);\n                if (postProp !\u003d 0) {\n                    addLeftExpr(first, NodeUtil.precedence(type), context);\n                    cc.addOp(o, false);\n                } else {\n                    cc.addOp(o, false);\n                    add(first);\n                }\n                break;\n            }\n        case Token.CALL:\n            if (first.getType() \u003d\u003d Token.NAME \u0026\u0026 \"eval\".equals(first.getString()) \u0026\u0026 !first.getBooleanProp(Node.DIRECT_EVAL)) {\n                add(\"(0,eval)\");\n            } else {\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n            }\n            add(\"(\");\n            addList(first.getNext());\n            add(\")\");\n            break;\n        case Token.IF:\n            boolean hasElse \u003d childCount \u003d\u003d 3;\n            boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n            if (ambiguousElseClause) {\n                cc.beginBlock();\n            }\n            add(\"if(\");\n            add(first);\n            add(\")\");\n            if (hasElse) {\n                addNonEmptyExpression(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                add(\"else\");\n                addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                addNonEmptyExpression(first.getNext(), Context.OTHER, false);\n                Preconditions.checkState(childCount \u003d\u003d 2);\n            }\n            if (ambiguousElseClause) {\n                cc.endBlock();\n            }\n            break;\n        case Token.NULL:\n        case Token.THIS:\n        case Token.FALSE:\n        case Token.TRUE:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(Node.tokenToName(type));\n            break;\n        case Token.CONTINUE:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"continue\");\n            if (childCount \u003d\u003d 1) {\n                if (first.getType() !\u003d Token.LABEL_NAME \u0026\u0026 validation) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.DEBUGGER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"debugger\");\n            cc.endStatement();\n            break;\n        case Token.BREAK:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"break\");\n            if (childCount \u003d\u003d 1) {\n                if (first.getType() !\u003d Token.LABEL_NAME \u0026\u0026 validation) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.EXPR_VOID:\n        case Token.EXPR_RESULT:\n            if (type \u003d\u003d Token.EXPR_VOID \u0026\u0026 validation) {\n                throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n            }\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first, Context.START_OF_EXPR);\n            cc.endStatement();\n            break;\n        case Token.NEW:\n            add(\"new \");\n            int precedence \u003d NodeUtil.precedence(type);\n            if (NodeUtil.containsCall(first)) {\n                precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n            }\n            addExpr(first, precedence);\n            Node next \u003d first.getNext();\n            if (next !\u003d null) {\n                add(\"(\");\n                addList(next);\n                add(\")\");\n            }\n            break;\n        case Token.STRING:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(jsString(n.getString(), outputCharsetEncoder));\n            break;\n        case Token.DELPROP:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"delete \");\n            add(first);\n            break;\n        case Token.OBJECTLIT:\n            {\n                Preconditions.checkState(childCount % 2 \u003d\u003d 0);\n                boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                add(\"{\");\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext().getNext()) {\n                    if (c !\u003d first) {\n                        cc.listSeparator();\n                    }\n                    if (c.getType() \u003d\u003d Token.STRING \u0026\u0026 !TokenStream.isKeyword(c.getString()) \u0026\u0026 TokenStream.isJSIdentifier(c.getString()) \u0026\u0026 NodeUtil.isLatin(c.getString())) {\n                        add(c.getString());\n                    } else {\n                        addExpr(c, 1);\n                    }\n                    add(\":\");\n                    addExpr(c.getNext(), 1);\n                }\n                add(\"}\");\n                if (needsParens) {\n                    add(\")\");\n                }\n                break;\n            }\n        case Token.SWITCH:\n            add(\"switch(\");\n            add(first);\n            add(\")\");\n            cc.beginBlock();\n            addAllSiblings(first.getNext());\n            cc.endBlock(context \u003d\u003d Context.STATEMENT);\n            break;\n        case Token.CASE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"case \");\n            add(first);\n            addCaseBody(last);\n            break;\n        case Token.DEFAULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"default\");\n            addCaseBody(first);\n            break;\n        case Token.LABEL:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            if (first.getType() !\u003d Token.LABEL_NAME \u0026\u0026 validation) {\n                throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n            }\n            add(first);\n            add(\":\");\n            addNonEmptyExpression(last, getContextForNonEmptyExpression(context), true);\n            break;\n        case Token.SETNAME:\n            break;\n        default:\n            throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n    cc.endSourceMapping(n);\n}",
      "path": "src/com/google/javascript/jscomp/CodeGenerator.java",
      "functionStartLine": 86,
      "functionName": "add",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,426 +1,439 @@\n void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n         return;\n     }\n     int type \u003d n.getType();\n     String opstr \u003d NodeUtil.opToStr(type);\n     int childCount \u003d n.getChildCount();\n     Node first \u003d n.getFirstChild();\n     Node last \u003d n.getLastChild();\n     if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n         Preconditions.checkState(childCount \u003d\u003d 2);\n         int p \u003d NodeUtil.precedence(type);\n         addLeftExpr(first, p, context);\n         cc.addOp(opstr, true);\n         Context rhsContext \u003d getContextForNoInOperator(context);\n         if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n             addExpr(last, p, rhsContext);\n         } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n             addExpr(last, p, rhsContext);\n         } else {\n             addExpr(last, p + 1, rhsContext);\n         }\n         return;\n     }\n     cc.startSourceMapping(n);\n     switch(type) {\n         case Token.TRY:\n             {\n                 Preconditions.checkState(first.getNext().getType() \u003d\u003d Token.BLOCK \u0026\u0026 first.getNext().getChildCount() \u003c\u003d 1);\n                 Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                 add(\"try\");\n                 add(first, Context.PRESERVE_BLOCK);\n                 Node catchblock \u003d first.getNext().getFirstChild();\n                 if (catchblock !\u003d null) {\n                     add(catchblock);\n                 }\n                 if (childCount \u003d\u003d 3) {\n                     add(\"finally\");\n                     add(last, Context.PRESERVE_BLOCK);\n                 }\n                 break;\n             }\n         case Token.CATCH:\n             Preconditions.checkState(childCount \u003d\u003d 3);\n             if (first.getNext().getType() !\u003d Token.EMPTY) {\n                 throw new Error(\"Catch conditions not suppored because I think\" + \" that it may be a netscape only feature.\");\n             }\n             add(\"catch(\");\n             add(first);\n             add(\")\");\n             add(last, Context.PRESERVE_BLOCK);\n             break;\n         case Token.THROW:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"throw\");\n             add(first);\n             cc.endStatement(true);\n             break;\n         case Token.RETURN:\n             add(\"return\");\n             if (childCount \u003d\u003d 1) {\n                 add(first);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 0);\n             }\n             cc.endStatement();\n             break;\n         case Token.VAR:\n             if (first !\u003d null) {\n                 add(\"var \");\n                 addList(first, false, getContextForNoInOperator(context));\n             }\n             break;\n+        case Token.LABEL_NAME:\n+            Preconditions.checkState(!n.getString().isEmpty());\n+            addIdentifier(n.getString());\n+            break;\n         case Token.NAME:\n             if (first \u003d\u003d null || first.getType() \u003d\u003d Token.EMPTY) {\n                 addIdentifier(n.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 addIdentifier(n.getString());\n                 cc.addOp(\"\u003d\", true);\n                 if (first.getType() \u003d\u003d Token.COMMA) {\n                     addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                 } else {\n                     addExpr(first, 0, getContextForNoInOperator(context));\n                 }\n             }\n             break;\n         case Token.ARRAYLIT:\n             add(\"[\");\n             addList(first, (int[]) n.getProp(Node.SKIP_INDEXES_PROP));\n             add(\"]\");\n             break;\n         case Token.LP:\n             add(\"(\");\n             addList(first);\n             add(\")\");\n             break;\n         case Token.COMMA:\n             addList(first, false, context);\n             break;\n         case Token.NUMBER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             cc.addNumber(n.getDouble());\n             break;\n         case Token.TYPEOF:\n         case Token.VOID:\n         case Token.NOT:\n         case Token.BITNOT:\n         case Token.POS:\n         case Token.NEG:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                 addExpr(first, NodeUtil.precedence(type));\n                 break;\n             }\n         case Token.HOOK:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 int p \u003d NodeUtil.precedence(type);\n                 addLeftExpr(first, p + 1, context);\n                 cc.addOp(\"?\", true);\n                 addExpr(first.getNext(), p);\n                 cc.addOp(\":\", true);\n                 addExpr(last, p);\n                 break;\n             }\n         case Token.REGEXP:\n             if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                 throw new Error(\"Expected children to be strings\");\n             }\n             String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n             if (childCount \u003d\u003d 2) {\n                 add(regexp + last.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 add(regexp);\n             }\n             break;\n         case Token.GET_REF:\n             add(first);\n             break;\n         case Token.REF_SPECIAL:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first);\n             add(\".\");\n             add((String) n.getProp(Node.NAME_PROP));\n             break;\n         case Token.FUNCTION:\n             Preconditions.checkState(childCount \u003d\u003d 3);\n             boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n             if (funcNeedsParens) {\n                 add(\"(\");\n             }\n             add(\"function\");\n             add(first);\n             add(first.getNext());\n             add(last, Context.PRESERVE_BLOCK);\n             cc.endFunction(context \u003d\u003d Context.STATEMENT);\n             if (funcNeedsParens) {\n                 add(\")\");\n             }\n             break;\n         case Token.SCRIPT:\n         case Token.BLOCK:\n             {\n                 boolean stripBlock \u003d n.isSyntheticBlock() || ((context !\u003d Context.PRESERVE_BLOCK) \u0026\u0026 (n.getChildCount() \u003c 2));\n                 if (!stripBlock) {\n                     cc.beginBlock();\n                 }\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     add(c, Context.STATEMENT);\n                     if (c.getType() \u003d\u003d Token.VAR) {\n                         cc.endStatement();\n                     }\n                     if (c.getType() \u003d\u003d Token.FUNCTION) {\n                         cc.maybeLineBreak();\n                     }\n                     if (type \u003d\u003d Token.SCRIPT) {\n                         cc.notePreferredLineBreak();\n                     }\n                 }\n                 if (!stripBlock) {\n-                    cc.endBlock(context \u003d\u003d Context.STATEMENT);\n+                    cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                 }\n                 break;\n             }\n         case Token.FOR:\n             if (childCount \u003d\u003d 4) {\n                 add(\"for(\");\n                 if (first.getType() \u003d\u003d Token.VAR) {\n                     add(first, Context.IN_FOR_INIT_CLAUSE);\n                 } else {\n                     addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                 }\n                 add(\";\");\n                 add(first.getNext());\n                 add(\";\");\n                 add(first.getNext().getNext());\n                 add(\")\");\n                 addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 add(\"for(\");\n                 add(first);\n                 add(\"in\");\n                 add(first.getNext());\n                 add(\")\");\n                 addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             }\n             break;\n         case Token.DO:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"do\");\n             addNonEmptyExpression(first, Context.OTHER, false);\n             add(\"while(\");\n             add(last);\n             add(\")\");\n             cc.endStatement();\n             break;\n         case Token.WHILE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"while(\");\n             add(first);\n             add(\")\");\n             addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.EMPTY:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             break;\n         case Token.GETPROP:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 2);\n                 Preconditions.checkState(last.getType() \u003d\u003d Token.STRING);\n                 boolean needsParens \u003d (first.getType() \u003d\u003d Token.NUMBER);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 add(\".\");\n                 addIdentifier(last.getString());\n                 break;\n             }\n         case Token.GETELEM:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             addLeftExpr(first, NodeUtil.precedence(type), context);\n             add(\"[\");\n             add(first.getNext());\n             add(\"]\");\n             break;\n         case Token.WITH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"with(\");\n             add(first);\n             add(\")\");\n             addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.INC:\n         case Token.DEC:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                 int postProp \u003d n.getIntProp(Node.INCRDECR_PROP, 0);\n                 if (postProp !\u003d 0) {\n                     addLeftExpr(first, NodeUtil.precedence(type), context);\n                     cc.addOp(o, false);\n                 } else {\n                     cc.addOp(o, false);\n                     add(first);\n                 }\n                 break;\n             }\n         case Token.CALL:\n             if (first.getType() \u003d\u003d Token.NAME \u0026\u0026 \"eval\".equals(first.getString()) \u0026\u0026 !first.getBooleanProp(Node.DIRECT_EVAL)) {\n                 add(\"(0,eval)\");\n             } else {\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n             }\n             add(\"(\");\n             addList(first.getNext());\n             add(\")\");\n             break;\n         case Token.IF:\n             boolean hasElse \u003d childCount \u003d\u003d 3;\n             boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n             if (ambiguousElseClause) {\n                 cc.beginBlock();\n             }\n             add(\"if(\");\n             add(first);\n             add(\")\");\n             if (hasElse) {\n                 addNonEmptyExpression(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                 add(\"else\");\n                 addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 addNonEmptyExpression(first.getNext(), Context.OTHER, false);\n                 Preconditions.checkState(childCount \u003d\u003d 2);\n             }\n             if (ambiguousElseClause) {\n                 cc.endBlock();\n             }\n             break;\n         case Token.NULL:\n         case Token.THIS:\n         case Token.FALSE:\n         case Token.TRUE:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(Node.tokenToName(type));\n             break;\n         case Token.CONTINUE:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"continue\");\n             if (childCount \u003d\u003d 1) {\n+                if (first.getType() !\u003d Token.LABEL_NAME \u0026\u0026 validation) {\n+                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n+                }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.DEBUGGER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(\"debugger\");\n             cc.endStatement();\n             break;\n         case Token.BREAK:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"break\");\n             if (childCount \u003d\u003d 1) {\n+                if (first.getType() !\u003d Token.LABEL_NAME \u0026\u0026 validation) {\n+                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n+                }\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.EXPR_VOID:\n         case Token.EXPR_RESULT:\n             if (type \u003d\u003d Token.EXPR_VOID \u0026\u0026 validation) {\n                 throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n             }\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first, Context.START_OF_EXPR);\n             cc.endStatement();\n             break;\n         case Token.NEW:\n             add(\"new \");\n             int precedence \u003d NodeUtil.precedence(type);\n             if (NodeUtil.containsCall(first)) {\n                 precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n             }\n             addExpr(first, precedence);\n             Node next \u003d first.getNext();\n             if (next !\u003d null) {\n                 add(\"(\");\n                 addList(next);\n                 add(\")\");\n             }\n             break;\n         case Token.STRING:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(jsString(n.getString(), outputCharsetEncoder));\n             break;\n         case Token.DELPROP:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"delete \");\n             add(first);\n             break;\n         case Token.OBJECTLIT:\n             {\n                 Preconditions.checkState(childCount % 2 \u003d\u003d 0);\n                 boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 add(\"{\");\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext().getNext()) {\n                     if (c !\u003d first) {\n                         cc.listSeparator();\n                     }\n                     if (c.getType() \u003d\u003d Token.STRING \u0026\u0026 !TokenStream.isKeyword(c.getString()) \u0026\u0026 TokenStream.isJSIdentifier(c.getString()) \u0026\u0026 NodeUtil.isLatin(c.getString())) {\n                         add(c.getString());\n                     } else {\n                         addExpr(c, 1);\n                     }\n                     add(\":\");\n                     addExpr(c.getNext(), 1);\n                 }\n                 add(\"}\");\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 break;\n             }\n         case Token.SWITCH:\n             add(\"switch(\");\n             add(first);\n             add(\")\");\n             cc.beginBlock();\n             addAllSiblings(first.getNext());\n             cc.endBlock(context \u003d\u003d Context.STATEMENT);\n             break;\n         case Token.CASE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"case \");\n             add(first);\n             addCaseBody(last);\n             break;\n         case Token.DEFAULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"default\");\n             addCaseBody(first);\n             break;\n         case Token.LABEL:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n+            if (first.getType() !\u003d Token.LABEL_NAME \u0026\u0026 validation) {\n+                throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n+            }\n             add(first);\n             add(\":\");\n             addNonEmptyExpression(last, getContextForNonEmptyExpression(context), true);\n             break;\n         case Token.SETNAME:\n             break;\n         default:\n             throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n     }\n     cc.endSourceMapping(n);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f01925cbf7a39a885e51865208368e861d25a0c1": {
      "type": "Ybodychange",
      "commitMessage": "Tests for deps generation (Nick)\nR\u003dandrew\n\nFix for decomposing assignment-ops. (john)\nR\u003dalan\nDELTA\u003d159  (127 added, 21 deleted, 11 changed)\n\nRemove unneeded imports. (John)\nR\u003drobert\nDELTA\u003d2  (0 added, 2 deleted, 0 changed)\n\nAutomated rollback of:\nRemove now unneeded checks for label names when inspecting NAME nodes. (Robert)\nR\u003dAlan\nDELTA\u003d6  (4 added, 0 deleted, 2 changed)\n\nAutomated rollback of:\nDon\u0027t use NAME for label names, introduce LABEL_NAME. This improves the correctness of the compiler as many passes don\u0027t distinguish between label names and variable names appropriately. (Robert)\nR\u003dAlan\nDELTA\u003d57  (12 added, 29 deleted, 16 changed)\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003dgydkaf\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@167 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/1/10, 7:32 PM",
      "commitName": "f01925cbf7a39a885e51865208368e861d25a0c1",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "3/30/10, 9:01 PM",
      "commitNameOld": "8c5eb247cb5361a6ffa2d86aa4c2de17c234bda7",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 1.94,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n        return;\n    }\n    int type \u003d n.getType();\n    String opstr \u003d NodeUtil.opToStr(type);\n    int childCount \u003d n.getChildCount();\n    Node first \u003d n.getFirstChild();\n    Node last \u003d n.getLastChild();\n    if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n        Preconditions.checkState(childCount \u003d\u003d 2);\n        int p \u003d NodeUtil.precedence(type);\n        addLeftExpr(first, p, context);\n        cc.addOp(opstr, true);\n        Context rhsContext \u003d getContextForNoInOperator(context);\n        if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n            addExpr(last, p, rhsContext);\n        } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n            addExpr(last, p, rhsContext);\n        } else {\n            addExpr(last, p + 1, rhsContext);\n        }\n        return;\n    }\n    cc.startSourceMapping(n);\n    switch(type) {\n        case Token.TRY:\n            {\n                Preconditions.checkState(first.getNext().getType() \u003d\u003d Token.BLOCK \u0026\u0026 first.getNext().getChildCount() \u003c\u003d 1);\n                Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                add(\"try\");\n                add(first, Context.PRESERVE_BLOCK);\n                Node catchblock \u003d first.getNext().getFirstChild();\n                if (catchblock !\u003d null) {\n                    add(catchblock);\n                }\n                if (childCount \u003d\u003d 3) {\n                    add(\"finally\");\n                    add(last, Context.PRESERVE_BLOCK);\n                }\n                break;\n            }\n        case Token.CATCH:\n            Preconditions.checkState(childCount \u003d\u003d 3);\n            if (first.getNext().getType() !\u003d Token.EMPTY) {\n                throw new Error(\"Catch conditions not suppored because I think\" + \" that it may be a netscape only feature.\");\n            }\n            add(\"catch(\");\n            add(first);\n            add(\")\");\n            add(last, Context.PRESERVE_BLOCK);\n            break;\n        case Token.THROW:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"throw\");\n            add(first);\n            cc.endStatement(true);\n            break;\n        case Token.RETURN:\n            add(\"return\");\n            if (childCount \u003d\u003d 1) {\n                add(first);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 0);\n            }\n            cc.endStatement();\n            break;\n        case Token.VAR:\n            if (first !\u003d null) {\n                add(\"var \");\n                addList(first, false, getContextForNoInOperator(context));\n            }\n            break;\n        case Token.NAME:\n            if (first \u003d\u003d null || first.getType() \u003d\u003d Token.EMPTY) {\n                addIdentifier(n.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                addIdentifier(n.getString());\n                cc.addOp(\"\u003d\", true);\n                if (first.getType() \u003d\u003d Token.COMMA) {\n                    addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                } else {\n                    addExpr(first, 0, getContextForNoInOperator(context));\n                }\n            }\n            break;\n        case Token.ARRAYLIT:\n            add(\"[\");\n            addList(first, (int[]) n.getProp(Node.SKIP_INDEXES_PROP));\n            add(\"]\");\n            break;\n        case Token.LP:\n            add(\"(\");\n            addList(first);\n            add(\")\");\n            break;\n        case Token.COMMA:\n            addList(first, false, context);\n            break;\n        case Token.NUMBER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            cc.addNumber(n.getDouble());\n            break;\n        case Token.TYPEOF:\n        case Token.VOID:\n        case Token.NOT:\n        case Token.BITNOT:\n        case Token.POS:\n        case Token.NEG:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                addExpr(first, NodeUtil.precedence(type));\n                break;\n            }\n        case Token.HOOK:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                int p \u003d NodeUtil.precedence(type);\n                addLeftExpr(first, p + 1, context);\n                cc.addOp(\"?\", true);\n                addExpr(first.getNext(), p);\n                cc.addOp(\":\", true);\n                addExpr(last, p);\n                break;\n            }\n        case Token.REGEXP:\n            if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                throw new Error(\"Expected children to be strings\");\n            }\n            String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n            if (childCount \u003d\u003d 2) {\n                add(regexp + last.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                add(regexp);\n            }\n            break;\n        case Token.GET_REF:\n            add(first);\n            break;\n        case Token.REF_SPECIAL:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first);\n            add(\".\");\n            add((String) n.getProp(Node.NAME_PROP));\n            break;\n        case Token.FUNCTION:\n            Preconditions.checkState(childCount \u003d\u003d 3);\n            boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n            if (funcNeedsParens) {\n                add(\"(\");\n            }\n            add(\"function\");\n            add(first);\n            add(first.getNext());\n            add(last, Context.PRESERVE_BLOCK);\n            cc.endFunction(context \u003d\u003d Context.STATEMENT);\n            if (funcNeedsParens) {\n                add(\")\");\n            }\n            break;\n        case Token.SCRIPT:\n        case Token.BLOCK:\n            {\n                boolean stripBlock \u003d n.isSyntheticBlock() || ((context !\u003d Context.PRESERVE_BLOCK) \u0026\u0026 (n.getChildCount() \u003c 2));\n                if (!stripBlock) {\n                    cc.beginBlock();\n                }\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    add(c, Context.STATEMENT);\n                    if (c.getType() \u003d\u003d Token.VAR) {\n                        cc.endStatement();\n                    }\n                    if (c.getType() \u003d\u003d Token.FUNCTION) {\n                        cc.maybeLineBreak();\n                    }\n                    if (type \u003d\u003d Token.SCRIPT) {\n                        cc.notePreferredLineBreak();\n                    }\n                }\n                if (!stripBlock) {\n                    cc.endBlock(context \u003d\u003d Context.STATEMENT);\n                }\n                break;\n            }\n        case Token.FOR:\n            if (childCount \u003d\u003d 4) {\n                add(\"for(\");\n                if (first.getType() \u003d\u003d Token.VAR) {\n                    add(first, Context.IN_FOR_INIT_CLAUSE);\n                } else {\n                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                }\n                add(\";\");\n                add(first.getNext());\n                add(\";\");\n                add(first.getNext().getNext());\n                add(\")\");\n                addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                add(\"for(\");\n                add(first);\n                add(\"in\");\n                add(first.getNext());\n                add(\")\");\n                addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            }\n            break;\n        case Token.DO:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"do\");\n            addNonEmptyExpression(first, Context.OTHER, false);\n            add(\"while(\");\n            add(last);\n            add(\")\");\n            cc.endStatement();\n            break;\n        case Token.WHILE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"while(\");\n            add(first);\n            add(\")\");\n            addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.EMPTY:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            break;\n        case Token.GETPROP:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 2);\n                Preconditions.checkState(last.getType() \u003d\u003d Token.STRING);\n                boolean needsParens \u003d (first.getType() \u003d\u003d Token.NUMBER);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n                if (needsParens) {\n                    add(\")\");\n                }\n                add(\".\");\n                addIdentifier(last.getString());\n                break;\n            }\n        case Token.GETELEM:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            addLeftExpr(first, NodeUtil.precedence(type), context);\n            add(\"[\");\n            add(first.getNext());\n            add(\"]\");\n            break;\n        case Token.WITH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"with(\");\n            add(first);\n            add(\")\");\n            addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.INC:\n        case Token.DEC:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                int postProp \u003d n.getIntProp(Node.INCRDECR_PROP, 0);\n                if (postProp !\u003d 0) {\n                    addLeftExpr(first, NodeUtil.precedence(type), context);\n                    cc.addOp(o, false);\n                } else {\n                    cc.addOp(o, false);\n                    add(first);\n                }\n                break;\n            }\n        case Token.CALL:\n            if (first.getType() \u003d\u003d Token.NAME \u0026\u0026 \"eval\".equals(first.getString()) \u0026\u0026 !first.getBooleanProp(Node.DIRECT_EVAL)) {\n                add(\"(0,eval)\");\n            } else {\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n            }\n            add(\"(\");\n            addList(first.getNext());\n            add(\")\");\n            break;\n        case Token.IF:\n            boolean hasElse \u003d childCount \u003d\u003d 3;\n            boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n            if (ambiguousElseClause) {\n                cc.beginBlock();\n            }\n            add(\"if(\");\n            add(first);\n            add(\")\");\n            if (hasElse) {\n                addNonEmptyExpression(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                add(\"else\");\n                addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                addNonEmptyExpression(first.getNext(), Context.OTHER, false);\n                Preconditions.checkState(childCount \u003d\u003d 2);\n            }\n            if (ambiguousElseClause) {\n                cc.endBlock();\n            }\n            break;\n        case Token.NULL:\n        case Token.THIS:\n        case Token.FALSE:\n        case Token.TRUE:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(Node.tokenToName(type));\n            break;\n        case Token.CONTINUE:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"continue\");\n            if (childCount \u003d\u003d 1) {\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.DEBUGGER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"debugger\");\n            cc.endStatement();\n            break;\n        case Token.BREAK:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"break\");\n            if (childCount \u003d\u003d 1) {\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.EXPR_VOID:\n        case Token.EXPR_RESULT:\n            if (type \u003d\u003d Token.EXPR_VOID \u0026\u0026 validation) {\n                throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n            }\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first, Context.START_OF_EXPR);\n            cc.endStatement();\n            break;\n        case Token.NEW:\n            add(\"new \");\n            int precedence \u003d NodeUtil.precedence(type);\n            if (NodeUtil.containsCall(first)) {\n                precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n            }\n            addExpr(first, precedence);\n            Node next \u003d first.getNext();\n            if (next !\u003d null) {\n                add(\"(\");\n                addList(next);\n                add(\")\");\n            }\n            break;\n        case Token.STRING:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(jsString(n.getString(), outputCharsetEncoder));\n            break;\n        case Token.DELPROP:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"delete \");\n            add(first);\n            break;\n        case Token.OBJECTLIT:\n            {\n                Preconditions.checkState(childCount % 2 \u003d\u003d 0);\n                boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                add(\"{\");\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext().getNext()) {\n                    if (c !\u003d first) {\n                        cc.listSeparator();\n                    }\n                    if (c.getType() \u003d\u003d Token.STRING \u0026\u0026 !TokenStream.isKeyword(c.getString()) \u0026\u0026 TokenStream.isJSIdentifier(c.getString()) \u0026\u0026 NodeUtil.isLatin(c.getString())) {\n                        add(c.getString());\n                    } else {\n                        addExpr(c, 1);\n                    }\n                    add(\":\");\n                    addExpr(c.getNext(), 1);\n                }\n                add(\"}\");\n                if (needsParens) {\n                    add(\")\");\n                }\n                break;\n            }\n        case Token.SWITCH:\n            add(\"switch(\");\n            add(first);\n            add(\")\");\n            cc.beginBlock();\n            addAllSiblings(first.getNext());\n            cc.endBlock(context \u003d\u003d Context.STATEMENT);\n            break;\n        case Token.CASE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"case \");\n            add(first);\n            addCaseBody(last);\n            break;\n        case Token.DEFAULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"default\");\n            addCaseBody(first);\n            break;\n        case Token.LABEL:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(first);\n            add(\":\");\n            addNonEmptyExpression(last, getContextForNonEmptyExpression(context), true);\n            break;\n        case Token.SETNAME:\n            break;\n        default:\n            throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n    cc.endSourceMapping(n);\n}",
      "path": "src/com/google/javascript/jscomp/CodeGenerator.java",
      "functionStartLine": 86,
      "functionName": "add",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,433 +1,426 @@\n void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n         return;\n     }\n     int type \u003d n.getType();\n     String opstr \u003d NodeUtil.opToStr(type);\n     int childCount \u003d n.getChildCount();\n     Node first \u003d n.getFirstChild();\n     Node last \u003d n.getLastChild();\n     if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n         Preconditions.checkState(childCount \u003d\u003d 2);\n         int p \u003d NodeUtil.precedence(type);\n         addLeftExpr(first, p, context);\n         cc.addOp(opstr, true);\n         Context rhsContext \u003d getContextForNoInOperator(context);\n         if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n             addExpr(last, p, rhsContext);\n         } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n             addExpr(last, p, rhsContext);\n         } else {\n             addExpr(last, p + 1, rhsContext);\n         }\n         return;\n     }\n     cc.startSourceMapping(n);\n     switch(type) {\n         case Token.TRY:\n             {\n                 Preconditions.checkState(first.getNext().getType() \u003d\u003d Token.BLOCK \u0026\u0026 first.getNext().getChildCount() \u003c\u003d 1);\n                 Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                 add(\"try\");\n                 add(first, Context.PRESERVE_BLOCK);\n                 Node catchblock \u003d first.getNext().getFirstChild();\n                 if (catchblock !\u003d null) {\n                     add(catchblock);\n                 }\n                 if (childCount \u003d\u003d 3) {\n                     add(\"finally\");\n                     add(last, Context.PRESERVE_BLOCK);\n                 }\n                 break;\n             }\n         case Token.CATCH:\n             Preconditions.checkState(childCount \u003d\u003d 3);\n             if (first.getNext().getType() !\u003d Token.EMPTY) {\n                 throw new Error(\"Catch conditions not suppored because I think\" + \" that it may be a netscape only feature.\");\n             }\n             add(\"catch(\");\n             add(first);\n             add(\")\");\n             add(last, Context.PRESERVE_BLOCK);\n             break;\n         case Token.THROW:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"throw\");\n             add(first);\n             cc.endStatement(true);\n             break;\n         case Token.RETURN:\n             add(\"return\");\n             if (childCount \u003d\u003d 1) {\n                 add(first);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 0);\n             }\n             cc.endStatement();\n             break;\n         case Token.VAR:\n             if (first !\u003d null) {\n                 add(\"var \");\n                 addList(first, false, getContextForNoInOperator(context));\n             }\n             break;\n-        case Token.LABEL_NAME:\n-            Preconditions.checkState(!n.getString().isEmpty());\n-            addIdentifier(n.getString());\n-            break;\n         case Token.NAME:\n             if (first \u003d\u003d null || first.getType() \u003d\u003d Token.EMPTY) {\n                 addIdentifier(n.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 addIdentifier(n.getString());\n                 cc.addOp(\"\u003d\", true);\n                 if (first.getType() \u003d\u003d Token.COMMA) {\n                     addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                 } else {\n                     addExpr(first, 0, getContextForNoInOperator(context));\n                 }\n             }\n             break;\n         case Token.ARRAYLIT:\n             add(\"[\");\n             addList(first, (int[]) n.getProp(Node.SKIP_INDEXES_PROP));\n             add(\"]\");\n             break;\n         case Token.LP:\n             add(\"(\");\n             addList(first);\n             add(\")\");\n             break;\n         case Token.COMMA:\n             addList(first, false, context);\n             break;\n         case Token.NUMBER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             cc.addNumber(n.getDouble());\n             break;\n         case Token.TYPEOF:\n         case Token.VOID:\n         case Token.NOT:\n         case Token.BITNOT:\n         case Token.POS:\n         case Token.NEG:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                 addExpr(first, NodeUtil.precedence(type));\n                 break;\n             }\n         case Token.HOOK:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 int p \u003d NodeUtil.precedence(type);\n                 addLeftExpr(first, p + 1, context);\n                 cc.addOp(\"?\", true);\n                 addExpr(first.getNext(), p);\n                 cc.addOp(\":\", true);\n                 addExpr(last, p);\n                 break;\n             }\n         case Token.REGEXP:\n             if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                 throw new Error(\"Expected children to be strings\");\n             }\n             String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n             if (childCount \u003d\u003d 2) {\n                 add(regexp + last.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 add(regexp);\n             }\n             break;\n         case Token.GET_REF:\n             add(first);\n             break;\n         case Token.REF_SPECIAL:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first);\n             add(\".\");\n             add((String) n.getProp(Node.NAME_PROP));\n             break;\n         case Token.FUNCTION:\n             Preconditions.checkState(childCount \u003d\u003d 3);\n             boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n             if (funcNeedsParens) {\n                 add(\"(\");\n             }\n             add(\"function\");\n             add(first);\n             add(first.getNext());\n             add(last, Context.PRESERVE_BLOCK);\n             cc.endFunction(context \u003d\u003d Context.STATEMENT);\n             if (funcNeedsParens) {\n                 add(\")\");\n             }\n             break;\n         case Token.SCRIPT:\n         case Token.BLOCK:\n             {\n                 boolean stripBlock \u003d n.isSyntheticBlock() || ((context !\u003d Context.PRESERVE_BLOCK) \u0026\u0026 (n.getChildCount() \u003c 2));\n                 if (!stripBlock) {\n                     cc.beginBlock();\n                 }\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     add(c, Context.STATEMENT);\n                     if (c.getType() \u003d\u003d Token.VAR) {\n                         cc.endStatement();\n                     }\n                     if (c.getType() \u003d\u003d Token.FUNCTION) {\n                         cc.maybeLineBreak();\n                     }\n                     if (type \u003d\u003d Token.SCRIPT) {\n                         cc.notePreferredLineBreak();\n                     }\n                 }\n                 if (!stripBlock) {\n                     cc.endBlock(context \u003d\u003d Context.STATEMENT);\n                 }\n                 break;\n             }\n         case Token.FOR:\n             if (childCount \u003d\u003d 4) {\n                 add(\"for(\");\n                 if (first.getType() \u003d\u003d Token.VAR) {\n                     add(first, Context.IN_FOR_INIT_CLAUSE);\n                 } else {\n                     addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                 }\n                 add(\";\");\n                 add(first.getNext());\n                 add(\";\");\n                 add(first.getNext().getNext());\n                 add(\")\");\n                 addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 add(\"for(\");\n                 add(first);\n                 add(\"in\");\n                 add(first.getNext());\n                 add(\")\");\n                 addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             }\n             break;\n         case Token.DO:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"do\");\n             addNonEmptyExpression(first, Context.OTHER, false);\n             add(\"while(\");\n             add(last);\n             add(\")\");\n             cc.endStatement();\n             break;\n         case Token.WHILE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"while(\");\n             add(first);\n             add(\")\");\n             addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.EMPTY:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             break;\n         case Token.GETPROP:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 2);\n                 Preconditions.checkState(last.getType() \u003d\u003d Token.STRING);\n                 boolean needsParens \u003d (first.getType() \u003d\u003d Token.NUMBER);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 add(\".\");\n                 addIdentifier(last.getString());\n                 break;\n             }\n         case Token.GETELEM:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             addLeftExpr(first, NodeUtil.precedence(type), context);\n             add(\"[\");\n             add(first.getNext());\n             add(\"]\");\n             break;\n         case Token.WITH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"with(\");\n             add(first);\n             add(\")\");\n             addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.INC:\n         case Token.DEC:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                 int postProp \u003d n.getIntProp(Node.INCRDECR_PROP, 0);\n                 if (postProp !\u003d 0) {\n                     addLeftExpr(first, NodeUtil.precedence(type), context);\n                     cc.addOp(o, false);\n                 } else {\n                     cc.addOp(o, false);\n                     add(first);\n                 }\n                 break;\n             }\n         case Token.CALL:\n             if (first.getType() \u003d\u003d Token.NAME \u0026\u0026 \"eval\".equals(first.getString()) \u0026\u0026 !first.getBooleanProp(Node.DIRECT_EVAL)) {\n                 add(\"(0,eval)\");\n             } else {\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n             }\n             add(\"(\");\n             addList(first.getNext());\n             add(\")\");\n             break;\n         case Token.IF:\n             boolean hasElse \u003d childCount \u003d\u003d 3;\n             boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n             if (ambiguousElseClause) {\n                 cc.beginBlock();\n             }\n             add(\"if(\");\n             add(first);\n             add(\")\");\n             if (hasElse) {\n                 addNonEmptyExpression(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                 add(\"else\");\n                 addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 addNonEmptyExpression(first.getNext(), Context.OTHER, false);\n                 Preconditions.checkState(childCount \u003d\u003d 2);\n             }\n             if (ambiguousElseClause) {\n                 cc.endBlock();\n             }\n             break;\n         case Token.NULL:\n         case Token.THIS:\n         case Token.FALSE:\n         case Token.TRUE:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(Node.tokenToName(type));\n             break;\n         case Token.CONTINUE:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"continue\");\n             if (childCount \u003d\u003d 1) {\n-                Preconditions.checkState(first.getType() \u003d\u003d Token.LABEL_NAME);\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.DEBUGGER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(\"debugger\");\n             cc.endStatement();\n             break;\n         case Token.BREAK:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"break\");\n             if (childCount \u003d\u003d 1) {\n-                Preconditions.checkState(first.getType() \u003d\u003d Token.LABEL_NAME);\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.EXPR_VOID:\n         case Token.EXPR_RESULT:\n             if (type \u003d\u003d Token.EXPR_VOID \u0026\u0026 validation) {\n                 throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n             }\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first, Context.START_OF_EXPR);\n             cc.endStatement();\n             break;\n         case Token.NEW:\n             add(\"new \");\n             int precedence \u003d NodeUtil.precedence(type);\n             if (NodeUtil.containsCall(first)) {\n                 precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n             }\n             addExpr(first, precedence);\n             Node next \u003d first.getNext();\n             if (next !\u003d null) {\n                 add(\"(\");\n                 addList(next);\n                 add(\")\");\n             }\n             break;\n         case Token.STRING:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(jsString(n.getString(), outputCharsetEncoder));\n             break;\n         case Token.DELPROP:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"delete \");\n             add(first);\n             break;\n         case Token.OBJECTLIT:\n             {\n                 Preconditions.checkState(childCount % 2 \u003d\u003d 0);\n                 boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 add(\"{\");\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext().getNext()) {\n                     if (c !\u003d first) {\n                         cc.listSeparator();\n                     }\n                     if (c.getType() \u003d\u003d Token.STRING \u0026\u0026 !TokenStream.isKeyword(c.getString()) \u0026\u0026 TokenStream.isJSIdentifier(c.getString()) \u0026\u0026 NodeUtil.isLatin(c.getString())) {\n                         add(c.getString());\n                     } else {\n                         addExpr(c, 1);\n                     }\n                     add(\":\");\n                     addExpr(c.getNext(), 1);\n                 }\n                 add(\"}\");\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 break;\n             }\n         case Token.SWITCH:\n             add(\"switch(\");\n             add(first);\n             add(\")\");\n             cc.beginBlock();\n             addAllSiblings(first.getNext());\n             cc.endBlock(context \u003d\u003d Context.STATEMENT);\n             break;\n         case Token.CASE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"case \");\n             add(first);\n             addCaseBody(last);\n             break;\n         case Token.DEFAULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"default\");\n             addCaseBody(first);\n             break;\n         case Token.LABEL:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n-            Preconditions.checkState(first.getType() \u003d\u003d Token.LABEL_NAME);\n             add(first);\n             add(\":\");\n             addNonEmptyExpression(last, getContextForNonEmptyExpression(context), true);\n             break;\n         case Token.SETNAME:\n             break;\n         default:\n             throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n     }\n     cc.endSourceMapping(n);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8c5eb247cb5361a6ffa2d86aa4c2de17c234bda7": {
      "type": "Ybodychange",
      "commitMessage": "Refactor how coding conventions are set (Nick)\nR\u003dalan\n\nDon\u0027t use NAME for label names, introduce LABEL_NAME. This improves\nthe correctness of the compiler as many passes don\u0027t distinguish\nbetween label names and variable names appropriately. (John)\nR\u003drobert\nDELTA\u003d57  (29 added, 12 deleted, 16 changed)\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@163 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "3/30/10, 9:01 PM",
      "commitName": "8c5eb247cb5361a6ffa2d86aa4c2de17c234bda7",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "3/15/10, 4:23 PM",
      "commitNameOld": "fe722ddeb545b6b3103369dea073ad3e6becde28",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 15.19,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "actualSource": "void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n        return;\n    }\n    int type \u003d n.getType();\n    String opstr \u003d NodeUtil.opToStr(type);\n    int childCount \u003d n.getChildCount();\n    Node first \u003d n.getFirstChild();\n    Node last \u003d n.getLastChild();\n    if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n        Preconditions.checkState(childCount \u003d\u003d 2);\n        int p \u003d NodeUtil.precedence(type);\n        addLeftExpr(first, p, context);\n        cc.addOp(opstr, true);\n        Context rhsContext \u003d getContextForNoInOperator(context);\n        if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n            addExpr(last, p, rhsContext);\n        } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n            addExpr(last, p, rhsContext);\n        } else {\n            addExpr(last, p + 1, rhsContext);\n        }\n        return;\n    }\n    cc.startSourceMapping(n);\n    switch(type) {\n        case Token.TRY:\n            {\n                Preconditions.checkState(first.getNext().getType() \u003d\u003d Token.BLOCK \u0026\u0026 first.getNext().getChildCount() \u003c\u003d 1);\n                Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                add(\"try\");\n                add(first, Context.PRESERVE_BLOCK);\n                Node catchblock \u003d first.getNext().getFirstChild();\n                if (catchblock !\u003d null) {\n                    add(catchblock);\n                }\n                if (childCount \u003d\u003d 3) {\n                    add(\"finally\");\n                    add(last, Context.PRESERVE_BLOCK);\n                }\n                break;\n            }\n        case Token.CATCH:\n            Preconditions.checkState(childCount \u003d\u003d 3);\n            if (first.getNext().getType() !\u003d Token.EMPTY) {\n                throw new Error(\"Catch conditions not suppored because I think\" + \" that it may be a netscape only feature.\");\n            }\n            add(\"catch(\");\n            add(first);\n            add(\")\");\n            add(last, Context.PRESERVE_BLOCK);\n            break;\n        case Token.THROW:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"throw\");\n            add(first);\n            cc.endStatement(true);\n            break;\n        case Token.RETURN:\n            add(\"return\");\n            if (childCount \u003d\u003d 1) {\n                add(first);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 0);\n            }\n            cc.endStatement();\n            break;\n        case Token.VAR:\n            if (first !\u003d null) {\n                add(\"var \");\n                addList(first, false, getContextForNoInOperator(context));\n            }\n            break;\n        case Token.LABEL_NAME:\n            Preconditions.checkState(!n.getString().isEmpty());\n            addIdentifier(n.getString());\n            break;\n        case Token.NAME:\n            if (first \u003d\u003d null || first.getType() \u003d\u003d Token.EMPTY) {\n                addIdentifier(n.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                addIdentifier(n.getString());\n                cc.addOp(\"\u003d\", true);\n                if (first.getType() \u003d\u003d Token.COMMA) {\n                    addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                } else {\n                    addExpr(first, 0, getContextForNoInOperator(context));\n                }\n            }\n            break;\n        case Token.ARRAYLIT:\n            add(\"[\");\n            addList(first, (int[]) n.getProp(Node.SKIP_INDEXES_PROP));\n            add(\"]\");\n            break;\n        case Token.LP:\n            add(\"(\");\n            addList(first);\n            add(\")\");\n            break;\n        case Token.COMMA:\n            addList(first, false, context);\n            break;\n        case Token.NUMBER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            cc.addNumber(n.getDouble());\n            break;\n        case Token.TYPEOF:\n        case Token.VOID:\n        case Token.NOT:\n        case Token.BITNOT:\n        case Token.POS:\n        case Token.NEG:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                addExpr(first, NodeUtil.precedence(type));\n                break;\n            }\n        case Token.HOOK:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                int p \u003d NodeUtil.precedence(type);\n                addLeftExpr(first, p + 1, context);\n                cc.addOp(\"?\", true);\n                addExpr(first.getNext(), p);\n                cc.addOp(\":\", true);\n                addExpr(last, p);\n                break;\n            }\n        case Token.REGEXP:\n            if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                throw new Error(\"Expected children to be strings\");\n            }\n            String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n            if (childCount \u003d\u003d 2) {\n                add(regexp + last.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                add(regexp);\n            }\n            break;\n        case Token.GET_REF:\n            add(first);\n            break;\n        case Token.REF_SPECIAL:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first);\n            add(\".\");\n            add((String) n.getProp(Node.NAME_PROP));\n            break;\n        case Token.FUNCTION:\n            Preconditions.checkState(childCount \u003d\u003d 3);\n            boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n            if (funcNeedsParens) {\n                add(\"(\");\n            }\n            add(\"function\");\n            add(first);\n            add(first.getNext());\n            add(last, Context.PRESERVE_BLOCK);\n            cc.endFunction(context \u003d\u003d Context.STATEMENT);\n            if (funcNeedsParens) {\n                add(\")\");\n            }\n            break;\n        case Token.SCRIPT:\n        case Token.BLOCK:\n            {\n                boolean stripBlock \u003d n.isSyntheticBlock() || ((context !\u003d Context.PRESERVE_BLOCK) \u0026\u0026 (n.getChildCount() \u003c 2));\n                if (!stripBlock) {\n                    cc.beginBlock();\n                }\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    add(c, Context.STATEMENT);\n                    if (c.getType() \u003d\u003d Token.VAR) {\n                        cc.endStatement();\n                    }\n                    if (c.getType() \u003d\u003d Token.FUNCTION) {\n                        cc.maybeLineBreak();\n                    }\n                    if (type \u003d\u003d Token.SCRIPT) {\n                        cc.notePreferredLineBreak();\n                    }\n                }\n                if (!stripBlock) {\n                    cc.endBlock(context \u003d\u003d Context.STATEMENT);\n                }\n                break;\n            }\n        case Token.FOR:\n            if (childCount \u003d\u003d 4) {\n                add(\"for(\");\n                if (first.getType() \u003d\u003d Token.VAR) {\n                    add(first, Context.IN_FOR_INIT_CLAUSE);\n                } else {\n                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                }\n                add(\";\");\n                add(first.getNext());\n                add(\";\");\n                add(first.getNext().getNext());\n                add(\")\");\n                addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                add(\"for(\");\n                add(first);\n                add(\"in\");\n                add(first.getNext());\n                add(\")\");\n                addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            }\n            break;\n        case Token.DO:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"do\");\n            addNonEmptyExpression(first, Context.OTHER, false);\n            add(\"while(\");\n            add(last);\n            add(\")\");\n            cc.endStatement();\n            break;\n        case Token.WHILE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"while(\");\n            add(first);\n            add(\")\");\n            addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.EMPTY:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            break;\n        case Token.GETPROP:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 2);\n                Preconditions.checkState(last.getType() \u003d\u003d Token.STRING);\n                boolean needsParens \u003d (first.getType() \u003d\u003d Token.NUMBER);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n                if (needsParens) {\n                    add(\")\");\n                }\n                add(\".\");\n                addIdentifier(last.getString());\n                break;\n            }\n        case Token.GETELEM:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            addLeftExpr(first, NodeUtil.precedence(type), context);\n            add(\"[\");\n            add(first.getNext());\n            add(\"]\");\n            break;\n        case Token.WITH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"with(\");\n            add(first);\n            add(\")\");\n            addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.INC:\n        case Token.DEC:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                int postProp \u003d n.getIntProp(Node.INCRDECR_PROP, 0);\n                if (postProp !\u003d 0) {\n                    addLeftExpr(first, NodeUtil.precedence(type), context);\n                    cc.addOp(o, false);\n                } else {\n                    cc.addOp(o, false);\n                    add(first);\n                }\n                break;\n            }\n        case Token.CALL:\n            if (first.getType() \u003d\u003d Token.NAME \u0026\u0026 \"eval\".equals(first.getString()) \u0026\u0026 !first.getBooleanProp(Node.DIRECT_EVAL)) {\n                add(\"(0,eval)\");\n            } else {\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n            }\n            add(\"(\");\n            addList(first.getNext());\n            add(\")\");\n            break;\n        case Token.IF:\n            boolean hasElse \u003d childCount \u003d\u003d 3;\n            boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n            if (ambiguousElseClause) {\n                cc.beginBlock();\n            }\n            add(\"if(\");\n            add(first);\n            add(\")\");\n            if (hasElse) {\n                addNonEmptyExpression(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                add(\"else\");\n                addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                addNonEmptyExpression(first.getNext(), Context.OTHER, false);\n                Preconditions.checkState(childCount \u003d\u003d 2);\n            }\n            if (ambiguousElseClause) {\n                cc.endBlock();\n            }\n            break;\n        case Token.NULL:\n        case Token.THIS:\n        case Token.FALSE:\n        case Token.TRUE:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(Node.tokenToName(type));\n            break;\n        case Token.CONTINUE:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"continue\");\n            if (childCount \u003d\u003d 1) {\n                Preconditions.checkState(first.getType() \u003d\u003d Token.LABEL_NAME);\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.DEBUGGER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"debugger\");\n            cc.endStatement();\n            break;\n        case Token.BREAK:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"break\");\n            if (childCount \u003d\u003d 1) {\n                Preconditions.checkState(first.getType() \u003d\u003d Token.LABEL_NAME);\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.EXPR_VOID:\n        case Token.EXPR_RESULT:\n            if (type \u003d\u003d Token.EXPR_VOID \u0026\u0026 validation) {\n                throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n            }\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first, Context.START_OF_EXPR);\n            cc.endStatement();\n            break;\n        case Token.NEW:\n            add(\"new \");\n            int precedence \u003d NodeUtil.precedence(type);\n            if (NodeUtil.containsCall(first)) {\n                precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n            }\n            addExpr(first, precedence);\n            Node next \u003d first.getNext();\n            if (next !\u003d null) {\n                add(\"(\");\n                addList(next);\n                add(\")\");\n            }\n            break;\n        case Token.STRING:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(jsString(n.getString(), outputCharsetEncoder));\n            break;\n        case Token.DELPROP:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"delete \");\n            add(first);\n            break;\n        case Token.OBJECTLIT:\n            {\n                Preconditions.checkState(childCount % 2 \u003d\u003d 0);\n                boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                add(\"{\");\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext().getNext()) {\n                    if (c !\u003d first) {\n                        cc.listSeparator();\n                    }\n                    if (c.getType() \u003d\u003d Token.STRING \u0026\u0026 !TokenStream.isKeyword(c.getString()) \u0026\u0026 TokenStream.isJSIdentifier(c.getString()) \u0026\u0026 NodeUtil.isLatin(c.getString())) {\n                        add(c.getString());\n                    } else {\n                        addExpr(c, 1);\n                    }\n                    add(\":\");\n                    addExpr(c.getNext(), 1);\n                }\n                add(\"}\");\n                if (needsParens) {\n                    add(\")\");\n                }\n                break;\n            }\n        case Token.SWITCH:\n            add(\"switch(\");\n            add(first);\n            add(\")\");\n            cc.beginBlock();\n            addAllSiblings(first.getNext());\n            cc.endBlock(context \u003d\u003d Context.STATEMENT);\n            break;\n        case Token.CASE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"case \");\n            add(first);\n            addCaseBody(last);\n            break;\n        case Token.DEFAULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"default\");\n            addCaseBody(first);\n            break;\n        case Token.LABEL:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            Preconditions.checkState(first.getType() \u003d\u003d Token.LABEL_NAME);\n            add(first);\n            add(\":\");\n            addNonEmptyExpression(last, getContextForNonEmptyExpression(context), true);\n            break;\n        case Token.SETNAME:\n            break;\n        default:\n            throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n    cc.endSourceMapping(n);\n}",
      "path": "src/com/google/javascript/jscomp/CodeGenerator.java",
      "functionStartLine": 86,
      "functionName": "add",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,426 +1,433 @@\n void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n         return;\n     }\n     int type \u003d n.getType();\n     String opstr \u003d NodeUtil.opToStr(type);\n     int childCount \u003d n.getChildCount();\n     Node first \u003d n.getFirstChild();\n     Node last \u003d n.getLastChild();\n     if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n         Preconditions.checkState(childCount \u003d\u003d 2);\n         int p \u003d NodeUtil.precedence(type);\n         addLeftExpr(first, p, context);\n         cc.addOp(opstr, true);\n         Context rhsContext \u003d getContextForNoInOperator(context);\n         if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n             addExpr(last, p, rhsContext);\n         } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n             addExpr(last, p, rhsContext);\n         } else {\n             addExpr(last, p + 1, rhsContext);\n         }\n         return;\n     }\n     cc.startSourceMapping(n);\n     switch(type) {\n         case Token.TRY:\n             {\n                 Preconditions.checkState(first.getNext().getType() \u003d\u003d Token.BLOCK \u0026\u0026 first.getNext().getChildCount() \u003c\u003d 1);\n                 Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                 add(\"try\");\n                 add(first, Context.PRESERVE_BLOCK);\n                 Node catchblock \u003d first.getNext().getFirstChild();\n                 if (catchblock !\u003d null) {\n                     add(catchblock);\n                 }\n                 if (childCount \u003d\u003d 3) {\n                     add(\"finally\");\n                     add(last, Context.PRESERVE_BLOCK);\n                 }\n                 break;\n             }\n         case Token.CATCH:\n             Preconditions.checkState(childCount \u003d\u003d 3);\n             if (first.getNext().getType() !\u003d Token.EMPTY) {\n                 throw new Error(\"Catch conditions not suppored because I think\" + \" that it may be a netscape only feature.\");\n             }\n             add(\"catch(\");\n             add(first);\n             add(\")\");\n             add(last, Context.PRESERVE_BLOCK);\n             break;\n         case Token.THROW:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"throw\");\n             add(first);\n             cc.endStatement(true);\n             break;\n         case Token.RETURN:\n             add(\"return\");\n             if (childCount \u003d\u003d 1) {\n                 add(first);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 0);\n             }\n             cc.endStatement();\n             break;\n         case Token.VAR:\n             if (first !\u003d null) {\n                 add(\"var \");\n                 addList(first, false, getContextForNoInOperator(context));\n             }\n             break;\n+        case Token.LABEL_NAME:\n+            Preconditions.checkState(!n.getString().isEmpty());\n+            addIdentifier(n.getString());\n+            break;\n         case Token.NAME:\n             if (first \u003d\u003d null || first.getType() \u003d\u003d Token.EMPTY) {\n                 addIdentifier(n.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 addIdentifier(n.getString());\n                 cc.addOp(\"\u003d\", true);\n                 if (first.getType() \u003d\u003d Token.COMMA) {\n                     addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                 } else {\n                     addExpr(first, 0, getContextForNoInOperator(context));\n                 }\n             }\n             break;\n         case Token.ARRAYLIT:\n             add(\"[\");\n             addList(first, (int[]) n.getProp(Node.SKIP_INDEXES_PROP));\n             add(\"]\");\n             break;\n         case Token.LP:\n             add(\"(\");\n             addList(first);\n             add(\")\");\n             break;\n         case Token.COMMA:\n             addList(first, false, context);\n             break;\n         case Token.NUMBER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             cc.addNumber(n.getDouble());\n             break;\n         case Token.TYPEOF:\n         case Token.VOID:\n         case Token.NOT:\n         case Token.BITNOT:\n         case Token.POS:\n         case Token.NEG:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                 addExpr(first, NodeUtil.precedence(type));\n                 break;\n             }\n         case Token.HOOK:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 int p \u003d NodeUtil.precedence(type);\n                 addLeftExpr(first, p + 1, context);\n                 cc.addOp(\"?\", true);\n                 addExpr(first.getNext(), p);\n                 cc.addOp(\":\", true);\n                 addExpr(last, p);\n                 break;\n             }\n         case Token.REGEXP:\n             if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                 throw new Error(\"Expected children to be strings\");\n             }\n             String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n             if (childCount \u003d\u003d 2) {\n                 add(regexp + last.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 add(regexp);\n             }\n             break;\n         case Token.GET_REF:\n             add(first);\n             break;\n         case Token.REF_SPECIAL:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first);\n             add(\".\");\n             add((String) n.getProp(Node.NAME_PROP));\n             break;\n         case Token.FUNCTION:\n             Preconditions.checkState(childCount \u003d\u003d 3);\n             boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n             if (funcNeedsParens) {\n                 add(\"(\");\n             }\n             add(\"function\");\n             add(first);\n             add(first.getNext());\n             add(last, Context.PRESERVE_BLOCK);\n             cc.endFunction(context \u003d\u003d Context.STATEMENT);\n             if (funcNeedsParens) {\n                 add(\")\");\n             }\n             break;\n         case Token.SCRIPT:\n         case Token.BLOCK:\n             {\n                 boolean stripBlock \u003d n.isSyntheticBlock() || ((context !\u003d Context.PRESERVE_BLOCK) \u0026\u0026 (n.getChildCount() \u003c 2));\n                 if (!stripBlock) {\n                     cc.beginBlock();\n                 }\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     add(c, Context.STATEMENT);\n                     if (c.getType() \u003d\u003d Token.VAR) {\n                         cc.endStatement();\n                     }\n                     if (c.getType() \u003d\u003d Token.FUNCTION) {\n                         cc.maybeLineBreak();\n                     }\n                     if (type \u003d\u003d Token.SCRIPT) {\n                         cc.notePreferredLineBreak();\n                     }\n                 }\n                 if (!stripBlock) {\n                     cc.endBlock(context \u003d\u003d Context.STATEMENT);\n                 }\n                 break;\n             }\n         case Token.FOR:\n             if (childCount \u003d\u003d 4) {\n                 add(\"for(\");\n                 if (first.getType() \u003d\u003d Token.VAR) {\n                     add(first, Context.IN_FOR_INIT_CLAUSE);\n                 } else {\n                     addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                 }\n                 add(\";\");\n                 add(first.getNext());\n                 add(\";\");\n                 add(first.getNext().getNext());\n                 add(\")\");\n                 addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 add(\"for(\");\n                 add(first);\n                 add(\"in\");\n                 add(first.getNext());\n                 add(\")\");\n                 addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             }\n             break;\n         case Token.DO:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"do\");\n             addNonEmptyExpression(first, Context.OTHER, false);\n             add(\"while(\");\n             add(last);\n             add(\")\");\n             cc.endStatement();\n             break;\n         case Token.WHILE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"while(\");\n             add(first);\n             add(\")\");\n             addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.EMPTY:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             break;\n         case Token.GETPROP:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 2);\n                 Preconditions.checkState(last.getType() \u003d\u003d Token.STRING);\n                 boolean needsParens \u003d (first.getType() \u003d\u003d Token.NUMBER);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 add(\".\");\n                 addIdentifier(last.getString());\n                 break;\n             }\n         case Token.GETELEM:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             addLeftExpr(first, NodeUtil.precedence(type), context);\n             add(\"[\");\n             add(first.getNext());\n             add(\"]\");\n             break;\n         case Token.WITH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"with(\");\n             add(first);\n             add(\")\");\n             addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.INC:\n         case Token.DEC:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                 int postProp \u003d n.getIntProp(Node.INCRDECR_PROP, 0);\n                 if (postProp !\u003d 0) {\n                     addLeftExpr(first, NodeUtil.precedence(type), context);\n                     cc.addOp(o, false);\n                 } else {\n                     cc.addOp(o, false);\n                     add(first);\n                 }\n                 break;\n             }\n         case Token.CALL:\n             if (first.getType() \u003d\u003d Token.NAME \u0026\u0026 \"eval\".equals(first.getString()) \u0026\u0026 !first.getBooleanProp(Node.DIRECT_EVAL)) {\n                 add(\"(0,eval)\");\n             } else {\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n             }\n             add(\"(\");\n             addList(first.getNext());\n             add(\")\");\n             break;\n         case Token.IF:\n             boolean hasElse \u003d childCount \u003d\u003d 3;\n             boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n             if (ambiguousElseClause) {\n                 cc.beginBlock();\n             }\n             add(\"if(\");\n             add(first);\n             add(\")\");\n             if (hasElse) {\n                 addNonEmptyExpression(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                 add(\"else\");\n                 addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 addNonEmptyExpression(first.getNext(), Context.OTHER, false);\n                 Preconditions.checkState(childCount \u003d\u003d 2);\n             }\n             if (ambiguousElseClause) {\n                 cc.endBlock();\n             }\n             break;\n         case Token.NULL:\n         case Token.THIS:\n         case Token.FALSE:\n         case Token.TRUE:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(Node.tokenToName(type));\n             break;\n         case Token.CONTINUE:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"continue\");\n             if (childCount \u003d\u003d 1) {\n+                Preconditions.checkState(first.getType() \u003d\u003d Token.LABEL_NAME);\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.DEBUGGER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(\"debugger\");\n             cc.endStatement();\n             break;\n         case Token.BREAK:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"break\");\n             if (childCount \u003d\u003d 1) {\n+                Preconditions.checkState(first.getType() \u003d\u003d Token.LABEL_NAME);\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.EXPR_VOID:\n         case Token.EXPR_RESULT:\n             if (type \u003d\u003d Token.EXPR_VOID \u0026\u0026 validation) {\n                 throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n             }\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first, Context.START_OF_EXPR);\n             cc.endStatement();\n             break;\n         case Token.NEW:\n             add(\"new \");\n             int precedence \u003d NodeUtil.precedence(type);\n             if (NodeUtil.containsCall(first)) {\n                 precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n             }\n             addExpr(first, precedence);\n             Node next \u003d first.getNext();\n             if (next !\u003d null) {\n                 add(\"(\");\n                 addList(next);\n                 add(\")\");\n             }\n             break;\n         case Token.STRING:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(jsString(n.getString(), outputCharsetEncoder));\n             break;\n         case Token.DELPROP:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"delete \");\n             add(first);\n             break;\n         case Token.OBJECTLIT:\n             {\n                 Preconditions.checkState(childCount % 2 \u003d\u003d 0);\n                 boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 add(\"{\");\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext().getNext()) {\n                     if (c !\u003d first) {\n                         cc.listSeparator();\n                     }\n                     if (c.getType() \u003d\u003d Token.STRING \u0026\u0026 !TokenStream.isKeyword(c.getString()) \u0026\u0026 TokenStream.isJSIdentifier(c.getString()) \u0026\u0026 NodeUtil.isLatin(c.getString())) {\n                         add(c.getString());\n                     } else {\n                         addExpr(c, 1);\n                     }\n                     add(\":\");\n                     addExpr(c.getNext(), 1);\n                 }\n                 add(\"}\");\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 break;\n             }\n         case Token.SWITCH:\n             add(\"switch(\");\n             add(first);\n             add(\")\");\n             cc.beginBlock();\n             addAllSiblings(first.getNext());\n             cc.endBlock(context \u003d\u003d Context.STATEMENT);\n             break;\n         case Token.CASE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"case \");\n             add(first);\n             addCaseBody(last);\n             break;\n         case Token.DEFAULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"default\");\n             addCaseBody(first);\n             break;\n         case Token.LABEL:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n+            Preconditions.checkState(first.getType() \u003d\u003d Token.LABEL_NAME);\n             add(first);\n             add(\":\");\n             addNonEmptyExpression(last, getContextForNonEmptyExpression(context), true);\n             break;\n         case Token.SETNAME:\n             break;\n         default:\n             throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n     }\n     cc.endSourceMapping(n);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8ba5e1f86eaf3c31b9279f92823b4fa2a50574a3": {
      "type": "Ybodychange",
      "commitMessage": "Print indirect calls to eval correctly (issue 81)\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@79 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "1/27/10, 5:22 PM",
      "commitName": "8ba5e1f86eaf3c31b9279f92823b4fa2a50574a3",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "1/11/10, 2:18 PM",
      "commitNameOld": "0c1e512f5eea2f80aa8caf529aa6790c86a88e2c",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 16.13,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "actualSource": "void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n        return;\n    }\n    int type \u003d n.getType();\n    String opstr \u003d NodeUtil.opToStr(type);\n    int childCount \u003d n.getChildCount();\n    Node first \u003d n.getFirstChild();\n    Node last \u003d n.getLastChild();\n    if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n        Preconditions.checkState(childCount \u003d\u003d 2);\n        int p \u003d NodeUtil.precedence(type);\n        addLeftExpr(first, p, context);\n        cc.addOp(opstr, true);\n        Context rhsContext \u003d getContextForNoInOperator(context);\n        if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n            addExpr(last, p, rhsContext);\n        } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n            addExpr(last, p, rhsContext);\n        } else {\n            addExpr(last, p + 1, rhsContext);\n        }\n        return;\n    }\n    cc.startSourceMapping(n);\n    switch(type) {\n        case Token.TRY:\n            {\n                Preconditions.checkState(first.getNext().getType() \u003d\u003d Token.BLOCK \u0026\u0026 first.getNext().getChildCount() \u003c\u003d 1);\n                Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                add(\"try\");\n                add(first, Context.PRESERVE_BLOCK);\n                Node catchblock \u003d first.getNext().getFirstChild();\n                if (catchblock !\u003d null) {\n                    add(catchblock);\n                }\n                if (childCount \u003d\u003d 3) {\n                    add(\"finally\");\n                    add(last, Context.PRESERVE_BLOCK);\n                }\n                break;\n            }\n        case Token.CATCH:\n            Preconditions.checkState(childCount \u003d\u003d 3);\n            if (first.getNext().getType() !\u003d Token.EMPTY) {\n                throw new Error(\"Catch conditions not suppored because I think\" + \" that it may be a netscape only feature.\");\n            }\n            add(\"catch(\");\n            add(first);\n            add(\")\");\n            add(last, Context.PRESERVE_BLOCK);\n            break;\n        case Token.THROW:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"throw\");\n            add(first);\n            cc.endStatement(true);\n            break;\n        case Token.RETURN:\n            add(\"return\");\n            if (childCount \u003d\u003d 1) {\n                add(first);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 0);\n            }\n            cc.endStatement();\n            break;\n        case Token.VAR:\n            if (first !\u003d null) {\n                add(\"var \");\n                addList(first, false, getContextForNoInOperator(context));\n            }\n            break;\n        case Token.NAME:\n            if (first \u003d\u003d null || first.getType() \u003d\u003d Token.EMPTY) {\n                addIdentifier(n.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                addIdentifier(n.getString());\n                cc.addOp(\"\u003d\", true);\n                if (first.getType() \u003d\u003d Token.COMMA) {\n                    addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                } else {\n                    addExpr(first, 0, getContextForNoInOperator(context));\n                }\n            }\n            break;\n        case Token.ARRAYLIT:\n            add(\"[\");\n            addList(first, (int[]) n.getProp(Node.SKIP_INDEXES_PROP));\n            add(\"]\");\n            break;\n        case Token.LP:\n            add(\"(\");\n            addList(first);\n            add(\")\");\n            break;\n        case Token.COMMA:\n            addList(first, false, context);\n            break;\n        case Token.NUMBER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            cc.addNumber(n.getDouble());\n            break;\n        case Token.TYPEOF:\n        case Token.VOID:\n        case Token.NOT:\n        case Token.BITNOT:\n        case Token.POS:\n        case Token.NEG:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                addExpr(first, NodeUtil.precedence(type));\n                break;\n            }\n        case Token.HOOK:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                int p \u003d NodeUtil.precedence(type);\n                addLeftExpr(first, p + 1, context);\n                cc.addOp(\"?\", true);\n                addExpr(first.getNext(), p);\n                cc.addOp(\":\", true);\n                addExpr(last, p);\n                break;\n            }\n        case Token.REGEXP:\n            if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                throw new Error(\"Expected children to be strings\");\n            }\n            String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n            if (childCount \u003d\u003d 2) {\n                add(regexp + last.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                add(regexp);\n            }\n            break;\n        case Token.GET_REF:\n            add(first);\n            break;\n        case Token.REF_SPECIAL:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first);\n            add(\".\");\n            add((String) n.getProp(Node.NAME_PROP));\n            break;\n        case Token.FUNCTION:\n            Preconditions.checkState(childCount \u003d\u003d 3);\n            boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n            if (funcNeedsParens) {\n                add(\"(\");\n            }\n            add(\"function\");\n            add(first);\n            add(first.getNext());\n            add(last, Context.PRESERVE_BLOCK);\n            cc.endFunction(context \u003d\u003d Context.STATEMENT);\n            if (funcNeedsParens) {\n                add(\")\");\n            }\n            break;\n        case Token.SCRIPT:\n        case Token.BLOCK:\n            {\n                boolean stripBlock \u003d n.isSyntheticBlock() || ((context !\u003d Context.PRESERVE_BLOCK) \u0026\u0026 (n.getChildCount() \u003c 2));\n                if (!stripBlock) {\n                    cc.beginBlock();\n                }\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    add(c, Context.STATEMENT);\n                    if (c.getType() \u003d\u003d Token.VAR) {\n                        cc.endStatement();\n                    }\n                    if (c.getType() \u003d\u003d Token.FUNCTION) {\n                        cc.maybeLineBreak();\n                    }\n                    if (type \u003d\u003d Token.SCRIPT) {\n                        cc.notePreferredLineBreak();\n                    }\n                }\n                if (!stripBlock) {\n                    cc.endBlock(context \u003d\u003d Context.STATEMENT);\n                }\n                break;\n            }\n        case Token.FOR:\n            if (childCount \u003d\u003d 4) {\n                add(\"for(\");\n                if (first.getType() \u003d\u003d Token.VAR) {\n                    add(first, Context.IN_FOR_INIT_CLAUSE);\n                } else {\n                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                }\n                add(\";\");\n                add(first.getNext());\n                add(\";\");\n                add(first.getNext().getNext());\n                add(\")\");\n                addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                add(\"for(\");\n                add(first);\n                add(\"in\");\n                add(first.getNext());\n                add(\")\");\n                addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            }\n            break;\n        case Token.DO:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"do\");\n            addNonEmptyExpression(first, Context.OTHER, false);\n            add(\"while(\");\n            add(last);\n            add(\")\");\n            cc.endStatement();\n            break;\n        case Token.WHILE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"while(\");\n            add(first);\n            add(\")\");\n            addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.EMPTY:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            break;\n        case Token.GETPROP:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 2);\n                Preconditions.checkState(last.getType() \u003d\u003d Token.STRING);\n                boolean needsParens \u003d (first.getType() \u003d\u003d Token.NUMBER);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n                if (needsParens) {\n                    add(\")\");\n                }\n                add(\".\");\n                addIdentifier(last.getString());\n                break;\n            }\n        case Token.GETELEM:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            addLeftExpr(first, NodeUtil.precedence(type), context);\n            add(\"[\");\n            add(first.getNext());\n            add(\"]\");\n            break;\n        case Token.WITH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"with(\");\n            add(first);\n            add(\")\");\n            addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.INC:\n        case Token.DEC:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                int postProp \u003d n.getIntProp(Node.INCRDECR_PROP, 0);\n                if (postProp !\u003d 0) {\n                    addLeftExpr(first, NodeUtil.precedence(type), context);\n                    cc.addOp(o, false);\n                } else {\n                    cc.addOp(o, false);\n                    add(first);\n                }\n                break;\n            }\n        case Token.CALL:\n            if (first.getType() \u003d\u003d Token.NAME \u0026\u0026 \"eval\".equals(first.getString()) \u0026\u0026 !first.getBooleanProp(Node.DIRECT_EVAL)) {\n                add(\"(0,eval)\");\n            } else {\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n            }\n            add(\"(\");\n            addList(first.getNext());\n            add(\")\");\n            break;\n        case Token.IF:\n            boolean hasElse \u003d childCount \u003d\u003d 3;\n            boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n            if (ambiguousElseClause) {\n                cc.beginBlock();\n            }\n            add(\"if(\");\n            add(first);\n            add(\")\");\n            if (hasElse) {\n                addNonEmptyExpression(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                add(\"else\");\n                addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                addNonEmptyExpression(first.getNext(), Context.OTHER, false);\n                Preconditions.checkState(childCount \u003d\u003d 2);\n            }\n            if (ambiguousElseClause) {\n                cc.endBlock();\n            }\n            break;\n        case Token.NULL:\n        case Token.THIS:\n        case Token.FALSE:\n        case Token.TRUE:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(Node.tokenToName(type));\n            break;\n        case Token.CONTINUE:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"continue\");\n            if (childCount \u003d\u003d 1) {\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.DEBUGGER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"debugger\");\n            cc.endStatement();\n            break;\n        case Token.BREAK:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"break\");\n            if (childCount \u003d\u003d 1) {\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.EXPR_VOID:\n        case Token.EXPR_RESULT:\n            if (type \u003d\u003d Token.EXPR_VOID \u0026\u0026 validation) {\n                throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n            }\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first, Context.START_OF_EXPR);\n            cc.endStatement();\n            break;\n        case Token.NEW:\n            add(\"new \");\n            int precedence \u003d NodeUtil.precedence(type);\n            if (NodeUtil.containsCall(first)) {\n                precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n            }\n            addExpr(first, precedence);\n            Node next \u003d first.getNext();\n            if (next !\u003d null) {\n                add(\"(\");\n                addList(next);\n                add(\")\");\n            }\n            break;\n        case Token.STRING:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(jsString(n.getString(), outputCharsetEncoder));\n            break;\n        case Token.DELPROP:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"delete \");\n            add(first);\n            break;\n        case Token.OBJECTLIT:\n            {\n                Preconditions.checkState(childCount % 2 \u003d\u003d 0);\n                boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                add(\"{\");\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext().getNext()) {\n                    if (c !\u003d first) {\n                        cc.listSeparator();\n                    }\n                    if (c.getType() \u003d\u003d Token.STRING \u0026\u0026 !TokenStream.isKeyword(c.getString()) \u0026\u0026 TokenStream.isJSIdentifier(c.getString()) \u0026\u0026 NodeUtil.isLatin(c.getString())) {\n                        add(c.getString());\n                    } else {\n                        addExpr(c, 1);\n                    }\n                    add(\":\");\n                    addExpr(c.getNext(), 1);\n                }\n                add(\"}\");\n                if (needsParens) {\n                    add(\")\");\n                }\n                break;\n            }\n        case Token.SWITCH:\n            add(\"switch(\");\n            add(first);\n            add(\")\");\n            cc.beginBlock();\n            addAllSiblings(first.getNext());\n            cc.endBlock(context \u003d\u003d Context.STATEMENT);\n            break;\n        case Token.CASE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"case \");\n            add(first);\n            addCaseBody(last);\n            break;\n        case Token.DEFAULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"default\");\n            addCaseBody(first);\n            break;\n        case Token.LABEL:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(first);\n            add(\":\");\n            addNonEmptyExpression(last, getContextForNonEmptyExpression(context), true);\n            break;\n        case Token.SETNAME:\n            break;\n        default:\n            throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n    cc.endSourceMapping(n);\n}",
      "path": "src/com/google/javascript/jscomp/CodeGenerator.java",
      "functionStartLine": 86,
      "functionName": "add",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,422 +1,426 @@\n void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n         return;\n     }\n     int type \u003d n.getType();\n     String opstr \u003d NodeUtil.opToStr(type);\n     int childCount \u003d n.getChildCount();\n     Node first \u003d n.getFirstChild();\n     Node last \u003d n.getLastChild();\n     if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n         Preconditions.checkState(childCount \u003d\u003d 2);\n         int p \u003d NodeUtil.precedence(type);\n         addLeftExpr(first, p, context);\n         cc.addOp(opstr, true);\n         Context rhsContext \u003d getContextForNoInOperator(context);\n         if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n             addExpr(last, p, rhsContext);\n         } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n             addExpr(last, p, rhsContext);\n         } else {\n             addExpr(last, p + 1, rhsContext);\n         }\n         return;\n     }\n     cc.startSourceMapping(n);\n     switch(type) {\n         case Token.TRY:\n             {\n                 Preconditions.checkState(first.getNext().getType() \u003d\u003d Token.BLOCK \u0026\u0026 first.getNext().getChildCount() \u003c\u003d 1);\n                 Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                 add(\"try\");\n                 add(first, Context.PRESERVE_BLOCK);\n                 Node catchblock \u003d first.getNext().getFirstChild();\n                 if (catchblock !\u003d null) {\n                     add(catchblock);\n                 }\n                 if (childCount \u003d\u003d 3) {\n                     add(\"finally\");\n                     add(last, Context.PRESERVE_BLOCK);\n                 }\n                 break;\n             }\n         case Token.CATCH:\n             Preconditions.checkState(childCount \u003d\u003d 3);\n             if (first.getNext().getType() !\u003d Token.EMPTY) {\n                 throw new Error(\"Catch conditions not suppored because I think\" + \" that it may be a netscape only feature.\");\n             }\n             add(\"catch(\");\n             add(first);\n             add(\")\");\n             add(last, Context.PRESERVE_BLOCK);\n             break;\n         case Token.THROW:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"throw\");\n             add(first);\n             cc.endStatement(true);\n             break;\n         case Token.RETURN:\n             add(\"return\");\n             if (childCount \u003d\u003d 1) {\n                 add(first);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 0);\n             }\n             cc.endStatement();\n             break;\n         case Token.VAR:\n             if (first !\u003d null) {\n                 add(\"var \");\n                 addList(first, false, getContextForNoInOperator(context));\n             }\n             break;\n         case Token.NAME:\n             if (first \u003d\u003d null || first.getType() \u003d\u003d Token.EMPTY) {\n                 addIdentifier(n.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 addIdentifier(n.getString());\n                 cc.addOp(\"\u003d\", true);\n                 if (first.getType() \u003d\u003d Token.COMMA) {\n                     addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                 } else {\n                     addExpr(first, 0, getContextForNoInOperator(context));\n                 }\n             }\n             break;\n         case Token.ARRAYLIT:\n             add(\"[\");\n             addList(first, (int[]) n.getProp(Node.SKIP_INDEXES_PROP));\n             add(\"]\");\n             break;\n         case Token.LP:\n             add(\"(\");\n             addList(first);\n             add(\")\");\n             break;\n         case Token.COMMA:\n             addList(first, false, context);\n             break;\n         case Token.NUMBER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             cc.addNumber(n.getDouble());\n             break;\n         case Token.TYPEOF:\n         case Token.VOID:\n         case Token.NOT:\n         case Token.BITNOT:\n         case Token.POS:\n         case Token.NEG:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                 addExpr(first, NodeUtil.precedence(type));\n                 break;\n             }\n         case Token.HOOK:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 int p \u003d NodeUtil.precedence(type);\n                 addLeftExpr(first, p + 1, context);\n                 cc.addOp(\"?\", true);\n                 addExpr(first.getNext(), p);\n                 cc.addOp(\":\", true);\n                 addExpr(last, p);\n                 break;\n             }\n         case Token.REGEXP:\n             if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                 throw new Error(\"Expected children to be strings\");\n             }\n             String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n             if (childCount \u003d\u003d 2) {\n                 add(regexp + last.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 add(regexp);\n             }\n             break;\n         case Token.GET_REF:\n             add(first);\n             break;\n         case Token.REF_SPECIAL:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first);\n             add(\".\");\n             add((String) n.getProp(Node.NAME_PROP));\n             break;\n         case Token.FUNCTION:\n             Preconditions.checkState(childCount \u003d\u003d 3);\n             boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n             if (funcNeedsParens) {\n                 add(\"(\");\n             }\n             add(\"function\");\n             add(first);\n             add(first.getNext());\n             add(last, Context.PRESERVE_BLOCK);\n             cc.endFunction(context \u003d\u003d Context.STATEMENT);\n             if (funcNeedsParens) {\n                 add(\")\");\n             }\n             break;\n         case Token.SCRIPT:\n         case Token.BLOCK:\n             {\n                 boolean stripBlock \u003d n.isSyntheticBlock() || ((context !\u003d Context.PRESERVE_BLOCK) \u0026\u0026 (n.getChildCount() \u003c 2));\n                 if (!stripBlock) {\n                     cc.beginBlock();\n                 }\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     add(c, Context.STATEMENT);\n                     if (c.getType() \u003d\u003d Token.VAR) {\n                         cc.endStatement();\n                     }\n                     if (c.getType() \u003d\u003d Token.FUNCTION) {\n                         cc.maybeLineBreak();\n                     }\n                     if (type \u003d\u003d Token.SCRIPT) {\n                         cc.notePreferredLineBreak();\n                     }\n                 }\n                 if (!stripBlock) {\n                     cc.endBlock(context \u003d\u003d Context.STATEMENT);\n                 }\n                 break;\n             }\n         case Token.FOR:\n             if (childCount \u003d\u003d 4) {\n                 add(\"for(\");\n                 if (first.getType() \u003d\u003d Token.VAR) {\n                     add(first, Context.IN_FOR_INIT_CLAUSE);\n                 } else {\n                     addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                 }\n                 add(\";\");\n                 add(first.getNext());\n                 add(\";\");\n                 add(first.getNext().getNext());\n                 add(\")\");\n                 addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 add(\"for(\");\n                 add(first);\n                 add(\"in\");\n                 add(first.getNext());\n                 add(\")\");\n                 addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             }\n             break;\n         case Token.DO:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"do\");\n             addNonEmptyExpression(first, Context.OTHER, false);\n             add(\"while(\");\n             add(last);\n             add(\")\");\n             cc.endStatement();\n             break;\n         case Token.WHILE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"while(\");\n             add(first);\n             add(\")\");\n             addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.EMPTY:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             break;\n         case Token.GETPROP:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 2);\n                 Preconditions.checkState(last.getType() \u003d\u003d Token.STRING);\n                 boolean needsParens \u003d (first.getType() \u003d\u003d Token.NUMBER);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 add(\".\");\n                 addIdentifier(last.getString());\n                 break;\n             }\n         case Token.GETELEM:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             addLeftExpr(first, NodeUtil.precedence(type), context);\n             add(\"[\");\n             add(first.getNext());\n             add(\"]\");\n             break;\n         case Token.WITH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"with(\");\n             add(first);\n             add(\")\");\n             addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.INC:\n         case Token.DEC:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                 int postProp \u003d n.getIntProp(Node.INCRDECR_PROP, 0);\n                 if (postProp !\u003d 0) {\n                     addLeftExpr(first, NodeUtil.precedence(type), context);\n                     cc.addOp(o, false);\n                 } else {\n                     cc.addOp(o, false);\n                     add(first);\n                 }\n                 break;\n             }\n         case Token.CALL:\n-            addLeftExpr(first, NodeUtil.precedence(type), context);\n+            if (first.getType() \u003d\u003d Token.NAME \u0026\u0026 \"eval\".equals(first.getString()) \u0026\u0026 !first.getBooleanProp(Node.DIRECT_EVAL)) {\n+                add(\"(0,eval)\");\n+            } else {\n+                addLeftExpr(first, NodeUtil.precedence(type), context);\n+            }\n             add(\"(\");\n             addList(first.getNext());\n             add(\")\");\n             break;\n         case Token.IF:\n             boolean hasElse \u003d childCount \u003d\u003d 3;\n             boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n             if (ambiguousElseClause) {\n                 cc.beginBlock();\n             }\n             add(\"if(\");\n             add(first);\n             add(\")\");\n             if (hasElse) {\n                 addNonEmptyExpression(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                 add(\"else\");\n                 addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 addNonEmptyExpression(first.getNext(), Context.OTHER, false);\n                 Preconditions.checkState(childCount \u003d\u003d 2);\n             }\n             if (ambiguousElseClause) {\n                 cc.endBlock();\n             }\n             break;\n         case Token.NULL:\n         case Token.THIS:\n         case Token.FALSE:\n         case Token.TRUE:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(Node.tokenToName(type));\n             break;\n         case Token.CONTINUE:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"continue\");\n             if (childCount \u003d\u003d 1) {\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.DEBUGGER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(\"debugger\");\n             cc.endStatement();\n             break;\n         case Token.BREAK:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"break\");\n             if (childCount \u003d\u003d 1) {\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.EXPR_VOID:\n         case Token.EXPR_RESULT:\n             if (type \u003d\u003d Token.EXPR_VOID \u0026\u0026 validation) {\n                 throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n             }\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first, Context.START_OF_EXPR);\n             cc.endStatement();\n             break;\n         case Token.NEW:\n             add(\"new \");\n             int precedence \u003d NodeUtil.precedence(type);\n             if (NodeUtil.containsCall(first)) {\n                 precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n             }\n             addExpr(first, precedence);\n             Node next \u003d first.getNext();\n             if (next !\u003d null) {\n                 add(\"(\");\n                 addList(next);\n                 add(\")\");\n             }\n             break;\n         case Token.STRING:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(jsString(n.getString(), outputCharsetEncoder));\n             break;\n         case Token.DELPROP:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"delete \");\n             add(first);\n             break;\n         case Token.OBJECTLIT:\n             {\n                 Preconditions.checkState(childCount % 2 \u003d\u003d 0);\n                 boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 add(\"{\");\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext().getNext()) {\n                     if (c !\u003d first) {\n                         cc.listSeparator();\n                     }\n                     if (c.getType() \u003d\u003d Token.STRING \u0026\u0026 !TokenStream.isKeyword(c.getString()) \u0026\u0026 TokenStream.isJSIdentifier(c.getString()) \u0026\u0026 NodeUtil.isLatin(c.getString())) {\n                         add(c.getString());\n                     } else {\n                         addExpr(c, 1);\n                     }\n                     add(\":\");\n                     addExpr(c.getNext(), 1);\n                 }\n                 add(\"}\");\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 break;\n             }\n         case Token.SWITCH:\n             add(\"switch(\");\n             add(first);\n             add(\")\");\n             cc.beginBlock();\n             addAllSiblings(first.getNext());\n             cc.endBlock(context \u003d\u003d Context.STATEMENT);\n             break;\n         case Token.CASE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"case \");\n             add(first);\n             addCaseBody(last);\n             break;\n         case Token.DEFAULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"default\");\n             addCaseBody(first);\n             break;\n         case Token.LABEL:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(first);\n             add(\":\");\n             addNonEmptyExpression(last, getContextForNonEmptyExpression(context), true);\n             break;\n         case Token.SETNAME:\n             break;\n         default:\n             throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n     }\n     cc.endSourceMapping(n);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "168bc14ff5e9e664863c3b1146f2a5b7a30ffb42": {
      "type": "Ybodychange",
      "commitMessage": "Add a pass for collecting symbols exported like window[\u0027x\u0027] \u003d ...\n\nFix for issue #70.\n\nAssorted minor bug fixes.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@31 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "12/11/09, 3:29 PM",
      "commitName": "168bc14ff5e9e664863c3b1146f2a5b7a30ffb42",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "commitDateOld": "12/8/09, 3:50 PM",
      "commitNameOld": "847b296c23a63aa0a0b38cc3e63883e1688288e3",
      "commitAuthorOld": "nicholas.j.santos@gmail.com",
      "daysBetweenCommits": 2.99,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n        return;\n    }\n    int type \u003d n.getType();\n    String opstr \u003d NodeUtil.opToStr(type);\n    int childCount \u003d n.getChildCount();\n    Node first \u003d n.getFirstChild();\n    Node last \u003d n.getLastChild();\n    if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n        Preconditions.checkState(childCount \u003d\u003d 2);\n        int p \u003d NodeUtil.precedence(type);\n        addLeftExpr(first, p, context);\n        cc.addOp(opstr, true);\n        Context rhsContext \u003d getContextForNoInOperator(context);\n        if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n            addExpr(last, p, rhsContext);\n        } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n            addExpr(last, p, rhsContext);\n        } else {\n            addExpr(last, p + 1, rhsContext);\n        }\n        return;\n    }\n    cc.startSourceMapping(n);\n    switch(type) {\n        case Token.TRY:\n            {\n                Preconditions.checkState(first.getNext().getType() \u003d\u003d Token.BLOCK \u0026\u0026 first.getNext().getChildCount() \u003c\u003d 1);\n                Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                add(\"try\");\n                add(first, Context.PRESERVE_BLOCK);\n                Node catchblock \u003d first.getNext().getFirstChild();\n                if (catchblock !\u003d null) {\n                    add(catchblock);\n                }\n                if (childCount \u003d\u003d 3) {\n                    add(\"finally\");\n                    add(last, Context.PRESERVE_BLOCK);\n                }\n                break;\n            }\n        case Token.CATCH:\n            Preconditions.checkState(childCount \u003d\u003d 3);\n            if (first.getNext().getType() !\u003d Token.EMPTY) {\n                throw new Error(\"Catch conditions not suppored because I think\" + \" that it may be a netscape only feature.\");\n            }\n            add(\"catch(\");\n            add(first);\n            add(\")\");\n            add(last, Context.PRESERVE_BLOCK);\n            break;\n        case Token.THROW:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"throw\");\n            add(first);\n            cc.endStatement(true);\n            break;\n        case Token.RETURN:\n            add(\"return\");\n            if (childCount \u003d\u003d 1) {\n                add(first);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 0);\n            }\n            cc.endStatement();\n            break;\n        case Token.VAR:\n            if (first !\u003d null) {\n                add(\"var \");\n                addList(first, false, getContextForNoInOperator(context));\n            }\n            break;\n        case Token.NAME:\n            if (first \u003d\u003d null || first.getType() \u003d\u003d Token.EMPTY) {\n                addIdentifier(n.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                addIdentifier(n.getString());\n                cc.addOp(\"\u003d\", true);\n                if (first.getType() \u003d\u003d Token.COMMA) {\n                    addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                } else {\n                    addExpr(first, 0, getContextForNoInOperator(context));\n                }\n            }\n            break;\n        case Token.ARRAYLIT:\n            add(\"[\");\n            addList(first, (int[]) n.getProp(Node.SKIP_INDEXES_PROP));\n            add(\"]\");\n            break;\n        case Token.LP:\n            add(\"(\");\n            addList(first);\n            add(\")\");\n            break;\n        case Token.COMMA:\n            addList(first, false, context);\n            break;\n        case Token.NUMBER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            cc.addNumber(n.getDouble());\n            break;\n        case Token.TYPEOF:\n        case Token.VOID:\n        case Token.NOT:\n        case Token.BITNOT:\n        case Token.POS:\n        case Token.NEG:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                addExpr(first, NodeUtil.precedence(type));\n                break;\n            }\n        case Token.HOOK:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                int p \u003d NodeUtil.precedence(type);\n                addLeftExpr(first, p + 1, context);\n                cc.addOp(\"?\", true);\n                addExpr(first.getNext(), p);\n                cc.addOp(\":\", true);\n                addExpr(last, p);\n                break;\n            }\n        case Token.REGEXP:\n            if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                throw new Error(\"Expected children to be strings\");\n            }\n            String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n            if (childCount \u003d\u003d 2) {\n                add(regexp + last.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                add(regexp);\n            }\n            break;\n        case Token.GET_REF:\n            add(first);\n            break;\n        case Token.REF_SPECIAL:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first);\n            add(\".\");\n            add((String) n.getProp(Node.NAME_PROP));\n            break;\n        case Token.FUNCTION:\n            Preconditions.checkState(childCount \u003d\u003d 3);\n            boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n            if (funcNeedsParens) {\n                add(\"(\");\n            }\n            add(\"function\");\n            add(first);\n            add(first.getNext());\n            add(last, Context.PRESERVE_BLOCK);\n            cc.endFunction(context \u003d\u003d Context.STATEMENT);\n            if (funcNeedsParens) {\n                add(\")\");\n            }\n            break;\n        case Token.SCRIPT:\n        case Token.BLOCK:\n            {\n                boolean stripBlock \u003d n.isSyntheticBlock() || ((context !\u003d Context.PRESERVE_BLOCK) \u0026\u0026 (n.getChildCount() \u003c 2));\n                if (!stripBlock) {\n                    cc.beginBlock();\n                }\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    add(c, Context.STATEMENT);\n                    if (c.getType() \u003d\u003d Token.VAR) {\n                        cc.endStatement();\n                    }\n                    if (c.getType() \u003d\u003d Token.FUNCTION) {\n                        cc.maybeLineBreak();\n                    }\n                    if (type \u003d\u003d Token.SCRIPT) {\n                        cc.notePreferredLineBreak();\n                    }\n                }\n                if (!stripBlock) {\n                    cc.endBlock(context \u003d\u003d Context.STATEMENT);\n                }\n                break;\n            }\n        case Token.FOR:\n            if (childCount \u003d\u003d 4) {\n                add(\"for(\");\n                if (first.getType() \u003d\u003d Token.VAR) {\n                    add(first, Context.IN_FOR_INIT_CLAUSE);\n                } else {\n                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                }\n                add(\";\");\n                add(first.getNext());\n                add(\";\");\n                add(first.getNext().getNext());\n                add(\")\");\n                addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                add(\"for(\");\n                add(first);\n                add(\"in\");\n                add(first.getNext());\n                add(\")\");\n                addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            }\n            break;\n        case Token.DO:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"do\");\n            addNonEmptyExpression(first, Context.OTHER, false);\n            add(\"while(\");\n            add(last);\n            add(\")\");\n            cc.endStatement();\n            break;\n        case Token.WHILE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"while(\");\n            add(first);\n            add(\")\");\n            addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.EMPTY:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            break;\n        case Token.GETPROP:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 2);\n                Preconditions.checkState(last.getType() \u003d\u003d Token.STRING);\n                boolean needsParens \u003d (first.getType() \u003d\u003d Token.NUMBER);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n                if (needsParens) {\n                    add(\")\");\n                }\n                add(\".\");\n                addIdentifier(last.getString());\n                break;\n            }\n        case Token.GETELEM:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            addLeftExpr(first, NodeUtil.precedence(type), context);\n            add(\"[\");\n            add(first.getNext());\n            add(\"]\");\n            break;\n        case Token.WITH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"with(\");\n            add(first);\n            add(\")\");\n            addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.INC:\n        case Token.DEC:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                int postProp \u003d n.getIntProp(Node.INCRDECR_PROP, 0);\n                if (postProp !\u003d 0) {\n                    addLeftExpr(first, NodeUtil.precedence(type), context);\n                    cc.addOp(o, false);\n                } else {\n                    cc.addOp(o, false);\n                    add(first);\n                }\n                break;\n            }\n        case Token.CALL:\n            addLeftExpr(first, NodeUtil.precedence(type), context);\n            add(\"(\");\n            addList(first.getNext());\n            add(\")\");\n            break;\n        case Token.IF:\n            boolean hasElse \u003d childCount \u003d\u003d 3;\n            boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n            if (ambiguousElseClause) {\n                cc.beginBlock();\n            }\n            add(\"if(\");\n            add(first);\n            add(\")\");\n            if (hasElse) {\n                addNonEmptyExpression(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                add(\"else\");\n                addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                addNonEmptyExpression(first.getNext(), Context.OTHER, false);\n                Preconditions.checkState(childCount \u003d\u003d 2);\n            }\n            if (ambiguousElseClause) {\n                cc.endBlock();\n            }\n            break;\n        case Token.NULL:\n        case Token.THIS:\n        case Token.FALSE:\n        case Token.TRUE:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(Node.tokenToName(type));\n            break;\n        case Token.CONTINUE:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"continue\");\n            if (childCount \u003d\u003d 1) {\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.DEBUGGER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"debugger\");\n            cc.endStatement();\n            break;\n        case Token.BREAK:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"break\");\n            if (childCount \u003d\u003d 1) {\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.EXPR_VOID:\n        case Token.EXPR_RESULT:\n            if (type \u003d\u003d Token.EXPR_VOID \u0026\u0026 validation) {\n                throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n            }\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first, Context.START_OF_EXPR);\n            cc.endStatement();\n            break;\n        case Token.NEW:\n            add(\"new \");\n            int precedence \u003d NodeUtil.precedence(type);\n            if (NodeUtil.containsCall(first)) {\n                precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n            }\n            addExpr(first, precedence);\n            Node next \u003d first.getNext();\n            if (next !\u003d null) {\n                add(\"(\");\n                addList(next);\n                add(\")\");\n            }\n            break;\n        case Token.STRING:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(jsString(n.getString(), outputCharsetEncoder));\n            break;\n        case Token.DELPROP:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"delete \");\n            add(first);\n            break;\n        case Token.OBJECTLIT:\n            {\n                Preconditions.checkState(childCount % 2 \u003d\u003d 0);\n                boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                add(\"{\");\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext().getNext()) {\n                    if (c !\u003d first) {\n                        cc.listSeparator();\n                    }\n                    if (c.getType() \u003d\u003d Token.STRING \u0026\u0026 !TokenStream.isKeyword(c.getString()) \u0026\u0026 TokenStream.isJSIdentifier(c.getString()) \u0026\u0026 NodeUtil.isLatin(c.getString())) {\n                        add(c.getString());\n                    } else {\n                        addExpr(c, 1);\n                    }\n                    add(\":\");\n                    addExpr(c.getNext(), 1);\n                }\n                add(\"}\");\n                if (needsParens) {\n                    add(\")\");\n                }\n                break;\n            }\n        case Token.SWITCH:\n            add(\"switch(\");\n            add(first);\n            add(\")\");\n            cc.beginBlock();\n            addAllSiblings(first.getNext());\n            cc.endBlock(context \u003d\u003d Context.STATEMENT);\n            break;\n        case Token.CASE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"case \");\n            add(first);\n            addCaseBody(last);\n            break;\n        case Token.DEFAULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"default\");\n            addCaseBody(first);\n            break;\n        case Token.LABEL:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(first);\n            add(\":\");\n            addNonEmptyExpression(last, getContextForNonEmptyExpression(context), true);\n            break;\n        case Token.SETNAME:\n            break;\n        default:\n            throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n    cc.endSourceMapping(n);\n}",
      "path": "src/com/google/javascript/jscomp/CodeGenerator.java",
      "functionStartLine": 82,
      "functionName": "add",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,419 +1,422 @@\n void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n         return;\n     }\n     int type \u003d n.getType();\n     String opstr \u003d NodeUtil.opToStr(type);\n     int childCount \u003d n.getChildCount();\n     Node first \u003d n.getFirstChild();\n     Node last \u003d n.getLastChild();\n     if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n         Preconditions.checkState(childCount \u003d\u003d 2);\n         int p \u003d NodeUtil.precedence(type);\n         addLeftExpr(first, p, context);\n         cc.addOp(opstr, true);\n         Context rhsContext \u003d getContextForNoInOperator(context);\n         if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n             addExpr(last, p, rhsContext);\n         } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n             addExpr(last, p, rhsContext);\n         } else {\n             addExpr(last, p + 1, rhsContext);\n         }\n         return;\n     }\n     cc.startSourceMapping(n);\n     switch(type) {\n         case Token.TRY:\n             {\n                 Preconditions.checkState(first.getNext().getType() \u003d\u003d Token.BLOCK \u0026\u0026 first.getNext().getChildCount() \u003c\u003d 1);\n                 Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                 add(\"try\");\n                 add(first, Context.PRESERVE_BLOCK);\n                 Node catchblock \u003d first.getNext().getFirstChild();\n                 if (catchblock !\u003d null) {\n                     add(catchblock);\n                 }\n                 if (childCount \u003d\u003d 3) {\n                     add(\"finally\");\n                     add(last, Context.PRESERVE_BLOCK);\n                 }\n                 break;\n             }\n         case Token.CATCH:\n             Preconditions.checkState(childCount \u003d\u003d 3);\n             if (first.getNext().getType() !\u003d Token.EMPTY) {\n                 throw new Error(\"Catch conditions not suppored because I think\" + \" that it may be a netscape only feature.\");\n             }\n             add(\"catch(\");\n             add(first);\n             add(\")\");\n             add(last, Context.PRESERVE_BLOCK);\n             break;\n         case Token.THROW:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"throw\");\n             add(first);\n             cc.endStatement(true);\n             break;\n         case Token.RETURN:\n             add(\"return\");\n             if (childCount \u003d\u003d 1) {\n                 add(first);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 0);\n             }\n             cc.endStatement();\n             break;\n         case Token.VAR:\n             if (first !\u003d null) {\n                 add(\"var \");\n                 addList(first, false, getContextForNoInOperator(context));\n             }\n             break;\n         case Token.NAME:\n             if (first \u003d\u003d null || first.getType() \u003d\u003d Token.EMPTY) {\n                 addIdentifier(n.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 addIdentifier(n.getString());\n                 cc.addOp(\"\u003d\", true);\n                 if (first.getType() \u003d\u003d Token.COMMA) {\n                     addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                 } else {\n                     addExpr(first, 0, getContextForNoInOperator(context));\n                 }\n             }\n             break;\n         case Token.ARRAYLIT:\n             add(\"[\");\n             addList(first, (int[]) n.getProp(Node.SKIP_INDEXES_PROP));\n             add(\"]\");\n             break;\n         case Token.LP:\n             add(\"(\");\n             addList(first);\n             add(\")\");\n             break;\n         case Token.COMMA:\n             addList(first, false, context);\n             break;\n         case Token.NUMBER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             cc.addNumber(n.getDouble());\n             break;\n         case Token.TYPEOF:\n         case Token.VOID:\n         case Token.NOT:\n         case Token.BITNOT:\n         case Token.POS:\n         case Token.NEG:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                 addExpr(first, NodeUtil.precedence(type));\n                 break;\n             }\n         case Token.HOOK:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 int p \u003d NodeUtil.precedence(type);\n                 addLeftExpr(first, p + 1, context);\n                 cc.addOp(\"?\", true);\n                 addExpr(first.getNext(), p);\n                 cc.addOp(\":\", true);\n                 addExpr(last, p);\n                 break;\n             }\n         case Token.REGEXP:\n             if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                 throw new Error(\"Expected children to be strings\");\n             }\n             String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n             if (childCount \u003d\u003d 2) {\n                 add(regexp + last.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 add(regexp);\n             }\n             break;\n         case Token.GET_REF:\n             add(first);\n             break;\n         case Token.REF_SPECIAL:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first);\n             add(\".\");\n             add((String) n.getProp(Node.NAME_PROP));\n             break;\n         case Token.FUNCTION:\n             Preconditions.checkState(childCount \u003d\u003d 3);\n             boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n             if (funcNeedsParens) {\n                 add(\"(\");\n             }\n             add(\"function\");\n             add(first);\n             add(first.getNext());\n             add(last, Context.PRESERVE_BLOCK);\n             cc.endFunction(context \u003d\u003d Context.STATEMENT);\n             if (funcNeedsParens) {\n                 add(\")\");\n             }\n             break;\n         case Token.SCRIPT:\n         case Token.BLOCK:\n             {\n                 boolean stripBlock \u003d n.isSyntheticBlock() || ((context !\u003d Context.PRESERVE_BLOCK) \u0026\u0026 (n.getChildCount() \u003c 2));\n                 if (!stripBlock) {\n                     cc.beginBlock();\n                 }\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     add(c, Context.STATEMENT);\n                     if (c.getType() \u003d\u003d Token.VAR) {\n                         cc.endStatement();\n                     }\n                     if (c.getType() \u003d\u003d Token.FUNCTION) {\n                         cc.maybeLineBreak();\n                     }\n                     if (type \u003d\u003d Token.SCRIPT) {\n                         cc.notePreferredLineBreak();\n                     }\n                 }\n                 if (!stripBlock) {\n                     cc.endBlock(context \u003d\u003d Context.STATEMENT);\n                 }\n                 break;\n             }\n         case Token.FOR:\n             if (childCount \u003d\u003d 4) {\n                 add(\"for(\");\n                 if (first.getType() \u003d\u003d Token.VAR) {\n                     add(first, Context.IN_FOR_INIT_CLAUSE);\n                 } else {\n                     addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                 }\n                 add(\";\");\n                 add(first.getNext());\n                 add(\";\");\n                 add(first.getNext().getNext());\n                 add(\")\");\n                 addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 add(\"for(\");\n                 add(first);\n                 add(\"in\");\n                 add(first.getNext());\n                 add(\")\");\n                 addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             }\n             break;\n         case Token.DO:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"do\");\n             addNonEmptyExpression(first, Context.OTHER, false);\n             add(\"while(\");\n             add(last);\n             add(\")\");\n             cc.endStatement();\n             break;\n         case Token.WHILE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"while(\");\n             add(first);\n             add(\")\");\n             addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.EMPTY:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             break;\n         case Token.GETPROP:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 2);\n                 Preconditions.checkState(last.getType() \u003d\u003d Token.STRING);\n                 boolean needsParens \u003d (first.getType() \u003d\u003d Token.NUMBER);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 add(\".\");\n                 addIdentifier(last.getString());\n                 break;\n             }\n         case Token.GETELEM:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             addLeftExpr(first, NodeUtil.precedence(type), context);\n             add(\"[\");\n             add(first.getNext());\n             add(\"]\");\n             break;\n         case Token.WITH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"with(\");\n             add(first);\n             add(\")\");\n             addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.INC:\n         case Token.DEC:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                 int postProp \u003d n.getIntProp(Node.INCRDECR_PROP, 0);\n                 if (postProp !\u003d 0) {\n                     addLeftExpr(first, NodeUtil.precedence(type), context);\n                     cc.addOp(o, false);\n                 } else {\n                     cc.addOp(o, false);\n                     add(first);\n                 }\n                 break;\n             }\n         case Token.CALL:\n             addLeftExpr(first, NodeUtil.precedence(type), context);\n             add(\"(\");\n             addList(first.getNext());\n             add(\")\");\n             break;\n         case Token.IF:\n             boolean hasElse \u003d childCount \u003d\u003d 3;\n             boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n             if (ambiguousElseClause) {\n                 cc.beginBlock();\n             }\n             add(\"if(\");\n             add(first);\n             add(\")\");\n             if (hasElse) {\n                 addNonEmptyExpression(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                 add(\"else\");\n                 addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 addNonEmptyExpression(first.getNext(), Context.OTHER, false);\n                 Preconditions.checkState(childCount \u003d\u003d 2);\n             }\n             if (ambiguousElseClause) {\n                 cc.endBlock();\n             }\n             break;\n         case Token.NULL:\n         case Token.THIS:\n         case Token.FALSE:\n         case Token.TRUE:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(Node.tokenToName(type));\n             break;\n         case Token.CONTINUE:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"continue\");\n             if (childCount \u003d\u003d 1) {\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.DEBUGGER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(\"debugger\");\n             cc.endStatement();\n             break;\n         case Token.BREAK:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"break\");\n             if (childCount \u003d\u003d 1) {\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.EXPR_VOID:\n         case Token.EXPR_RESULT:\n+            if (type \u003d\u003d Token.EXPR_VOID \u0026\u0026 validation) {\n+                throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n+            }\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first, Context.START_OF_EXPR);\n             cc.endStatement();\n             break;\n         case Token.NEW:\n             add(\"new \");\n             int precedence \u003d NodeUtil.precedence(type);\n             if (NodeUtil.containsCall(first)) {\n                 precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n             }\n             addExpr(first, precedence);\n             Node next \u003d first.getNext();\n             if (next !\u003d null) {\n                 add(\"(\");\n                 addList(next);\n                 add(\")\");\n             }\n             break;\n         case Token.STRING:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(jsString(n.getString(), outputCharsetEncoder));\n             break;\n         case Token.DELPROP:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"delete \");\n             add(first);\n             break;\n         case Token.OBJECTLIT:\n             {\n                 Preconditions.checkState(childCount % 2 \u003d\u003d 0);\n                 boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 add(\"{\");\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext().getNext()) {\n                     if (c !\u003d first) {\n                         cc.listSeparator();\n                     }\n                     if (c.getType() \u003d\u003d Token.STRING \u0026\u0026 !TokenStream.isKeyword(c.getString()) \u0026\u0026 TokenStream.isJSIdentifier(c.getString()) \u0026\u0026 NodeUtil.isLatin(c.getString())) {\n                         add(c.getString());\n                     } else {\n                         addExpr(c, 1);\n                     }\n                     add(\":\");\n                     addExpr(c.getNext(), 1);\n                 }\n                 add(\"}\");\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 break;\n             }\n         case Token.SWITCH:\n             add(\"switch(\");\n             add(first);\n             add(\")\");\n             cc.beginBlock();\n             addAllSiblings(first.getNext());\n             cc.endBlock(context \u003d\u003d Context.STATEMENT);\n             break;\n         case Token.CASE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"case \");\n             add(first);\n             addCaseBody(last);\n             break;\n         case Token.DEFAULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"default\");\n             addCaseBody(first);\n             break;\n         case Token.LABEL:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(first);\n             add(\":\");\n             addNonEmptyExpression(last, getContextForNonEmptyExpression(context), true);\n             break;\n         case Token.SETNAME:\n             break;\n         default:\n             throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n     }\n     cc.endSourceMapping(n);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "847b296c23a63aa0a0b38cc3e63883e1688288e3": {
      "type": "Ybodychange",
      "commitMessage": "Add support for other charset types.\n\nAdd support for ES5 directives.\n\nFork unit tests, so that they run more hermetically.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@21 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "12/8/09, 3:50 PM",
      "commitName": "847b296c23a63aa0a0b38cc3e63883e1688288e3",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "commitDateOld": "11/3/09, 3:51 PM",
      "commitNameOld": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthorOld": "nicholas.j.santos@gmail.com",
      "daysBetweenCommits": 35.0,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "actualSource": "void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n        return;\n    }\n    int type \u003d n.getType();\n    String opstr \u003d NodeUtil.opToStr(type);\n    int childCount \u003d n.getChildCount();\n    Node first \u003d n.getFirstChild();\n    Node last \u003d n.getLastChild();\n    if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n        Preconditions.checkState(childCount \u003d\u003d 2);\n        int p \u003d NodeUtil.precedence(type);\n        addLeftExpr(first, p, context);\n        cc.addOp(opstr, true);\n        Context rhsContext \u003d getContextForNoInOperator(context);\n        if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n            addExpr(last, p, rhsContext);\n        } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n            addExpr(last, p, rhsContext);\n        } else {\n            addExpr(last, p + 1, rhsContext);\n        }\n        return;\n    }\n    cc.startSourceMapping(n);\n    switch(type) {\n        case Token.TRY:\n            {\n                Preconditions.checkState(first.getNext().getType() \u003d\u003d Token.BLOCK \u0026\u0026 first.getNext().getChildCount() \u003c\u003d 1);\n                Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                add(\"try\");\n                add(first, Context.PRESERVE_BLOCK);\n                Node catchblock \u003d first.getNext().getFirstChild();\n                if (catchblock !\u003d null) {\n                    add(catchblock);\n                }\n                if (childCount \u003d\u003d 3) {\n                    add(\"finally\");\n                    add(last, Context.PRESERVE_BLOCK);\n                }\n                break;\n            }\n        case Token.CATCH:\n            Preconditions.checkState(childCount \u003d\u003d 3);\n            if (first.getNext().getType() !\u003d Token.EMPTY) {\n                throw new Error(\"Catch conditions not suppored because I think\" + \" that it may be a netscape only feature.\");\n            }\n            add(\"catch(\");\n            add(first);\n            add(\")\");\n            add(last, Context.PRESERVE_BLOCK);\n            break;\n        case Token.THROW:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"throw\");\n            add(first);\n            cc.endStatement(true);\n            break;\n        case Token.RETURN:\n            add(\"return\");\n            if (childCount \u003d\u003d 1) {\n                add(first);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 0);\n            }\n            cc.endStatement();\n            break;\n        case Token.VAR:\n            if (first !\u003d null) {\n                add(\"var \");\n                addList(first, false, getContextForNoInOperator(context));\n            }\n            break;\n        case Token.NAME:\n            if (first \u003d\u003d null || first.getType() \u003d\u003d Token.EMPTY) {\n                addIdentifier(n.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                addIdentifier(n.getString());\n                cc.addOp(\"\u003d\", true);\n                if (first.getType() \u003d\u003d Token.COMMA) {\n                    addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                } else {\n                    addExpr(first, 0, getContextForNoInOperator(context));\n                }\n            }\n            break;\n        case Token.ARRAYLIT:\n            add(\"[\");\n            addList(first, (int[]) n.getProp(Node.SKIP_INDEXES_PROP));\n            add(\"]\");\n            break;\n        case Token.LP:\n            add(\"(\");\n            addList(first);\n            add(\")\");\n            break;\n        case Token.COMMA:\n            addList(first, false, context);\n            break;\n        case Token.NUMBER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            cc.addNumber(n.getDouble());\n            break;\n        case Token.TYPEOF:\n        case Token.VOID:\n        case Token.NOT:\n        case Token.BITNOT:\n        case Token.POS:\n        case Token.NEG:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                addExpr(first, NodeUtil.precedence(type));\n                break;\n            }\n        case Token.HOOK:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                int p \u003d NodeUtil.precedence(type);\n                addLeftExpr(first, p + 1, context);\n                cc.addOp(\"?\", true);\n                addExpr(first.getNext(), p);\n                cc.addOp(\":\", true);\n                addExpr(last, p);\n                break;\n            }\n        case Token.REGEXP:\n            if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                throw new Error(\"Expected children to be strings\");\n            }\n            String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n            if (childCount \u003d\u003d 2) {\n                add(regexp + last.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                add(regexp);\n            }\n            break;\n        case Token.GET_REF:\n            add(first);\n            break;\n        case Token.REF_SPECIAL:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first);\n            add(\".\");\n            add((String) n.getProp(Node.NAME_PROP));\n            break;\n        case Token.FUNCTION:\n            Preconditions.checkState(childCount \u003d\u003d 3);\n            boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n            if (funcNeedsParens) {\n                add(\"(\");\n            }\n            add(\"function\");\n            add(first);\n            add(first.getNext());\n            add(last, Context.PRESERVE_BLOCK);\n            cc.endFunction(context \u003d\u003d Context.STATEMENT);\n            if (funcNeedsParens) {\n                add(\")\");\n            }\n            break;\n        case Token.SCRIPT:\n        case Token.BLOCK:\n            {\n                boolean stripBlock \u003d n.isSyntheticBlock() || ((context !\u003d Context.PRESERVE_BLOCK) \u0026\u0026 (n.getChildCount() \u003c 2));\n                if (!stripBlock) {\n                    cc.beginBlock();\n                }\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    add(c, Context.STATEMENT);\n                    if (c.getType() \u003d\u003d Token.VAR) {\n                        cc.endStatement();\n                    }\n                    if (c.getType() \u003d\u003d Token.FUNCTION) {\n                        cc.maybeLineBreak();\n                    }\n                    if (type \u003d\u003d Token.SCRIPT) {\n                        cc.notePreferredLineBreak();\n                    }\n                }\n                if (!stripBlock) {\n                    cc.endBlock(context \u003d\u003d Context.STATEMENT);\n                }\n                break;\n            }\n        case Token.FOR:\n            if (childCount \u003d\u003d 4) {\n                add(\"for(\");\n                if (first.getType() \u003d\u003d Token.VAR) {\n                    add(first, Context.IN_FOR_INIT_CLAUSE);\n                } else {\n                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                }\n                add(\";\");\n                add(first.getNext());\n                add(\";\");\n                add(first.getNext().getNext());\n                add(\")\");\n                addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                add(\"for(\");\n                add(first);\n                add(\"in\");\n                add(first.getNext());\n                add(\")\");\n                addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            }\n            break;\n        case Token.DO:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"do\");\n            addNonEmptyExpression(first, Context.OTHER, false);\n            add(\"while(\");\n            add(last);\n            add(\")\");\n            cc.endStatement();\n            break;\n        case Token.WHILE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"while(\");\n            add(first);\n            add(\")\");\n            addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.EMPTY:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            break;\n        case Token.GETPROP:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 2);\n                Preconditions.checkState(last.getType() \u003d\u003d Token.STRING);\n                boolean needsParens \u003d (first.getType() \u003d\u003d Token.NUMBER);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n                if (needsParens) {\n                    add(\")\");\n                }\n                add(\".\");\n                addIdentifier(last.getString());\n                break;\n            }\n        case Token.GETELEM:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            addLeftExpr(first, NodeUtil.precedence(type), context);\n            add(\"[\");\n            add(first.getNext());\n            add(\"]\");\n            break;\n        case Token.WITH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"with(\");\n            add(first);\n            add(\")\");\n            addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.INC:\n        case Token.DEC:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                int postProp \u003d n.getIntProp(Node.INCRDECR_PROP, 0);\n                if (postProp !\u003d 0) {\n                    addLeftExpr(first, NodeUtil.precedence(type), context);\n                    cc.addOp(o, false);\n                } else {\n                    cc.addOp(o, false);\n                    add(first);\n                }\n                break;\n            }\n        case Token.CALL:\n            addLeftExpr(first, NodeUtil.precedence(type), context);\n            add(\"(\");\n            addList(first.getNext());\n            add(\")\");\n            break;\n        case Token.IF:\n            boolean hasElse \u003d childCount \u003d\u003d 3;\n            boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n            if (ambiguousElseClause) {\n                cc.beginBlock();\n            }\n            add(\"if(\");\n            add(first);\n            add(\")\");\n            if (hasElse) {\n                addNonEmptyExpression(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                add(\"else\");\n                addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                addNonEmptyExpression(first.getNext(), Context.OTHER, false);\n                Preconditions.checkState(childCount \u003d\u003d 2);\n            }\n            if (ambiguousElseClause) {\n                cc.endBlock();\n            }\n            break;\n        case Token.NULL:\n        case Token.THIS:\n        case Token.FALSE:\n        case Token.TRUE:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(Node.tokenToName(type));\n            break;\n        case Token.CONTINUE:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"continue\");\n            if (childCount \u003d\u003d 1) {\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.DEBUGGER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"debugger\");\n            cc.endStatement();\n            break;\n        case Token.BREAK:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"break\");\n            if (childCount \u003d\u003d 1) {\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.EXPR_VOID:\n        case Token.EXPR_RESULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first, Context.START_OF_EXPR);\n            cc.endStatement();\n            break;\n        case Token.NEW:\n            add(\"new \");\n            int precedence \u003d NodeUtil.precedence(type);\n            if (NodeUtil.containsCall(first)) {\n                precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n            }\n            addExpr(first, precedence);\n            Node next \u003d first.getNext();\n            if (next !\u003d null) {\n                add(\"(\");\n                addList(next);\n                add(\")\");\n            }\n            break;\n        case Token.STRING:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(jsString(n.getString(), outputCharsetEncoder));\n            break;\n        case Token.DELPROP:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"delete \");\n            add(first);\n            break;\n        case Token.OBJECTLIT:\n            {\n                Preconditions.checkState(childCount % 2 \u003d\u003d 0);\n                boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                add(\"{\");\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext().getNext()) {\n                    if (c !\u003d first) {\n                        cc.listSeparator();\n                    }\n                    if (c.getType() \u003d\u003d Token.STRING \u0026\u0026 !TokenStream.isKeyword(c.getString()) \u0026\u0026 TokenStream.isJSIdentifier(c.getString()) \u0026\u0026 NodeUtil.isLatin(c.getString())) {\n                        add(c.getString());\n                    } else {\n                        addExpr(c, 1);\n                    }\n                    add(\":\");\n                    addExpr(c.getNext(), 1);\n                }\n                add(\"}\");\n                if (needsParens) {\n                    add(\")\");\n                }\n                break;\n            }\n        case Token.SWITCH:\n            add(\"switch(\");\n            add(first);\n            add(\")\");\n            cc.beginBlock();\n            addAllSiblings(first.getNext());\n            cc.endBlock(context \u003d\u003d Context.STATEMENT);\n            break;\n        case Token.CASE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"case \");\n            add(first);\n            addCaseBody(last);\n            break;\n        case Token.DEFAULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"default\");\n            addCaseBody(first);\n            break;\n        case Token.LABEL:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(first);\n            add(\":\");\n            addNonEmptyExpression(last, getContextForNonEmptyExpression(context), true);\n            break;\n        case Token.SETNAME:\n            break;\n        default:\n            throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n    cc.endSourceMapping(n);\n}",
      "path": "src/com/google/javascript/jscomp/CodeGenerator.java",
      "functionStartLine": 71,
      "functionName": "add",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,419 +1,419 @@\n void add(Node n, Context context) {\n     if (!cc.continueProcessing()) {\n         return;\n     }\n     int type \u003d n.getType();\n     String opstr \u003d NodeUtil.opToStr(type);\n     int childCount \u003d n.getChildCount();\n     Node first \u003d n.getFirstChild();\n     Node last \u003d n.getLastChild();\n     if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n         Preconditions.checkState(childCount \u003d\u003d 2);\n         int p \u003d NodeUtil.precedence(type);\n         addLeftExpr(first, p, context);\n         cc.addOp(opstr, true);\n         Context rhsContext \u003d getContextForNoInOperator(context);\n         if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n             addExpr(last, p, rhsContext);\n         } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n             addExpr(last, p, rhsContext);\n         } else {\n             addExpr(last, p + 1, rhsContext);\n         }\n         return;\n     }\n     cc.startSourceMapping(n);\n     switch(type) {\n         case Token.TRY:\n             {\n                 Preconditions.checkState(first.getNext().getType() \u003d\u003d Token.BLOCK \u0026\u0026 first.getNext().getChildCount() \u003c\u003d 1);\n                 Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                 add(\"try\");\n                 add(first, Context.PRESERVE_BLOCK);\n                 Node catchblock \u003d first.getNext().getFirstChild();\n                 if (catchblock !\u003d null) {\n                     add(catchblock);\n                 }\n                 if (childCount \u003d\u003d 3) {\n                     add(\"finally\");\n                     add(last, Context.PRESERVE_BLOCK);\n                 }\n                 break;\n             }\n         case Token.CATCH:\n             Preconditions.checkState(childCount \u003d\u003d 3);\n             if (first.getNext().getType() !\u003d Token.EMPTY) {\n                 throw new Error(\"Catch conditions not suppored because I think\" + \" that it may be a netscape only feature.\");\n             }\n             add(\"catch(\");\n             add(first);\n             add(\")\");\n             add(last, Context.PRESERVE_BLOCK);\n             break;\n         case Token.THROW:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"throw\");\n             add(first);\n             cc.endStatement(true);\n             break;\n         case Token.RETURN:\n             add(\"return\");\n             if (childCount \u003d\u003d 1) {\n                 add(first);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 0);\n             }\n             cc.endStatement();\n             break;\n         case Token.VAR:\n             if (first !\u003d null) {\n                 add(\"var \");\n                 addList(first, false, getContextForNoInOperator(context));\n             }\n             break;\n         case Token.NAME:\n             if (first \u003d\u003d null || first.getType() \u003d\u003d Token.EMPTY) {\n                 addIdentifier(n.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 addIdentifier(n.getString());\n                 cc.addOp(\"\u003d\", true);\n                 if (first.getType() \u003d\u003d Token.COMMA) {\n                     addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                 } else {\n                     addExpr(first, 0, getContextForNoInOperator(context));\n                 }\n             }\n             break;\n         case Token.ARRAYLIT:\n             add(\"[\");\n             addList(first, (int[]) n.getProp(Node.SKIP_INDEXES_PROP));\n             add(\"]\");\n             break;\n         case Token.LP:\n             add(\"(\");\n             addList(first);\n             add(\")\");\n             break;\n         case Token.COMMA:\n             addList(first, false, context);\n             break;\n         case Token.NUMBER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             cc.addNumber(n.getDouble());\n             break;\n         case Token.TYPEOF:\n         case Token.VOID:\n         case Token.NOT:\n         case Token.BITNOT:\n         case Token.POS:\n         case Token.NEG:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                 addExpr(first, NodeUtil.precedence(type));\n                 break;\n             }\n         case Token.HOOK:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 int p \u003d NodeUtil.precedence(type);\n                 addLeftExpr(first, p + 1, context);\n                 cc.addOp(\"?\", true);\n                 addExpr(first.getNext(), p);\n                 cc.addOp(\":\", true);\n                 addExpr(last, p);\n                 break;\n             }\n         case Token.REGEXP:\n             if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                 throw new Error(\"Expected children to be strings\");\n             }\n-            String regexp \u003d regexpEscape(first.getString());\n+            String regexp \u003d regexpEscape(first.getString(), outputCharsetEncoder);\n             if (childCount \u003d\u003d 2) {\n                 add(regexp + last.getString());\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 add(regexp);\n             }\n             break;\n         case Token.GET_REF:\n             add(first);\n             break;\n         case Token.REF_SPECIAL:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first);\n             add(\".\");\n             add((String) n.getProp(Node.NAME_PROP));\n             break;\n         case Token.FUNCTION:\n             Preconditions.checkState(childCount \u003d\u003d 3);\n             boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n             if (funcNeedsParens) {\n                 add(\"(\");\n             }\n             add(\"function\");\n             add(first);\n             add(first.getNext());\n             add(last, Context.PRESERVE_BLOCK);\n             cc.endFunction(context \u003d\u003d Context.STATEMENT);\n             if (funcNeedsParens) {\n                 add(\")\");\n             }\n             break;\n         case Token.SCRIPT:\n         case Token.BLOCK:\n             {\n                 boolean stripBlock \u003d n.isSyntheticBlock() || ((context !\u003d Context.PRESERVE_BLOCK) \u0026\u0026 (n.getChildCount() \u003c 2));\n                 if (!stripBlock) {\n                     cc.beginBlock();\n                 }\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                     add(c, Context.STATEMENT);\n                     if (c.getType() \u003d\u003d Token.VAR) {\n                         cc.endStatement();\n                     }\n                     if (c.getType() \u003d\u003d Token.FUNCTION) {\n                         cc.maybeLineBreak();\n                     }\n                     if (type \u003d\u003d Token.SCRIPT) {\n                         cc.notePreferredLineBreak();\n                     }\n                 }\n                 if (!stripBlock) {\n                     cc.endBlock(context \u003d\u003d Context.STATEMENT);\n                 }\n                 break;\n             }\n         case Token.FOR:\n             if (childCount \u003d\u003d 4) {\n                 add(\"for(\");\n                 if (first.getType() \u003d\u003d Token.VAR) {\n                     add(first, Context.IN_FOR_INIT_CLAUSE);\n                 } else {\n                     addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                 }\n                 add(\";\");\n                 add(first.getNext());\n                 add(\";\");\n                 add(first.getNext().getNext());\n                 add(\")\");\n                 addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 Preconditions.checkState(childCount \u003d\u003d 3);\n                 add(\"for(\");\n                 add(first);\n                 add(\"in\");\n                 add(first.getNext());\n                 add(\")\");\n                 addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             }\n             break;\n         case Token.DO:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"do\");\n             addNonEmptyExpression(first, Context.OTHER, false);\n             add(\"while(\");\n             add(last);\n             add(\")\");\n             cc.endStatement();\n             break;\n         case Token.WHILE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"while(\");\n             add(first);\n             add(\")\");\n             addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.EMPTY:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             break;\n         case Token.GETPROP:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 2);\n                 Preconditions.checkState(last.getType() \u003d\u003d Token.STRING);\n                 boolean needsParens \u003d (first.getType() \u003d\u003d Token.NUMBER);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 addLeftExpr(first, NodeUtil.precedence(type), context);\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 add(\".\");\n                 addIdentifier(last.getString());\n                 break;\n             }\n         case Token.GETELEM:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             addLeftExpr(first, NodeUtil.precedence(type), context);\n             add(\"[\");\n             add(first.getNext());\n             add(\"]\");\n             break;\n         case Token.WITH:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"with(\");\n             add(first);\n             add(\")\");\n             addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             break;\n         case Token.INC:\n         case Token.DEC:\n             {\n                 Preconditions.checkState(childCount \u003d\u003d 1);\n                 String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                 int postProp \u003d n.getIntProp(Node.INCRDECR_PROP, 0);\n                 if (postProp !\u003d 0) {\n                     addLeftExpr(first, NodeUtil.precedence(type), context);\n                     cc.addOp(o, false);\n                 } else {\n                     cc.addOp(o, false);\n                     add(first);\n                 }\n                 break;\n             }\n         case Token.CALL:\n             addLeftExpr(first, NodeUtil.precedence(type), context);\n             add(\"(\");\n             addList(first.getNext());\n             add(\")\");\n             break;\n         case Token.IF:\n             boolean hasElse \u003d childCount \u003d\u003d 3;\n             boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n             if (ambiguousElseClause) {\n                 cc.beginBlock();\n             }\n             add(\"if(\");\n             add(first);\n             add(\")\");\n             if (hasElse) {\n                 addNonEmptyExpression(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                 add(\"else\");\n                 addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n             } else {\n                 addNonEmptyExpression(first.getNext(), Context.OTHER, false);\n                 Preconditions.checkState(childCount \u003d\u003d 2);\n             }\n             if (ambiguousElseClause) {\n                 cc.endBlock();\n             }\n             break;\n         case Token.NULL:\n         case Token.THIS:\n         case Token.FALSE:\n         case Token.TRUE:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(Node.tokenToName(type));\n             break;\n         case Token.CONTINUE:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"continue\");\n             if (childCount \u003d\u003d 1) {\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.DEBUGGER:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n             add(\"debugger\");\n             cc.endStatement();\n             break;\n         case Token.BREAK:\n             Preconditions.checkState(childCount \u003c\u003d 1);\n             add(\"break\");\n             if (childCount \u003d\u003d 1) {\n                 add(\" \");\n                 add(first);\n             }\n             cc.endStatement();\n             break;\n         case Token.EXPR_VOID:\n         case Token.EXPR_RESULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(first, Context.START_OF_EXPR);\n             cc.endStatement();\n             break;\n         case Token.NEW:\n             add(\"new \");\n             int precedence \u003d NodeUtil.precedence(type);\n             if (NodeUtil.containsCall(first)) {\n                 precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n             }\n             addExpr(first, precedence);\n             Node next \u003d first.getNext();\n             if (next !\u003d null) {\n                 add(\"(\");\n                 addList(next);\n                 add(\")\");\n             }\n             break;\n         case Token.STRING:\n             Preconditions.checkState(childCount \u003d\u003d 0);\n-            add(jsString(n.getString()));\n+            add(jsString(n.getString(), outputCharsetEncoder));\n             break;\n         case Token.DELPROP:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"delete \");\n             add(first);\n             break;\n         case Token.OBJECTLIT:\n             {\n                 Preconditions.checkState(childCount % 2 \u003d\u003d 0);\n                 boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                 if (needsParens) {\n                     add(\"(\");\n                 }\n                 add(\"{\");\n                 for (Node c \u003d first; c !\u003d null; c \u003d c.getNext().getNext()) {\n                     if (c !\u003d first) {\n                         cc.listSeparator();\n                     }\n                     if (c.getType() \u003d\u003d Token.STRING \u0026\u0026 !TokenStream.isKeyword(c.getString()) \u0026\u0026 TokenStream.isJSIdentifier(c.getString()) \u0026\u0026 NodeUtil.isLatin(c.getString())) {\n                         add(c.getString());\n                     } else {\n                         addExpr(c, 1);\n                     }\n                     add(\":\");\n                     addExpr(c.getNext(), 1);\n                 }\n                 add(\"}\");\n                 if (needsParens) {\n                     add(\")\");\n                 }\n                 break;\n             }\n         case Token.SWITCH:\n             add(\"switch(\");\n             add(first);\n             add(\")\");\n             cc.beginBlock();\n             addAllSiblings(first.getNext());\n             cc.endBlock(context \u003d\u003d Context.STATEMENT);\n             break;\n         case Token.CASE:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(\"case \");\n             add(first);\n             addCaseBody(last);\n             break;\n         case Token.DEFAULT:\n             Preconditions.checkState(childCount \u003d\u003d 1);\n             add(\"default\");\n             addCaseBody(first);\n             break;\n         case Token.LABEL:\n             Preconditions.checkState(childCount \u003d\u003d 2);\n             add(first);\n             add(\":\");\n             addNonEmptyExpression(last, getContextForNonEmptyExpression(context), true);\n             break;\n         case Token.SETNAME:\n             break;\n         default:\n             throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n     }\n     cc.endSourceMapping(n);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": {
      "type": "Yintroduced",
      "commitMessage": "Initial commit.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/3/09, 3:51 PM",
      "commitName": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "diff": "@@ -0,0 +1,419 @@\n+void add(Node n, Context context) {\n+    if (!cc.continueProcessing()) {\n+        return;\n+    }\n+    int type \u003d n.getType();\n+    String opstr \u003d NodeUtil.opToStr(type);\n+    int childCount \u003d n.getChildCount();\n+    Node first \u003d n.getFirstChild();\n+    Node last \u003d n.getLastChild();\n+    if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n+        Preconditions.checkState(childCount \u003d\u003d 2);\n+        int p \u003d NodeUtil.precedence(type);\n+        addLeftExpr(first, p, context);\n+        cc.addOp(opstr, true);\n+        Context rhsContext \u003d getContextForNoInOperator(context);\n+        if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n+            addExpr(last, p, rhsContext);\n+        } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n+            addExpr(last, p, rhsContext);\n+        } else {\n+            addExpr(last, p + 1, rhsContext);\n+        }\n+        return;\n+    }\n+    cc.startSourceMapping(n);\n+    switch(type) {\n+        case Token.TRY:\n+            {\n+                Preconditions.checkState(first.getNext().getType() \u003d\u003d Token.BLOCK \u0026\u0026 first.getNext().getChildCount() \u003c\u003d 1);\n+                Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n+                add(\"try\");\n+                add(first, Context.PRESERVE_BLOCK);\n+                Node catchblock \u003d first.getNext().getFirstChild();\n+                if (catchblock !\u003d null) {\n+                    add(catchblock);\n+                }\n+                if (childCount \u003d\u003d 3) {\n+                    add(\"finally\");\n+                    add(last, Context.PRESERVE_BLOCK);\n+                }\n+                break;\n+            }\n+        case Token.CATCH:\n+            Preconditions.checkState(childCount \u003d\u003d 3);\n+            if (first.getNext().getType() !\u003d Token.EMPTY) {\n+                throw new Error(\"Catch conditions not suppored because I think\" + \" that it may be a netscape only feature.\");\n+            }\n+            add(\"catch(\");\n+            add(first);\n+            add(\")\");\n+            add(last, Context.PRESERVE_BLOCK);\n+            break;\n+        case Token.THROW:\n+            Preconditions.checkState(childCount \u003d\u003d 1);\n+            add(\"throw\");\n+            add(first);\n+            cc.endStatement(true);\n+            break;\n+        case Token.RETURN:\n+            add(\"return\");\n+            if (childCount \u003d\u003d 1) {\n+                add(first);\n+            } else {\n+                Preconditions.checkState(childCount \u003d\u003d 0);\n+            }\n+            cc.endStatement();\n+            break;\n+        case Token.VAR:\n+            if (first !\u003d null) {\n+                add(\"var \");\n+                addList(first, false, getContextForNoInOperator(context));\n+            }\n+            break;\n+        case Token.NAME:\n+            if (first \u003d\u003d null || first.getType() \u003d\u003d Token.EMPTY) {\n+                addIdentifier(n.getString());\n+            } else {\n+                Preconditions.checkState(childCount \u003d\u003d 1);\n+                addIdentifier(n.getString());\n+                cc.addOp(\"\u003d\", true);\n+                if (first.getType() \u003d\u003d Token.COMMA) {\n+                    addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n+                } else {\n+                    addExpr(first, 0, getContextForNoInOperator(context));\n+                }\n+            }\n+            break;\n+        case Token.ARRAYLIT:\n+            add(\"[\");\n+            addList(first, (int[]) n.getProp(Node.SKIP_INDEXES_PROP));\n+            add(\"]\");\n+            break;\n+        case Token.LP:\n+            add(\"(\");\n+            addList(first);\n+            add(\")\");\n+            break;\n+        case Token.COMMA:\n+            addList(first, false, context);\n+            break;\n+        case Token.NUMBER:\n+            Preconditions.checkState(childCount \u003d\u003d 0);\n+            cc.addNumber(n.getDouble());\n+            break;\n+        case Token.TYPEOF:\n+        case Token.VOID:\n+        case Token.NOT:\n+        case Token.BITNOT:\n+        case Token.POS:\n+        case Token.NEG:\n+            {\n+                Preconditions.checkState(childCount \u003d\u003d 1);\n+                cc.addOp(NodeUtil.opToStrNoFail(type), false);\n+                addExpr(first, NodeUtil.precedence(type));\n+                break;\n+            }\n+        case Token.HOOK:\n+            {\n+                Preconditions.checkState(childCount \u003d\u003d 3);\n+                int p \u003d NodeUtil.precedence(type);\n+                addLeftExpr(first, p + 1, context);\n+                cc.addOp(\"?\", true);\n+                addExpr(first.getNext(), p);\n+                cc.addOp(\":\", true);\n+                addExpr(last, p);\n+                break;\n+            }\n+        case Token.REGEXP:\n+            if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n+                throw new Error(\"Expected children to be strings\");\n+            }\n+            String regexp \u003d regexpEscape(first.getString());\n+            if (childCount \u003d\u003d 2) {\n+                add(regexp + last.getString());\n+            } else {\n+                Preconditions.checkState(childCount \u003d\u003d 1);\n+                add(regexp);\n+            }\n+            break;\n+        case Token.GET_REF:\n+            add(first);\n+            break;\n+        case Token.REF_SPECIAL:\n+            Preconditions.checkState(childCount \u003d\u003d 1);\n+            add(first);\n+            add(\".\");\n+            add((String) n.getProp(Node.NAME_PROP));\n+            break;\n+        case Token.FUNCTION:\n+            Preconditions.checkState(childCount \u003d\u003d 3);\n+            boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n+            if (funcNeedsParens) {\n+                add(\"(\");\n+            }\n+            add(\"function\");\n+            add(first);\n+            add(first.getNext());\n+            add(last, Context.PRESERVE_BLOCK);\n+            cc.endFunction(context \u003d\u003d Context.STATEMENT);\n+            if (funcNeedsParens) {\n+                add(\")\");\n+            }\n+            break;\n+        case Token.SCRIPT:\n+        case Token.BLOCK:\n+            {\n+                boolean stripBlock \u003d n.isSyntheticBlock() || ((context !\u003d Context.PRESERVE_BLOCK) \u0026\u0026 (n.getChildCount() \u003c 2));\n+                if (!stripBlock) {\n+                    cc.beginBlock();\n+                }\n+                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n+                    add(c, Context.STATEMENT);\n+                    if (c.getType() \u003d\u003d Token.VAR) {\n+                        cc.endStatement();\n+                    }\n+                    if (c.getType() \u003d\u003d Token.FUNCTION) {\n+                        cc.maybeLineBreak();\n+                    }\n+                    if (type \u003d\u003d Token.SCRIPT) {\n+                        cc.notePreferredLineBreak();\n+                    }\n+                }\n+                if (!stripBlock) {\n+                    cc.endBlock(context \u003d\u003d Context.STATEMENT);\n+                }\n+                break;\n+            }\n+        case Token.FOR:\n+            if (childCount \u003d\u003d 4) {\n+                add(\"for(\");\n+                if (first.getType() \u003d\u003d Token.VAR) {\n+                    add(first, Context.IN_FOR_INIT_CLAUSE);\n+                } else {\n+                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n+                }\n+                add(\";\");\n+                add(first.getNext());\n+                add(\";\");\n+                add(first.getNext().getNext());\n+                add(\")\");\n+                addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n+            } else {\n+                Preconditions.checkState(childCount \u003d\u003d 3);\n+                add(\"for(\");\n+                add(first);\n+                add(\"in\");\n+                add(first.getNext());\n+                add(\")\");\n+                addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n+            }\n+            break;\n+        case Token.DO:\n+            Preconditions.checkState(childCount \u003d\u003d 2);\n+            add(\"do\");\n+            addNonEmptyExpression(first, Context.OTHER, false);\n+            add(\"while(\");\n+            add(last);\n+            add(\")\");\n+            cc.endStatement();\n+            break;\n+        case Token.WHILE:\n+            Preconditions.checkState(childCount \u003d\u003d 2);\n+            add(\"while(\");\n+            add(first);\n+            add(\")\");\n+            addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n+            break;\n+        case Token.EMPTY:\n+            Preconditions.checkState(childCount \u003d\u003d 0);\n+            break;\n+        case Token.GETPROP:\n+            {\n+                Preconditions.checkState(childCount \u003d\u003d 2);\n+                Preconditions.checkState(last.getType() \u003d\u003d Token.STRING);\n+                boolean needsParens \u003d (first.getType() \u003d\u003d Token.NUMBER);\n+                if (needsParens) {\n+                    add(\"(\");\n+                }\n+                addLeftExpr(first, NodeUtil.precedence(type), context);\n+                if (needsParens) {\n+                    add(\")\");\n+                }\n+                add(\".\");\n+                addIdentifier(last.getString());\n+                break;\n+            }\n+        case Token.GETELEM:\n+            Preconditions.checkState(childCount \u003d\u003d 2);\n+            addLeftExpr(first, NodeUtil.precedence(type), context);\n+            add(\"[\");\n+            add(first.getNext());\n+            add(\"]\");\n+            break;\n+        case Token.WITH:\n+            Preconditions.checkState(childCount \u003d\u003d 2);\n+            add(\"with(\");\n+            add(first);\n+            add(\")\");\n+            addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n+            break;\n+        case Token.INC:\n+        case Token.DEC:\n+            {\n+                Preconditions.checkState(childCount \u003d\u003d 1);\n+                String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n+                int postProp \u003d n.getIntProp(Node.INCRDECR_PROP, 0);\n+                if (postProp !\u003d 0) {\n+                    addLeftExpr(first, NodeUtil.precedence(type), context);\n+                    cc.addOp(o, false);\n+                } else {\n+                    cc.addOp(o, false);\n+                    add(first);\n+                }\n+                break;\n+            }\n+        case Token.CALL:\n+            addLeftExpr(first, NodeUtil.precedence(type), context);\n+            add(\"(\");\n+            addList(first.getNext());\n+            add(\")\");\n+            break;\n+        case Token.IF:\n+            boolean hasElse \u003d childCount \u003d\u003d 3;\n+            boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n+            if (ambiguousElseClause) {\n+                cc.beginBlock();\n+            }\n+            add(\"if(\");\n+            add(first);\n+            add(\")\");\n+            if (hasElse) {\n+                addNonEmptyExpression(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n+                add(\"else\");\n+                addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n+            } else {\n+                addNonEmptyExpression(first.getNext(), Context.OTHER, false);\n+                Preconditions.checkState(childCount \u003d\u003d 2);\n+            }\n+            if (ambiguousElseClause) {\n+                cc.endBlock();\n+            }\n+            break;\n+        case Token.NULL:\n+        case Token.THIS:\n+        case Token.FALSE:\n+        case Token.TRUE:\n+            Preconditions.checkState(childCount \u003d\u003d 0);\n+            add(Node.tokenToName(type));\n+            break;\n+        case Token.CONTINUE:\n+            Preconditions.checkState(childCount \u003c\u003d 1);\n+            add(\"continue\");\n+            if (childCount \u003d\u003d 1) {\n+                add(\" \");\n+                add(first);\n+            }\n+            cc.endStatement();\n+            break;\n+        case Token.DEBUGGER:\n+            Preconditions.checkState(childCount \u003d\u003d 0);\n+            add(\"debugger\");\n+            cc.endStatement();\n+            break;\n+        case Token.BREAK:\n+            Preconditions.checkState(childCount \u003c\u003d 1);\n+            add(\"break\");\n+            if (childCount \u003d\u003d 1) {\n+                add(\" \");\n+                add(first);\n+            }\n+            cc.endStatement();\n+            break;\n+        case Token.EXPR_VOID:\n+        case Token.EXPR_RESULT:\n+            Preconditions.checkState(childCount \u003d\u003d 1);\n+            add(first, Context.START_OF_EXPR);\n+            cc.endStatement();\n+            break;\n+        case Token.NEW:\n+            add(\"new \");\n+            int precedence \u003d NodeUtil.precedence(type);\n+            if (NodeUtil.containsCall(first)) {\n+                precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n+            }\n+            addExpr(first, precedence);\n+            Node next \u003d first.getNext();\n+            if (next !\u003d null) {\n+                add(\"(\");\n+                addList(next);\n+                add(\")\");\n+            }\n+            break;\n+        case Token.STRING:\n+            Preconditions.checkState(childCount \u003d\u003d 0);\n+            add(jsString(n.getString()));\n+            break;\n+        case Token.DELPROP:\n+            Preconditions.checkState(childCount \u003d\u003d 1);\n+            add(\"delete \");\n+            add(first);\n+            break;\n+        case Token.OBJECTLIT:\n+            {\n+                Preconditions.checkState(childCount % 2 \u003d\u003d 0);\n+                boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n+                if (needsParens) {\n+                    add(\"(\");\n+                }\n+                add(\"{\");\n+                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext().getNext()) {\n+                    if (c !\u003d first) {\n+                        cc.listSeparator();\n+                    }\n+                    if (c.getType() \u003d\u003d Token.STRING \u0026\u0026 !TokenStream.isKeyword(c.getString()) \u0026\u0026 TokenStream.isJSIdentifier(c.getString()) \u0026\u0026 NodeUtil.isLatin(c.getString())) {\n+                        add(c.getString());\n+                    } else {\n+                        addExpr(c, 1);\n+                    }\n+                    add(\":\");\n+                    addExpr(c.getNext(), 1);\n+                }\n+                add(\"}\");\n+                if (needsParens) {\n+                    add(\")\");\n+                }\n+                break;\n+            }\n+        case Token.SWITCH:\n+            add(\"switch(\");\n+            add(first);\n+            add(\")\");\n+            cc.beginBlock();\n+            addAllSiblings(first.getNext());\n+            cc.endBlock(context \u003d\u003d Context.STATEMENT);\n+            break;\n+        case Token.CASE:\n+            Preconditions.checkState(childCount \u003d\u003d 2);\n+            add(\"case \");\n+            add(first);\n+            addCaseBody(last);\n+            break;\n+        case Token.DEFAULT:\n+            Preconditions.checkState(childCount \u003d\u003d 1);\n+            add(\"default\");\n+            addCaseBody(first);\n+            break;\n+        case Token.LABEL:\n+            Preconditions.checkState(childCount \u003d\u003d 2);\n+            add(first);\n+            add(\":\");\n+            addNonEmptyExpression(last, getContextForNonEmptyExpression(context), true);\n+            break;\n+        case Token.SETNAME:\n+            break;\n+        default:\n+            throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n+    }\n+    cc.endSourceMapping(n);\n+}\n\\ No newline at end of file\n",
      "actualSource": "void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n        return;\n    }\n    int type \u003d n.getType();\n    String opstr \u003d NodeUtil.opToStr(type);\n    int childCount \u003d n.getChildCount();\n    Node first \u003d n.getFirstChild();\n    Node last \u003d n.getLastChild();\n    if (opstr !\u003d null \u0026\u0026 first !\u003d last) {\n        Preconditions.checkState(childCount \u003d\u003d 2);\n        int p \u003d NodeUtil.precedence(type);\n        addLeftExpr(first, p, context);\n        cc.addOp(opstr, true);\n        Context rhsContext \u003d getContextForNoInOperator(context);\n        if (last.getType() \u003d\u003d type \u0026\u0026 NodeUtil.isAssociative(type)) {\n            addExpr(last, p, rhsContext);\n        } else if (NodeUtil.isAssignmentOp(n) \u0026\u0026 NodeUtil.isAssignmentOp(last)) {\n            addExpr(last, p, rhsContext);\n        } else {\n            addExpr(last, p + 1, rhsContext);\n        }\n        return;\n    }\n    cc.startSourceMapping(n);\n    switch(type) {\n        case Token.TRY:\n            {\n                Preconditions.checkState(first.getNext().getType() \u003d\u003d Token.BLOCK \u0026\u0026 first.getNext().getChildCount() \u003c\u003d 1);\n                Preconditions.checkState(childCount \u003e\u003d 2 \u0026\u0026 childCount \u003c\u003d 3);\n                add(\"try\");\n                add(first, Context.PRESERVE_BLOCK);\n                Node catchblock \u003d first.getNext().getFirstChild();\n                if (catchblock !\u003d null) {\n                    add(catchblock);\n                }\n                if (childCount \u003d\u003d 3) {\n                    add(\"finally\");\n                    add(last, Context.PRESERVE_BLOCK);\n                }\n                break;\n            }\n        case Token.CATCH:\n            Preconditions.checkState(childCount \u003d\u003d 3);\n            if (first.getNext().getType() !\u003d Token.EMPTY) {\n                throw new Error(\"Catch conditions not suppored because I think\" + \" that it may be a netscape only feature.\");\n            }\n            add(\"catch(\");\n            add(first);\n            add(\")\");\n            add(last, Context.PRESERVE_BLOCK);\n            break;\n        case Token.THROW:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"throw\");\n            add(first);\n            cc.endStatement(true);\n            break;\n        case Token.RETURN:\n            add(\"return\");\n            if (childCount \u003d\u003d 1) {\n                add(first);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 0);\n            }\n            cc.endStatement();\n            break;\n        case Token.VAR:\n            if (first !\u003d null) {\n                add(\"var \");\n                addList(first, false, getContextForNoInOperator(context));\n            }\n            break;\n        case Token.NAME:\n            if (first \u003d\u003d null || first.getType() \u003d\u003d Token.EMPTY) {\n                addIdentifier(n.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                addIdentifier(n.getString());\n                cc.addOp(\"\u003d\", true);\n                if (first.getType() \u003d\u003d Token.COMMA) {\n                    addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n                } else {\n                    addExpr(first, 0, getContextForNoInOperator(context));\n                }\n            }\n            break;\n        case Token.ARRAYLIT:\n            add(\"[\");\n            addList(first, (int[]) n.getProp(Node.SKIP_INDEXES_PROP));\n            add(\"]\");\n            break;\n        case Token.LP:\n            add(\"(\");\n            addList(first);\n            add(\")\");\n            break;\n        case Token.COMMA:\n            addList(first, false, context);\n            break;\n        case Token.NUMBER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            cc.addNumber(n.getDouble());\n            break;\n        case Token.TYPEOF:\n        case Token.VOID:\n        case Token.NOT:\n        case Token.BITNOT:\n        case Token.POS:\n        case Token.NEG:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                addExpr(first, NodeUtil.precedence(type));\n                break;\n            }\n        case Token.HOOK:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                int p \u003d NodeUtil.precedence(type);\n                addLeftExpr(first, p + 1, context);\n                cc.addOp(\"?\", true);\n                addExpr(first.getNext(), p);\n                cc.addOp(\":\", true);\n                addExpr(last, p);\n                break;\n            }\n        case Token.REGEXP:\n            if (first.getType() !\u003d Token.STRING || last.getType() !\u003d Token.STRING) {\n                throw new Error(\"Expected children to be strings\");\n            }\n            String regexp \u003d regexpEscape(first.getString());\n            if (childCount \u003d\u003d 2) {\n                add(regexp + last.getString());\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                add(regexp);\n            }\n            break;\n        case Token.GET_REF:\n            add(first);\n            break;\n        case Token.REF_SPECIAL:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first);\n            add(\".\");\n            add((String) n.getProp(Node.NAME_PROP));\n            break;\n        case Token.FUNCTION:\n            Preconditions.checkState(childCount \u003d\u003d 3);\n            boolean funcNeedsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n            if (funcNeedsParens) {\n                add(\"(\");\n            }\n            add(\"function\");\n            add(first);\n            add(first.getNext());\n            add(last, Context.PRESERVE_BLOCK);\n            cc.endFunction(context \u003d\u003d Context.STATEMENT);\n            if (funcNeedsParens) {\n                add(\")\");\n            }\n            break;\n        case Token.SCRIPT:\n        case Token.BLOCK:\n            {\n                boolean stripBlock \u003d n.isSyntheticBlock() || ((context !\u003d Context.PRESERVE_BLOCK) \u0026\u0026 (n.getChildCount() \u003c 2));\n                if (!stripBlock) {\n                    cc.beginBlock();\n                }\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext()) {\n                    add(c, Context.STATEMENT);\n                    if (c.getType() \u003d\u003d Token.VAR) {\n                        cc.endStatement();\n                    }\n                    if (c.getType() \u003d\u003d Token.FUNCTION) {\n                        cc.maybeLineBreak();\n                    }\n                    if (type \u003d\u003d Token.SCRIPT) {\n                        cc.notePreferredLineBreak();\n                    }\n                }\n                if (!stripBlock) {\n                    cc.endBlock(context \u003d\u003d Context.STATEMENT);\n                }\n                break;\n            }\n        case Token.FOR:\n            if (childCount \u003d\u003d 4) {\n                add(\"for(\");\n                if (first.getType() \u003d\u003d Token.VAR) {\n                    add(first, Context.IN_FOR_INIT_CLAUSE);\n                } else {\n                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                }\n                add(\";\");\n                add(first.getNext());\n                add(\";\");\n                add(first.getNext().getNext());\n                add(\")\");\n                addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                Preconditions.checkState(childCount \u003d\u003d 3);\n                add(\"for(\");\n                add(first);\n                add(\"in\");\n                add(first.getNext());\n                add(\")\");\n                addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            }\n            break;\n        case Token.DO:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"do\");\n            addNonEmptyExpression(first, Context.OTHER, false);\n            add(\"while(\");\n            add(last);\n            add(\")\");\n            cc.endStatement();\n            break;\n        case Token.WHILE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"while(\");\n            add(first);\n            add(\")\");\n            addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.EMPTY:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            break;\n        case Token.GETPROP:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 2);\n                Preconditions.checkState(last.getType() \u003d\u003d Token.STRING);\n                boolean needsParens \u003d (first.getType() \u003d\u003d Token.NUMBER);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                addLeftExpr(first, NodeUtil.precedence(type), context);\n                if (needsParens) {\n                    add(\")\");\n                }\n                add(\".\");\n                addIdentifier(last.getString());\n                break;\n            }\n        case Token.GETELEM:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            addLeftExpr(first, NodeUtil.precedence(type), context);\n            add(\"[\");\n            add(first.getNext());\n            add(\"]\");\n            break;\n        case Token.WITH:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"with(\");\n            add(first);\n            add(\")\");\n            addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            break;\n        case Token.INC:\n        case Token.DEC:\n            {\n                Preconditions.checkState(childCount \u003d\u003d 1);\n                String o \u003d type \u003d\u003d Token.INC ? \"++\" : \"--\";\n                int postProp \u003d n.getIntProp(Node.INCRDECR_PROP, 0);\n                if (postProp !\u003d 0) {\n                    addLeftExpr(first, NodeUtil.precedence(type), context);\n                    cc.addOp(o, false);\n                } else {\n                    cc.addOp(o, false);\n                    add(first);\n                }\n                break;\n            }\n        case Token.CALL:\n            addLeftExpr(first, NodeUtil.precedence(type), context);\n            add(\"(\");\n            addList(first.getNext());\n            add(\")\");\n            break;\n        case Token.IF:\n            boolean hasElse \u003d childCount \u003d\u003d 3;\n            boolean ambiguousElseClause \u003d context \u003d\u003d Context.BEFORE_DANGLING_ELSE \u0026\u0026 !hasElse;\n            if (ambiguousElseClause) {\n                cc.beginBlock();\n            }\n            add(\"if(\");\n            add(first);\n            add(\")\");\n            if (hasElse) {\n                addNonEmptyExpression(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                add(\"else\");\n                addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false);\n            } else {\n                addNonEmptyExpression(first.getNext(), Context.OTHER, false);\n                Preconditions.checkState(childCount \u003d\u003d 2);\n            }\n            if (ambiguousElseClause) {\n                cc.endBlock();\n            }\n            break;\n        case Token.NULL:\n        case Token.THIS:\n        case Token.FALSE:\n        case Token.TRUE:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(Node.tokenToName(type));\n            break;\n        case Token.CONTINUE:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"continue\");\n            if (childCount \u003d\u003d 1) {\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.DEBUGGER:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(\"debugger\");\n            cc.endStatement();\n            break;\n        case Token.BREAK:\n            Preconditions.checkState(childCount \u003c\u003d 1);\n            add(\"break\");\n            if (childCount \u003d\u003d 1) {\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n        case Token.EXPR_VOID:\n        case Token.EXPR_RESULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(first, Context.START_OF_EXPR);\n            cc.endStatement();\n            break;\n        case Token.NEW:\n            add(\"new \");\n            int precedence \u003d NodeUtil.precedence(type);\n            if (NodeUtil.containsCall(first)) {\n                precedence \u003d NodeUtil.precedence(first.getType()) + 1;\n            }\n            addExpr(first, precedence);\n            Node next \u003d first.getNext();\n            if (next !\u003d null) {\n                add(\"(\");\n                addList(next);\n                add(\")\");\n            }\n            break;\n        case Token.STRING:\n            Preconditions.checkState(childCount \u003d\u003d 0);\n            add(jsString(n.getString()));\n            break;\n        case Token.DELPROP:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"delete \");\n            add(first);\n            break;\n        case Token.OBJECTLIT:\n            {\n                Preconditions.checkState(childCount % 2 \u003d\u003d 0);\n                boolean needsParens \u003d (context \u003d\u003d Context.START_OF_EXPR);\n                if (needsParens) {\n                    add(\"(\");\n                }\n                add(\"{\");\n                for (Node c \u003d first; c !\u003d null; c \u003d c.getNext().getNext()) {\n                    if (c !\u003d first) {\n                        cc.listSeparator();\n                    }\n                    if (c.getType() \u003d\u003d Token.STRING \u0026\u0026 !TokenStream.isKeyword(c.getString()) \u0026\u0026 TokenStream.isJSIdentifier(c.getString()) \u0026\u0026 NodeUtil.isLatin(c.getString())) {\n                        add(c.getString());\n                    } else {\n                        addExpr(c, 1);\n                    }\n                    add(\":\");\n                    addExpr(c.getNext(), 1);\n                }\n                add(\"}\");\n                if (needsParens) {\n                    add(\")\");\n                }\n                break;\n            }\n        case Token.SWITCH:\n            add(\"switch(\");\n            add(first);\n            add(\")\");\n            cc.beginBlock();\n            addAllSiblings(first.getNext());\n            cc.endBlock(context \u003d\u003d Context.STATEMENT);\n            break;\n        case Token.CASE:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(\"case \");\n            add(first);\n            addCaseBody(last);\n            break;\n        case Token.DEFAULT:\n            Preconditions.checkState(childCount \u003d\u003d 1);\n            add(\"default\");\n            addCaseBody(first);\n            break;\n        case Token.LABEL:\n            Preconditions.checkState(childCount \u003d\u003d 2);\n            add(first);\n            add(\":\");\n            addNonEmptyExpression(last, getContextForNonEmptyExpression(context), true);\n            break;\n        case Token.SETNAME:\n            break;\n        default:\n            throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n    cc.endSourceMapping(n);\n}",
      "path": "src/com/google/javascript/jscomp/CodeGenerator.java",
      "functionStartLine": 53,
      "functionName": "add",
      "functionAnnotation": "",
      "functionDoc": ""
    }
  }
}