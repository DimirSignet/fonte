{
  "origin": "codeshovel",
  "repositoryName": "Closure-74b",
  "repositoryPath": "/tmp/Closure-74b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "PrepareAst.java",
  "functionName": "visit",
  "functionId": "$visit___t-NodeTraversal__n-Node__parent-Node",
  "sourceFilePath": "src/com/google/javascript/jscomp/PrepareAst.java",
  "functionAnnotation": "@Override",
  "functionDoc": "",
  "functionStartLine": 149,
  "functionEndLine": 160,
  "numCommitsSeen": 14,
  "timeTaken": 1155,
  "changeHistory": [
    "24b7eb9a4a8850f2d0988eb81245b4b9a977d53a",
    "f93cdf97ea803c4702023daf1326dc45172de611",
    "d7e85b0997ebb3d920c977de7a4a3f8ede5ba2d8",
    "e829dafb9b3365bda6b6bb80f5fa97783752d143",
    "9a1ddf5f982e54ecbc3e028dfa84ef9bd07a8044",
    "8ba5e1f86eaf3c31b9279f92823b4fa2a50574a3",
    "6a36f04485599820ff86441accee002b4deec2eb",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3"
  ],
  "changeHistoryShort": {
    "24b7eb9a4a8850f2d0988eb81245b4b9a977d53a": "Ymultichange(Ybodychange,Yannotationchange)",
    "f93cdf97ea803c4702023daf1326dc45172de611": "Ybodychange",
    "d7e85b0997ebb3d920c977de7a4a3f8ede5ba2d8": "Ymultichange(Ybodychange,Yannotationchange,Ydocchange)",
    "e829dafb9b3365bda6b6bb80f5fa97783752d143": "Ymultichange(Ybodychange,Yannotationchange)",
    "9a1ddf5f982e54ecbc3e028dfa84ef9bd07a8044": "Ymultichange(Ymovefromfile,Ybodychange,Yannotationchange,Ydocchange)",
    "8ba5e1f86eaf3c31b9279f92823b4fa2a50574a3": "Ybodychange",
    "6a36f04485599820ff86441accee002b4deec2eb": "Ybodychange",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "24b7eb9a4a8850f2d0988eb81245b4b9a977d53a": {
      "type": "Ymultichange(Ybodychange,Yannotationchange)",
      "commitMessage": "\nClean up constant annotations so that all constant annotations\nare added during the normalize() phase.\nThis was really confusing to me, because certain kinds\nof constant annotations would work pre-normalize, and certain kinds\nwould work post-normalize.\n\nR\u003djohnlenz\nDELTA\u003d204  (114 added, 75 deleted, 15 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d1188239\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@551 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/12/10, 2:28 PM",
      "commitName": "24b7eb9a4a8850f2d0988eb81245b4b9a977d53a",
      "commitAuthor": "nicksantos@google.com",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "\nClean up constant annotations so that all constant annotations\nare added during the normalize() phase.\nThis was really confusing to me, because certain kinds\nof constant annotations would work pre-normalize, and certain kinds\nwould work post-normalize.\n\nR\u003djohnlenz\nDELTA\u003d204  (114 added, 75 deleted, 15 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d1188239\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@551 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "11/12/10, 2:28 PM",
          "commitName": "24b7eb9a4a8850f2d0988eb81245b4b9a977d53a",
          "commitAuthor": "nicksantos@google.com",
          "commitDateOld": "11/11/10, 9:42 PM",
          "commitNameOld": "df223efd38c514d584f00d076488ab9a02011492",
          "commitAuthorOld": "nicksantos@google.com",
          "daysBetweenCommits": 0.7,
          "commitsBetweenForRepo": 7,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.CALL:\n            annotateCalls(n);\n            break;\n        case Token.FUNCTION:\n            annotateFunctions(n, parent);\n            annotateDispatchers(n, parent);\n            break;\n    }\n}",
          "path": "src/com/google/javascript/jscomp/PrepareAst.java",
          "functionStartLine": 149,
          "functionName": "visit",
          "functionAnnotation": "@Override",
          "functionDoc": "",
          "diff": "@@ -1,18 +1,12 @@\n+@Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n     switch(n.getType()) {\n         case Token.CALL:\n             annotateCalls(n);\n             break;\n         case Token.FUNCTION:\n             annotateFunctions(n, parent);\n             annotateDispatchers(n, parent);\n             break;\n-        case Token.NAME:\n-        case Token.STRING:\n-            annotateConstants(n, parent);\n-            break;\n-        case Token.OBJECTLIT:\n-            visitObjectLiteral(n);\n-            break;\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Yannotationchange",
          "commitMessage": "\nClean up constant annotations so that all constant annotations\nare added during the normalize() phase.\nThis was really confusing to me, because certain kinds\nof constant annotations would work pre-normalize, and certain kinds\nwould work post-normalize.\n\nR\u003djohnlenz\nDELTA\u003d204  (114 added, 75 deleted, 15 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d1188239\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@551 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "11/12/10, 2:28 PM",
          "commitName": "24b7eb9a4a8850f2d0988eb81245b4b9a977d53a",
          "commitAuthor": "nicksantos@google.com",
          "commitDateOld": "11/11/10, 9:42 PM",
          "commitNameOld": "df223efd38c514d584f00d076488ab9a02011492",
          "commitAuthorOld": "nicksantos@google.com",
          "daysBetweenCommits": 0.7,
          "commitsBetweenForRepo": 7,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.CALL:\n            annotateCalls(n);\n            break;\n        case Token.FUNCTION:\n            annotateFunctions(n, parent);\n            annotateDispatchers(n, parent);\n            break;\n    }\n}",
          "path": "src/com/google/javascript/jscomp/PrepareAst.java",
          "functionStartLine": 149,
          "functionName": "visit",
          "functionAnnotation": "@Override",
          "functionDoc": "",
          "diff": "@@ -1,18 +1,12 @@\n+@Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n     switch(n.getType()) {\n         case Token.CALL:\n             annotateCalls(n);\n             break;\n         case Token.FUNCTION:\n             annotateFunctions(n, parent);\n             annotateDispatchers(n, parent);\n             break;\n-        case Token.NAME:\n-        case Token.STRING:\n-            annotateConstants(n, parent);\n-            break;\n-        case Token.OBJECTLIT:\n-            visitObjectLiteral(n);\n-            break;\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "",
            "newValue": "@Override"
          }
        }
      ]
    },
    "f93cdf97ea803c4702023daf1326dc45172de611": {
      "type": "Ybodychange",
      "commitMessage": "\nMinor parse time performance improvement (profiling was showing ~500ms\nspent traversing the obj lit keys).  This changes the order from\nO(keys^2) to O(keys).\n\nR\u003dnicksantos\nDELTA\u003d47  (29 added, 5 deleted, 13 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d216974\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@428 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "9/14/10, 4:04 PM",
      "commitName": "f93cdf97ea803c4702023daf1326dc45172de611",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "8/5/10, 7:31 PM",
      "commitNameOld": "52547e61d187e102f21e5545c24e8d232fefe92f",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 39.86,
      "commitsBetweenForRepo": 83,
      "commitsBetweenForFile": 1,
      "actualSource": "public void visit(NodeTraversal t, Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.CALL:\n            annotateCalls(n);\n            break;\n        case Token.FUNCTION:\n            annotateFunctions(n, parent);\n            annotateDispatchers(n, parent);\n            break;\n        case Token.NAME:\n        case Token.STRING:\n            annotateConstants(n, parent);\n            break;\n        case Token.OBJECTLIT:\n            visitObjectLiteral(n);\n            break;\n    }\n}",
      "path": "src/com/google/javascript/jscomp/PrepareAst.java",
      "functionStartLine": 140,
      "functionName": "visit",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,18 +1,18 @@\n public void visit(NodeTraversal t, Node n, Node parent) {\n     switch(n.getType()) {\n         case Token.CALL:\n             annotateCalls(n);\n             break;\n         case Token.FUNCTION:\n             annotateFunctions(n, parent);\n             annotateDispatchers(n, parent);\n             break;\n         case Token.NAME:\n         case Token.STRING:\n             annotateConstants(n, parent);\n             break;\n         case Token.OBJECTLIT:\n-            normalizeObjectLitJsDocs(n);\n+            visitObjectLiteral(n);\n             break;\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d7e85b0997ebb3d920c977de7a4a3f8ede5ba2d8": {
      "type": "Ymultichange(Ybodychange,Yannotationchange,Ydocchange)",
      "commitMessage": "\nAdd basic \"free call\" annotation and support for issue 180.  Additional\ntesting is required to validate that new CALL nodes are not\ninappropriately introduced.\n\nAlso, refactored PrepareAst to make the different actions being taken\neasier to follow.\n\nR\u003dnicksantos\nDELTA\u003d215  (120 added, 18 deleted, 77 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d52003\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@282 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "7/15/10, 2:34 PM",
      "commitName": "d7e85b0997ebb3d920c977de7a4a3f8ede5ba2d8",
      "commitAuthor": "johnlenz@google.com",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "\nAdd basic \"free call\" annotation and support for issue 180.  Additional\ntesting is required to validate that new CALL nodes are not\ninappropriately introduced.\n\nAlso, refactored PrepareAst to make the different actions being taken\neasier to follow.\n\nR\u003dnicksantos\nDELTA\u003d215  (120 added, 18 deleted, 77 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d52003\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@282 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "7/15/10, 2:34 PM",
          "commitName": "d7e85b0997ebb3d920c977de7a4a3f8ede5ba2d8",
          "commitAuthor": "johnlenz@google.com",
          "commitDateOld": "6/18/10, 5:18 PM",
          "commitNameOld": "e829dafb9b3365bda6b6bb80f5fa97783752d143",
          "commitAuthorOld": "Nicholas.J.Santos",
          "daysBetweenCommits": 26.89,
          "commitsBetweenForRepo": 36,
          "commitsBetweenForFile": 1,
          "actualSource": "public void visit(NodeTraversal t, Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.CALL:\n            annotateCalls(n);\n            break;\n        case Token.FUNCTION:\n            annotateFunctions(n, parent);\n            annotateDispatchers(n, parent);\n            break;\n        case Token.NAME:\n        case Token.STRING:\n            annotateConstants(n, parent);\n            break;\n        case Token.OBJECTLIT:\n            normalizeObjectLitJsDocs(n);\n            break;\n    }\n}",
          "path": "src/com/google/javascript/jscomp/PrepareAst.java",
          "functionStartLine": 140,
          "functionName": "visit",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,57 +1,18 @@\n-@SuppressWarnings(\"fallthrough\")\n public void visit(NodeTraversal t, Node n, Node parent) {\n-    int nType \u003d n.getType();\n-    switch(nType) {\n-        case Token.STRING:\n-            if (parent.getType() !\u003d Token.OBJECTLIT \u0026\u0026 parent.getType() !\u003d Token.GETPROP) {\n-                break;\n-            }\n-        case Token.NAME:\n-            String nString \u003d n.getString();\n-            if (nType \u003d\u003d Token.NAME \u0026\u0026 n.getParent().getType() \u003d\u003d Token.CALL \u0026\u0026 \"eval\".equals(nString)) {\n-                n.putBooleanProp(Node.DIRECT_EVAL, true);\n-            }\n-            if (NodeUtil.isConstantByConvention(convention, n, parent)) {\n-                n.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n-            }\n+    switch(n.getType()) {\n+        case Token.CALL:\n+            annotateCalls(n);\n             break;\n         case Token.FUNCTION:\n-            JSDocInfo fnInfo \u003d n.getJSDocInfo();\n-            if (fnInfo \u003d\u003d null) {\n-                if (parent.getType() \u003d\u003d Token.ASSIGN) {\n-                    fnInfo \u003d parent.getJSDocInfo();\n-                } else if (parent.getType() \u003d\u003d Token.NAME) {\n-                    fnInfo \u003d parent.getParent().getJSDocInfo();\n-                }\n-            }\n-            Node args \u003d n.getFirstChild().getNext();\n-            for (Node arg \u003d args.getFirstChild(); arg !\u003d null; arg \u003d arg.getNext()) {\n-                String argName \u003d arg.getString();\n-                JSTypeExpression typeExpr \u003d fnInfo \u003d\u003d null ? null : fnInfo.getParameterType(argName);\n-                if (convention.isOptionalParameter(arg) || typeExpr !\u003d null \u0026\u0026 typeExpr.isOptionalArg()) {\n-                    arg.putBooleanProp(Node.IS_OPTIONAL_PARAM, true);\n-                }\n-                if (convention.isVarArgsParameter(arg) || typeExpr !\u003d null \u0026\u0026 typeExpr.isVarArgs()) {\n-                    arg.putBooleanProp(Node.IS_VAR_ARGS_PARAM, true);\n-                }\n-            }\n+            annotateFunctions(n, parent);\n+            annotateDispatchers(n, parent);\n+            break;\n+        case Token.NAME:\n+        case Token.STRING:\n+            annotateConstants(n, parent);\n             break;\n         case Token.OBJECTLIT:\n-            if (n.getType() \u003d\u003d Token.OBJECTLIT) {\n-                for (Node key \u003d n.getFirstChild(); key !\u003d null; key \u003d key.getNext().getNext()) {\n-                    Node value \u003d key.getNext();\n-                    if (key.getJSDocInfo() !\u003d null \u0026\u0026 key.getNext().getType() \u003d\u003d Token.FUNCTION) {\n-                        value.setJSDocInfo(key.getJSDocInfo());\n-                    }\n-                }\n-            }\n+            normalizeObjectLitJsDocs(n);\n             break;\n     }\n-    if (n.getJSDocInfo() !\u003d null \u0026\u0026 n.getJSDocInfo().isJavaDispatch()) {\n-        if (n.getType() \u003d\u003d Token.ASSIGN) {\n-            Node fnNode \u003d n.getLastChild();\n-            Preconditions.checkState(fnNode.getType() \u003d\u003d Token.FUNCTION);\n-            fnNode.putBooleanProp(Node.IS_DISPATCHER, true);\n-        }\n-    }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Yannotationchange",
          "commitMessage": "\nAdd basic \"free call\" annotation and support for issue 180.  Additional\ntesting is required to validate that new CALL nodes are not\ninappropriately introduced.\n\nAlso, refactored PrepareAst to make the different actions being taken\neasier to follow.\n\nR\u003dnicksantos\nDELTA\u003d215  (120 added, 18 deleted, 77 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d52003\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@282 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "7/15/10, 2:34 PM",
          "commitName": "d7e85b0997ebb3d920c977de7a4a3f8ede5ba2d8",
          "commitAuthor": "johnlenz@google.com",
          "commitDateOld": "6/18/10, 5:18 PM",
          "commitNameOld": "e829dafb9b3365bda6b6bb80f5fa97783752d143",
          "commitAuthorOld": "Nicholas.J.Santos",
          "daysBetweenCommits": 26.89,
          "commitsBetweenForRepo": 36,
          "commitsBetweenForFile": 1,
          "actualSource": "public void visit(NodeTraversal t, Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.CALL:\n            annotateCalls(n);\n            break;\n        case Token.FUNCTION:\n            annotateFunctions(n, parent);\n            annotateDispatchers(n, parent);\n            break;\n        case Token.NAME:\n        case Token.STRING:\n            annotateConstants(n, parent);\n            break;\n        case Token.OBJECTLIT:\n            normalizeObjectLitJsDocs(n);\n            break;\n    }\n}",
          "path": "src/com/google/javascript/jscomp/PrepareAst.java",
          "functionStartLine": 140,
          "functionName": "visit",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,57 +1,18 @@\n-@SuppressWarnings(\"fallthrough\")\n public void visit(NodeTraversal t, Node n, Node parent) {\n-    int nType \u003d n.getType();\n-    switch(nType) {\n-        case Token.STRING:\n-            if (parent.getType() !\u003d Token.OBJECTLIT \u0026\u0026 parent.getType() !\u003d Token.GETPROP) {\n-                break;\n-            }\n-        case Token.NAME:\n-            String nString \u003d n.getString();\n-            if (nType \u003d\u003d Token.NAME \u0026\u0026 n.getParent().getType() \u003d\u003d Token.CALL \u0026\u0026 \"eval\".equals(nString)) {\n-                n.putBooleanProp(Node.DIRECT_EVAL, true);\n-            }\n-            if (NodeUtil.isConstantByConvention(convention, n, parent)) {\n-                n.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n-            }\n+    switch(n.getType()) {\n+        case Token.CALL:\n+            annotateCalls(n);\n             break;\n         case Token.FUNCTION:\n-            JSDocInfo fnInfo \u003d n.getJSDocInfo();\n-            if (fnInfo \u003d\u003d null) {\n-                if (parent.getType() \u003d\u003d Token.ASSIGN) {\n-                    fnInfo \u003d parent.getJSDocInfo();\n-                } else if (parent.getType() \u003d\u003d Token.NAME) {\n-                    fnInfo \u003d parent.getParent().getJSDocInfo();\n-                }\n-            }\n-            Node args \u003d n.getFirstChild().getNext();\n-            for (Node arg \u003d args.getFirstChild(); arg !\u003d null; arg \u003d arg.getNext()) {\n-                String argName \u003d arg.getString();\n-                JSTypeExpression typeExpr \u003d fnInfo \u003d\u003d null ? null : fnInfo.getParameterType(argName);\n-                if (convention.isOptionalParameter(arg) || typeExpr !\u003d null \u0026\u0026 typeExpr.isOptionalArg()) {\n-                    arg.putBooleanProp(Node.IS_OPTIONAL_PARAM, true);\n-                }\n-                if (convention.isVarArgsParameter(arg) || typeExpr !\u003d null \u0026\u0026 typeExpr.isVarArgs()) {\n-                    arg.putBooleanProp(Node.IS_VAR_ARGS_PARAM, true);\n-                }\n-            }\n+            annotateFunctions(n, parent);\n+            annotateDispatchers(n, parent);\n+            break;\n+        case Token.NAME:\n+        case Token.STRING:\n+            annotateConstants(n, parent);\n             break;\n         case Token.OBJECTLIT:\n-            if (n.getType() \u003d\u003d Token.OBJECTLIT) {\n-                for (Node key \u003d n.getFirstChild(); key !\u003d null; key \u003d key.getNext().getNext()) {\n-                    Node value \u003d key.getNext();\n-                    if (key.getJSDocInfo() !\u003d null \u0026\u0026 key.getNext().getType() \u003d\u003d Token.FUNCTION) {\n-                        value.setJSDocInfo(key.getJSDocInfo());\n-                    }\n-                }\n-            }\n+            normalizeObjectLitJsDocs(n);\n             break;\n     }\n-    if (n.getJSDocInfo() !\u003d null \u0026\u0026 n.getJSDocInfo().isJavaDispatch()) {\n-        if (n.getType() \u003d\u003d Token.ASSIGN) {\n-            Node fnNode \u003d n.getLastChild();\n-            Preconditions.checkState(fnNode.getType() \u003d\u003d Token.FUNCTION);\n-            fnNode.putBooleanProp(Node.IS_DISPATCHER, true);\n-        }\n-    }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "@SuppressWarnings(\"fallthrough\")",
            "newValue": ""
          }
        },
        {
          "type": "Ydocchange",
          "commitMessage": "\nAdd basic \"free call\" annotation and support for issue 180.  Additional\ntesting is required to validate that new CALL nodes are not\ninappropriately introduced.\n\nAlso, refactored PrepareAst to make the different actions being taken\neasier to follow.\n\nR\u003dnicksantos\nDELTA\u003d215  (120 added, 18 deleted, 77 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d52003\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@282 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "7/15/10, 2:34 PM",
          "commitName": "d7e85b0997ebb3d920c977de7a4a3f8ede5ba2d8",
          "commitAuthor": "johnlenz@google.com",
          "commitDateOld": "6/18/10, 5:18 PM",
          "commitNameOld": "e829dafb9b3365bda6b6bb80f5fa97783752d143",
          "commitAuthorOld": "Nicholas.J.Santos",
          "daysBetweenCommits": 26.89,
          "commitsBetweenForRepo": 36,
          "commitsBetweenForFile": 1,
          "actualSource": "public void visit(NodeTraversal t, Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.CALL:\n            annotateCalls(n);\n            break;\n        case Token.FUNCTION:\n            annotateFunctions(n, parent);\n            annotateDispatchers(n, parent);\n            break;\n        case Token.NAME:\n        case Token.STRING:\n            annotateConstants(n, parent);\n            break;\n        case Token.OBJECTLIT:\n            normalizeObjectLitJsDocs(n);\n            break;\n    }\n}",
          "path": "src/com/google/javascript/jscomp/PrepareAst.java",
          "functionStartLine": 140,
          "functionName": "visit",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,57 +1,18 @@\n-@SuppressWarnings(\"fallthrough\")\n public void visit(NodeTraversal t, Node n, Node parent) {\n-    int nType \u003d n.getType();\n-    switch(nType) {\n-        case Token.STRING:\n-            if (parent.getType() !\u003d Token.OBJECTLIT \u0026\u0026 parent.getType() !\u003d Token.GETPROP) {\n-                break;\n-            }\n-        case Token.NAME:\n-            String nString \u003d n.getString();\n-            if (nType \u003d\u003d Token.NAME \u0026\u0026 n.getParent().getType() \u003d\u003d Token.CALL \u0026\u0026 \"eval\".equals(nString)) {\n-                n.putBooleanProp(Node.DIRECT_EVAL, true);\n-            }\n-            if (NodeUtil.isConstantByConvention(convention, n, parent)) {\n-                n.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n-            }\n+    switch(n.getType()) {\n+        case Token.CALL:\n+            annotateCalls(n);\n             break;\n         case Token.FUNCTION:\n-            JSDocInfo fnInfo \u003d n.getJSDocInfo();\n-            if (fnInfo \u003d\u003d null) {\n-                if (parent.getType() \u003d\u003d Token.ASSIGN) {\n-                    fnInfo \u003d parent.getJSDocInfo();\n-                } else if (parent.getType() \u003d\u003d Token.NAME) {\n-                    fnInfo \u003d parent.getParent().getJSDocInfo();\n-                }\n-            }\n-            Node args \u003d n.getFirstChild().getNext();\n-            for (Node arg \u003d args.getFirstChild(); arg !\u003d null; arg \u003d arg.getNext()) {\n-                String argName \u003d arg.getString();\n-                JSTypeExpression typeExpr \u003d fnInfo \u003d\u003d null ? null : fnInfo.getParameterType(argName);\n-                if (convention.isOptionalParameter(arg) || typeExpr !\u003d null \u0026\u0026 typeExpr.isOptionalArg()) {\n-                    arg.putBooleanProp(Node.IS_OPTIONAL_PARAM, true);\n-                }\n-                if (convention.isVarArgsParameter(arg) || typeExpr !\u003d null \u0026\u0026 typeExpr.isVarArgs()) {\n-                    arg.putBooleanProp(Node.IS_VAR_ARGS_PARAM, true);\n-                }\n-            }\n+            annotateFunctions(n, parent);\n+            annotateDispatchers(n, parent);\n+            break;\n+        case Token.NAME:\n+        case Token.STRING:\n+            annotateConstants(n, parent);\n             break;\n         case Token.OBJECTLIT:\n-            if (n.getType() \u003d\u003d Token.OBJECTLIT) {\n-                for (Node key \u003d n.getFirstChild(); key !\u003d null; key \u003d key.getNext().getNext()) {\n-                    Node value \u003d key.getNext();\n-                    if (key.getJSDocInfo() !\u003d null \u0026\u0026 key.getNext().getType() \u003d\u003d Token.FUNCTION) {\n-                        value.setJSDocInfo(key.getJSDocInfo());\n-                    }\n-                }\n-            }\n+            normalizeObjectLitJsDocs(n);\n             break;\n     }\n-    if (n.getJSDocInfo() !\u003d null \u0026\u0026 n.getJSDocInfo().isJavaDispatch()) {\n-        if (n.getType() \u003d\u003d Token.ASSIGN) {\n-            Node fnNode \u003d n.getLastChild();\n-            Preconditions.checkState(fnNode.getType() \u003d\u003d Token.FUNCTION);\n-            fnNode.putBooleanProp(Node.IS_DISPATCHER, true);\n-        }\n-    }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "In the AST that Rhino gives us, it needs to make a distinction\nbetween jsdoc on the object literal node and jsdoc on the object literal\nvalue. For example,\n\u003cpre\u003e\nvar x \u003d {\n  / JSDOC /\n  a: \u0027b\u0027,\n  c: / JSDOC / \u0027d\u0027\n};\n\u003c/pre\u003e\n\nBut in few narrow cases (in particular, function literals), it\u0027s\na lot easier for us if the doc is attached to the value.\n",
            "newValue": ""
          }
        }
      ]
    },
    "e829dafb9b3365bda6b6bb80f5fa97783752d143": {
      "type": "Ymultichange(Ybodychange,Yannotationchange)",
      "commitMessage": "\nChange on 2010/06/17 by nicksantos\n\n        don\u0027t use Sets to build union types.\n\n        R\u003djohnlenz\n        DELTA\u003d76  (52 added, 6 deleted, 18 changed)\n\nChange on 2010/06/17 by nicksantos\n\n        fix a couple bugs in goog.scope processing\n\n        R\u003drobbyw\n        DELTA\u003d54  (42 added, 11 deleted, 1 changed)\n\n\nChange on 2010/06/17 by acleung\n\n        Disables function argument check with @notypecheck is on for the whole file.\n\n        R\u003djohnlenz\n        DELTA\u003d8  (5 added, 1 deleted, 2 changed)\n\nChange on 2010/06/17 by dcc\n\n        Fix NPE in ExportExternsPass with --check_types\u003dfalse.\n\n        R\u003dacleung\n        DELTA\u003d72  (66 added, 4 deleted, 2 changed)\n\nChange on 2010/06/17 by johnlenz\n\n        Change stub method parameters to allow sanity checks to pass with\n        CrossModuleMethodMotion.\n\n        R\u003dnicksantos\n        DELTA\u003d7  (3 added, 0 deleted, 4 changed)\n\nChange on 2010/06/18 by johnlenz\n\n        Modify AliasKeywords so passes the sanity checks: don\u0027t create coding\n        convention constants without annotation them so that the tests pass\n        when the sanity checks are on.\n\n        R\u003dnicksantos\n        DELTA\u003d18  (5 added, 0 deleted, 13 changed)\n\nChange on 2010/06/18 by johnlenz\n\n        Fix source maps when run with sanity checks.\n\n        R\u003dnicksantos\n        DELTA\u003d10  (7 added, 0 deleted, 3 changed)\n\nChange on 2010/06/18 by johnlenz\n\n        Changes to PrepareAst to make it valid to run during SanityChecks.\n\n        R\u003dnicksantos\n        DELTA\u003d18  (5 added, 0 deleted, 13 changed)\n\nChange on 2010/06/18 by nicksantos\n\n        fix constant annotations in CollapseProperties.\n\n        R\u003djohnlenz\n        DELTA\u003d61  (49 added, 1 deleted, 11 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d30002\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@246 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "6/18/10, 5:18 PM",
      "commitName": "e829dafb9b3365bda6b6bb80f5fa97783752d143",
      "commitAuthor": "Nicholas.J.Santos",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "\nChange on 2010/06/17 by nicksantos\n\n        don\u0027t use Sets to build union types.\n\n        R\u003djohnlenz\n        DELTA\u003d76  (52 added, 6 deleted, 18 changed)\n\nChange on 2010/06/17 by nicksantos\n\n        fix a couple bugs in goog.scope processing\n\n        R\u003drobbyw\n        DELTA\u003d54  (42 added, 11 deleted, 1 changed)\n\n\nChange on 2010/06/17 by acleung\n\n        Disables function argument check with @notypecheck is on for the whole file.\n\n        R\u003djohnlenz\n        DELTA\u003d8  (5 added, 1 deleted, 2 changed)\n\nChange on 2010/06/17 by dcc\n\n        Fix NPE in ExportExternsPass with --check_types\u003dfalse.\n\n        R\u003dacleung\n        DELTA\u003d72  (66 added, 4 deleted, 2 changed)\n\nChange on 2010/06/17 by johnlenz\n\n        Change stub method parameters to allow sanity checks to pass with\n        CrossModuleMethodMotion.\n\n        R\u003dnicksantos\n        DELTA\u003d7  (3 added, 0 deleted, 4 changed)\n\nChange on 2010/06/18 by johnlenz\n\n        Modify AliasKeywords so passes the sanity checks: don\u0027t create coding\n        convention constants without annotation them so that the tests pass\n        when the sanity checks are on.\n\n        R\u003dnicksantos\n        DELTA\u003d18  (5 added, 0 deleted, 13 changed)\n\nChange on 2010/06/18 by johnlenz\n\n        Fix source maps when run with sanity checks.\n\n        R\u003dnicksantos\n        DELTA\u003d10  (7 added, 0 deleted, 3 changed)\n\nChange on 2010/06/18 by johnlenz\n\n        Changes to PrepareAst to make it valid to run during SanityChecks.\n\n        R\u003dnicksantos\n        DELTA\u003d18  (5 added, 0 deleted, 13 changed)\n\nChange on 2010/06/18 by nicksantos\n\n        fix constant annotations in CollapseProperties.\n\n        R\u003djohnlenz\n        DELTA\u003d61  (49 added, 1 deleted, 11 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d30002\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@246 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "6/18/10, 5:18 PM",
          "commitName": "e829dafb9b3365bda6b6bb80f5fa97783752d143",
          "commitAuthor": "Nicholas.J.Santos",
          "commitDateOld": "3/26/10, 11:52 AM",
          "commitNameOld": "458118289064379bc22acfc7fd991686a4b062f1",
          "commitAuthorOld": "Nicholas.J.Santos",
          "daysBetweenCommits": 84.23,
          "commitsBetweenForRepo": 74,
          "commitsBetweenForFile": 1,
          "actualSource": "@SuppressWarnings(\"fallthrough\")\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    int nType \u003d n.getType();\n    switch(nType) {\n        case Token.STRING:\n            if (parent.getType() !\u003d Token.OBJECTLIT \u0026\u0026 parent.getType() !\u003d Token.GETPROP) {\n                break;\n            }\n        case Token.NAME:\n            String nString \u003d n.getString();\n            if (nType \u003d\u003d Token.NAME \u0026\u0026 n.getParent().getType() \u003d\u003d Token.CALL \u0026\u0026 \"eval\".equals(nString)) {\n                n.putBooleanProp(Node.DIRECT_EVAL, true);\n            }\n            if (NodeUtil.isConstantByConvention(convention, n, parent)) {\n                n.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n            }\n            break;\n        case Token.FUNCTION:\n            JSDocInfo fnInfo \u003d n.getJSDocInfo();\n            if (fnInfo \u003d\u003d null) {\n                if (parent.getType() \u003d\u003d Token.ASSIGN) {\n                    fnInfo \u003d parent.getJSDocInfo();\n                } else if (parent.getType() \u003d\u003d Token.NAME) {\n                    fnInfo \u003d parent.getParent().getJSDocInfo();\n                }\n            }\n            Node args \u003d n.getFirstChild().getNext();\n            for (Node arg \u003d args.getFirstChild(); arg !\u003d null; arg \u003d arg.getNext()) {\n                String argName \u003d arg.getString();\n                JSTypeExpression typeExpr \u003d fnInfo \u003d\u003d null ? null : fnInfo.getParameterType(argName);\n                if (convention.isOptionalParameter(arg) || typeExpr !\u003d null \u0026\u0026 typeExpr.isOptionalArg()) {\n                    arg.putBooleanProp(Node.IS_OPTIONAL_PARAM, true);\n                }\n                if (convention.isVarArgsParameter(arg) || typeExpr !\u003d null \u0026\u0026 typeExpr.isVarArgs()) {\n                    arg.putBooleanProp(Node.IS_VAR_ARGS_PARAM, true);\n                }\n            }\n            break;\n        case Token.OBJECTLIT:\n            if (n.getType() \u003d\u003d Token.OBJECTLIT) {\n                for (Node key \u003d n.getFirstChild(); key !\u003d null; key \u003d key.getNext().getNext()) {\n                    Node value \u003d key.getNext();\n                    if (key.getJSDocInfo() !\u003d null \u0026\u0026 key.getNext().getType() \u003d\u003d Token.FUNCTION) {\n                        value.setJSDocInfo(key.getJSDocInfo());\n                    }\n                }\n            }\n            break;\n    }\n    if (n.getJSDocInfo() !\u003d null \u0026\u0026 n.getJSDocInfo().isJavaDispatch()) {\n        if (n.getType() \u003d\u003d Token.ASSIGN) {\n            Node fnNode \u003d n.getLastChild();\n            Preconditions.checkState(fnNode.getType() \u003d\u003d Token.FUNCTION);\n            fnNode.putBooleanProp(Node.IS_DISPATCHER, true);\n        }\n    }\n}",
          "path": "src/com/google/javascript/jscomp/PrepareAst.java",
          "functionStartLine": 157,
          "functionName": "visit",
          "functionAnnotation": "@SuppressWarnings(\"fallthrough\")",
          "functionDoc": "In the AST that Rhino gives us, it needs to make a distinction\nbetween jsdoc on the object literal node and jsdoc on the object literal\nvalue. For example,\n\u003cpre\u003e\nvar x \u003d {\n  / JSDOC /\n  a: \u0027b\u0027,\n  c: / JSDOC / \u0027d\u0027\n};\n\u003c/pre\u003e\n\nBut in few narrow cases (in particular, function literals), it\u0027s\na lot easier for us if the doc is attached to the value.\n",
          "diff": "@@ -1,53 +1,57 @@\n+@SuppressWarnings(\"fallthrough\")\n public void visit(NodeTraversal t, Node n, Node parent) {\n     int nType \u003d n.getType();\n     switch(nType) {\n-        case Token.NAME:\n         case Token.STRING:\n+            if (parent.getType() !\u003d Token.OBJECTLIT \u0026\u0026 parent.getType() !\u003d Token.GETPROP) {\n+                break;\n+            }\n+        case Token.NAME:\n             String nString \u003d n.getString();\n             if (nType \u003d\u003d Token.NAME \u0026\u0026 n.getParent().getType() \u003d\u003d Token.CALL \u0026\u0026 \"eval\".equals(nString)) {\n                 n.putBooleanProp(Node.DIRECT_EVAL, true);\n             }\n-            if (convention.isConstant(nString)) {\n+            if (NodeUtil.isConstantByConvention(convention, n, parent)) {\n                 n.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n             }\n             break;\n         case Token.FUNCTION:\n             JSDocInfo fnInfo \u003d n.getJSDocInfo();\n             if (fnInfo \u003d\u003d null) {\n                 if (parent.getType() \u003d\u003d Token.ASSIGN) {\n                     fnInfo \u003d parent.getJSDocInfo();\n                 } else if (parent.getType() \u003d\u003d Token.NAME) {\n                     fnInfo \u003d parent.getParent().getJSDocInfo();\n                 }\n             }\n             Node args \u003d n.getFirstChild().getNext();\n             for (Node arg \u003d args.getFirstChild(); arg !\u003d null; arg \u003d arg.getNext()) {\n                 String argName \u003d arg.getString();\n                 JSTypeExpression typeExpr \u003d fnInfo \u003d\u003d null ? null : fnInfo.getParameterType(argName);\n                 if (convention.isOptionalParameter(arg) || typeExpr !\u003d null \u0026\u0026 typeExpr.isOptionalArg()) {\n                     arg.putBooleanProp(Node.IS_OPTIONAL_PARAM, true);\n                 }\n                 if (convention.isVarArgsParameter(arg) || typeExpr !\u003d null \u0026\u0026 typeExpr.isVarArgs()) {\n                     arg.putBooleanProp(Node.IS_VAR_ARGS_PARAM, true);\n                 }\n             }\n             break;\n         case Token.OBJECTLIT:\n             if (n.getType() \u003d\u003d Token.OBJECTLIT) {\n                 for (Node key \u003d n.getFirstChild(); key !\u003d null; key \u003d key.getNext().getNext()) {\n                     Node value \u003d key.getNext();\n                     if (key.getJSDocInfo() !\u003d null \u0026\u0026 key.getNext().getType() \u003d\u003d Token.FUNCTION) {\n                         value.setJSDocInfo(key.getJSDocInfo());\n                     }\n                 }\n             }\n             break;\n     }\n     if (n.getJSDocInfo() !\u003d null \u0026\u0026 n.getJSDocInfo().isJavaDispatch()) {\n         if (n.getType() \u003d\u003d Token.ASSIGN) {\n             Node fnNode \u003d n.getLastChild();\n             Preconditions.checkState(fnNode.getType() \u003d\u003d Token.FUNCTION);\n             fnNode.putBooleanProp(Node.IS_DISPATCHER, true);\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Yannotationchange",
          "commitMessage": "\nChange on 2010/06/17 by nicksantos\n\n        don\u0027t use Sets to build union types.\n\n        R\u003djohnlenz\n        DELTA\u003d76  (52 added, 6 deleted, 18 changed)\n\nChange on 2010/06/17 by nicksantos\n\n        fix a couple bugs in goog.scope processing\n\n        R\u003drobbyw\n        DELTA\u003d54  (42 added, 11 deleted, 1 changed)\n\n\nChange on 2010/06/17 by acleung\n\n        Disables function argument check with @notypecheck is on for the whole file.\n\n        R\u003djohnlenz\n        DELTA\u003d8  (5 added, 1 deleted, 2 changed)\n\nChange on 2010/06/17 by dcc\n\n        Fix NPE in ExportExternsPass with --check_types\u003dfalse.\n\n        R\u003dacleung\n        DELTA\u003d72  (66 added, 4 deleted, 2 changed)\n\nChange on 2010/06/17 by johnlenz\n\n        Change stub method parameters to allow sanity checks to pass with\n        CrossModuleMethodMotion.\n\n        R\u003dnicksantos\n        DELTA\u003d7  (3 added, 0 deleted, 4 changed)\n\nChange on 2010/06/18 by johnlenz\n\n        Modify AliasKeywords so passes the sanity checks: don\u0027t create coding\n        convention constants without annotation them so that the tests pass\n        when the sanity checks are on.\n\n        R\u003dnicksantos\n        DELTA\u003d18  (5 added, 0 deleted, 13 changed)\n\nChange on 2010/06/18 by johnlenz\n\n        Fix source maps when run with sanity checks.\n\n        R\u003dnicksantos\n        DELTA\u003d10  (7 added, 0 deleted, 3 changed)\n\nChange on 2010/06/18 by johnlenz\n\n        Changes to PrepareAst to make it valid to run during SanityChecks.\n\n        R\u003dnicksantos\n        DELTA\u003d18  (5 added, 0 deleted, 13 changed)\n\nChange on 2010/06/18 by nicksantos\n\n        fix constant annotations in CollapseProperties.\n\n        R\u003djohnlenz\n        DELTA\u003d61  (49 added, 1 deleted, 11 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d30002\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@246 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "6/18/10, 5:18 PM",
          "commitName": "e829dafb9b3365bda6b6bb80f5fa97783752d143",
          "commitAuthor": "Nicholas.J.Santos",
          "commitDateOld": "3/26/10, 11:52 AM",
          "commitNameOld": "458118289064379bc22acfc7fd991686a4b062f1",
          "commitAuthorOld": "Nicholas.J.Santos",
          "daysBetweenCommits": 84.23,
          "commitsBetweenForRepo": 74,
          "commitsBetweenForFile": 1,
          "actualSource": "@SuppressWarnings(\"fallthrough\")\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    int nType \u003d n.getType();\n    switch(nType) {\n        case Token.STRING:\n            if (parent.getType() !\u003d Token.OBJECTLIT \u0026\u0026 parent.getType() !\u003d Token.GETPROP) {\n                break;\n            }\n        case Token.NAME:\n            String nString \u003d n.getString();\n            if (nType \u003d\u003d Token.NAME \u0026\u0026 n.getParent().getType() \u003d\u003d Token.CALL \u0026\u0026 \"eval\".equals(nString)) {\n                n.putBooleanProp(Node.DIRECT_EVAL, true);\n            }\n            if (NodeUtil.isConstantByConvention(convention, n, parent)) {\n                n.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n            }\n            break;\n        case Token.FUNCTION:\n            JSDocInfo fnInfo \u003d n.getJSDocInfo();\n            if (fnInfo \u003d\u003d null) {\n                if (parent.getType() \u003d\u003d Token.ASSIGN) {\n                    fnInfo \u003d parent.getJSDocInfo();\n                } else if (parent.getType() \u003d\u003d Token.NAME) {\n                    fnInfo \u003d parent.getParent().getJSDocInfo();\n                }\n            }\n            Node args \u003d n.getFirstChild().getNext();\n            for (Node arg \u003d args.getFirstChild(); arg !\u003d null; arg \u003d arg.getNext()) {\n                String argName \u003d arg.getString();\n                JSTypeExpression typeExpr \u003d fnInfo \u003d\u003d null ? null : fnInfo.getParameterType(argName);\n                if (convention.isOptionalParameter(arg) || typeExpr !\u003d null \u0026\u0026 typeExpr.isOptionalArg()) {\n                    arg.putBooleanProp(Node.IS_OPTIONAL_PARAM, true);\n                }\n                if (convention.isVarArgsParameter(arg) || typeExpr !\u003d null \u0026\u0026 typeExpr.isVarArgs()) {\n                    arg.putBooleanProp(Node.IS_VAR_ARGS_PARAM, true);\n                }\n            }\n            break;\n        case Token.OBJECTLIT:\n            if (n.getType() \u003d\u003d Token.OBJECTLIT) {\n                for (Node key \u003d n.getFirstChild(); key !\u003d null; key \u003d key.getNext().getNext()) {\n                    Node value \u003d key.getNext();\n                    if (key.getJSDocInfo() !\u003d null \u0026\u0026 key.getNext().getType() \u003d\u003d Token.FUNCTION) {\n                        value.setJSDocInfo(key.getJSDocInfo());\n                    }\n                }\n            }\n            break;\n    }\n    if (n.getJSDocInfo() !\u003d null \u0026\u0026 n.getJSDocInfo().isJavaDispatch()) {\n        if (n.getType() \u003d\u003d Token.ASSIGN) {\n            Node fnNode \u003d n.getLastChild();\n            Preconditions.checkState(fnNode.getType() \u003d\u003d Token.FUNCTION);\n            fnNode.putBooleanProp(Node.IS_DISPATCHER, true);\n        }\n    }\n}",
          "path": "src/com/google/javascript/jscomp/PrepareAst.java",
          "functionStartLine": 157,
          "functionName": "visit",
          "functionAnnotation": "@SuppressWarnings(\"fallthrough\")",
          "functionDoc": "In the AST that Rhino gives us, it needs to make a distinction\nbetween jsdoc on the object literal node and jsdoc on the object literal\nvalue. For example,\n\u003cpre\u003e\nvar x \u003d {\n  / JSDOC /\n  a: \u0027b\u0027,\n  c: / JSDOC / \u0027d\u0027\n};\n\u003c/pre\u003e\n\nBut in few narrow cases (in particular, function literals), it\u0027s\na lot easier for us if the doc is attached to the value.\n",
          "diff": "@@ -1,53 +1,57 @@\n+@SuppressWarnings(\"fallthrough\")\n public void visit(NodeTraversal t, Node n, Node parent) {\n     int nType \u003d n.getType();\n     switch(nType) {\n-        case Token.NAME:\n         case Token.STRING:\n+            if (parent.getType() !\u003d Token.OBJECTLIT \u0026\u0026 parent.getType() !\u003d Token.GETPROP) {\n+                break;\n+            }\n+        case Token.NAME:\n             String nString \u003d n.getString();\n             if (nType \u003d\u003d Token.NAME \u0026\u0026 n.getParent().getType() \u003d\u003d Token.CALL \u0026\u0026 \"eval\".equals(nString)) {\n                 n.putBooleanProp(Node.DIRECT_EVAL, true);\n             }\n-            if (convention.isConstant(nString)) {\n+            if (NodeUtil.isConstantByConvention(convention, n, parent)) {\n                 n.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n             }\n             break;\n         case Token.FUNCTION:\n             JSDocInfo fnInfo \u003d n.getJSDocInfo();\n             if (fnInfo \u003d\u003d null) {\n                 if (parent.getType() \u003d\u003d Token.ASSIGN) {\n                     fnInfo \u003d parent.getJSDocInfo();\n                 } else if (parent.getType() \u003d\u003d Token.NAME) {\n                     fnInfo \u003d parent.getParent().getJSDocInfo();\n                 }\n             }\n             Node args \u003d n.getFirstChild().getNext();\n             for (Node arg \u003d args.getFirstChild(); arg !\u003d null; arg \u003d arg.getNext()) {\n                 String argName \u003d arg.getString();\n                 JSTypeExpression typeExpr \u003d fnInfo \u003d\u003d null ? null : fnInfo.getParameterType(argName);\n                 if (convention.isOptionalParameter(arg) || typeExpr !\u003d null \u0026\u0026 typeExpr.isOptionalArg()) {\n                     arg.putBooleanProp(Node.IS_OPTIONAL_PARAM, true);\n                 }\n                 if (convention.isVarArgsParameter(arg) || typeExpr !\u003d null \u0026\u0026 typeExpr.isVarArgs()) {\n                     arg.putBooleanProp(Node.IS_VAR_ARGS_PARAM, true);\n                 }\n             }\n             break;\n         case Token.OBJECTLIT:\n             if (n.getType() \u003d\u003d Token.OBJECTLIT) {\n                 for (Node key \u003d n.getFirstChild(); key !\u003d null; key \u003d key.getNext().getNext()) {\n                     Node value \u003d key.getNext();\n                     if (key.getJSDocInfo() !\u003d null \u0026\u0026 key.getNext().getType() \u003d\u003d Token.FUNCTION) {\n                         value.setJSDocInfo(key.getJSDocInfo());\n                     }\n                 }\n             }\n             break;\n     }\n     if (n.getJSDocInfo() !\u003d null \u0026\u0026 n.getJSDocInfo().isJavaDispatch()) {\n         if (n.getType() \u003d\u003d Token.ASSIGN) {\n             Node fnNode \u003d n.getLastChild();\n             Preconditions.checkState(fnNode.getType() \u003d\u003d Token.FUNCTION);\n             fnNode.putBooleanProp(Node.IS_DISPATCHER, true);\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "",
            "newValue": "@SuppressWarnings(\"fallthrough\")"
          }
        }
      ]
    },
    "9a1ddf5f982e54ecbc3e028dfa84ef9bd07a8044": {
      "type": "Ymultichange(Ymovefromfile,Ybodychange,Yannotationchange,Ydocchange)",
      "commitMessage": "Merge NodeTypeNormalizer and CodingConventionAnnotator into\na single pass. (Nick)\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@116 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "2/24/10, 8:37 PM",
      "commitName": "9a1ddf5f982e54ecbc3e028dfa84ef9bd07a8044",
      "commitAuthor": "Nicholas.J.Santos",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "Merge NodeTypeNormalizer and CodingConventionAnnotator into\na single pass. (Nick)\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@116 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "2/24/10, 8:37 PM",
          "commitName": "9a1ddf5f982e54ecbc3e028dfa84ef9bd07a8044",
          "commitAuthor": "Nicholas.J.Santos",
          "commitDateOld": "2/24/10, 4:14 PM",
          "commitNameOld": "4922461babcc37fb037d2a6db3fcb33fe4127a60",
          "commitAuthorOld": "Nicholas.J.Santos",
          "daysBetweenCommits": 0.18,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public void visit(NodeTraversal t, Node n, Node parent) {\n    int nType \u003d n.getType();\n    switch(nType) {\n        case Token.NAME:\n        case Token.STRING:\n            String nString \u003d n.getString();\n            if (nType \u003d\u003d Token.NAME \u0026\u0026 n.getParent().getType() \u003d\u003d Token.CALL \u0026\u0026 \"eval\".equals(nString)) {\n                n.putBooleanProp(Node.DIRECT_EVAL, true);\n            }\n            if (convention.isConstant(nString)) {\n                n.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n            }\n            break;\n        case Token.FUNCTION:\n            JSDocInfo fnInfo \u003d n.getJSDocInfo();\n            if (fnInfo \u003d\u003d null) {\n                if (parent.getType() \u003d\u003d Token.ASSIGN) {\n                    fnInfo \u003d parent.getJSDocInfo();\n                } else if (parent.getType() \u003d\u003d Token.NAME) {\n                    fnInfo \u003d parent.getParent().getJSDocInfo();\n                }\n            }\n            Node args \u003d n.getFirstChild().getNext();\n            for (Node arg \u003d args.getFirstChild(); arg !\u003d null; arg \u003d arg.getNext()) {\n                String argName \u003d arg.getString();\n                JSTypeExpression typeExpr \u003d fnInfo \u003d\u003d null ? null : fnInfo.getParameterType(argName);\n                if (convention.isOptionalParameter(arg) || typeExpr !\u003d null \u0026\u0026 typeExpr.isOptionalArg()) {\n                    arg.putBooleanProp(Node.IS_OPTIONAL_PARAM, true);\n                }\n                if (convention.isVarArgsParameter(arg) || typeExpr !\u003d null \u0026\u0026 typeExpr.isVarArgs()) {\n                    arg.putBooleanProp(Node.IS_VAR_ARGS_PARAM, true);\n                }\n            }\n            break;\n        case Token.OBJECTLIT:\n            if (n.getType() \u003d\u003d Token.OBJECTLIT) {\n                for (Node key \u003d n.getFirstChild(); key !\u003d null; key \u003d key.getNext().getNext()) {\n                    Node value \u003d key.getNext();\n                    if (key.getJSDocInfo() !\u003d null \u0026\u0026 key.getNext().getType() \u003d\u003d Token.FUNCTION) {\n                        value.setJSDocInfo(key.getJSDocInfo());\n                    }\n                }\n            }\n            break;\n    }\n    if (n.getJSDocInfo() !\u003d null \u0026\u0026 n.getJSDocInfo().isJavaDispatch()) {\n        if (n.getType() \u003d\u003d Token.ASSIGN) {\n            Node fnNode \u003d n.getLastChild();\n            Preconditions.checkState(fnNode.getType() \u003d\u003d Token.FUNCTION);\n            fnNode.putBooleanProp(Node.IS_DISPATCHER, true);\n        }\n    }\n}",
          "path": "src/com/google/javascript/jscomp/PrepareAst.java",
          "functionStartLine": 150,
          "functionName": "visit",
          "functionAnnotation": "",
          "functionDoc": "In the AST that Rhino gives us, it needs to make a distinction\nbetween jsdoc on the object literal node and jsdoc on the object literal\nvalue. For example,\n\u003cpre\u003e\nvar x \u003d {\n  / JSDOC /\n  a: \u0027b\u0027,\n  c: / JSDOC / \u0027d\u0027\n};\n\u003c/pre\u003e\n\nBut in few narrow cases (in particular, function literals), it\u0027s\na lot easier for us if the doc is attached to the value.\n",
          "diff": "@@ -1,37 +1,53 @@\n-@Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n     int nType \u003d n.getType();\n     switch(nType) {\n         case Token.NAME:\n         case Token.STRING:\n             String nString \u003d n.getString();\n             if (nType \u003d\u003d Token.NAME \u0026\u0026 n.getParent().getType() \u003d\u003d Token.CALL \u0026\u0026 \"eval\".equals(nString)) {\n                 n.putBooleanProp(Node.DIRECT_EVAL, true);\n             }\n             if (convention.isConstant(nString)) {\n                 n.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n             }\n             break;\n         case Token.FUNCTION:\n             JSDocInfo fnInfo \u003d n.getJSDocInfo();\n             if (fnInfo \u003d\u003d null) {\n                 if (parent.getType() \u003d\u003d Token.ASSIGN) {\n                     fnInfo \u003d parent.getJSDocInfo();\n                 } else if (parent.getType() \u003d\u003d Token.NAME) {\n                     fnInfo \u003d parent.getParent().getJSDocInfo();\n                 }\n             }\n             Node args \u003d n.getFirstChild().getNext();\n             for (Node arg \u003d args.getFirstChild(); arg !\u003d null; arg \u003d arg.getNext()) {\n                 String argName \u003d arg.getString();\n                 JSTypeExpression typeExpr \u003d fnInfo \u003d\u003d null ? null : fnInfo.getParameterType(argName);\n                 if (convention.isOptionalParameter(arg) || typeExpr !\u003d null \u0026\u0026 typeExpr.isOptionalArg()) {\n                     arg.putBooleanProp(Node.IS_OPTIONAL_PARAM, true);\n                 }\n                 if (convention.isVarArgsParameter(arg) || typeExpr !\u003d null \u0026\u0026 typeExpr.isVarArgs()) {\n                     arg.putBooleanProp(Node.IS_VAR_ARGS_PARAM, true);\n                 }\n             }\n             break;\n+        case Token.OBJECTLIT:\n+            if (n.getType() \u003d\u003d Token.OBJECTLIT) {\n+                for (Node key \u003d n.getFirstChild(); key !\u003d null; key \u003d key.getNext().getNext()) {\n+                    Node value \u003d key.getNext();\n+                    if (key.getJSDocInfo() !\u003d null \u0026\u0026 key.getNext().getType() \u003d\u003d Token.FUNCTION) {\n+                        value.setJSDocInfo(key.getJSDocInfo());\n+                    }\n+                }\n+            }\n+            break;\n+    }\n+    if (n.getJSDocInfo() !\u003d null \u0026\u0026 n.getJSDocInfo().isJavaDispatch()) {\n+        if (n.getType() \u003d\u003d Token.ASSIGN) {\n+            Node fnNode \u003d n.getLastChild();\n+            Preconditions.checkState(fnNode.getType() \u003d\u003d Token.FUNCTION);\n+            fnNode.putBooleanProp(Node.IS_DISPATCHER, true);\n+        }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldPath": "src/com/google/javascript/jscomp/CodingConventionAnnotator.java",
            "newPath": "src/com/google/javascript/jscomp/PrepareAst.java",
            "oldMethodName": "visit",
            "newMethodName": "visit"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Merge NodeTypeNormalizer and CodingConventionAnnotator into\na single pass. (Nick)\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@116 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "2/24/10, 8:37 PM",
          "commitName": "9a1ddf5f982e54ecbc3e028dfa84ef9bd07a8044",
          "commitAuthor": "Nicholas.J.Santos",
          "commitDateOld": "2/24/10, 4:14 PM",
          "commitNameOld": "4922461babcc37fb037d2a6db3fcb33fe4127a60",
          "commitAuthorOld": "Nicholas.J.Santos",
          "daysBetweenCommits": 0.18,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public void visit(NodeTraversal t, Node n, Node parent) {\n    int nType \u003d n.getType();\n    switch(nType) {\n        case Token.NAME:\n        case Token.STRING:\n            String nString \u003d n.getString();\n            if (nType \u003d\u003d Token.NAME \u0026\u0026 n.getParent().getType() \u003d\u003d Token.CALL \u0026\u0026 \"eval\".equals(nString)) {\n                n.putBooleanProp(Node.DIRECT_EVAL, true);\n            }\n            if (convention.isConstant(nString)) {\n                n.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n            }\n            break;\n        case Token.FUNCTION:\n            JSDocInfo fnInfo \u003d n.getJSDocInfo();\n            if (fnInfo \u003d\u003d null) {\n                if (parent.getType() \u003d\u003d Token.ASSIGN) {\n                    fnInfo \u003d parent.getJSDocInfo();\n                } else if (parent.getType() \u003d\u003d Token.NAME) {\n                    fnInfo \u003d parent.getParent().getJSDocInfo();\n                }\n            }\n            Node args \u003d n.getFirstChild().getNext();\n            for (Node arg \u003d args.getFirstChild(); arg !\u003d null; arg \u003d arg.getNext()) {\n                String argName \u003d arg.getString();\n                JSTypeExpression typeExpr \u003d fnInfo \u003d\u003d null ? null : fnInfo.getParameterType(argName);\n                if (convention.isOptionalParameter(arg) || typeExpr !\u003d null \u0026\u0026 typeExpr.isOptionalArg()) {\n                    arg.putBooleanProp(Node.IS_OPTIONAL_PARAM, true);\n                }\n                if (convention.isVarArgsParameter(arg) || typeExpr !\u003d null \u0026\u0026 typeExpr.isVarArgs()) {\n                    arg.putBooleanProp(Node.IS_VAR_ARGS_PARAM, true);\n                }\n            }\n            break;\n        case Token.OBJECTLIT:\n            if (n.getType() \u003d\u003d Token.OBJECTLIT) {\n                for (Node key \u003d n.getFirstChild(); key !\u003d null; key \u003d key.getNext().getNext()) {\n                    Node value \u003d key.getNext();\n                    if (key.getJSDocInfo() !\u003d null \u0026\u0026 key.getNext().getType() \u003d\u003d Token.FUNCTION) {\n                        value.setJSDocInfo(key.getJSDocInfo());\n                    }\n                }\n            }\n            break;\n    }\n    if (n.getJSDocInfo() !\u003d null \u0026\u0026 n.getJSDocInfo().isJavaDispatch()) {\n        if (n.getType() \u003d\u003d Token.ASSIGN) {\n            Node fnNode \u003d n.getLastChild();\n            Preconditions.checkState(fnNode.getType() \u003d\u003d Token.FUNCTION);\n            fnNode.putBooleanProp(Node.IS_DISPATCHER, true);\n        }\n    }\n}",
          "path": "src/com/google/javascript/jscomp/PrepareAst.java",
          "functionStartLine": 150,
          "functionName": "visit",
          "functionAnnotation": "",
          "functionDoc": "In the AST that Rhino gives us, it needs to make a distinction\nbetween jsdoc on the object literal node and jsdoc on the object literal\nvalue. For example,\n\u003cpre\u003e\nvar x \u003d {\n  / JSDOC /\n  a: \u0027b\u0027,\n  c: / JSDOC / \u0027d\u0027\n};\n\u003c/pre\u003e\n\nBut in few narrow cases (in particular, function literals), it\u0027s\na lot easier for us if the doc is attached to the value.\n",
          "diff": "@@ -1,37 +1,53 @@\n-@Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n     int nType \u003d n.getType();\n     switch(nType) {\n         case Token.NAME:\n         case Token.STRING:\n             String nString \u003d n.getString();\n             if (nType \u003d\u003d Token.NAME \u0026\u0026 n.getParent().getType() \u003d\u003d Token.CALL \u0026\u0026 \"eval\".equals(nString)) {\n                 n.putBooleanProp(Node.DIRECT_EVAL, true);\n             }\n             if (convention.isConstant(nString)) {\n                 n.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n             }\n             break;\n         case Token.FUNCTION:\n             JSDocInfo fnInfo \u003d n.getJSDocInfo();\n             if (fnInfo \u003d\u003d null) {\n                 if (parent.getType() \u003d\u003d Token.ASSIGN) {\n                     fnInfo \u003d parent.getJSDocInfo();\n                 } else if (parent.getType() \u003d\u003d Token.NAME) {\n                     fnInfo \u003d parent.getParent().getJSDocInfo();\n                 }\n             }\n             Node args \u003d n.getFirstChild().getNext();\n             for (Node arg \u003d args.getFirstChild(); arg !\u003d null; arg \u003d arg.getNext()) {\n                 String argName \u003d arg.getString();\n                 JSTypeExpression typeExpr \u003d fnInfo \u003d\u003d null ? null : fnInfo.getParameterType(argName);\n                 if (convention.isOptionalParameter(arg) || typeExpr !\u003d null \u0026\u0026 typeExpr.isOptionalArg()) {\n                     arg.putBooleanProp(Node.IS_OPTIONAL_PARAM, true);\n                 }\n                 if (convention.isVarArgsParameter(arg) || typeExpr !\u003d null \u0026\u0026 typeExpr.isVarArgs()) {\n                     arg.putBooleanProp(Node.IS_VAR_ARGS_PARAM, true);\n                 }\n             }\n             break;\n+        case Token.OBJECTLIT:\n+            if (n.getType() \u003d\u003d Token.OBJECTLIT) {\n+                for (Node key \u003d n.getFirstChild(); key !\u003d null; key \u003d key.getNext().getNext()) {\n+                    Node value \u003d key.getNext();\n+                    if (key.getJSDocInfo() !\u003d null \u0026\u0026 key.getNext().getType() \u003d\u003d Token.FUNCTION) {\n+                        value.setJSDocInfo(key.getJSDocInfo());\n+                    }\n+                }\n+            }\n+            break;\n+    }\n+    if (n.getJSDocInfo() !\u003d null \u0026\u0026 n.getJSDocInfo().isJavaDispatch()) {\n+        if (n.getType() \u003d\u003d Token.ASSIGN) {\n+            Node fnNode \u003d n.getLastChild();\n+            Preconditions.checkState(fnNode.getType() \u003d\u003d Token.FUNCTION);\n+            fnNode.putBooleanProp(Node.IS_DISPATCHER, true);\n+        }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Yannotationchange",
          "commitMessage": "Merge NodeTypeNormalizer and CodingConventionAnnotator into\na single pass. (Nick)\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@116 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "2/24/10, 8:37 PM",
          "commitName": "9a1ddf5f982e54ecbc3e028dfa84ef9bd07a8044",
          "commitAuthor": "Nicholas.J.Santos",
          "commitDateOld": "2/24/10, 4:14 PM",
          "commitNameOld": "4922461babcc37fb037d2a6db3fcb33fe4127a60",
          "commitAuthorOld": "Nicholas.J.Santos",
          "daysBetweenCommits": 0.18,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public void visit(NodeTraversal t, Node n, Node parent) {\n    int nType \u003d n.getType();\n    switch(nType) {\n        case Token.NAME:\n        case Token.STRING:\n            String nString \u003d n.getString();\n            if (nType \u003d\u003d Token.NAME \u0026\u0026 n.getParent().getType() \u003d\u003d Token.CALL \u0026\u0026 \"eval\".equals(nString)) {\n                n.putBooleanProp(Node.DIRECT_EVAL, true);\n            }\n            if (convention.isConstant(nString)) {\n                n.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n            }\n            break;\n        case Token.FUNCTION:\n            JSDocInfo fnInfo \u003d n.getJSDocInfo();\n            if (fnInfo \u003d\u003d null) {\n                if (parent.getType() \u003d\u003d Token.ASSIGN) {\n                    fnInfo \u003d parent.getJSDocInfo();\n                } else if (parent.getType() \u003d\u003d Token.NAME) {\n                    fnInfo \u003d parent.getParent().getJSDocInfo();\n                }\n            }\n            Node args \u003d n.getFirstChild().getNext();\n            for (Node arg \u003d args.getFirstChild(); arg !\u003d null; arg \u003d arg.getNext()) {\n                String argName \u003d arg.getString();\n                JSTypeExpression typeExpr \u003d fnInfo \u003d\u003d null ? null : fnInfo.getParameterType(argName);\n                if (convention.isOptionalParameter(arg) || typeExpr !\u003d null \u0026\u0026 typeExpr.isOptionalArg()) {\n                    arg.putBooleanProp(Node.IS_OPTIONAL_PARAM, true);\n                }\n                if (convention.isVarArgsParameter(arg) || typeExpr !\u003d null \u0026\u0026 typeExpr.isVarArgs()) {\n                    arg.putBooleanProp(Node.IS_VAR_ARGS_PARAM, true);\n                }\n            }\n            break;\n        case Token.OBJECTLIT:\n            if (n.getType() \u003d\u003d Token.OBJECTLIT) {\n                for (Node key \u003d n.getFirstChild(); key !\u003d null; key \u003d key.getNext().getNext()) {\n                    Node value \u003d key.getNext();\n                    if (key.getJSDocInfo() !\u003d null \u0026\u0026 key.getNext().getType() \u003d\u003d Token.FUNCTION) {\n                        value.setJSDocInfo(key.getJSDocInfo());\n                    }\n                }\n            }\n            break;\n    }\n    if (n.getJSDocInfo() !\u003d null \u0026\u0026 n.getJSDocInfo().isJavaDispatch()) {\n        if (n.getType() \u003d\u003d Token.ASSIGN) {\n            Node fnNode \u003d n.getLastChild();\n            Preconditions.checkState(fnNode.getType() \u003d\u003d Token.FUNCTION);\n            fnNode.putBooleanProp(Node.IS_DISPATCHER, true);\n        }\n    }\n}",
          "path": "src/com/google/javascript/jscomp/PrepareAst.java",
          "functionStartLine": 150,
          "functionName": "visit",
          "functionAnnotation": "",
          "functionDoc": "In the AST that Rhino gives us, it needs to make a distinction\nbetween jsdoc on the object literal node and jsdoc on the object literal\nvalue. For example,\n\u003cpre\u003e\nvar x \u003d {\n  / JSDOC /\n  a: \u0027b\u0027,\n  c: / JSDOC / \u0027d\u0027\n};\n\u003c/pre\u003e\n\nBut in few narrow cases (in particular, function literals), it\u0027s\na lot easier for us if the doc is attached to the value.\n",
          "diff": "@@ -1,37 +1,53 @@\n-@Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n     int nType \u003d n.getType();\n     switch(nType) {\n         case Token.NAME:\n         case Token.STRING:\n             String nString \u003d n.getString();\n             if (nType \u003d\u003d Token.NAME \u0026\u0026 n.getParent().getType() \u003d\u003d Token.CALL \u0026\u0026 \"eval\".equals(nString)) {\n                 n.putBooleanProp(Node.DIRECT_EVAL, true);\n             }\n             if (convention.isConstant(nString)) {\n                 n.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n             }\n             break;\n         case Token.FUNCTION:\n             JSDocInfo fnInfo \u003d n.getJSDocInfo();\n             if (fnInfo \u003d\u003d null) {\n                 if (parent.getType() \u003d\u003d Token.ASSIGN) {\n                     fnInfo \u003d parent.getJSDocInfo();\n                 } else if (parent.getType() \u003d\u003d Token.NAME) {\n                     fnInfo \u003d parent.getParent().getJSDocInfo();\n                 }\n             }\n             Node args \u003d n.getFirstChild().getNext();\n             for (Node arg \u003d args.getFirstChild(); arg !\u003d null; arg \u003d arg.getNext()) {\n                 String argName \u003d arg.getString();\n                 JSTypeExpression typeExpr \u003d fnInfo \u003d\u003d null ? null : fnInfo.getParameterType(argName);\n                 if (convention.isOptionalParameter(arg) || typeExpr !\u003d null \u0026\u0026 typeExpr.isOptionalArg()) {\n                     arg.putBooleanProp(Node.IS_OPTIONAL_PARAM, true);\n                 }\n                 if (convention.isVarArgsParameter(arg) || typeExpr !\u003d null \u0026\u0026 typeExpr.isVarArgs()) {\n                     arg.putBooleanProp(Node.IS_VAR_ARGS_PARAM, true);\n                 }\n             }\n             break;\n+        case Token.OBJECTLIT:\n+            if (n.getType() \u003d\u003d Token.OBJECTLIT) {\n+                for (Node key \u003d n.getFirstChild(); key !\u003d null; key \u003d key.getNext().getNext()) {\n+                    Node value \u003d key.getNext();\n+                    if (key.getJSDocInfo() !\u003d null \u0026\u0026 key.getNext().getType() \u003d\u003d Token.FUNCTION) {\n+                        value.setJSDocInfo(key.getJSDocInfo());\n+                    }\n+                }\n+            }\n+            break;\n+    }\n+    if (n.getJSDocInfo() !\u003d null \u0026\u0026 n.getJSDocInfo().isJavaDispatch()) {\n+        if (n.getType() \u003d\u003d Token.ASSIGN) {\n+            Node fnNode \u003d n.getLastChild();\n+            Preconditions.checkState(fnNode.getType() \u003d\u003d Token.FUNCTION);\n+            fnNode.putBooleanProp(Node.IS_DISPATCHER, true);\n+        }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "@Override",
            "newValue": ""
          }
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Merge NodeTypeNormalizer and CodingConventionAnnotator into\na single pass. (Nick)\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@116 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "2/24/10, 8:37 PM",
          "commitName": "9a1ddf5f982e54ecbc3e028dfa84ef9bd07a8044",
          "commitAuthor": "Nicholas.J.Santos",
          "commitDateOld": "2/24/10, 4:14 PM",
          "commitNameOld": "4922461babcc37fb037d2a6db3fcb33fe4127a60",
          "commitAuthorOld": "Nicholas.J.Santos",
          "daysBetweenCommits": 0.18,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public void visit(NodeTraversal t, Node n, Node parent) {\n    int nType \u003d n.getType();\n    switch(nType) {\n        case Token.NAME:\n        case Token.STRING:\n            String nString \u003d n.getString();\n            if (nType \u003d\u003d Token.NAME \u0026\u0026 n.getParent().getType() \u003d\u003d Token.CALL \u0026\u0026 \"eval\".equals(nString)) {\n                n.putBooleanProp(Node.DIRECT_EVAL, true);\n            }\n            if (convention.isConstant(nString)) {\n                n.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n            }\n            break;\n        case Token.FUNCTION:\n            JSDocInfo fnInfo \u003d n.getJSDocInfo();\n            if (fnInfo \u003d\u003d null) {\n                if (parent.getType() \u003d\u003d Token.ASSIGN) {\n                    fnInfo \u003d parent.getJSDocInfo();\n                } else if (parent.getType() \u003d\u003d Token.NAME) {\n                    fnInfo \u003d parent.getParent().getJSDocInfo();\n                }\n            }\n            Node args \u003d n.getFirstChild().getNext();\n            for (Node arg \u003d args.getFirstChild(); arg !\u003d null; arg \u003d arg.getNext()) {\n                String argName \u003d arg.getString();\n                JSTypeExpression typeExpr \u003d fnInfo \u003d\u003d null ? null : fnInfo.getParameterType(argName);\n                if (convention.isOptionalParameter(arg) || typeExpr !\u003d null \u0026\u0026 typeExpr.isOptionalArg()) {\n                    arg.putBooleanProp(Node.IS_OPTIONAL_PARAM, true);\n                }\n                if (convention.isVarArgsParameter(arg) || typeExpr !\u003d null \u0026\u0026 typeExpr.isVarArgs()) {\n                    arg.putBooleanProp(Node.IS_VAR_ARGS_PARAM, true);\n                }\n            }\n            break;\n        case Token.OBJECTLIT:\n            if (n.getType() \u003d\u003d Token.OBJECTLIT) {\n                for (Node key \u003d n.getFirstChild(); key !\u003d null; key \u003d key.getNext().getNext()) {\n                    Node value \u003d key.getNext();\n                    if (key.getJSDocInfo() !\u003d null \u0026\u0026 key.getNext().getType() \u003d\u003d Token.FUNCTION) {\n                        value.setJSDocInfo(key.getJSDocInfo());\n                    }\n                }\n            }\n            break;\n    }\n    if (n.getJSDocInfo() !\u003d null \u0026\u0026 n.getJSDocInfo().isJavaDispatch()) {\n        if (n.getType() \u003d\u003d Token.ASSIGN) {\n            Node fnNode \u003d n.getLastChild();\n            Preconditions.checkState(fnNode.getType() \u003d\u003d Token.FUNCTION);\n            fnNode.putBooleanProp(Node.IS_DISPATCHER, true);\n        }\n    }\n}",
          "path": "src/com/google/javascript/jscomp/PrepareAst.java",
          "functionStartLine": 150,
          "functionName": "visit",
          "functionAnnotation": "",
          "functionDoc": "In the AST that Rhino gives us, it needs to make a distinction\nbetween jsdoc on the object literal node and jsdoc on the object literal\nvalue. For example,\n\u003cpre\u003e\nvar x \u003d {\n  / JSDOC /\n  a: \u0027b\u0027,\n  c: / JSDOC / \u0027d\u0027\n};\n\u003c/pre\u003e\n\nBut in few narrow cases (in particular, function literals), it\u0027s\na lot easier for us if the doc is attached to the value.\n",
          "diff": "@@ -1,37 +1,53 @@\n-@Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n     int nType \u003d n.getType();\n     switch(nType) {\n         case Token.NAME:\n         case Token.STRING:\n             String nString \u003d n.getString();\n             if (nType \u003d\u003d Token.NAME \u0026\u0026 n.getParent().getType() \u003d\u003d Token.CALL \u0026\u0026 \"eval\".equals(nString)) {\n                 n.putBooleanProp(Node.DIRECT_EVAL, true);\n             }\n             if (convention.isConstant(nString)) {\n                 n.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n             }\n             break;\n         case Token.FUNCTION:\n             JSDocInfo fnInfo \u003d n.getJSDocInfo();\n             if (fnInfo \u003d\u003d null) {\n                 if (parent.getType() \u003d\u003d Token.ASSIGN) {\n                     fnInfo \u003d parent.getJSDocInfo();\n                 } else if (parent.getType() \u003d\u003d Token.NAME) {\n                     fnInfo \u003d parent.getParent().getJSDocInfo();\n                 }\n             }\n             Node args \u003d n.getFirstChild().getNext();\n             for (Node arg \u003d args.getFirstChild(); arg !\u003d null; arg \u003d arg.getNext()) {\n                 String argName \u003d arg.getString();\n                 JSTypeExpression typeExpr \u003d fnInfo \u003d\u003d null ? null : fnInfo.getParameterType(argName);\n                 if (convention.isOptionalParameter(arg) || typeExpr !\u003d null \u0026\u0026 typeExpr.isOptionalArg()) {\n                     arg.putBooleanProp(Node.IS_OPTIONAL_PARAM, true);\n                 }\n                 if (convention.isVarArgsParameter(arg) || typeExpr !\u003d null \u0026\u0026 typeExpr.isVarArgs()) {\n                     arg.putBooleanProp(Node.IS_VAR_ARGS_PARAM, true);\n                 }\n             }\n             break;\n+        case Token.OBJECTLIT:\n+            if (n.getType() \u003d\u003d Token.OBJECTLIT) {\n+                for (Node key \u003d n.getFirstChild(); key !\u003d null; key \u003d key.getNext().getNext()) {\n+                    Node value \u003d key.getNext();\n+                    if (key.getJSDocInfo() !\u003d null \u0026\u0026 key.getNext().getType() \u003d\u003d Token.FUNCTION) {\n+                        value.setJSDocInfo(key.getJSDocInfo());\n+                    }\n+                }\n+            }\n+            break;\n+    }\n+    if (n.getJSDocInfo() !\u003d null \u0026\u0026 n.getJSDocInfo().isJavaDispatch()) {\n+        if (n.getType() \u003d\u003d Token.ASSIGN) {\n+            Node fnNode \u003d n.getLastChild();\n+            Preconditions.checkState(fnNode.getType() \u003d\u003d Token.FUNCTION);\n+            fnNode.putBooleanProp(Node.IS_DISPATCHER, true);\n+        }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "",
            "newValue": "In the AST that Rhino gives us, it needs to make a distinction\nbetween jsdoc on the object literal node and jsdoc on the object literal\nvalue. For example,\n\u003cpre\u003e\nvar x \u003d {\n  / JSDOC /\n  a: \u0027b\u0027,\n  c: / JSDOC / \u0027d\u0027\n};\n\u003c/pre\u003e\n\nBut in few narrow cases (in particular, function literals), it\u0027s\na lot easier for us if the doc is attached to the value.\n"
          }
        }
      ]
    },
    "8ba5e1f86eaf3c31b9279f92823b4fa2a50574a3": {
      "type": "Ybodychange",
      "commitMessage": "Print indirect calls to eval correctly (issue 81)\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@79 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "1/27/10, 5:22 PM",
      "commitName": "8ba5e1f86eaf3c31b9279f92823b4fa2a50574a3",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "11/11/09, 11:05 AM",
      "commitNameOld": "6a36f04485599820ff86441accee002b4deec2eb",
      "commitAuthorOld": "nicholas.j.santos@gmail.com",
      "daysBetweenCommits": 77.26,
      "commitsBetweenForRepo": 51,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    int nType \u003d n.getType();\n    switch(nType) {\n        case Token.NAME:\n        case Token.STRING:\n            String nString \u003d n.getString();\n            if (nType \u003d\u003d Token.NAME \u0026\u0026 n.getParent().getType() \u003d\u003d Token.CALL \u0026\u0026 \"eval\".equals(nString)) {\n                n.putBooleanProp(Node.DIRECT_EVAL, true);\n            }\n            if (convention.isConstant(nString)) {\n                n.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n            }\n            break;\n        case Token.FUNCTION:\n            JSDocInfo fnInfo \u003d n.getJSDocInfo();\n            if (fnInfo \u003d\u003d null) {\n                if (parent.getType() \u003d\u003d Token.ASSIGN) {\n                    fnInfo \u003d parent.getJSDocInfo();\n                } else if (parent.getType() \u003d\u003d Token.NAME) {\n                    fnInfo \u003d parent.getParent().getJSDocInfo();\n                }\n            }\n            Node args \u003d n.getFirstChild().getNext();\n            for (Node arg \u003d args.getFirstChild(); arg !\u003d null; arg \u003d arg.getNext()) {\n                String argName \u003d arg.getString();\n                JSTypeExpression typeExpr \u003d fnInfo \u003d\u003d null ? null : fnInfo.getParameterType(argName);\n                if (convention.isOptionalParameter(arg) || typeExpr !\u003d null \u0026\u0026 typeExpr.isOptionalArg()) {\n                    arg.putBooleanProp(Node.IS_OPTIONAL_PARAM, true);\n                }\n                if (convention.isVarArgsParameter(arg) || typeExpr !\u003d null \u0026\u0026 typeExpr.isVarArgs()) {\n                    arg.putBooleanProp(Node.IS_VAR_ARGS_PARAM, true);\n                }\n            }\n            break;\n    }\n}",
      "path": "src/com/google/javascript/jscomp/CodingConventionAnnotator.java",
      "functionStartLine": 56,
      "functionName": "visit",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,32 +1,37 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n+    int nType \u003d n.getType();\n+    switch(nType) {\n         case Token.NAME:\n         case Token.STRING:\n-            if (convention.isConstant(n.getString())) {\n+            String nString \u003d n.getString();\n+            if (nType \u003d\u003d Token.NAME \u0026\u0026 n.getParent().getType() \u003d\u003d Token.CALL \u0026\u0026 \"eval\".equals(nString)) {\n+                n.putBooleanProp(Node.DIRECT_EVAL, true);\n+            }\n+            if (convention.isConstant(nString)) {\n                 n.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n             }\n             break;\n         case Token.FUNCTION:\n             JSDocInfo fnInfo \u003d n.getJSDocInfo();\n             if (fnInfo \u003d\u003d null) {\n                 if (parent.getType() \u003d\u003d Token.ASSIGN) {\n                     fnInfo \u003d parent.getJSDocInfo();\n                 } else if (parent.getType() \u003d\u003d Token.NAME) {\n                     fnInfo \u003d parent.getParent().getJSDocInfo();\n                 }\n             }\n             Node args \u003d n.getFirstChild().getNext();\n             for (Node arg \u003d args.getFirstChild(); arg !\u003d null; arg \u003d arg.getNext()) {\n                 String argName \u003d arg.getString();\n                 JSTypeExpression typeExpr \u003d fnInfo \u003d\u003d null ? null : fnInfo.getParameterType(argName);\n                 if (convention.isOptionalParameter(arg) || typeExpr !\u003d null \u0026\u0026 typeExpr.isOptionalArg()) {\n                     arg.putBooleanProp(Node.IS_OPTIONAL_PARAM, true);\n                 }\n                 if (convention.isVarArgsParameter(arg) || typeExpr !\u003d null \u0026\u0026 typeExpr.isVarArgs()) {\n                     arg.putBooleanProp(Node.IS_VAR_ARGS_PARAM, true);\n                 }\n             }\n             break;\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6a36f04485599820ff86441accee002b4deec2eb": {
      "type": "Ybodychange",
      "commitMessage": "Fixes for issues 14 and 16.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@7 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/11/09, 11:05 AM",
      "commitName": "6a36f04485599820ff86441accee002b4deec2eb",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "commitDateOld": "11/3/09, 3:51 PM",
      "commitNameOld": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthorOld": "nicholas.j.santos@gmail.com",
      "daysBetweenCommits": 7.8,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.NAME:\n        case Token.STRING:\n            if (convention.isConstant(n.getString())) {\n                n.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n            }\n            break;\n        case Token.FUNCTION:\n            JSDocInfo fnInfo \u003d n.getJSDocInfo();\n            if (fnInfo \u003d\u003d null) {\n                if (parent.getType() \u003d\u003d Token.ASSIGN) {\n                    fnInfo \u003d parent.getJSDocInfo();\n                } else if (parent.getType() \u003d\u003d Token.NAME) {\n                    fnInfo \u003d parent.getParent().getJSDocInfo();\n                }\n            }\n            Node args \u003d n.getFirstChild().getNext();\n            for (Node arg \u003d args.getFirstChild(); arg !\u003d null; arg \u003d arg.getNext()) {\n                String argName \u003d arg.getString();\n                JSTypeExpression typeExpr \u003d fnInfo \u003d\u003d null ? null : fnInfo.getParameterType(argName);\n                if (convention.isOptionalParameter(arg) || typeExpr !\u003d null \u0026\u0026 typeExpr.isOptionalArg()) {\n                    arg.putBooleanProp(Node.IS_OPTIONAL_PARAM, true);\n                }\n                if (convention.isVarArgsParameter(arg) || typeExpr !\u003d null \u0026\u0026 typeExpr.isVarArgs()) {\n                    arg.putBooleanProp(Node.IS_VAR_ARGS_PARAM, true);\n                }\n            }\n            break;\n    }\n}",
      "path": "src/com/google/javascript/jscomp/CodingConventionAnnotator.java",
      "functionStartLine": 53,
      "functionName": "visit",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,32 +1,32 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n     switch(n.getType()) {\n         case Token.NAME:\n         case Token.STRING:\n             if (convention.isConstant(n.getString())) {\n                 n.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n             }\n             break;\n         case Token.FUNCTION:\n             JSDocInfo fnInfo \u003d n.getJSDocInfo();\n             if (fnInfo \u003d\u003d null) {\n                 if (parent.getType() \u003d\u003d Token.ASSIGN) {\n                     fnInfo \u003d parent.getJSDocInfo();\n                 } else if (parent.getType() \u003d\u003d Token.NAME) {\n                     fnInfo \u003d parent.getParent().getJSDocInfo();\n                 }\n             }\n             Node args \u003d n.getFirstChild().getNext();\n             for (Node arg \u003d args.getFirstChild(); arg !\u003d null; arg \u003d arg.getNext()) {\n                 String argName \u003d arg.getString();\n                 JSTypeExpression typeExpr \u003d fnInfo \u003d\u003d null ? null : fnInfo.getParameterType(argName);\n-                if (convention.isOptionalParameter(argName) || typeExpr !\u003d null \u0026\u0026 typeExpr.isOptionalArg()) {\n+                if (convention.isOptionalParameter(arg) || typeExpr !\u003d null \u0026\u0026 typeExpr.isOptionalArg()) {\n                     arg.putBooleanProp(Node.IS_OPTIONAL_PARAM, true);\n                 }\n-                if (convention.isVarArgsParameter(arg, argName) || typeExpr !\u003d null \u0026\u0026 typeExpr.isVarArgs()) {\n+                if (convention.isVarArgsParameter(arg) || typeExpr !\u003d null \u0026\u0026 typeExpr.isVarArgs()) {\n                     arg.putBooleanProp(Node.IS_VAR_ARGS_PARAM, true);\n                 }\n             }\n             break;\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": {
      "type": "Yintroduced",
      "commitMessage": "Initial commit.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/3/09, 3:51 PM",
      "commitName": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "diff": "@@ -0,0 +1,32 @@\n+@Override\n+public void visit(NodeTraversal t, Node n, Node parent) {\n+    switch(n.getType()) {\n+        case Token.NAME:\n+        case Token.STRING:\n+            if (convention.isConstant(n.getString())) {\n+                n.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n+            }\n+            break;\n+        case Token.FUNCTION:\n+            JSDocInfo fnInfo \u003d n.getJSDocInfo();\n+            if (fnInfo \u003d\u003d null) {\n+                if (parent.getType() \u003d\u003d Token.ASSIGN) {\n+                    fnInfo \u003d parent.getJSDocInfo();\n+                } else if (parent.getType() \u003d\u003d Token.NAME) {\n+                    fnInfo \u003d parent.getParent().getJSDocInfo();\n+                }\n+            }\n+            Node args \u003d n.getFirstChild().getNext();\n+            for (Node arg \u003d args.getFirstChild(); arg !\u003d null; arg \u003d arg.getNext()) {\n+                String argName \u003d arg.getString();\n+                JSTypeExpression typeExpr \u003d fnInfo \u003d\u003d null ? null : fnInfo.getParameterType(argName);\n+                if (convention.isOptionalParameter(argName) || typeExpr !\u003d null \u0026\u0026 typeExpr.isOptionalArg()) {\n+                    arg.putBooleanProp(Node.IS_OPTIONAL_PARAM, true);\n+                }\n+                if (convention.isVarArgsParameter(arg, argName) || typeExpr !\u003d null \u0026\u0026 typeExpr.isVarArgs()) {\n+                    arg.putBooleanProp(Node.IS_VAR_ARGS_PARAM, true);\n+                }\n+            }\n+            break;\n+    }\n+}\n\\ No newline at end of file\n",
      "actualSource": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.NAME:\n        case Token.STRING:\n            if (convention.isConstant(n.getString())) {\n                n.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n            }\n            break;\n        case Token.FUNCTION:\n            JSDocInfo fnInfo \u003d n.getJSDocInfo();\n            if (fnInfo \u003d\u003d null) {\n                if (parent.getType() \u003d\u003d Token.ASSIGN) {\n                    fnInfo \u003d parent.getJSDocInfo();\n                } else if (parent.getType() \u003d\u003d Token.NAME) {\n                    fnInfo \u003d parent.getParent().getJSDocInfo();\n                }\n            }\n            Node args \u003d n.getFirstChild().getNext();\n            for (Node arg \u003d args.getFirstChild(); arg !\u003d null; arg \u003d arg.getNext()) {\n                String argName \u003d arg.getString();\n                JSTypeExpression typeExpr \u003d fnInfo \u003d\u003d null ? null : fnInfo.getParameterType(argName);\n                if (convention.isOptionalParameter(argName) || typeExpr !\u003d null \u0026\u0026 typeExpr.isOptionalArg()) {\n                    arg.putBooleanProp(Node.IS_OPTIONAL_PARAM, true);\n                }\n                if (convention.isVarArgsParameter(arg, argName) || typeExpr !\u003d null \u0026\u0026 typeExpr.isVarArgs()) {\n                    arg.putBooleanProp(Node.IS_VAR_ARGS_PARAM, true);\n                }\n            }\n            break;\n    }\n}",
      "path": "src/com/google/javascript/jscomp/CodingConventionAnnotator.java",
      "functionStartLine": 53,
      "functionName": "visit",
      "functionAnnotation": "@Override",
      "functionDoc": ""
    }
  }
}