{
  "origin": "codeshovel",
  "repositoryName": "Closure-74b",
  "repositoryPath": "/tmp/Closure-74b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "PeepholeFoldConstants.java",
  "functionName": "tryFoldAssign",
  "functionId": "tryFoldAssign___n-Node__left-Node__right-Node",
  "sourceFilePath": "src/com/google/javascript/jscomp/PeepholeFoldConstants.java",
  "functionAnnotation": "",
  "functionDoc": "",
  "functionStartLine": 450,
  "functionEndLine": 520,
  "numCommitsSeen": 54,
  "timeTaken": 5174,
  "changeHistory": [
    "35205c538a7d2f181dcf9d15b69538d9c533d7be",
    "e4d75597fbd25bab4291efcfd8b36be880258498",
    "9de5e9b4671773bb3f2d5932e57c1b4186b9b777",
    "c9e89727dc8063d087d28e42629606f4fd74a6e5",
    "45f2bdf91ad3c2f2ac901c72efe9e26148b08d2b",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3"
  ],
  "changeHistoryShort": {
    "35205c538a7d2f181dcf9d15b69538d9c533d7be": "Ybodychange",
    "e4d75597fbd25bab4291efcfd8b36be880258498": "Ybodychange",
    "9de5e9b4671773bb3f2d5932e57c1b4186b9b777": "Yformatchange",
    "c9e89727dc8063d087d28e42629606f4fd74a6e5": "Ymultichange(Ymovefromfile,Yreturntypechange,Ybodychange,Yparameterchange)",
    "45f2bdf91ad3c2f2ac901c72efe9e26148b08d2b": "Ybodychange",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "35205c538a7d2f181dcf9d15b69538d9c533d7be": {
      "type": "Ybodychange",
      "commitMessage": "\nFold assignments with commutative operators:\n\"x\u003d2|x\" becomes \"x|\u003d2\"\n\nR\u003dnicksantos\nDELTA\u003d19  (16 added, 0 deleted, 3 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d251\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@688 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "1/11/11, 4:50 PM",
      "commitName": "35205c538a7d2f181dcf9d15b69538d9c533d7be",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "1/11/11, 3:59 PM",
      "commitNameOld": "685443251d5be1186e0d8abf4ad1181153bebe01",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private Node tryFoldAssign(Node n, Node left, Node right) {\n    Preconditions.checkArgument(n.getType() \u003d\u003d Token.ASSIGN);\n    if (!right.hasChildren() || right.getFirstChild().getNext() !\u003d right.getLastChild()) {\n        return n;\n    }\n    if (mayHaveSideEffects(left)) {\n        return n;\n    }\n    Node newRight;\n    if (areNodesEqualForInlining(left, right.getFirstChild())) {\n        newRight \u003d right.getLastChild();\n    } else if (NodeUtil.isCommutative(right.getType()) \u0026\u0026 areNodesEqualForInlining(left, right.getLastChild())) {\n        newRight \u003d right.getFirstChild();\n    } else {\n        return n;\n    }\n    int newType \u003d -1;\n    switch(right.getType()) {\n        case Token.ADD:\n            newType \u003d Token.ASSIGN_ADD;\n            break;\n        case Token.BITAND:\n            newType \u003d Token.ASSIGN_BITAND;\n            break;\n        case Token.BITOR:\n            newType \u003d Token.ASSIGN_BITOR;\n            break;\n        case Token.BITXOR:\n            newType \u003d Token.ASSIGN_BITXOR;\n            break;\n        case Token.DIV:\n            newType \u003d Token.ASSIGN_DIV;\n            break;\n        case Token.LSH:\n            newType \u003d Token.ASSIGN_LSH;\n            break;\n        case Token.MOD:\n            newType \u003d Token.ASSIGN_MOD;\n            break;\n        case Token.MUL:\n            newType \u003d Token.ASSIGN_MUL;\n            break;\n        case Token.RSH:\n            newType \u003d Token.ASSIGN_RSH;\n            break;\n        case Token.SUB:\n            newType \u003d Token.ASSIGN_SUB;\n            break;\n        case Token.URSH:\n            newType \u003d Token.ASSIGN_URSH;\n            break;\n        default:\n            return n;\n    }\n    Node newNode \u003d new Node(newType, left.detachFromParent(), newRight.detachFromParent());\n    n.getParent().replaceChild(n, newNode);\n    reportCodeChange();\n    return newNode;\n}",
      "path": "src/com/google/javascript/jscomp/PeepholeFoldConstants.java",
      "functionStartLine": 325,
      "functionName": "tryFoldAssign",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,55 +1,59 @@\n private Node tryFoldAssign(Node n, Node left, Node right) {\n     Preconditions.checkArgument(n.getType() \u003d\u003d Token.ASSIGN);\n     if (!right.hasChildren() || right.getFirstChild().getNext() !\u003d right.getLastChild()) {\n         return n;\n     }\n     if (mayHaveSideEffects(left)) {\n         return n;\n     }\n-    Node leftChild \u003d right.getFirstChild();\n-    if (!areNodesEqualForInlining(left, leftChild)) {\n+    Node newRight;\n+    if (areNodesEqualForInlining(left, right.getFirstChild())) {\n+        newRight \u003d right.getLastChild();\n+    } else if (NodeUtil.isCommutative(right.getType()) \u0026\u0026 areNodesEqualForInlining(left, right.getLastChild())) {\n+        newRight \u003d right.getFirstChild();\n+    } else {\n         return n;\n     }\n     int newType \u003d -1;\n     switch(right.getType()) {\n         case Token.ADD:\n             newType \u003d Token.ASSIGN_ADD;\n             break;\n         case Token.BITAND:\n             newType \u003d Token.ASSIGN_BITAND;\n             break;\n         case Token.BITOR:\n             newType \u003d Token.ASSIGN_BITOR;\n             break;\n         case Token.BITXOR:\n             newType \u003d Token.ASSIGN_BITXOR;\n             break;\n         case Token.DIV:\n             newType \u003d Token.ASSIGN_DIV;\n             break;\n         case Token.LSH:\n             newType \u003d Token.ASSIGN_LSH;\n             break;\n         case Token.MOD:\n             newType \u003d Token.ASSIGN_MOD;\n             break;\n         case Token.MUL:\n             newType \u003d Token.ASSIGN_MUL;\n             break;\n         case Token.RSH:\n             newType \u003d Token.ASSIGN_RSH;\n             break;\n         case Token.SUB:\n             newType \u003d Token.ASSIGN_SUB;\n             break;\n         case Token.URSH:\n             newType \u003d Token.ASSIGN_URSH;\n             break;\n         default:\n             return n;\n     }\n-    Node newNode \u003d new Node(newType, left.detachFromParent(), right.getLastChild().detachFromParent());\n+    Node newNode \u003d new Node(newType, left.detachFromParent(), newRight.detachFromParent());\n     n.getParent().replaceChild(n, newNode);\n     reportCodeChange();\n     return newNode;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e4d75597fbd25bab4291efcfd8b36be880258498": {
      "type": "Ybodychange",
      "commitMessage": "\nUpdate passes to use the pass private mayHaveSideEffects call.\n\nR\u003ddcc\nDELTA\u003d7  (0 added, 0 deleted, 7 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d89005\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@333 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "8/4/10, 9:46 AM",
      "commitName": "e4d75597fbd25bab4291efcfd8b36be880258498",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "7/23/10, 2:49 PM",
      "commitNameOld": "f0362b1ab1ae1339e017b1d04f016980e3fa6cb6",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 11.79,
      "commitsBetweenForRepo": 24,
      "commitsBetweenForFile": 1,
      "actualSource": "private Node tryFoldAssign(Node n, Node left, Node right) {\n    Preconditions.checkArgument(n.getType() \u003d\u003d Token.ASSIGN);\n    if (!right.hasChildren() || right.getFirstChild().getNext() !\u003d right.getLastChild()) {\n        return n;\n    }\n    if (mayHaveSideEffects(left)) {\n        return n;\n    }\n    Node leftChild \u003d right.getFirstChild();\n    if (!areNodesEqualForInlining(left, leftChild)) {\n        return n;\n    }\n    int newType \u003d -1;\n    switch(right.getType()) {\n        case Token.ADD:\n            newType \u003d Token.ASSIGN_ADD;\n            break;\n        case Token.BITAND:\n            newType \u003d Token.ASSIGN_BITAND;\n            break;\n        case Token.BITOR:\n            newType \u003d Token.ASSIGN_BITOR;\n            break;\n        case Token.BITXOR:\n            newType \u003d Token.ASSIGN_BITXOR;\n            break;\n        case Token.DIV:\n            newType \u003d Token.ASSIGN_DIV;\n            break;\n        case Token.LSH:\n            newType \u003d Token.ASSIGN_LSH;\n            break;\n        case Token.MOD:\n            newType \u003d Token.ASSIGN_MOD;\n            break;\n        case Token.MUL:\n            newType \u003d Token.ASSIGN_MUL;\n            break;\n        case Token.RSH:\n            newType \u003d Token.ASSIGN_RSH;\n            break;\n        case Token.SUB:\n            newType \u003d Token.ASSIGN_SUB;\n            break;\n        case Token.URSH:\n            newType \u003d Token.ASSIGN_URSH;\n            break;\n        default:\n            return n;\n    }\n    Node newNode \u003d new Node(newType, left.detachFromParent(), right.getLastChild().detachFromParent());\n    n.getParent().replaceChild(n, newNode);\n    reportCodeChange();\n    return newNode;\n}",
      "path": "src/com/google/javascript/jscomp/PeepholeFoldConstants.java",
      "functionStartLine": 331,
      "functionName": "tryFoldAssign",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,55 +1,55 @@\n private Node tryFoldAssign(Node n, Node left, Node right) {\n     Preconditions.checkArgument(n.getType() \u003d\u003d Token.ASSIGN);\n     if (!right.hasChildren() || right.getFirstChild().getNext() !\u003d right.getLastChild()) {\n         return n;\n     }\n-    if (NodeUtil.mayHaveSideEffects(left)) {\n+    if (mayHaveSideEffects(left)) {\n         return n;\n     }\n     Node leftChild \u003d right.getFirstChild();\n     if (!areNodesEqualForInlining(left, leftChild)) {\n         return n;\n     }\n     int newType \u003d -1;\n     switch(right.getType()) {\n         case Token.ADD:\n             newType \u003d Token.ASSIGN_ADD;\n             break;\n         case Token.BITAND:\n             newType \u003d Token.ASSIGN_BITAND;\n             break;\n         case Token.BITOR:\n             newType \u003d Token.ASSIGN_BITOR;\n             break;\n         case Token.BITXOR:\n             newType \u003d Token.ASSIGN_BITXOR;\n             break;\n         case Token.DIV:\n             newType \u003d Token.ASSIGN_DIV;\n             break;\n         case Token.LSH:\n             newType \u003d Token.ASSIGN_LSH;\n             break;\n         case Token.MOD:\n             newType \u003d Token.ASSIGN_MOD;\n             break;\n         case Token.MUL:\n             newType \u003d Token.ASSIGN_MUL;\n             break;\n         case Token.RSH:\n             newType \u003d Token.ASSIGN_RSH;\n             break;\n         case Token.SUB:\n             newType \u003d Token.ASSIGN_SUB;\n             break;\n         case Token.URSH:\n             newType \u003d Token.ASSIGN_URSH;\n             break;\n         default:\n             return n;\n     }\n     Node newNode \u003d new Node(newType, left.detachFromParent(), right.getLastChild().detachFromParent());\n     n.getParent().replaceChild(n, newNode);\n     reportCodeChange();\n     return newNode;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9de5e9b4671773bb3f2d5932e57c1b4186b9b777": {
      "type": "Yformatchange",
      "commitMessage": "\nChange on 2010/06/30 15:06:33 by johnlenz\n\n\tAdd a diagnostic group so that projects with weird externs can opt-out of the stricter extern checks.\n\n\tR\u003dnicksantos\n\tDELTA\u003d54  (52 added, 0 deleted, 2 changed)\n\nChange on 2010/06/30 17:56:51 by johnlenz\n\n\tRevert warning levels until after a release is put out to control them.\n\n\tR\u003dnicksantos\n\tDELTA\u003d4  (2 added, 0 deleted, 2 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d47002\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@260 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "7/1/10, 7:38 AM",
      "commitName": "9de5e9b4671773bb3f2d5932e57c1b4186b9b777",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "6/28/10, 5:30 PM",
      "commitNameOld": "9925370292834ea846727f1f9db76af0d40261df",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 2.59,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "private Node tryFoldAssign(Node n, Node left, Node right) {\n    Preconditions.checkArgument(n.getType() \u003d\u003d Token.ASSIGN);\n    if (!right.hasChildren() || right.getFirstChild().getNext() !\u003d right.getLastChild()) {\n        return n;\n    }\n    if (NodeUtil.mayHaveSideEffects(left)) {\n        return n;\n    }\n    Node leftChild \u003d right.getFirstChild();\n    if (!areNodesEqualForInlining(left, leftChild)) {\n        return n;\n    }\n    int newType \u003d -1;\n    switch(right.getType()) {\n        case Token.ADD:\n            newType \u003d Token.ASSIGN_ADD;\n            break;\n        case Token.BITAND:\n            newType \u003d Token.ASSIGN_BITAND;\n            break;\n        case Token.BITOR:\n            newType \u003d Token.ASSIGN_BITOR;\n            break;\n        case Token.BITXOR:\n            newType \u003d Token.ASSIGN_BITXOR;\n            break;\n        case Token.DIV:\n            newType \u003d Token.ASSIGN_DIV;\n            break;\n        case Token.LSH:\n            newType \u003d Token.ASSIGN_LSH;\n            break;\n        case Token.MOD:\n            newType \u003d Token.ASSIGN_MOD;\n            break;\n        case Token.MUL:\n            newType \u003d Token.ASSIGN_MUL;\n            break;\n        case Token.RSH:\n            newType \u003d Token.ASSIGN_RSH;\n            break;\n        case Token.SUB:\n            newType \u003d Token.ASSIGN_SUB;\n            break;\n        case Token.URSH:\n            newType \u003d Token.ASSIGN_URSH;\n            break;\n        default:\n            return n;\n    }\n    Node newNode \u003d new Node(newType, left.detachFromParent(), right.getLastChild().detachFromParent());\n    n.getParent().replaceChild(n, newNode);\n    reportCodeChange();\n    return newNode;\n}",
      "path": "src/com/google/javascript/jscomp/PeepholeFoldConstants.java",
      "functionStartLine": 325,
      "functionName": "tryFoldAssign",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {}
    },
    "c9e89727dc8063d087d28e42629606f4fd74a6e5": {
      "type": "Ymultichange(Ymovefromfile,Yreturntypechange,Ybodychange,Yparameterchange)",
      "commitMessage": "\nChange on 2010/06/22 by nicksantos\n\n\tvariable coalescing better be run AFTER ambiguate properties, and\n\tafter denormalization.\n\n\tR\u003djohnlenz\n\tDELTA\u003d36  (20 added, 16 deleted, 0 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d34005\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@248 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "6/22/10, 4:00 PM",
      "commitName": "c9e89727dc8063d087d28e42629606f4fd74a6e5",
      "commitAuthor": "Nicholas.J.Santos",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "\nChange on 2010/06/22 by nicksantos\n\n\tvariable coalescing better be run AFTER ambiguate properties, and\n\tafter denormalization.\n\n\tR\u003djohnlenz\n\tDELTA\u003d36  (20 added, 16 deleted, 0 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d34005\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@248 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "6/22/10, 4:00 PM",
          "commitName": "c9e89727dc8063d087d28e42629606f4fd74a6e5",
          "commitAuthor": "Nicholas.J.Santos",
          "commitDateOld": "6/21/10, 12:59 PM",
          "commitNameOld": "5f09a76531fb4f6e182238411017e6fc7e74ad16",
          "commitAuthorOld": "Nicholas.J.Santos",
          "daysBetweenCommits": 1.13,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "private Node tryFoldAssign(Node n, Node left, Node right) {\n    Preconditions.checkArgument(n.getType() \u003d\u003d Token.ASSIGN);\n    if (!right.hasChildren() || right.getFirstChild().getNext() !\u003d right.getLastChild()) {\n        return n;\n    }\n    if (NodeUtil.mayHaveSideEffects(left)) {\n        return n;\n    }\n    Node leftChild \u003d right.getFirstChild();\n    if (!areNodesEqualForInlining(left, leftChild)) {\n        return n;\n    }\n    int newType \u003d -1;\n    switch(right.getType()) {\n        case Token.ADD:\n            newType \u003d Token.ASSIGN_ADD;\n            break;\n        case Token.BITAND:\n            newType \u003d Token.ASSIGN_BITAND;\n            break;\n        case Token.BITOR:\n            newType \u003d Token.ASSIGN_BITOR;\n            break;\n        case Token.BITXOR:\n            newType \u003d Token.ASSIGN_BITXOR;\n            break;\n        case Token.DIV:\n            newType \u003d Token.ASSIGN_DIV;\n            break;\n        case Token.LSH:\n            newType \u003d Token.ASSIGN_LSH;\n            break;\n        case Token.MOD:\n            newType \u003d Token.ASSIGN_MOD;\n            break;\n        case Token.MUL:\n            newType \u003d Token.ASSIGN_MUL;\n            break;\n        case Token.RSH:\n            newType \u003d Token.ASSIGN_RSH;\n            break;\n        case Token.SUB:\n            newType \u003d Token.ASSIGN_SUB;\n            break;\n        case Token.URSH:\n            newType \u003d Token.ASSIGN_URSH;\n            break;\n        default:\n            return n;\n    }\n    Node newNode \u003d new Node(newType, left.detachFromParent(), right.getLastChild().detachFromParent());\n    n.getParent().replaceChild(n, newNode);\n    reportCodeChange();\n    return newNode;\n}",
          "path": "src/com/google/javascript/jscomp/PeepholeFoldConstants.java",
          "functionStartLine": 318,
          "functionName": "tryFoldAssign",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,53 +1,55 @@\n-private void tryFoldAssign(NodeTraversal t, Node n, Node left, Node right) {\n+private Node tryFoldAssign(Node n, Node left, Node right) {\n     Preconditions.checkArgument(n.getType() \u003d\u003d Token.ASSIGN);\n     if (!right.hasChildren() || right.getFirstChild().getNext() !\u003d right.getLastChild()) {\n-        return;\n+        return n;\n     }\n     if (NodeUtil.mayHaveSideEffects(left)) {\n-        return;\n+        return n;\n     }\n     Node leftChild \u003d right.getFirstChild();\n-    if (!compiler.areNodesEqualForInlining(left, leftChild)) {\n-        return;\n+    if (!areNodesEqualForInlining(left, leftChild)) {\n+        return n;\n     }\n     int newType \u003d -1;\n     switch(right.getType()) {\n         case Token.ADD:\n             newType \u003d Token.ASSIGN_ADD;\n             break;\n         case Token.BITAND:\n             newType \u003d Token.ASSIGN_BITAND;\n             break;\n         case Token.BITOR:\n             newType \u003d Token.ASSIGN_BITOR;\n             break;\n         case Token.BITXOR:\n             newType \u003d Token.ASSIGN_BITXOR;\n             break;\n         case Token.DIV:\n             newType \u003d Token.ASSIGN_DIV;\n             break;\n         case Token.LSH:\n             newType \u003d Token.ASSIGN_LSH;\n             break;\n         case Token.MOD:\n             newType \u003d Token.ASSIGN_MOD;\n             break;\n         case Token.MUL:\n             newType \u003d Token.ASSIGN_MUL;\n             break;\n         case Token.RSH:\n             newType \u003d Token.ASSIGN_RSH;\n             break;\n         case Token.SUB:\n             newType \u003d Token.ASSIGN_SUB;\n             break;\n         case Token.URSH:\n             newType \u003d Token.ASSIGN_URSH;\n             break;\n         default:\n-            return;\n+            return n;\n     }\n-    n.getParent().replaceChild(n, new Node(newType, left.detachFromParent(), right.getLastChild().detachFromParent()));\n-    t.getCompiler().reportCodeChange();\n+    Node newNode \u003d new Node(newType, left.detachFromParent(), right.getLastChild().detachFromParent());\n+    n.getParent().replaceChild(n, newNode);\n+    reportCodeChange();\n+    return newNode;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldPath": "src/com/google/javascript/jscomp/FoldConstants.java",
            "newPath": "src/com/google/javascript/jscomp/PeepholeFoldConstants.java",
            "oldMethodName": "tryFoldAssign",
            "newMethodName": "tryFoldAssign"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "\nChange on 2010/06/22 by nicksantos\n\n\tvariable coalescing better be run AFTER ambiguate properties, and\n\tafter denormalization.\n\n\tR\u003djohnlenz\n\tDELTA\u003d36  (20 added, 16 deleted, 0 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d34005\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@248 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "6/22/10, 4:00 PM",
          "commitName": "c9e89727dc8063d087d28e42629606f4fd74a6e5",
          "commitAuthor": "Nicholas.J.Santos",
          "commitDateOld": "6/21/10, 12:59 PM",
          "commitNameOld": "5f09a76531fb4f6e182238411017e6fc7e74ad16",
          "commitAuthorOld": "Nicholas.J.Santos",
          "daysBetweenCommits": 1.13,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "private Node tryFoldAssign(Node n, Node left, Node right) {\n    Preconditions.checkArgument(n.getType() \u003d\u003d Token.ASSIGN);\n    if (!right.hasChildren() || right.getFirstChild().getNext() !\u003d right.getLastChild()) {\n        return n;\n    }\n    if (NodeUtil.mayHaveSideEffects(left)) {\n        return n;\n    }\n    Node leftChild \u003d right.getFirstChild();\n    if (!areNodesEqualForInlining(left, leftChild)) {\n        return n;\n    }\n    int newType \u003d -1;\n    switch(right.getType()) {\n        case Token.ADD:\n            newType \u003d Token.ASSIGN_ADD;\n            break;\n        case Token.BITAND:\n            newType \u003d Token.ASSIGN_BITAND;\n            break;\n        case Token.BITOR:\n            newType \u003d Token.ASSIGN_BITOR;\n            break;\n        case Token.BITXOR:\n            newType \u003d Token.ASSIGN_BITXOR;\n            break;\n        case Token.DIV:\n            newType \u003d Token.ASSIGN_DIV;\n            break;\n        case Token.LSH:\n            newType \u003d Token.ASSIGN_LSH;\n            break;\n        case Token.MOD:\n            newType \u003d Token.ASSIGN_MOD;\n            break;\n        case Token.MUL:\n            newType \u003d Token.ASSIGN_MUL;\n            break;\n        case Token.RSH:\n            newType \u003d Token.ASSIGN_RSH;\n            break;\n        case Token.SUB:\n            newType \u003d Token.ASSIGN_SUB;\n            break;\n        case Token.URSH:\n            newType \u003d Token.ASSIGN_URSH;\n            break;\n        default:\n            return n;\n    }\n    Node newNode \u003d new Node(newType, left.detachFromParent(), right.getLastChild().detachFromParent());\n    n.getParent().replaceChild(n, newNode);\n    reportCodeChange();\n    return newNode;\n}",
          "path": "src/com/google/javascript/jscomp/PeepholeFoldConstants.java",
          "functionStartLine": 318,
          "functionName": "tryFoldAssign",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,53 +1,55 @@\n-private void tryFoldAssign(NodeTraversal t, Node n, Node left, Node right) {\n+private Node tryFoldAssign(Node n, Node left, Node right) {\n     Preconditions.checkArgument(n.getType() \u003d\u003d Token.ASSIGN);\n     if (!right.hasChildren() || right.getFirstChild().getNext() !\u003d right.getLastChild()) {\n-        return;\n+        return n;\n     }\n     if (NodeUtil.mayHaveSideEffects(left)) {\n-        return;\n+        return n;\n     }\n     Node leftChild \u003d right.getFirstChild();\n-    if (!compiler.areNodesEqualForInlining(left, leftChild)) {\n-        return;\n+    if (!areNodesEqualForInlining(left, leftChild)) {\n+        return n;\n     }\n     int newType \u003d -1;\n     switch(right.getType()) {\n         case Token.ADD:\n             newType \u003d Token.ASSIGN_ADD;\n             break;\n         case Token.BITAND:\n             newType \u003d Token.ASSIGN_BITAND;\n             break;\n         case Token.BITOR:\n             newType \u003d Token.ASSIGN_BITOR;\n             break;\n         case Token.BITXOR:\n             newType \u003d Token.ASSIGN_BITXOR;\n             break;\n         case Token.DIV:\n             newType \u003d Token.ASSIGN_DIV;\n             break;\n         case Token.LSH:\n             newType \u003d Token.ASSIGN_LSH;\n             break;\n         case Token.MOD:\n             newType \u003d Token.ASSIGN_MOD;\n             break;\n         case Token.MUL:\n             newType \u003d Token.ASSIGN_MUL;\n             break;\n         case Token.RSH:\n             newType \u003d Token.ASSIGN_RSH;\n             break;\n         case Token.SUB:\n             newType \u003d Token.ASSIGN_SUB;\n             break;\n         case Token.URSH:\n             newType \u003d Token.ASSIGN_URSH;\n             break;\n         default:\n-            return;\n+            return n;\n     }\n-    n.getParent().replaceChild(n, new Node(newType, left.detachFromParent(), right.getLastChild().detachFromParent()));\n-    t.getCompiler().reportCodeChange();\n+    Node newNode \u003d new Node(newType, left.detachFromParent(), right.getLastChild().detachFromParent());\n+    n.getParent().replaceChild(n, newNode);\n+    reportCodeChange();\n+    return newNode;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "void",
            "newValue": "Node"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "\nChange on 2010/06/22 by nicksantos\n\n\tvariable coalescing better be run AFTER ambiguate properties, and\n\tafter denormalization.\n\n\tR\u003djohnlenz\n\tDELTA\u003d36  (20 added, 16 deleted, 0 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d34005\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@248 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "6/22/10, 4:00 PM",
          "commitName": "c9e89727dc8063d087d28e42629606f4fd74a6e5",
          "commitAuthor": "Nicholas.J.Santos",
          "commitDateOld": "6/21/10, 12:59 PM",
          "commitNameOld": "5f09a76531fb4f6e182238411017e6fc7e74ad16",
          "commitAuthorOld": "Nicholas.J.Santos",
          "daysBetweenCommits": 1.13,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "private Node tryFoldAssign(Node n, Node left, Node right) {\n    Preconditions.checkArgument(n.getType() \u003d\u003d Token.ASSIGN);\n    if (!right.hasChildren() || right.getFirstChild().getNext() !\u003d right.getLastChild()) {\n        return n;\n    }\n    if (NodeUtil.mayHaveSideEffects(left)) {\n        return n;\n    }\n    Node leftChild \u003d right.getFirstChild();\n    if (!areNodesEqualForInlining(left, leftChild)) {\n        return n;\n    }\n    int newType \u003d -1;\n    switch(right.getType()) {\n        case Token.ADD:\n            newType \u003d Token.ASSIGN_ADD;\n            break;\n        case Token.BITAND:\n            newType \u003d Token.ASSIGN_BITAND;\n            break;\n        case Token.BITOR:\n            newType \u003d Token.ASSIGN_BITOR;\n            break;\n        case Token.BITXOR:\n            newType \u003d Token.ASSIGN_BITXOR;\n            break;\n        case Token.DIV:\n            newType \u003d Token.ASSIGN_DIV;\n            break;\n        case Token.LSH:\n            newType \u003d Token.ASSIGN_LSH;\n            break;\n        case Token.MOD:\n            newType \u003d Token.ASSIGN_MOD;\n            break;\n        case Token.MUL:\n            newType \u003d Token.ASSIGN_MUL;\n            break;\n        case Token.RSH:\n            newType \u003d Token.ASSIGN_RSH;\n            break;\n        case Token.SUB:\n            newType \u003d Token.ASSIGN_SUB;\n            break;\n        case Token.URSH:\n            newType \u003d Token.ASSIGN_URSH;\n            break;\n        default:\n            return n;\n    }\n    Node newNode \u003d new Node(newType, left.detachFromParent(), right.getLastChild().detachFromParent());\n    n.getParent().replaceChild(n, newNode);\n    reportCodeChange();\n    return newNode;\n}",
          "path": "src/com/google/javascript/jscomp/PeepholeFoldConstants.java",
          "functionStartLine": 318,
          "functionName": "tryFoldAssign",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,53 +1,55 @@\n-private void tryFoldAssign(NodeTraversal t, Node n, Node left, Node right) {\n+private Node tryFoldAssign(Node n, Node left, Node right) {\n     Preconditions.checkArgument(n.getType() \u003d\u003d Token.ASSIGN);\n     if (!right.hasChildren() || right.getFirstChild().getNext() !\u003d right.getLastChild()) {\n-        return;\n+        return n;\n     }\n     if (NodeUtil.mayHaveSideEffects(left)) {\n-        return;\n+        return n;\n     }\n     Node leftChild \u003d right.getFirstChild();\n-    if (!compiler.areNodesEqualForInlining(left, leftChild)) {\n-        return;\n+    if (!areNodesEqualForInlining(left, leftChild)) {\n+        return n;\n     }\n     int newType \u003d -1;\n     switch(right.getType()) {\n         case Token.ADD:\n             newType \u003d Token.ASSIGN_ADD;\n             break;\n         case Token.BITAND:\n             newType \u003d Token.ASSIGN_BITAND;\n             break;\n         case Token.BITOR:\n             newType \u003d Token.ASSIGN_BITOR;\n             break;\n         case Token.BITXOR:\n             newType \u003d Token.ASSIGN_BITXOR;\n             break;\n         case Token.DIV:\n             newType \u003d Token.ASSIGN_DIV;\n             break;\n         case Token.LSH:\n             newType \u003d Token.ASSIGN_LSH;\n             break;\n         case Token.MOD:\n             newType \u003d Token.ASSIGN_MOD;\n             break;\n         case Token.MUL:\n             newType \u003d Token.ASSIGN_MUL;\n             break;\n         case Token.RSH:\n             newType \u003d Token.ASSIGN_RSH;\n             break;\n         case Token.SUB:\n             newType \u003d Token.ASSIGN_SUB;\n             break;\n         case Token.URSH:\n             newType \u003d Token.ASSIGN_URSH;\n             break;\n         default:\n-            return;\n+            return n;\n     }\n-    n.getParent().replaceChild(n, new Node(newType, left.detachFromParent(), right.getLastChild().detachFromParent()));\n-    t.getCompiler().reportCodeChange();\n+    Node newNode \u003d new Node(newType, left.detachFromParent(), right.getLastChild().detachFromParent());\n+    n.getParent().replaceChild(n, newNode);\n+    reportCodeChange();\n+    return newNode;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "\nChange on 2010/06/22 by nicksantos\n\n\tvariable coalescing better be run AFTER ambiguate properties, and\n\tafter denormalization.\n\n\tR\u003djohnlenz\n\tDELTA\u003d36  (20 added, 16 deleted, 0 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d34005\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@248 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "6/22/10, 4:00 PM",
          "commitName": "c9e89727dc8063d087d28e42629606f4fd74a6e5",
          "commitAuthor": "Nicholas.J.Santos",
          "commitDateOld": "6/21/10, 12:59 PM",
          "commitNameOld": "5f09a76531fb4f6e182238411017e6fc7e74ad16",
          "commitAuthorOld": "Nicholas.J.Santos",
          "daysBetweenCommits": 1.13,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "private Node tryFoldAssign(Node n, Node left, Node right) {\n    Preconditions.checkArgument(n.getType() \u003d\u003d Token.ASSIGN);\n    if (!right.hasChildren() || right.getFirstChild().getNext() !\u003d right.getLastChild()) {\n        return n;\n    }\n    if (NodeUtil.mayHaveSideEffects(left)) {\n        return n;\n    }\n    Node leftChild \u003d right.getFirstChild();\n    if (!areNodesEqualForInlining(left, leftChild)) {\n        return n;\n    }\n    int newType \u003d -1;\n    switch(right.getType()) {\n        case Token.ADD:\n            newType \u003d Token.ASSIGN_ADD;\n            break;\n        case Token.BITAND:\n            newType \u003d Token.ASSIGN_BITAND;\n            break;\n        case Token.BITOR:\n            newType \u003d Token.ASSIGN_BITOR;\n            break;\n        case Token.BITXOR:\n            newType \u003d Token.ASSIGN_BITXOR;\n            break;\n        case Token.DIV:\n            newType \u003d Token.ASSIGN_DIV;\n            break;\n        case Token.LSH:\n            newType \u003d Token.ASSIGN_LSH;\n            break;\n        case Token.MOD:\n            newType \u003d Token.ASSIGN_MOD;\n            break;\n        case Token.MUL:\n            newType \u003d Token.ASSIGN_MUL;\n            break;\n        case Token.RSH:\n            newType \u003d Token.ASSIGN_RSH;\n            break;\n        case Token.SUB:\n            newType \u003d Token.ASSIGN_SUB;\n            break;\n        case Token.URSH:\n            newType \u003d Token.ASSIGN_URSH;\n            break;\n        default:\n            return n;\n    }\n    Node newNode \u003d new Node(newType, left.detachFromParent(), right.getLastChild().detachFromParent());\n    n.getParent().replaceChild(n, newNode);\n    reportCodeChange();\n    return newNode;\n}",
          "path": "src/com/google/javascript/jscomp/PeepholeFoldConstants.java",
          "functionStartLine": 318,
          "functionName": "tryFoldAssign",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,53 +1,55 @@\n-private void tryFoldAssign(NodeTraversal t, Node n, Node left, Node right) {\n+private Node tryFoldAssign(Node n, Node left, Node right) {\n     Preconditions.checkArgument(n.getType() \u003d\u003d Token.ASSIGN);\n     if (!right.hasChildren() || right.getFirstChild().getNext() !\u003d right.getLastChild()) {\n-        return;\n+        return n;\n     }\n     if (NodeUtil.mayHaveSideEffects(left)) {\n-        return;\n+        return n;\n     }\n     Node leftChild \u003d right.getFirstChild();\n-    if (!compiler.areNodesEqualForInlining(left, leftChild)) {\n-        return;\n+    if (!areNodesEqualForInlining(left, leftChild)) {\n+        return n;\n     }\n     int newType \u003d -1;\n     switch(right.getType()) {\n         case Token.ADD:\n             newType \u003d Token.ASSIGN_ADD;\n             break;\n         case Token.BITAND:\n             newType \u003d Token.ASSIGN_BITAND;\n             break;\n         case Token.BITOR:\n             newType \u003d Token.ASSIGN_BITOR;\n             break;\n         case Token.BITXOR:\n             newType \u003d Token.ASSIGN_BITXOR;\n             break;\n         case Token.DIV:\n             newType \u003d Token.ASSIGN_DIV;\n             break;\n         case Token.LSH:\n             newType \u003d Token.ASSIGN_LSH;\n             break;\n         case Token.MOD:\n             newType \u003d Token.ASSIGN_MOD;\n             break;\n         case Token.MUL:\n             newType \u003d Token.ASSIGN_MUL;\n             break;\n         case Token.RSH:\n             newType \u003d Token.ASSIGN_RSH;\n             break;\n         case Token.SUB:\n             newType \u003d Token.ASSIGN_SUB;\n             break;\n         case Token.URSH:\n             newType \u003d Token.ASSIGN_URSH;\n             break;\n         default:\n-            return;\n+            return n;\n     }\n-    n.getParent().replaceChild(n, new Node(newType, left.detachFromParent(), right.getLastChild().detachFromParent()));\n-    t.getCompiler().reportCodeChange();\n+    Node newNode \u003d new Node(newType, left.detachFromParent(), right.getLastChild().detachFromParent());\n+    n.getParent().replaceChild(n, newNode);\n+    reportCodeChange();\n+    return newNode;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[t-NodeTraversal, n-Node, left-Node, right-Node]",
            "newValue": "[n-Node, left-Node, right-Node]"
          }
        }
      ]
    },
    "45f2bdf91ad3c2f2ac901c72efe9e26148b08d2b": {
      "type": "Ybodychange",
      "commitMessage": "Fix a bunch of passes to preserve more type information.\n\nFix goog.provide/goog.require handling to work in the presence of modules.\n\nImprove a bunch of type annotations in gecko_dom.\n\nMake NameAnalyzer use the Graph package.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@95 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "2/8/10, 11:30 AM",
      "commitName": "45f2bdf91ad3c2f2ac901c72efe9e26148b08d2b",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "12/16/09, 6:37 PM",
      "commitNameOld": "06377401a3b08af2cc75c10e603b3ded983aaf8c",
      "commitAuthorOld": "nicholas.j.santos@gmail.com",
      "daysBetweenCommits": 53.7,
      "commitsBetweenForRepo": 45,
      "commitsBetweenForFile": 1,
      "actualSource": "private void tryFoldAssign(NodeTraversal t, Node n, Node left, Node right) {\n    Preconditions.checkArgument(n.getType() \u003d\u003d Token.ASSIGN);\n    if (!right.hasChildren() || right.getFirstChild().getNext() !\u003d right.getLastChild()) {\n        return;\n    }\n    if (NodeUtil.mayHaveSideEffects(left)) {\n        return;\n    }\n    Node leftChild \u003d right.getFirstChild();\n    if (!compiler.areNodesEqualForInlining(left, leftChild)) {\n        return;\n    }\n    int newType \u003d -1;\n    switch(right.getType()) {\n        case Token.ADD:\n            newType \u003d Token.ASSIGN_ADD;\n            break;\n        case Token.BITAND:\n            newType \u003d Token.ASSIGN_BITAND;\n            break;\n        case Token.BITOR:\n            newType \u003d Token.ASSIGN_BITOR;\n            break;\n        case Token.BITXOR:\n            newType \u003d Token.ASSIGN_BITXOR;\n            break;\n        case Token.DIV:\n            newType \u003d Token.ASSIGN_DIV;\n            break;\n        case Token.LSH:\n            newType \u003d Token.ASSIGN_LSH;\n            break;\n        case Token.MOD:\n            newType \u003d Token.ASSIGN_MOD;\n            break;\n        case Token.MUL:\n            newType \u003d Token.ASSIGN_MUL;\n            break;\n        case Token.RSH:\n            newType \u003d Token.ASSIGN_RSH;\n            break;\n        case Token.SUB:\n            newType \u003d Token.ASSIGN_SUB;\n            break;\n        case Token.URSH:\n            newType \u003d Token.ASSIGN_URSH;\n            break;\n        default:\n            return;\n    }\n    n.getParent().replaceChild(n, new Node(newType, left.detachFromParent(), right.getLastChild().detachFromParent()));\n    t.getCompiler().reportCodeChange();\n}",
      "path": "src/com/google/javascript/jscomp/FoldConstants.java",
      "functionStartLine": 412,
      "functionName": "tryFoldAssign",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,53 +1,53 @@\n private void tryFoldAssign(NodeTraversal t, Node n, Node left, Node right) {\n     Preconditions.checkArgument(n.getType() \u003d\u003d Token.ASSIGN);\n     if (!right.hasChildren() || right.getFirstChild().getNext() !\u003d right.getLastChild()) {\n         return;\n     }\n     if (NodeUtil.mayHaveSideEffects(left)) {\n         return;\n     }\n     Node leftChild \u003d right.getFirstChild();\n-    if (!left.checkTreeEqualsSilent(leftChild)) {\n+    if (!compiler.areNodesEqualForInlining(left, leftChild)) {\n         return;\n     }\n     int newType \u003d -1;\n     switch(right.getType()) {\n         case Token.ADD:\n             newType \u003d Token.ASSIGN_ADD;\n             break;\n         case Token.BITAND:\n             newType \u003d Token.ASSIGN_BITAND;\n             break;\n         case Token.BITOR:\n             newType \u003d Token.ASSIGN_BITOR;\n             break;\n         case Token.BITXOR:\n             newType \u003d Token.ASSIGN_BITXOR;\n             break;\n         case Token.DIV:\n             newType \u003d Token.ASSIGN_DIV;\n             break;\n         case Token.LSH:\n             newType \u003d Token.ASSIGN_LSH;\n             break;\n         case Token.MOD:\n             newType \u003d Token.ASSIGN_MOD;\n             break;\n         case Token.MUL:\n             newType \u003d Token.ASSIGN_MUL;\n             break;\n         case Token.RSH:\n             newType \u003d Token.ASSIGN_RSH;\n             break;\n         case Token.SUB:\n             newType \u003d Token.ASSIGN_SUB;\n             break;\n         case Token.URSH:\n             newType \u003d Token.ASSIGN_URSH;\n             break;\n         default:\n             return;\n     }\n     n.getParent().replaceChild(n, new Node(newType, left.detachFromParent(), right.getLastChild().detachFromParent()));\n     t.getCompiler().reportCodeChange();\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": {
      "type": "Yintroduced",
      "commitMessage": "Initial commit.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/3/09, 3:51 PM",
      "commitName": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "diff": "@@ -0,0 +1,53 @@\n+private void tryFoldAssign(NodeTraversal t, Node n, Node left, Node right) {\n+    Preconditions.checkArgument(n.getType() \u003d\u003d Token.ASSIGN);\n+    if (!right.hasChildren() || right.getFirstChild().getNext() !\u003d right.getLastChild()) {\n+        return;\n+    }\n+    if (NodeUtil.mayHaveSideEffects(left)) {\n+        return;\n+    }\n+    Node leftChild \u003d right.getFirstChild();\n+    if (!left.checkTreeEqualsSilent(leftChild)) {\n+        return;\n+    }\n+    int newType \u003d -1;\n+    switch(right.getType()) {\n+        case Token.ADD:\n+            newType \u003d Token.ASSIGN_ADD;\n+            break;\n+        case Token.BITAND:\n+            newType \u003d Token.ASSIGN_BITAND;\n+            break;\n+        case Token.BITOR:\n+            newType \u003d Token.ASSIGN_BITOR;\n+            break;\n+        case Token.BITXOR:\n+            newType \u003d Token.ASSIGN_BITXOR;\n+            break;\n+        case Token.DIV:\n+            newType \u003d Token.ASSIGN_DIV;\n+            break;\n+        case Token.LSH:\n+            newType \u003d Token.ASSIGN_LSH;\n+            break;\n+        case Token.MOD:\n+            newType \u003d Token.ASSIGN_MOD;\n+            break;\n+        case Token.MUL:\n+            newType \u003d Token.ASSIGN_MUL;\n+            break;\n+        case Token.RSH:\n+            newType \u003d Token.ASSIGN_RSH;\n+            break;\n+        case Token.SUB:\n+            newType \u003d Token.ASSIGN_SUB;\n+            break;\n+        case Token.URSH:\n+            newType \u003d Token.ASSIGN_URSH;\n+            break;\n+        default:\n+            return;\n+    }\n+    n.getParent().replaceChild(n, new Node(newType, left.detachFromParent(), right.getLastChild().detachFromParent()));\n+    t.getCompiler().reportCodeChange();\n+}\n\\ No newline at end of file\n",
      "actualSource": "private void tryFoldAssign(NodeTraversal t, Node n, Node left, Node right) {\n    Preconditions.checkArgument(n.getType() \u003d\u003d Token.ASSIGN);\n    if (!right.hasChildren() || right.getFirstChild().getNext() !\u003d right.getLastChild()) {\n        return;\n    }\n    if (NodeUtil.mayHaveSideEffects(left)) {\n        return;\n    }\n    Node leftChild \u003d right.getFirstChild();\n    if (!left.checkTreeEqualsSilent(leftChild)) {\n        return;\n    }\n    int newType \u003d -1;\n    switch(right.getType()) {\n        case Token.ADD:\n            newType \u003d Token.ASSIGN_ADD;\n            break;\n        case Token.BITAND:\n            newType \u003d Token.ASSIGN_BITAND;\n            break;\n        case Token.BITOR:\n            newType \u003d Token.ASSIGN_BITOR;\n            break;\n        case Token.BITXOR:\n            newType \u003d Token.ASSIGN_BITXOR;\n            break;\n        case Token.DIV:\n            newType \u003d Token.ASSIGN_DIV;\n            break;\n        case Token.LSH:\n            newType \u003d Token.ASSIGN_LSH;\n            break;\n        case Token.MOD:\n            newType \u003d Token.ASSIGN_MOD;\n            break;\n        case Token.MUL:\n            newType \u003d Token.ASSIGN_MUL;\n            break;\n        case Token.RSH:\n            newType \u003d Token.ASSIGN_RSH;\n            break;\n        case Token.SUB:\n            newType \u003d Token.ASSIGN_SUB;\n            break;\n        case Token.URSH:\n            newType \u003d Token.ASSIGN_URSH;\n            break;\n        default:\n            return;\n    }\n    n.getParent().replaceChild(n, new Node(newType, left.detachFromParent(), right.getLastChild().detachFromParent()));\n    t.getCompiler().reportCodeChange();\n}",
      "path": "src/com/google/javascript/jscomp/FoldConstants.java",
      "functionStartLine": 408,
      "functionName": "tryFoldAssign",
      "functionAnnotation": "",
      "functionDoc": ""
    }
  }
}