{
  "origin": "codeshovel",
  "repositoryName": "Closure-115b",
  "repositoryPath": "/tmp/Closure-115b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "InlineFunctions.java",
  "functionName": "maybeAddReferenceUsingMode",
  "functionId": "$maybeAddReferenceUsingMode___t-NodeTraversal__fs-FunctionState__callNode-Node__module-JSModule__mode-InliningMode",
  "sourceFilePath": "src/com/google/javascript/jscomp/InlineFunctions.java",
  "functionAnnotation": "",
  "functionDoc": "",
  "functionStartLine": 515,
  "functionEndLine": 542,
  "numCommitsSeen": 43,
  "timeTaken": 2177,
  "changeHistory": [
    "98a487531ce3d6555851398daead0471b5932774",
    "44e59948342527c9d8ffc6f2b01d86af72aaef54",
    "b4801b28ceea8db0f63da7440d6769cb9b7cce8a",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3"
  ],
  "changeHistoryShort": {
    "98a487531ce3d6555851398daead0471b5932774": "Ybodychange",
    "44e59948342527c9d8ffc6f2b01d86af72aaef54": "Ybodychange",
    "b4801b28ceea8db0f63da7440d6769cb9b7cce8a": "Ybodychange",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "98a487531ce3d6555851398daead0471b5932774": {
      "type": "Ybodychange",
      "commitMessage": "\nFix incosistent internal state caused by when multiple functions are\ninlined into the same expression.\n\nR\u003dnicksantos\nDELTA\u003d300  (131 added, 51 deleted, 118 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d5029\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2052 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "6/18/12, 9:58 AM",
      "commitName": "98a487531ce3d6555851398daead0471b5932774",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "5/18/12, 11:09 AM",
      "commitNameOld": "70a5626922ea7e8c98747e22b6986638ba38fadc",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 30.95,
      "commitsBetweenForRepo": 73,
      "commitsBetweenForFile": 1,
      "actualSource": "private boolean maybeAddReferenceUsingMode(NodeTraversal t, FunctionState fs, Node callNode, JSModule module, InliningMode mode) {\n    if (specializationState !\u003d null) {\n        Node containingFunction \u003d getContainingFunction(t);\n        if (containingFunction !\u003d null \u0026\u0026 !specializationState.canFixupFunction(containingFunction)) {\n            return false;\n        }\n    }\n    CanInlineResult result \u003d injector.canInlineReferenceToFunction(t, callNode, fs.getFn().getFunctionNode(), fs.getNamesToAlias(), mode, fs.getReferencesThis(), fs.hasInnerFunctions());\n    if (result !\u003d CanInlineResult.NO) {\n        boolean decompose \u003d (result \u003d\u003d CanInlineResult.AFTER_PREPARATION);\n        fs.addReference(new Reference(callNode, module, mode, decompose));\n        return true;\n    }\n    return false;\n}",
      "path": "src/com/google/javascript/jscomp/InlineFunctions.java",
      "functionStartLine": 517,
      "functionName": "maybeAddReferenceUsingMode",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,15 +1,15 @@\n private boolean maybeAddReferenceUsingMode(NodeTraversal t, FunctionState fs, Node callNode, JSModule module, InliningMode mode) {\n     if (specializationState !\u003d null) {\n         Node containingFunction \u003d getContainingFunction(t);\n         if (containingFunction !\u003d null \u0026\u0026 !specializationState.canFixupFunction(containingFunction)) {\n             return false;\n         }\n     }\n     CanInlineResult result \u003d injector.canInlineReferenceToFunction(t, callNode, fs.getFn().getFunctionNode(), fs.getNamesToAlias(), mode, fs.getReferencesThis(), fs.hasInnerFunctions());\n     if (result !\u003d CanInlineResult.NO) {\n-        boolean decompose \u003d (result \u003d\u003d CanInlineResult.AFTER_DECOMPOSITION);\n+        boolean decompose \u003d (result \u003d\u003d CanInlineResult.AFTER_PREPARATION);\n         fs.addReference(new Reference(callNode, module, mode, decompose));\n         return true;\n     }\n     return false;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "44e59948342527c9d8ffc6f2b01d86af72aaef54": {
      "type": "Ybodychange",
      "commitMessage": "\nExperimental initial module specialization.\n\nThis optimization replaces functions in the initial module with specialized\nversions that are only safe in the initial module.\nThe original, general, versions of the functions are \"fixed up\" in later\nmodules.\nThis optimization can shrink the initial module significantly but the fixup code\nin later modules increases overall code size.\n\nSee SpecializeModule.java for more details.\n\nThis change modifies three existing passes: DevirtualizePrototyMethods, InlineFunctions, and\nRemoveUnusedPrototypeProperties, to be specialization-aware.\nWhen running under specialization, these modules now ask before modifying or\nremoving a function and report\nwhat functions they have modified or removed.\n\nFiles meriting extra scrutiny:\n- DevirtualizePrototypeMethods.java\n- RemoveUnusedPrototypeProperties.java\n- InlineFunctions.java\n- DefaultPassConfig.java\n\nR\u003dacleung\nDELTA\u003d1820  (1810 added, 0 deleted, 10 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d103003\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@353 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "8/12/10, 11:58 AM",
      "commitName": "44e59948342527c9d8ffc6f2b01d86af72aaef54",
      "commitAuthor": "dcc@google.com",
      "commitDateOld": "8/12/10, 6:02 PM",
      "commitNameOld": "15acafb00636f99295b394145b9b60a5e624ddfa",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": -0.25,
      "commitsBetweenForRepo": 0,
      "commitsBetweenForFile": 0,
      "actualSource": "private boolean maybeAddReferenceUsingMode(NodeTraversal t, FunctionState fs, Node callNode, JSModule module, InliningMode mode) {\n    if (specializationState !\u003d null) {\n        Node containingFunction \u003d getContainingFunction(t);\n        if (containingFunction !\u003d null \u0026\u0026 !specializationState.canFixupFunction(containingFunction)) {\n            return false;\n        }\n    }\n    CanInlineResult result \u003d injector.canInlineReferenceToFunction(t, callNode, fs.getFn().getFunctionNode(), fs.getNamesToAlias(), mode, fs.getReferencesThis(), fs.hasInnerFunctions());\n    if (result !\u003d CanInlineResult.NO) {\n        boolean decompose \u003d (result \u003d\u003d CanInlineResult.AFTER_DECOMPOSITION);\n        fs.addReference(new Reference(callNode, module, mode, decompose));\n        return true;\n    }\n    return false;\n}",
      "path": "src/com/google/javascript/jscomp/InlineFunctions.java",
      "functionStartLine": 469,
      "functionName": "maybeAddReferenceUsingMode",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,9 +1,15 @@\n private boolean maybeAddReferenceUsingMode(NodeTraversal t, FunctionState fs, Node callNode, JSModule module, InliningMode mode) {\n+    if (specializationState !\u003d null) {\n+        Node containingFunction \u003d getContainingFunction(t);\n+        if (containingFunction !\u003d null \u0026\u0026 !specializationState.canFixupFunction(containingFunction)) {\n+            return false;\n+        }\n+    }\n     CanInlineResult result \u003d injector.canInlineReferenceToFunction(t, callNode, fs.getFn().getFunctionNode(), fs.getNamesToAlias(), mode, fs.getReferencesThis(), fs.hasInnerFunctions());\n     if (result !\u003d CanInlineResult.NO) {\n         boolean decompose \u003d (result \u003d\u003d CanInlineResult.AFTER_DECOMPOSITION);\n         fs.addReference(new Reference(callNode, module, mode, decompose));\n         return true;\n     }\n     return false;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b4801b28ceea8db0f63da7440d6769cb9b7cce8a": {
      "type": "Ybodychange",
      "commitMessage": "\nChange on 2010/05/28 by johnlenz\n\n        Inline functions with inner functions into global scope if they don\u0027t\n        declare any names.\n\n        R\u003dacleung\n        DELTA\u003d329  (244 added, 27 deleted, 58 changed)\n\nChange on 2010/05/28 by dcc\n\n        First pass on refactoring FoldConstants into separate peephole optimizations. This changelist adds the notion of an AbstractPeepholeOptimization and adds a PeepholeOptimizationsPass that runs them. In this go around the minimization aspects of FoldConstants have been factored out into PeepholeMinimize. A future change will factor out the other components of FoldConstants into their own PeepholeOptimizations. DefaultPassConfig has also been updated to run the new PeepholeOptimizationPass.\n\n        This change does not move the minimization-related unit tests from FoldConstantsTest to PeepholeMinimizeTest -- a future, separate, change will do so. Hopefully this will make it easier to review.\n\n        R\u003dacleung\n        DELTA\u003d1966  (1271 added, 675 deleted, 20 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d13010\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@235 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "5/29/10, 1:07 PM",
      "commitName": "b4801b28ceea8db0f63da7440d6769cb9b7cce8a",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "5/25/10, 10:51 AM",
      "commitNameOld": "170b23fa89cdcc38411fc29ec4453935e0903b16",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 4.09,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "private boolean maybeAddReferenceUsingMode(NodeTraversal t, FunctionState fs, Node callNode, JSModule module, InliningMode mode) {\n    CanInlineResult result \u003d injector.canInlineReferenceToFunction(t, callNode, fs.getFn().getFunctionNode(), fs.getNamesToAlias(), mode, fs.getReferencesThis(), fs.hasInnerFunctions());\n    if (result !\u003d CanInlineResult.NO) {\n        boolean decompose \u003d (result \u003d\u003d CanInlineResult.AFTER_DECOMPOSITION);\n        fs.addReference(new Reference(callNode, module, mode, decompose));\n        return true;\n    }\n    return false;\n}",
      "path": "src/com/google/javascript/jscomp/InlineFunctions.java",
      "functionStartLine": 448,
      "functionName": "maybeAddReferenceUsingMode",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,9 +1,9 @@\n private boolean maybeAddReferenceUsingMode(NodeTraversal t, FunctionState fs, Node callNode, JSModule module, InliningMode mode) {\n-    CanInlineResult result \u003d injector.canInlineReferenceToFunction(t, callNode, fs.getFn().getFunctionNode(), fs.getNamesToAlias(), mode, fs.getReferencesThis());\n+    CanInlineResult result \u003d injector.canInlineReferenceToFunction(t, callNode, fs.getFn().getFunctionNode(), fs.getNamesToAlias(), mode, fs.getReferencesThis(), fs.hasInnerFunctions());\n     if (result !\u003d CanInlineResult.NO) {\n         boolean decompose \u003d (result \u003d\u003d CanInlineResult.AFTER_DECOMPOSITION);\n         fs.addReference(new Reference(callNode, module, mode, decompose));\n         return true;\n     }\n     return false;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": {
      "type": "Yintroduced",
      "commitMessage": "Initial commit.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/3/09, 3:51 PM",
      "commitName": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "diff": "@@ -0,0 +1,9 @@\n+private boolean maybeAddReferenceUsingMode(NodeTraversal t, FunctionState fs, Node callNode, JSModule module, InliningMode mode) {\n+    CanInlineResult result \u003d injector.canInlineReferenceToFunction(t, callNode, fs.getFn().getFunctionNode(), fs.getNamesToAlias(), mode, fs.getReferencesThis());\n+    if (result !\u003d CanInlineResult.NO) {\n+        boolean decompose \u003d (result \u003d\u003d CanInlineResult.AFTER_DECOMPOSITION);\n+        fs.addReference(new Reference(callNode, module, mode, decompose));\n+        return true;\n+    }\n+    return false;\n+}\n\\ No newline at end of file\n",
      "actualSource": "private boolean maybeAddReferenceUsingMode(NodeTraversal t, FunctionState fs, Node callNode, JSModule module, InliningMode mode) {\n    CanInlineResult result \u003d injector.canInlineReferenceToFunction(t, callNode, fs.getFn().getFunctionNode(), fs.getNamesToAlias(), mode, fs.getReferencesThis());\n    if (result !\u003d CanInlineResult.NO) {\n        boolean decompose \u003d (result \u003d\u003d CanInlineResult.AFTER_DECOMPOSITION);\n        fs.addReference(new Reference(callNode, module, mode, decompose));\n        return true;\n    }\n    return false;\n}",
      "path": "src/com/google/javascript/jscomp/InlineFunctions.java",
      "functionStartLine": 410,
      "functionName": "maybeAddReferenceUsingMode",
      "functionAnnotation": "",
      "functionDoc": ""
    }
  }
}