{
  "origin": "codeshovel",
  "repositoryName": "Closure-115b",
  "repositoryPath": "/tmp/Closure-115b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ExpressionDecomposer.java",
  "functionName": "exposeExpression",
  "functionId": "exposeExpression___expressionRoot-Node__subExpression-Node",
  "sourceFilePath": "src/com/google/javascript/jscomp/ExpressionDecomposer.java",
  "functionAnnotation": "",
  "functionDoc": "Rewrite the expression such that the sub-expression is in a movable\nexpression statement while maintaining evaluation order.\n\nTwo types of subexpressions are extracted from the source expression:\n1) subexpressions with side-effects.\n2) conditional expressions, that contain the call, which are transformed\ninto IF statements.\n\nThe following terms are used:\n   expressionRoot: The top-level node before which the any extracted\n                   expressions should be placed before.\n   nonconditionalExpr: The node that will be extracted either expres.\n",
  "functionStartLine": 146,
  "functionEndLine": 235,
  "numCommitsSeen": 25,
  "timeTaken": 2106,
  "changeHistory": [
    "f0ff2971eca336e950929b3ee0d80155338bb1dd",
    "58fdad08ba7f8e24ac48a006f1e2989bda46b9a9",
    "70a5626922ea7e8c98747e22b6986638ba38fadc",
    "39f629a8cfaab37da55288010640d7e516000b1f",
    "76abdf11394c0e7515ae63335676ea3657badb45",
    "251c596a9aa846d8b1e657dfa51417a74c706f7e",
    "34fd5f8275ae69fc772c2283a3c5fd13b93a7c42",
    "3ce4716848eb71b6e78a4545a2cc0c27e74a29b3",
    "78995bf9e88599055a8c4165d89c09dc92a44b30",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3"
  ],
  "changeHistoryShort": {
    "f0ff2971eca336e950929b3ee0d80155338bb1dd": "Ybodychange",
    "58fdad08ba7f8e24ac48a006f1e2989bda46b9a9": "Ybodychange",
    "70a5626922ea7e8c98747e22b6986638ba38fadc": "Ymultichange(Ybodychange,Ydocchange)",
    "39f629a8cfaab37da55288010640d7e516000b1f": "Ybodychange",
    "76abdf11394c0e7515ae63335676ea3657badb45": "Ybodychange",
    "251c596a9aa846d8b1e657dfa51417a74c706f7e": "Ybodychange",
    "34fd5f8275ae69fc772c2283a3c5fd13b93a7c42": "Ybodychange",
    "3ce4716848eb71b6e78a4545a2cc0c27e74a29b3": "Yformatchange",
    "78995bf9e88599055a8c4165d89c09dc92a44b30": "Ybodychange",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "f0ff2971eca336e950929b3ee0d80155338bb1dd": {
      "type": "Ybodychange",
      "commitMessage": "\nCruft removal: remove some unused locals and parameters.\n\nR\u003ddimvar\nDELTA\u003d336 (6 added, 108 deleted, 222 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d6092\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2447 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "1/8/13, 12:15 PM",
      "commitName": "f0ff2971eca336e950929b3ee0d80155338bb1dd",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "9/20/12, 11:55 AM",
      "commitNameOld": "58fdad08ba7f8e24ac48a006f1e2989bda46b9a9",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 110.06,
      "commitsBetweenForRepo": 226,
      "commitsBetweenForFile": 1,
      "actualSource": "private void exposeExpression(Node expressionRoot, Node subExpression) {\n    Node nonconditionalExpr \u003d findNonconditionalParent(subExpression, expressionRoot);\n    boolean hasFollowingSideEffects \u003d NodeUtil.mayHaveSideEffects(nonconditionalExpr, compiler);\n    Node exprInjectionPoint \u003d findInjectionPoint(nonconditionalExpr);\n    DecompositionState state \u003d new DecompositionState();\n    state.sideEffects \u003d hasFollowingSideEffects;\n    state.extractBeforeStatement \u003d exprInjectionPoint;\n    for (Node grandchild \u003d null, child \u003d nonconditionalExpr, parent \u003d child.getParent(); parent !\u003d expressionRoot; grandchild \u003d child, child \u003d parent, parent \u003d child.getParent()) {\n        int parentType \u003d parent.getType();\n        Preconditions.checkState(!isConditionalOp(parent) || child \u003d\u003d parent.getFirstChild());\n        if (parentType \u003d\u003d Token.ASSIGN) {\n            if (isSafeAssign(parent, state.sideEffects)) {\n            } else {\n                Node left \u003d parent.getFirstChild();\n                int type \u003d left.getType();\n                if (left !\u003d child) {\n                    Preconditions.checkState(NodeUtil.isGet(left));\n                    if (type \u003d\u003d Token.GETELEM) {\n                        decomposeSubExpressions(left.getLastChild(), null, state);\n                    }\n                    decomposeSubExpressions(left.getFirstChild(), null, state);\n                }\n            }\n        } else if (parentType \u003d\u003d Token.CALL \u0026\u0026 NodeUtil.isGet(parent.getFirstChild())) {\n            Node functionExpression \u003d parent.getFirstChild();\n            decomposeSubExpressions(functionExpression.getNext(), child, state);\n            if (isExpressionTreeUnsafe(functionExpression, state.sideEffects) \u0026\u0026 functionExpression.getFirstChild() !\u003d grandchild) {\n                Preconditions.checkState(allowObjectCallDecomposing(), \"Object method calls can not be decomposed.\");\n                state.sideEffects \u003d true;\n                Node replacement \u003d rewriteCallExpression(parent, state);\n                parent \u003d replacement;\n            }\n        } else if (parentType \u003d\u003d Token.OBJECTLIT) {\n            decomposeObjectLiteralKeys(parent.getFirstChild(), child, state);\n        } else {\n            decomposeSubExpressions(parent.getFirstChild(), child, state);\n        }\n    }\n    if (nonconditionalExpr \u003d\u003d subExpression) {\n    } else {\n        Node parent \u003d nonconditionalExpr.getParent();\n        boolean needResult \u003d !parent.isExprResult();\n        extractConditional(nonconditionalExpr, exprInjectionPoint, needResult);\n    }\n}",
      "path": "src/com/google/javascript/jscomp/ExpressionDecomposer.java",
      "functionStartLine": 146,
      "functionName": "exposeExpression",
      "functionAnnotation": "",
      "functionDoc": "Rewrite the expression such that the sub-expression is in a movable\nexpression statement while maintaining evaluation order.\n\nTwo types of subexpressions are extracted from the source expression:\n1) subexpressions with side-effects.\n2) conditional expressions, that contain the call, which are transformed\ninto IF statements.\n\nThe following terms are used:\n   expressionRoot: The top-level node before which the any extracted\n                   expressions should be placed before.\n   nonconditionalExpr: The node that will be extracted either expres.\n",
      "diff": "@@ -1,45 +1,45 @@\n private void exposeExpression(Node expressionRoot, Node subExpression) {\n     Node nonconditionalExpr \u003d findNonconditionalParent(subExpression, expressionRoot);\n     boolean hasFollowingSideEffects \u003d NodeUtil.mayHaveSideEffects(nonconditionalExpr, compiler);\n     Node exprInjectionPoint \u003d findInjectionPoint(nonconditionalExpr);\n     DecompositionState state \u003d new DecompositionState();\n     state.sideEffects \u003d hasFollowingSideEffects;\n     state.extractBeforeStatement \u003d exprInjectionPoint;\n     for (Node grandchild \u003d null, child \u003d nonconditionalExpr, parent \u003d child.getParent(); parent !\u003d expressionRoot; grandchild \u003d child, child \u003d parent, parent \u003d child.getParent()) {\n         int parentType \u003d parent.getType();\n         Preconditions.checkState(!isConditionalOp(parent) || child \u003d\u003d parent.getFirstChild());\n         if (parentType \u003d\u003d Token.ASSIGN) {\n             if (isSafeAssign(parent, state.sideEffects)) {\n             } else {\n                 Node left \u003d parent.getFirstChild();\n                 int type \u003d left.getType();\n                 if (left !\u003d child) {\n                     Preconditions.checkState(NodeUtil.isGet(left));\n                     if (type \u003d\u003d Token.GETELEM) {\n                         decomposeSubExpressions(left.getLastChild(), null, state);\n                     }\n                     decomposeSubExpressions(left.getFirstChild(), null, state);\n                 }\n             }\n         } else if (parentType \u003d\u003d Token.CALL \u0026\u0026 NodeUtil.isGet(parent.getFirstChild())) {\n             Node functionExpression \u003d parent.getFirstChild();\n             decomposeSubExpressions(functionExpression.getNext(), child, state);\n             if (isExpressionTreeUnsafe(functionExpression, state.sideEffects) \u0026\u0026 functionExpression.getFirstChild() !\u003d grandchild) {\n                 Preconditions.checkState(allowObjectCallDecomposing(), \"Object method calls can not be decomposed.\");\n                 state.sideEffects \u003d true;\n                 Node replacement \u003d rewriteCallExpression(parent, state);\n                 parent \u003d replacement;\n             }\n         } else if (parentType \u003d\u003d Token.OBJECTLIT) {\n             decomposeObjectLiteralKeys(parent.getFirstChild(), child, state);\n         } else {\n             decomposeSubExpressions(parent.getFirstChild(), child, state);\n         }\n     }\n     if (nonconditionalExpr \u003d\u003d subExpression) {\n     } else {\n         Node parent \u003d nonconditionalExpr.getParent();\n         boolean needResult \u003d !parent.isExprResult();\n-        Node extractedConditional \u003d extractConditional(nonconditionalExpr, exprInjectionPoint, needResult);\n+        extractConditional(nonconditionalExpr, exprInjectionPoint, needResult);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "58fdad08ba7f8e24ac48a006f1e2989bda46b9a9": {
      "type": "Ybodychange",
      "commitMessage": "\nSome NodeUtil cleanup, narrow the public interface, remove some unused\nfunctions, and some other cleanup.\n\nR\u003dnicksantos\nDELTA\u003d130  (40 added, 50 deleted, 40 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d5519\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2202 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "9/20/12, 11:55 AM",
      "commitName": "58fdad08ba7f8e24ac48a006f1e2989bda46b9a9",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "6/18/12, 9:58 AM",
      "commitNameOld": "98a487531ce3d6555851398daead0471b5932774",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 94.08,
      "commitsBetweenForRepo": 137,
      "commitsBetweenForFile": 1,
      "actualSource": "private void exposeExpression(Node expressionRoot, Node subExpression) {\n    Node nonconditionalExpr \u003d findNonconditionalParent(subExpression, expressionRoot);\n    boolean hasFollowingSideEffects \u003d NodeUtil.mayHaveSideEffects(nonconditionalExpr, compiler);\n    Node exprInjectionPoint \u003d findInjectionPoint(nonconditionalExpr);\n    DecompositionState state \u003d new DecompositionState();\n    state.sideEffects \u003d hasFollowingSideEffects;\n    state.extractBeforeStatement \u003d exprInjectionPoint;\n    for (Node grandchild \u003d null, child \u003d nonconditionalExpr, parent \u003d child.getParent(); parent !\u003d expressionRoot; grandchild \u003d child, child \u003d parent, parent \u003d child.getParent()) {\n        int parentType \u003d parent.getType();\n        Preconditions.checkState(!isConditionalOp(parent) || child \u003d\u003d parent.getFirstChild());\n        if (parentType \u003d\u003d Token.ASSIGN) {\n            if (isSafeAssign(parent, state.sideEffects)) {\n            } else {\n                Node left \u003d parent.getFirstChild();\n                int type \u003d left.getType();\n                if (left !\u003d child) {\n                    Preconditions.checkState(NodeUtil.isGet(left));\n                    if (type \u003d\u003d Token.GETELEM) {\n                        decomposeSubExpressions(left.getLastChild(), null, state);\n                    }\n                    decomposeSubExpressions(left.getFirstChild(), null, state);\n                }\n            }\n        } else if (parentType \u003d\u003d Token.CALL \u0026\u0026 NodeUtil.isGet(parent.getFirstChild())) {\n            Node functionExpression \u003d parent.getFirstChild();\n            decomposeSubExpressions(functionExpression.getNext(), child, state);\n            if (isExpressionTreeUnsafe(functionExpression, state.sideEffects) \u0026\u0026 functionExpression.getFirstChild() !\u003d grandchild) {\n                Preconditions.checkState(allowObjectCallDecomposing(), \"Object method calls can not be decomposed.\");\n                state.sideEffects \u003d true;\n                Node replacement \u003d rewriteCallExpression(parent, state);\n                parent \u003d replacement;\n            }\n        } else if (parentType \u003d\u003d Token.OBJECTLIT) {\n            decomposeObjectLiteralKeys(parent.getFirstChild(), child, state);\n        } else {\n            decomposeSubExpressions(parent.getFirstChild(), child, state);\n        }\n    }\n    if (nonconditionalExpr \u003d\u003d subExpression) {\n    } else {\n        Node parent \u003d nonconditionalExpr.getParent();\n        boolean needResult \u003d !parent.isExprResult();\n        Node extractedConditional \u003d extractConditional(nonconditionalExpr, exprInjectionPoint, needResult);\n    }\n}",
      "path": "src/com/google/javascript/jscomp/ExpressionDecomposer.java",
      "functionStartLine": 146,
      "functionName": "exposeExpression",
      "functionAnnotation": "",
      "functionDoc": "Rewrite the expression such that the sub-expression is in a movable\nexpression statement while maintaining evaluation order.\n\nTwo types of subexpressions are extracted from the source expression:\n1) subexpressions with side-effects.\n2) conditional expressions, that contain the call, which are transformed\ninto IF statements.\n\nThe following terms are used:\n   expressionRoot: The top-level node before which the any extracted\n                   expressions should be placed before.\n   nonconditionalExpr: The node that will be extracted either expres.\n",
      "diff": "@@ -1,45 +1,45 @@\n private void exposeExpression(Node expressionRoot, Node subExpression) {\n     Node nonconditionalExpr \u003d findNonconditionalParent(subExpression, expressionRoot);\n-    boolean hasFollowingSideEffects \u003d NodeUtil.mayHaveSideEffects(nonconditionalExpr);\n+    boolean hasFollowingSideEffects \u003d NodeUtil.mayHaveSideEffects(nonconditionalExpr, compiler);\n     Node exprInjectionPoint \u003d findInjectionPoint(nonconditionalExpr);\n     DecompositionState state \u003d new DecompositionState();\n     state.sideEffects \u003d hasFollowingSideEffects;\n     state.extractBeforeStatement \u003d exprInjectionPoint;\n     for (Node grandchild \u003d null, child \u003d nonconditionalExpr, parent \u003d child.getParent(); parent !\u003d expressionRoot; grandchild \u003d child, child \u003d parent, parent \u003d child.getParent()) {\n         int parentType \u003d parent.getType();\n         Preconditions.checkState(!isConditionalOp(parent) || child \u003d\u003d parent.getFirstChild());\n         if (parentType \u003d\u003d Token.ASSIGN) {\n             if (isSafeAssign(parent, state.sideEffects)) {\n             } else {\n                 Node left \u003d parent.getFirstChild();\n                 int type \u003d left.getType();\n                 if (left !\u003d child) {\n                     Preconditions.checkState(NodeUtil.isGet(left));\n                     if (type \u003d\u003d Token.GETELEM) {\n                         decomposeSubExpressions(left.getLastChild(), null, state);\n                     }\n                     decomposeSubExpressions(left.getFirstChild(), null, state);\n                 }\n             }\n         } else if (parentType \u003d\u003d Token.CALL \u0026\u0026 NodeUtil.isGet(parent.getFirstChild())) {\n             Node functionExpression \u003d parent.getFirstChild();\n             decomposeSubExpressions(functionExpression.getNext(), child, state);\n             if (isExpressionTreeUnsafe(functionExpression, state.sideEffects) \u0026\u0026 functionExpression.getFirstChild() !\u003d grandchild) {\n                 Preconditions.checkState(allowObjectCallDecomposing(), \"Object method calls can not be decomposed.\");\n                 state.sideEffects \u003d true;\n                 Node replacement \u003d rewriteCallExpression(parent, state);\n                 parent \u003d replacement;\n             }\n         } else if (parentType \u003d\u003d Token.OBJECTLIT) {\n             decomposeObjectLiteralKeys(parent.getFirstChild(), child, state);\n         } else {\n             decomposeSubExpressions(parent.getFirstChild(), child, state);\n         }\n     }\n     if (nonconditionalExpr \u003d\u003d subExpression) {\n     } else {\n         Node parent \u003d nonconditionalExpr.getParent();\n         boolean needResult \u003d !parent.isExprResult();\n         Node extractedConditional \u003d extractConditional(nonconditionalExpr, exprInjectionPoint, needResult);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "70a5626922ea7e8c98747e22b6986638ba38fadc": {
      "type": "Ymultichange(Ybodychange,Ydocchange)",
      "commitMessage": "\nFix various typos, spelling and grammar errors.\nFixes issue 734. \nContributed by Robert Gust Bardon\n\nR\u003dnicksantos\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d4827\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1979 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "5/18/12, 11:09 AM",
      "commitName": "70a5626922ea7e8c98747e22b6986638ba38fadc",
      "commitAuthor": "johnlenz@google.com",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "\nFix various typos, spelling and grammar errors.\nFixes issue 734. \nContributed by Robert Gust Bardon\n\nR\u003dnicksantos\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d4827\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1979 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "5/18/12, 11:09 AM",
          "commitName": "70a5626922ea7e8c98747e22b6986638ba38fadc",
          "commitAuthor": "johnlenz@google.com",
          "commitDateOld": "11/22/11, 2:28 PM",
          "commitNameOld": "9dfbc803407e714f9744555a1c9e7c4230f1816d",
          "commitAuthorOld": "johnlenz@google.com",
          "daysBetweenCommits": 177.82,
          "commitsBetweenForRepo": 292,
          "commitsBetweenForFile": 1,
          "actualSource": "private void exposeExpression(Node expressionRoot, Node subExpression) {\n    Node nonconditionalExpr \u003d findNonconditionalParent(subExpression, expressionRoot);\n    boolean hasFollowingSideEffects \u003d NodeUtil.mayHaveSideEffects(nonconditionalExpr);\n    Node exprInjectionPoint \u003d findInjectionPoint(nonconditionalExpr);\n    DecompositionState state \u003d new DecompositionState();\n    state.sideEffects \u003d hasFollowingSideEffects;\n    state.extractBeforeStatement \u003d exprInjectionPoint;\n    for (Node grandchild \u003d null, child \u003d nonconditionalExpr, parent \u003d child.getParent(); parent !\u003d expressionRoot; grandchild \u003d child, child \u003d parent, parent \u003d child.getParent()) {\n        int parentType \u003d parent.getType();\n        Preconditions.checkState(!isConditionalOp(parent) || child \u003d\u003d parent.getFirstChild());\n        if (parentType \u003d\u003d Token.ASSIGN) {\n            if (isSafeAssign(parent, state.sideEffects)) {\n            } else {\n                Node left \u003d parent.getFirstChild();\n                int type \u003d left.getType();\n                if (left !\u003d child) {\n                    Preconditions.checkState(NodeUtil.isGet(left));\n                    if (type \u003d\u003d Token.GETELEM) {\n                        decomposeSubExpressions(left.getLastChild(), null, state);\n                    }\n                    decomposeSubExpressions(left.getFirstChild(), null, state);\n                }\n            }\n        } else if (parentType \u003d\u003d Token.CALL \u0026\u0026 NodeUtil.isGet(parent.getFirstChild())) {\n            Node functionExpression \u003d parent.getFirstChild();\n            decomposeSubExpressions(functionExpression.getNext(), child, state);\n            if (isExpressionTreeUnsafe(functionExpression, state.sideEffects) \u0026\u0026 functionExpression.getFirstChild() !\u003d grandchild) {\n                Preconditions.checkState(allowObjectCallDecomposing(), \"Object method calls can not be decomposed.\");\n                state.sideEffects \u003d true;\n                Node replacement \u003d rewriteCallExpression(parent, state);\n                parent \u003d replacement;\n            }\n        } else if (parentType \u003d\u003d Token.OBJECTLIT) {\n            decomposeObjectLiteralKeys(parent.getFirstChild(), child, state);\n        } else {\n            decomposeSubExpressions(parent.getFirstChild(), child, state);\n        }\n    }\n    if (nonconditionalExpr \u003d\u003d subExpression) {\n    } else {\n        Node parent \u003d nonconditionalExpr.getParent();\n        boolean needResult \u003d !parent.isExprResult();\n        Node extractedConditional \u003d extractConditional(nonconditionalExpr, exprInjectionPoint, needResult);\n    }\n}",
          "path": "src/com/google/javascript/jscomp/ExpressionDecomposer.java",
          "functionStartLine": 146,
          "functionName": "exposeExpression",
          "functionAnnotation": "",
          "functionDoc": "Rewrite the expression such that the sub-expression is in a movable\nexpression statement while maintaining evaluation order.\n\nTwo types of subexpressions are extracted from the source expression:\n1) subexpressions with side-effects.\n2) conditional expressions, that contain the call, which are transformed\ninto IF statements.\n\nThe following terms are used:\n   expressionRoot: The top-level node before which the any extracted\n                   expressions should be placed before.\n   nonconditionalExpr: The node that will be extracted either expres.\n",
          "diff": "",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "\nFix various typos, spelling and grammar errors.\nFixes issue 734. \nContributed by Robert Gust Bardon\n\nR\u003dnicksantos\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d4827\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1979 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "5/18/12, 11:09 AM",
          "commitName": "70a5626922ea7e8c98747e22b6986638ba38fadc",
          "commitAuthor": "johnlenz@google.com",
          "commitDateOld": "11/22/11, 2:28 PM",
          "commitNameOld": "9dfbc803407e714f9744555a1c9e7c4230f1816d",
          "commitAuthorOld": "johnlenz@google.com",
          "daysBetweenCommits": 177.82,
          "commitsBetweenForRepo": 292,
          "commitsBetweenForFile": 1,
          "actualSource": "private void exposeExpression(Node expressionRoot, Node subExpression) {\n    Node nonconditionalExpr \u003d findNonconditionalParent(subExpression, expressionRoot);\n    boolean hasFollowingSideEffects \u003d NodeUtil.mayHaveSideEffects(nonconditionalExpr);\n    Node exprInjectionPoint \u003d findInjectionPoint(nonconditionalExpr);\n    DecompositionState state \u003d new DecompositionState();\n    state.sideEffects \u003d hasFollowingSideEffects;\n    state.extractBeforeStatement \u003d exprInjectionPoint;\n    for (Node grandchild \u003d null, child \u003d nonconditionalExpr, parent \u003d child.getParent(); parent !\u003d expressionRoot; grandchild \u003d child, child \u003d parent, parent \u003d child.getParent()) {\n        int parentType \u003d parent.getType();\n        Preconditions.checkState(!isConditionalOp(parent) || child \u003d\u003d parent.getFirstChild());\n        if (parentType \u003d\u003d Token.ASSIGN) {\n            if (isSafeAssign(parent, state.sideEffects)) {\n            } else {\n                Node left \u003d parent.getFirstChild();\n                int type \u003d left.getType();\n                if (left !\u003d child) {\n                    Preconditions.checkState(NodeUtil.isGet(left));\n                    if (type \u003d\u003d Token.GETELEM) {\n                        decomposeSubExpressions(left.getLastChild(), null, state);\n                    }\n                    decomposeSubExpressions(left.getFirstChild(), null, state);\n                }\n            }\n        } else if (parentType \u003d\u003d Token.CALL \u0026\u0026 NodeUtil.isGet(parent.getFirstChild())) {\n            Node functionExpression \u003d parent.getFirstChild();\n            decomposeSubExpressions(functionExpression.getNext(), child, state);\n            if (isExpressionTreeUnsafe(functionExpression, state.sideEffects) \u0026\u0026 functionExpression.getFirstChild() !\u003d grandchild) {\n                Preconditions.checkState(allowObjectCallDecomposing(), \"Object method calls can not be decomposed.\");\n                state.sideEffects \u003d true;\n                Node replacement \u003d rewriteCallExpression(parent, state);\n                parent \u003d replacement;\n            }\n        } else if (parentType \u003d\u003d Token.OBJECTLIT) {\n            decomposeObjectLiteralKeys(parent.getFirstChild(), child, state);\n        } else {\n            decomposeSubExpressions(parent.getFirstChild(), child, state);\n        }\n    }\n    if (nonconditionalExpr \u003d\u003d subExpression) {\n    } else {\n        Node parent \u003d nonconditionalExpr.getParent();\n        boolean needResult \u003d !parent.isExprResult();\n        Node extractedConditional \u003d extractConditional(nonconditionalExpr, exprInjectionPoint, needResult);\n    }\n}",
          "path": "src/com/google/javascript/jscomp/ExpressionDecomposer.java",
          "functionStartLine": 146,
          "functionName": "exposeExpression",
          "functionAnnotation": "",
          "functionDoc": "Rewrite the expression such that the sub-expression is in a movable\nexpression statement while maintaining evaluation order.\n\nTwo types of subexpressions are extracted from the source expression:\n1) subexpressions with side-effects.\n2) conditional expressions, that contain the call, which are transformed\ninto IF statements.\n\nThe following terms are used:\n   expressionRoot: The top-level node before which the any extracted\n                   expressions should be placed before.\n   nonconditionalExpr: The node that will be extracted either expres.\n",
          "diff": "",
          "extendedDetails": {
            "oldValue": "Rewrite the expression such that the sub-expression is in a movable\nexpression statement while maintaining evaluation order.\n\nTwo types of subexpressions are extracted from the source expression:\n1) subexpressions with side-effects.\n2) conditional expressions, that contain the call, which are transformed\ninto IF statements.\n\nThe following terms are used:\n   expressionRoot: The top level node before which the any extracted\n                   expressions should be placed before.\n   nonconditionalExpr: The node that will be extracted either expres.\n",
            "newValue": "Rewrite the expression such that the sub-expression is in a movable\nexpression statement while maintaining evaluation order.\n\nTwo types of subexpressions are extracted from the source expression:\n1) subexpressions with side-effects.\n2) conditional expressions, that contain the call, which are transformed\ninto IF statements.\n\nThe following terms are used:\n   expressionRoot: The top-level node before which the any extracted\n                   expressions should be placed before.\n   nonconditionalExpr: The node that will be extracted either expres.\n"
          }
        }
      ]
    },
    "39f629a8cfaab37da55288010640d7e516000b1f": {
      "type": "Ybodychange",
      "commitMessage": "\nReplace calls of the form \"Node.getType() !\u003d Token.XX\" with\n\"!Node.isXX()\" calls.\n\nR\u003dnicksantos\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3706\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1598 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/14/11, 6:13 PM",
      "commitName": "39f629a8cfaab37da55288010640d7e516000b1f",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "11/11/11, 4:42 PM",
      "commitNameOld": "5524adbda991632656059566b69cc2771ba42b7d",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 3.06,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "private void exposeExpression(Node expressionRoot, Node subExpression) {\n    Node nonconditionalExpr \u003d findNonconditionalParent(subExpression, expressionRoot);\n    boolean hasFollowingSideEffects \u003d NodeUtil.mayHaveSideEffects(nonconditionalExpr);\n    Node exprInjectionPoint \u003d findInjectionPoint(nonconditionalExpr);\n    DecompositionState state \u003d new DecompositionState();\n    state.sideEffects \u003d hasFollowingSideEffects;\n    state.extractBeforeStatement \u003d exprInjectionPoint;\n    for (Node grandchild \u003d null, child \u003d nonconditionalExpr, parent \u003d child.getParent(); parent !\u003d expressionRoot; grandchild \u003d child, child \u003d parent, parent \u003d child.getParent()) {\n        int parentType \u003d parent.getType();\n        Preconditions.checkState(!isConditionalOp(parent) || child \u003d\u003d parent.getFirstChild());\n        if (parentType \u003d\u003d Token.ASSIGN) {\n            if (isSafeAssign(parent, state.sideEffects)) {\n            } else {\n                Node left \u003d parent.getFirstChild();\n                int type \u003d left.getType();\n                if (left !\u003d child) {\n                    Preconditions.checkState(NodeUtil.isGet(left));\n                    if (type \u003d\u003d Token.GETELEM) {\n                        decomposeSubExpressions(left.getLastChild(), null, state);\n                    }\n                    decomposeSubExpressions(left.getFirstChild(), null, state);\n                }\n            }\n        } else if (parentType \u003d\u003d Token.CALL \u0026\u0026 NodeUtil.isGet(parent.getFirstChild())) {\n            Node functionExpression \u003d parent.getFirstChild();\n            decomposeSubExpressions(functionExpression.getNext(), child, state);\n            if (isExpressionTreeUnsafe(functionExpression, state.sideEffects) \u0026\u0026 functionExpression.getFirstChild() !\u003d grandchild) {\n                Preconditions.checkState(allowObjectCallDecomposing(), \"Object method calls can not be decomposed.\");\n                state.sideEffects \u003d true;\n                Node replacement \u003d rewriteCallExpression(parent, state);\n                parent \u003d replacement;\n            }\n        } else if (parentType \u003d\u003d Token.OBJECTLIT) {\n            decomposeObjectLiteralKeys(parent.getFirstChild(), child, state);\n        } else {\n            decomposeSubExpressions(parent.getFirstChild(), child, state);\n        }\n    }\n    if (nonconditionalExpr \u003d\u003d subExpression) {\n    } else {\n        Node parent \u003d nonconditionalExpr.getParent();\n        boolean needResult \u003d !parent.isExprResult();\n        Node extractedConditional \u003d extractConditional(nonconditionalExpr, exprInjectionPoint, needResult);\n    }\n}",
      "path": "src/com/google/javascript/jscomp/ExpressionDecomposer.java",
      "functionStartLine": 145,
      "functionName": "exposeExpression",
      "functionAnnotation": "",
      "functionDoc": "Rewrite the expression such that the sub-expression is in a movable\nexpression statement while maintaining evaluation order.\n\nTwo types of subexpressions are extracted from the source expression:\n1) subexpressions with side-effects.\n2) conditional expressions, that contain the call, which are transformed\ninto IF statements.\n\nThe following terms are used:\n   expressionRoot: The top level node before which the any extracted\n                   expressions should be placed before.\n   nonconditionalExpr: The node that will be extracted either expres.\n",
      "diff": "@@ -1,45 +1,45 @@\n private void exposeExpression(Node expressionRoot, Node subExpression) {\n     Node nonconditionalExpr \u003d findNonconditionalParent(subExpression, expressionRoot);\n     boolean hasFollowingSideEffects \u003d NodeUtil.mayHaveSideEffects(nonconditionalExpr);\n     Node exprInjectionPoint \u003d findInjectionPoint(nonconditionalExpr);\n     DecompositionState state \u003d new DecompositionState();\n     state.sideEffects \u003d hasFollowingSideEffects;\n     state.extractBeforeStatement \u003d exprInjectionPoint;\n     for (Node grandchild \u003d null, child \u003d nonconditionalExpr, parent \u003d child.getParent(); parent !\u003d expressionRoot; grandchild \u003d child, child \u003d parent, parent \u003d child.getParent()) {\n         int parentType \u003d parent.getType();\n         Preconditions.checkState(!isConditionalOp(parent) || child \u003d\u003d parent.getFirstChild());\n         if (parentType \u003d\u003d Token.ASSIGN) {\n             if (isSafeAssign(parent, state.sideEffects)) {\n             } else {\n                 Node left \u003d parent.getFirstChild();\n                 int type \u003d left.getType();\n                 if (left !\u003d child) {\n                     Preconditions.checkState(NodeUtil.isGet(left));\n                     if (type \u003d\u003d Token.GETELEM) {\n                         decomposeSubExpressions(left.getLastChild(), null, state);\n                     }\n                     decomposeSubExpressions(left.getFirstChild(), null, state);\n                 }\n             }\n         } else if (parentType \u003d\u003d Token.CALL \u0026\u0026 NodeUtil.isGet(parent.getFirstChild())) {\n             Node functionExpression \u003d parent.getFirstChild();\n             decomposeSubExpressions(functionExpression.getNext(), child, state);\n             if (isExpressionTreeUnsafe(functionExpression, state.sideEffects) \u0026\u0026 functionExpression.getFirstChild() !\u003d grandchild) {\n                 Preconditions.checkState(allowObjectCallDecomposing(), \"Object method calls can not be decomposed.\");\n                 state.sideEffects \u003d true;\n                 Node replacement \u003d rewriteCallExpression(parent, state);\n                 parent \u003d replacement;\n             }\n         } else if (parentType \u003d\u003d Token.OBJECTLIT) {\n             decomposeObjectLiteralKeys(parent.getFirstChild(), child, state);\n         } else {\n             decomposeSubExpressions(parent.getFirstChild(), child, state);\n         }\n     }\n     if (nonconditionalExpr \u003d\u003d subExpression) {\n     } else {\n         Node parent \u003d nonconditionalExpr.getParent();\n-        boolean needResult \u003d parent.getType() !\u003d Token.EXPR_RESULT;\n+        boolean needResult \u003d !parent.isExprResult();\n         Node extractedConditional \u003d extractConditional(nonconditionalExpr, exprInjectionPoint, needResult);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "76abdf11394c0e7515ae63335676ea3657badb45": {
      "type": "Ybodychange",
      "commitMessage": "\nMake our build warnings free.\n\nR\u003dacleung\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d2830\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1301 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "7/28/11, 4:19 PM",
      "commitName": "76abdf11394c0e7515ae63335676ea3657badb45",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "6/29/11, 11:20 AM",
      "commitNameOld": "251c596a9aa846d8b1e657dfa51417a74c706f7e",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 29.21,
      "commitsBetweenForRepo": 68,
      "commitsBetweenForFile": 1,
      "actualSource": "private void exposeExpression(Node expressionRoot, Node subExpression) {\n    Node nonconditionalExpr \u003d findNonconditionalParent(subExpression, expressionRoot);\n    boolean hasFollowingSideEffects \u003d NodeUtil.mayHaveSideEffects(nonconditionalExpr);\n    Node exprInjectionPoint \u003d findInjectionPoint(nonconditionalExpr);\n    DecompositionState state \u003d new DecompositionState();\n    state.sideEffects \u003d hasFollowingSideEffects;\n    state.extractBeforeStatement \u003d exprInjectionPoint;\n    for (Node grandchild \u003d null, child \u003d nonconditionalExpr, parent \u003d child.getParent(); parent !\u003d expressionRoot; grandchild \u003d child, child \u003d parent, parent \u003d child.getParent()) {\n        int parentType \u003d parent.getType();\n        Preconditions.checkState(!isConditionalOp(parent) || child \u003d\u003d parent.getFirstChild());\n        if (parentType \u003d\u003d Token.ASSIGN) {\n            if (isSafeAssign(parent, state.sideEffects)) {\n            } else {\n                Node left \u003d parent.getFirstChild();\n                int type \u003d left.getType();\n                if (left !\u003d child) {\n                    Preconditions.checkState(NodeUtil.isGet(left));\n                    if (type \u003d\u003d Token.GETELEM) {\n                        decomposeSubExpressions(left.getLastChild(), null, state);\n                    }\n                    decomposeSubExpressions(left.getFirstChild(), null, state);\n                }\n            }\n        } else if (parentType \u003d\u003d Token.CALL \u0026\u0026 NodeUtil.isGet(parent.getFirstChild())) {\n            Node functionExpression \u003d parent.getFirstChild();\n            decomposeSubExpressions(functionExpression.getNext(), child, state);\n            if (isExpressionTreeUnsafe(functionExpression, state.sideEffects) \u0026\u0026 functionExpression.getFirstChild() !\u003d grandchild) {\n                Preconditions.checkState(allowObjectCallDecomposing(), \"Object method calls can not be decomposed.\");\n                state.sideEffects \u003d true;\n                Node replacement \u003d rewriteCallExpression(parent, state);\n                parent \u003d replacement;\n            }\n        } else if (parentType \u003d\u003d Token.OBJECTLIT) {\n            decomposeObjectLiteralKeys(parent.getFirstChild(), child, state);\n        } else {\n            decomposeSubExpressions(parent.getFirstChild(), child, state);\n        }\n    }\n    if (nonconditionalExpr \u003d\u003d subExpression) {\n    } else {\n        Node parent \u003d nonconditionalExpr.getParent();\n        boolean needResult \u003d parent.getType() !\u003d Token.EXPR_RESULT;\n        Node extractedConditional \u003d extractConditional(nonconditionalExpr, exprInjectionPoint, needResult);\n    }\n}",
      "path": "src/com/google/javascript/jscomp/ExpressionDecomposer.java",
      "functionStartLine": 145,
      "functionName": "exposeExpression",
      "functionAnnotation": "",
      "functionDoc": "Rewrite the expression such that the sub-expression is in a movable\nexpression statement while maintaining evaluation order.\n\nTwo types of subexpressions are extracted from the source expression:\n1) subexpressions with side-effects.\n2) conditional expressions, that contain the call, which are transformed\ninto IF statements.\n\nThe following terms are used:\n   expressionRoot: The top level node before which the any extracted\n                   expressions should be placed before.\n   nonconditionalExpr: The node that will be extracted either expres.\n",
      "diff": "@@ -1,48 +1,45 @@\n private void exposeExpression(Node expressionRoot, Node subExpression) {\n     Node nonconditionalExpr \u003d findNonconditionalParent(subExpression, expressionRoot);\n     boolean hasFollowingSideEffects \u003d NodeUtil.mayHaveSideEffects(nonconditionalExpr);\n     Node exprInjectionPoint \u003d findInjectionPoint(nonconditionalExpr);\n     DecompositionState state \u003d new DecompositionState();\n     state.sideEffects \u003d hasFollowingSideEffects;\n     state.extractBeforeStatement \u003d exprInjectionPoint;\n     for (Node grandchild \u003d null, child \u003d nonconditionalExpr, parent \u003d child.getParent(); parent !\u003d expressionRoot; grandchild \u003d child, child \u003d parent, parent \u003d child.getParent()) {\n         int parentType \u003d parent.getType();\n         Preconditions.checkState(!isConditionalOp(parent) || child \u003d\u003d parent.getFirstChild());\n         if (parentType \u003d\u003d Token.ASSIGN) {\n             if (isSafeAssign(parent, state.sideEffects)) {\n             } else {\n                 Node left \u003d parent.getFirstChild();\n                 int type \u003d left.getType();\n                 if (left !\u003d child) {\n                     Preconditions.checkState(NodeUtil.isGet(left));\n                     if (type \u003d\u003d Token.GETELEM) {\n                         decomposeSubExpressions(left.getLastChild(), null, state);\n                     }\n                     decomposeSubExpressions(left.getFirstChild(), null, state);\n                 }\n             }\n         } else if (parentType \u003d\u003d Token.CALL \u0026\u0026 NodeUtil.isGet(parent.getFirstChild())) {\n             Node functionExpression \u003d parent.getFirstChild();\n             decomposeSubExpressions(functionExpression.getNext(), child, state);\n             if (isExpressionTreeUnsafe(functionExpression, state.sideEffects) \u0026\u0026 functionExpression.getFirstChild() !\u003d grandchild) {\n-                if (true) {\n-                    throw new IllegalStateException(\"Object method calls can not be decomposed.\");\n-                } else {\n-                    state.sideEffects \u003d true;\n-                    Node replacement \u003d rewriteCallExpression(parent, state);\n-                    parent \u003d replacement;\n-                }\n+                Preconditions.checkState(allowObjectCallDecomposing(), \"Object method calls can not be decomposed.\");\n+                state.sideEffects \u003d true;\n+                Node replacement \u003d rewriteCallExpression(parent, state);\n+                parent \u003d replacement;\n             }\n         } else if (parentType \u003d\u003d Token.OBJECTLIT) {\n             decomposeObjectLiteralKeys(parent.getFirstChild(), child, state);\n         } else {\n             decomposeSubExpressions(parent.getFirstChild(), child, state);\n         }\n     }\n     if (nonconditionalExpr \u003d\u003d subExpression) {\n     } else {\n         Node parent \u003d nonconditionalExpr.getParent();\n         boolean needResult \u003d parent.getType() !\u003d Token.EXPR_RESULT;\n         Node extractedConditional \u003d extractConditional(nonconditionalExpr, exprInjectionPoint, needResult);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "251c596a9aa846d8b1e657dfa51417a74c706f7e": {
      "type": "Ybodychange",
      "commitMessage": "\nThe was being too aggressive about trying to preserve \"this\" for\nmethod calls and should a this point never try to do so.\n\nR\u003dacleung\nDELTA\u003d99  (82 added, 2 deleted, 15 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d2453\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1227 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "6/29/11, 11:20 AM",
      "commitName": "251c596a9aa846d8b1e657dfa51417a74c706f7e",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "4/12/11, 12:15 PM",
      "commitNameOld": "f322be0e576d5e2114cb59c0a6537197997b9c59",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 77.96,
      "commitsBetweenForRepo": 221,
      "commitsBetweenForFile": 1,
      "actualSource": "private void exposeExpression(Node expressionRoot, Node subExpression) {\n    Node nonconditionalExpr \u003d findNonconditionalParent(subExpression, expressionRoot);\n    boolean hasFollowingSideEffects \u003d NodeUtil.mayHaveSideEffects(nonconditionalExpr);\n    Node exprInjectionPoint \u003d findInjectionPoint(nonconditionalExpr);\n    DecompositionState state \u003d new DecompositionState();\n    state.sideEffects \u003d hasFollowingSideEffects;\n    state.extractBeforeStatement \u003d exprInjectionPoint;\n    for (Node grandchild \u003d null, child \u003d nonconditionalExpr, parent \u003d child.getParent(); parent !\u003d expressionRoot; grandchild \u003d child, child \u003d parent, parent \u003d child.getParent()) {\n        int parentType \u003d parent.getType();\n        Preconditions.checkState(!isConditionalOp(parent) || child \u003d\u003d parent.getFirstChild());\n        if (parentType \u003d\u003d Token.ASSIGN) {\n            if (isSafeAssign(parent, state.sideEffects)) {\n            } else {\n                Node left \u003d parent.getFirstChild();\n                int type \u003d left.getType();\n                if (left !\u003d child) {\n                    Preconditions.checkState(NodeUtil.isGet(left));\n                    if (type \u003d\u003d Token.GETELEM) {\n                        decomposeSubExpressions(left.getLastChild(), null, state);\n                    }\n                    decomposeSubExpressions(left.getFirstChild(), null, state);\n                }\n            }\n        } else if (parentType \u003d\u003d Token.CALL \u0026\u0026 NodeUtil.isGet(parent.getFirstChild())) {\n            Node functionExpression \u003d parent.getFirstChild();\n            decomposeSubExpressions(functionExpression.getNext(), child, state);\n            if (isExpressionTreeUnsafe(functionExpression, state.sideEffects) \u0026\u0026 functionExpression.getFirstChild() !\u003d grandchild) {\n                if (true) {\n                    throw new IllegalStateException(\"Object method calls can not be decomposed.\");\n                } else {\n                    state.sideEffects \u003d true;\n                    Node replacement \u003d rewriteCallExpression(parent, state);\n                    parent \u003d replacement;\n                }\n            }\n        } else if (parentType \u003d\u003d Token.OBJECTLIT) {\n            decomposeObjectLiteralKeys(parent.getFirstChild(), child, state);\n        } else {\n            decomposeSubExpressions(parent.getFirstChild(), child, state);\n        }\n    }\n    if (nonconditionalExpr \u003d\u003d subExpression) {\n    } else {\n        Node parent \u003d nonconditionalExpr.getParent();\n        boolean needResult \u003d parent.getType() !\u003d Token.EXPR_RESULT;\n        Node extractedConditional \u003d extractConditional(nonconditionalExpr, exprInjectionPoint, needResult);\n    }\n}",
      "path": "src/com/google/javascript/jscomp/ExpressionDecomposer.java",
      "functionStartLine": 145,
      "functionName": "exposeExpression",
      "functionAnnotation": "",
      "functionDoc": "Rewrite the expression such that the sub-expression is in a movable\nexpression statement while maintaining evaluation order.\n\nTwo types of subexpressions are extracted from the source expression:\n1) subexpressions with side-effects.\n2) conditional expressions, that contain the call, which are transformed\ninto IF statements.\n\nThe following terms are used:\n   expressionRoot: The top level node before which the any extracted\n                   expressions should be placed before.\n   nonconditionalExpr: The node that will be extracted either expres.\n",
      "diff": "@@ -1,48 +1,48 @@\n private void exposeExpression(Node expressionRoot, Node subExpression) {\n     Node nonconditionalExpr \u003d findNonconditionalParent(subExpression, expressionRoot);\n     boolean hasFollowingSideEffects \u003d NodeUtil.mayHaveSideEffects(nonconditionalExpr);\n     Node exprInjectionPoint \u003d findInjectionPoint(nonconditionalExpr);\n     DecompositionState state \u003d new DecompositionState();\n     state.sideEffects \u003d hasFollowingSideEffects;\n     state.extractBeforeStatement \u003d exprInjectionPoint;\n-    for (Node child \u003d nonconditionalExpr, parent \u003d child.getParent(); parent !\u003d expressionRoot; child \u003d parent, parent \u003d child.getParent()) {\n+    for (Node grandchild \u003d null, child \u003d nonconditionalExpr, parent \u003d child.getParent(); parent !\u003d expressionRoot; grandchild \u003d child, child \u003d parent, parent \u003d child.getParent()) {\n         int parentType \u003d parent.getType();\n         Preconditions.checkState(!isConditionalOp(parent) || child \u003d\u003d parent.getFirstChild());\n         if (parentType \u003d\u003d Token.ASSIGN) {\n             if (isSafeAssign(parent, state.sideEffects)) {\n             } else {\n                 Node left \u003d parent.getFirstChild();\n                 int type \u003d left.getType();\n                 if (left !\u003d child) {\n                     Preconditions.checkState(NodeUtil.isGet(left));\n                     if (type \u003d\u003d Token.GETELEM) {\n                         decomposeSubExpressions(left.getLastChild(), null, state);\n                     }\n                     decomposeSubExpressions(left.getFirstChild(), null, state);\n                 }\n             }\n         } else if (parentType \u003d\u003d Token.CALL \u0026\u0026 NodeUtil.isGet(parent.getFirstChild())) {\n-            if (!maybeExternMethod(parent.getFirstChild())) {\n-                throw new IllegalStateException(\"External object method calls can not be decomposed.\");\n-            } else {\n-                Node functionExpression \u003d parent.getFirstChild();\n-                decomposeSubExpressions(functionExpression.getNext(), child, state);\n-                if (isExpressionTreeUnsafe(functionExpression, state.sideEffects)) {\n+            Node functionExpression \u003d parent.getFirstChild();\n+            decomposeSubExpressions(functionExpression.getNext(), child, state);\n+            if (isExpressionTreeUnsafe(functionExpression, state.sideEffects) \u0026\u0026 functionExpression.getFirstChild() !\u003d grandchild) {\n+                if (true) {\n+                    throw new IllegalStateException(\"Object method calls can not be decomposed.\");\n+                } else {\n                     state.sideEffects \u003d true;\n                     Node replacement \u003d rewriteCallExpression(parent, state);\n                     parent \u003d replacement;\n                 }\n             }\n         } else if (parentType \u003d\u003d Token.OBJECTLIT) {\n             decomposeObjectLiteralKeys(parent.getFirstChild(), child, state);\n         } else {\n             decomposeSubExpressions(parent.getFirstChild(), child, state);\n         }\n     }\n     if (nonconditionalExpr \u003d\u003d subExpression) {\n     } else {\n         Node parent \u003d nonconditionalExpr.getParent();\n         boolean needResult \u003d parent.getType() !\u003d Token.EXPR_RESULT;\n         Node extractedConditional \u003d extractConditional(nonconditionalExpr, exprInjectionPoint, needResult);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "34fd5f8275ae69fc772c2283a3c5fd13b93a7c42": {
      "type": "Ybodychange",
      "commitMessage": "\nChange the OBJECTLIT AST structure from:\n\nOBJECTLIT\n  KEY1\n  VALUE1\n\nto\n\nOBJECTLIT\n  KEY1\n    VALUE1\n\nFixes issue 241\n\nR\u003dacleung,johnlenz,stevey\nDELTA\u003d268  (101 added, 51 deleted, 116 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d356416\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@494 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "10/18/10, 2:55 PM",
      "commitName": "34fd5f8275ae69fc772c2283a3c5fd13b93a7c42",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "10/14/10, 8:43 AM",
      "commitNameOld": "725ecc108d6c4e02730ed79f471437f240fbc107",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 4.26,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "private void exposeExpression(Node expressionRoot, Node subExpression) {\n    Node nonconditionalExpr \u003d findNonconditionalParent(subExpression, expressionRoot);\n    boolean hasFollowingSideEffects \u003d NodeUtil.mayHaveSideEffects(nonconditionalExpr);\n    Node exprInjectionPoint \u003d findInjectionPoint(nonconditionalExpr);\n    DecompositionState state \u003d new DecompositionState();\n    state.sideEffects \u003d hasFollowingSideEffects;\n    state.extractBeforeStatement \u003d exprInjectionPoint;\n    for (Node child \u003d nonconditionalExpr, parent \u003d child.getParent(); parent !\u003d expressionRoot; child \u003d parent, parent \u003d child.getParent()) {\n        int parentType \u003d parent.getType();\n        Preconditions.checkState(!isConditionalOp(parent) || child \u003d\u003d parent.getFirstChild());\n        if (parentType \u003d\u003d Token.ASSIGN) {\n            if (isSafeAssign(parent, state.sideEffects)) {\n            } else {\n                Node left \u003d parent.getFirstChild();\n                int type \u003d left.getType();\n                if (left !\u003d child) {\n                    Preconditions.checkState(NodeUtil.isGet(left));\n                    if (type \u003d\u003d Token.GETELEM) {\n                        decomposeSubExpressions(left.getLastChild(), null, state);\n                    }\n                    decomposeSubExpressions(left.getFirstChild(), null, state);\n                }\n            }\n        } else if (parentType \u003d\u003d Token.CALL \u0026\u0026 NodeUtil.isGet(parent.getFirstChild())) {\n            if (!maybeExternMethod(parent.getFirstChild())) {\n                throw new IllegalStateException(\"External object method calls can not be decomposed.\");\n            } else {\n                Node functionExpression \u003d parent.getFirstChild();\n                decomposeSubExpressions(functionExpression.getNext(), child, state);\n                if (isExpressionTreeUnsafe(functionExpression, state.sideEffects)) {\n                    state.sideEffects \u003d true;\n                    Node replacement \u003d rewriteCallExpression(parent, state);\n                    parent \u003d replacement;\n                }\n            }\n        } else if (parentType \u003d\u003d Token.OBJECTLIT) {\n            decomposeObjectLiteralKeys(parent.getFirstChild(), child, state);\n        } else {\n            decomposeSubExpressions(parent.getFirstChild(), child, state);\n        }\n    }\n    if (nonconditionalExpr \u003d\u003d subExpression) {\n    } else {\n        Node parent \u003d nonconditionalExpr.getParent();\n        boolean needResult \u003d parent.getType() !\u003d Token.EXPR_RESULT;\n        Node extractedConditional \u003d extractConditional(nonconditionalExpr, exprInjectionPoint, needResult);\n    }\n}",
      "path": "src/com/google/javascript/jscomp/ExpressionDecomposer.java",
      "functionStartLine": 145,
      "functionName": "exposeExpression",
      "functionAnnotation": "",
      "functionDoc": "Rewrite the expression such that the sub-expression is in a movable\nexpression statement while maintaining evaluation order.\n\nTwo types of subexpressions are extracted from the source expression:\n1) subexpressions with side-effects.\n2) conditional expressions, that contain the call, which are transformed\ninto IF statements.\n\nThe following terms are used:\n   expressionRoot: The top level node before which the any extracted\n                   expressions should be placed before.\n   nonconditionalExpr: The node that will be extracted either expres.\n",
      "diff": "@@ -1,46 +1,48 @@\n private void exposeExpression(Node expressionRoot, Node subExpression) {\n     Node nonconditionalExpr \u003d findNonconditionalParent(subExpression, expressionRoot);\n     boolean hasFollowingSideEffects \u003d NodeUtil.mayHaveSideEffects(nonconditionalExpr);\n     Node exprInjectionPoint \u003d findInjectionPoint(nonconditionalExpr);\n     DecompositionState state \u003d new DecompositionState();\n     state.sideEffects \u003d hasFollowingSideEffects;\n     state.extractBeforeStatement \u003d exprInjectionPoint;\n     for (Node child \u003d nonconditionalExpr, parent \u003d child.getParent(); parent !\u003d expressionRoot; child \u003d parent, parent \u003d child.getParent()) {\n         int parentType \u003d parent.getType();\n         Preconditions.checkState(!isConditionalOp(parent) || child \u003d\u003d parent.getFirstChild());\n         if (parentType \u003d\u003d Token.ASSIGN) {\n             if (isSafeAssign(parent, state.sideEffects)) {\n             } else {\n                 Node left \u003d parent.getFirstChild();\n                 int type \u003d left.getType();\n                 if (left !\u003d child) {\n                     Preconditions.checkState(NodeUtil.isGet(left));\n                     if (type \u003d\u003d Token.GETELEM) {\n                         decomposeSubExpressions(left.getLastChild(), null, state);\n                     }\n                     decomposeSubExpressions(left.getFirstChild(), null, state);\n                 }\n             }\n         } else if (parentType \u003d\u003d Token.CALL \u0026\u0026 NodeUtil.isGet(parent.getFirstChild())) {\n             if (!maybeExternMethod(parent.getFirstChild())) {\n                 throw new IllegalStateException(\"External object method calls can not be decomposed.\");\n             } else {\n                 Node functionExpression \u003d parent.getFirstChild();\n                 decomposeSubExpressions(functionExpression.getNext(), child, state);\n                 if (isExpressionTreeUnsafe(functionExpression, state.sideEffects)) {\n                     state.sideEffects \u003d true;\n                     Node replacement \u003d rewriteCallExpression(parent, state);\n                     parent \u003d replacement;\n                 }\n             }\n+        } else if (parentType \u003d\u003d Token.OBJECTLIT) {\n+            decomposeObjectLiteralKeys(parent.getFirstChild(), child, state);\n         } else {\n             decomposeSubExpressions(parent.getFirstChild(), child, state);\n         }\n     }\n     if (nonconditionalExpr \u003d\u003d subExpression) {\n     } else {\n         Node parent \u003d nonconditionalExpr.getParent();\n         boolean needResult \u003d parent.getType() !\u003d Token.EXPR_RESULT;\n         Node extractedConditional \u003d extractConditional(nonconditionalExpr, exprInjectionPoint, needResult);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3ce4716848eb71b6e78a4545a2cc0c27e74a29b3": {
      "type": "Yformatchange",
      "commitMessage": "Tweak to allow chained initialization:\nnew Node(Token.EXPR_RESULT, a).copyInformationFrom(a); (John)\nR\u003dalan\nDELTA\u003d10  (6 added, 0 deleted, 4 changed)\n\n\nTeach PureFunctionnIdentifier about (f || g)() calls (antonio)\nFixes issue 116\nR\u003djohn\nDELTA\u003d105  (84 added, 0 deleted, 21 changed)\n\nFix decomposition issue \nAnonymous function declaration can not be side-effected and are\nside-effect free. (John)\nR\u003dalan\nDELTA\u003d115  (101 added, 8 deleted, 6 changed)\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@154 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "3/25/10, 8:58 AM",
      "commitName": "3ce4716848eb71b6e78a4545a2cc0c27e74a29b3",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "3/11/10, 9:31 PM",
      "commitNameOld": "7bfdbd9164601af44d17edd51be829fde2cc51aa",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 13.44,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "actualSource": "private void exposeExpression(Node expressionRoot, Node subExpression) {\n    Node nonconditionalExpr \u003d findNonconditionalParent(subExpression, expressionRoot);\n    boolean hasFollowingSideEffects \u003d NodeUtil.mayHaveSideEffects(nonconditionalExpr);\n    Node exprInjectionPoint \u003d findInjectionPoint(nonconditionalExpr);\n    DecompositionState state \u003d new DecompositionState();\n    state.sideEffects \u003d hasFollowingSideEffects;\n    state.extractBeforeStatement \u003d exprInjectionPoint;\n    for (Node child \u003d nonconditionalExpr, parent \u003d child.getParent(); parent !\u003d expressionRoot; child \u003d parent, parent \u003d child.getParent()) {\n        int parentType \u003d parent.getType();\n        Preconditions.checkState(!isConditionalOp(parent) || child \u003d\u003d parent.getFirstChild());\n        if (parentType \u003d\u003d Token.ASSIGN) {\n            if (isSafeAssign(parent, state.sideEffects)) {\n            } else {\n                Node left \u003d parent.getFirstChild();\n                int type \u003d left.getType();\n                if (left !\u003d child) {\n                    Preconditions.checkState(NodeUtil.isGet(left));\n                    if (type \u003d\u003d Token.GETELEM) {\n                        decomposeSubExpressions(left.getLastChild(), null, state);\n                    }\n                    decomposeSubExpressions(left.getFirstChild(), null, state);\n                }\n            }\n        } else if (parentType \u003d\u003d Token.CALL \u0026\u0026 NodeUtil.isGet(parent.getFirstChild())) {\n            if (!maybeExternMethod(parent.getFirstChild())) {\n                throw new IllegalStateException(\"External object method calls can not be decomposed.\");\n            } else {\n                Node functionExpression \u003d parent.getFirstChild();\n                decomposeSubExpressions(functionExpression.getNext(), child, state);\n                if (isExpressionTreeUnsafe(functionExpression, state.sideEffects)) {\n                    state.sideEffects \u003d true;\n                    Node replacement \u003d rewriteCallExpression(parent, state);\n                    parent \u003d replacement;\n                }\n            }\n        } else {\n            decomposeSubExpressions(parent.getFirstChild(), child, state);\n        }\n    }\n    if (nonconditionalExpr \u003d\u003d subExpression) {\n    } else {\n        Node parent \u003d nonconditionalExpr.getParent();\n        boolean needResult \u003d parent.getType() !\u003d Token.EXPR_RESULT;\n        Node extractedConditional \u003d extractConditional(nonconditionalExpr, exprInjectionPoint, needResult);\n    }\n}",
      "path": "src/com/google/javascript/jscomp/ExpressionDecomposer.java",
      "functionStartLine": 143,
      "functionName": "exposeExpression",
      "functionAnnotation": "",
      "functionDoc": "Rewrite the expression such that the sub-expression is in a movable\nexpression statement while maintaining evaluation order.\n\nTwo types of subexpressions are extracted from the source expression:\n1) subexpressions with side-effects.\n2) conditional expressions, that contain the call, which are transformed\ninto IF statements.\n\nThe following terms are used:\n   expressionRoot: The top level node before which the any extracted\n                   expressions should be placed before.\n   nonconditionalExpr: The node that will be extracted either expres.\n",
      "diff": "",
      "extendedDetails": {}
    },
    "78995bf9e88599055a8c4165d89c09dc92a44b30": {
      "type": "Ybodychange",
      "commitMessage": "Fix synthesis of vars in DEFAULT mode.\nBetter variable inlining\nBetter function inlining\nAssorted bug fixes\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@6 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/10/09, 11:16 AM",
      "commitName": "78995bf9e88599055a8c4165d89c09dc92a44b30",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "commitDateOld": "11/3/09, 3:51 PM",
      "commitNameOld": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthorOld": "nicholas.j.santos@gmail.com",
      "daysBetweenCommits": 6.81,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "private void exposeExpression(Node expressionRoot, Node subExpression) {\n    Node nonconditionalExpr \u003d findNonconditionalParent(subExpression, expressionRoot);\n    boolean hasFollowingSideEffects \u003d NodeUtil.mayHaveSideEffects(nonconditionalExpr);\n    Node exprInjectionPoint \u003d findInjectionPoint(nonconditionalExpr);\n    DecompositionState state \u003d new DecompositionState();\n    state.sideEffects \u003d hasFollowingSideEffects;\n    state.extractBeforeStatement \u003d exprInjectionPoint;\n    for (Node child \u003d nonconditionalExpr, parent \u003d child.getParent(); parent !\u003d expressionRoot; child \u003d parent, parent \u003d child.getParent()) {\n        int parentType \u003d parent.getType();\n        Preconditions.checkState(!isConditionalOp(parent) || child \u003d\u003d parent.getFirstChild());\n        if (parentType \u003d\u003d Token.ASSIGN) {\n            if (isSafeAssign(parent, state.sideEffects)) {\n            } else {\n                Node left \u003d parent.getFirstChild();\n                int type \u003d left.getType();\n                if (left !\u003d child) {\n                    Preconditions.checkState(NodeUtil.isGet(left));\n                    if (type \u003d\u003d Token.GETELEM) {\n                        decomposeSubExpressions(left.getLastChild(), null, state);\n                    }\n                    decomposeSubExpressions(left.getFirstChild(), null, state);\n                }\n            }\n        } else if (parentType \u003d\u003d Token.CALL \u0026\u0026 NodeUtil.isGet(parent.getFirstChild())) {\n            if (!maybeExternMethod(parent.getFirstChild())) {\n                throw new IllegalStateException(\"External object method calls can not be decomposed.\");\n            } else {\n                Node functionExpression \u003d parent.getFirstChild();\n                decomposeSubExpressions(functionExpression.getNext(), child, state);\n                if (isExpressionTreeUnsafe(functionExpression, state.sideEffects)) {\n                    state.sideEffects \u003d true;\n                    Node replacement \u003d rewriteCallExpression(parent, state);\n                    parent \u003d replacement;\n                }\n            }\n        } else {\n            decomposeSubExpressions(parent.getFirstChild(), child, state);\n        }\n    }\n    if (nonconditionalExpr \u003d\u003d subExpression) {\n    } else {\n        Node parent \u003d nonconditionalExpr.getParent();\n        boolean needResult \u003d parent.getType() !\u003d Token.EXPR_RESULT;\n        Node extractedConditional \u003d extractConditional(nonconditionalExpr, exprInjectionPoint, needResult);\n    }\n}",
      "path": "src/com/google/javascript/jscomp/ExpressionDecomposer.java",
      "functionStartLine": 142,
      "functionName": "exposeExpression",
      "functionAnnotation": "",
      "functionDoc": "Rewrite the expression such that the sub-expression is in a movable\nexpression statement while maintaining evaluation order.\n\nTwo types of subexpressions are extracted from the source expression:\n1) subexpressions with side-effects.\n2) conditional expressions, that contain the call, which are transformed\ninto IF statements.\n\nThe following terms are used:\n   expressionRoot: The top level node before which the any extracted\n                   expressions should be placed before.\n   nonconditionalExpr: The node that will be extracted either expres.\n",
      "diff": "@@ -1,42 +1,46 @@\n private void exposeExpression(Node expressionRoot, Node subExpression) {\n     Node nonconditionalExpr \u003d findNonconditionalParent(subExpression, expressionRoot);\n     boolean hasFollowingSideEffects \u003d NodeUtil.mayHaveSideEffects(nonconditionalExpr);\n     Node exprInjectionPoint \u003d findInjectionPoint(nonconditionalExpr);\n     DecompositionState state \u003d new DecompositionState();\n     state.sideEffects \u003d hasFollowingSideEffects;\n     state.extractBeforeStatement \u003d exprInjectionPoint;\n     for (Node child \u003d nonconditionalExpr, parent \u003d child.getParent(); parent !\u003d expressionRoot; child \u003d parent, parent \u003d child.getParent()) {\n         int parentType \u003d parent.getType();\n         Preconditions.checkState(!isConditionalOp(parent) || child \u003d\u003d parent.getFirstChild());\n         if (parentType \u003d\u003d Token.ASSIGN) {\n-            if (parent.getFirstChild().getType() \u003d\u003d Token.NAME) {\n+            if (isSafeAssign(parent, state.sideEffects)) {\n             } else {\n                 Node left \u003d parent.getFirstChild();\n                 int type \u003d left.getType();\n                 if (left !\u003d child) {\n                     Preconditions.checkState(NodeUtil.isGet(left));\n                     if (type \u003d\u003d Token.GETELEM) {\n                         decomposeSubExpressions(left.getLastChild(), null, state);\n                     }\n                     decomposeSubExpressions(left.getFirstChild(), null, state);\n                 }\n             }\n         } else if (parentType \u003d\u003d Token.CALL \u0026\u0026 NodeUtil.isGet(parent.getFirstChild())) {\n-            Node functionExpression \u003d parent.getFirstChild();\n-            decomposeSubExpressions(functionExpression.getNext(), child, state);\n-            if (isExpressionTreeUnsafe(functionExpression, state.sideEffects)) {\n-                state.sideEffects \u003d true;\n-                Node replacement \u003d rewriteCallExpression(parent, state);\n-                parent \u003d replacement;\n+            if (!maybeExternMethod(parent.getFirstChild())) {\n+                throw new IllegalStateException(\"External object method calls can not be decomposed.\");\n+            } else {\n+                Node functionExpression \u003d parent.getFirstChild();\n+                decomposeSubExpressions(functionExpression.getNext(), child, state);\n+                if (isExpressionTreeUnsafe(functionExpression, state.sideEffects)) {\n+                    state.sideEffects \u003d true;\n+                    Node replacement \u003d rewriteCallExpression(parent, state);\n+                    parent \u003d replacement;\n+                }\n             }\n         } else {\n             decomposeSubExpressions(parent.getFirstChild(), child, state);\n         }\n     }\n     if (nonconditionalExpr \u003d\u003d subExpression) {\n     } else {\n         Node parent \u003d nonconditionalExpr.getParent();\n         boolean needResult \u003d parent.getType() !\u003d Token.EXPR_RESULT;\n         Node extractedConditional \u003d extractConditional(nonconditionalExpr, exprInjectionPoint, needResult);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": {
      "type": "Yintroduced",
      "commitMessage": "Initial commit.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/3/09, 3:51 PM",
      "commitName": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "diff": "@@ -0,0 +1,42 @@\n+private void exposeExpression(Node expressionRoot, Node subExpression) {\n+    Node nonconditionalExpr \u003d findNonconditionalParent(subExpression, expressionRoot);\n+    boolean hasFollowingSideEffects \u003d NodeUtil.mayHaveSideEffects(nonconditionalExpr);\n+    Node exprInjectionPoint \u003d findInjectionPoint(nonconditionalExpr);\n+    DecompositionState state \u003d new DecompositionState();\n+    state.sideEffects \u003d hasFollowingSideEffects;\n+    state.extractBeforeStatement \u003d exprInjectionPoint;\n+    for (Node child \u003d nonconditionalExpr, parent \u003d child.getParent(); parent !\u003d expressionRoot; child \u003d parent, parent \u003d child.getParent()) {\n+        int parentType \u003d parent.getType();\n+        Preconditions.checkState(!isConditionalOp(parent) || child \u003d\u003d parent.getFirstChild());\n+        if (parentType \u003d\u003d Token.ASSIGN) {\n+            if (parent.getFirstChild().getType() \u003d\u003d Token.NAME) {\n+            } else {\n+                Node left \u003d parent.getFirstChild();\n+                int type \u003d left.getType();\n+                if (left !\u003d child) {\n+                    Preconditions.checkState(NodeUtil.isGet(left));\n+                    if (type \u003d\u003d Token.GETELEM) {\n+                        decomposeSubExpressions(left.getLastChild(), null, state);\n+                    }\n+                    decomposeSubExpressions(left.getFirstChild(), null, state);\n+                }\n+            }\n+        } else if (parentType \u003d\u003d Token.CALL \u0026\u0026 NodeUtil.isGet(parent.getFirstChild())) {\n+            Node functionExpression \u003d parent.getFirstChild();\n+            decomposeSubExpressions(functionExpression.getNext(), child, state);\n+            if (isExpressionTreeUnsafe(functionExpression, state.sideEffects)) {\n+                state.sideEffects \u003d true;\n+                Node replacement \u003d rewriteCallExpression(parent, state);\n+                parent \u003d replacement;\n+            }\n+        } else {\n+            decomposeSubExpressions(parent.getFirstChild(), child, state);\n+        }\n+    }\n+    if (nonconditionalExpr \u003d\u003d subExpression) {\n+    } else {\n+        Node parent \u003d nonconditionalExpr.getParent();\n+        boolean needResult \u003d parent.getType() !\u003d Token.EXPR_RESULT;\n+        Node extractedConditional \u003d extractConditional(nonconditionalExpr, exprInjectionPoint, needResult);\n+    }\n+}\n\\ No newline at end of file\n",
      "actualSource": "private void exposeExpression(Node expressionRoot, Node subExpression) {\n    Node nonconditionalExpr \u003d findNonconditionalParent(subExpression, expressionRoot);\n    boolean hasFollowingSideEffects \u003d NodeUtil.mayHaveSideEffects(nonconditionalExpr);\n    Node exprInjectionPoint \u003d findInjectionPoint(nonconditionalExpr);\n    DecompositionState state \u003d new DecompositionState();\n    state.sideEffects \u003d hasFollowingSideEffects;\n    state.extractBeforeStatement \u003d exprInjectionPoint;\n    for (Node child \u003d nonconditionalExpr, parent \u003d child.getParent(); parent !\u003d expressionRoot; child \u003d parent, parent \u003d child.getParent()) {\n        int parentType \u003d parent.getType();\n        Preconditions.checkState(!isConditionalOp(parent) || child \u003d\u003d parent.getFirstChild());\n        if (parentType \u003d\u003d Token.ASSIGN) {\n            if (parent.getFirstChild().getType() \u003d\u003d Token.NAME) {\n            } else {\n                Node left \u003d parent.getFirstChild();\n                int type \u003d left.getType();\n                if (left !\u003d child) {\n                    Preconditions.checkState(NodeUtil.isGet(left));\n                    if (type \u003d\u003d Token.GETELEM) {\n                        decomposeSubExpressions(left.getLastChild(), null, state);\n                    }\n                    decomposeSubExpressions(left.getFirstChild(), null, state);\n                }\n            }\n        } else if (parentType \u003d\u003d Token.CALL \u0026\u0026 NodeUtil.isGet(parent.getFirstChild())) {\n            Node functionExpression \u003d parent.getFirstChild();\n            decomposeSubExpressions(functionExpression.getNext(), child, state);\n            if (isExpressionTreeUnsafe(functionExpression, state.sideEffects)) {\n                state.sideEffects \u003d true;\n                Node replacement \u003d rewriteCallExpression(parent, state);\n                parent \u003d replacement;\n            }\n        } else {\n            decomposeSubExpressions(parent.getFirstChild(), child, state);\n        }\n    }\n    if (nonconditionalExpr \u003d\u003d subExpression) {\n    } else {\n        Node parent \u003d nonconditionalExpr.getParent();\n        boolean needResult \u003d parent.getType() !\u003d Token.EXPR_RESULT;\n        Node extractedConditional \u003d extractConditional(nonconditionalExpr, exprInjectionPoint, needResult);\n    }\n}",
      "path": "src/com/google/javascript/jscomp/ExpressionDecomposer.java",
      "functionStartLine": 136,
      "functionName": "exposeExpression",
      "functionAnnotation": "",
      "functionDoc": "Rewrite the expression such that the sub-expression is in a movable\nexpression statement while maintaining evaluation order.\n\nTwo types of subexpressions are extracted from the source expression:\n1) subexpressions with side-effects.\n2) conditional expressions, that contain the call, which are transformed\ninto IF statements.\n\nThe following terms are used:\n   expressionRoot: The top level node before which the any extracted\n                   expressions should be placed before.\n   nonconditionalExpr: The node that will be extracted either expres.\n"
    }
  }
}