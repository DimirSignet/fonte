{
  "origin": "codeshovel",
  "repositoryName": "Closure-115b",
  "repositoryPath": "/tmp/Closure-115b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FunctionInjector.java",
  "functionName": "canInlineReferenceToFunction",
  "functionId": "canInlineReferenceToFunction___t-NodeTraversal__callNode-Node__fnNode-Node__needAliases-Set__String____mode-InliningMode__referencesThis-boolean__containsFunctions-boolean",
  "sourceFilePath": "src/com/google/javascript/jscomp/FunctionInjector.java",
  "functionAnnotation": "",
  "functionDoc": "\n@param t The traversal use to reach the call site.\n@param callNode The CALL node.\n@param fnNode The function to evaluate for inlining.\n@param needAliases A set of function parameter names that can not be\n    used without aliasing. Returned by getUnsafeParameterNames().\n@param mode Inlining mode to be used.\n@param referencesThis Whether fnNode contains references to its this\n    object.\n@param containsFunctions Whether fnNode contains inner functions.\n@return Whether the inlining can occur.\n",
  "functionStartLine": 173,
  "functionEndLine": 213,
  "numCommitsSeen": 41,
  "timeTaken": 2307,
  "changeHistory": [
    "de20cf30dfdf0f885c9b97dfb75f8425df0280b9",
    "f791e3a7a172728b54a337c94bff4bc27c7adc43",
    "43cece8ccf72521faa04fc79fddfc5f7d661a787",
    "0b05c26eefae171f9b4d0e1f8eba4249088207fa",
    "e33e925eea3a8e4de958864e531e1adc4da62e18",
    "b4801b28ceea8db0f63da7440d6769cb9b7cce8a",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3"
  ],
  "changeHistoryShort": {
    "de20cf30dfdf0f885c9b97dfb75f8425df0280b9": "Ybodychange",
    "f791e3a7a172728b54a337c94bff4bc27c7adc43": "Ybodychange",
    "43cece8ccf72521faa04fc79fddfc5f7d661a787": "Ybodychange",
    "0b05c26eefae171f9b4d0e1f8eba4249088207fa": "Ybodychange",
    "e33e925eea3a8e4de958864e531e1adc4da62e18": "Yformatchange",
    "b4801b28ceea8db0f63da7440d6769cb9b7cce8a": "Ymultichange(Yparameterchange,Ybodychange,Ydocchange)",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "de20cf30dfdf0f885c9b97dfb75f8425df0280b9": {
      "type": "Ybodychange",
      "commitMessage": "\nAdd an inliner option to inline function without considering whether \"capture\" of variables. Traditionally, we have avoiding inlining function with closure into scope (because they might capture unintended values) or inline functions that require temporaries into scopes that contain closures (because the temps might leak into the closure scopes).\nThis CL does not include a means of enabling the option.\n\nR\u003dacleung\nDELTA\u003d332  (313 added, 0 deleted, 19 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3089\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1378 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "8/22/11, 5:34 PM",
      "commitName": "de20cf30dfdf0f885c9b97dfb75f8425df0280b9",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "8/22/11, 2:35 PM",
      "commitNameOld": "f791e3a7a172728b54a337c94bff4bc27c7adc43",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 0.12,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "CanInlineResult canInlineReferenceToFunction(NodeTraversal t, Node callNode, Node fnNode, Set\u003cString\u003e needAliases, InliningMode mode, boolean referencesThis, boolean containsFunctions) {\n    if (!isSupportedCallType(callNode)) {\n        return CanInlineResult.NO;\n    }\n    if (containsFunctions) {\n        if (!assumeMinimumCapture \u0026\u0026 !t.inGlobalScope()) {\n            return CanInlineResult.NO;\n        } else if (NodeUtil.isWithinLoop(callNode)) {\n            return CanInlineResult.NO;\n        }\n    }\n    if (referencesThis \u0026\u0026 !NodeUtil.isFunctionObjectCall(callNode)) {\n        return CanInlineResult.NO;\n    }\n    if (mode \u003d\u003d InliningMode.DIRECT) {\n        return canInlineReferenceDirectly(callNode, fnNode);\n    } else {\n        return canInlineReferenceAsStatementBlock(t, callNode, fnNode, needAliases);\n    }\n}",
      "path": "src/com/google/javascript/jscomp/FunctionInjector.java",
      "functionStartLine": 169,
      "functionName": "canInlineReferenceToFunction",
      "functionAnnotation": "",
      "functionDoc": "\n@param t The traversal use to reach the call site.\n@param callNode The CALL node.\n@param fnNode The function to evaluate for inlining.\n@param needAliases A set of function parameter names that can not be\n    used without aliasing. Returned by getUnsafeParameterNames().\n@param mode Inlining mode to be used.\n@param referencesThis Whether fnNode contains references to its this\n    object.\n@param containsFunctions Whether fnNode contains inner functions.\n@return Whether the inlining can occur.\n",
      "diff": "@@ -1,20 +1,20 @@\n CanInlineResult canInlineReferenceToFunction(NodeTraversal t, Node callNode, Node fnNode, Set\u003cString\u003e needAliases, InliningMode mode, boolean referencesThis, boolean containsFunctions) {\n     if (!isSupportedCallType(callNode)) {\n         return CanInlineResult.NO;\n     }\n     if (containsFunctions) {\n-        if (!t.inGlobalScope()) {\n+        if (!assumeMinimumCapture \u0026\u0026 !t.inGlobalScope()) {\n             return CanInlineResult.NO;\n         } else if (NodeUtil.isWithinLoop(callNode)) {\n             return CanInlineResult.NO;\n         }\n     }\n     if (referencesThis \u0026\u0026 !NodeUtil.isFunctionObjectCall(callNode)) {\n         return CanInlineResult.NO;\n     }\n     if (mode \u003d\u003d InliningMode.DIRECT) {\n         return canInlineReferenceDirectly(callNode, fnNode);\n     } else {\n         return canInlineReferenceAsStatementBlock(t, callNode, fnNode, needAliases);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f791e3a7a172728b54a337c94bff4bc27c7adc43": {
      "type": "Ybodychange",
      "commitMessage": "\nDon\u0027t inline function with inner function into loops.\n\nR\u003dacleung\nDELTA\u003d30  (26 added, 0 deleted, 4 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3083\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1372 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "8/22/11, 2:35 PM",
      "commitName": "f791e3a7a172728b54a337c94bff4bc27c7adc43",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "8/19/11, 11:37 AM",
      "commitNameOld": "869c65d5c43d96526d90c7ea9a186df9edd67eb0",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 3.12,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "CanInlineResult canInlineReferenceToFunction(NodeTraversal t, Node callNode, Node fnNode, Set\u003cString\u003e needAliases, InliningMode mode, boolean referencesThis, boolean containsFunctions) {\n    if (!isSupportedCallType(callNode)) {\n        return CanInlineResult.NO;\n    }\n    if (containsFunctions) {\n        if (!t.inGlobalScope()) {\n            return CanInlineResult.NO;\n        } else if (NodeUtil.isWithinLoop(callNode)) {\n            return CanInlineResult.NO;\n        }\n    }\n    if (referencesThis \u0026\u0026 !NodeUtil.isFunctionObjectCall(callNode)) {\n        return CanInlineResult.NO;\n    }\n    if (mode \u003d\u003d InliningMode.DIRECT) {\n        return canInlineReferenceDirectly(callNode, fnNode);\n    } else {\n        return canInlineReferenceAsStatementBlock(t, callNode, fnNode, needAliases);\n    }\n}",
      "path": "src/com/google/javascript/jscomp/FunctionInjector.java",
      "functionStartLine": 166,
      "functionName": "canInlineReferenceToFunction",
      "functionAnnotation": "",
      "functionDoc": "\n@param t The traversal use to reach the call site.\n@param callNode The CALL node.\n@param fnNode The function to evaluate for inlining.\n@param needAliases A set of function parameter names that can not be\n    used without aliasing. Returned by getUnsafeParameterNames().\n@param mode Inlining mode to be used.\n@param referencesThis Whether fnNode contains references to its this\n    object.\n@param containsFunctions Whether fnNode contains inner functions.\n@return Whether the inlining can occur.\n",
      "diff": "@@ -1,16 +1,20 @@\n CanInlineResult canInlineReferenceToFunction(NodeTraversal t, Node callNode, Node fnNode, Set\u003cString\u003e needAliases, InliningMode mode, boolean referencesThis, boolean containsFunctions) {\n     if (!isSupportedCallType(callNode)) {\n         return CanInlineResult.NO;\n     }\n-    if (containsFunctions \u0026\u0026 !t.inGlobalScope()) {\n-        return CanInlineResult.NO;\n+    if (containsFunctions) {\n+        if (!t.inGlobalScope()) {\n+            return CanInlineResult.NO;\n+        } else if (NodeUtil.isWithinLoop(callNode)) {\n+            return CanInlineResult.NO;\n+        }\n     }\n     if (referencesThis \u0026\u0026 !NodeUtil.isFunctionObjectCall(callNode)) {\n         return CanInlineResult.NO;\n     }\n     if (mode \u003d\u003d InliningMode.DIRECT) {\n         return canInlineReferenceDirectly(callNode, fnNode);\n     } else {\n         return canInlineReferenceAsStatementBlock(t, callNode, fnNode, needAliases);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "43cece8ccf72521faa04fc79fddfc5f7d661a787": {
      "type": "Ybodychange",
      "commitMessage": "\nAutomated g4 rollback.\n\n*** Reason for rollback ***\n\nBreaks tests\n\n*** Original change description ***\n\nTweaks to function inlining:\n- an unnamed function expression containing a inner unnamed function\nexpression should not be disallow because the names are the same.\n- a caller that only contains the function definition to be inlined should\nnot consider the candidate to be a capturing function.\n- allow inlining a function containing an inner function that\nreferences arguments.\n- disallow inlining a function into a function containing eval.\n- when inlining a function containing a function dec\n\n... description truncated by g4 rollback ...\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d2930\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1339 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "8/8/11, 2:51 PM",
      "commitName": "43cece8ccf72521faa04fc79fddfc5f7d661a787",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "8/8/11, 2:03 PM",
      "commitNameOld": "0b05c26eefae171f9b4d0e1f8eba4249088207fa",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "CanInlineResult canInlineReferenceToFunction(NodeTraversal t, Node callNode, Node fnNode, Set\u003cString\u003e needAliases, InliningMode mode, boolean referencesThis, boolean containsFunctions) {\n    if (!isSupportedCallType(callNode)) {\n        return CanInlineResult.NO;\n    }\n    if (containsFunctions \u0026\u0026 !t.inGlobalScope()) {\n        return CanInlineResult.NO;\n    }\n    if (referencesThis \u0026\u0026 !NodeUtil.isFunctionObjectCall(callNode)) {\n        return CanInlineResult.NO;\n    }\n    if (mode \u003d\u003d InliningMode.DIRECT) {\n        return canInlineReferenceDirectly(callNode, fnNode);\n    } else {\n        return canInlineReferenceAsStatementBlock(t, callNode, fnNode, needAliases);\n    }\n}",
      "path": "src/com/google/javascript/jscomp/FunctionInjector.java",
      "functionStartLine": 160,
      "functionName": "canInlineReferenceToFunction",
      "functionAnnotation": "",
      "functionDoc": "\n@param t The traversal use to reach the call site.\n@param callNode The CALL node.\n@param fnNode The function to evaluate for inlining.\n@param needAliases A set of function parameter names that can not be\n    used without aliasing. Returned by getUnsafeParameterNames().\n@param mode Inlining mode to be used.\n@param referencesThis Whether fnNode contains references to its this\n    object.\n@param containsFunctions Whether fnNode contains inner functions.\n@return Whether the inlining can occur.\n",
      "diff": "@@ -1,13 +1,16 @@\n CanInlineResult canInlineReferenceToFunction(NodeTraversal t, Node callNode, Node fnNode, Set\u003cString\u003e needAliases, InliningMode mode, boolean referencesThis, boolean containsFunctions) {\n     if (!isSupportedCallType(callNode)) {\n         return CanInlineResult.NO;\n     }\n+    if (containsFunctions \u0026\u0026 !t.inGlobalScope()) {\n+        return CanInlineResult.NO;\n+    }\n     if (referencesThis \u0026\u0026 !NodeUtil.isFunctionObjectCall(callNode)) {\n         return CanInlineResult.NO;\n     }\n     if (mode \u003d\u003d InliningMode.DIRECT) {\n         return canInlineReferenceDirectly(callNode, fnNode);\n     } else {\n-        return canInlineReferenceAsStatementBlock(t, callNode, fnNode, needAliases, containsFunctions);\n+        return canInlineReferenceAsStatementBlock(t, callNode, fnNode, needAliases);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0b05c26eefae171f9b4d0e1f8eba4249088207fa": {
      "type": "Ybodychange",
      "commitMessage": "\nTweaks to function inlining:\n- an unnamed function expression containing a inner unnamed function\nexpression should not be disallow because the names are the same.\n- a caller that only contains the function definition to be inlined should\nnot consider the candidate to be a capturing function.\n- allow inlining a function containing an inner function that\nreferences arguments.\n- disallow inlining a function into a function containing eval.\n- when inlining a function containing a function declaration, rewrite\nit a var declarations and function expressions to avoid introducing\nfunction declaraions into contexts disallowed by ES5 strict.\n\nR\u003dacleung\nDELTA\u003d228  (182 added, 14 deleted, 32 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d2929\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1338 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "8/8/11, 2:03 PM",
      "commitName": "0b05c26eefae171f9b4d0e1f8eba4249088207fa",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "7/28/11, 4:19 PM",
      "commitNameOld": "76abdf11394c0e7515ae63335676ea3657badb45",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 10.91,
      "commitsBetweenForRepo": 29,
      "commitsBetweenForFile": 1,
      "actualSource": "CanInlineResult canInlineReferenceToFunction(NodeTraversal t, Node callNode, Node fnNode, Set\u003cString\u003e needAliases, InliningMode mode, boolean referencesThis, boolean containsFunctions) {\n    if (!isSupportedCallType(callNode)) {\n        return CanInlineResult.NO;\n    }\n    if (referencesThis \u0026\u0026 !NodeUtil.isFunctionObjectCall(callNode)) {\n        return CanInlineResult.NO;\n    }\n    if (mode \u003d\u003d InliningMode.DIRECT) {\n        return canInlineReferenceDirectly(callNode, fnNode);\n    } else {\n        return canInlineReferenceAsStatementBlock(t, callNode, fnNode, needAliases, containsFunctions);\n    }\n}",
      "path": "src/com/google/javascript/jscomp/FunctionInjector.java",
      "functionStartLine": 166,
      "functionName": "canInlineReferenceToFunction",
      "functionAnnotation": "",
      "functionDoc": "\n@param t The traversal use to reach the call site.\n@param callNode The CALL node.\n@param fnNode The function to evaluate for inlining.\n@param needAliases A set of function parameter names that can not be\n    used without aliasing. Returned by getUnsafeParameterNames().\n@param mode Inlining mode to be used.\n@param referencesThis Whether fnNode contains references to its this\n    object.\n@param containsFunctions Whether fnNode contains inner functions.\n@return Whether the inlining can occur.\n",
      "diff": "@@ -1,16 +1,13 @@\n CanInlineResult canInlineReferenceToFunction(NodeTraversal t, Node callNode, Node fnNode, Set\u003cString\u003e needAliases, InliningMode mode, boolean referencesThis, boolean containsFunctions) {\n     if (!isSupportedCallType(callNode)) {\n         return CanInlineResult.NO;\n     }\n-    if (containsFunctions \u0026\u0026 !t.inGlobalScope()) {\n-        return CanInlineResult.NO;\n-    }\n     if (referencesThis \u0026\u0026 !NodeUtil.isFunctionObjectCall(callNode)) {\n         return CanInlineResult.NO;\n     }\n     if (mode \u003d\u003d InliningMode.DIRECT) {\n         return canInlineReferenceDirectly(callNode, fnNode);\n     } else {\n-        return canInlineReferenceAsStatementBlock(t, callNode, fnNode, needAliases);\n+        return canInlineReferenceAsStatementBlock(t, callNode, fnNode, needAliases, containsFunctions);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e33e925eea3a8e4de958864e531e1adc4da62e18": {
      "type": "Yformatchange",
      "commitMessage": "\nChange on 2010/06/14 by johnlenz\n\n        Remove unneed parenthese from hook expressions.\n\n        R\u003dacleung\n        DELTA\u003d76  (20 added, 4 deleted, 52 changed)\n\nChange on 2010/06/14 by johnlenz\n\n        Fix non-determinisim.\n\n        R\u003djschorr\n        DELTA\u003d5  (3 added, 0 deleted, 2 changed)\n\nChange on 2010/06/15 by nicksantos\n\n        fix a regression caused by a change in the ordering in which\n        constant folding is done.\n        parts of PeepholeSubstituteAlternateSyntax will crash if they\n        see a NEG node with a NUMBER child.\n        They were assuming that FoldConstants would fold these into one node.\n\n        R\u003ddcc,acleung\n        DELTA\u003d153  (70 added, 6 deleted, 77 changed)\n\nChange on 2010/06/15 by johnlenz\n\n        More debug diffing improvements: convert unique globally unique names\n        to locally unique names for reproduciblity.\n\n        R\u003dacleung\n        DELTA\u003d222  (44 added, 7 deleted, 171 changed)\n\nChange on 2010/06/15 by nicksantos\n\n        Add the @nocompile annotation as a signal that this file should\n        be dropped silently if it gets pulled into a --manage_closure_dependencies\n        build.\n\n        R\u003dbowdidge,gboyer\n        DELTA\u003d82  (60 added, 1 deleted, 21 changed)\n\nChange on 2010/06/15 by dcc\n\n        Refactor FoldConstants dead code removal into PeepholeRemoveDeadCode.\n\n        R\u003dacleung\n        DELTA\u003d744  (403 added, 307 deleted, 34 changed)\n\nChange on 2010/06/15 by dcc\n\n        ExternExports test now emits type annotation for exported externs.\n                - Changed ExternExportsPass to generate the externs as an AST and then print\n        to a String rather than ad hoc with a StringBuilder.\n                - Changed TypedCodeGenerator to generate \u0027*\u0027 (AllType) for parameters with unknown types rather than \u0027?\u0027 (UnknownType) since \u0027?\u0027 is not valid JSDoc.\n\n        R\u003dacleung\n        DELTA\u003d643  (496 added, 66 deleted, 81 changed)\n\nChange on 2010/06/16 by johnlenz\n\n        Tweak to PureFunctionIndentifier to propagate the side-effects for\n        anonymous function expressions like: (Date.now||function(){return\n        +new Date})()\n\n        R\u003davd\n        DELTA\u003d42  (39 added, 0 deleted, 3 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d29010\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@243 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "6/16/10, 12:33 PM",
      "commitName": "e33e925eea3a8e4de958864e531e1adc4da62e18",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "5/29/10, 1:07 PM",
      "commitNameOld": "b4801b28ceea8db0f63da7440d6769cb9b7cce8a",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 17.98,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "CanInlineResult canInlineReferenceToFunction(NodeTraversal t, Node callNode, Node fnNode, Set\u003cString\u003e needAliases, InliningMode mode, boolean referencesThis, boolean containsFunctions) {\n    if (!isSupportedCallType(callNode)) {\n        return CanInlineResult.NO;\n    }\n    if (containsFunctions \u0026\u0026 !t.inGlobalScope()) {\n        return CanInlineResult.NO;\n    }\n    if (referencesThis \u0026\u0026 !NodeUtil.isFunctionObjectCall(callNode)) {\n        return CanInlineResult.NO;\n    }\n    if (mode \u003d\u003d InliningMode.DIRECT) {\n        return canInlineReferenceDirectly(callNode, fnNode);\n    } else {\n        return canInlineReferenceAsStatementBlock(t, callNode, fnNode, needAliases);\n    }\n}",
      "path": "src/com/google/javascript/jscomp/FunctionInjector.java",
      "functionStartLine": 150,
      "functionName": "canInlineReferenceToFunction",
      "functionAnnotation": "",
      "functionDoc": "\n@param t The traversal use to reach the call site.\n@param callNode The CALL node.\n@param fnNode The function to evaluate for inlining.\n@param needAliases A set of function parameter names that can not be\n    used without aliasing. Returned by getUnsafeParameterNames().\n@param mode Inlining mode to be used.\n@param referencesThis Whether fnNode contains references to its this\n    object.\n@param containsFunctions Whether fnNode contains inner functions.\n@return Whether the inlining can occur.\n",
      "diff": "",
      "extendedDetails": {}
    },
    "b4801b28ceea8db0f63da7440d6769cb9b7cce8a": {
      "type": "Ymultichange(Yparameterchange,Ybodychange,Ydocchange)",
      "commitMessage": "\nChange on 2010/05/28 by johnlenz\n\n        Inline functions with inner functions into global scope if they don\u0027t\n        declare any names.\n\n        R\u003dacleung\n        DELTA\u003d329  (244 added, 27 deleted, 58 changed)\n\nChange on 2010/05/28 by dcc\n\n        First pass on refactoring FoldConstants into separate peephole optimizations. This changelist adds the notion of an AbstractPeepholeOptimization and adds a PeepholeOptimizationsPass that runs them. In this go around the minimization aspects of FoldConstants have been factored out into PeepholeMinimize. A future change will factor out the other components of FoldConstants into their own PeepholeOptimizations. DefaultPassConfig has also been updated to run the new PeepholeOptimizationPass.\n\n        This change does not move the minimization-related unit tests from FoldConstantsTest to PeepholeMinimizeTest -- a future, separate, change will do so. Hopefully this will make it easier to review.\n\n        R\u003dacleung\n        DELTA\u003d1966  (1271 added, 675 deleted, 20 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d13010\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@235 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "5/29/10, 1:07 PM",
      "commitName": "b4801b28ceea8db0f63da7440d6769cb9b7cce8a",
      "commitAuthor": "Nicholas.J.Santos",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "\nChange on 2010/05/28 by johnlenz\n\n        Inline functions with inner functions into global scope if they don\u0027t\n        declare any names.\n\n        R\u003dacleung\n        DELTA\u003d329  (244 added, 27 deleted, 58 changed)\n\nChange on 2010/05/28 by dcc\n\n        First pass on refactoring FoldConstants into separate peephole optimizations. This changelist adds the notion of an AbstractPeepholeOptimization and adds a PeepholeOptimizationsPass that runs them. In this go around the minimization aspects of FoldConstants have been factored out into PeepholeMinimize. A future change will factor out the other components of FoldConstants into their own PeepholeOptimizations. DefaultPassConfig has also been updated to run the new PeepholeOptimizationPass.\n\n        This change does not move the minimization-related unit tests from FoldConstantsTest to PeepholeMinimizeTest -- a future, separate, change will do so. Hopefully this will make it easier to review.\n\n        R\u003dacleung\n        DELTA\u003d1966  (1271 added, 675 deleted, 20 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d13010\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@235 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "5/29/10, 1:07 PM",
          "commitName": "b4801b28ceea8db0f63da7440d6769cb9b7cce8a",
          "commitAuthor": "Nicholas.J.Santos",
          "commitDateOld": "4/16/10, 10:20 AM",
          "commitNameOld": "6e3eb4f7619179ba6c23db2af7549ef02f588c35",
          "commitAuthorOld": "Nicholas.J.Santos",
          "daysBetweenCommits": 43.12,
          "commitsBetweenForRepo": 36,
          "commitsBetweenForFile": 1,
          "actualSource": "CanInlineResult canInlineReferenceToFunction(NodeTraversal t, Node callNode, Node fnNode, Set\u003cString\u003e needAliases, InliningMode mode, boolean referencesThis, boolean containsFunctions) {\n    if (!isSupportedCallType(callNode)) {\n        return CanInlineResult.NO;\n    }\n    if (containsFunctions \u0026\u0026 !t.inGlobalScope()) {\n        return CanInlineResult.NO;\n    }\n    if (referencesThis \u0026\u0026 !NodeUtil.isFunctionObjectCall(callNode)) {\n        return CanInlineResult.NO;\n    }\n    if (mode \u003d\u003d InliningMode.DIRECT) {\n        return canInlineReferenceDirectly(callNode, fnNode);\n    } else {\n        return canInlineReferenceAsStatementBlock(t, callNode, fnNode, needAliases);\n    }\n}",
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java",
          "functionStartLine": 149,
          "functionName": "canInlineReferenceToFunction",
          "functionAnnotation": "",
          "functionDoc": "\n@param t The traversal use to reach the call site.\n@param callNode The CALL node.\n@param fnNode The function to evaluate for inlining.\n@param needAliases A set of function parameter names that can not be\n    used without aliasing. Returned by getUnsafeParameterNames().\n@param mode Inlining mode to be used.\n@param referencesThis Whether fnNode contains references to its this\n    object.\n@param containsFunctions Whether fnNode contains inner functions.\n@return Whether the inlining can occur.\n",
          "diff": "@@ -1,13 +1,16 @@\n-CanInlineResult canInlineReferenceToFunction(NodeTraversal t, Node callNode, Node fnNode, Set\u003cString\u003e needAliases, InliningMode mode, boolean referencesThis) {\n+CanInlineResult canInlineReferenceToFunction(NodeTraversal t, Node callNode, Node fnNode, Set\u003cString\u003e needAliases, InliningMode mode, boolean referencesThis, boolean containsFunctions) {\n     if (!isSupportedCallType(callNode)) {\n         return CanInlineResult.NO;\n     }\n+    if (containsFunctions \u0026\u0026 !t.inGlobalScope()) {\n+        return CanInlineResult.NO;\n+    }\n     if (referencesThis \u0026\u0026 !NodeUtil.isFunctionObjectCall(callNode)) {\n         return CanInlineResult.NO;\n     }\n     if (mode \u003d\u003d InliningMode.DIRECT) {\n         return canInlineReferenceDirectly(callNode, fnNode);\n     } else {\n         return canInlineReferenceAsStatementBlock(t, callNode, fnNode, needAliases);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[t-NodeTraversal, callNode-Node, fnNode-Node, needAliases-Set\u003cString\u003e, mode-InliningMode, referencesThis-boolean]",
            "newValue": "[t-NodeTraversal, callNode-Node, fnNode-Node, needAliases-Set\u003cString\u003e, mode-InliningMode, referencesThis-boolean, containsFunctions-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "\nChange on 2010/05/28 by johnlenz\n\n        Inline functions with inner functions into global scope if they don\u0027t\n        declare any names.\n\n        R\u003dacleung\n        DELTA\u003d329  (244 added, 27 deleted, 58 changed)\n\nChange on 2010/05/28 by dcc\n\n        First pass on refactoring FoldConstants into separate peephole optimizations. This changelist adds the notion of an AbstractPeepholeOptimization and adds a PeepholeOptimizationsPass that runs them. In this go around the minimization aspects of FoldConstants have been factored out into PeepholeMinimize. A future change will factor out the other components of FoldConstants into their own PeepholeOptimizations. DefaultPassConfig has also been updated to run the new PeepholeOptimizationPass.\n\n        This change does not move the minimization-related unit tests from FoldConstantsTest to PeepholeMinimizeTest -- a future, separate, change will do so. Hopefully this will make it easier to review.\n\n        R\u003dacleung\n        DELTA\u003d1966  (1271 added, 675 deleted, 20 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d13010\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@235 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "5/29/10, 1:07 PM",
          "commitName": "b4801b28ceea8db0f63da7440d6769cb9b7cce8a",
          "commitAuthor": "Nicholas.J.Santos",
          "commitDateOld": "4/16/10, 10:20 AM",
          "commitNameOld": "6e3eb4f7619179ba6c23db2af7549ef02f588c35",
          "commitAuthorOld": "Nicholas.J.Santos",
          "daysBetweenCommits": 43.12,
          "commitsBetweenForRepo": 36,
          "commitsBetweenForFile": 1,
          "actualSource": "CanInlineResult canInlineReferenceToFunction(NodeTraversal t, Node callNode, Node fnNode, Set\u003cString\u003e needAliases, InliningMode mode, boolean referencesThis, boolean containsFunctions) {\n    if (!isSupportedCallType(callNode)) {\n        return CanInlineResult.NO;\n    }\n    if (containsFunctions \u0026\u0026 !t.inGlobalScope()) {\n        return CanInlineResult.NO;\n    }\n    if (referencesThis \u0026\u0026 !NodeUtil.isFunctionObjectCall(callNode)) {\n        return CanInlineResult.NO;\n    }\n    if (mode \u003d\u003d InliningMode.DIRECT) {\n        return canInlineReferenceDirectly(callNode, fnNode);\n    } else {\n        return canInlineReferenceAsStatementBlock(t, callNode, fnNode, needAliases);\n    }\n}",
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java",
          "functionStartLine": 149,
          "functionName": "canInlineReferenceToFunction",
          "functionAnnotation": "",
          "functionDoc": "\n@param t The traversal use to reach the call site.\n@param callNode The CALL node.\n@param fnNode The function to evaluate for inlining.\n@param needAliases A set of function parameter names that can not be\n    used without aliasing. Returned by getUnsafeParameterNames().\n@param mode Inlining mode to be used.\n@param referencesThis Whether fnNode contains references to its this\n    object.\n@param containsFunctions Whether fnNode contains inner functions.\n@return Whether the inlining can occur.\n",
          "diff": "@@ -1,13 +1,16 @@\n-CanInlineResult canInlineReferenceToFunction(NodeTraversal t, Node callNode, Node fnNode, Set\u003cString\u003e needAliases, InliningMode mode, boolean referencesThis) {\n+CanInlineResult canInlineReferenceToFunction(NodeTraversal t, Node callNode, Node fnNode, Set\u003cString\u003e needAliases, InliningMode mode, boolean referencesThis, boolean containsFunctions) {\n     if (!isSupportedCallType(callNode)) {\n         return CanInlineResult.NO;\n     }\n+    if (containsFunctions \u0026\u0026 !t.inGlobalScope()) {\n+        return CanInlineResult.NO;\n+    }\n     if (referencesThis \u0026\u0026 !NodeUtil.isFunctionObjectCall(callNode)) {\n         return CanInlineResult.NO;\n     }\n     if (mode \u003d\u003d InliningMode.DIRECT) {\n         return canInlineReferenceDirectly(callNode, fnNode);\n     } else {\n         return canInlineReferenceAsStatementBlock(t, callNode, fnNode, needAliases);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "\nChange on 2010/05/28 by johnlenz\n\n        Inline functions with inner functions into global scope if they don\u0027t\n        declare any names.\n\n        R\u003dacleung\n        DELTA\u003d329  (244 added, 27 deleted, 58 changed)\n\nChange on 2010/05/28 by dcc\n\n        First pass on refactoring FoldConstants into separate peephole optimizations. This changelist adds the notion of an AbstractPeepholeOptimization and adds a PeepholeOptimizationsPass that runs them. In this go around the minimization aspects of FoldConstants have been factored out into PeepholeMinimize. A future change will factor out the other components of FoldConstants into their own PeepholeOptimizations. DefaultPassConfig has also been updated to run the new PeepholeOptimizationPass.\n\n        This change does not move the minimization-related unit tests from FoldConstantsTest to PeepholeMinimizeTest -- a future, separate, change will do so. Hopefully this will make it easier to review.\n\n        R\u003dacleung\n        DELTA\u003d1966  (1271 added, 675 deleted, 20 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d13010\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@235 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "5/29/10, 1:07 PM",
          "commitName": "b4801b28ceea8db0f63da7440d6769cb9b7cce8a",
          "commitAuthor": "Nicholas.J.Santos",
          "commitDateOld": "4/16/10, 10:20 AM",
          "commitNameOld": "6e3eb4f7619179ba6c23db2af7549ef02f588c35",
          "commitAuthorOld": "Nicholas.J.Santos",
          "daysBetweenCommits": 43.12,
          "commitsBetweenForRepo": 36,
          "commitsBetweenForFile": 1,
          "actualSource": "CanInlineResult canInlineReferenceToFunction(NodeTraversal t, Node callNode, Node fnNode, Set\u003cString\u003e needAliases, InliningMode mode, boolean referencesThis, boolean containsFunctions) {\n    if (!isSupportedCallType(callNode)) {\n        return CanInlineResult.NO;\n    }\n    if (containsFunctions \u0026\u0026 !t.inGlobalScope()) {\n        return CanInlineResult.NO;\n    }\n    if (referencesThis \u0026\u0026 !NodeUtil.isFunctionObjectCall(callNode)) {\n        return CanInlineResult.NO;\n    }\n    if (mode \u003d\u003d InliningMode.DIRECT) {\n        return canInlineReferenceDirectly(callNode, fnNode);\n    } else {\n        return canInlineReferenceAsStatementBlock(t, callNode, fnNode, needAliases);\n    }\n}",
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java",
          "functionStartLine": 149,
          "functionName": "canInlineReferenceToFunction",
          "functionAnnotation": "",
          "functionDoc": "\n@param t The traversal use to reach the call site.\n@param callNode The CALL node.\n@param fnNode The function to evaluate for inlining.\n@param needAliases A set of function parameter names that can not be\n    used without aliasing. Returned by getUnsafeParameterNames().\n@param mode Inlining mode to be used.\n@param referencesThis Whether fnNode contains references to its this\n    object.\n@param containsFunctions Whether fnNode contains inner functions.\n@return Whether the inlining can occur.\n",
          "diff": "@@ -1,13 +1,16 @@\n-CanInlineResult canInlineReferenceToFunction(NodeTraversal t, Node callNode, Node fnNode, Set\u003cString\u003e needAliases, InliningMode mode, boolean referencesThis) {\n+CanInlineResult canInlineReferenceToFunction(NodeTraversal t, Node callNode, Node fnNode, Set\u003cString\u003e needAliases, InliningMode mode, boolean referencesThis, boolean containsFunctions) {\n     if (!isSupportedCallType(callNode)) {\n         return CanInlineResult.NO;\n     }\n+    if (containsFunctions \u0026\u0026 !t.inGlobalScope()) {\n+        return CanInlineResult.NO;\n+    }\n     if (referencesThis \u0026\u0026 !NodeUtil.isFunctionObjectCall(callNode)) {\n         return CanInlineResult.NO;\n     }\n     if (mode \u003d\u003d InliningMode.DIRECT) {\n         return canInlineReferenceDirectly(callNode, fnNode);\n     } else {\n         return canInlineReferenceAsStatementBlock(t, callNode, fnNode, needAliases);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "\n@param t The traversal use to reach the call site.\n@param callNode The CALL node.\n@param fnNode The function to evaluate.\n@param needAliases A set of function parameter names that can not be\n    used without aliasing. Returned by getUnsafeParameterNames().\n@param mode Inlining mode to be used.\n@return Whether the inlining can occur.\n",
            "newValue": "\n@param t The traversal use to reach the call site.\n@param callNode The CALL node.\n@param fnNode The function to evaluate for inlining.\n@param needAliases A set of function parameter names that can not be\n    used without aliasing. Returned by getUnsafeParameterNames().\n@param mode Inlining mode to be used.\n@param referencesThis Whether fnNode contains references to its this\n    object.\n@param containsFunctions Whether fnNode contains inner functions.\n@return Whether the inlining can occur.\n"
          }
        }
      ]
    },
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": {
      "type": "Yintroduced",
      "commitMessage": "Initial commit.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/3/09, 3:51 PM",
      "commitName": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "diff": "@@ -0,0 +1,13 @@\n+CanInlineResult canInlineReferenceToFunction(NodeTraversal t, Node callNode, Node fnNode, Set\u003cString\u003e needAliases, InliningMode mode, boolean referencesThis) {\n+    if (!isSupportedCallType(callNode)) {\n+        return CanInlineResult.NO;\n+    }\n+    if (referencesThis \u0026\u0026 !NodeUtil.isFunctionObjectCall(callNode)) {\n+        return CanInlineResult.NO;\n+    }\n+    if (mode \u003d\u003d InliningMode.DIRECT) {\n+        return canInlineReferenceDirectly(callNode, fnNode);\n+    } else {\n+        return canInlineReferenceAsStatementBlock(t, callNode, fnNode, needAliases);\n+    }\n+}\n\\ No newline at end of file\n",
      "actualSource": "CanInlineResult canInlineReferenceToFunction(NodeTraversal t, Node callNode, Node fnNode, Set\u003cString\u003e needAliases, InliningMode mode, boolean referencesThis) {\n    if (!isSupportedCallType(callNode)) {\n        return CanInlineResult.NO;\n    }\n    if (referencesThis \u0026\u0026 !NodeUtil.isFunctionObjectCall(callNode)) {\n        return CanInlineResult.NO;\n    }\n    if (mode \u003d\u003d InliningMode.DIRECT) {\n        return canInlineReferenceDirectly(callNode, fnNode);\n    } else {\n        return canInlineReferenceAsStatementBlock(t, callNode, fnNode, needAliases);\n    }\n}",
      "path": "src/com/google/javascript/jscomp/FunctionInjector.java",
      "functionStartLine": 152,
      "functionName": "canInlineReferenceToFunction",
      "functionAnnotation": "",
      "functionDoc": "\n@param t The traversal use to reach the call site.\n@param callNode The CALL node.\n@param fnNode The function to evaluate.\n@param needAliases A set of function parameter names that can not be\n    used without aliasing. Returned by getUnsafeParameterNames().\n@param mode Inlining mode to be used.\n@return Whether the inlining can occur.\n"
    }
  }
}