{
  "origin": "codeshovel",
  "repositoryName": "Closure-115b",
  "repositoryPath": "/tmp/Closure-115b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "CodeGenerator.java",
  "functionName": "addNonEmptyStatement",
  "functionId": "addNonEmptyStatement___n-Node__context-Context__allowNonBlockChild-boolean",
  "sourceFilePath": "src/com/google/javascript/jscomp/CodeGenerator.java",
  "functionAnnotation": "",
  "functionDoc": "Adds a block or expression, substituting a VOID with an empty statement.\nThis is used for \"for (...);\" and \"if (...);\" type statements.\n\n@param n The node to print.\n@param context The context to determine how the node should be printed.\n",
  "functionStartLine": 852,
  "functionEndLine": 908,
  "numCommitsSeen": 113,
  "timeTaken": 5446,
  "changeHistory": [
    "39f629a8cfaab37da55288010640d7e516000b1f",
    "ec324a9bb23eb78c76f537f4c4170ba88d542f1c",
    "f0e3cbc250fd9536ff92119bdf5e1a62120a7fac",
    "dff6e0114f19c20aeb63393d67aa0880ff5745b5",
    "0c3fdb92840718de9f9da085b818efb419cfb927",
    "de13c3313c05f4449c50c560324389d6905a214d",
    "222eafd303155b3eac5cd244584b2cb3c4c11975",
    "fe722ddeb545b6b3103369dea073ad3e6becde28",
    "168bc14ff5e9e664863c3b1146f2a5b7a30ffb42",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3"
  ],
  "changeHistoryShort": {
    "39f629a8cfaab37da55288010640d7e516000b1f": "Ybodychange",
    "ec324a9bb23eb78c76f537f4c4170ba88d542f1c": "Ybodychange",
    "f0e3cbc250fd9536ff92119bdf5e1a62120a7fac": "Ymultichange(Yrename,Ybodychange)",
    "dff6e0114f19c20aeb63393d67aa0880ff5745b5": "Ybodychange",
    "0c3fdb92840718de9f9da085b818efb419cfb927": "Ybodychange",
    "de13c3313c05f4449c50c560324389d6905a214d": "Ybodychange",
    "222eafd303155b3eac5cd244584b2cb3c4c11975": "Ybodychange",
    "fe722ddeb545b6b3103369dea073ad3e6becde28": "Ybodychange",
    "168bc14ff5e9e664863c3b1146f2a5b7a30ffb42": "Ybodychange",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "39f629a8cfaab37da55288010640d7e516000b1f": {
      "type": "Ybodychange",
      "commitMessage": "\nReplace calls of the form \"Node.getType() !\u003d Token.XX\" with\n\"!Node.isXX()\" calls.\n\nR\u003dnicksantos\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3706\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1598 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/14/11, 6:13 PM",
      "commitName": "39f629a8cfaab37da55288010640d7e516000b1f",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "11/11/11, 4:42 PM",
      "commitNameOld": "5524adbda991632656059566b69cc2771ba42b7d",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 3.06,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "private void addNonEmptyStatement(Node n, Context context, boolean allowNonBlockChild) {\n    Node nodeToProcess \u003d n;\n    if (!allowNonBlockChild \u0026\u0026 !n.isBlock()) {\n        throw new Error(\"Missing BLOCK child.\");\n    }\n    if (n.isBlock()) {\n        int count \u003d getNonEmptyChildCount(n, 2);\n        if (count \u003d\u003d 0) {\n            if (cc.shouldPreserveExtraBlocks()) {\n                cc.beginBlock();\n                cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n            } else {\n                cc.endStatement(true);\n            }\n            return;\n        }\n        if (count \u003d\u003d 1) {\n            Node firstAndOnlyChild \u003d getFirstNonEmptyChild(n);\n            boolean alwaysWrapInBlock \u003d cc.shouldPreserveExtraBlocks();\n            if (alwaysWrapInBlock || isOneExactlyFunctionOrDo(firstAndOnlyChild)) {\n                cc.beginBlock();\n                add(firstAndOnlyChild, Context.STATEMENT);\n                cc.maybeLineBreak();\n                cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                return;\n            } else {\n                nodeToProcess \u003d firstAndOnlyChild;\n            }\n        }\n        if (count \u003e 1) {\n            context \u003d Context.PRESERVE_BLOCK;\n        }\n    }\n    if (nodeToProcess.isEmpty()) {\n        cc.endStatement(true);\n    } else {\n        add(nodeToProcess, context);\n        if (nodeToProcess.isVar()) {\n            cc.endStatement();\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/CodeGenerator.java",
      "functionStartLine": 758,
      "functionName": "addNonEmptyStatement",
      "functionAnnotation": "",
      "functionDoc": "Adds a block or expression, substituting a VOID with an empty statement.\nThis is used for \"for (...);\" and \"if (...);\" type statements.\n\n@param n The node to print.\n@param context The context to determine how the node should be printed.\n",
      "diff": "@@ -1,42 +1,42 @@\n private void addNonEmptyStatement(Node n, Context context, boolean allowNonBlockChild) {\n     Node nodeToProcess \u003d n;\n-    if (!allowNonBlockChild \u0026\u0026 n.getType() !\u003d Token.BLOCK) {\n+    if (!allowNonBlockChild \u0026\u0026 !n.isBlock()) {\n         throw new Error(\"Missing BLOCK child.\");\n     }\n     if (n.isBlock()) {\n         int count \u003d getNonEmptyChildCount(n, 2);\n         if (count \u003d\u003d 0) {\n             if (cc.shouldPreserveExtraBlocks()) {\n                 cc.beginBlock();\n                 cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n             } else {\n                 cc.endStatement(true);\n             }\n             return;\n         }\n         if (count \u003d\u003d 1) {\n             Node firstAndOnlyChild \u003d getFirstNonEmptyChild(n);\n             boolean alwaysWrapInBlock \u003d cc.shouldPreserveExtraBlocks();\n             if (alwaysWrapInBlock || isOneExactlyFunctionOrDo(firstAndOnlyChild)) {\n                 cc.beginBlock();\n                 add(firstAndOnlyChild, Context.STATEMENT);\n                 cc.maybeLineBreak();\n                 cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                 return;\n             } else {\n                 nodeToProcess \u003d firstAndOnlyChild;\n             }\n         }\n         if (count \u003e 1) {\n             context \u003d Context.PRESERVE_BLOCK;\n         }\n     }\n     if (nodeToProcess.isEmpty()) {\n         cc.endStatement(true);\n     } else {\n         add(nodeToProcess, context);\n         if (nodeToProcess.isVar()) {\n             cc.endStatement();\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ec324a9bb23eb78c76f537f4c4170ba88d542f1c": {
      "type": "Ybodychange",
      "commitMessage": "\nReplace the bulk of the Node.getType() \u003d\u003d Token.XXX calls with\nNode.isXXX calls.\n\nR\u003dnicksantos\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3677\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1582 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/10/11, 8:36 AM",
      "commitName": "ec324a9bb23eb78c76f537f4c4170ba88d542f1c",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "11/7/11, 2:21 PM",
      "commitNameOld": "6641663fa9970c4d7bcdd96a6f31b83b18c3ee3d",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 2.76,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "actualSource": "private void addNonEmptyStatement(Node n, Context context, boolean allowNonBlockChild) {\n    Node nodeToProcess \u003d n;\n    if (!allowNonBlockChild \u0026\u0026 n.getType() !\u003d Token.BLOCK) {\n        throw new Error(\"Missing BLOCK child.\");\n    }\n    if (n.isBlock()) {\n        int count \u003d getNonEmptyChildCount(n, 2);\n        if (count \u003d\u003d 0) {\n            if (cc.shouldPreserveExtraBlocks()) {\n                cc.beginBlock();\n                cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n            } else {\n                cc.endStatement(true);\n            }\n            return;\n        }\n        if (count \u003d\u003d 1) {\n            Node firstAndOnlyChild \u003d getFirstNonEmptyChild(n);\n            boolean alwaysWrapInBlock \u003d cc.shouldPreserveExtraBlocks();\n            if (alwaysWrapInBlock || isOneExactlyFunctionOrDo(firstAndOnlyChild)) {\n                cc.beginBlock();\n                add(firstAndOnlyChild, Context.STATEMENT);\n                cc.maybeLineBreak();\n                cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                return;\n            } else {\n                nodeToProcess \u003d firstAndOnlyChild;\n            }\n        }\n        if (count \u003e 1) {\n            context \u003d Context.PRESERVE_BLOCK;\n        }\n    }\n    if (nodeToProcess.isEmpty()) {\n        cc.endStatement(true);\n    } else {\n        add(nodeToProcess, context);\n        if (nodeToProcess.isVar()) {\n            cc.endStatement();\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/CodeGenerator.java",
      "functionStartLine": 758,
      "functionName": "addNonEmptyStatement",
      "functionAnnotation": "",
      "functionDoc": "Adds a block or expression, substituting a VOID with an empty statement.\nThis is used for \"for (...);\" and \"if (...);\" type statements.\n\n@param n The node to print.\n@param context The context to determine how the node should be printed.\n",
      "diff": "@@ -1,42 +1,42 @@\n private void addNonEmptyStatement(Node n, Context context, boolean allowNonBlockChild) {\n     Node nodeToProcess \u003d n;\n     if (!allowNonBlockChild \u0026\u0026 n.getType() !\u003d Token.BLOCK) {\n         throw new Error(\"Missing BLOCK child.\");\n     }\n-    if (n.getType() \u003d\u003d Token.BLOCK) {\n+    if (n.isBlock()) {\n         int count \u003d getNonEmptyChildCount(n, 2);\n         if (count \u003d\u003d 0) {\n             if (cc.shouldPreserveExtraBlocks()) {\n                 cc.beginBlock();\n                 cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n             } else {\n                 cc.endStatement(true);\n             }\n             return;\n         }\n         if (count \u003d\u003d 1) {\n             Node firstAndOnlyChild \u003d getFirstNonEmptyChild(n);\n             boolean alwaysWrapInBlock \u003d cc.shouldPreserveExtraBlocks();\n             if (alwaysWrapInBlock || isOneExactlyFunctionOrDo(firstAndOnlyChild)) {\n                 cc.beginBlock();\n                 add(firstAndOnlyChild, Context.STATEMENT);\n                 cc.maybeLineBreak();\n                 cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                 return;\n             } else {\n                 nodeToProcess \u003d firstAndOnlyChild;\n             }\n         }\n         if (count \u003e 1) {\n             context \u003d Context.PRESERVE_BLOCK;\n         }\n     }\n-    if (nodeToProcess.getType() \u003d\u003d Token.EMPTY) {\n+    if (nodeToProcess.isEmpty()) {\n         cc.endStatement(true);\n     } else {\n         add(nodeToProcess, context);\n-        if (nodeToProcess.getType() \u003d\u003d Token.VAR) {\n+        if (nodeToProcess.isVar()) {\n             cc.endStatement();\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f0e3cbc250fd9536ff92119bdf5e1a62120a7fac": {
      "type": "Ymultichange(Yrename,Ybodychange)",
      "commitMessage": "\nFix handling of blocks containing synthetic blocks in control\nstructures.\n\nR\u003dnicksantos\nDELTA\u003d43  (19 added, 2 deleted, 22 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d209648\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@410 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "9/8/10, 11:48 AM",
      "commitName": "f0e3cbc250fd9536ff92119bdf5e1a62120a7fac",
      "commitAuthor": "johnlenz@google.com",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "\nFix handling of blocks containing synthetic blocks in control\nstructures.\n\nR\u003dnicksantos\nDELTA\u003d43  (19 added, 2 deleted, 22 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d209648\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@410 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "9/8/10, 11:48 AM",
          "commitName": "f0e3cbc250fd9536ff92119bdf5e1a62120a7fac",
          "commitAuthor": "johnlenz@google.com",
          "commitDateOld": "8/27/10, 3:51 PM",
          "commitNameOld": "9390e7889e85aca41bdf98fb38a19bd69f6fdb87",
          "commitAuthorOld": "johnlenz@google.com",
          "daysBetweenCommits": 11.83,
          "commitsBetweenForRepo": 17,
          "commitsBetweenForFile": 1,
          "actualSource": "private void addNonEmptyStatement(Node n, Context context, boolean allowNonBlockChild) {\n    Node nodeToProcess \u003d n;\n    if (!allowNonBlockChild \u0026\u0026 n.getType() !\u003d Token.BLOCK) {\n        throw new Error(\"Missing BLOCK child.\");\n    }\n    if (n.getType() \u003d\u003d Token.BLOCK) {\n        int count \u003d getNonEmptyChildCount(n, 2);\n        if (count \u003d\u003d 0) {\n            if (cc.shouldPreserveExtraBlocks()) {\n                cc.beginBlock();\n                cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n            } else {\n                cc.endStatement(true);\n            }\n            return;\n        }\n        if (count \u003d\u003d 1) {\n            Node firstAndOnlyChild \u003d getFirstNonEmptyChild(n);\n            boolean alwaysWrapInBlock \u003d cc.shouldPreserveExtraBlocks();\n            if (alwaysWrapInBlock || isOneExactlyFunctionOrDo(firstAndOnlyChild)) {\n                cc.beginBlock();\n                add(firstAndOnlyChild, Context.STATEMENT);\n                cc.maybeLineBreak();\n                cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                return;\n            } else {\n                nodeToProcess \u003d firstAndOnlyChild;\n            }\n        }\n        if (count \u003e 1) {\n            context \u003d Context.PRESERVE_BLOCK;\n        }\n    }\n    if (nodeToProcess.getType() \u003d\u003d Token.EMPTY) {\n        cc.endStatement(true);\n    } else {\n        add(nodeToProcess, context);\n        if (nodeToProcess.getType() \u003d\u003d Token.VAR) {\n            cc.endStatement();\n        }\n    }\n}",
          "path": "src/com/google/javascript/jscomp/CodeGenerator.java",
          "functionStartLine": 665,
          "functionName": "addNonEmptyStatement",
          "functionAnnotation": "",
          "functionDoc": "Adds a block or expression, substituting a VOID with an empty statement.\nThis is used for \"for (...);\" and \"if (...);\" type statements.\n\n@param n The node to print.\n@param context The context to determine how the node should be printed.\n",
          "diff": "@@ -1,39 +1,42 @@\n-private void addNonEmptyExpression(Node n, Context context, boolean allowNonBlockChild) {\n+private void addNonEmptyStatement(Node n, Context context, boolean allowNonBlockChild) {\n     Node nodeToProcess \u003d n;\n     if (!allowNonBlockChild \u0026\u0026 n.getType() !\u003d Token.BLOCK) {\n         throw new Error(\"Missing BLOCK child.\");\n     }\n     if (n.getType() \u003d\u003d Token.BLOCK) {\n         int count \u003d getNonEmptyChildCount(n, 2);\n         if (count \u003d\u003d 0) {\n             if (cc.shouldPreserveExtraBlocks()) {\n                 cc.beginBlock();\n                 cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n             } else {\n                 cc.endStatement(true);\n             }\n             return;\n         }\n         if (count \u003d\u003d 1) {\n             Node firstAndOnlyChild \u003d getFirstNonEmptyChild(n);\n             boolean alwaysWrapInBlock \u003d cc.shouldPreserveExtraBlocks();\n             if (alwaysWrapInBlock || isOneExactlyFunctionOrDo(firstAndOnlyChild)) {\n                 cc.beginBlock();\n                 add(firstAndOnlyChild, Context.STATEMENT);\n                 cc.maybeLineBreak();\n                 cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                 return;\n             } else {\n                 nodeToProcess \u003d firstAndOnlyChild;\n             }\n         }\n+        if (count \u003e 1) {\n+            context \u003d Context.PRESERVE_BLOCK;\n+        }\n     }\n     if (nodeToProcess.getType() \u003d\u003d Token.EMPTY) {\n         cc.endStatement(true);\n     } else {\n         add(nodeToProcess, context);\n         if (nodeToProcess.getType() \u003d\u003d Token.VAR) {\n             cc.endStatement();\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "addNonEmptyExpression",
            "newValue": "addNonEmptyStatement"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "\nFix handling of blocks containing synthetic blocks in control\nstructures.\n\nR\u003dnicksantos\nDELTA\u003d43  (19 added, 2 deleted, 22 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d209648\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@410 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "9/8/10, 11:48 AM",
          "commitName": "f0e3cbc250fd9536ff92119bdf5e1a62120a7fac",
          "commitAuthor": "johnlenz@google.com",
          "commitDateOld": "8/27/10, 3:51 PM",
          "commitNameOld": "9390e7889e85aca41bdf98fb38a19bd69f6fdb87",
          "commitAuthorOld": "johnlenz@google.com",
          "daysBetweenCommits": 11.83,
          "commitsBetweenForRepo": 17,
          "commitsBetweenForFile": 1,
          "actualSource": "private void addNonEmptyStatement(Node n, Context context, boolean allowNonBlockChild) {\n    Node nodeToProcess \u003d n;\n    if (!allowNonBlockChild \u0026\u0026 n.getType() !\u003d Token.BLOCK) {\n        throw new Error(\"Missing BLOCK child.\");\n    }\n    if (n.getType() \u003d\u003d Token.BLOCK) {\n        int count \u003d getNonEmptyChildCount(n, 2);\n        if (count \u003d\u003d 0) {\n            if (cc.shouldPreserveExtraBlocks()) {\n                cc.beginBlock();\n                cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n            } else {\n                cc.endStatement(true);\n            }\n            return;\n        }\n        if (count \u003d\u003d 1) {\n            Node firstAndOnlyChild \u003d getFirstNonEmptyChild(n);\n            boolean alwaysWrapInBlock \u003d cc.shouldPreserveExtraBlocks();\n            if (alwaysWrapInBlock || isOneExactlyFunctionOrDo(firstAndOnlyChild)) {\n                cc.beginBlock();\n                add(firstAndOnlyChild, Context.STATEMENT);\n                cc.maybeLineBreak();\n                cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                return;\n            } else {\n                nodeToProcess \u003d firstAndOnlyChild;\n            }\n        }\n        if (count \u003e 1) {\n            context \u003d Context.PRESERVE_BLOCK;\n        }\n    }\n    if (nodeToProcess.getType() \u003d\u003d Token.EMPTY) {\n        cc.endStatement(true);\n    } else {\n        add(nodeToProcess, context);\n        if (nodeToProcess.getType() \u003d\u003d Token.VAR) {\n            cc.endStatement();\n        }\n    }\n}",
          "path": "src/com/google/javascript/jscomp/CodeGenerator.java",
          "functionStartLine": 665,
          "functionName": "addNonEmptyStatement",
          "functionAnnotation": "",
          "functionDoc": "Adds a block or expression, substituting a VOID with an empty statement.\nThis is used for \"for (...);\" and \"if (...);\" type statements.\n\n@param n The node to print.\n@param context The context to determine how the node should be printed.\n",
          "diff": "@@ -1,39 +1,42 @@\n-private void addNonEmptyExpression(Node n, Context context, boolean allowNonBlockChild) {\n+private void addNonEmptyStatement(Node n, Context context, boolean allowNonBlockChild) {\n     Node nodeToProcess \u003d n;\n     if (!allowNonBlockChild \u0026\u0026 n.getType() !\u003d Token.BLOCK) {\n         throw new Error(\"Missing BLOCK child.\");\n     }\n     if (n.getType() \u003d\u003d Token.BLOCK) {\n         int count \u003d getNonEmptyChildCount(n, 2);\n         if (count \u003d\u003d 0) {\n             if (cc.shouldPreserveExtraBlocks()) {\n                 cc.beginBlock();\n                 cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n             } else {\n                 cc.endStatement(true);\n             }\n             return;\n         }\n         if (count \u003d\u003d 1) {\n             Node firstAndOnlyChild \u003d getFirstNonEmptyChild(n);\n             boolean alwaysWrapInBlock \u003d cc.shouldPreserveExtraBlocks();\n             if (alwaysWrapInBlock || isOneExactlyFunctionOrDo(firstAndOnlyChild)) {\n                 cc.beginBlock();\n                 add(firstAndOnlyChild, Context.STATEMENT);\n                 cc.maybeLineBreak();\n                 cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                 return;\n             } else {\n                 nodeToProcess \u003d firstAndOnlyChild;\n             }\n         }\n+        if (count \u003e 1) {\n+            context \u003d Context.PRESERVE_BLOCK;\n+        }\n     }\n     if (nodeToProcess.getType() \u003d\u003d Token.EMPTY) {\n         cc.endStatement(true);\n     } else {\n         add(nodeToProcess, context);\n         if (nodeToProcess.getType() \u003d\u003d Token.VAR) {\n             cc.endStatement();\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "dff6e0114f19c20aeb63393d67aa0880ff5745b5": {
      "type": "Ybodychange",
      "commitMessage": "\nChange on 2010/06/25 by johnlenz\n\n\tPreserve blocks around problematic labelled statements.\n\tFixes issue 190\n\n\tR\u003dnicksantos\n\tDELTA\u003d95  (86 added, 2 deleted, 7 changed)\n\nChange on 2010/06/25 by nicksantos\n\n\tmore descriptive error messaging for CheckReturns.\n\n\n\tR\u003dacleung\n\tDELTA\u003d59  (21 added, 2 deleted, 36 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d42001\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@255 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "6/25/10, 4:56 PM",
      "commitName": "dff6e0114f19c20aeb63393d67aa0880ff5745b5",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "6/25/10, 2:35 PM",
      "commitNameOld": "b1ffe42efdaaf0266b4ba10e05de124a885cf979",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private void addNonEmptyExpression(Node n, Context context, boolean allowNonBlockChild) {\n    Node nodeToProcess \u003d n;\n    if (!allowNonBlockChild \u0026\u0026 n.getType() !\u003d Token.BLOCK) {\n        throw new Error(\"Missing BLOCK child.\");\n    }\n    if (n.getType() \u003d\u003d Token.BLOCK) {\n        int count \u003d getNonEmptyChildCount(n, 2);\n        if (count \u003d\u003d 0) {\n            if (cc.shouldPreserveExtraBlocks()) {\n                cc.beginBlock();\n                cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n            } else {\n                cc.endStatement(true);\n            }\n            return;\n        }\n        if (count \u003d\u003d 1) {\n            Node firstAndOnlyChild \u003d getFirstNonEmptyChild(n);\n            boolean alwaysWrapInBlock \u003d cc.shouldPreserveExtraBlocks();\n            if (alwaysWrapInBlock || isOneExactlyFunctionOrDo(firstAndOnlyChild)) {\n                cc.beginBlock();\n                add(firstAndOnlyChild, Context.STATEMENT);\n                cc.maybeLineBreak();\n                cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                return;\n            } else {\n                nodeToProcess \u003d firstAndOnlyChild;\n            }\n        }\n    }\n    if (nodeToProcess.getType() \u003d\u003d Token.EMPTY) {\n        cc.endStatement(true);\n    } else {\n        add(nodeToProcess, context);\n        if (nodeToProcess.getType() \u003d\u003d Token.VAR) {\n            cc.endStatement();\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/CodeGenerator.java",
      "functionStartLine": 650,
      "functionName": "addNonEmptyExpression",
      "functionAnnotation": "",
      "functionDoc": "Adds a block or expression, substituting a VOID with an empty statement.\nThis is used for \"for (...);\" and \"if (...);\" type statements.\n\n@param n The node to print.\n@param context The context to determine how the node should be printed.\n",
      "diff": "@@ -1,39 +1,39 @@\n private void addNonEmptyExpression(Node n, Context context, boolean allowNonBlockChild) {\n     Node nodeToProcess \u003d n;\n     if (!allowNonBlockChild \u0026\u0026 n.getType() !\u003d Token.BLOCK) {\n         throw new Error(\"Missing BLOCK child.\");\n     }\n     if (n.getType() \u003d\u003d Token.BLOCK) {\n-        int count \u003d getNonEmptyChildCount(n);\n+        int count \u003d getNonEmptyChildCount(n, 2);\n         if (count \u003d\u003d 0) {\n             if (cc.shouldPreserveExtraBlocks()) {\n                 cc.beginBlock();\n                 cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n             } else {\n                 cc.endStatement(true);\n             }\n             return;\n         }\n         if (count \u003d\u003d 1) {\n             Node firstAndOnlyChild \u003d getFirstNonEmptyChild(n);\n             boolean alwaysWrapInBlock \u003d cc.shouldPreserveExtraBlocks();\n-            if (alwaysWrapInBlock || firstAndOnlyChild.getType() \u003d\u003d Token.FUNCTION || firstAndOnlyChild.getType() \u003d\u003d Token.DO) {\n+            if (alwaysWrapInBlock || isOneExactlyFunctionOrDo(firstAndOnlyChild)) {\n                 cc.beginBlock();\n                 add(firstAndOnlyChild, Context.STATEMENT);\n                 cc.maybeLineBreak();\n                 cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                 return;\n             } else {\n                 nodeToProcess \u003d firstAndOnlyChild;\n             }\n         }\n     }\n     if (nodeToProcess.getType() \u003d\u003d Token.EMPTY) {\n         cc.endStatement(true);\n     } else {\n         add(nodeToProcess, context);\n         if (nodeToProcess.getType() \u003d\u003d Token.VAR) {\n             cc.endStatement();\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0c3fdb92840718de9f9da085b818efb419cfb927": {
      "type": "Ybodychange",
      "commitMessage": "\nChange on 2010/04/20 by john\n\n        Move Normalize from the end of \"check\" to the beginning of \"optimize\",\n        which is more consistent with how we are using it.\n\n        R\u003dnick\n        DELTA\u003d14  (7 added, 7 deleted, 0 changed)\n\nChange on 2010/04/20 by john\n\n        When pretty printing, output empty blocks instead of semicolons for if, for, etc so that\n        reparsing doesn\u0027t generate empty block warnings.\n\n        R\u003drobert\n        DELTA\u003d12  (8 added, 0 deleted, 4 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003divhzkq\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@193 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/20/10, 2:39 PM",
      "commitName": "0c3fdb92840718de9f9da085b818efb419cfb927",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "4/14/10, 4:53 PM",
      "commitNameOld": "43859717972907dd1ecebd8dca6e05036386e28b",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 5.91,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "private void addNonEmptyExpression(Node n, Context context, boolean allowNonBlockChild) {\n    Node nodeToProcess \u003d n;\n    if (!allowNonBlockChild \u0026\u0026 n.getType() !\u003d Token.BLOCK) {\n        throw new Error(\"Missing BLOCK child.\");\n    }\n    if (n.getType() \u003d\u003d Token.BLOCK) {\n        int count \u003d getNonEmptyChildCount(n);\n        if (count \u003d\u003d 0) {\n            if (cc.shouldPreserveExtraBlocks()) {\n                cc.beginBlock();\n                cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n            } else {\n                cc.endStatement(true);\n            }\n            return;\n        }\n        if (count \u003d\u003d 1) {\n            Node firstAndOnlyChild \u003d getFirstNonEmptyChild(n);\n            boolean alwaysWrapInBlock \u003d cc.shouldPreserveExtraBlocks();\n            if (alwaysWrapInBlock || firstAndOnlyChild.getType() \u003d\u003d Token.FUNCTION || firstAndOnlyChild.getType() \u003d\u003d Token.DO) {\n                cc.beginBlock();\n                add(firstAndOnlyChild, Context.STATEMENT);\n                cc.maybeLineBreak();\n                cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                return;\n            } else {\n                nodeToProcess \u003d firstAndOnlyChild;\n            }\n        }\n    }\n    if (nodeToProcess.getType() \u003d\u003d Token.EMPTY) {\n        cc.endStatement(true);\n    } else {\n        add(nodeToProcess, context);\n        if (nodeToProcess.getType() \u003d\u003d Token.VAR) {\n            cc.endStatement();\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/CodeGenerator.java",
      "functionStartLine": 642,
      "functionName": "addNonEmptyExpression",
      "functionAnnotation": "",
      "functionDoc": "Adds a block or expression, substituting a VOID with an empty statement.\nThis is used for \"for (...);\" and \"if (...);\" type statements.\n\n@param n The node to print.\n@param context The context to determine how the node should be printed.\n",
      "diff": "@@ -1,34 +1,39 @@\n private void addNonEmptyExpression(Node n, Context context, boolean allowNonBlockChild) {\n     Node nodeToProcess \u003d n;\n     if (!allowNonBlockChild \u0026\u0026 n.getType() !\u003d Token.BLOCK) {\n         throw new Error(\"Missing BLOCK child.\");\n     }\n     if (n.getType() \u003d\u003d Token.BLOCK) {\n         int count \u003d getNonEmptyChildCount(n);\n         if (count \u003d\u003d 0) {\n-            cc.endStatement(true);\n+            if (cc.shouldPreserveExtraBlocks()) {\n+                cc.beginBlock();\n+                cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n+            } else {\n+                cc.endStatement(true);\n+            }\n             return;\n         }\n         if (count \u003d\u003d 1) {\n             Node firstAndOnlyChild \u003d getFirstNonEmptyChild(n);\n             boolean alwaysWrapInBlock \u003d cc.shouldPreserveExtraBlocks();\n             if (alwaysWrapInBlock || firstAndOnlyChild.getType() \u003d\u003d Token.FUNCTION || firstAndOnlyChild.getType() \u003d\u003d Token.DO) {\n                 cc.beginBlock();\n                 add(firstAndOnlyChild, Context.STATEMENT);\n                 cc.maybeLineBreak();\n                 cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                 return;\n             } else {\n                 nodeToProcess \u003d firstAndOnlyChild;\n             }\n         }\n     }\n     if (nodeToProcess.getType() \u003d\u003d Token.EMPTY) {\n         cc.endStatement(true);\n     } else {\n         add(nodeToProcess, context);\n         if (nodeToProcess.getType() \u003d\u003d Token.VAR) {\n             cc.endStatement();\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "de13c3313c05f4449c50c560324389d6905a214d": {
      "type": "Ybodychange",
      "commitMessage": "\nChange on 2010/04/13 by john\n\n        Experimental option: Flag to change named object references from \"Object|null\" to \"Object|null|undefined\".\n\n        R\u003dalan,nick\n        DELTA\u003d7144  (7131 added, 5 deleted, 8 changed)\n\nChange on 2010/04/13 by nicksantos\n\n        get rid of some backdoor gmail apis.\n\n        R\u003djohn\n        DELTA\u003d44  (0 added, 33 deleted, 11 changed)\n\nChange on 2010/04/13 by nicksantos\n\n        fix TypeCheckTest to parse externs files properly.\n        i still need to merge the TypeCheckTest-forking cl into this one.\n\n        R\u003djohn\n        DELTA\u003d42  (12 added, 0 deleted, 30 changed)\n\nChange on 2010/04/13 by john\n\n        Enable expression decomposition for function inlining by default.\n\n        R\u003dnick\n        DELTA\u003d1  (0 added, 0 deleted, 1 changed)\n\nChange on 2010/04/13 by john\n\n        Move ReplaceCssNames to allow type checking of goog.getCssName.\n\n        R\u003dmark\n        DELTA\u003d39  (35 added, 4 deleted, 0 changed)\n\nChange on 2010/04/13 by john\n\n        Maintain source and type information during ReplaceCssNames.\n\n        R\u003dmark\n        DELTA\u003d31  (30 added, 0 deleted, 1 changed)\n\nChange on 2010/04/13 by nick\n\n        fix up type information on event listener functions.\n\n        R\u003dalan\n        DELTA\u003d2  (0 added, 0 deleted, 2 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003dwescxy\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@182 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/13/10, 2:39 PM",
      "commitName": "de13c3313c05f4449c50c560324389d6905a214d",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "4/5/10, 12:30 PM",
      "commitNameOld": "222eafd303155b3eac5cd244584b2cb3c4c11975",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 8.09,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "actualSource": "private void addNonEmptyExpression(Node n, Context context, boolean allowNonBlockChild) {\n    Node nodeToProcess \u003d n;\n    if (!allowNonBlockChild \u0026\u0026 n.getType() !\u003d Token.BLOCK) {\n        throw new Error(\"Missing BLOCK child.\");\n    }\n    if (n.getType() \u003d\u003d Token.BLOCK) {\n        int count \u003d getNonEmptyChildCount(n);\n        if (count \u003d\u003d 0) {\n            cc.endStatement(true);\n            return;\n        }\n        if (count \u003d\u003d 1) {\n            Node firstAndOnlyChild \u003d getFirstNonEmptyChild(n);\n            boolean alwaysWrapInBlock \u003d cc.shouldPreserveExtraBlocks();\n            if (alwaysWrapInBlock || firstAndOnlyChild.getType() \u003d\u003d Token.FUNCTION || firstAndOnlyChild.getType() \u003d\u003d Token.DO) {\n                cc.beginBlock();\n                add(firstAndOnlyChild, Context.STATEMENT);\n                cc.maybeLineBreak();\n                cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                return;\n            } else {\n                nodeToProcess \u003d firstAndOnlyChild;\n            }\n        }\n    }\n    if (nodeToProcess.getType() \u003d\u003d Token.EMPTY) {\n        cc.endStatement(true);\n    } else {\n        add(nodeToProcess, context);\n        if (nodeToProcess.getType() \u003d\u003d Token.VAR) {\n            cc.endStatement();\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/CodeGenerator.java",
      "functionStartLine": 636,
      "functionName": "addNonEmptyExpression",
      "functionAnnotation": "",
      "functionDoc": "Adds a block or expression, substituting a VOID with an empty statement.\nThis is used for \"for (...);\" and \"if (...);\" type statements.\n\n@param n The node to print.\n@param context The context to determine how the node should be printed.\n",
      "diff": "@@ -1,36 +1,34 @@\n private void addNonEmptyExpression(Node n, Context context, boolean allowNonBlockChild) {\n     Node nodeToProcess \u003d n;\n     if (!allowNonBlockChild \u0026\u0026 n.getType() !\u003d Token.BLOCK) {\n-        if (validation) {\n-            throw new Error(\"Missing BLOCK child.\");\n-        }\n+        throw new Error(\"Missing BLOCK child.\");\n     }\n     if (n.getType() \u003d\u003d Token.BLOCK) {\n         int count \u003d getNonEmptyChildCount(n);\n         if (count \u003d\u003d 0) {\n             cc.endStatement(true);\n             return;\n         }\n         if (count \u003d\u003d 1) {\n             Node firstAndOnlyChild \u003d getFirstNonEmptyChild(n);\n             boolean alwaysWrapInBlock \u003d cc.shouldPreserveExtraBlocks();\n             if (alwaysWrapInBlock || firstAndOnlyChild.getType() \u003d\u003d Token.FUNCTION || firstAndOnlyChild.getType() \u003d\u003d Token.DO) {\n                 cc.beginBlock();\n                 add(firstAndOnlyChild, Context.STATEMENT);\n                 cc.maybeLineBreak();\n                 cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                 return;\n             } else {\n                 nodeToProcess \u003d firstAndOnlyChild;\n             }\n         }\n     }\n     if (nodeToProcess.getType() \u003d\u003d Token.EMPTY) {\n         cc.endStatement(true);\n     } else {\n         add(nodeToProcess, context);\n         if (nodeToProcess.getType() \u003d\u003d Token.VAR) {\n             cc.endStatement();\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "222eafd303155b3eac5cd244584b2cb3c4c11975": {
      "type": "Ybodychange",
      "commitMessage": "tighten up some types. (Nick)\nR\u003dalan\nDELTA\u003d4  (2 added, 0 deleted, 2 changed)\n\nDon\u0027t use NAME for label names, introduce LABEL_NAME. This improves the correctness of the compiler as many passes don\u0027t distinguish between label names and variable names appropriately. (John)\nR\u003drobert\n\nRemove now unneeded checks for label names when inspecting NAME nodes. (John)\nR\u003drobert\n\nTweak code generator to break after blocks for better pretty printing. (John)\nR\u003drobert\nDELTA\u003d196  (160 added, 0 deleted, 36 changed)\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003dktmses\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@170 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/5/10, 12:30 PM",
      "commitName": "222eafd303155b3eac5cd244584b2cb3c4c11975",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "4/1/10, 7:32 PM",
      "commitNameOld": "f01925cbf7a39a885e51865208368e861d25a0c1",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 3.71,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "private void addNonEmptyExpression(Node n, Context context, boolean allowNonBlockChild) {\n    Node nodeToProcess \u003d n;\n    if (!allowNonBlockChild \u0026\u0026 n.getType() !\u003d Token.BLOCK) {\n        if (validation) {\n            throw new Error(\"Missing BLOCK child.\");\n        }\n    }\n    if (n.getType() \u003d\u003d Token.BLOCK) {\n        int count \u003d getNonEmptyChildCount(n);\n        if (count \u003d\u003d 0) {\n            cc.endStatement(true);\n            return;\n        }\n        if (count \u003d\u003d 1) {\n            Node firstAndOnlyChild \u003d getFirstNonEmptyChild(n);\n            boolean alwaysWrapInBlock \u003d cc.shouldPreserveExtraBlocks();\n            if (alwaysWrapInBlock || firstAndOnlyChild.getType() \u003d\u003d Token.FUNCTION || firstAndOnlyChild.getType() \u003d\u003d Token.DO) {\n                cc.beginBlock();\n                add(firstAndOnlyChild, Context.STATEMENT);\n                cc.maybeLineBreak();\n                cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                return;\n            } else {\n                nodeToProcess \u003d firstAndOnlyChild;\n            }\n        }\n    }\n    if (nodeToProcess.getType() \u003d\u003d Token.EMPTY) {\n        cc.endStatement(true);\n    } else {\n        add(nodeToProcess, context);\n        if (nodeToProcess.getType() \u003d\u003d Token.VAR) {\n            cc.endStatement();\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/CodeGenerator.java",
      "functionStartLine": 646,
      "functionName": "addNonEmptyExpression",
      "functionAnnotation": "",
      "functionDoc": "Adds a block or expression, substituting a VOID with an empty statement.\nThis is used for \"for (...);\" and \"if (...);\" type statements.\n\n@param n The node to print.\n@param context The context to determine how the node should be printed.\n",
      "diff": "@@ -1,36 +1,36 @@\n private void addNonEmptyExpression(Node n, Context context, boolean allowNonBlockChild) {\n     Node nodeToProcess \u003d n;\n     if (!allowNonBlockChild \u0026\u0026 n.getType() !\u003d Token.BLOCK) {\n         if (validation) {\n             throw new Error(\"Missing BLOCK child.\");\n         }\n     }\n     if (n.getType() \u003d\u003d Token.BLOCK) {\n         int count \u003d getNonEmptyChildCount(n);\n         if (count \u003d\u003d 0) {\n             cc.endStatement(true);\n             return;\n         }\n         if (count \u003d\u003d 1) {\n             Node firstAndOnlyChild \u003d getFirstNonEmptyChild(n);\n             boolean alwaysWrapInBlock \u003d cc.shouldPreserveExtraBlocks();\n             if (alwaysWrapInBlock || firstAndOnlyChild.getType() \u003d\u003d Token.FUNCTION || firstAndOnlyChild.getType() \u003d\u003d Token.DO) {\n                 cc.beginBlock();\n                 add(firstAndOnlyChild, Context.STATEMENT);\n                 cc.maybeLineBreak();\n-                cc.endBlock(context \u003d\u003d Context.STATEMENT);\n+                cc.endBlock(cc.breakAfterBlockFor(n, context \u003d\u003d Context.STATEMENT));\n                 return;\n             } else {\n                 nodeToProcess \u003d firstAndOnlyChild;\n             }\n         }\n     }\n     if (nodeToProcess.getType() \u003d\u003d Token.EMPTY) {\n         cc.endStatement(true);\n     } else {\n         add(nodeToProcess, context);\n         if (nodeToProcess.getType() \u003d\u003d Token.VAR) {\n             cc.endStatement();\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fe722ddeb545b6b3103369dea073ad3e6becde28": {
      "type": "Ybodychange",
      "commitMessage": "Add an alias for the --define flag to ensure the api is backwards\ncompatible. \n(Nick)\nR\u003drobert\nDELTA\u003d9  (6 added, 0 deleted, 3 changed)\n\nChange the default pretty printer so that then clauses of if\nstatements and bodies of for statements get printed in blocks\nand on separate lines even if the the body is a single statement:\nif (a) {\nb\n}\nrather than\nif (a) b;\nThis makes it easier to put breakpoints on the then clause rather\nthan only on the entire if statement. (Robert)\nR\u003djohn\nDELTA\u003d125  (122 added, 0 deleted, 3 changed)\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@137 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "3/15/10, 4:23 PM",
      "commitName": "fe722ddeb545b6b3103369dea073ad3e6becde28",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "1/27/10, 5:22 PM",
      "commitNameOld": "8ba5e1f86eaf3c31b9279f92823b4fa2a50574a3",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 46.92,
      "commitsBetweenForRepo": 54,
      "commitsBetweenForFile": 1,
      "actualSource": "private void addNonEmptyExpression(Node n, Context context, boolean allowNonBlockChild) {\n    Node nodeToProcess \u003d n;\n    if (!allowNonBlockChild \u0026\u0026 n.getType() !\u003d Token.BLOCK) {\n        if (validation) {\n            throw new Error(\"Missing BLOCK child.\");\n        }\n    }\n    if (n.getType() \u003d\u003d Token.BLOCK) {\n        int count \u003d getNonEmptyChildCount(n);\n        if (count \u003d\u003d 0) {\n            cc.endStatement(true);\n            return;\n        }\n        if (count \u003d\u003d 1) {\n            Node firstAndOnlyChild \u003d getFirstNonEmptyChild(n);\n            boolean alwaysWrapInBlock \u003d cc.shouldPreserveExtraBlocks();\n            if (alwaysWrapInBlock || firstAndOnlyChild.getType() \u003d\u003d Token.FUNCTION || firstAndOnlyChild.getType() \u003d\u003d Token.DO) {\n                cc.beginBlock();\n                add(firstAndOnlyChild, Context.STATEMENT);\n                cc.maybeLineBreak();\n                cc.endBlock(context \u003d\u003d Context.STATEMENT);\n                return;\n            } else {\n                nodeToProcess \u003d firstAndOnlyChild;\n            }\n        }\n    }\n    if (nodeToProcess.getType() \u003d\u003d Token.EMPTY) {\n        cc.endStatement(true);\n    } else {\n        add(nodeToProcess, context);\n        if (nodeToProcess.getType() \u003d\u003d Token.VAR) {\n            cc.endStatement();\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/CodeGenerator.java",
      "functionStartLine": 633,
      "functionName": "addNonEmptyExpression",
      "functionAnnotation": "",
      "functionDoc": "Adds a block or expression, substituting a VOID with an empty statement.\nThis is used for \"for (...);\" and \"if (...);\" type statements.\n\n@param n The node to print.\n@param context The context to determine how the node should be printed.\n",
      "diff": "@@ -1,35 +1,36 @@\n private void addNonEmptyExpression(Node n, Context context, boolean allowNonBlockChild) {\n     Node nodeToProcess \u003d n;\n     if (!allowNonBlockChild \u0026\u0026 n.getType() !\u003d Token.BLOCK) {\n         if (validation) {\n             throw new Error(\"Missing BLOCK child.\");\n         }\n     }\n     if (n.getType() \u003d\u003d Token.BLOCK) {\n         int count \u003d getNonEmptyChildCount(n);\n         if (count \u003d\u003d 0) {\n             cc.endStatement(true);\n             return;\n         }\n         if (count \u003d\u003d 1) {\n             Node firstAndOnlyChild \u003d getFirstNonEmptyChild(n);\n-            if (firstAndOnlyChild.getType() \u003d\u003d Token.FUNCTION || firstAndOnlyChild.getType() \u003d\u003d Token.DO) {\n+            boolean alwaysWrapInBlock \u003d cc.shouldPreserveExtraBlocks();\n+            if (alwaysWrapInBlock || firstAndOnlyChild.getType() \u003d\u003d Token.FUNCTION || firstAndOnlyChild.getType() \u003d\u003d Token.DO) {\n                 cc.beginBlock();\n                 add(firstAndOnlyChild, Context.STATEMENT);\n                 cc.maybeLineBreak();\n                 cc.endBlock(context \u003d\u003d Context.STATEMENT);\n                 return;\n             } else {\n                 nodeToProcess \u003d firstAndOnlyChild;\n             }\n         }\n     }\n     if (nodeToProcess.getType() \u003d\u003d Token.EMPTY) {\n         cc.endStatement(true);\n     } else {\n         add(nodeToProcess, context);\n         if (nodeToProcess.getType() \u003d\u003d Token.VAR) {\n             cc.endStatement();\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "168bc14ff5e9e664863c3b1146f2a5b7a30ffb42": {
      "type": "Ybodychange",
      "commitMessage": "Add a pass for collecting symbols exported like window[\u0027x\u0027] \u003d ...\n\nFix for issue #70.\n\nAssorted minor bug fixes.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@31 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "12/11/09, 3:29 PM",
      "commitName": "168bc14ff5e9e664863c3b1146f2a5b7a30ffb42",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "commitDateOld": "12/8/09, 3:50 PM",
      "commitNameOld": "847b296c23a63aa0a0b38cc3e63883e1688288e3",
      "commitAuthorOld": "nicholas.j.santos@gmail.com",
      "daysBetweenCommits": 2.99,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "private void addNonEmptyExpression(Node n, Context context, boolean allowNonBlockChild) {\n    Node nodeToProcess \u003d n;\n    if (!allowNonBlockChild \u0026\u0026 n.getType() !\u003d Token.BLOCK) {\n        if (validation) {\n            throw new Error(\"Missing BLOCK child.\");\n        }\n    }\n    if (n.getType() \u003d\u003d Token.BLOCK) {\n        int count \u003d getNonEmptyChildCount(n);\n        if (count \u003d\u003d 0) {\n            cc.endStatement(true);\n            return;\n        }\n        if (count \u003d\u003d 1) {\n            Node firstAndOnlyChild \u003d getFirstNonEmptyChild(n);\n            if (firstAndOnlyChild.getType() \u003d\u003d Token.FUNCTION || firstAndOnlyChild.getType() \u003d\u003d Token.DO) {\n                cc.beginBlock();\n                add(firstAndOnlyChild, Context.STATEMENT);\n                cc.maybeLineBreak();\n                cc.endBlock(context \u003d\u003d Context.STATEMENT);\n                return;\n            } else {\n                nodeToProcess \u003d firstAndOnlyChild;\n            }\n        }\n    }\n    if (nodeToProcess.getType() \u003d\u003d Token.EMPTY) {\n        cc.endStatement(true);\n    } else {\n        add(nodeToProcess, context);\n        if (nodeToProcess.getType() \u003d\u003d Token.VAR) {\n            cc.endStatement();\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/CodeGenerator.java",
      "functionStartLine": 619,
      "functionName": "addNonEmptyExpression",
      "functionAnnotation": "",
      "functionDoc": "Adds a block or expression, substituting a VOID with an empty statement.\nThis is used for \"for (...);\" and \"if (...);\" type statements.\n\n@param n The node to print.\n@param context The context to determine how the node should be printed.\n",
      "diff": "@@ -1,32 +1,35 @@\n private void addNonEmptyExpression(Node n, Context context, boolean allowNonBlockChild) {\n     Node nodeToProcess \u003d n;\n     if (!allowNonBlockChild \u0026\u0026 n.getType() !\u003d Token.BLOCK) {\n+        if (validation) {\n+            throw new Error(\"Missing BLOCK child.\");\n+        }\n     }\n     if (n.getType() \u003d\u003d Token.BLOCK) {\n         int count \u003d getNonEmptyChildCount(n);\n         if (count \u003d\u003d 0) {\n             cc.endStatement(true);\n             return;\n         }\n         if (count \u003d\u003d 1) {\n             Node firstAndOnlyChild \u003d getFirstNonEmptyChild(n);\n             if (firstAndOnlyChild.getType() \u003d\u003d Token.FUNCTION || firstAndOnlyChild.getType() \u003d\u003d Token.DO) {\n                 cc.beginBlock();\n                 add(firstAndOnlyChild, Context.STATEMENT);\n                 cc.maybeLineBreak();\n                 cc.endBlock(context \u003d\u003d Context.STATEMENT);\n                 return;\n             } else {\n                 nodeToProcess \u003d firstAndOnlyChild;\n             }\n         }\n     }\n     if (nodeToProcess.getType() \u003d\u003d Token.EMPTY) {\n         cc.endStatement(true);\n     } else {\n         add(nodeToProcess, context);\n         if (nodeToProcess.getType() \u003d\u003d Token.VAR) {\n             cc.endStatement();\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": {
      "type": "Yintroduced",
      "commitMessage": "Initial commit.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/3/09, 3:51 PM",
      "commitName": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "diff": "@@ -0,0 +1,32 @@\n+private void addNonEmptyExpression(Node n, Context context, boolean allowNonBlockChild) {\n+    Node nodeToProcess \u003d n;\n+    if (!allowNonBlockChild \u0026\u0026 n.getType() !\u003d Token.BLOCK) {\n+    }\n+    if (n.getType() \u003d\u003d Token.BLOCK) {\n+        int count \u003d getNonEmptyChildCount(n);\n+        if (count \u003d\u003d 0) {\n+            cc.endStatement(true);\n+            return;\n+        }\n+        if (count \u003d\u003d 1) {\n+            Node firstAndOnlyChild \u003d getFirstNonEmptyChild(n);\n+            if (firstAndOnlyChild.getType() \u003d\u003d Token.FUNCTION || firstAndOnlyChild.getType() \u003d\u003d Token.DO) {\n+                cc.beginBlock();\n+                add(firstAndOnlyChild, Context.STATEMENT);\n+                cc.maybeLineBreak();\n+                cc.endBlock(context \u003d\u003d Context.STATEMENT);\n+                return;\n+            } else {\n+                nodeToProcess \u003d firstAndOnlyChild;\n+            }\n+        }\n+    }\n+    if (nodeToProcess.getType() \u003d\u003d Token.EMPTY) {\n+        cc.endStatement(true);\n+    } else {\n+        add(nodeToProcess, context);\n+        if (nodeToProcess.getType() \u003d\u003d Token.VAR) {\n+            cc.endStatement();\n+        }\n+    }\n+}\n\\ No newline at end of file\n",
      "actualSource": "private void addNonEmptyExpression(Node n, Context context, boolean allowNonBlockChild) {\n    Node nodeToProcess \u003d n;\n    if (!allowNonBlockChild \u0026\u0026 n.getType() !\u003d Token.BLOCK) {\n    }\n    if (n.getType() \u003d\u003d Token.BLOCK) {\n        int count \u003d getNonEmptyChildCount(n);\n        if (count \u003d\u003d 0) {\n            cc.endStatement(true);\n            return;\n        }\n        if (count \u003d\u003d 1) {\n            Node firstAndOnlyChild \u003d getFirstNonEmptyChild(n);\n            if (firstAndOnlyChild.getType() \u003d\u003d Token.FUNCTION || firstAndOnlyChild.getType() \u003d\u003d Token.DO) {\n                cc.beginBlock();\n                add(firstAndOnlyChild, Context.STATEMENT);\n                cc.maybeLineBreak();\n                cc.endBlock(context \u003d\u003d Context.STATEMENT);\n                return;\n            } else {\n                nodeToProcess \u003d firstAndOnlyChild;\n            }\n        }\n    }\n    if (nodeToProcess.getType() \u003d\u003d Token.EMPTY) {\n        cc.endStatement(true);\n    } else {\n        add(nodeToProcess, context);\n        if (nodeToProcess.getType() \u003d\u003d Token.VAR) {\n            cc.endStatement();\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/CodeGenerator.java",
      "functionStartLine": 590,
      "functionName": "addNonEmptyExpression",
      "functionAnnotation": "",
      "functionDoc": "Adds a block or expression, substituting a VOID with an empty statement.\nThis is used for \"for (...);\" and \"if (...);\" type statements.\n\n@param n The node to print.\n@param context The context to determine how the node should be printed.\n"
    }
  }
}