{
  "origin": "codeshovel",
  "repositoryName": "Closure-115b",
  "repositoryPath": "/tmp/Closure-115b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "InlineFunctions.java",
  "functionName": "maybeAddFunction",
  "functionId": "maybeAddFunction___fn-Function__module-JSModule",
  "sourceFilePath": "src/com/google/javascript/jscomp/InlineFunctions.java",
  "functionAnnotation": "",
  "functionDoc": "Updates the FunctionState object for the given function. Checks if the\ngiven function matches the criteria for an inlinable function.\n",
  "functionStartLine": 240,
  "functionEndLine": 306,
  "numCommitsSeen": 43,
  "timeTaken": 2207,
  "changeHistory": [
    "70a5626922ea7e8c98747e22b6986638ba38fadc",
    "de20cf30dfdf0f885c9b97dfb75f8425df0280b9",
    "b4801b28ceea8db0f63da7440d6769cb9b7cce8a",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3"
  ],
  "changeHistoryShort": {
    "70a5626922ea7e8c98747e22b6986638ba38fadc": "Ybodychange",
    "de20cf30dfdf0f885c9b97dfb75f8425df0280b9": "Ybodychange",
    "b4801b28ceea8db0f63da7440d6769cb9b7cce8a": "Ybodychange",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "70a5626922ea7e8c98747e22b6986638ba38fadc": {
      "type": "Ybodychange",
      "commitMessage": "\nFix various typos, spelling and grammar errors.\nFixes issue 734. \nContributed by Robert Gust Bardon\n\nR\u003dnicksantos\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d4827\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1979 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "5/18/12, 11:09 AM",
      "commitName": "70a5626922ea7e8c98747e22b6986638ba38fadc",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "11/10/11, 8:36 AM",
      "commitNameOld": "ec324a9bb23eb78c76f537f4c4170ba88d542f1c",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 190.06,
      "commitsBetweenForRepo": 339,
      "commitsBetweenForFile": 1,
      "actualSource": "private void maybeAddFunction(Function fn, JSModule module) {\n    String name \u003d fn.getName();\n    FunctionState fs \u003d getOrCreateFunctionState(name);\n    if (fs.hasExistingFunctionDefinition()) {\n        fs.setInline(false);\n    } else {\n        if (fs.canInline()) {\n            fs.setFn(fn);\n            if (injector.isDirectCallNodeReplacementPossible(fn.getFunctionNode())) {\n                fs.inlineDirectly(true);\n            }\n            if (!isCandidateFunction(fn)) {\n                fs.setInline(false);\n            }\n            if (fs.canInline()) {\n                fs.setModule(module);\n                Node fnNode \u003d fn.getFunctionNode();\n                Set\u003cString\u003e namesToAlias \u003d FunctionArgumentInjector.findModifiedParameters(fnNode);\n                if (!namesToAlias.isEmpty()) {\n                    fs.inlineDirectly(false);\n                    fs.setNamesToAlias(namesToAlias);\n                }\n                Node block \u003d NodeUtil.getFunctionBody(fnNode);\n                if (NodeUtil.referencesThis(block)) {\n                    fs.setReferencesThis(true);\n                }\n                if (NodeUtil.containsFunction(block)) {\n                    fs.setHasInnerFunctions(true);\n                    if (!assumeMinimumCapture \u0026\u0026 hasLocalNames(fnNode)) {\n                        fs.setInline(false);\n                    }\n                }\n            }\n            if (fs.canInline() \u0026\u0026 !fs.canInlineDirectly()) {\n                if (!blockFunctionInliningEnabled) {\n                    fs.setInline(false);\n                }\n            }\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/InlineFunctions.java",
      "functionStartLine": 242,
      "functionName": "maybeAddFunction",
      "functionAnnotation": "",
      "functionDoc": "Updates the FunctionState object for the given function. Checks if the\ngiven function matches the criteria for an inlinable function.\n",
      "diff": "",
      "extendedDetails": {}
    },
    "de20cf30dfdf0f885c9b97dfb75f8425df0280b9": {
      "type": "Ybodychange",
      "commitMessage": "\nAdd an inliner option to inline function without considering whether \"capture\" of variables. Traditionally, we have avoiding inlining function with closure into scope (because they might capture unintended values) or inline functions that require temporaries into scopes that contain closures (because the temps might leak into the closure scopes).\nThis CL does not include a means of enabling the option.\n\nR\u003dacleung\nDELTA\u003d332  (313 added, 0 deleted, 19 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3089\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1378 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "8/22/11, 5:34 PM",
      "commitName": "de20cf30dfdf0f885c9b97dfb75f8425df0280b9",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "8/8/11, 2:51 PM",
      "commitNameOld": "43cece8ccf72521faa04fc79fddfc5f7d661a787",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 14.11,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "actualSource": "private void maybeAddFunction(Function fn, JSModule module) {\n    String name \u003d fn.getName();\n    FunctionState fs \u003d getOrCreateFunctionState(name);\n    if (fs.hasExistingFunctionDefinition()) {\n        fs.setInline(false);\n    } else {\n        if (fs.canInline()) {\n            fs.setFn(fn);\n            if (injector.isDirectCallNodeReplacementPossible(fn.getFunctionNode())) {\n                fs.inlineDirectly(true);\n            }\n            if (!isCandidateFunction(fn)) {\n                fs.setInline(false);\n            }\n            if (fs.canInline()) {\n                fs.setModule(module);\n                Node fnNode \u003d fn.getFunctionNode();\n                Set\u003cString\u003e namesToAlias \u003d FunctionArgumentInjector.findModifiedParameters(fnNode);\n                if (!namesToAlias.isEmpty()) {\n                    fs.inlineDirectly(false);\n                    fs.setNamesToAlias(namesToAlias);\n                }\n                Node block \u003d NodeUtil.getFunctionBody(fnNode);\n                if (NodeUtil.referencesThis(block)) {\n                    fs.setReferencesThis(true);\n                }\n                if (NodeUtil.containsFunction(block)) {\n                    fs.setHasInnerFunctions(true);\n                    if (!assumeMinimumCapture \u0026\u0026 hasLocalNames(fnNode)) {\n                        fs.setInline(false);\n                    }\n                }\n            }\n            if (fs.canInline() \u0026\u0026 !fs.canInlineDirectly()) {\n                if (!blockFunctionInliningEnabled) {\n                    fs.setInline(false);\n                }\n            }\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/InlineFunctions.java",
      "functionStartLine": 242,
      "functionName": "maybeAddFunction",
      "functionAnnotation": "",
      "functionDoc": "Updates the FunctionState object for the given function. Checks if the\ngiven function matches the criteria for an inlinable function.\n",
      "diff": "@@ -1,41 +1,41 @@\n private void maybeAddFunction(Function fn, JSModule module) {\n     String name \u003d fn.getName();\n     FunctionState fs \u003d getOrCreateFunctionState(name);\n     if (fs.hasExistingFunctionDefinition()) {\n         fs.setInline(false);\n     } else {\n         if (fs.canInline()) {\n             fs.setFn(fn);\n             if (injector.isDirectCallNodeReplacementPossible(fn.getFunctionNode())) {\n                 fs.inlineDirectly(true);\n             }\n             if (!isCandidateFunction(fn)) {\n                 fs.setInline(false);\n             }\n             if (fs.canInline()) {\n                 fs.setModule(module);\n                 Node fnNode \u003d fn.getFunctionNode();\n                 Set\u003cString\u003e namesToAlias \u003d FunctionArgumentInjector.findModifiedParameters(fnNode);\n                 if (!namesToAlias.isEmpty()) {\n                     fs.inlineDirectly(false);\n                     fs.setNamesToAlias(namesToAlias);\n                 }\n                 Node block \u003d NodeUtil.getFunctionBody(fnNode);\n                 if (NodeUtil.referencesThis(block)) {\n                     fs.setReferencesThis(true);\n                 }\n                 if (NodeUtil.containsFunction(block)) {\n                     fs.setHasInnerFunctions(true);\n-                    if (hasLocalNames(fnNode)) {\n+                    if (!assumeMinimumCapture \u0026\u0026 hasLocalNames(fnNode)) {\n                         fs.setInline(false);\n                     }\n                 }\n             }\n             if (fs.canInline() \u0026\u0026 !fs.canInlineDirectly()) {\n                 if (!blockFunctionInliningEnabled) {\n                     fs.setInline(false);\n                 }\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b4801b28ceea8db0f63da7440d6769cb9b7cce8a": {
      "type": "Ybodychange",
      "commitMessage": "\nChange on 2010/05/28 by johnlenz\n\n        Inline functions with inner functions into global scope if they don\u0027t\n        declare any names.\n\n        R\u003dacleung\n        DELTA\u003d329  (244 added, 27 deleted, 58 changed)\n\nChange on 2010/05/28 by dcc\n\n        First pass on refactoring FoldConstants into separate peephole optimizations. This changelist adds the notion of an AbstractPeepholeOptimization and adds a PeepholeOptimizationsPass that runs them. In this go around the minimization aspects of FoldConstants have been factored out into PeepholeMinimize. A future change will factor out the other components of FoldConstants into their own PeepholeOptimizations. DefaultPassConfig has also been updated to run the new PeepholeOptimizationPass.\n\n        This change does not move the minimization-related unit tests from FoldConstantsTest to PeepholeMinimizeTest -- a future, separate, change will do so. Hopefully this will make it easier to review.\n\n        R\u003dacleung\n        DELTA\u003d1966  (1271 added, 675 deleted, 20 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d13010\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@235 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "5/29/10, 1:07 PM",
      "commitName": "b4801b28ceea8db0f63da7440d6769cb9b7cce8a",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "5/25/10, 10:51 AM",
      "commitNameOld": "170b23fa89cdcc38411fc29ec4453935e0903b16",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 4.09,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "private void maybeAddFunction(Function fn, JSModule module) {\n    String name \u003d fn.getName();\n    FunctionState fs \u003d getOrCreateFunctionState(name);\n    if (fs.hasExistingFunctionDefinition()) {\n        fs.setInline(false);\n    } else {\n        if (fs.canInline()) {\n            fs.setFn(fn);\n            if (injector.isDirectCallNodeReplacementPossible(fn.getFunctionNode())) {\n                fs.inlineDirectly(true);\n            }\n            if (!isCandidateFunction(fn)) {\n                fs.setInline(false);\n            }\n            if (fs.canInline()) {\n                fs.setModule(module);\n                Node fnNode \u003d fn.getFunctionNode();\n                Set\u003cString\u003e namesToAlias \u003d FunctionArgumentInjector.findModifiedParameters(fnNode);\n                if (!namesToAlias.isEmpty()) {\n                    fs.inlineDirectly(false);\n                    fs.setNamesToAlias(namesToAlias);\n                }\n                Node block \u003d NodeUtil.getFunctionBody(fnNode);\n                if (NodeUtil.referencesThis(block)) {\n                    fs.setReferencesThis(true);\n                }\n                if (NodeUtil.containsFunction(block)) {\n                    fs.setHasInnerFunctions(true);\n                    if (hasLocalNames(fnNode)) {\n                        fs.setInline(false);\n                    }\n                }\n            }\n            if (fs.canInline() \u0026\u0026 !fs.canInlineDirectly()) {\n                if (!blockFunctionInliningEnabled) {\n                    fs.setInline(false);\n                }\n            }\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/InlineFunctions.java",
      "functionStartLine": 228,
      "functionName": "maybeAddFunction",
      "functionAnnotation": "",
      "functionDoc": "Updates the FunctionState object for the given function. Checks if the\ngiven function matches the criteria for an inlinable function.\n",
      "diff": "@@ -1,35 +1,41 @@\n private void maybeAddFunction(Function fn, JSModule module) {\n     String name \u003d fn.getName();\n     FunctionState fs \u003d getOrCreateFunctionState(name);\n     if (fs.hasExistingFunctionDefinition()) {\n         fs.setInline(false);\n     } else {\n         if (fs.canInline()) {\n             fs.setFn(fn);\n             if (injector.isDirectCallNodeReplacementPossible(fn.getFunctionNode())) {\n                 fs.inlineDirectly(true);\n             }\n             if (!isCandidateFunction(fn)) {\n                 fs.setInline(false);\n             }\n             if (fs.canInline()) {\n                 fs.setModule(module);\n                 Node fnNode \u003d fn.getFunctionNode();\n                 Set\u003cString\u003e namesToAlias \u003d FunctionArgumentInjector.findModifiedParameters(fnNode);\n                 if (!namesToAlias.isEmpty()) {\n                     fs.inlineDirectly(false);\n                     fs.setNamesToAlias(namesToAlias);\n                 }\n                 Node block \u003d NodeUtil.getFunctionBody(fnNode);\n                 if (NodeUtil.referencesThis(block)) {\n                     fs.setReferencesThis(true);\n                 }\n+                if (NodeUtil.containsFunction(block)) {\n+                    fs.setHasInnerFunctions(true);\n+                    if (hasLocalNames(fnNode)) {\n+                        fs.setInline(false);\n+                    }\n+                }\n             }\n             if (fs.canInline() \u0026\u0026 !fs.canInlineDirectly()) {\n                 if (!blockFunctionInliningEnabled) {\n                     fs.setInline(false);\n                 }\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": {
      "type": "Yintroduced",
      "commitMessage": "Initial commit.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/3/09, 3:51 PM",
      "commitName": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "diff": "@@ -0,0 +1,35 @@\n+private void maybeAddFunction(Function fn, JSModule module) {\n+    String name \u003d fn.getName();\n+    FunctionState fs \u003d getOrCreateFunctionState(name);\n+    if (fs.hasExistingFunctionDefinition()) {\n+        fs.setInline(false);\n+    } else {\n+        if (fs.canInline()) {\n+            fs.setFn(fn);\n+            if (injector.isDirectCallNodeReplacementPossible(fn.getFunctionNode())) {\n+                fs.inlineDirectly(true);\n+            }\n+            if (!isCandidateFunction(fn)) {\n+                fs.setInline(false);\n+            }\n+            if (fs.canInline()) {\n+                fs.setModule(module);\n+                Node fnNode \u003d fn.getFunctionNode();\n+                Set\u003cString\u003e namesToAlias \u003d FunctionArgumentInjector.findModifiedParameters(fnNode);\n+                if (!namesToAlias.isEmpty()) {\n+                    fs.inlineDirectly(false);\n+                    fs.setNamesToAlias(namesToAlias);\n+                }\n+                Node block \u003d NodeUtil.getFunctionBody(fnNode);\n+                if (NodeUtil.referencesThis(block)) {\n+                    fs.setReferencesThis(true);\n+                }\n+            }\n+            if (fs.canInline() \u0026\u0026 !fs.canInlineDirectly()) {\n+                if (!blockFunctionInliningEnabled) {\n+                    fs.setInline(false);\n+                }\n+            }\n+        }\n+    }\n+}\n\\ No newline at end of file\n",
      "actualSource": "private void maybeAddFunction(Function fn, JSModule module) {\n    String name \u003d fn.getName();\n    FunctionState fs \u003d getOrCreateFunctionState(name);\n    if (fs.hasExistingFunctionDefinition()) {\n        fs.setInline(false);\n    } else {\n        if (fs.canInline()) {\n            fs.setFn(fn);\n            if (injector.isDirectCallNodeReplacementPossible(fn.getFunctionNode())) {\n                fs.inlineDirectly(true);\n            }\n            if (!isCandidateFunction(fn)) {\n                fs.setInline(false);\n            }\n            if (fs.canInline()) {\n                fs.setModule(module);\n                Node fnNode \u003d fn.getFunctionNode();\n                Set\u003cString\u003e namesToAlias \u003d FunctionArgumentInjector.findModifiedParameters(fnNode);\n                if (!namesToAlias.isEmpty()) {\n                    fs.inlineDirectly(false);\n                    fs.setNamesToAlias(namesToAlias);\n                }\n                Node block \u003d NodeUtil.getFunctionBody(fnNode);\n                if (NodeUtil.referencesThis(block)) {\n                    fs.setReferencesThis(true);\n                }\n            }\n            if (fs.canInline() \u0026\u0026 !fs.canInlineDirectly()) {\n                if (!blockFunctionInliningEnabled) {\n                    fs.setInline(false);\n                }\n            }\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/InlineFunctions.java",
      "functionStartLine": 220,
      "functionName": "maybeAddFunction",
      "functionAnnotation": "",
      "functionDoc": "Updates the FunctionState object for the given function. Checks if the\ngiven function matches the criteria for an inlinable function.\n"
    }
  }
}