{
  "origin": "codeshovel",
  "repositoryName": "Closure-115b",
  "repositoryPath": "/tmp/Closure-115b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ExpressionDecomposer.java",
  "functionName": "extractExpression",
  "functionId": "extractExpression___expr-Node__injectionPoint-Node",
  "sourceFilePath": "src/com/google/javascript/jscomp/ExpressionDecomposer.java",
  "functionAnnotation": "",
  "functionDoc": "\n@param expr The expression to extract.\n@param injectionPoint The node before which to added the extracted\n    expression.\n@return The extract statement node.\n",
  "functionStartLine": 440,
  "functionEndLine": 508,
  "numCommitsSeen": 25,
  "timeTaken": 1812,
  "changeHistory": [
    "9dfbc803407e714f9744555a1c9e7c4230f1816d",
    "39f629a8cfaab37da55288010640d7e516000b1f",
    "3d80e1ed8fffbcb5f41b63f64726d9a4c76f209f",
    "6e3eb4f7619179ba6c23db2af7549ef02f588c35",
    "f01925cbf7a39a885e51865208368e861d25a0c1",
    "4922461babcc37fb037d2a6db3fcb33fe4127a60",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3"
  ],
  "changeHistoryShort": {
    "9dfbc803407e714f9744555a1c9e7c4230f1816d": "Ybodychange",
    "39f629a8cfaab37da55288010640d7e516000b1f": "Ybodychange",
    "3d80e1ed8fffbcb5f41b63f64726d9a4c76f209f": "Ybodychange",
    "6e3eb4f7619179ba6c23db2af7549ef02f588c35": "Ybodychange",
    "f01925cbf7a39a885e51865208368e861d25a0c1": "Ybodychange",
    "4922461babcc37fb037d2a6db3fcb33fe4127a60": "Ybodychange",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "9dfbc803407e714f9744555a1c9e7c4230f1816d": {
      "type": "Ybodychange",
      "commitMessage": "\nUse the new IR interface where possible.\n\nR\u003dnicksantos\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3799\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1641 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/22/11, 2:28 PM",
      "commitName": "9dfbc803407e714f9744555a1c9e7c4230f1816d",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "11/14/11, 6:13 PM",
      "commitNameOld": "39f629a8cfaab37da55288010640d7e516000b1f",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 7.84,
      "commitsBetweenForRepo": 31,
      "commitsBetweenForFile": 1,
      "actualSource": "private Node extractExpression(Node expr, Node injectionPoint) {\n    Node parent \u003d expr.getParent();\n    boolean isLhsOfAssignOp \u003d NodeUtil.isAssignmentOp(parent) \u0026\u0026 !parent.isAssign() \u0026\u0026 parent.getFirstChild() \u003d\u003d expr;\n    Node firstExtractedNode \u003d null;\n    if (isLhsOfAssignOp \u0026\u0026 NodeUtil.isGet(expr)) {\n        for (Node n : expr.children()) {\n            if (!n.isString() \u0026\u0026 !isConstantName(n, knownConstants)) {\n                Node extractedNode \u003d extractExpression(n, injectionPoint);\n                if (firstExtractedNode \u003d\u003d null) {\n                    firstExtractedNode \u003d extractedNode;\n                }\n            }\n        }\n    }\n    String tempName \u003d getTempConstantValueName();\n    Node replacementValueNode \u003d IR.name(tempName).srcref(expr);\n    Node tempNameValue;\n    if (isLhsOfAssignOp) {\n        Preconditions.checkState(expr.isName() || NodeUtil.isGet(expr));\n        Node opNode \u003d new Node(NodeUtil.getOpFromAssignmentOp(parent)).copyInformationFrom(parent);\n        Node rightOperand \u003d parent.getLastChild();\n        parent.setType(Token.ASSIGN);\n        parent.replaceChild(rightOperand, opNode);\n        opNode.addChildToFront(replacementValueNode);\n        opNode.addChildToBack(rightOperand);\n        tempNameValue \u003d expr.cloneTree();\n    } else {\n        parent.replaceChild(expr, replacementValueNode);\n        tempNameValue \u003d expr;\n    }\n    Node tempVarNode \u003d NodeUtil.newVarNode(tempName, tempNameValue);\n    Node injectionPointParent \u003d injectionPoint.getParent();\n    injectionPointParent.addChildBefore(tempVarNode, injectionPoint);\n    if (firstExtractedNode \u003d\u003d null) {\n        firstExtractedNode \u003d tempVarNode;\n    }\n    return firstExtractedNode;\n}",
      "path": "src/com/google/javascript/jscomp/ExpressionDecomposer.java",
      "functionStartLine": 441,
      "functionName": "extractExpression",
      "functionAnnotation": "",
      "functionDoc": "\n@param expr The expression to extract.\n@param injectionPoint The node before which to added the extracted\n    expression.\n@return The extract statement node.\n",
      "diff": "@@ -1,38 +1,38 @@\n private Node extractExpression(Node expr, Node injectionPoint) {\n     Node parent \u003d expr.getParent();\n     boolean isLhsOfAssignOp \u003d NodeUtil.isAssignmentOp(parent) \u0026\u0026 !parent.isAssign() \u0026\u0026 parent.getFirstChild() \u003d\u003d expr;\n     Node firstExtractedNode \u003d null;\n     if (isLhsOfAssignOp \u0026\u0026 NodeUtil.isGet(expr)) {\n         for (Node n : expr.children()) {\n             if (!n.isString() \u0026\u0026 !isConstantName(n, knownConstants)) {\n                 Node extractedNode \u003d extractExpression(n, injectionPoint);\n                 if (firstExtractedNode \u003d\u003d null) {\n                     firstExtractedNode \u003d extractedNode;\n                 }\n             }\n         }\n     }\n     String tempName \u003d getTempConstantValueName();\n-    Node replacementValueNode \u003d Node.newString(Token.NAME, tempName).copyInformationFrom(expr);\n+    Node replacementValueNode \u003d IR.name(tempName).srcref(expr);\n     Node tempNameValue;\n     if (isLhsOfAssignOp) {\n         Preconditions.checkState(expr.isName() || NodeUtil.isGet(expr));\n         Node opNode \u003d new Node(NodeUtil.getOpFromAssignmentOp(parent)).copyInformationFrom(parent);\n         Node rightOperand \u003d parent.getLastChild();\n         parent.setType(Token.ASSIGN);\n         parent.replaceChild(rightOperand, opNode);\n         opNode.addChildToFront(replacementValueNode);\n         opNode.addChildToBack(rightOperand);\n         tempNameValue \u003d expr.cloneTree();\n     } else {\n         parent.replaceChild(expr, replacementValueNode);\n         tempNameValue \u003d expr;\n     }\n     Node tempVarNode \u003d NodeUtil.newVarNode(tempName, tempNameValue);\n     Node injectionPointParent \u003d injectionPoint.getParent();\n     injectionPointParent.addChildBefore(tempVarNode, injectionPoint);\n     if (firstExtractedNode \u003d\u003d null) {\n         firstExtractedNode \u003d tempVarNode;\n     }\n     return firstExtractedNode;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "39f629a8cfaab37da55288010640d7e516000b1f": {
      "type": "Ybodychange",
      "commitMessage": "\nReplace calls of the form \"Node.getType() !\u003d Token.XX\" with\n\"!Node.isXX()\" calls.\n\nR\u003dnicksantos\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3706\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1598 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/14/11, 6:13 PM",
      "commitName": "39f629a8cfaab37da55288010640d7e516000b1f",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "11/11/11, 4:42 PM",
      "commitNameOld": "5524adbda991632656059566b69cc2771ba42b7d",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 3.06,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "private Node extractExpression(Node expr, Node injectionPoint) {\n    Node parent \u003d expr.getParent();\n    boolean isLhsOfAssignOp \u003d NodeUtil.isAssignmentOp(parent) \u0026\u0026 !parent.isAssign() \u0026\u0026 parent.getFirstChild() \u003d\u003d expr;\n    Node firstExtractedNode \u003d null;\n    if (isLhsOfAssignOp \u0026\u0026 NodeUtil.isGet(expr)) {\n        for (Node n : expr.children()) {\n            if (!n.isString() \u0026\u0026 !isConstantName(n, knownConstants)) {\n                Node extractedNode \u003d extractExpression(n, injectionPoint);\n                if (firstExtractedNode \u003d\u003d null) {\n                    firstExtractedNode \u003d extractedNode;\n                }\n            }\n        }\n    }\n    String tempName \u003d getTempConstantValueName();\n    Node replacementValueNode \u003d Node.newString(Token.NAME, tempName).copyInformationFrom(expr);\n    Node tempNameValue;\n    if (isLhsOfAssignOp) {\n        Preconditions.checkState(expr.isName() || NodeUtil.isGet(expr));\n        Node opNode \u003d new Node(NodeUtil.getOpFromAssignmentOp(parent)).copyInformationFrom(parent);\n        Node rightOperand \u003d parent.getLastChild();\n        parent.setType(Token.ASSIGN);\n        parent.replaceChild(rightOperand, opNode);\n        opNode.addChildToFront(replacementValueNode);\n        opNode.addChildToBack(rightOperand);\n        tempNameValue \u003d expr.cloneTree();\n    } else {\n        parent.replaceChild(expr, replacementValueNode);\n        tempNameValue \u003d expr;\n    }\n    Node tempVarNode \u003d NodeUtil.newVarNode(tempName, tempNameValue);\n    Node injectionPointParent \u003d injectionPoint.getParent();\n    injectionPointParent.addChildBefore(tempVarNode, injectionPoint);\n    if (firstExtractedNode \u003d\u003d null) {\n        firstExtractedNode \u003d tempVarNode;\n    }\n    return firstExtractedNode;\n}",
      "path": "src/com/google/javascript/jscomp/ExpressionDecomposer.java",
      "functionStartLine": 440,
      "functionName": "extractExpression",
      "functionAnnotation": "",
      "functionDoc": "\n@param expr The expression to extract.\n@param injectionPoint The node before which to added the extracted\n    expression.\n@return The extract statement node.\n",
      "diff": "@@ -1,38 +1,38 @@\n private Node extractExpression(Node expr, Node injectionPoint) {\n     Node parent \u003d expr.getParent();\n     boolean isLhsOfAssignOp \u003d NodeUtil.isAssignmentOp(parent) \u0026\u0026 !parent.isAssign() \u0026\u0026 parent.getFirstChild() \u003d\u003d expr;\n     Node firstExtractedNode \u003d null;\n     if (isLhsOfAssignOp \u0026\u0026 NodeUtil.isGet(expr)) {\n         for (Node n : expr.children()) {\n-            if (n.getType() !\u003d Token.STRING \u0026\u0026 !isConstantName(n, knownConstants)) {\n+            if (!n.isString() \u0026\u0026 !isConstantName(n, knownConstants)) {\n                 Node extractedNode \u003d extractExpression(n, injectionPoint);\n                 if (firstExtractedNode \u003d\u003d null) {\n                     firstExtractedNode \u003d extractedNode;\n                 }\n             }\n         }\n     }\n     String tempName \u003d getTempConstantValueName();\n     Node replacementValueNode \u003d Node.newString(Token.NAME, tempName).copyInformationFrom(expr);\n     Node tempNameValue;\n     if (isLhsOfAssignOp) {\n         Preconditions.checkState(expr.isName() || NodeUtil.isGet(expr));\n         Node opNode \u003d new Node(NodeUtil.getOpFromAssignmentOp(parent)).copyInformationFrom(parent);\n         Node rightOperand \u003d parent.getLastChild();\n         parent.setType(Token.ASSIGN);\n         parent.replaceChild(rightOperand, opNode);\n         opNode.addChildToFront(replacementValueNode);\n         opNode.addChildToBack(rightOperand);\n         tempNameValue \u003d expr.cloneTree();\n     } else {\n         parent.replaceChild(expr, replacementValueNode);\n         tempNameValue \u003d expr;\n     }\n     Node tempVarNode \u003d NodeUtil.newVarNode(tempName, tempNameValue);\n     Node injectionPointParent \u003d injectionPoint.getParent();\n     injectionPointParent.addChildBefore(tempVarNode, injectionPoint);\n     if (firstExtractedNode \u003d\u003d null) {\n         firstExtractedNode \u003d tempVarNode;\n     }\n     return firstExtractedNode;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3d80e1ed8fffbcb5f41b63f64726d9a4c76f209f": {
      "type": "Ybodychange",
      "commitMessage": "\nInline NodeUtil.isXXX functions and call the Node.isXXX functions\ndirectly.\n\nR\u003dnicksantos\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3673\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1578 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/9/11, 1:51 PM",
      "commitName": "3d80e1ed8fffbcb5f41b63f64726d9a4c76f209f",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "7/28/11, 4:19 PM",
      "commitNameOld": "76abdf11394c0e7515ae63335676ea3657badb45",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 103.94,
      "commitsBetweenForRepo": 246,
      "commitsBetweenForFile": 1,
      "actualSource": "private Node extractExpression(Node expr, Node injectionPoint) {\n    Node parent \u003d expr.getParent();\n    boolean isLhsOfAssignOp \u003d NodeUtil.isAssignmentOp(parent) \u0026\u0026 !parent.isAssign() \u0026\u0026 parent.getFirstChild() \u003d\u003d expr;\n    Node firstExtractedNode \u003d null;\n    if (isLhsOfAssignOp \u0026\u0026 NodeUtil.isGet(expr)) {\n        for (Node n : expr.children()) {\n            if (n.getType() !\u003d Token.STRING \u0026\u0026 !isConstantName(n, knownConstants)) {\n                Node extractedNode \u003d extractExpression(n, injectionPoint);\n                if (firstExtractedNode \u003d\u003d null) {\n                    firstExtractedNode \u003d extractedNode;\n                }\n            }\n        }\n    }\n    String tempName \u003d getTempConstantValueName();\n    Node replacementValueNode \u003d Node.newString(Token.NAME, tempName).copyInformationFrom(expr);\n    Node tempNameValue;\n    if (isLhsOfAssignOp) {\n        Preconditions.checkState(expr.isName() || NodeUtil.isGet(expr));\n        Node opNode \u003d new Node(NodeUtil.getOpFromAssignmentOp(parent)).copyInformationFrom(parent);\n        Node rightOperand \u003d parent.getLastChild();\n        parent.setType(Token.ASSIGN);\n        parent.replaceChild(rightOperand, opNode);\n        opNode.addChildToFront(replacementValueNode);\n        opNode.addChildToBack(rightOperand);\n        tempNameValue \u003d expr.cloneTree();\n    } else {\n        parent.replaceChild(expr, replacementValueNode);\n        tempNameValue \u003d expr;\n    }\n    Node tempVarNode \u003d NodeUtil.newVarNode(tempName, tempNameValue);\n    Node injectionPointParent \u003d injectionPoint.getParent();\n    injectionPointParent.addChildBefore(tempVarNode, injectionPoint);\n    if (firstExtractedNode \u003d\u003d null) {\n        firstExtractedNode \u003d tempVarNode;\n    }\n    return firstExtractedNode;\n}",
      "path": "src/com/google/javascript/jscomp/ExpressionDecomposer.java",
      "functionStartLine": 440,
      "functionName": "extractExpression",
      "functionAnnotation": "",
      "functionDoc": "\n@param expr The expression to extract.\n@param injectionPoint The node before which to added the extracted\n    expression.\n@return The extract statement node.\n",
      "diff": "@@ -1,38 +1,38 @@\n private Node extractExpression(Node expr, Node injectionPoint) {\n     Node parent \u003d expr.getParent();\n-    boolean isLhsOfAssignOp \u003d NodeUtil.isAssignmentOp(parent) \u0026\u0026 !NodeUtil.isAssign(parent) \u0026\u0026 parent.getFirstChild() \u003d\u003d expr;\n+    boolean isLhsOfAssignOp \u003d NodeUtil.isAssignmentOp(parent) \u0026\u0026 !parent.isAssign() \u0026\u0026 parent.getFirstChild() \u003d\u003d expr;\n     Node firstExtractedNode \u003d null;\n     if (isLhsOfAssignOp \u0026\u0026 NodeUtil.isGet(expr)) {\n         for (Node n : expr.children()) {\n             if (n.getType() !\u003d Token.STRING \u0026\u0026 !isConstantName(n, knownConstants)) {\n                 Node extractedNode \u003d extractExpression(n, injectionPoint);\n                 if (firstExtractedNode \u003d\u003d null) {\n                     firstExtractedNode \u003d extractedNode;\n                 }\n             }\n         }\n     }\n     String tempName \u003d getTempConstantValueName();\n     Node replacementValueNode \u003d Node.newString(Token.NAME, tempName).copyInformationFrom(expr);\n     Node tempNameValue;\n     if (isLhsOfAssignOp) {\n-        Preconditions.checkState(NodeUtil.isName(expr) || NodeUtil.isGet(expr));\n+        Preconditions.checkState(expr.isName() || NodeUtil.isGet(expr));\n         Node opNode \u003d new Node(NodeUtil.getOpFromAssignmentOp(parent)).copyInformationFrom(parent);\n         Node rightOperand \u003d parent.getLastChild();\n         parent.setType(Token.ASSIGN);\n         parent.replaceChild(rightOperand, opNode);\n         opNode.addChildToFront(replacementValueNode);\n         opNode.addChildToBack(rightOperand);\n         tempNameValue \u003d expr.cloneTree();\n     } else {\n         parent.replaceChild(expr, replacementValueNode);\n         tempNameValue \u003d expr;\n     }\n     Node tempVarNode \u003d NodeUtil.newVarNode(tempName, tempNameValue);\n     Node injectionPointParent \u003d injectionPoint.getParent();\n     injectionPointParent.addChildBefore(tempVarNode, injectionPoint);\n     if (firstExtractedNode \u003d\u003d null) {\n         firstExtractedNode \u003d tempVarNode;\n     }\n     return firstExtractedNode;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6e3eb4f7619179ba6c23db2af7549ef02f588c35": {
      "type": "Ybodychange",
      "commitMessage": "\nChange on 2010/04/15 by john\n\n        Maintain source information in OverloadedMethodResolution.\n\n        R\u003dandrew\n        DELTA\u003d8  (5 added, 1 deleted, 2 changed)\n\nChange on 2010/04/15 by john\n\n        Maintain source information during function inlining.\n\n        R\u003dalan\n        DELTA\u003d104  (73 added, 2 deleted, 29 changed)\n\nChange on 2010/04/15 by john\n\n        Improve LineNumberCheck error message.\n\n        R\u003dnick\n        DELTA\u003d4  (3 added, 0 deleted, 1 changed)\n\nChange on 2010/04/15 by john\n\n        Maintain source information in smart name removal.\n        Enabled Normalize during tests, simplified VAR handling.\n\n        R\u003dantonio\n        DELTA\u003d71  (12 added, 48 deleted, 11 changed)\n\nChange on 2010/04/15 by john\n\n        Maintain source information in InlineGetters.\n\n        R\u003dalan\n        DELTA\u003d8  (7 added, 0 deleted, 1 changed)\n\nChange on 2010/04/15 by alan\n\n        Stops the post data from printing multiple times.\n\n        R\u003djohn\n        DELTA\u003d4  (1 added, 0 deleted, 3 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003dhuwaud\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@188 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/16/10, 10:20 AM",
      "commitName": "6e3eb4f7619179ba6c23db2af7549ef02f588c35",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "4/1/10, 7:32 PM",
      "commitNameOld": "f01925cbf7a39a885e51865208368e861d25a0c1",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 14.62,
      "commitsBetweenForRepo": 18,
      "commitsBetweenForFile": 1,
      "actualSource": "private Node extractExpression(Node expr, Node injectionPoint) {\n    Node parent \u003d expr.getParent();\n    boolean isLhsOfAssignOp \u003d NodeUtil.isAssignmentOp(parent) \u0026\u0026 !NodeUtil.isAssign(parent) \u0026\u0026 parent.getFirstChild() \u003d\u003d expr;\n    Node firstExtractedNode \u003d null;\n    if (isLhsOfAssignOp \u0026\u0026 NodeUtil.isGet(expr)) {\n        for (Node n : expr.children()) {\n            if (n.getType() !\u003d Token.STRING \u0026\u0026 !isConstantName(n, knownConstants)) {\n                Node extractedNode \u003d extractExpression(n, injectionPoint);\n                if (firstExtractedNode \u003d\u003d null) {\n                    firstExtractedNode \u003d extractedNode;\n                }\n            }\n        }\n    }\n    String tempName \u003d getTempConstantValueName();\n    Node replacementValueNode \u003d Node.newString(Token.NAME, tempName).copyInformationFrom(expr);\n    Node tempNameValue;\n    if (isLhsOfAssignOp) {\n        Preconditions.checkState(NodeUtil.isName(expr) || NodeUtil.isGet(expr));\n        Node opNode \u003d new Node(NodeUtil.getOpFromAssignmentOp(parent)).copyInformationFrom(parent);\n        Node rightOperand \u003d parent.getLastChild();\n        parent.setType(Token.ASSIGN);\n        parent.replaceChild(rightOperand, opNode);\n        opNode.addChildToFront(replacementValueNode);\n        opNode.addChildToBack(rightOperand);\n        tempNameValue \u003d expr.cloneTree();\n    } else {\n        parent.replaceChild(expr, replacementValueNode);\n        tempNameValue \u003d expr;\n    }\n    Node tempVarNode \u003d NodeUtil.newVarNode(tempName, tempNameValue);\n    Node injectionPointParent \u003d injectionPoint.getParent();\n    injectionPointParent.addChildBefore(tempVarNode, injectionPoint);\n    if (firstExtractedNode \u003d\u003d null) {\n        firstExtractedNode \u003d tempVarNode;\n    }\n    return firstExtractedNode;\n}",
      "path": "src/com/google/javascript/jscomp/ExpressionDecomposer.java",
      "functionStartLine": 416,
      "functionName": "extractExpression",
      "functionAnnotation": "",
      "functionDoc": "\n@param expr The expression to extract.\n@param injectionPoint The node before which to added the extracted\n    expression.\n@return The extract statement node.\n",
      "diff": "@@ -1,40 +1,38 @@\n private Node extractExpression(Node expr, Node injectionPoint) {\n     Node parent \u003d expr.getParent();\n     boolean isLhsOfAssignOp \u003d NodeUtil.isAssignmentOp(parent) \u0026\u0026 !NodeUtil.isAssign(parent) \u0026\u0026 parent.getFirstChild() \u003d\u003d expr;\n     Node firstExtractedNode \u003d null;\n     if (isLhsOfAssignOp \u0026\u0026 NodeUtil.isGet(expr)) {\n         for (Node n : expr.children()) {\n             if (n.getType() !\u003d Token.STRING \u0026\u0026 !isConstantName(n, knownConstants)) {\n                 Node extractedNode \u003d extractExpression(n, injectionPoint);\n                 if (firstExtractedNode \u003d\u003d null) {\n                     firstExtractedNode \u003d extractedNode;\n                 }\n             }\n         }\n     }\n     String tempName \u003d getTempConstantValueName();\n-    Node replacementValueNode \u003d Node.newString(Token.NAME, tempName);\n+    Node replacementValueNode \u003d Node.newString(Token.NAME, tempName).copyInformationFrom(expr);\n     Node tempNameValue;\n     if (isLhsOfAssignOp) {\n         Preconditions.checkState(NodeUtil.isName(expr) || NodeUtil.isGet(expr));\n         Node opNode \u003d new Node(NodeUtil.getOpFromAssignmentOp(parent)).copyInformationFrom(parent);\n         Node rightOperand \u003d parent.getLastChild();\n         parent.setType(Token.ASSIGN);\n         parent.replaceChild(rightOperand, opNode);\n         opNode.addChildToFront(replacementValueNode);\n         opNode.addChildToBack(rightOperand);\n         tempNameValue \u003d expr.cloneTree();\n     } else {\n         parent.replaceChild(expr, replacementValueNode);\n         tempNameValue \u003d expr;\n     }\n-    Node tempNameNode \u003d Node.newString(Token.NAME, tempName);\n-    tempNameNode.addChildToBack(tempNameValue);\n-    Node tempVarNode \u003d new Node(Token.VAR, tempNameNode);\n+    Node tempVarNode \u003d NodeUtil.newVarNode(tempName, tempNameValue);\n     Node injectionPointParent \u003d injectionPoint.getParent();\n     injectionPointParent.addChildBefore(tempVarNode, injectionPoint);\n     if (firstExtractedNode \u003d\u003d null) {\n         firstExtractedNode \u003d tempVarNode;\n     }\n     return firstExtractedNode;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f01925cbf7a39a885e51865208368e861d25a0c1": {
      "type": "Ybodychange",
      "commitMessage": "Tests for deps generation (Nick)\nR\u003dandrew\n\nFix for decomposing assignment-ops. (john)\nR\u003dalan\nDELTA\u003d159  (127 added, 21 deleted, 11 changed)\n\nRemove unneeded imports. (John)\nR\u003drobert\nDELTA\u003d2  (0 added, 2 deleted, 0 changed)\n\nAutomated rollback of:\nRemove now unneeded checks for label names when inspecting NAME nodes. (Robert)\nR\u003dAlan\nDELTA\u003d6  (4 added, 0 deleted, 2 changed)\n\nAutomated rollback of:\nDon\u0027t use NAME for label names, introduce LABEL_NAME. This improves the correctness of the compiler as many passes don\u0027t distinguish between label names and variable names appropriately. (Robert)\nR\u003dAlan\nDELTA\u003d57  (12 added, 29 deleted, 16 changed)\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003dgydkaf\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@167 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/1/10, 7:32 PM",
      "commitName": "f01925cbf7a39a885e51865208368e861d25a0c1",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "3/25/10, 8:58 AM",
      "commitNameOld": "3ce4716848eb71b6e78a4545a2cc0c27e74a29b3",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 7.44,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "actualSource": "private Node extractExpression(Node expr, Node injectionPoint) {\n    Node parent \u003d expr.getParent();\n    boolean isLhsOfAssignOp \u003d NodeUtil.isAssignmentOp(parent) \u0026\u0026 !NodeUtil.isAssign(parent) \u0026\u0026 parent.getFirstChild() \u003d\u003d expr;\n    Node firstExtractedNode \u003d null;\n    if (isLhsOfAssignOp \u0026\u0026 NodeUtil.isGet(expr)) {\n        for (Node n : expr.children()) {\n            if (n.getType() !\u003d Token.STRING \u0026\u0026 !isConstantName(n, knownConstants)) {\n                Node extractedNode \u003d extractExpression(n, injectionPoint);\n                if (firstExtractedNode \u003d\u003d null) {\n                    firstExtractedNode \u003d extractedNode;\n                }\n            }\n        }\n    }\n    String tempName \u003d getTempConstantValueName();\n    Node replacementValueNode \u003d Node.newString(Token.NAME, tempName);\n    Node tempNameValue;\n    if (isLhsOfAssignOp) {\n        Preconditions.checkState(NodeUtil.isName(expr) || NodeUtil.isGet(expr));\n        Node opNode \u003d new Node(NodeUtil.getOpFromAssignmentOp(parent)).copyInformationFrom(parent);\n        Node rightOperand \u003d parent.getLastChild();\n        parent.setType(Token.ASSIGN);\n        parent.replaceChild(rightOperand, opNode);\n        opNode.addChildToFront(replacementValueNode);\n        opNode.addChildToBack(rightOperand);\n        tempNameValue \u003d expr.cloneTree();\n    } else {\n        parent.replaceChild(expr, replacementValueNode);\n        tempNameValue \u003d expr;\n    }\n    Node tempNameNode \u003d Node.newString(Token.NAME, tempName);\n    tempNameNode.addChildToBack(tempNameValue);\n    Node tempVarNode \u003d new Node(Token.VAR, tempNameNode);\n    Node injectionPointParent \u003d injectionPoint.getParent();\n    injectionPointParent.addChildBefore(tempVarNode, injectionPoint);\n    if (firstExtractedNode \u003d\u003d null) {\n        firstExtractedNode \u003d tempVarNode;\n    }\n    return firstExtractedNode;\n}",
      "path": "src/com/google/javascript/jscomp/ExpressionDecomposer.java",
      "functionStartLine": 415,
      "functionName": "extractExpression",
      "functionAnnotation": "",
      "functionDoc": "\n@param expr The expression to extract.\n@param injectionPoint The node before which to added the extracted\n    expression.\n@return The extract statement node.\n",
      "diff": "@@ -1,24 +1,40 @@\n private Node extractExpression(Node expr, Node injectionPoint) {\n     Node parent \u003d expr.getParent();\n+    boolean isLhsOfAssignOp \u003d NodeUtil.isAssignmentOp(parent) \u0026\u0026 !NodeUtil.isAssign(parent) \u0026\u0026 parent.getFirstChild() \u003d\u003d expr;\n+    Node firstExtractedNode \u003d null;\n+    if (isLhsOfAssignOp \u0026\u0026 NodeUtil.isGet(expr)) {\n+        for (Node n : expr.children()) {\n+            if (n.getType() !\u003d Token.STRING \u0026\u0026 !isConstantName(n, knownConstants)) {\n+                Node extractedNode \u003d extractExpression(n, injectionPoint);\n+                if (firstExtractedNode \u003d\u003d null) {\n+                    firstExtractedNode \u003d extractedNode;\n+                }\n+            }\n+        }\n+    }\n     String tempName \u003d getTempConstantValueName();\n     Node replacementValueNode \u003d Node.newString(Token.NAME, tempName);\n-    parent.replaceChild(expr, replacementValueNode);\n+    Node tempNameValue;\n+    if (isLhsOfAssignOp) {\n+        Preconditions.checkState(NodeUtil.isName(expr) || NodeUtil.isGet(expr));\n+        Node opNode \u003d new Node(NodeUtil.getOpFromAssignmentOp(parent)).copyInformationFrom(parent);\n+        Node rightOperand \u003d parent.getLastChild();\n+        parent.setType(Token.ASSIGN);\n+        parent.replaceChild(rightOperand, opNode);\n+        opNode.addChildToFront(replacementValueNode);\n+        opNode.addChildToBack(rightOperand);\n+        tempNameValue \u003d expr.cloneTree();\n+    } else {\n+        parent.replaceChild(expr, replacementValueNode);\n+        tempNameValue \u003d expr;\n+    }\n     Node tempNameNode \u003d Node.newString(Token.NAME, tempName);\n-    tempNameNode.addChildrenToBack(expr);\n+    tempNameNode.addChildToBack(tempNameValue);\n     Node tempVarNode \u003d new Node(Token.VAR, tempNameNode);\n     Node injectionPointParent \u003d injectionPoint.getParent();\n     injectionPointParent.addChildBefore(tempVarNode, injectionPoint);\n-    if (NodeUtil.isAssignmentOp(parent) \u0026\u0026 !NodeUtil.isAssign(parent)) {\n-        Node gParent \u003d parent.getParent();\n-        Node assignBack \u003d new Node(Token.ASSIGN, expr.cloneTree(), tempNameNode.cloneNode());\n-        if (NodeUtil.isExpressionNode(gParent)) {\n-            gParent.getParent().addChildAfter(NodeUtil.newExpr(assignBack), gParent);\n-        } else {\n-            Node comma \u003d new Node(Token.COMMA);\n-            gParent.replaceChild(parent, comma);\n-            comma.addChildrenToFront(assignBack);\n-            comma.addChildrenToFront(parent);\n-        }\n+    if (firstExtractedNode \u003d\u003d null) {\n+        firstExtractedNode \u003d tempVarNode;\n     }\n-    return tempVarNode;\n+    return firstExtractedNode;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4922461babcc37fb037d2a6db3fcb33fe4127a60": {
      "type": "Ybodychange",
      "commitMessage": "Fix a bug in expression decomposition (Alan)\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@115 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "2/24/10, 4:14 PM",
      "commitName": "4922461babcc37fb037d2a6db3fcb33fe4127a60",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "11/10/09, 11:16 AM",
      "commitNameOld": "78995bf9e88599055a8c4165d89c09dc92a44b30",
      "commitAuthorOld": "nicholas.j.santos@gmail.com",
      "daysBetweenCommits": 106.21,
      "commitsBetweenForRepo": 84,
      "commitsBetweenForFile": 1,
      "actualSource": "private Node extractExpression(Node expr, Node injectionPoint) {\n    Node parent \u003d expr.getParent();\n    String tempName \u003d getTempConstantValueName();\n    Node replacementValueNode \u003d Node.newString(Token.NAME, tempName);\n    parent.replaceChild(expr, replacementValueNode);\n    Node tempNameNode \u003d Node.newString(Token.NAME, tempName);\n    tempNameNode.addChildrenToBack(expr);\n    Node tempVarNode \u003d new Node(Token.VAR, tempNameNode);\n    Node injectionPointParent \u003d injectionPoint.getParent();\n    injectionPointParent.addChildBefore(tempVarNode, injectionPoint);\n    if (NodeUtil.isAssignmentOp(parent) \u0026\u0026 !NodeUtil.isAssign(parent)) {\n        Node gParent \u003d parent.getParent();\n        Node assignBack \u003d new Node(Token.ASSIGN, expr.cloneTree(), tempNameNode.cloneNode());\n        if (NodeUtil.isExpressionNode(gParent)) {\n            gParent.getParent().addChildAfter(NodeUtil.newExpr(assignBack), gParent);\n        } else {\n            Node comma \u003d new Node(Token.COMMA);\n            gParent.replaceChild(parent, comma);\n            comma.addChildrenToFront(assignBack);\n            comma.addChildrenToFront(parent);\n        }\n    }\n    return tempVarNode;\n}",
      "path": "src/com/google/javascript/jscomp/ExpressionDecomposer.java",
      "functionStartLine": 408,
      "functionName": "extractExpression",
      "functionAnnotation": "",
      "functionDoc": "\n@param expr The expression to extract.\n@param injectionPoint The node before which to added the extracted\n    expression.\n@return The extract statement node.\n",
      "diff": "@@ -1,12 +1,24 @@\n private Node extractExpression(Node expr, Node injectionPoint) {\n     Node parent \u003d expr.getParent();\n     String tempName \u003d getTempConstantValueName();\n     Node replacementValueNode \u003d Node.newString(Token.NAME, tempName);\n     parent.replaceChild(expr, replacementValueNode);\n     Node tempNameNode \u003d Node.newString(Token.NAME, tempName);\n     tempNameNode.addChildrenToBack(expr);\n     Node tempVarNode \u003d new Node(Token.VAR, tempNameNode);\n     Node injectionPointParent \u003d injectionPoint.getParent();\n     injectionPointParent.addChildBefore(tempVarNode, injectionPoint);\n+    if (NodeUtil.isAssignmentOp(parent) \u0026\u0026 !NodeUtil.isAssign(parent)) {\n+        Node gParent \u003d parent.getParent();\n+        Node assignBack \u003d new Node(Token.ASSIGN, expr.cloneTree(), tempNameNode.cloneNode());\n+        if (NodeUtil.isExpressionNode(gParent)) {\n+            gParent.getParent().addChildAfter(NodeUtil.newExpr(assignBack), gParent);\n+        } else {\n+            Node comma \u003d new Node(Token.COMMA);\n+            gParent.replaceChild(parent, comma);\n+            comma.addChildrenToFront(assignBack);\n+            comma.addChildrenToFront(parent);\n+        }\n+    }\n     return tempVarNode;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": {
      "type": "Yintroduced",
      "commitMessage": "Initial commit.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/3/09, 3:51 PM",
      "commitName": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "diff": "@@ -0,0 +1,12 @@\n+private Node extractExpression(Node expr, Node injectionPoint) {\n+    Node parent \u003d expr.getParent();\n+    String tempName \u003d getTempConstantValueName();\n+    Node replacementValueNode \u003d Node.newString(Token.NAME, tempName);\n+    parent.replaceChild(expr, replacementValueNode);\n+    Node tempNameNode \u003d Node.newString(Token.NAME, tempName);\n+    tempNameNode.addChildrenToBack(expr);\n+    Node tempVarNode \u003d new Node(Token.VAR, tempNameNode);\n+    Node injectionPointParent \u003d injectionPoint.getParent();\n+    injectionPointParent.addChildBefore(tempVarNode, injectionPoint);\n+    return tempVarNode;\n+}\n\\ No newline at end of file\n",
      "actualSource": "private Node extractExpression(Node expr, Node injectionPoint) {\n    Node parent \u003d expr.getParent();\n    String tempName \u003d getTempConstantValueName();\n    Node replacementValueNode \u003d Node.newString(Token.NAME, tempName);\n    parent.replaceChild(expr, replacementValueNode);\n    Node tempNameNode \u003d Node.newString(Token.NAME, tempName);\n    tempNameNode.addChildrenToBack(expr);\n    Node tempVarNode \u003d new Node(Token.VAR, tempNameNode);\n    Node injectionPointParent \u003d injectionPoint.getParent();\n    injectionPointParent.addChildBefore(tempVarNode, injectionPoint);\n    return tempVarNode;\n}",
      "path": "src/com/google/javascript/jscomp/ExpressionDecomposer.java",
      "functionStartLine": 387,
      "functionName": "extractExpression",
      "functionAnnotation": "",
      "functionDoc": "\n@param expr The expression to extract.\n@param injectionPoint The node before which to added the extracted\n    expression.\n@return The extract statement node.\n"
    }
  }
}