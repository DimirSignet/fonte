{
  "origin": "codeshovel",
  "repositoryName": "Closure-115b",
  "repositoryPath": "/tmp/Closure-115b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FunctionArgumentInjector.java",
  "functionName": "maybeAddTempsForCallArguments",
  "functionId": "maybeAddTempsForCallArguments___fnNode-Node__argMap-Map__String,Node____namesNeedingTemps-Set__String____convention-CodingConvention",
  "sourceFilePath": "src/com/google/javascript/jscomp/FunctionArgumentInjector.java",
  "functionAnnotation": "",
  "functionDoc": "Updates the set of parameter names in set unsafe to include any\narguments from the call site that require aliases.\n\n@param fnNode The FUNCTION node to be inlined.\n@param argMap The argument list for the call to fnNode.\n@param namesNeedingTemps The set of names to update.\n",
  "functionStartLine": 245,
  "functionEndLine": 314,
  "numCommitsSeen": 24,
  "timeTaken": 1320,
  "changeHistory": [
    "ec324a9bb23eb78c76f537f4c4170ba88d542f1c",
    "7c44f228de588387734227a0c08be36d11bf2b17",
    "62aa60c33726dd4e4de412e5880b87ba713b3a9a",
    "9150994b2e41be7d49ca7ab03d3d751f782650ee",
    "78995bf9e88599055a8c4165d89c09dc92a44b30",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3"
  ],
  "changeHistoryShort": {
    "ec324a9bb23eb78c76f537f4c4170ba88d542f1c": "Ybodychange",
    "7c44f228de588387734227a0c08be36d11bf2b17": "Ybodychange",
    "62aa60c33726dd4e4de412e5880b87ba713b3a9a": "Ybodychange",
    "9150994b2e41be7d49ca7ab03d3d751f782650ee": "Ybodychange",
    "78995bf9e88599055a8c4165d89c09dc92a44b30": "Ybodychange",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "ec324a9bb23eb78c76f537f4c4170ba88d542f1c": {
      "type": "Ybodychange",
      "commitMessage": "\nReplace the bulk of the Node.getType() \u003d\u003d Token.XXX calls with\nNode.isXXX calls.\n\nR\u003dnicksantos\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3677\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1582 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/10/11, 8:36 AM",
      "commitName": "ec324a9bb23eb78c76f537f4c4170ba88d542f1c",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "11/9/11, 1:51 PM",
      "commitNameOld": "3d80e1ed8fffbcb5f41b63f64726d9a4c76f209f",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 0.78,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "static void maybeAddTempsForCallArguments(Node fnNode, Map\u003cString, Node\u003e argMap, Set\u003cString\u003e namesNeedingTemps, CodingConvention convention) {\n    if (argMap.isEmpty()) {\n        return;\n    }\n    Preconditions.checkArgument(fnNode.isFunction());\n    Node block \u003d fnNode.getLastChild();\n    Set\u003cString\u003e parameters \u003d argMap.keySet();\n    Set\u003cString\u003e namesAfterSideEffects \u003d findParametersReferencedAfterSideEffect(parameters, block);\n    for (Map.Entry\u003cString, Node\u003e entry : argMap.entrySet()) {\n        String argName \u003d entry.getKey();\n        if (namesNeedingTemps.contains(argName)) {\n            continue;\n        }\n        Node cArg \u003d entry.getValue();\n        boolean safe \u003d true;\n        int references \u003d NodeUtil.getNameReferenceCount(block, argName);\n        if (NodeUtil.mayEffectMutableState(cArg) \u0026\u0026 references \u003e 0) {\n            safe \u003d false;\n        } else if (NodeUtil.mayHaveSideEffects(cArg)) {\n            safe \u003d false;\n        } else if (NodeUtil.canBeSideEffected(cArg) \u0026\u0026 namesAfterSideEffects.contains(argName)) {\n            safe \u003d false;\n        } else if (references \u003e 1) {\n            switch(cArg.getType()) {\n                case Token.NAME:\n                    String name \u003d cArg.getString();\n                    safe \u003d !(convention.isExported(name));\n                    break;\n                case Token.THIS:\n                    safe \u003d true;\n                    break;\n                case Token.STRING:\n                    safe \u003d (cArg.getString().length() \u003c 2);\n                    break;\n                default:\n                    safe \u003d NodeUtil.isImmutableValue(cArg);\n                    break;\n            }\n        }\n        if (!safe) {\n            namesNeedingTemps.add(argName);\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/FunctionArgumentInjector.java",
      "functionStartLine": 245,
      "functionName": "maybeAddTempsForCallArguments",
      "functionAnnotation": "",
      "functionDoc": "Updates the set of parameter names in set unsafe to include any\narguments from the call site that require aliases.\n\n@param fnNode The FUNCTION node to be inlined.\n@param argMap The argument list for the call to fnNode.\n@param namesNeedingTemps The set of names to update.\n",
      "diff": "@@ -1,44 +1,44 @@\n static void maybeAddTempsForCallArguments(Node fnNode, Map\u003cString, Node\u003e argMap, Set\u003cString\u003e namesNeedingTemps, CodingConvention convention) {\n     if (argMap.isEmpty()) {\n         return;\n     }\n-    Preconditions.checkArgument(fnNode.getType() \u003d\u003d Token.FUNCTION);\n+    Preconditions.checkArgument(fnNode.isFunction());\n     Node block \u003d fnNode.getLastChild();\n     Set\u003cString\u003e parameters \u003d argMap.keySet();\n     Set\u003cString\u003e namesAfterSideEffects \u003d findParametersReferencedAfterSideEffect(parameters, block);\n     for (Map.Entry\u003cString, Node\u003e entry : argMap.entrySet()) {\n         String argName \u003d entry.getKey();\n         if (namesNeedingTemps.contains(argName)) {\n             continue;\n         }\n         Node cArg \u003d entry.getValue();\n         boolean safe \u003d true;\n         int references \u003d NodeUtil.getNameReferenceCount(block, argName);\n         if (NodeUtil.mayEffectMutableState(cArg) \u0026\u0026 references \u003e 0) {\n             safe \u003d false;\n         } else if (NodeUtil.mayHaveSideEffects(cArg)) {\n             safe \u003d false;\n         } else if (NodeUtil.canBeSideEffected(cArg) \u0026\u0026 namesAfterSideEffects.contains(argName)) {\n             safe \u003d false;\n         } else if (references \u003e 1) {\n             switch(cArg.getType()) {\n                 case Token.NAME:\n                     String name \u003d cArg.getString();\n                     safe \u003d !(convention.isExported(name));\n                     break;\n                 case Token.THIS:\n                     safe \u003d true;\n                     break;\n                 case Token.STRING:\n                     safe \u003d (cArg.getString().length() \u003c 2);\n                     break;\n                 default:\n                     safe \u003d NodeUtil.isImmutableValue(cArg);\n                     break;\n             }\n         }\n         if (!safe) {\n             namesNeedingTemps.add(argName);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7c44f228de588387734227a0c08be36d11bf2b17": {
      "type": "Ybodychange",
      "commitMessage": "\nFix a couple of classes to handle !0 and !1 as TRUE and FALSE.\n\nR\u003dacleung\nDELTA\u003d118  (82 added, 32 deleted, 4 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d751\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@845 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "3/2/11, 3:41 PM",
      "commitName": "7c44f228de588387734227a0c08be36d11bf2b17",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "2/24/11, 1:58 PM",
      "commitNameOld": "62aa60c33726dd4e4de412e5880b87ba713b3a9a",
      "commitAuthorOld": "ankit@google.com",
      "daysBetweenCommits": 6.07,
      "commitsBetweenForRepo": 28,
      "commitsBetweenForFile": 1,
      "actualSource": "static void maybeAddTempsForCallArguments(Node fnNode, Map\u003cString, Node\u003e argMap, Set\u003cString\u003e namesNeedingTemps, CodingConvention convention) {\n    if (argMap.isEmpty()) {\n        return;\n    }\n    Preconditions.checkArgument(fnNode.getType() \u003d\u003d Token.FUNCTION);\n    Node block \u003d fnNode.getLastChild();\n    Set\u003cString\u003e parameters \u003d argMap.keySet();\n    Set\u003cString\u003e namesAfterSideEffects \u003d findParametersReferencedAfterSideEffect(parameters, block);\n    for (Map.Entry\u003cString, Node\u003e entry : argMap.entrySet()) {\n        String argName \u003d entry.getKey();\n        if (namesNeedingTemps.contains(argName)) {\n            continue;\n        }\n        Node cArg \u003d entry.getValue();\n        boolean safe \u003d true;\n        int references \u003d NodeUtil.getNameReferenceCount(block, argName);\n        if (NodeUtil.mayEffectMutableState(cArg) \u0026\u0026 references \u003e 0) {\n            safe \u003d false;\n        } else if (NodeUtil.mayHaveSideEffects(cArg)) {\n            safe \u003d false;\n        } else if (NodeUtil.canBeSideEffected(cArg) \u0026\u0026 namesAfterSideEffects.contains(argName)) {\n            safe \u003d false;\n        } else if (references \u003e 1) {\n            switch(cArg.getType()) {\n                case Token.NAME:\n                    String name \u003d cArg.getString();\n                    safe \u003d !(convention.isExported(name));\n                    break;\n                case Token.THIS:\n                    safe \u003d true;\n                    break;\n                case Token.STRING:\n                    safe \u003d (cArg.getString().length() \u003c 2);\n                    break;\n                default:\n                    safe \u003d NodeUtil.isImmutableValue(cArg);\n                    break;\n            }\n        }\n        if (!safe) {\n            namesNeedingTemps.add(argName);\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/FunctionArgumentInjector.java",
      "functionStartLine": 205,
      "functionName": "maybeAddTempsForCallArguments",
      "functionAnnotation": "",
      "functionDoc": "Updates the set of parameter names in set unsafe to include any\narguments from the call site that require aliases.\n\n@param fnNode The FUNCTION node to be inlined.\n@param argMap The argument list for the call to fnNode.\n@param namesNeedingTemps The set of names to update.\n",
      "diff": "@@ -1,49 +1,44 @@\n static void maybeAddTempsForCallArguments(Node fnNode, Map\u003cString, Node\u003e argMap, Set\u003cString\u003e namesNeedingTemps, CodingConvention convention) {\n     if (argMap.isEmpty()) {\n         return;\n     }\n     Preconditions.checkArgument(fnNode.getType() \u003d\u003d Token.FUNCTION);\n     Node block \u003d fnNode.getLastChild();\n     Set\u003cString\u003e parameters \u003d argMap.keySet();\n     Set\u003cString\u003e namesAfterSideEffects \u003d findParametersReferencedAfterSideEffect(parameters, block);\n     for (Map.Entry\u003cString, Node\u003e entry : argMap.entrySet()) {\n         String argName \u003d entry.getKey();\n         if (namesNeedingTemps.contains(argName)) {\n             continue;\n         }\n         Node cArg \u003d entry.getValue();\n         boolean safe \u003d true;\n         int references \u003d NodeUtil.getNameReferenceCount(block, argName);\n         if (NodeUtil.mayEffectMutableState(cArg) \u0026\u0026 references \u003e 0) {\n             safe \u003d false;\n         } else if (NodeUtil.mayHaveSideEffects(cArg)) {\n             safe \u003d false;\n         } else if (NodeUtil.canBeSideEffected(cArg) \u0026\u0026 namesAfterSideEffects.contains(argName)) {\n             safe \u003d false;\n         } else if (references \u003e 1) {\n             switch(cArg.getType()) {\n                 case Token.NAME:\n                     String name \u003d cArg.getString();\n                     safe \u003d !(convention.isExported(name));\n                     break;\n-                case Token.NULL:\n-                case Token.VOID:\n                 case Token.THIS:\n-                case Token.FALSE:\n-                case Token.TRUE:\n-                case Token.NUMBER:\n                     safe \u003d true;\n                     break;\n                 case Token.STRING:\n                     safe \u003d (cArg.getString().length() \u003c 2);\n                     break;\n                 default:\n-                    safe \u003d false;\n+                    safe \u003d NodeUtil.isImmutableValue(cArg);\n                     break;\n             }\n         }\n         if (!safe) {\n             namesNeedingTemps.add(argName);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "62aa60c33726dd4e4de412e5880b87ba713b3a9a": {
      "type": "Ybodychange",
      "commitMessage": "\nAutomated g4 rollback.\n\n*** Reason for rollback ***\n\nBreaks gmail\n\n*** Original change description ***\n\nFix a couple of classes to handle !0 and !1 as TRUE and FALSE.\n\nR\u003djohnlenz\nDELTA\u003d114  (32 added, 78 deleted, 4 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d668\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@817 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "2/24/11, 1:58 PM",
      "commitName": "62aa60c33726dd4e4de412e5880b87ba713b3a9a",
      "commitAuthor": "ankit@google.com",
      "commitDateOld": "2/24/11, 12:11 PM",
      "commitNameOld": "9150994b2e41be7d49ca7ab03d3d751f782650ee",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 0.07,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "static void maybeAddTempsForCallArguments(Node fnNode, Map\u003cString, Node\u003e argMap, Set\u003cString\u003e namesNeedingTemps, CodingConvention convention) {\n    if (argMap.isEmpty()) {\n        return;\n    }\n    Preconditions.checkArgument(fnNode.getType() \u003d\u003d Token.FUNCTION);\n    Node block \u003d fnNode.getLastChild();\n    Set\u003cString\u003e parameters \u003d argMap.keySet();\n    Set\u003cString\u003e namesAfterSideEffects \u003d findParametersReferencedAfterSideEffect(parameters, block);\n    for (Map.Entry\u003cString, Node\u003e entry : argMap.entrySet()) {\n        String argName \u003d entry.getKey();\n        if (namesNeedingTemps.contains(argName)) {\n            continue;\n        }\n        Node cArg \u003d entry.getValue();\n        boolean safe \u003d true;\n        int references \u003d NodeUtil.getNameReferenceCount(block, argName);\n        if (NodeUtil.mayEffectMutableState(cArg) \u0026\u0026 references \u003e 0) {\n            safe \u003d false;\n        } else if (NodeUtil.mayHaveSideEffects(cArg)) {\n            safe \u003d false;\n        } else if (NodeUtil.canBeSideEffected(cArg) \u0026\u0026 namesAfterSideEffects.contains(argName)) {\n            safe \u003d false;\n        } else if (references \u003e 1) {\n            switch(cArg.getType()) {\n                case Token.NAME:\n                    String name \u003d cArg.getString();\n                    safe \u003d !(convention.isExported(name));\n                    break;\n                case Token.NULL:\n                case Token.VOID:\n                case Token.THIS:\n                case Token.FALSE:\n                case Token.TRUE:\n                case Token.NUMBER:\n                    safe \u003d true;\n                    break;\n                case Token.STRING:\n                    safe \u003d (cArg.getString().length() \u003c 2);\n                    break;\n                default:\n                    safe \u003d false;\n                    break;\n            }\n        }\n        if (!safe) {\n            namesNeedingTemps.add(argName);\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/FunctionArgumentInjector.java",
      "functionStartLine": 205,
      "functionName": "maybeAddTempsForCallArguments",
      "functionAnnotation": "",
      "functionDoc": "Updates the set of parameter names in set unsafe to include any\narguments from the call site that require aliases.\n\n@param fnNode The FUNCTION node to be inlined.\n@param argMap The argument list for the call to fnNode.\n@param namesNeedingTemps The set of names to update.\n",
      "diff": "@@ -1,44 +1,49 @@\n static void maybeAddTempsForCallArguments(Node fnNode, Map\u003cString, Node\u003e argMap, Set\u003cString\u003e namesNeedingTemps, CodingConvention convention) {\n     if (argMap.isEmpty()) {\n         return;\n     }\n     Preconditions.checkArgument(fnNode.getType() \u003d\u003d Token.FUNCTION);\n     Node block \u003d fnNode.getLastChild();\n     Set\u003cString\u003e parameters \u003d argMap.keySet();\n     Set\u003cString\u003e namesAfterSideEffects \u003d findParametersReferencedAfterSideEffect(parameters, block);\n     for (Map.Entry\u003cString, Node\u003e entry : argMap.entrySet()) {\n         String argName \u003d entry.getKey();\n         if (namesNeedingTemps.contains(argName)) {\n             continue;\n         }\n         Node cArg \u003d entry.getValue();\n         boolean safe \u003d true;\n         int references \u003d NodeUtil.getNameReferenceCount(block, argName);\n         if (NodeUtil.mayEffectMutableState(cArg) \u0026\u0026 references \u003e 0) {\n             safe \u003d false;\n         } else if (NodeUtil.mayHaveSideEffects(cArg)) {\n             safe \u003d false;\n         } else if (NodeUtil.canBeSideEffected(cArg) \u0026\u0026 namesAfterSideEffects.contains(argName)) {\n             safe \u003d false;\n         } else if (references \u003e 1) {\n             switch(cArg.getType()) {\n                 case Token.NAME:\n                     String name \u003d cArg.getString();\n                     safe \u003d !(convention.isExported(name));\n                     break;\n+                case Token.NULL:\n+                case Token.VOID:\n                 case Token.THIS:\n+                case Token.FALSE:\n+                case Token.TRUE:\n+                case Token.NUMBER:\n                     safe \u003d true;\n                     break;\n                 case Token.STRING:\n                     safe \u003d (cArg.getString().length() \u003c 2);\n                     break;\n                 default:\n-                    safe \u003d NodeUtil.isImmutableValue(cArg);\n+                    safe \u003d false;\n                     break;\n             }\n         }\n         if (!safe) {\n             namesNeedingTemps.add(argName);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9150994b2e41be7d49ca7ab03d3d751f782650ee": {
      "type": "Ybodychange",
      "commitMessage": "\nFix a couple of classes to handle !0 and !1 as TRUE and FALSE.\n\nR\u003dacleung\nDELTA\u003d114  (78 added, 32 deleted, 4 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d665\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@814 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "2/24/11, 12:11 PM",
      "commitName": "9150994b2e41be7d49ca7ab03d3d751f782650ee",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "11/11/10, 9:42 PM",
      "commitNameOld": "df223efd38c514d584f00d076488ab9a02011492",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 104.6,
      "commitsBetweenForRepo": 257,
      "commitsBetweenForFile": 1,
      "actualSource": "static void maybeAddTempsForCallArguments(Node fnNode, Map\u003cString, Node\u003e argMap, Set\u003cString\u003e namesNeedingTemps, CodingConvention convention) {\n    if (argMap.isEmpty()) {\n        return;\n    }\n    Preconditions.checkArgument(fnNode.getType() \u003d\u003d Token.FUNCTION);\n    Node block \u003d fnNode.getLastChild();\n    Set\u003cString\u003e parameters \u003d argMap.keySet();\n    Set\u003cString\u003e namesAfterSideEffects \u003d findParametersReferencedAfterSideEffect(parameters, block);\n    for (Map.Entry\u003cString, Node\u003e entry : argMap.entrySet()) {\n        String argName \u003d entry.getKey();\n        if (namesNeedingTemps.contains(argName)) {\n            continue;\n        }\n        Node cArg \u003d entry.getValue();\n        boolean safe \u003d true;\n        int references \u003d NodeUtil.getNameReferenceCount(block, argName);\n        if (NodeUtil.mayEffectMutableState(cArg) \u0026\u0026 references \u003e 0) {\n            safe \u003d false;\n        } else if (NodeUtil.mayHaveSideEffects(cArg)) {\n            safe \u003d false;\n        } else if (NodeUtil.canBeSideEffected(cArg) \u0026\u0026 namesAfterSideEffects.contains(argName)) {\n            safe \u003d false;\n        } else if (references \u003e 1) {\n            switch(cArg.getType()) {\n                case Token.NAME:\n                    String name \u003d cArg.getString();\n                    safe \u003d !(convention.isExported(name));\n                    break;\n                case Token.THIS:\n                    safe \u003d true;\n                    break;\n                case Token.STRING:\n                    safe \u003d (cArg.getString().length() \u003c 2);\n                    break;\n                default:\n                    safe \u003d NodeUtil.isImmutableValue(cArg);\n                    break;\n            }\n        }\n        if (!safe) {\n            namesNeedingTemps.add(argName);\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/FunctionArgumentInjector.java",
      "functionStartLine": 205,
      "functionName": "maybeAddTempsForCallArguments",
      "functionAnnotation": "",
      "functionDoc": "Updates the set of parameter names in set unsafe to include any\narguments from the call site that require aliases.\n\n@param fnNode The FUNCTION node to be inlined.\n@param argMap The argument list for the call to fnNode.\n@param namesNeedingTemps The set of names to update.\n",
      "diff": "@@ -1,49 +1,44 @@\n static void maybeAddTempsForCallArguments(Node fnNode, Map\u003cString, Node\u003e argMap, Set\u003cString\u003e namesNeedingTemps, CodingConvention convention) {\n     if (argMap.isEmpty()) {\n         return;\n     }\n     Preconditions.checkArgument(fnNode.getType() \u003d\u003d Token.FUNCTION);\n     Node block \u003d fnNode.getLastChild();\n     Set\u003cString\u003e parameters \u003d argMap.keySet();\n     Set\u003cString\u003e namesAfterSideEffects \u003d findParametersReferencedAfterSideEffect(parameters, block);\n     for (Map.Entry\u003cString, Node\u003e entry : argMap.entrySet()) {\n         String argName \u003d entry.getKey();\n         if (namesNeedingTemps.contains(argName)) {\n             continue;\n         }\n         Node cArg \u003d entry.getValue();\n         boolean safe \u003d true;\n         int references \u003d NodeUtil.getNameReferenceCount(block, argName);\n         if (NodeUtil.mayEffectMutableState(cArg) \u0026\u0026 references \u003e 0) {\n             safe \u003d false;\n         } else if (NodeUtil.mayHaveSideEffects(cArg)) {\n             safe \u003d false;\n         } else if (NodeUtil.canBeSideEffected(cArg) \u0026\u0026 namesAfterSideEffects.contains(argName)) {\n             safe \u003d false;\n         } else if (references \u003e 1) {\n             switch(cArg.getType()) {\n                 case Token.NAME:\n                     String name \u003d cArg.getString();\n                     safe \u003d !(convention.isExported(name));\n                     break;\n-                case Token.NULL:\n-                case Token.VOID:\n                 case Token.THIS:\n-                case Token.FALSE:\n-                case Token.TRUE:\n-                case Token.NUMBER:\n                     safe \u003d true;\n                     break;\n                 case Token.STRING:\n                     safe \u003d (cArg.getString().length() \u003c 2);\n                     break;\n                 default:\n-                    safe \u003d false;\n+                    safe \u003d NodeUtil.isImmutableValue(cArg);\n                     break;\n             }\n         }\n         if (!safe) {\n             namesNeedingTemps.add(argName);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "78995bf9e88599055a8c4165d89c09dc92a44b30": {
      "type": "Ybodychange",
      "commitMessage": "Fix synthesis of vars in DEFAULT mode.\nBetter variable inlining\nBetter function inlining\nAssorted bug fixes\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@6 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/10/09, 11:16 AM",
      "commitName": "78995bf9e88599055a8c4165d89c09dc92a44b30",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "commitDateOld": "11/3/09, 3:51 PM",
      "commitNameOld": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthorOld": "nicholas.j.santos@gmail.com",
      "daysBetweenCommits": 6.81,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "static void maybeAddTempsForCallArguments(Node fnNode, Map\u003cString, Node\u003e argMap, Set\u003cString\u003e namesNeedingTemps, CodingConvention convention) {\n    if (argMap.isEmpty()) {\n        return;\n    }\n    Preconditions.checkArgument(fnNode.getType() \u003d\u003d Token.FUNCTION);\n    Node block \u003d fnNode.getLastChild();\n    Set\u003cString\u003e parameters \u003d argMap.keySet();\n    Set\u003cString\u003e namesAfterSideEffects \u003d findParametersReferencedAfterSideEffect(parameters, block);\n    for (Map.Entry\u003cString, Node\u003e entry : argMap.entrySet()) {\n        String argName \u003d entry.getKey();\n        if (namesNeedingTemps.contains(argName)) {\n            continue;\n        }\n        Node cArg \u003d entry.getValue();\n        boolean safe \u003d true;\n        int references \u003d NodeUtil.getNameReferenceCount(block, argName);\n        if (NodeUtil.mayEffectMutableState(cArg) \u0026\u0026 references \u003e 0) {\n            safe \u003d false;\n        } else if (NodeUtil.mayHaveSideEffects(cArg)) {\n            safe \u003d false;\n        } else if (NodeUtil.canBeSideEffected(cArg) \u0026\u0026 namesAfterSideEffects.contains(argName)) {\n            safe \u003d false;\n        } else if (references \u003e 1) {\n            switch(cArg.getType()) {\n                case Token.NAME:\n                    String name \u003d cArg.getString();\n                    safe \u003d !(convention.isExported(name));\n                    break;\n                case Token.NULL:\n                case Token.VOID:\n                case Token.THIS:\n                case Token.FALSE:\n                case Token.TRUE:\n                case Token.NUMBER:\n                    safe \u003d true;\n                    break;\n                case Token.STRING:\n                    safe \u003d (cArg.getString().length() \u003c 2);\n                    break;\n                default:\n                    safe \u003d false;\n                    break;\n            }\n        }\n        if (!safe) {\n            namesNeedingTemps.add(argName);\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/FunctionArgumentInjector.java",
      "functionStartLine": 204,
      "functionName": "maybeAddTempsForCallArguments",
      "functionAnnotation": "",
      "functionDoc": "Updates the set of parameter names in set unsafe to include any\narguments from the call site that require aliases.\n\n@param fnNode The FUNCTION node to be inlined.\n@param argMap The argument list for the call to fnNode.\n@param namesNeedingTemps The set of names to update.\n",
      "diff": "@@ -1,49 +1,49 @@\n static void maybeAddTempsForCallArguments(Node fnNode, Map\u003cString, Node\u003e argMap, Set\u003cString\u003e namesNeedingTemps, CodingConvention convention) {\n     if (argMap.isEmpty()) {\n         return;\n     }\n     Preconditions.checkArgument(fnNode.getType() \u003d\u003d Token.FUNCTION);\n     Node block \u003d fnNode.getLastChild();\n     Set\u003cString\u003e parameters \u003d argMap.keySet();\n     Set\u003cString\u003e namesAfterSideEffects \u003d findParametersReferencedAfterSideEffect(parameters, block);\n     for (Map.Entry\u003cString, Node\u003e entry : argMap.entrySet()) {\n         String argName \u003d entry.getKey();\n         if (namesNeedingTemps.contains(argName)) {\n             continue;\n         }\n         Node cArg \u003d entry.getValue();\n         boolean safe \u003d true;\n         int references \u003d NodeUtil.getNameReferenceCount(block, argName);\n         if (NodeUtil.mayEffectMutableState(cArg) \u0026\u0026 references \u003e 0) {\n             safe \u003d false;\n         } else if (NodeUtil.mayHaveSideEffects(cArg)) {\n             safe \u003d false;\n-        } else if (canBeSideEffected(cArg) \u0026\u0026 namesAfterSideEffects.contains(argName)) {\n+        } else if (NodeUtil.canBeSideEffected(cArg) \u0026\u0026 namesAfterSideEffects.contains(argName)) {\n             safe \u003d false;\n         } else if (references \u003e 1) {\n             switch(cArg.getType()) {\n                 case Token.NAME:\n                     String name \u003d cArg.getString();\n                     safe \u003d !(convention.isExported(name));\n                     break;\n                 case Token.NULL:\n                 case Token.VOID:\n                 case Token.THIS:\n                 case Token.FALSE:\n                 case Token.TRUE:\n                 case Token.NUMBER:\n                     safe \u003d true;\n                     break;\n                 case Token.STRING:\n                     safe \u003d (cArg.getString().length() \u003c 2);\n                     break;\n                 default:\n                     safe \u003d false;\n                     break;\n             }\n         }\n         if (!safe) {\n             namesNeedingTemps.add(argName);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": {
      "type": "Yintroduced",
      "commitMessage": "Initial commit.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/3/09, 3:51 PM",
      "commitName": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "diff": "@@ -0,0 +1,49 @@\n+static void maybeAddTempsForCallArguments(Node fnNode, Map\u003cString, Node\u003e argMap, Set\u003cString\u003e namesNeedingTemps, CodingConvention convention) {\n+    if (argMap.isEmpty()) {\n+        return;\n+    }\n+    Preconditions.checkArgument(fnNode.getType() \u003d\u003d Token.FUNCTION);\n+    Node block \u003d fnNode.getLastChild();\n+    Set\u003cString\u003e parameters \u003d argMap.keySet();\n+    Set\u003cString\u003e namesAfterSideEffects \u003d findParametersReferencedAfterSideEffect(parameters, block);\n+    for (Map.Entry\u003cString, Node\u003e entry : argMap.entrySet()) {\n+        String argName \u003d entry.getKey();\n+        if (namesNeedingTemps.contains(argName)) {\n+            continue;\n+        }\n+        Node cArg \u003d entry.getValue();\n+        boolean safe \u003d true;\n+        int references \u003d NodeUtil.getNameReferenceCount(block, argName);\n+        if (NodeUtil.mayEffectMutableState(cArg) \u0026\u0026 references \u003e 0) {\n+            safe \u003d false;\n+        } else if (NodeUtil.mayHaveSideEffects(cArg)) {\n+            safe \u003d false;\n+        } else if (canBeSideEffected(cArg) \u0026\u0026 namesAfterSideEffects.contains(argName)) {\n+            safe \u003d false;\n+        } else if (references \u003e 1) {\n+            switch(cArg.getType()) {\n+                case Token.NAME:\n+                    String name \u003d cArg.getString();\n+                    safe \u003d !(convention.isExported(name));\n+                    break;\n+                case Token.NULL:\n+                case Token.VOID:\n+                case Token.THIS:\n+                case Token.FALSE:\n+                case Token.TRUE:\n+                case Token.NUMBER:\n+                    safe \u003d true;\n+                    break;\n+                case Token.STRING:\n+                    safe \u003d (cArg.getString().length() \u003c 2);\n+                    break;\n+                default:\n+                    safe \u003d false;\n+                    break;\n+            }\n+        }\n+        if (!safe) {\n+            namesNeedingTemps.add(argName);\n+        }\n+    }\n+}\n\\ No newline at end of file\n",
      "actualSource": "static void maybeAddTempsForCallArguments(Node fnNode, Map\u003cString, Node\u003e argMap, Set\u003cString\u003e namesNeedingTemps, CodingConvention convention) {\n    if (argMap.isEmpty()) {\n        return;\n    }\n    Preconditions.checkArgument(fnNode.getType() \u003d\u003d Token.FUNCTION);\n    Node block \u003d fnNode.getLastChild();\n    Set\u003cString\u003e parameters \u003d argMap.keySet();\n    Set\u003cString\u003e namesAfterSideEffects \u003d findParametersReferencedAfterSideEffect(parameters, block);\n    for (Map.Entry\u003cString, Node\u003e entry : argMap.entrySet()) {\n        String argName \u003d entry.getKey();\n        if (namesNeedingTemps.contains(argName)) {\n            continue;\n        }\n        Node cArg \u003d entry.getValue();\n        boolean safe \u003d true;\n        int references \u003d NodeUtil.getNameReferenceCount(block, argName);\n        if (NodeUtil.mayEffectMutableState(cArg) \u0026\u0026 references \u003e 0) {\n            safe \u003d false;\n        } else if (NodeUtil.mayHaveSideEffects(cArg)) {\n            safe \u003d false;\n        } else if (canBeSideEffected(cArg) \u0026\u0026 namesAfterSideEffects.contains(argName)) {\n            safe \u003d false;\n        } else if (references \u003e 1) {\n            switch(cArg.getType()) {\n                case Token.NAME:\n                    String name \u003d cArg.getString();\n                    safe \u003d !(convention.isExported(name));\n                    break;\n                case Token.NULL:\n                case Token.VOID:\n                case Token.THIS:\n                case Token.FALSE:\n                case Token.TRUE:\n                case Token.NUMBER:\n                    safe \u003d true;\n                    break;\n                case Token.STRING:\n                    safe \u003d (cArg.getString().length() \u003c 2);\n                    break;\n                default:\n                    safe \u003d false;\n                    break;\n            }\n        }\n        if (!safe) {\n            namesNeedingTemps.add(argName);\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/FunctionArgumentInjector.java",
      "functionStartLine": 204,
      "functionName": "maybeAddTempsForCallArguments",
      "functionAnnotation": "",
      "functionDoc": "Updates the set of parameter names in set unsafe to include any\narguments from the call site that require aliases.\n\n@param fnNode The FUNCTION node to be inlined.\n@param argMap The argument list for the call to fnNode.\n@param namesNeedingTemps The set of names to update.\n"
    }
  }
}