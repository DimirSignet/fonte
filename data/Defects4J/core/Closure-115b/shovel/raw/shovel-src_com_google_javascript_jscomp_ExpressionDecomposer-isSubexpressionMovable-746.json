{
  "origin": "codeshovel",
  "repositoryName": "Closure-115b",
  "repositoryPath": "/tmp/Closure-115b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ExpressionDecomposer.java",
  "functionName": "isSubexpressionMovable",
  "functionId": "isSubexpressionMovable___expressionRoot-Node__subExpression-Node",
  "sourceFilePath": "src/com/google/javascript/jscomp/ExpressionDecomposer.java",
  "functionAnnotation": "",
  "functionDoc": "Walk the AST from the call site to the expression root and verify that\nthe portions of the expression that are evaluated before the call are:\n1) Unaffected by the the side-effects, if any, of the call.\n2) That there are no side-effects, that may influence the call.\n\nFor example, if x has side-effects:\n  a \u003d 1 + x();\nthe call to x can be moved because \"a\" final value of a can not be\ninfluenced by x(), but in:\n  a \u003d b + x();\nthe call to x can not be moved because the value of b may be modified\nby the call to x.\n\nIf x is without side-effects in:\n  a \u003d b + x();\nthe call to x can be moved, but in:\n  a \u003d (b.foo \u003d c) + x();\nthe call to x can not be moved because the value of b.foo may be referenced\nby x().  Note: this is true even if b is a local variable; the object that\nb refers to may have a global alias.\n\n@return UNDECOMPOSABLE if the expression can not be moved, DECOMPOSABLE if\ndecomposition is required before the expression can be moved, otherwise\nMOVABLE.\n",
  "functionStartLine": 746,
  "functionEndLine": 836,
  "numCommitsSeen": 25,
  "timeTaken": 1984,
  "changeHistory": [
    "f0ff2971eca336e950929b3ee0d80155338bb1dd",
    "58fdad08ba7f8e24ac48a006f1e2989bda46b9a9",
    "70a5626922ea7e8c98747e22b6986638ba38fadc",
    "ec324a9bb23eb78c76f537f4c4170ba88d542f1c",
    "3ce4716848eb71b6e78a4545a2cc0c27e74a29b3",
    "78995bf9e88599055a8c4165d89c09dc92a44b30",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3"
  ],
  "changeHistoryShort": {
    "f0ff2971eca336e950929b3ee0d80155338bb1dd": "Ybodychange",
    "58fdad08ba7f8e24ac48a006f1e2989bda46b9a9": "Ybodychange",
    "70a5626922ea7e8c98747e22b6986638ba38fadc": "Ymultichange(Ybodychange,Ydocchange)",
    "ec324a9bb23eb78c76f537f4c4170ba88d542f1c": "Ybodychange",
    "3ce4716848eb71b6e78a4545a2cc0c27e74a29b3": "Yformatchange",
    "78995bf9e88599055a8c4165d89c09dc92a44b30": "Ymultichange(Yreturntypechange,Ybodychange,Ydocchange)",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "f0ff2971eca336e950929b3ee0d80155338bb1dd": {
      "type": "Ybodychange",
      "commitMessage": "\nCruft removal: remove some unused locals and parameters.\n\nR\u003ddimvar\nDELTA\u003d336 (6 added, 108 deleted, 222 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d6092\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2447 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "1/8/13, 12:15 PM",
      "commitName": "f0ff2971eca336e950929b3ee0d80155338bb1dd",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "9/20/12, 11:55 AM",
      "commitNameOld": "58fdad08ba7f8e24ac48a006f1e2989bda46b9a9",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 110.06,
      "commitsBetweenForRepo": 226,
      "commitsBetweenForFile": 1,
      "actualSource": "private DecompositionType isSubexpressionMovable(Node expressionRoot, Node subExpression) {\n    boolean requiresDecomposition \u003d false;\n    boolean seenSideEffects \u003d NodeUtil.mayHaveSideEffects(subExpression, compiler);\n    Node child \u003d subExpression;\n    for (Node parent : child.getAncestors()) {\n        if (parent \u003d\u003d expressionRoot) {\n            return requiresDecomposition ? DecompositionType.DECOMPOSABLE : DecompositionType.MOVABLE;\n        }\n        if (isConditionalOp(parent)) {\n            if (child !\u003d parent.getFirstChild()) {\n                requiresDecomposition \u003d true;\n            }\n        } else {\n            if (isSafeAssign(parent, seenSideEffects)) {\n            } else {\n                for (Node n : parent.children()) {\n                    if (n \u003d\u003d child) {\n                        break;\n                    }\n                    if (isExpressionTreeUnsafe(n, seenSideEffects)) {\n                        seenSideEffects \u003d true;\n                        requiresDecomposition \u003d true;\n                    }\n                }\n                Node first \u003d parent.getFirstChild();\n                if (requiresDecomposition \u0026\u0026 parent.isCall() \u0026\u0026 NodeUtil.isGet(first)) {\n                    if (maybeExternMethod(first)) {\n                        return DecompositionType.UNDECOMPOSABLE;\n                    } else {\n                        return DecompositionType.DECOMPOSABLE;\n                    }\n                }\n            }\n        }\n        child \u003d parent;\n    }\n    throw new IllegalStateException(\"Unexpected.\");\n}",
      "path": "src/com/google/javascript/jscomp/ExpressionDecomposer.java",
      "functionStartLine": 746,
      "functionName": "isSubexpressionMovable",
      "functionAnnotation": "",
      "functionDoc": "Walk the AST from the call site to the expression root and verify that\nthe portions of the expression that are evaluated before the call are:\n1) Unaffected by the the side-effects, if any, of the call.\n2) That there are no side-effects, that may influence the call.\n\nFor example, if x has side-effects:\n  a \u003d 1 + x();\nthe call to x can be moved because \"a\" final value of a can not be\ninfluenced by x(), but in:\n  a \u003d b + x();\nthe call to x can not be moved because the value of b may be modified\nby the call to x.\n\nIf x is without side-effects in:\n  a \u003d b + x();\nthe call to x can be moved, but in:\n  a \u003d (b.foo \u003d c) + x();\nthe call to x can not be moved because the value of b.foo may be referenced\nby x().  Note: this is true even if b is a local variable; the object that\nb refers to may have a global alias.\n\n@return UNDECOMPOSABLE if the expression can not be moved, DECOMPOSABLE if\ndecomposition is required before the expression can be moved, otherwise\nMOVABLE.\n",
      "diff": "@@ -1,39 +1,38 @@\n private DecompositionType isSubexpressionMovable(Node expressionRoot, Node subExpression) {\n     boolean requiresDecomposition \u003d false;\n     boolean seenSideEffects \u003d NodeUtil.mayHaveSideEffects(subExpression, compiler);\n     Node child \u003d subExpression;\n     for (Node parent : child.getAncestors()) {\n         if (parent \u003d\u003d expressionRoot) {\n             return requiresDecomposition ? DecompositionType.DECOMPOSABLE : DecompositionType.MOVABLE;\n         }\n-        int parentType \u003d parent.getType();\n         if (isConditionalOp(parent)) {\n             if (child !\u003d parent.getFirstChild()) {\n                 requiresDecomposition \u003d true;\n             }\n         } else {\n             if (isSafeAssign(parent, seenSideEffects)) {\n             } else {\n                 for (Node n : parent.children()) {\n                     if (n \u003d\u003d child) {\n                         break;\n                     }\n                     if (isExpressionTreeUnsafe(n, seenSideEffects)) {\n                         seenSideEffects \u003d true;\n                         requiresDecomposition \u003d true;\n                     }\n                 }\n                 Node first \u003d parent.getFirstChild();\n                 if (requiresDecomposition \u0026\u0026 parent.isCall() \u0026\u0026 NodeUtil.isGet(first)) {\n                     if (maybeExternMethod(first)) {\n                         return DecompositionType.UNDECOMPOSABLE;\n                     } else {\n                         return DecompositionType.DECOMPOSABLE;\n                     }\n                 }\n             }\n         }\n         child \u003d parent;\n     }\n     throw new IllegalStateException(\"Unexpected.\");\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "58fdad08ba7f8e24ac48a006f1e2989bda46b9a9": {
      "type": "Ybodychange",
      "commitMessage": "\nSome NodeUtil cleanup, narrow the public interface, remove some unused\nfunctions, and some other cleanup.\n\nR\u003dnicksantos\nDELTA\u003d130  (40 added, 50 deleted, 40 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d5519\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2202 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "9/20/12, 11:55 AM",
      "commitName": "58fdad08ba7f8e24ac48a006f1e2989bda46b9a9",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "6/18/12, 9:58 AM",
      "commitNameOld": "98a487531ce3d6555851398daead0471b5932774",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 94.08,
      "commitsBetweenForRepo": 137,
      "commitsBetweenForFile": 1,
      "actualSource": "private DecompositionType isSubexpressionMovable(Node expressionRoot, Node subExpression) {\n    boolean requiresDecomposition \u003d false;\n    boolean seenSideEffects \u003d NodeUtil.mayHaveSideEffects(subExpression, compiler);\n    Node child \u003d subExpression;\n    for (Node parent : child.getAncestors()) {\n        if (parent \u003d\u003d expressionRoot) {\n            return requiresDecomposition ? DecompositionType.DECOMPOSABLE : DecompositionType.MOVABLE;\n        }\n        int parentType \u003d parent.getType();\n        if (isConditionalOp(parent)) {\n            if (child !\u003d parent.getFirstChild()) {\n                requiresDecomposition \u003d true;\n            }\n        } else {\n            if (isSafeAssign(parent, seenSideEffects)) {\n            } else {\n                for (Node n : parent.children()) {\n                    if (n \u003d\u003d child) {\n                        break;\n                    }\n                    if (isExpressionTreeUnsafe(n, seenSideEffects)) {\n                        seenSideEffects \u003d true;\n                        requiresDecomposition \u003d true;\n                    }\n                }\n                Node first \u003d parent.getFirstChild();\n                if (requiresDecomposition \u0026\u0026 parent.isCall() \u0026\u0026 NodeUtil.isGet(first)) {\n                    if (maybeExternMethod(first)) {\n                        return DecompositionType.UNDECOMPOSABLE;\n                    } else {\n                        return DecompositionType.DECOMPOSABLE;\n                    }\n                }\n            }\n        }\n        child \u003d parent;\n    }\n    throw new IllegalStateException(\"Unexpected.\");\n}",
      "path": "src/com/google/javascript/jscomp/ExpressionDecomposer.java",
      "functionStartLine": 747,
      "functionName": "isSubexpressionMovable",
      "functionAnnotation": "",
      "functionDoc": "Walk the AST from the call site to the expression root and verify that\nthe portions of the expression that are evaluated before the call are:\n1) Unaffected by the the side-effects, if any, of the call.\n2) That there are no side-effects, that may influence the call.\n\nFor example, if x has side-effects:\n  a \u003d 1 + x();\nthe call to x can be moved because \"a\" final value of a can not be\ninfluenced by x(), but in:\n  a \u003d b + x();\nthe call to x can not be moved because the value of b may be modified\nby the call to x.\n\nIf x is without side-effects in:\n  a \u003d b + x();\nthe call to x can be moved, but in:\n  a \u003d (b.foo \u003d c) + x();\nthe call to x can not be moved because the value of b.foo may be referenced\nby x().  Note: this is true even if b is a local variable; the object that\nb refers to may have a global alias.\n\n@return UNDECOMPOSABLE if the expression can not be moved, DECOMPOSABLE if\ndecomposition is required before the expression can be moved, otherwise\nMOVABLE.\n",
      "diff": "@@ -1,39 +1,39 @@\n private DecompositionType isSubexpressionMovable(Node expressionRoot, Node subExpression) {\n     boolean requiresDecomposition \u003d false;\n-    boolean seenSideEffects \u003d NodeUtil.mayHaveSideEffects(subExpression);\n+    boolean seenSideEffects \u003d NodeUtil.mayHaveSideEffects(subExpression, compiler);\n     Node child \u003d subExpression;\n     for (Node parent : child.getAncestors()) {\n         if (parent \u003d\u003d expressionRoot) {\n             return requiresDecomposition ? DecompositionType.DECOMPOSABLE : DecompositionType.MOVABLE;\n         }\n         int parentType \u003d parent.getType();\n         if (isConditionalOp(parent)) {\n             if (child !\u003d parent.getFirstChild()) {\n                 requiresDecomposition \u003d true;\n             }\n         } else {\n             if (isSafeAssign(parent, seenSideEffects)) {\n             } else {\n                 for (Node n : parent.children()) {\n                     if (n \u003d\u003d child) {\n                         break;\n                     }\n                     if (isExpressionTreeUnsafe(n, seenSideEffects)) {\n                         seenSideEffects \u003d true;\n                         requiresDecomposition \u003d true;\n                     }\n                 }\n                 Node first \u003d parent.getFirstChild();\n                 if (requiresDecomposition \u0026\u0026 parent.isCall() \u0026\u0026 NodeUtil.isGet(first)) {\n                     if (maybeExternMethod(first)) {\n                         return DecompositionType.UNDECOMPOSABLE;\n                     } else {\n                         return DecompositionType.DECOMPOSABLE;\n                     }\n                 }\n             }\n         }\n         child \u003d parent;\n     }\n     throw new IllegalStateException(\"Unexpected.\");\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "70a5626922ea7e8c98747e22b6986638ba38fadc": {
      "type": "Ymultichange(Ybodychange,Ydocchange)",
      "commitMessage": "\nFix various typos, spelling and grammar errors.\nFixes issue 734. \nContributed by Robert Gust Bardon\n\nR\u003dnicksantos\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d4827\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1979 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "5/18/12, 11:09 AM",
      "commitName": "70a5626922ea7e8c98747e22b6986638ba38fadc",
      "commitAuthor": "johnlenz@google.com",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "\nFix various typos, spelling and grammar errors.\nFixes issue 734. \nContributed by Robert Gust Bardon\n\nR\u003dnicksantos\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d4827\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1979 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "5/18/12, 11:09 AM",
          "commitName": "70a5626922ea7e8c98747e22b6986638ba38fadc",
          "commitAuthor": "johnlenz@google.com",
          "commitDateOld": "11/22/11, 2:28 PM",
          "commitNameOld": "9dfbc803407e714f9744555a1c9e7c4230f1816d",
          "commitAuthorOld": "johnlenz@google.com",
          "daysBetweenCommits": 177.82,
          "commitsBetweenForRepo": 292,
          "commitsBetweenForFile": 1,
          "actualSource": "private DecompositionType isSubexpressionMovable(Node expressionRoot, Node subExpression) {\n    boolean requiresDecomposition \u003d false;\n    boolean seenSideEffects \u003d NodeUtil.mayHaveSideEffects(subExpression);\n    Node child \u003d subExpression;\n    for (Node parent : child.getAncestors()) {\n        if (parent \u003d\u003d expressionRoot) {\n            return requiresDecomposition ? DecompositionType.DECOMPOSABLE : DecompositionType.MOVABLE;\n        }\n        int parentType \u003d parent.getType();\n        if (isConditionalOp(parent)) {\n            if (child !\u003d parent.getFirstChild()) {\n                requiresDecomposition \u003d true;\n            }\n        } else {\n            if (isSafeAssign(parent, seenSideEffects)) {\n            } else {\n                for (Node n : parent.children()) {\n                    if (n \u003d\u003d child) {\n                        break;\n                    }\n                    if (isExpressionTreeUnsafe(n, seenSideEffects)) {\n                        seenSideEffects \u003d true;\n                        requiresDecomposition \u003d true;\n                    }\n                }\n                Node first \u003d parent.getFirstChild();\n                if (requiresDecomposition \u0026\u0026 parent.isCall() \u0026\u0026 NodeUtil.isGet(first)) {\n                    if (maybeExternMethod(first)) {\n                        return DecompositionType.UNDECOMPOSABLE;\n                    } else {\n                        return DecompositionType.DECOMPOSABLE;\n                    }\n                }\n            }\n        }\n        child \u003d parent;\n    }\n    throw new IllegalStateException(\"Unexpected.\");\n}",
          "path": "src/com/google/javascript/jscomp/ExpressionDecomposer.java",
          "functionStartLine": 730,
          "functionName": "isSubexpressionMovable",
          "functionAnnotation": "",
          "functionDoc": "Walk the AST from the call site to the expression root and verify that\nthe portions of the expression that are evaluated before the call are:\n1) Unaffected by the the side-effects, if any, of the call.\n2) That there are no side-effects, that may influence the call.\n\nFor example, if x has side-effects:\n  a \u003d 1 + x();\nthe call to x can be moved because \"a\" final value of a can not be\ninfluenced by x(), but in:\n  a \u003d b + x();\nthe call to x can not be moved because the value of b may be modified\nby the call to x.\n\nIf x is without side-effects in:\n  a \u003d b + x();\nthe call to x can be moved, but in:\n  a \u003d (b.foo \u003d c) + x();\nthe call to x can not be moved because the value of b.foo may be referenced\nby x().  Note: this is true even if b is a local variable; the object that\nb refers to may have a global alias.\n\n@return UNDECOMPOSABLE if the expression can not be moved, DECOMPOSABLE if\ndecomposition is required before the expression can be moved, otherwise\nMOVABLE.\n",
          "diff": "",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "\nFix various typos, spelling and grammar errors.\nFixes issue 734. \nContributed by Robert Gust Bardon\n\nR\u003dnicksantos\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d4827\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1979 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "5/18/12, 11:09 AM",
          "commitName": "70a5626922ea7e8c98747e22b6986638ba38fadc",
          "commitAuthor": "johnlenz@google.com",
          "commitDateOld": "11/22/11, 2:28 PM",
          "commitNameOld": "9dfbc803407e714f9744555a1c9e7c4230f1816d",
          "commitAuthorOld": "johnlenz@google.com",
          "daysBetweenCommits": 177.82,
          "commitsBetweenForRepo": 292,
          "commitsBetweenForFile": 1,
          "actualSource": "private DecompositionType isSubexpressionMovable(Node expressionRoot, Node subExpression) {\n    boolean requiresDecomposition \u003d false;\n    boolean seenSideEffects \u003d NodeUtil.mayHaveSideEffects(subExpression);\n    Node child \u003d subExpression;\n    for (Node parent : child.getAncestors()) {\n        if (parent \u003d\u003d expressionRoot) {\n            return requiresDecomposition ? DecompositionType.DECOMPOSABLE : DecompositionType.MOVABLE;\n        }\n        int parentType \u003d parent.getType();\n        if (isConditionalOp(parent)) {\n            if (child !\u003d parent.getFirstChild()) {\n                requiresDecomposition \u003d true;\n            }\n        } else {\n            if (isSafeAssign(parent, seenSideEffects)) {\n            } else {\n                for (Node n : parent.children()) {\n                    if (n \u003d\u003d child) {\n                        break;\n                    }\n                    if (isExpressionTreeUnsafe(n, seenSideEffects)) {\n                        seenSideEffects \u003d true;\n                        requiresDecomposition \u003d true;\n                    }\n                }\n                Node first \u003d parent.getFirstChild();\n                if (requiresDecomposition \u0026\u0026 parent.isCall() \u0026\u0026 NodeUtil.isGet(first)) {\n                    if (maybeExternMethod(first)) {\n                        return DecompositionType.UNDECOMPOSABLE;\n                    } else {\n                        return DecompositionType.DECOMPOSABLE;\n                    }\n                }\n            }\n        }\n        child \u003d parent;\n    }\n    throw new IllegalStateException(\"Unexpected.\");\n}",
          "path": "src/com/google/javascript/jscomp/ExpressionDecomposer.java",
          "functionStartLine": 730,
          "functionName": "isSubexpressionMovable",
          "functionAnnotation": "",
          "functionDoc": "Walk the AST from the call site to the expression root and verify that\nthe portions of the expression that are evaluated before the call are:\n1) Unaffected by the the side-effects, if any, of the call.\n2) That there are no side-effects, that may influence the call.\n\nFor example, if x has side-effects:\n  a \u003d 1 + x();\nthe call to x can be moved because \"a\" final value of a can not be\ninfluenced by x(), but in:\n  a \u003d b + x();\nthe call to x can not be moved because the value of b may be modified\nby the call to x.\n\nIf x is without side-effects in:\n  a \u003d b + x();\nthe call to x can be moved, but in:\n  a \u003d (b.foo \u003d c) + x();\nthe call to x can not be moved because the value of b.foo may be referenced\nby x().  Note: this is true even if b is a local variable; the object that\nb refers to may have a global alias.\n\n@return UNDECOMPOSABLE if the expression can not be moved, DECOMPOSABLE if\ndecomposition is required before the expression can be moved, otherwise\nMOVABLE.\n",
          "diff": "",
          "extendedDetails": {
            "oldValue": "Walk the AST from the call site to the expression root and verify that\nthe portions of the expression that are evaluated before the call are:\n1) Unaffected by the the side-efects, if any, of the call.\n2) That there are no side-effects, that may influence the call.\n\nFor example, if x has side-effects:\n  a \u003d 1 + x();\nthe call to x can be moved because \"a\" final value of a can not be\ninfluenced by x(), but in:\n  a \u003d b + x();\nthe call to x can not be moved because the value of b may be modified\nby the call to x.\n\nIf x is without side-effects in:\n  a \u003d b + x();\nthe call to x can be moved, but in:\n  a \u003d (b.foo \u003d c) + x();\nthe call to x can not be moved because the value of b.foo may be referenced\nby x().  Note: this is true even if b is a local variable; the object that\nb refers to may have a global alias.\n\n@return UNDECOMPOSABLE if the expression can not be moved, DECOMPOSABLE if\ndecomposition is required before the expression can be moved, otherwise\nMOVABLE.\n",
            "newValue": "Walk the AST from the call site to the expression root and verify that\nthe portions of the expression that are evaluated before the call are:\n1) Unaffected by the the side-effects, if any, of the call.\n2) That there are no side-effects, that may influence the call.\n\nFor example, if x has side-effects:\n  a \u003d 1 + x();\nthe call to x can be moved because \"a\" final value of a can not be\ninfluenced by x(), but in:\n  a \u003d b + x();\nthe call to x can not be moved because the value of b may be modified\nby the call to x.\n\nIf x is without side-effects in:\n  a \u003d b + x();\nthe call to x can be moved, but in:\n  a \u003d (b.foo \u003d c) + x();\nthe call to x can not be moved because the value of b.foo may be referenced\nby x().  Note: this is true even if b is a local variable; the object that\nb refers to may have a global alias.\n\n@return UNDECOMPOSABLE if the expression can not be moved, DECOMPOSABLE if\ndecomposition is required before the expression can be moved, otherwise\nMOVABLE.\n"
          }
        }
      ]
    },
    "ec324a9bb23eb78c76f537f4c4170ba88d542f1c": {
      "type": "Ybodychange",
      "commitMessage": "\nReplace the bulk of the Node.getType() \u003d\u003d Token.XXX calls with\nNode.isXXX calls.\n\nR\u003dnicksantos\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3677\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1582 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/10/11, 8:36 AM",
      "commitName": "ec324a9bb23eb78c76f537f4c4170ba88d542f1c",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "11/9/11, 1:51 PM",
      "commitNameOld": "3d80e1ed8fffbcb5f41b63f64726d9a4c76f209f",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 0.78,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "private DecompositionType isSubexpressionMovable(Node expressionRoot, Node subExpression) {\n    boolean requiresDecomposition \u003d false;\n    boolean seenSideEffects \u003d NodeUtil.mayHaveSideEffects(subExpression);\n    Node child \u003d subExpression;\n    for (Node parent : child.getAncestors()) {\n        if (parent \u003d\u003d expressionRoot) {\n            return requiresDecomposition ? DecompositionType.DECOMPOSABLE : DecompositionType.MOVABLE;\n        }\n        int parentType \u003d parent.getType();\n        if (isConditionalOp(parent)) {\n            if (child !\u003d parent.getFirstChild()) {\n                requiresDecomposition \u003d true;\n            }\n        } else {\n            if (isSafeAssign(parent, seenSideEffects)) {\n            } else {\n                for (Node n : parent.children()) {\n                    if (n \u003d\u003d child) {\n                        break;\n                    }\n                    if (isExpressionTreeUnsafe(n, seenSideEffects)) {\n                        seenSideEffects \u003d true;\n                        requiresDecomposition \u003d true;\n                    }\n                }\n                Node first \u003d parent.getFirstChild();\n                if (requiresDecomposition \u0026\u0026 parent.isCall() \u0026\u0026 NodeUtil.isGet(first)) {\n                    if (maybeExternMethod(first)) {\n                        return DecompositionType.UNDECOMPOSABLE;\n                    } else {\n                        return DecompositionType.DECOMPOSABLE;\n                    }\n                }\n            }\n        }\n        child \u003d parent;\n    }\n    throw new IllegalStateException(\"Unexpected.\");\n}",
      "path": "src/com/google/javascript/jscomp/ExpressionDecomposer.java",
      "functionStartLine": 730,
      "functionName": "isSubexpressionMovable",
      "functionAnnotation": "",
      "functionDoc": "Walk the AST from the call site to the expression root and verify that\nthe portions of the expression that are evaluated before the call are:\n1) Unaffected by the the side-efects, if any, of the call.\n2) That there are no side-effects, that may influence the call.\n\nFor example, if x has side-effects:\n  a \u003d 1 + x();\nthe call to x can be moved because \"a\" final value of a can not be\ninfluenced by x(), but in:\n  a \u003d b + x();\nthe call to x can not be moved because the value of b may be modified\nby the call to x.\n\nIf x is without side-effects in:\n  a \u003d b + x();\nthe call to x can be moved, but in:\n  a \u003d (b.foo \u003d c) + x();\nthe call to x can not be moved because the value of b.foo may be referenced\nby x().  Note: this is true even if b is a local variable; the object that\nb refers to may have a global alias.\n\n@return UNDECOMPOSABLE if the expression can not be moved, DECOMPOSABLE if\ndecomposition is required before the expression can be moved, otherwise\nMOVABLE.\n",
      "diff": "@@ -1,39 +1,39 @@\n private DecompositionType isSubexpressionMovable(Node expressionRoot, Node subExpression) {\n     boolean requiresDecomposition \u003d false;\n     boolean seenSideEffects \u003d NodeUtil.mayHaveSideEffects(subExpression);\n     Node child \u003d subExpression;\n     for (Node parent : child.getAncestors()) {\n         if (parent \u003d\u003d expressionRoot) {\n             return requiresDecomposition ? DecompositionType.DECOMPOSABLE : DecompositionType.MOVABLE;\n         }\n         int parentType \u003d parent.getType();\n         if (isConditionalOp(parent)) {\n             if (child !\u003d parent.getFirstChild()) {\n                 requiresDecomposition \u003d true;\n             }\n         } else {\n             if (isSafeAssign(parent, seenSideEffects)) {\n             } else {\n                 for (Node n : parent.children()) {\n                     if (n \u003d\u003d child) {\n                         break;\n                     }\n                     if (isExpressionTreeUnsafe(n, seenSideEffects)) {\n                         seenSideEffects \u003d true;\n                         requiresDecomposition \u003d true;\n                     }\n                 }\n                 Node first \u003d parent.getFirstChild();\n-                if (requiresDecomposition \u0026\u0026 parent.getType() \u003d\u003d Token.CALL \u0026\u0026 NodeUtil.isGet(first)) {\n+                if (requiresDecomposition \u0026\u0026 parent.isCall() \u0026\u0026 NodeUtil.isGet(first)) {\n                     if (maybeExternMethod(first)) {\n                         return DecompositionType.UNDECOMPOSABLE;\n                     } else {\n                         return DecompositionType.DECOMPOSABLE;\n                     }\n                 }\n             }\n         }\n         child \u003d parent;\n     }\n     throw new IllegalStateException(\"Unexpected.\");\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3ce4716848eb71b6e78a4545a2cc0c27e74a29b3": {
      "type": "Yformatchange",
      "commitMessage": "Tweak to allow chained initialization:\nnew Node(Token.EXPR_RESULT, a).copyInformationFrom(a); (John)\nR\u003dalan\nDELTA\u003d10  (6 added, 0 deleted, 4 changed)\n\n\nTeach PureFunctionnIdentifier about (f || g)() calls (antonio)\nFixes issue 116\nR\u003djohn\nDELTA\u003d105  (84 added, 0 deleted, 21 changed)\n\nFix decomposition issue \nAnonymous function declaration can not be side-effected and are\nside-effect free. (John)\nR\u003dalan\nDELTA\u003d115  (101 added, 8 deleted, 6 changed)\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@154 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "3/25/10, 8:58 AM",
      "commitName": "3ce4716848eb71b6e78a4545a2cc0c27e74a29b3",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "3/11/10, 9:31 PM",
      "commitNameOld": "7bfdbd9164601af44d17edd51be829fde2cc51aa",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 13.44,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "actualSource": "private DecompositionType isSubexpressionMovable(Node expressionRoot, Node subExpression) {\n    boolean requiresDecomposition \u003d false;\n    boolean seenSideEffects \u003d NodeUtil.mayHaveSideEffects(subExpression);\n    Node child \u003d subExpression;\n    for (Node parent : child.getAncestors()) {\n        if (parent \u003d\u003d expressionRoot) {\n            return requiresDecomposition ? DecompositionType.DECOMPOSABLE : DecompositionType.MOVABLE;\n        }\n        int parentType \u003d parent.getType();\n        if (isConditionalOp(parent)) {\n            if (child !\u003d parent.getFirstChild()) {\n                requiresDecomposition \u003d true;\n            }\n        } else {\n            if (isSafeAssign(parent, seenSideEffects)) {\n            } else {\n                for (Node n : parent.children()) {\n                    if (n \u003d\u003d child) {\n                        break;\n                    }\n                    if (isExpressionTreeUnsafe(n, seenSideEffects)) {\n                        seenSideEffects \u003d true;\n                        requiresDecomposition \u003d true;\n                    }\n                }\n                Node first \u003d parent.getFirstChild();\n                if (requiresDecomposition \u0026\u0026 parent.getType() \u003d\u003d Token.CALL \u0026\u0026 NodeUtil.isGet(first)) {\n                    if (maybeExternMethod(first)) {\n                        return DecompositionType.UNDECOMPOSABLE;\n                    } else {\n                        return DecompositionType.DECOMPOSABLE;\n                    }\n                }\n            }\n        }\n        child \u003d parent;\n    }\n    throw new IllegalStateException(\"Unexpected.\");\n}",
      "path": "src/com/google/javascript/jscomp/ExpressionDecomposer.java",
      "functionStartLine": 665,
      "functionName": "isSubexpressionMovable",
      "functionAnnotation": "",
      "functionDoc": "Walk the AST from the call site to the expression root and verify that\nthe portions of the expression that are evaluated before the call are:\n1) Unaffected by the the side-efects, if any, of the call.\n2) That there are no side-effects, that may influence the call.\n\nFor example, if x has side-effects:\n  a \u003d 1 + x();\nthe call to x can be moved because \"a\" final value of a can not be\ninfluenced by x(), but in:\n  a \u003d b + x();\nthe call to x can not be moved because the value of b may be modified\nby the call to x.\n\nIf x is without side-effects in:\n  a \u003d b + x();\nthe call to x can be moved, but in:\n  a \u003d (b.foo \u003d c) + x();\nthe call to x can not be moved because the value of b.foo may be referenced\nby x().  Note: this is true even if b is a local variable; the object that\nb refers to may have a global alias.\n\n@return UNDECOMPOSABLE if the expression can not be moved, DECOMPOSABLE if\ndecomposition is required before the expression can be moved, otherwise\nMOVABLE.\n",
      "diff": "",
      "extendedDetails": {}
    },
    "78995bf9e88599055a8c4165d89c09dc92a44b30": {
      "type": "Ymultichange(Yreturntypechange,Ybodychange,Ydocchange)",
      "commitMessage": "Fix synthesis of vars in DEFAULT mode.\nBetter variable inlining\nBetter function inlining\nAssorted bug fixes\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@6 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/10/09, 11:16 AM",
      "commitName": "78995bf9e88599055a8c4165d89c09dc92a44b30",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "subchanges": [
        {
          "type": "Yreturntypechange",
          "commitMessage": "Fix synthesis of vars in DEFAULT mode.\nBetter variable inlining\nBetter function inlining\nAssorted bug fixes\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@6 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "11/10/09, 11:16 AM",
          "commitName": "78995bf9e88599055a8c4165d89c09dc92a44b30",
          "commitAuthor": "nicholas.j.santos@gmail.com",
          "commitDateOld": "11/3/09, 3:51 PM",
          "commitNameOld": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
          "commitAuthorOld": "nicholas.j.santos@gmail.com",
          "daysBetweenCommits": 6.81,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "actualSource": "private DecompositionType isSubexpressionMovable(Node expressionRoot, Node subExpression) {\n    boolean requiresDecomposition \u003d false;\n    boolean seenSideEffects \u003d NodeUtil.mayHaveSideEffects(subExpression);\n    Node child \u003d subExpression;\n    for (Node parent : child.getAncestors()) {\n        if (parent \u003d\u003d expressionRoot) {\n            return requiresDecomposition ? DecompositionType.DECOMPOSABLE : DecompositionType.MOVABLE;\n        }\n        int parentType \u003d parent.getType();\n        if (isConditionalOp(parent)) {\n            if (child !\u003d parent.getFirstChild()) {\n                requiresDecomposition \u003d true;\n            }\n        } else {\n            if (isSafeAssign(parent, seenSideEffects)) {\n            } else {\n                for (Node n : parent.children()) {\n                    if (n \u003d\u003d child) {\n                        break;\n                    }\n                    if (isExpressionTreeUnsafe(n, seenSideEffects)) {\n                        seenSideEffects \u003d true;\n                        requiresDecomposition \u003d true;\n                    }\n                }\n                Node first \u003d parent.getFirstChild();\n                if (requiresDecomposition \u0026\u0026 parent.getType() \u003d\u003d Token.CALL \u0026\u0026 NodeUtil.isGet(first)) {\n                    if (maybeExternMethod(first)) {\n                        return DecompositionType.UNDECOMPOSABLE;\n                    } else {\n                        return DecompositionType.DECOMPOSABLE;\n                    }\n                }\n            }\n        }\n        child \u003d parent;\n    }\n    throw new IllegalStateException(\"Unexpected.\");\n}",
          "path": "src/com/google/javascript/jscomp/ExpressionDecomposer.java",
          "functionStartLine": 644,
          "functionName": "isSubexpressionMovable",
          "functionAnnotation": "",
          "functionDoc": "Walk the AST from the call site to the expression root and verify that\nthe portions of the expression that are evaluated before the call are:\n1) Unaffected by the the side-efects, if any, of the call.\n2) That there are no side-effects, that may influence the call.\n\nFor example, if x has side-effects:\n  a \u003d 1 + x();\nthe call to x can be moved because \"a\" final value of a can not be\ninfluenced by x(), but in:\n  a \u003d b + x();\nthe call to x can not be moved because the value of b may be modified\nby the call to x.\n\nIf x is without side-effects in:\n  a \u003d b + x();\nthe call to x can be moved, but in:\n  a \u003d (b.foo \u003d c) + x();\nthe call to x can not be moved because the value of b.foo may be referenced\nby x().  Note: this is true even if b is a local variable; the object that\nb refers to may have a global alias.\n\n@return UNDECOMPOSABLE if the expression can not be moved, DECOMPOSABLE if\ndecomposition is required before the expression can be moved, otherwise\nMOVABLE.\n",
          "diff": "@@ -1,29 +1,39 @@\n-private boolean isSubexpressionMovable(Node expressionRoot, Node subExpression) {\n-    boolean callExpressionHasSideEffects \u003d NodeUtil.mayHaveSideEffects(subExpression);\n+private DecompositionType isSubexpressionMovable(Node expressionRoot, Node subExpression) {\n+    boolean requiresDecomposition \u003d false;\n+    boolean seenSideEffects \u003d NodeUtil.mayHaveSideEffects(subExpression);\n     Node child \u003d subExpression;\n     for (Node parent : child.getAncestors()) {\n         if (parent \u003d\u003d expressionRoot) {\n-            return true;\n+            return requiresDecomposition ? DecompositionType.DECOMPOSABLE : DecompositionType.MOVABLE;\n         }\n         int parentType \u003d parent.getType();\n         if (isConditionalOp(parent)) {\n             if (child !\u003d parent.getFirstChild()) {\n-                return false;\n+                requiresDecomposition \u003d true;\n             }\n         } else {\n-            if (parentType \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild().getType() \u003d\u003d Token.NAME) {\n+            if (isSafeAssign(parent, seenSideEffects)) {\n             } else {\n                 for (Node n : parent.children()) {\n                     if (n \u003d\u003d child) {\n                         break;\n                     }\n-                    if (isExpressionTreeUnsafe(n, callExpressionHasSideEffects)) {\n-                        return false;\n+                    if (isExpressionTreeUnsafe(n, seenSideEffects)) {\n+                        seenSideEffects \u003d true;\n+                        requiresDecomposition \u003d true;\n+                    }\n+                }\n+                Node first \u003d parent.getFirstChild();\n+                if (requiresDecomposition \u0026\u0026 parent.getType() \u003d\u003d Token.CALL \u0026\u0026 NodeUtil.isGet(first)) {\n+                    if (maybeExternMethod(first)) {\n+                        return DecompositionType.UNDECOMPOSABLE;\n+                    } else {\n+                        return DecompositionType.DECOMPOSABLE;\n                     }\n                 }\n             }\n         }\n         child \u003d parent;\n     }\n     throw new IllegalStateException(\"Unexpected.\");\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "boolean",
            "newValue": "DecompositionType"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Fix synthesis of vars in DEFAULT mode.\nBetter variable inlining\nBetter function inlining\nAssorted bug fixes\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@6 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "11/10/09, 11:16 AM",
          "commitName": "78995bf9e88599055a8c4165d89c09dc92a44b30",
          "commitAuthor": "nicholas.j.santos@gmail.com",
          "commitDateOld": "11/3/09, 3:51 PM",
          "commitNameOld": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
          "commitAuthorOld": "nicholas.j.santos@gmail.com",
          "daysBetweenCommits": 6.81,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "actualSource": "private DecompositionType isSubexpressionMovable(Node expressionRoot, Node subExpression) {\n    boolean requiresDecomposition \u003d false;\n    boolean seenSideEffects \u003d NodeUtil.mayHaveSideEffects(subExpression);\n    Node child \u003d subExpression;\n    for (Node parent : child.getAncestors()) {\n        if (parent \u003d\u003d expressionRoot) {\n            return requiresDecomposition ? DecompositionType.DECOMPOSABLE : DecompositionType.MOVABLE;\n        }\n        int parentType \u003d parent.getType();\n        if (isConditionalOp(parent)) {\n            if (child !\u003d parent.getFirstChild()) {\n                requiresDecomposition \u003d true;\n            }\n        } else {\n            if (isSafeAssign(parent, seenSideEffects)) {\n            } else {\n                for (Node n : parent.children()) {\n                    if (n \u003d\u003d child) {\n                        break;\n                    }\n                    if (isExpressionTreeUnsafe(n, seenSideEffects)) {\n                        seenSideEffects \u003d true;\n                        requiresDecomposition \u003d true;\n                    }\n                }\n                Node first \u003d parent.getFirstChild();\n                if (requiresDecomposition \u0026\u0026 parent.getType() \u003d\u003d Token.CALL \u0026\u0026 NodeUtil.isGet(first)) {\n                    if (maybeExternMethod(first)) {\n                        return DecompositionType.UNDECOMPOSABLE;\n                    } else {\n                        return DecompositionType.DECOMPOSABLE;\n                    }\n                }\n            }\n        }\n        child \u003d parent;\n    }\n    throw new IllegalStateException(\"Unexpected.\");\n}",
          "path": "src/com/google/javascript/jscomp/ExpressionDecomposer.java",
          "functionStartLine": 644,
          "functionName": "isSubexpressionMovable",
          "functionAnnotation": "",
          "functionDoc": "Walk the AST from the call site to the expression root and verify that\nthe portions of the expression that are evaluated before the call are:\n1) Unaffected by the the side-efects, if any, of the call.\n2) That there are no side-effects, that may influence the call.\n\nFor example, if x has side-effects:\n  a \u003d 1 + x();\nthe call to x can be moved because \"a\" final value of a can not be\ninfluenced by x(), but in:\n  a \u003d b + x();\nthe call to x can not be moved because the value of b may be modified\nby the call to x.\n\nIf x is without side-effects in:\n  a \u003d b + x();\nthe call to x can be moved, but in:\n  a \u003d (b.foo \u003d c) + x();\nthe call to x can not be moved because the value of b.foo may be referenced\nby x().  Note: this is true even if b is a local variable; the object that\nb refers to may have a global alias.\n\n@return UNDECOMPOSABLE if the expression can not be moved, DECOMPOSABLE if\ndecomposition is required before the expression can be moved, otherwise\nMOVABLE.\n",
          "diff": "@@ -1,29 +1,39 @@\n-private boolean isSubexpressionMovable(Node expressionRoot, Node subExpression) {\n-    boolean callExpressionHasSideEffects \u003d NodeUtil.mayHaveSideEffects(subExpression);\n+private DecompositionType isSubexpressionMovable(Node expressionRoot, Node subExpression) {\n+    boolean requiresDecomposition \u003d false;\n+    boolean seenSideEffects \u003d NodeUtil.mayHaveSideEffects(subExpression);\n     Node child \u003d subExpression;\n     for (Node parent : child.getAncestors()) {\n         if (parent \u003d\u003d expressionRoot) {\n-            return true;\n+            return requiresDecomposition ? DecompositionType.DECOMPOSABLE : DecompositionType.MOVABLE;\n         }\n         int parentType \u003d parent.getType();\n         if (isConditionalOp(parent)) {\n             if (child !\u003d parent.getFirstChild()) {\n-                return false;\n+                requiresDecomposition \u003d true;\n             }\n         } else {\n-            if (parentType \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild().getType() \u003d\u003d Token.NAME) {\n+            if (isSafeAssign(parent, seenSideEffects)) {\n             } else {\n                 for (Node n : parent.children()) {\n                     if (n \u003d\u003d child) {\n                         break;\n                     }\n-                    if (isExpressionTreeUnsafe(n, callExpressionHasSideEffects)) {\n-                        return false;\n+                    if (isExpressionTreeUnsafe(n, seenSideEffects)) {\n+                        seenSideEffects \u003d true;\n+                        requiresDecomposition \u003d true;\n+                    }\n+                }\n+                Node first \u003d parent.getFirstChild();\n+                if (requiresDecomposition \u0026\u0026 parent.getType() \u003d\u003d Token.CALL \u0026\u0026 NodeUtil.isGet(first)) {\n+                    if (maybeExternMethod(first)) {\n+                        return DecompositionType.UNDECOMPOSABLE;\n+                    } else {\n+                        return DecompositionType.DECOMPOSABLE;\n                     }\n                 }\n             }\n         }\n         child \u003d parent;\n     }\n     throw new IllegalStateException(\"Unexpected.\");\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Fix synthesis of vars in DEFAULT mode.\nBetter variable inlining\nBetter function inlining\nAssorted bug fixes\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@6 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "11/10/09, 11:16 AM",
          "commitName": "78995bf9e88599055a8c4165d89c09dc92a44b30",
          "commitAuthor": "nicholas.j.santos@gmail.com",
          "commitDateOld": "11/3/09, 3:51 PM",
          "commitNameOld": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
          "commitAuthorOld": "nicholas.j.santos@gmail.com",
          "daysBetweenCommits": 6.81,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "actualSource": "private DecompositionType isSubexpressionMovable(Node expressionRoot, Node subExpression) {\n    boolean requiresDecomposition \u003d false;\n    boolean seenSideEffects \u003d NodeUtil.mayHaveSideEffects(subExpression);\n    Node child \u003d subExpression;\n    for (Node parent : child.getAncestors()) {\n        if (parent \u003d\u003d expressionRoot) {\n            return requiresDecomposition ? DecompositionType.DECOMPOSABLE : DecompositionType.MOVABLE;\n        }\n        int parentType \u003d parent.getType();\n        if (isConditionalOp(parent)) {\n            if (child !\u003d parent.getFirstChild()) {\n                requiresDecomposition \u003d true;\n            }\n        } else {\n            if (isSafeAssign(parent, seenSideEffects)) {\n            } else {\n                for (Node n : parent.children()) {\n                    if (n \u003d\u003d child) {\n                        break;\n                    }\n                    if (isExpressionTreeUnsafe(n, seenSideEffects)) {\n                        seenSideEffects \u003d true;\n                        requiresDecomposition \u003d true;\n                    }\n                }\n                Node first \u003d parent.getFirstChild();\n                if (requiresDecomposition \u0026\u0026 parent.getType() \u003d\u003d Token.CALL \u0026\u0026 NodeUtil.isGet(first)) {\n                    if (maybeExternMethod(first)) {\n                        return DecompositionType.UNDECOMPOSABLE;\n                    } else {\n                        return DecompositionType.DECOMPOSABLE;\n                    }\n                }\n            }\n        }\n        child \u003d parent;\n    }\n    throw new IllegalStateException(\"Unexpected.\");\n}",
          "path": "src/com/google/javascript/jscomp/ExpressionDecomposer.java",
          "functionStartLine": 644,
          "functionName": "isSubexpressionMovable",
          "functionAnnotation": "",
          "functionDoc": "Walk the AST from the call site to the expression root and verify that\nthe portions of the expression that are evaluated before the call are:\n1) Unaffected by the the side-efects, if any, of the call.\n2) That there are no side-effects, that may influence the call.\n\nFor example, if x has side-effects:\n  a \u003d 1 + x();\nthe call to x can be moved because \"a\" final value of a can not be\ninfluenced by x(), but in:\n  a \u003d b + x();\nthe call to x can not be moved because the value of b may be modified\nby the call to x.\n\nIf x is without side-effects in:\n  a \u003d b + x();\nthe call to x can be moved, but in:\n  a \u003d (b.foo \u003d c) + x();\nthe call to x can not be moved because the value of b.foo may be referenced\nby x().  Note: this is true even if b is a local variable; the object that\nb refers to may have a global alias.\n\n@return UNDECOMPOSABLE if the expression can not be moved, DECOMPOSABLE if\ndecomposition is required before the expression can be moved, otherwise\nMOVABLE.\n",
          "diff": "@@ -1,29 +1,39 @@\n-private boolean isSubexpressionMovable(Node expressionRoot, Node subExpression) {\n-    boolean callExpressionHasSideEffects \u003d NodeUtil.mayHaveSideEffects(subExpression);\n+private DecompositionType isSubexpressionMovable(Node expressionRoot, Node subExpression) {\n+    boolean requiresDecomposition \u003d false;\n+    boolean seenSideEffects \u003d NodeUtil.mayHaveSideEffects(subExpression);\n     Node child \u003d subExpression;\n     for (Node parent : child.getAncestors()) {\n         if (parent \u003d\u003d expressionRoot) {\n-            return true;\n+            return requiresDecomposition ? DecompositionType.DECOMPOSABLE : DecompositionType.MOVABLE;\n         }\n         int parentType \u003d parent.getType();\n         if (isConditionalOp(parent)) {\n             if (child !\u003d parent.getFirstChild()) {\n-                return false;\n+                requiresDecomposition \u003d true;\n             }\n         } else {\n-            if (parentType \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild().getType() \u003d\u003d Token.NAME) {\n+            if (isSafeAssign(parent, seenSideEffects)) {\n             } else {\n                 for (Node n : parent.children()) {\n                     if (n \u003d\u003d child) {\n                         break;\n                     }\n-                    if (isExpressionTreeUnsafe(n, callExpressionHasSideEffects)) {\n-                        return false;\n+                    if (isExpressionTreeUnsafe(n, seenSideEffects)) {\n+                        seenSideEffects \u003d true;\n+                        requiresDecomposition \u003d true;\n+                    }\n+                }\n+                Node first \u003d parent.getFirstChild();\n+                if (requiresDecomposition \u0026\u0026 parent.getType() \u003d\u003d Token.CALL \u0026\u0026 NodeUtil.isGet(first)) {\n+                    if (maybeExternMethod(first)) {\n+                        return DecompositionType.UNDECOMPOSABLE;\n+                    } else {\n+                        return DecompositionType.DECOMPOSABLE;\n                     }\n                 }\n             }\n         }\n         child \u003d parent;\n     }\n     throw new IllegalStateException(\"Unexpected.\");\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Walk the AST from the call site to the expression root and verify that\nthe portions of the expression that are evaluated before the call are:\n1) Unaffected by the the side-efects, if any, of the call.\n2) That there are no side-effects, that may influence the call.\n\nFor example, if x has side-effects:\n  a \u003d 1 + x();\nthe call to x can be moved because \"a\" final value of a can not be\ninfluenced by x(), but in:\n  a \u003d b + x();\nthe call to x can not be moved because the value of b may be modified\nby the call to x.\n\nIf x is without side-effects in:\n  a \u003d b + x();\nthe call to x can be moved, but in:\n  a \u003d (b.foo \u003d c) + x();\nthe call to x can not be moved because the value of b.foo may be referenced\nby x().  Note: this is true even if b is a local variable; the object that\nb refers to may have a global alias.\n\n@return Whether the call can be moved before the expression.\n",
            "newValue": "Walk the AST from the call site to the expression root and verify that\nthe portions of the expression that are evaluated before the call are:\n1) Unaffected by the the side-efects, if any, of the call.\n2) That there are no side-effects, that may influence the call.\n\nFor example, if x has side-effects:\n  a \u003d 1 + x();\nthe call to x can be moved because \"a\" final value of a can not be\ninfluenced by x(), but in:\n  a \u003d b + x();\nthe call to x can not be moved because the value of b may be modified\nby the call to x.\n\nIf x is without side-effects in:\n  a \u003d b + x();\nthe call to x can be moved, but in:\n  a \u003d (b.foo \u003d c) + x();\nthe call to x can not be moved because the value of b.foo may be referenced\nby x().  Note: this is true even if b is a local variable; the object that\nb refers to may have a global alias.\n\n@return UNDECOMPOSABLE if the expression can not be moved, DECOMPOSABLE if\ndecomposition is required before the expression can be moved, otherwise\nMOVABLE.\n"
          }
        }
      ]
    },
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": {
      "type": "Yintroduced",
      "commitMessage": "Initial commit.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/3/09, 3:51 PM",
      "commitName": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "diff": "@@ -0,0 +1,29 @@\n+private boolean isSubexpressionMovable(Node expressionRoot, Node subExpression) {\n+    boolean callExpressionHasSideEffects \u003d NodeUtil.mayHaveSideEffects(subExpression);\n+    Node child \u003d subExpression;\n+    for (Node parent : child.getAncestors()) {\n+        if (parent \u003d\u003d expressionRoot) {\n+            return true;\n+        }\n+        int parentType \u003d parent.getType();\n+        if (isConditionalOp(parent)) {\n+            if (child !\u003d parent.getFirstChild()) {\n+                return false;\n+            }\n+        } else {\n+            if (parentType \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild().getType() \u003d\u003d Token.NAME) {\n+            } else {\n+                for (Node n : parent.children()) {\n+                    if (n \u003d\u003d child) {\n+                        break;\n+                    }\n+                    if (isExpressionTreeUnsafe(n, callExpressionHasSideEffects)) {\n+                        return false;\n+                    }\n+                }\n+            }\n+        }\n+        child \u003d parent;\n+    }\n+    throw new IllegalStateException(\"Unexpected.\");\n+}\n\\ No newline at end of file\n",
      "actualSource": "private boolean isSubexpressionMovable(Node expressionRoot, Node subExpression) {\n    boolean callExpressionHasSideEffects \u003d NodeUtil.mayHaveSideEffects(subExpression);\n    Node child \u003d subExpression;\n    for (Node parent : child.getAncestors()) {\n        if (parent \u003d\u003d expressionRoot) {\n            return true;\n        }\n        int parentType \u003d parent.getType();\n        if (isConditionalOp(parent)) {\n            if (child !\u003d parent.getFirstChild()) {\n                return false;\n            }\n        } else {\n            if (parentType \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild().getType() \u003d\u003d Token.NAME) {\n            } else {\n                for (Node n : parent.children()) {\n                    if (n \u003d\u003d child) {\n                        break;\n                    }\n                    if (isExpressionTreeUnsafe(n, callExpressionHasSideEffects)) {\n                        return false;\n                    }\n                }\n            }\n        }\n        child \u003d parent;\n    }\n    throw new IllegalStateException(\"Unexpected.\");\n}",
      "path": "src/com/google/javascript/jscomp/ExpressionDecomposer.java",
      "functionStartLine": 625,
      "functionName": "isSubexpressionMovable",
      "functionAnnotation": "",
      "functionDoc": "Walk the AST from the call site to the expression root and verify that\nthe portions of the expression that are evaluated before the call are:\n1) Unaffected by the the side-efects, if any, of the call.\n2) That there are no side-effects, that may influence the call.\n\nFor example, if x has side-effects:\n  a \u003d 1 + x();\nthe call to x can be moved because \"a\" final value of a can not be\ninfluenced by x(), but in:\n  a \u003d b + x();\nthe call to x can not be moved because the value of b may be modified\nby the call to x.\n\nIf x is without side-effects in:\n  a \u003d b + x();\nthe call to x can be moved, but in:\n  a \u003d (b.foo \u003d c) + x();\nthe call to x can not be moved because the value of b.foo may be referenced\nby x().  Note: this is true even if b is a local variable; the object that\nb refers to may have a global alias.\n\n@return Whether the call can be moved before the expression.\n"
    }
  }
}