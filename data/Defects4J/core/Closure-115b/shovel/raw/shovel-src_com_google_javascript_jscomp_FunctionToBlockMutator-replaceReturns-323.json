{
  "origin": "codeshovel",
  "repositoryName": "Closure-115b",
  "repositoryPath": "/tmp/Closure-115b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FunctionToBlockMutator.java",
  "functionName": "replaceReturns",
  "functionId": "replaceReturns___block-Node__resultName-String__labelName-String__resultMustBeSet-boolean",
  "sourceFilePath": "src/com/google/javascript/jscomp/FunctionToBlockMutator.java",
  "functionAnnotation": "",
  "functionDoc": " Convert returns to assignments and breaks, as needed.\n For example, with a labelName of \u0027foo\u0027:\n   {\n     return a;\n   }\n becomes:\n   foo: {\n     a;\n     break foo;\n   }\n or\n   foo: {\n     resultName \u003d a;\n     break foo;\n   }\n\n@param resultMustBeSet Whether the result must always be set to a value.\n@return The node containing the transformed block, this may be different\n    than the passed in node \u0027block\u0027.\n",
  "functionStartLine": 323,
  "functionEndLine": 369,
  "numCommitsSeen": 26,
  "timeTaken": 1427,
  "changeHistory": [
    "70a5626922ea7e8c98747e22b6986638ba38fadc",
    "9dfbc803407e714f9744555a1c9e7c4230f1816d",
    "a2715a52745d816a87c05d3007ed8bfe7ef18491",
    "b4801b28ceea8db0f63da7440d6769cb9b7cce8a",
    "6e3eb4f7619179ba6c23db2af7549ef02f588c35",
    "222eafd303155b3eac5cd244584b2cb3c4c11975",
    "f01925cbf7a39a885e51865208368e861d25a0c1",
    "8c5eb247cb5361a6ffa2d86aa4c2de17c234bda7",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3"
  ],
  "changeHistoryShort": {
    "70a5626922ea7e8c98747e22b6986638ba38fadc": "Ydocchange",
    "9dfbc803407e714f9744555a1c9e7c4230f1816d": "Ybodychange",
    "a2715a52745d816a87c05d3007ed8bfe7ef18491": "Yformatchange",
    "b4801b28ceea8db0f63da7440d6769cb9b7cce8a": "Ybodychange",
    "6e3eb4f7619179ba6c23db2af7549ef02f588c35": "Ybodychange",
    "222eafd303155b3eac5cd244584b2cb3c4c11975": "Ybodychange",
    "f01925cbf7a39a885e51865208368e861d25a0c1": "Ybodychange",
    "8c5eb247cb5361a6ffa2d86aa4c2de17c234bda7": "Ybodychange",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "70a5626922ea7e8c98747e22b6986638ba38fadc": {
      "type": "Ydocchange",
      "commitMessage": "\nFix various typos, spelling and grammar errors.\nFixes issue 734. \nContributed by Robert Gust Bardon\n\nR\u003dnicksantos\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d4827\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1979 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "5/18/12, 11:09 AM",
      "commitName": "70a5626922ea7e8c98747e22b6986638ba38fadc",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "11/22/11, 2:28 PM",
      "commitNameOld": "9dfbc803407e714f9744555a1c9e7c4230f1816d",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 177.82,
      "commitsBetweenForRepo": 292,
      "commitsBetweenForFile": 1,
      "actualSource": "private static Node replaceReturns(Node block, String resultName, String labelName, boolean resultMustBeSet) {\n    Preconditions.checkNotNull(block);\n    Preconditions.checkNotNull(labelName);\n    Node root \u003d block;\n    boolean hasReturnAtExit \u003d false;\n    int returnCount \u003d NodeUtil.getNodeTypeReferenceCount(block, Token.RETURN, new NodeUtil.MatchShallowStatement());\n    if (returnCount \u003e 0) {\n        hasReturnAtExit \u003d hasReturnAtExit(block);\n        if (hasReturnAtExit) {\n            convertLastReturnToStatement(block, resultName);\n            returnCount--;\n        }\n        if (returnCount \u003e 0) {\n            replaceReturnWithBreak(block, null, resultName, labelName);\n            Node name \u003d IR.labelName(labelName).srcref(block);\n            Node label \u003d IR.label(name, block).srcref(block);\n            Node newRoot \u003d IR.block().srcref(block);\n            newRoot.addChildrenToBack(label);\n            root \u003d newRoot;\n        }\n    }\n    if (resultMustBeSet \u0026\u0026 !hasReturnAtExit \u0026\u0026 resultName !\u003d null) {\n        addDummyAssignment(block, resultName);\n    }\n    return root;\n}",
      "path": "src/com/google/javascript/jscomp/FunctionToBlockMutator.java",
      "functionStartLine": 322,
      "functionName": "replaceReturns",
      "functionAnnotation": "",
      "functionDoc": " Convert returns to assignments and breaks, as needed.\n For example, with a labelName of \u0027foo\u0027:\n   {\n     return a;\n   }\n becomes:\n   foo: {\n     a;\n     break foo;\n   }\n or\n   foo: {\n     resultName \u003d a;\n     break foo;\n   }\n\n@param resultMustBeSet Whether the result must always be set to a value.\n@return The node containing the transformed block, this may be different\n    than the passed in node \u0027block\u0027.\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": " Convert returns to assignments and breaks, as needed.\n For example, with a lableName of \u0027foo\u0027:\n   {\n     return a;\n   }\n becomes:\n   foo: {\n     a;\n     break foo;\n   }\n or\n   foo: {\n     resultName \u003d a;\n     break foo;\n   }\n\n@param resultMustBeSet Whether the result must always be set to a value.\n@return The node containing the transformed block, this may be different\n    than the passed in node \u0027block\u0027.\n",
        "newValue": " Convert returns to assignments and breaks, as needed.\n For example, with a labelName of \u0027foo\u0027:\n   {\n     return a;\n   }\n becomes:\n   foo: {\n     a;\n     break foo;\n   }\n or\n   foo: {\n     resultName \u003d a;\n     break foo;\n   }\n\n@param resultMustBeSet Whether the result must always be set to a value.\n@return The node containing the transformed block, this may be different\n    than the passed in node \u0027block\u0027.\n"
      }
    },
    "9dfbc803407e714f9744555a1c9e7c4230f1816d": {
      "type": "Ybodychange",
      "commitMessage": "\nUse the new IR interface where possible.\n\nR\u003dnicksantos\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3799\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1641 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/22/11, 2:28 PM",
      "commitName": "9dfbc803407e714f9744555a1c9e7c4230f1816d",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "11/14/11, 6:13 PM",
      "commitNameOld": "39f629a8cfaab37da55288010640d7e516000b1f",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 7.84,
      "commitsBetweenForRepo": 31,
      "commitsBetweenForFile": 1,
      "actualSource": "private static Node replaceReturns(Node block, String resultName, String labelName, boolean resultMustBeSet) {\n    Preconditions.checkNotNull(block);\n    Preconditions.checkNotNull(labelName);\n    Node root \u003d block;\n    boolean hasReturnAtExit \u003d false;\n    int returnCount \u003d NodeUtil.getNodeTypeReferenceCount(block, Token.RETURN, new NodeUtil.MatchShallowStatement());\n    if (returnCount \u003e 0) {\n        hasReturnAtExit \u003d hasReturnAtExit(block);\n        if (hasReturnAtExit) {\n            convertLastReturnToStatement(block, resultName);\n            returnCount--;\n        }\n        if (returnCount \u003e 0) {\n            replaceReturnWithBreak(block, null, resultName, labelName);\n            Node name \u003d IR.labelName(labelName).srcref(block);\n            Node label \u003d IR.label(name, block).srcref(block);\n            Node newRoot \u003d IR.block().srcref(block);\n            newRoot.addChildrenToBack(label);\n            root \u003d newRoot;\n        }\n    }\n    if (resultMustBeSet \u0026\u0026 !hasReturnAtExit \u0026\u0026 resultName !\u003d null) {\n        addDummyAssignment(block, resultName);\n    }\n    return root;\n}",
      "path": "src/com/google/javascript/jscomp/FunctionToBlockMutator.java",
      "functionStartLine": 322,
      "functionName": "replaceReturns",
      "functionAnnotation": "",
      "functionDoc": " Convert returns to assignments and breaks, as needed.\n For example, with a lableName of \u0027foo\u0027:\n   {\n     return a;\n   }\n becomes:\n   foo: {\n     a;\n     break foo;\n   }\n or\n   foo: {\n     resultName \u003d a;\n     break foo;\n   }\n\n@param resultMustBeSet Whether the result must always be set to a value.\n@return The node containing the transformed block, this may be different\n    than the passed in node \u0027block\u0027.\n",
      "diff": "@@ -1,28 +1,26 @@\n private static Node replaceReturns(Node block, String resultName, String labelName, boolean resultMustBeSet) {\n     Preconditions.checkNotNull(block);\n     Preconditions.checkNotNull(labelName);\n     Node root \u003d block;\n     boolean hasReturnAtExit \u003d false;\n     int returnCount \u003d NodeUtil.getNodeTypeReferenceCount(block, Token.RETURN, new NodeUtil.MatchShallowStatement());\n     if (returnCount \u003e 0) {\n         hasReturnAtExit \u003d hasReturnAtExit(block);\n         if (hasReturnAtExit) {\n             convertLastReturnToStatement(block, resultName);\n             returnCount--;\n         }\n         if (returnCount \u003e 0) {\n             replaceReturnWithBreak(block, null, resultName, labelName);\n-            Node label \u003d new Node(Token.LABEL).copyInformationFrom(block);\n-            Node name \u003d Node.newString(Token.LABEL_NAME, labelName).copyInformationFrom(block);\n-            label.addChildToFront(name);\n-            label.addChildToBack(block);\n-            Node newRoot \u003d new Node(Token.BLOCK).copyInformationFrom(block);\n+            Node name \u003d IR.labelName(labelName).srcref(block);\n+            Node label \u003d IR.label(name, block).srcref(block);\n+            Node newRoot \u003d IR.block().srcref(block);\n             newRoot.addChildrenToBack(label);\n             root \u003d newRoot;\n         }\n     }\n     if (resultMustBeSet \u0026\u0026 !hasReturnAtExit \u0026\u0026 resultName !\u003d null) {\n         addDummyAssignment(block, resultName);\n     }\n     return root;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a2715a52745d816a87c05d3007ed8bfe7ef18491": {
      "type": "Yformatchange",
      "commitMessage": "\ndelete all trailing whitespace\nfix up the presubmit to skip generated files\n\nR\u003djohnlenz\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d822\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@875 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "3/10/11, 3:34 PM",
      "commitName": "a2715a52745d816a87c05d3007ed8bfe7ef18491",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "11/11/10, 9:42 PM",
      "commitNameOld": "df223efd38c514d584f00d076488ab9a02011492",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 118.74,
      "commitsBetweenForRepo": 317,
      "commitsBetweenForFile": 1,
      "actualSource": "private static Node replaceReturns(Node block, String resultName, String labelName, boolean resultMustBeSet) {\n    Preconditions.checkNotNull(block);\n    Preconditions.checkNotNull(labelName);\n    Node root \u003d block;\n    boolean hasReturnAtExit \u003d false;\n    int returnCount \u003d NodeUtil.getNodeTypeReferenceCount(block, Token.RETURN, new NodeUtil.MatchShallowStatement());\n    if (returnCount \u003e 0) {\n        hasReturnAtExit \u003d hasReturnAtExit(block);\n        if (hasReturnAtExit) {\n            convertLastReturnToStatement(block, resultName);\n            returnCount--;\n        }\n        if (returnCount \u003e 0) {\n            replaceReturnWithBreak(block, null, resultName, labelName);\n            Node label \u003d new Node(Token.LABEL).copyInformationFrom(block);\n            Node name \u003d Node.newString(Token.LABEL_NAME, labelName).copyInformationFrom(block);\n            label.addChildToFront(name);\n            label.addChildToBack(block);\n            Node newRoot \u003d new Node(Token.BLOCK).copyInformationFrom(block);\n            newRoot.addChildrenToBack(label);\n            root \u003d newRoot;\n        }\n    }\n    if (resultMustBeSet \u0026\u0026 !hasReturnAtExit \u0026\u0026 resultName !\u003d null) {\n        addDummyAssignment(block, resultName);\n    }\n    return root;\n}",
      "path": "src/com/google/javascript/jscomp/FunctionToBlockMutator.java",
      "functionStartLine": 240,
      "functionName": "replaceReturns",
      "functionAnnotation": "",
      "functionDoc": " Convert returns to assignments and breaks, as needed.\n For example, with a lableName of \u0027foo\u0027:\n   {\n     return a;\n   }\n becomes:\n   foo: {\n     a;\n     break foo;\n   }\n or\n   foo: {\n     resultName \u003d a;\n     break foo;\n   }\n\n@param resultMustBeSet Whether the result must always be set to a value.\n@return The node containing the transformed block, this may be different\n    than the passed in node \u0027block\u0027.\n",
      "diff": "",
      "extendedDetails": {}
    },
    "b4801b28ceea8db0f63da7440d6769cb9b7cce8a": {
      "type": "Ybodychange",
      "commitMessage": "\nChange on 2010/05/28 by johnlenz\n\n        Inline functions with inner functions into global scope if they don\u0027t\n        declare any names.\n\n        R\u003dacleung\n        DELTA\u003d329  (244 added, 27 deleted, 58 changed)\n\nChange on 2010/05/28 by dcc\n\n        First pass on refactoring FoldConstants into separate peephole optimizations. This changelist adds the notion of an AbstractPeepholeOptimization and adds a PeepholeOptimizationsPass that runs them. In this go around the minimization aspects of FoldConstants have been factored out into PeepholeMinimize. A future change will factor out the other components of FoldConstants into their own PeepholeOptimizations. DefaultPassConfig has also been updated to run the new PeepholeOptimizationPass.\n\n        This change does not move the minimization-related unit tests from FoldConstantsTest to PeepholeMinimizeTest -- a future, separate, change will do so. Hopefully this will make it easier to review.\n\n        R\u003dacleung\n        DELTA\u003d1966  (1271 added, 675 deleted, 20 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d13010\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@235 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "5/29/10, 1:07 PM",
      "commitName": "b4801b28ceea8db0f63da7440d6769cb9b7cce8a",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "4/16/10, 10:20 AM",
      "commitNameOld": "6e3eb4f7619179ba6c23db2af7549ef02f588c35",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 43.12,
      "commitsBetweenForRepo": 36,
      "commitsBetweenForFile": 1,
      "actualSource": "private static Node replaceReturns(Node block, String resultName, String labelName, boolean resultMustBeSet) {\n    Preconditions.checkNotNull(block);\n    Preconditions.checkNotNull(labelName);\n    Node root \u003d block;\n    boolean hasReturnAtExit \u003d false;\n    int returnCount \u003d NodeUtil.getNodeTypeReferenceCount(block, Token.RETURN, new NodeUtil.MatchShallowStatement());\n    if (returnCount \u003e 0) {\n        hasReturnAtExit \u003d hasReturnAtExit(block);\n        if (hasReturnAtExit) {\n            convertLastReturnToStatement(block, resultName);\n            returnCount--;\n        }\n        if (returnCount \u003e 0) {\n            replaceReturnWithBreak(block, null, resultName, labelName);\n            Node label \u003d new Node(Token.LABEL).copyInformationFrom(block);\n            Node name \u003d Node.newString(Token.LABEL_NAME, labelName).copyInformationFrom(block);\n            label.addChildToFront(name);\n            label.addChildToBack(block);\n            Node newRoot \u003d new Node(Token.BLOCK).copyInformationFrom(block);\n            newRoot.addChildrenToBack(label);\n            root \u003d newRoot;\n        }\n    }\n    if (resultMustBeSet \u0026\u0026 !hasReturnAtExit \u0026\u0026 resultName !\u003d null) {\n        addDummyAssignment(block, resultName);\n    }\n    return root;\n}",
      "path": "src/com/google/javascript/jscomp/FunctionToBlockMutator.java",
      "functionStartLine": 240,
      "functionName": "replaceReturns",
      "functionAnnotation": "",
      "functionDoc": " Convert returns to assignments and breaks, as needed.\n For example, with a lableName of \u0027foo\u0027:\n   {\n     return a;\n   }\n becomes:\n   foo: {\n     a;\n     break foo;\n   }\n or\n   foo: {\n     resultName \u003d a;\n     break foo;\n   }\n\n@param resultMustBeSet Whether the result must always be set to a value.\n@return The node containing the transformed block, this may be different\n    than the passed in node \u0027block\u0027.\n",
      "diff": "@@ -1,28 +1,28 @@\n private static Node replaceReturns(Node block, String resultName, String labelName, boolean resultMustBeSet) {\n     Preconditions.checkNotNull(block);\n     Preconditions.checkNotNull(labelName);\n     Node root \u003d block;\n     boolean hasReturnAtExit \u003d false;\n-    int returnCount \u003d NodeUtil.getNodeTypeReferenceCount(block, Token.RETURN);\n+    int returnCount \u003d NodeUtil.getNodeTypeReferenceCount(block, Token.RETURN, new NodeUtil.MatchShallowStatement());\n     if (returnCount \u003e 0) {\n         hasReturnAtExit \u003d hasReturnAtExit(block);\n         if (hasReturnAtExit) {\n             convertLastReturnToStatement(block, resultName);\n             returnCount--;\n         }\n         if (returnCount \u003e 0) {\n             replaceReturnWithBreak(block, null, resultName, labelName);\n             Node label \u003d new Node(Token.LABEL).copyInformationFrom(block);\n             Node name \u003d Node.newString(Token.LABEL_NAME, labelName).copyInformationFrom(block);\n             label.addChildToFront(name);\n             label.addChildToBack(block);\n             Node newRoot \u003d new Node(Token.BLOCK).copyInformationFrom(block);\n             newRoot.addChildrenToBack(label);\n             root \u003d newRoot;\n         }\n     }\n     if (resultMustBeSet \u0026\u0026 !hasReturnAtExit \u0026\u0026 resultName !\u003d null) {\n         addDummyAssignment(block, resultName);\n     }\n     return root;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6e3eb4f7619179ba6c23db2af7549ef02f588c35": {
      "type": "Ybodychange",
      "commitMessage": "\nChange on 2010/04/15 by john\n\n        Maintain source information in OverloadedMethodResolution.\n\n        R\u003dandrew\n        DELTA\u003d8  (5 added, 1 deleted, 2 changed)\n\nChange on 2010/04/15 by john\n\n        Maintain source information during function inlining.\n\n        R\u003dalan\n        DELTA\u003d104  (73 added, 2 deleted, 29 changed)\n\nChange on 2010/04/15 by john\n\n        Improve LineNumberCheck error message.\n\n        R\u003dnick\n        DELTA\u003d4  (3 added, 0 deleted, 1 changed)\n\nChange on 2010/04/15 by john\n\n        Maintain source information in smart name removal.\n        Enabled Normalize during tests, simplified VAR handling.\n\n        R\u003dantonio\n        DELTA\u003d71  (12 added, 48 deleted, 11 changed)\n\nChange on 2010/04/15 by john\n\n        Maintain source information in InlineGetters.\n\n        R\u003dalan\n        DELTA\u003d8  (7 added, 0 deleted, 1 changed)\n\nChange on 2010/04/15 by alan\n\n        Stops the post data from printing multiple times.\n\n        R\u003djohn\n        DELTA\u003d4  (1 added, 0 deleted, 3 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003dhuwaud\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@188 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/16/10, 10:20 AM",
      "commitName": "6e3eb4f7619179ba6c23db2af7549ef02f588c35",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "4/5/10, 12:30 PM",
      "commitNameOld": "222eafd303155b3eac5cd244584b2cb3c4c11975",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 10.91,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "actualSource": "private static Node replaceReturns(Node block, String resultName, String labelName, boolean resultMustBeSet) {\n    Preconditions.checkNotNull(block);\n    Preconditions.checkNotNull(labelName);\n    Node root \u003d block;\n    boolean hasReturnAtExit \u003d false;\n    int returnCount \u003d NodeUtil.getNodeTypeReferenceCount(block, Token.RETURN);\n    if (returnCount \u003e 0) {\n        hasReturnAtExit \u003d hasReturnAtExit(block);\n        if (hasReturnAtExit) {\n            convertLastReturnToStatement(block, resultName);\n            returnCount--;\n        }\n        if (returnCount \u003e 0) {\n            replaceReturnWithBreak(block, null, resultName, labelName);\n            Node label \u003d new Node(Token.LABEL).copyInformationFrom(block);\n            Node name \u003d Node.newString(Token.LABEL_NAME, labelName).copyInformationFrom(block);\n            label.addChildToFront(name);\n            label.addChildToBack(block);\n            Node newRoot \u003d new Node(Token.BLOCK).copyInformationFrom(block);\n            newRoot.addChildrenToBack(label);\n            root \u003d newRoot;\n        }\n    }\n    if (resultMustBeSet \u0026\u0026 !hasReturnAtExit \u0026\u0026 resultName !\u003d null) {\n        addDummyAssignment(block, resultName);\n    }\n    return root;\n}",
      "path": "src/com/google/javascript/jscomp/FunctionToBlockMutator.java",
      "functionStartLine": 240,
      "functionName": "replaceReturns",
      "functionAnnotation": "",
      "functionDoc": " Convert returns to assignments and breaks, as needed.\n For example, with a lableName of \u0027foo\u0027:\n   {\n     return a;\n   }\n becomes:\n   foo: {\n     a;\n     break foo;\n   }\n or\n   foo: {\n     resultName \u003d a;\n     break foo;\n   }\n\n@param resultMustBeSet Whether the result must always be set to a value.\n@return The node containing the transformed block, this may be different\n    than the passed in node \u0027block\u0027.\n",
      "diff": "@@ -1,28 +1,28 @@\n private static Node replaceReturns(Node block, String resultName, String labelName, boolean resultMustBeSet) {\n     Preconditions.checkNotNull(block);\n     Preconditions.checkNotNull(labelName);\n     Node root \u003d block;\n     boolean hasReturnAtExit \u003d false;\n     int returnCount \u003d NodeUtil.getNodeTypeReferenceCount(block, Token.RETURN);\n     if (returnCount \u003e 0) {\n         hasReturnAtExit \u003d hasReturnAtExit(block);\n         if (hasReturnAtExit) {\n             convertLastReturnToStatement(block, resultName);\n             returnCount--;\n         }\n         if (returnCount \u003e 0) {\n             replaceReturnWithBreak(block, null, resultName, labelName);\n-            Node label \u003d new Node(Token.LABEL);\n-            Node name \u003d Node.newString(Token.LABEL_NAME, labelName);\n+            Node label \u003d new Node(Token.LABEL).copyInformationFrom(block);\n+            Node name \u003d Node.newString(Token.LABEL_NAME, labelName).copyInformationFrom(block);\n             label.addChildToFront(name);\n             label.addChildToBack(block);\n-            Node newRoot \u003d new Node(Token.BLOCK);\n+            Node newRoot \u003d new Node(Token.BLOCK).copyInformationFrom(block);\n             newRoot.addChildrenToBack(label);\n             root \u003d newRoot;\n         }\n     }\n     if (resultMustBeSet \u0026\u0026 !hasReturnAtExit \u0026\u0026 resultName !\u003d null) {\n         addDummyAssignment(block, resultName);\n     }\n     return root;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "222eafd303155b3eac5cd244584b2cb3c4c11975": {
      "type": "Ybodychange",
      "commitMessage": "tighten up some types. (Nick)\nR\u003dalan\nDELTA\u003d4  (2 added, 0 deleted, 2 changed)\n\nDon\u0027t use NAME for label names, introduce LABEL_NAME. This improves the correctness of the compiler as many passes don\u0027t distinguish between label names and variable names appropriately. (John)\nR\u003drobert\n\nRemove now unneeded checks for label names when inspecting NAME nodes. (John)\nR\u003drobert\n\nTweak code generator to break after blocks for better pretty printing. (John)\nR\u003drobert\nDELTA\u003d196  (160 added, 0 deleted, 36 changed)\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003dktmses\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@170 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/5/10, 12:30 PM",
      "commitName": "222eafd303155b3eac5cd244584b2cb3c4c11975",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "4/1/10, 7:32 PM",
      "commitNameOld": "f01925cbf7a39a885e51865208368e861d25a0c1",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 3.71,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "private static Node replaceReturns(Node block, String resultName, String labelName, boolean resultMustBeSet) {\n    Preconditions.checkNotNull(block);\n    Preconditions.checkNotNull(labelName);\n    Node root \u003d block;\n    boolean hasReturnAtExit \u003d false;\n    int returnCount \u003d NodeUtil.getNodeTypeReferenceCount(block, Token.RETURN);\n    if (returnCount \u003e 0) {\n        hasReturnAtExit \u003d hasReturnAtExit(block);\n        if (hasReturnAtExit) {\n            convertLastReturnToStatement(block, resultName);\n            returnCount--;\n        }\n        if (returnCount \u003e 0) {\n            replaceReturnWithBreak(block, null, resultName, labelName);\n            Node label \u003d new Node(Token.LABEL);\n            Node name \u003d Node.newString(Token.LABEL_NAME, labelName);\n            label.addChildToFront(name);\n            label.addChildToBack(block);\n            Node newRoot \u003d new Node(Token.BLOCK);\n            newRoot.addChildrenToBack(label);\n            root \u003d newRoot;\n        }\n    }\n    if (resultMustBeSet \u0026\u0026 !hasReturnAtExit \u0026\u0026 resultName !\u003d null) {\n        addDummyAssignment(block, resultName);\n    }\n    return root;\n}",
      "path": "src/com/google/javascript/jscomp/FunctionToBlockMutator.java",
      "functionStartLine": 238,
      "functionName": "replaceReturns",
      "functionAnnotation": "",
      "functionDoc": " Convert returns to assignments and breaks, as needed.\n For example, with a lableName of \u0027foo\u0027:\n   {\n     return a;\n   }\n becomes:\n   foo: {\n     a;\n     break foo;\n   }\n or\n   foo: {\n     resultName \u003d a;\n     break foo;\n   }\n\n@param resultMustBeSet Whether the result must always be set to a value.\n@return The node containing the transformed block, this may be different\n    than the passed in node \u0027block\u0027.\n",
      "diff": "@@ -1,28 +1,28 @@\n private static Node replaceReturns(Node block, String resultName, String labelName, boolean resultMustBeSet) {\n     Preconditions.checkNotNull(block);\n     Preconditions.checkNotNull(labelName);\n     Node root \u003d block;\n     boolean hasReturnAtExit \u003d false;\n     int returnCount \u003d NodeUtil.getNodeTypeReferenceCount(block, Token.RETURN);\n     if (returnCount \u003e 0) {\n         hasReturnAtExit \u003d hasReturnAtExit(block);\n         if (hasReturnAtExit) {\n             convertLastReturnToStatement(block, resultName);\n             returnCount--;\n         }\n         if (returnCount \u003e 0) {\n             replaceReturnWithBreak(block, null, resultName, labelName);\n             Node label \u003d new Node(Token.LABEL);\n-            Node name \u003d Node.newString(Token.NAME, labelName);\n+            Node name \u003d Node.newString(Token.LABEL_NAME, labelName);\n             label.addChildToFront(name);\n             label.addChildToBack(block);\n             Node newRoot \u003d new Node(Token.BLOCK);\n             newRoot.addChildrenToBack(label);\n             root \u003d newRoot;\n         }\n     }\n     if (resultMustBeSet \u0026\u0026 !hasReturnAtExit \u0026\u0026 resultName !\u003d null) {\n         addDummyAssignment(block, resultName);\n     }\n     return root;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f01925cbf7a39a885e51865208368e861d25a0c1": {
      "type": "Ybodychange",
      "commitMessage": "Tests for deps generation (Nick)\nR\u003dandrew\n\nFix for decomposing assignment-ops. (john)\nR\u003dalan\nDELTA\u003d159  (127 added, 21 deleted, 11 changed)\n\nRemove unneeded imports. (John)\nR\u003drobert\nDELTA\u003d2  (0 added, 2 deleted, 0 changed)\n\nAutomated rollback of:\nRemove now unneeded checks for label names when inspecting NAME nodes. (Robert)\nR\u003dAlan\nDELTA\u003d6  (4 added, 0 deleted, 2 changed)\n\nAutomated rollback of:\nDon\u0027t use NAME for label names, introduce LABEL_NAME. This improves the correctness of the compiler as many passes don\u0027t distinguish between label names and variable names appropriately. (Robert)\nR\u003dAlan\nDELTA\u003d57  (12 added, 29 deleted, 16 changed)\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003dgydkaf\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@167 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/1/10, 7:32 PM",
      "commitName": "f01925cbf7a39a885e51865208368e861d25a0c1",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "3/30/10, 9:01 PM",
      "commitNameOld": "8c5eb247cb5361a6ffa2d86aa4c2de17c234bda7",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 1.94,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "private static Node replaceReturns(Node block, String resultName, String labelName, boolean resultMustBeSet) {\n    Preconditions.checkNotNull(block);\n    Preconditions.checkNotNull(labelName);\n    Node root \u003d block;\n    boolean hasReturnAtExit \u003d false;\n    int returnCount \u003d NodeUtil.getNodeTypeReferenceCount(block, Token.RETURN);\n    if (returnCount \u003e 0) {\n        hasReturnAtExit \u003d hasReturnAtExit(block);\n        if (hasReturnAtExit) {\n            convertLastReturnToStatement(block, resultName);\n            returnCount--;\n        }\n        if (returnCount \u003e 0) {\n            replaceReturnWithBreak(block, null, resultName, labelName);\n            Node label \u003d new Node(Token.LABEL);\n            Node name \u003d Node.newString(Token.NAME, labelName);\n            label.addChildToFront(name);\n            label.addChildToBack(block);\n            Node newRoot \u003d new Node(Token.BLOCK);\n            newRoot.addChildrenToBack(label);\n            root \u003d newRoot;\n        }\n    }\n    if (resultMustBeSet \u0026\u0026 !hasReturnAtExit \u0026\u0026 resultName !\u003d null) {\n        addDummyAssignment(block, resultName);\n    }\n    return root;\n}",
      "path": "src/com/google/javascript/jscomp/FunctionToBlockMutator.java",
      "functionStartLine": 238,
      "functionName": "replaceReturns",
      "functionAnnotation": "",
      "functionDoc": " Convert returns to assignments and breaks, as needed.\n For example, with a lableName of \u0027foo\u0027:\n   {\n     return a;\n   }\n becomes:\n   foo: {\n     a;\n     break foo;\n   }\n or\n   foo: {\n     resultName \u003d a;\n     break foo;\n   }\n\n@param resultMustBeSet Whether the result must always be set to a value.\n@return The node containing the transformed block, this may be different\n    than the passed in node \u0027block\u0027.\n",
      "diff": "@@ -1,28 +1,28 @@\n private static Node replaceReturns(Node block, String resultName, String labelName, boolean resultMustBeSet) {\n     Preconditions.checkNotNull(block);\n     Preconditions.checkNotNull(labelName);\n     Node root \u003d block;\n     boolean hasReturnAtExit \u003d false;\n     int returnCount \u003d NodeUtil.getNodeTypeReferenceCount(block, Token.RETURN);\n     if (returnCount \u003e 0) {\n         hasReturnAtExit \u003d hasReturnAtExit(block);\n         if (hasReturnAtExit) {\n             convertLastReturnToStatement(block, resultName);\n             returnCount--;\n         }\n         if (returnCount \u003e 0) {\n             replaceReturnWithBreak(block, null, resultName, labelName);\n             Node label \u003d new Node(Token.LABEL);\n-            Node name \u003d Node.newString(Token.LABEL_NAME, labelName);\n+            Node name \u003d Node.newString(Token.NAME, labelName);\n             label.addChildToFront(name);\n             label.addChildToBack(block);\n             Node newRoot \u003d new Node(Token.BLOCK);\n             newRoot.addChildrenToBack(label);\n             root \u003d newRoot;\n         }\n     }\n     if (resultMustBeSet \u0026\u0026 !hasReturnAtExit \u0026\u0026 resultName !\u003d null) {\n         addDummyAssignment(block, resultName);\n     }\n     return root;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8c5eb247cb5361a6ffa2d86aa4c2de17c234bda7": {
      "type": "Ybodychange",
      "commitMessage": "Refactor how coding conventions are set (Nick)\nR\u003dalan\n\nDon\u0027t use NAME for label names, introduce LABEL_NAME. This improves\nthe correctness of the compiler as many passes don\u0027t distinguish\nbetween label names and variable names appropriately. (John)\nR\u003drobert\nDELTA\u003d57  (29 added, 12 deleted, 16 changed)\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@163 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "3/30/10, 9:01 PM",
      "commitName": "8c5eb247cb5361a6ffa2d86aa4c2de17c234bda7",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "3/15/10, 3:46 PM",
      "commitNameOld": "3df1d1eeb4a5868e5331ee98fb6748a2f1ccedba",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 15.22,
      "commitsBetweenForRepo": 27,
      "commitsBetweenForFile": 1,
      "actualSource": "private static Node replaceReturns(Node block, String resultName, String labelName, boolean resultMustBeSet) {\n    Preconditions.checkNotNull(block);\n    Preconditions.checkNotNull(labelName);\n    Node root \u003d block;\n    boolean hasReturnAtExit \u003d false;\n    int returnCount \u003d NodeUtil.getNodeTypeReferenceCount(block, Token.RETURN);\n    if (returnCount \u003e 0) {\n        hasReturnAtExit \u003d hasReturnAtExit(block);\n        if (hasReturnAtExit) {\n            convertLastReturnToStatement(block, resultName);\n            returnCount--;\n        }\n        if (returnCount \u003e 0) {\n            replaceReturnWithBreak(block, null, resultName, labelName);\n            Node label \u003d new Node(Token.LABEL);\n            Node name \u003d Node.newString(Token.LABEL_NAME, labelName);\n            label.addChildToFront(name);\n            label.addChildToBack(block);\n            Node newRoot \u003d new Node(Token.BLOCK);\n            newRoot.addChildrenToBack(label);\n            root \u003d newRoot;\n        }\n    }\n    if (resultMustBeSet \u0026\u0026 !hasReturnAtExit \u0026\u0026 resultName !\u003d null) {\n        addDummyAssignment(block, resultName);\n    }\n    return root;\n}",
      "path": "src/com/google/javascript/jscomp/FunctionToBlockMutator.java",
      "functionStartLine": 238,
      "functionName": "replaceReturns",
      "functionAnnotation": "",
      "functionDoc": " Convert returns to assignments and breaks, as needed.\n For example, with a lableName of \u0027foo\u0027:\n   {\n     return a;\n   }\n becomes:\n   foo: {\n     a;\n     break foo;\n   }\n or\n   foo: {\n     resultName \u003d a;\n     break foo;\n   }\n\n@param resultMustBeSet Whether the result must always be set to a value.\n@return The node containing the transformed block, this may be different\n    than the passed in node \u0027block\u0027.\n",
      "diff": "@@ -1,28 +1,28 @@\n private static Node replaceReturns(Node block, String resultName, String labelName, boolean resultMustBeSet) {\n     Preconditions.checkNotNull(block);\n     Preconditions.checkNotNull(labelName);\n     Node root \u003d block;\n     boolean hasReturnAtExit \u003d false;\n     int returnCount \u003d NodeUtil.getNodeTypeReferenceCount(block, Token.RETURN);\n     if (returnCount \u003e 0) {\n         hasReturnAtExit \u003d hasReturnAtExit(block);\n         if (hasReturnAtExit) {\n             convertLastReturnToStatement(block, resultName);\n             returnCount--;\n         }\n         if (returnCount \u003e 0) {\n             replaceReturnWithBreak(block, null, resultName, labelName);\n             Node label \u003d new Node(Token.LABEL);\n-            Node name \u003d Node.newString(Token.NAME, labelName);\n+            Node name \u003d Node.newString(Token.LABEL_NAME, labelName);\n             label.addChildToFront(name);\n             label.addChildToBack(block);\n             Node newRoot \u003d new Node(Token.BLOCK);\n             newRoot.addChildrenToBack(label);\n             root \u003d newRoot;\n         }\n     }\n     if (resultMustBeSet \u0026\u0026 !hasReturnAtExit \u0026\u0026 resultName !\u003d null) {\n         addDummyAssignment(block, resultName);\n     }\n     return root;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": {
      "type": "Yintroduced",
      "commitMessage": "Initial commit.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/3/09, 3:51 PM",
      "commitName": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "diff": "@@ -0,0 +1,28 @@\n+private static Node replaceReturns(Node block, String resultName, String labelName, boolean resultMustBeSet) {\n+    Preconditions.checkNotNull(block);\n+    Preconditions.checkNotNull(labelName);\n+    Node root \u003d block;\n+    boolean hasReturnAtExit \u003d false;\n+    int returnCount \u003d NodeUtil.getNodeTypeReferenceCount(block, Token.RETURN);\n+    if (returnCount \u003e 0) {\n+        hasReturnAtExit \u003d hasReturnAtExit(block);\n+        if (hasReturnAtExit) {\n+            convertLastReturnToStatement(block, resultName);\n+            returnCount--;\n+        }\n+        if (returnCount \u003e 0) {\n+            replaceReturnWithBreak(block, null, resultName, labelName);\n+            Node label \u003d new Node(Token.LABEL);\n+            Node name \u003d Node.newString(Token.NAME, labelName);\n+            label.addChildToFront(name);\n+            label.addChildToBack(block);\n+            Node newRoot \u003d new Node(Token.BLOCK);\n+            newRoot.addChildrenToBack(label);\n+            root \u003d newRoot;\n+        }\n+    }\n+    if (resultMustBeSet \u0026\u0026 !hasReturnAtExit \u0026\u0026 resultName !\u003d null) {\n+        addDummyAssignment(block, resultName);\n+    }\n+    return root;\n+}\n\\ No newline at end of file\n",
      "actualSource": "private static Node replaceReturns(Node block, String resultName, String labelName, boolean resultMustBeSet) {\n    Preconditions.checkNotNull(block);\n    Preconditions.checkNotNull(labelName);\n    Node root \u003d block;\n    boolean hasReturnAtExit \u003d false;\n    int returnCount \u003d NodeUtil.getNodeTypeReferenceCount(block, Token.RETURN);\n    if (returnCount \u003e 0) {\n        hasReturnAtExit \u003d hasReturnAtExit(block);\n        if (hasReturnAtExit) {\n            convertLastReturnToStatement(block, resultName);\n            returnCount--;\n        }\n        if (returnCount \u003e 0) {\n            replaceReturnWithBreak(block, null, resultName, labelName);\n            Node label \u003d new Node(Token.LABEL);\n            Node name \u003d Node.newString(Token.NAME, labelName);\n            label.addChildToFront(name);\n            label.addChildToBack(block);\n            Node newRoot \u003d new Node(Token.BLOCK);\n            newRoot.addChildrenToBack(label);\n            root \u003d newRoot;\n        }\n    }\n    if (resultMustBeSet \u0026\u0026 !hasReturnAtExit \u0026\u0026 resultName !\u003d null) {\n        addDummyAssignment(block, resultName);\n    }\n    return root;\n}",
      "path": "src/com/google/javascript/jscomp/FunctionToBlockMutator.java",
      "functionStartLine": 238,
      "functionName": "replaceReturns",
      "functionAnnotation": "",
      "functionDoc": " Convert returns to assignments and breaks, as needed.\n For example, with a lableName of \u0027foo\u0027:\n   {\n     return a;\n   }\n becomes:\n   foo: {\n     a;\n     break foo;\n   }\n or\n   foo: {\n     resultName \u003d a;\n     break foo;\n   }\n\n@param resultMustBeSet Whether the result must always be set to a value.\n@return The node containing the transformed block, this may be different\n    than the passed in node \u0027block\u0027.\n"
    }
  }
}