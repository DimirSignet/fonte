{
  "origin": "codeshovel",
  "repositoryName": "Closure-115b",
  "repositoryPath": "/tmp/Closure-115b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FunctionToBlockMutator.java",
  "functionName": "aliasAndInlineArguments",
  "functionId": "aliasAndInlineArguments___fnTemplateRoot-Node__argMap-LinkedHashMap__String,Node____namesToAlias-Set__String__",
  "sourceFilePath": "src/com/google/javascript/jscomp/FunctionToBlockMutator.java",
  "functionAnnotation": "",
  "functionDoc": "Inlines the arguments within the node tree using the given argument map,\nreplaces \"unsafe\" names with local aliases.\n\nThe aliases for unsafe require new VAR declarations, so this function\ncan not be used in for direct CALL node replacement as VAR nodes can not be\ncreated there.\n\n@return The node or its replacement.\n",
  "functionStartLine": 230,
  "functionEndLine": 300,
  "numCommitsSeen": 26,
  "timeTaken": 1527,
  "changeHistory": [
    "9dfbc803407e714f9744555a1c9e7c4230f1816d",
    "39f629a8cfaab37da55288010640d7e516000b1f",
    "cc4ec1a70e6fa02bda751582c3902b3c19f85bbb",
    "dd5a73fdb8740d4753a2c08efaa9eb56932943a0",
    "51e81d0fd794bee6d8765513f853a312f176dcd7",
    "6e3eb4f7619179ba6c23db2af7549ef02f588c35",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3"
  ],
  "changeHistoryShort": {
    "9dfbc803407e714f9744555a1c9e7c4230f1816d": "Ybodychange",
    "39f629a8cfaab37da55288010640d7e516000b1f": "Ybodychange",
    "cc4ec1a70e6fa02bda751582c3902b3c19f85bbb": "Ybodychange",
    "dd5a73fdb8740d4753a2c08efaa9eb56932943a0": "Ybodychange",
    "51e81d0fd794bee6d8765513f853a312f176dcd7": "Ybodychange",
    "6e3eb4f7619179ba6c23db2af7549ef02f588c35": "Ybodychange",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "9dfbc803407e714f9744555a1c9e7c4230f1816d": {
      "type": "Ybodychange",
      "commitMessage": "\nUse the new IR interface where possible.\n\nR\u003dnicksantos\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3799\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1641 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/22/11, 2:28 PM",
      "commitName": "9dfbc803407e714f9744555a1c9e7c4230f1816d",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "11/14/11, 6:13 PM",
      "commitNameOld": "39f629a8cfaab37da55288010640d7e516000b1f",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 7.84,
      "commitsBetweenForRepo": 31,
      "commitsBetweenForFile": 1,
      "actualSource": "private Node aliasAndInlineArguments(Node fnTemplateRoot, LinkedHashMap\u003cString, Node\u003e argMap, Set\u003cString\u003e namesToAlias) {\n    if (namesToAlias \u003d\u003d null || namesToAlias.isEmpty()) {\n        Node result \u003d FunctionArgumentInjector.inject(compiler, fnTemplateRoot, null, argMap);\n        Preconditions.checkState(result \u003d\u003d fnTemplateRoot);\n        return result;\n    } else {\n        Map\u003cString, Node\u003e newArgMap \u003d Maps.newHashMap(argMap);\n        List\u003cNode\u003e newVars \u003d Lists.newLinkedList();\n        for (Entry\u003cString, Node\u003e entry : argMap.entrySet()) {\n            String name \u003d entry.getKey();\n            if (namesToAlias.contains(name)) {\n                if (name.equals(THIS_MARKER)) {\n                    boolean referencesThis \u003d NodeUtil.referencesThis(fnTemplateRoot);\n                    Node value \u003d entry.getValue();\n                    if (!value.isThis() \u0026\u0026 (referencesThis || NodeUtil.mayHaveSideEffects(value, compiler))) {\n                        String newName \u003d getUniqueThisName();\n                        Node newValue \u003d entry.getValue().cloneTree();\n                        Node newNode \u003d NodeUtil.newVarNode(newName, newValue).copyInformationFromForTree(newValue);\n                        newVars.add(0, newNode);\n                        newArgMap.put(THIS_MARKER, IR.name(newName).srcrefTree(newValue));\n                    }\n                } else {\n                    Node newValue \u003d entry.getValue().cloneTree();\n                    Node newNode \u003d NodeUtil.newVarNode(name, newValue).copyInformationFromForTree(newValue);\n                    newVars.add(0, newNode);\n                    newArgMap.remove(name);\n                }\n            }\n        }\n        Node result \u003d FunctionArgumentInjector.inject(compiler, fnTemplateRoot, null, newArgMap);\n        Preconditions.checkState(result \u003d\u003d fnTemplateRoot);\n        for (Node n : newVars) {\n            fnTemplateRoot.addChildToFront(n);\n        }\n        return result;\n    }\n}",
      "path": "src/com/google/javascript/jscomp/FunctionToBlockMutator.java",
      "functionStartLine": 229,
      "functionName": "aliasAndInlineArguments",
      "functionAnnotation": "",
      "functionDoc": "Inlines the arguments within the node tree using the given argument map,\nreplaces \"unsafe\" names with local aliases.\n\nThe aliases for unsafe require new VAR declarations, so this function\ncan not be used in for direct CALL node replacement as VAR nodes can not be\ncreated there.\n\n@return The node or its replacement.\n",
      "diff": "@@ -1,37 +1,37 @@\n private Node aliasAndInlineArguments(Node fnTemplateRoot, LinkedHashMap\u003cString, Node\u003e argMap, Set\u003cString\u003e namesToAlias) {\n     if (namesToAlias \u003d\u003d null || namesToAlias.isEmpty()) {\n         Node result \u003d FunctionArgumentInjector.inject(compiler, fnTemplateRoot, null, argMap);\n         Preconditions.checkState(result \u003d\u003d fnTemplateRoot);\n         return result;\n     } else {\n         Map\u003cString, Node\u003e newArgMap \u003d Maps.newHashMap(argMap);\n         List\u003cNode\u003e newVars \u003d Lists.newLinkedList();\n         for (Entry\u003cString, Node\u003e entry : argMap.entrySet()) {\n             String name \u003d entry.getKey();\n             if (namesToAlias.contains(name)) {\n                 if (name.equals(THIS_MARKER)) {\n                     boolean referencesThis \u003d NodeUtil.referencesThis(fnTemplateRoot);\n                     Node value \u003d entry.getValue();\n                     if (!value.isThis() \u0026\u0026 (referencesThis || NodeUtil.mayHaveSideEffects(value, compiler))) {\n                         String newName \u003d getUniqueThisName();\n                         Node newValue \u003d entry.getValue().cloneTree();\n                         Node newNode \u003d NodeUtil.newVarNode(newName, newValue).copyInformationFromForTree(newValue);\n                         newVars.add(0, newNode);\n-                        newArgMap.put(THIS_MARKER, Node.newString(Token.NAME, newName).copyInformationFromForTree(newValue));\n+                        newArgMap.put(THIS_MARKER, IR.name(newName).srcrefTree(newValue));\n                     }\n                 } else {\n                     Node newValue \u003d entry.getValue().cloneTree();\n                     Node newNode \u003d NodeUtil.newVarNode(name, newValue).copyInformationFromForTree(newValue);\n                     newVars.add(0, newNode);\n                     newArgMap.remove(name);\n                 }\n             }\n         }\n         Node result \u003d FunctionArgumentInjector.inject(compiler, fnTemplateRoot, null, newArgMap);\n         Preconditions.checkState(result \u003d\u003d fnTemplateRoot);\n         for (Node n : newVars) {\n             fnTemplateRoot.addChildToFront(n);\n         }\n         return result;\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "39f629a8cfaab37da55288010640d7e516000b1f": {
      "type": "Ybodychange",
      "commitMessage": "\nReplace calls of the form \"Node.getType() !\u003d Token.XX\" with\n\"!Node.isXX()\" calls.\n\nR\u003dnicksantos\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3706\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1598 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/14/11, 6:13 PM",
      "commitName": "39f629a8cfaab37da55288010640d7e516000b1f",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "11/10/11, 8:36 AM",
      "commitNameOld": "ec324a9bb23eb78c76f537f4c4170ba88d542f1c",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 4.4,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "actualSource": "private Node aliasAndInlineArguments(Node fnTemplateRoot, LinkedHashMap\u003cString, Node\u003e argMap, Set\u003cString\u003e namesToAlias) {\n    if (namesToAlias \u003d\u003d null || namesToAlias.isEmpty()) {\n        Node result \u003d FunctionArgumentInjector.inject(compiler, fnTemplateRoot, null, argMap);\n        Preconditions.checkState(result \u003d\u003d fnTemplateRoot);\n        return result;\n    } else {\n        Map\u003cString, Node\u003e newArgMap \u003d Maps.newHashMap(argMap);\n        List\u003cNode\u003e newVars \u003d Lists.newLinkedList();\n        for (Entry\u003cString, Node\u003e entry : argMap.entrySet()) {\n            String name \u003d entry.getKey();\n            if (namesToAlias.contains(name)) {\n                if (name.equals(THIS_MARKER)) {\n                    boolean referencesThis \u003d NodeUtil.referencesThis(fnTemplateRoot);\n                    Node value \u003d entry.getValue();\n                    if (!value.isThis() \u0026\u0026 (referencesThis || NodeUtil.mayHaveSideEffects(value, compiler))) {\n                        String newName \u003d getUniqueThisName();\n                        Node newValue \u003d entry.getValue().cloneTree();\n                        Node newNode \u003d NodeUtil.newVarNode(newName, newValue).copyInformationFromForTree(newValue);\n                        newVars.add(0, newNode);\n                        newArgMap.put(THIS_MARKER, Node.newString(Token.NAME, newName).copyInformationFromForTree(newValue));\n                    }\n                } else {\n                    Node newValue \u003d entry.getValue().cloneTree();\n                    Node newNode \u003d NodeUtil.newVarNode(name, newValue).copyInformationFromForTree(newValue);\n                    newVars.add(0, newNode);\n                    newArgMap.remove(name);\n                }\n            }\n        }\n        Node result \u003d FunctionArgumentInjector.inject(compiler, fnTemplateRoot, null, newArgMap);\n        Preconditions.checkState(result \u003d\u003d fnTemplateRoot);\n        for (Node n : newVars) {\n            fnTemplateRoot.addChildToFront(n);\n        }\n        return result;\n    }\n}",
      "path": "src/com/google/javascript/jscomp/FunctionToBlockMutator.java",
      "functionStartLine": 230,
      "functionName": "aliasAndInlineArguments",
      "functionAnnotation": "",
      "functionDoc": "Inlines the arguments within the node tree using the given argument map,\nreplaces \"unsafe\" names with local aliases.\n\nThe aliases for unsafe require new VAR declarations, so this function\ncan not be used in for direct CALL node replacement as VAR nodes can not be\ncreated there.\n\n@return The node or its replacement.\n",
      "diff": "@@ -1,37 +1,37 @@\n private Node aliasAndInlineArguments(Node fnTemplateRoot, LinkedHashMap\u003cString, Node\u003e argMap, Set\u003cString\u003e namesToAlias) {\n     if (namesToAlias \u003d\u003d null || namesToAlias.isEmpty()) {\n         Node result \u003d FunctionArgumentInjector.inject(compiler, fnTemplateRoot, null, argMap);\n         Preconditions.checkState(result \u003d\u003d fnTemplateRoot);\n         return result;\n     } else {\n         Map\u003cString, Node\u003e newArgMap \u003d Maps.newHashMap(argMap);\n         List\u003cNode\u003e newVars \u003d Lists.newLinkedList();\n         for (Entry\u003cString, Node\u003e entry : argMap.entrySet()) {\n             String name \u003d entry.getKey();\n             if (namesToAlias.contains(name)) {\n                 if (name.equals(THIS_MARKER)) {\n                     boolean referencesThis \u003d NodeUtil.referencesThis(fnTemplateRoot);\n                     Node value \u003d entry.getValue();\n-                    if (value.getType() !\u003d Token.THIS \u0026\u0026 (referencesThis || NodeUtil.mayHaveSideEffects(value, compiler))) {\n+                    if (!value.isThis() \u0026\u0026 (referencesThis || NodeUtil.mayHaveSideEffects(value, compiler))) {\n                         String newName \u003d getUniqueThisName();\n                         Node newValue \u003d entry.getValue().cloneTree();\n                         Node newNode \u003d NodeUtil.newVarNode(newName, newValue).copyInformationFromForTree(newValue);\n                         newVars.add(0, newNode);\n                         newArgMap.put(THIS_MARKER, Node.newString(Token.NAME, newName).copyInformationFromForTree(newValue));\n                     }\n                 } else {\n                     Node newValue \u003d entry.getValue().cloneTree();\n                     Node newNode \u003d NodeUtil.newVarNode(name, newValue).copyInformationFromForTree(newValue);\n                     newVars.add(0, newNode);\n                     newArgMap.remove(name);\n                 }\n             }\n         }\n         Node result \u003d FunctionArgumentInjector.inject(compiler, fnTemplateRoot, null, newArgMap);\n         Preconditions.checkState(result \u003d\u003d fnTemplateRoot);\n         for (Node n : newVars) {\n             fnTemplateRoot.addChildToFront(n);\n         }\n         return result;\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "cc4ec1a70e6fa02bda751582c3902b3c19f85bbb": {
      "type": "Ybodychange",
      "commitMessage": "\nAutomated g4 rollback.\n\n*** Reason for rollback ***\n\nFixed invalid \"this\" replacement within inner functions.\n\n*** Original change description ***\n\nAutomated g4 rollback.\n\n*** Reason for rollback ***\n\nBreaks things\n\n*** Original change description ***\n\nWhen it is possible to make the ES5 Strict mode assumptions about a\nfunction\u0027s \"this\" it is easier to inline a function referencing \"this\".\nAdd \"CompilerOption.assumeStrictThis\" and take advantage of it during\nfunction inlining.\n\nR\u003dmoedinger\nDELTA\u003d263  (223 added, 4 deleted, 36 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d2320\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1188 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "6/16/11, 5:29 PM",
      "commitName": "cc4ec1a70e6fa02bda751582c3902b3c19f85bbb",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "6/7/11, 10:32 AM",
      "commitNameOld": "dd5a73fdb8740d4753a2c08efaa9eb56932943a0",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 9.29,
      "commitsBetweenForRepo": 22,
      "commitsBetweenForFile": 1,
      "actualSource": "private Node aliasAndInlineArguments(Node fnTemplateRoot, LinkedHashMap\u003cString, Node\u003e argMap, Set\u003cString\u003e namesToAlias) {\n    if (namesToAlias \u003d\u003d null || namesToAlias.isEmpty()) {\n        Node result \u003d FunctionArgumentInjector.inject(compiler, fnTemplateRoot, null, argMap);\n        Preconditions.checkState(result \u003d\u003d fnTemplateRoot);\n        return result;\n    } else {\n        Map\u003cString, Node\u003e newArgMap \u003d Maps.newHashMap(argMap);\n        List\u003cNode\u003e newVars \u003d Lists.newLinkedList();\n        for (Entry\u003cString, Node\u003e entry : argMap.entrySet()) {\n            String name \u003d entry.getKey();\n            if (namesToAlias.contains(name)) {\n                if (name.equals(THIS_MARKER)) {\n                    boolean referencesThis \u003d NodeUtil.referencesThis(fnTemplateRoot);\n                    Node value \u003d entry.getValue();\n                    if (value.getType() !\u003d Token.THIS \u0026\u0026 (referencesThis || NodeUtil.mayHaveSideEffects(value, compiler))) {\n                        String newName \u003d getUniqueThisName();\n                        Node newValue \u003d entry.getValue().cloneTree();\n                        Node newNode \u003d NodeUtil.newVarNode(newName, newValue).copyInformationFromForTree(newValue);\n                        newVars.add(0, newNode);\n                        newArgMap.put(THIS_MARKER, Node.newString(Token.NAME, newName).copyInformationFromForTree(newValue));\n                    }\n                } else {\n                    Node newValue \u003d entry.getValue().cloneTree();\n                    Node newNode \u003d NodeUtil.newVarNode(name, newValue).copyInformationFromForTree(newValue);\n                    newVars.add(0, newNode);\n                    newArgMap.remove(name);\n                }\n            }\n        }\n        Node result \u003d FunctionArgumentInjector.inject(compiler, fnTemplateRoot, null, newArgMap);\n        Preconditions.checkState(result \u003d\u003d fnTemplateRoot);\n        for (Node n : newVars) {\n            fnTemplateRoot.addChildToFront(n);\n        }\n        return result;\n    }\n}",
      "path": "src/com/google/javascript/jscomp/FunctionToBlockMutator.java",
      "functionStartLine": 196,
      "functionName": "aliasAndInlineArguments",
      "functionAnnotation": "",
      "functionDoc": "Inlines the arguments within the node tree using the given argument map,\nreplaces \"unsafe\" names with local aliases.\n\nThe aliases for unsafe require new VAR declarations, so this function\ncan not be used in for direct CALL node replacement as VAR nodes can not be\ncreated there.\n\n@return The node or its replacement.\n",
      "diff": "@@ -1,25 +1,37 @@\n private Node aliasAndInlineArguments(Node fnTemplateRoot, LinkedHashMap\u003cString, Node\u003e argMap, Set\u003cString\u003e namesToAlias) {\n     if (namesToAlias \u003d\u003d null || namesToAlias.isEmpty()) {\n-        Node result \u003d FunctionArgumentInjector.inject(fnTemplateRoot, null, argMap);\n+        Node result \u003d FunctionArgumentInjector.inject(compiler, fnTemplateRoot, null, argMap);\n         Preconditions.checkState(result \u003d\u003d fnTemplateRoot);\n         return result;\n     } else {\n         Map\u003cString, Node\u003e newArgMap \u003d Maps.newHashMap(argMap);\n         List\u003cNode\u003e newVars \u003d Lists.newLinkedList();\n         for (Entry\u003cString, Node\u003e entry : argMap.entrySet()) {\n             String name \u003d entry.getKey();\n             if (namesToAlias.contains(name)) {\n-                Node newValue \u003d entry.getValue().cloneTree();\n-                Node newNode \u003d NodeUtil.newVarNode(name, newValue).copyInformationFromForTree(newValue);\n-                newVars.add(0, newNode);\n-                newArgMap.remove(name);\n+                if (name.equals(THIS_MARKER)) {\n+                    boolean referencesThis \u003d NodeUtil.referencesThis(fnTemplateRoot);\n+                    Node value \u003d entry.getValue();\n+                    if (value.getType() !\u003d Token.THIS \u0026\u0026 (referencesThis || NodeUtil.mayHaveSideEffects(value, compiler))) {\n+                        String newName \u003d getUniqueThisName();\n+                        Node newValue \u003d entry.getValue().cloneTree();\n+                        Node newNode \u003d NodeUtil.newVarNode(newName, newValue).copyInformationFromForTree(newValue);\n+                        newVars.add(0, newNode);\n+                        newArgMap.put(THIS_MARKER, Node.newString(Token.NAME, newName).copyInformationFromForTree(newValue));\n+                    }\n+                } else {\n+                    Node newValue \u003d entry.getValue().cloneTree();\n+                    Node newNode \u003d NodeUtil.newVarNode(name, newValue).copyInformationFromForTree(newValue);\n+                    newVars.add(0, newNode);\n+                    newArgMap.remove(name);\n+                }\n             }\n         }\n-        Node result \u003d FunctionArgumentInjector.inject(fnTemplateRoot, null, newArgMap);\n+        Node result \u003d FunctionArgumentInjector.inject(compiler, fnTemplateRoot, null, newArgMap);\n         Preconditions.checkState(result \u003d\u003d fnTemplateRoot);\n         for (Node n : newVars) {\n             fnTemplateRoot.addChildToFront(n);\n         }\n         return result;\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "dd5a73fdb8740d4753a2c08efaa9eb56932943a0": {
      "type": "Ybodychange",
      "commitMessage": "\nAutomated g4 rollback.\n\n*** Reason for rollback ***\n\nBreaks gmail\n\n*** Original change description ***\n\nWhen it is possible to make the ES5 Strict mode assumptions about a\nfunction\u0027s \"this\" it is easier to inline a function referencing \"this\".\nAdd \"CompilerOption.assumeStrictThis\" and take advantage of it during\nfunction inlining.\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d2200\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1165 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "6/7/11, 10:32 AM",
      "commitName": "dd5a73fdb8740d4753a2c08efaa9eb56932943a0",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "6/7/11, 9:49 AM",
      "commitNameOld": "51e81d0fd794bee6d8765513f853a312f176dcd7",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private Node aliasAndInlineArguments(Node fnTemplateRoot, LinkedHashMap\u003cString, Node\u003e argMap, Set\u003cString\u003e namesToAlias) {\n    if (namesToAlias \u003d\u003d null || namesToAlias.isEmpty()) {\n        Node result \u003d FunctionArgumentInjector.inject(fnTemplateRoot, null, argMap);\n        Preconditions.checkState(result \u003d\u003d fnTemplateRoot);\n        return result;\n    } else {\n        Map\u003cString, Node\u003e newArgMap \u003d Maps.newHashMap(argMap);\n        List\u003cNode\u003e newVars \u003d Lists.newLinkedList();\n        for (Entry\u003cString, Node\u003e entry : argMap.entrySet()) {\n            String name \u003d entry.getKey();\n            if (namesToAlias.contains(name)) {\n                Node newValue \u003d entry.getValue().cloneTree();\n                Node newNode \u003d NodeUtil.newVarNode(name, newValue).copyInformationFromForTree(newValue);\n                newVars.add(0, newNode);\n                newArgMap.remove(name);\n            }\n        }\n        Node result \u003d FunctionArgumentInjector.inject(fnTemplateRoot, null, newArgMap);\n        Preconditions.checkState(result \u003d\u003d fnTemplateRoot);\n        for (Node n : newVars) {\n            fnTemplateRoot.addChildToFront(n);\n        }\n        return result;\n    }\n}",
      "path": "src/com/google/javascript/jscomp/FunctionToBlockMutator.java",
      "functionStartLine": 187,
      "functionName": "aliasAndInlineArguments",
      "functionAnnotation": "",
      "functionDoc": "Inlines the arguments within the node tree using the given argument map,\nreplaces \"unsafe\" names with local aliases.\n\nThe aliases for unsafe require new VAR declarations, so this function\ncan not be used in for direct CALL node replacement as VAR nodes can not be\ncreated there.\n\n@return The node or its replacement.\n",
      "diff": "@@ -1,37 +1,25 @@\n private Node aliasAndInlineArguments(Node fnTemplateRoot, LinkedHashMap\u003cString, Node\u003e argMap, Set\u003cString\u003e namesToAlias) {\n     if (namesToAlias \u003d\u003d null || namesToAlias.isEmpty()) {\n-        Node result \u003d FunctionArgumentInjector.inject(compiler, fnTemplateRoot, null, argMap);\n+        Node result \u003d FunctionArgumentInjector.inject(fnTemplateRoot, null, argMap);\n         Preconditions.checkState(result \u003d\u003d fnTemplateRoot);\n         return result;\n     } else {\n         Map\u003cString, Node\u003e newArgMap \u003d Maps.newHashMap(argMap);\n         List\u003cNode\u003e newVars \u003d Lists.newLinkedList();\n         for (Entry\u003cString, Node\u003e entry : argMap.entrySet()) {\n             String name \u003d entry.getKey();\n             if (namesToAlias.contains(name)) {\n-                if (name.equals(THIS_MARKER)) {\n-                    boolean referencesThis \u003d NodeUtil.referencesThis(fnTemplateRoot);\n-                    Node value \u003d entry.getValue();\n-                    if (value.getType() !\u003d Token.THIS \u0026\u0026 (referencesThis || NodeUtil.mayHaveSideEffects(value, compiler))) {\n-                        String newName \u003d getUniqueThisName();\n-                        Node newValue \u003d entry.getValue().cloneTree();\n-                        Node newNode \u003d NodeUtil.newVarNode(newName, newValue).copyInformationFromForTree(newValue);\n-                        newVars.add(0, newNode);\n-                        newArgMap.put(THIS_MARKER, Node.newString(Token.NAME, newName).copyInformationFromForTree(newValue));\n-                    }\n-                } else {\n-                    Node newValue \u003d entry.getValue().cloneTree();\n-                    Node newNode \u003d NodeUtil.newVarNode(name, newValue).copyInformationFromForTree(newValue);\n-                    newVars.add(0, newNode);\n-                    newArgMap.remove(name);\n-                }\n+                Node newValue \u003d entry.getValue().cloneTree();\n+                Node newNode \u003d NodeUtil.newVarNode(name, newValue).copyInformationFromForTree(newValue);\n+                newVars.add(0, newNode);\n+                newArgMap.remove(name);\n             }\n         }\n-        Node result \u003d FunctionArgumentInjector.inject(compiler, fnTemplateRoot, null, newArgMap);\n+        Node result \u003d FunctionArgumentInjector.inject(fnTemplateRoot, null, newArgMap);\n         Preconditions.checkState(result \u003d\u003d fnTemplateRoot);\n         for (Node n : newVars) {\n             fnTemplateRoot.addChildToFront(n);\n         }\n         return result;\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "51e81d0fd794bee6d8765513f853a312f176dcd7": {
      "type": "Ybodychange",
      "commitMessage": "\nWhen it is possible to make the ES5 Strict mode assumptions about a\nfunction\u0027s \"this\" it is easier to inline a function referencing \"this\".\nAdd \"CompilerOption.assumeStrictThis\" and take advantage of it during\nfunction inlining.\n\nR\u003dacleung\nDELTA\u003d243  (204 added, 4 deleted, 35 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d2199\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1164 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "6/7/11, 9:49 AM",
      "commitName": "51e81d0fd794bee6d8765513f853a312f176dcd7",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "5/2/11, 1:12 PM",
      "commitNameOld": "e323b879de2e53e5eedf6e7afb0d582382c6248d",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 35.86,
      "commitsBetweenForRepo": 110,
      "commitsBetweenForFile": 1,
      "actualSource": "private Node aliasAndInlineArguments(Node fnTemplateRoot, LinkedHashMap\u003cString, Node\u003e argMap, Set\u003cString\u003e namesToAlias) {\n    if (namesToAlias \u003d\u003d null || namesToAlias.isEmpty()) {\n        Node result \u003d FunctionArgumentInjector.inject(compiler, fnTemplateRoot, null, argMap);\n        Preconditions.checkState(result \u003d\u003d fnTemplateRoot);\n        return result;\n    } else {\n        Map\u003cString, Node\u003e newArgMap \u003d Maps.newHashMap(argMap);\n        List\u003cNode\u003e newVars \u003d Lists.newLinkedList();\n        for (Entry\u003cString, Node\u003e entry : argMap.entrySet()) {\n            String name \u003d entry.getKey();\n            if (namesToAlias.contains(name)) {\n                if (name.equals(THIS_MARKER)) {\n                    boolean referencesThis \u003d NodeUtil.referencesThis(fnTemplateRoot);\n                    Node value \u003d entry.getValue();\n                    if (value.getType() !\u003d Token.THIS \u0026\u0026 (referencesThis || NodeUtil.mayHaveSideEffects(value, compiler))) {\n                        String newName \u003d getUniqueThisName();\n                        Node newValue \u003d entry.getValue().cloneTree();\n                        Node newNode \u003d NodeUtil.newVarNode(newName, newValue).copyInformationFromForTree(newValue);\n                        newVars.add(0, newNode);\n                        newArgMap.put(THIS_MARKER, Node.newString(Token.NAME, newName).copyInformationFromForTree(newValue));\n                    }\n                } else {\n                    Node newValue \u003d entry.getValue().cloneTree();\n                    Node newNode \u003d NodeUtil.newVarNode(name, newValue).copyInformationFromForTree(newValue);\n                    newVars.add(0, newNode);\n                    newArgMap.remove(name);\n                }\n            }\n        }\n        Node result \u003d FunctionArgumentInjector.inject(compiler, fnTemplateRoot, null, newArgMap);\n        Preconditions.checkState(result \u003d\u003d fnTemplateRoot);\n        for (Node n : newVars) {\n            fnTemplateRoot.addChildToFront(n);\n        }\n        return result;\n    }\n}",
      "path": "src/com/google/javascript/jscomp/FunctionToBlockMutator.java",
      "functionStartLine": 196,
      "functionName": "aliasAndInlineArguments",
      "functionAnnotation": "",
      "functionDoc": "Inlines the arguments within the node tree using the given argument map,\nreplaces \"unsafe\" names with local aliases.\n\nThe aliases for unsafe require new VAR declarations, so this function\ncan not be used in for direct CALL node replacement as VAR nodes can not be\ncreated there.\n\n@return The node or its replacement.\n",
      "diff": "@@ -1,25 +1,37 @@\n private Node aliasAndInlineArguments(Node fnTemplateRoot, LinkedHashMap\u003cString, Node\u003e argMap, Set\u003cString\u003e namesToAlias) {\n     if (namesToAlias \u003d\u003d null || namesToAlias.isEmpty()) {\n-        Node result \u003d FunctionArgumentInjector.inject(fnTemplateRoot, null, argMap);\n+        Node result \u003d FunctionArgumentInjector.inject(compiler, fnTemplateRoot, null, argMap);\n         Preconditions.checkState(result \u003d\u003d fnTemplateRoot);\n         return result;\n     } else {\n         Map\u003cString, Node\u003e newArgMap \u003d Maps.newHashMap(argMap);\n         List\u003cNode\u003e newVars \u003d Lists.newLinkedList();\n         for (Entry\u003cString, Node\u003e entry : argMap.entrySet()) {\n             String name \u003d entry.getKey();\n             if (namesToAlias.contains(name)) {\n-                Node newValue \u003d entry.getValue().cloneTree();\n-                Node newNode \u003d NodeUtil.newVarNode(name, newValue).copyInformationFromForTree(newValue);\n-                newVars.add(0, newNode);\n-                newArgMap.remove(name);\n+                if (name.equals(THIS_MARKER)) {\n+                    boolean referencesThis \u003d NodeUtil.referencesThis(fnTemplateRoot);\n+                    Node value \u003d entry.getValue();\n+                    if (value.getType() !\u003d Token.THIS \u0026\u0026 (referencesThis || NodeUtil.mayHaveSideEffects(value, compiler))) {\n+                        String newName \u003d getUniqueThisName();\n+                        Node newValue \u003d entry.getValue().cloneTree();\n+                        Node newNode \u003d NodeUtil.newVarNode(newName, newValue).copyInformationFromForTree(newValue);\n+                        newVars.add(0, newNode);\n+                        newArgMap.put(THIS_MARKER, Node.newString(Token.NAME, newName).copyInformationFromForTree(newValue));\n+                    }\n+                } else {\n+                    Node newValue \u003d entry.getValue().cloneTree();\n+                    Node newNode \u003d NodeUtil.newVarNode(name, newValue).copyInformationFromForTree(newValue);\n+                    newVars.add(0, newNode);\n+                    newArgMap.remove(name);\n+                }\n             }\n         }\n-        Node result \u003d FunctionArgumentInjector.inject(fnTemplateRoot, null, newArgMap);\n+        Node result \u003d FunctionArgumentInjector.inject(compiler, fnTemplateRoot, null, newArgMap);\n         Preconditions.checkState(result \u003d\u003d fnTemplateRoot);\n         for (Node n : newVars) {\n             fnTemplateRoot.addChildToFront(n);\n         }\n         return result;\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6e3eb4f7619179ba6c23db2af7549ef02f588c35": {
      "type": "Ybodychange",
      "commitMessage": "\nChange on 2010/04/15 by john\n\n        Maintain source information in OverloadedMethodResolution.\n\n        R\u003dandrew\n        DELTA\u003d8  (5 added, 1 deleted, 2 changed)\n\nChange on 2010/04/15 by john\n\n        Maintain source information during function inlining.\n\n        R\u003dalan\n        DELTA\u003d104  (73 added, 2 deleted, 29 changed)\n\nChange on 2010/04/15 by john\n\n        Improve LineNumberCheck error message.\n\n        R\u003dnick\n        DELTA\u003d4  (3 added, 0 deleted, 1 changed)\n\nChange on 2010/04/15 by john\n\n        Maintain source information in smart name removal.\n        Enabled Normalize during tests, simplified VAR handling.\n\n        R\u003dantonio\n        DELTA\u003d71  (12 added, 48 deleted, 11 changed)\n\nChange on 2010/04/15 by john\n\n        Maintain source information in InlineGetters.\n\n        R\u003dalan\n        DELTA\u003d8  (7 added, 0 deleted, 1 changed)\n\nChange on 2010/04/15 by alan\n\n        Stops the post data from printing multiple times.\n\n        R\u003djohn\n        DELTA\u003d4  (1 added, 0 deleted, 3 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003dhuwaud\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@188 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/16/10, 10:20 AM",
      "commitName": "6e3eb4f7619179ba6c23db2af7549ef02f588c35",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "4/5/10, 12:30 PM",
      "commitNameOld": "222eafd303155b3eac5cd244584b2cb3c4c11975",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 10.91,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "actualSource": "private Node aliasAndInlineArguments(Node fnTemplateRoot, LinkedHashMap\u003cString, Node\u003e argMap, Set\u003cString\u003e namesToAlias) {\n    if (namesToAlias \u003d\u003d null || namesToAlias.isEmpty()) {\n        Node result \u003d FunctionArgumentInjector.inject(fnTemplateRoot, null, argMap);\n        Preconditions.checkState(result \u003d\u003d fnTemplateRoot);\n        return result;\n    } else {\n        Map\u003cString, Node\u003e newArgMap \u003d Maps.newHashMap(argMap);\n        List\u003cNode\u003e newVars \u003d Lists.newLinkedList();\n        for (Entry\u003cString, Node\u003e entry : argMap.entrySet()) {\n            String name \u003d entry.getKey();\n            if (namesToAlias.contains(name)) {\n                Node newValue \u003d entry.getValue().cloneTree();\n                Node newNode \u003d NodeUtil.newVarNode(name, newValue).copyInformationFromForTree(newValue);\n                newVars.add(0, newNode);\n                newArgMap.remove(name);\n            }\n        }\n        Node result \u003d FunctionArgumentInjector.inject(fnTemplateRoot, null, newArgMap);\n        Preconditions.checkState(result \u003d\u003d fnTemplateRoot);\n        for (Node n : newVars) {\n            fnTemplateRoot.addChildToFront(n);\n        }\n        return result;\n    }\n}",
      "path": "src/com/google/javascript/jscomp/FunctionToBlockMutator.java",
      "functionStartLine": 169,
      "functionName": "aliasAndInlineArguments",
      "functionAnnotation": "",
      "functionDoc": "Inlines the arguments within the node tree using the given argument map,\nreplaces \"unsafe\" names with local aliases.\n\nThe aliases for unsafe require new VAR declarations, so this function\ncan not be used in for direct CALL node replacement as VAR nodes can not be\ncreated there.\n\n@return The node or its replacement.\n",
      "diff": "@@ -1,25 +1,25 @@\n private Node aliasAndInlineArguments(Node fnTemplateRoot, LinkedHashMap\u003cString, Node\u003e argMap, Set\u003cString\u003e namesToAlias) {\n     if (namesToAlias \u003d\u003d null || namesToAlias.isEmpty()) {\n         Node result \u003d FunctionArgumentInjector.inject(fnTemplateRoot, null, argMap);\n         Preconditions.checkState(result \u003d\u003d fnTemplateRoot);\n         return result;\n     } else {\n         Map\u003cString, Node\u003e newArgMap \u003d Maps.newHashMap(argMap);\n         List\u003cNode\u003e newVars \u003d Lists.newLinkedList();\n         for (Entry\u003cString, Node\u003e entry : argMap.entrySet()) {\n             String name \u003d entry.getKey();\n             if (namesToAlias.contains(name)) {\n                 Node newValue \u003d entry.getValue().cloneTree();\n-                Node newNode \u003d NodeUtil.newVarNode(name, newValue);\n+                Node newNode \u003d NodeUtil.newVarNode(name, newValue).copyInformationFromForTree(newValue);\n                 newVars.add(0, newNode);\n                 newArgMap.remove(name);\n             }\n         }\n         Node result \u003d FunctionArgumentInjector.inject(fnTemplateRoot, null, newArgMap);\n         Preconditions.checkState(result \u003d\u003d fnTemplateRoot);\n         for (Node n : newVars) {\n             fnTemplateRoot.addChildToFront(n);\n         }\n         return result;\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": {
      "type": "Yintroduced",
      "commitMessage": "Initial commit.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/3/09, 3:51 PM",
      "commitName": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "diff": "@@ -0,0 +1,25 @@\n+private Node aliasAndInlineArguments(Node fnTemplateRoot, LinkedHashMap\u003cString, Node\u003e argMap, Set\u003cString\u003e namesToAlias) {\n+    if (namesToAlias \u003d\u003d null || namesToAlias.isEmpty()) {\n+        Node result \u003d FunctionArgumentInjector.inject(fnTemplateRoot, null, argMap);\n+        Preconditions.checkState(result \u003d\u003d fnTemplateRoot);\n+        return result;\n+    } else {\n+        Map\u003cString, Node\u003e newArgMap \u003d Maps.newHashMap(argMap);\n+        List\u003cNode\u003e newVars \u003d Lists.newLinkedList();\n+        for (Entry\u003cString, Node\u003e entry : argMap.entrySet()) {\n+            String name \u003d entry.getKey();\n+            if (namesToAlias.contains(name)) {\n+                Node newValue \u003d entry.getValue().cloneTree();\n+                Node newNode \u003d NodeUtil.newVarNode(name, newValue);\n+                newVars.add(0, newNode);\n+                newArgMap.remove(name);\n+            }\n+        }\n+        Node result \u003d FunctionArgumentInjector.inject(fnTemplateRoot, null, newArgMap);\n+        Preconditions.checkState(result \u003d\u003d fnTemplateRoot);\n+        for (Node n : newVars) {\n+            fnTemplateRoot.addChildToFront(n);\n+        }\n+        return result;\n+    }\n+}\n\\ No newline at end of file\n",
      "actualSource": "private Node aliasAndInlineArguments(Node fnTemplateRoot, LinkedHashMap\u003cString, Node\u003e argMap, Set\u003cString\u003e namesToAlias) {\n    if (namesToAlias \u003d\u003d null || namesToAlias.isEmpty()) {\n        Node result \u003d FunctionArgumentInjector.inject(fnTemplateRoot, null, argMap);\n        Preconditions.checkState(result \u003d\u003d fnTemplateRoot);\n        return result;\n    } else {\n        Map\u003cString, Node\u003e newArgMap \u003d Maps.newHashMap(argMap);\n        List\u003cNode\u003e newVars \u003d Lists.newLinkedList();\n        for (Entry\u003cString, Node\u003e entry : argMap.entrySet()) {\n            String name \u003d entry.getKey();\n            if (namesToAlias.contains(name)) {\n                Node newValue \u003d entry.getValue().cloneTree();\n                Node newNode \u003d NodeUtil.newVarNode(name, newValue);\n                newVars.add(0, newNode);\n                newArgMap.remove(name);\n            }\n        }\n        Node result \u003d FunctionArgumentInjector.inject(fnTemplateRoot, null, newArgMap);\n        Preconditions.checkState(result \u003d\u003d fnTemplateRoot);\n        for (Node n : newVars) {\n            fnTemplateRoot.addChildToFront(n);\n        }\n        return result;\n    }\n}",
      "path": "src/com/google/javascript/jscomp/FunctionToBlockMutator.java",
      "functionStartLine": 168,
      "functionName": "aliasAndInlineArguments",
      "functionAnnotation": "",
      "functionDoc": "Inlines the arguments within the node tree using the given argument map,\nreplaces \"unsafe\" names with local aliases.\n\nThe aliases for unsafe require new VAR declarations, so this function\ncan not be used in for direct CALL node replacement as VAR nodes can not be\ncreated there.\n\n@return The node or its replacement.\n"
    }
  }
}