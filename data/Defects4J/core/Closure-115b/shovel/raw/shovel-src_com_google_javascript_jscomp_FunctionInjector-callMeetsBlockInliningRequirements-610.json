{
  "origin": "codeshovel",
  "repositoryName": "Closure-115b",
  "repositoryPath": "/tmp/Closure-115b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FunctionInjector.java",
  "functionName": "callMeetsBlockInliningRequirements",
  "functionId": "callMeetsBlockInliningRequirements___t-NodeTraversal__callNode-Node__fnNode-Node(modifiers-final)__namesToAlias-Set__String__",
  "sourceFilePath": "src/com/google/javascript/jscomp/FunctionInjector.java",
  "functionAnnotation": "",
  "functionDoc": "Determines whether a function can be inlined at a particular call site.\n- Don\u0027t inline if the calling function contains an inner function and\ninlining would introduce new globals.\n",
  "functionStartLine": 610,
  "functionEndLine": 675,
  "numCommitsSeen": 75,
  "timeTaken": 2751,
  "changeHistory": [
    "70a5626922ea7e8c98747e22b6986638ba38fadc",
    "ec324a9bb23eb78c76f537f4c4170ba88d542f1c",
    "de20cf30dfdf0f885c9b97dfb75f8425df0280b9",
    "869c65d5c43d96526d90c7ea9a186df9edd67eb0",
    "43cece8ccf72521faa04fc79fddfc5f7d661a787",
    "0b05c26eefae171f9b4d0e1f8eba4249088207fa",
    "b4801b28ceea8db0f63da7440d6769cb9b7cce8a",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3"
  ],
  "changeHistoryShort": {
    "70a5626922ea7e8c98747e22b6986638ba38fadc": "Ybodychange",
    "ec324a9bb23eb78c76f537f4c4170ba88d542f1c": "Ybodychange",
    "de20cf30dfdf0f885c9b97dfb75f8425df0280b9": "Ybodychange",
    "869c65d5c43d96526d90c7ea9a186df9edd67eb0": "Ymultichange(Ybodychange,Yparametermetachange)",
    "43cece8ccf72521faa04fc79fddfc5f7d661a787": "Ymultichange(Yparameterchange,Ybodychange,Yparametermetachange)",
    "0b05c26eefae171f9b4d0e1f8eba4249088207fa": "Ymultichange(Yparameterchange,Ybodychange,Yparametermetachange)",
    "b4801b28ceea8db0f63da7440d6769cb9b7cce8a": "Ybodychange",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "70a5626922ea7e8c98747e22b6986638ba38fadc": {
      "type": "Ybodychange",
      "commitMessage": "\nFix various typos, spelling and grammar errors.\nFixes issue 734. \nContributed by Robert Gust Bardon\n\nR\u003dnicksantos\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d4827\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1979 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "5/18/12, 11:09 AM",
      "commitName": "70a5626922ea7e8c98747e22b6986638ba38fadc",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "4/30/12, 4:40 PM",
      "commitNameOld": "f58f7523c285197df175ad780dbe6288c67bc08c",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 17.77,
      "commitsBetweenForRepo": 39,
      "commitsBetweenForFile": 1,
      "actualSource": "private boolean callMeetsBlockInliningRequirements(NodeTraversal t, Node callNode, final Node fnNode, Set\u003cString\u003e namesToAlias) {\n    final boolean assumeMinimumCapture \u003d this.assumeMinimumCapture;\n    boolean fnContainsVars \u003d NodeUtil.has(NodeUtil.getFunctionBody(fnNode), new NodeUtil.MatchDeclaration(), new NodeUtil.MatchShallowStatement());\n    boolean forbidTemps \u003d false;\n    if (!t.inGlobalScope()) {\n        Node fnCaller \u003d t.getScopeRoot();\n        Node fnCallerBody \u003d fnCaller.getLastChild();\n        Predicate\u003cNode\u003e match \u003d new Predicate\u003cNode\u003e() {\n\n            @Override\n            public boolean apply(Node n) {\n                if (n.isName()) {\n                    return n.getString().equals(\"eval\");\n                }\n                if (!assumeMinimumCapture \u0026\u0026 n.isFunction()) {\n                    return n !\u003d fnNode;\n                }\n                return false;\n            }\n        };\n        forbidTemps \u003d NodeUtil.has(fnCallerBody, match, NodeUtil.MATCH_NOT_FUNCTION);\n    }\n    if (fnContainsVars \u0026\u0026 forbidTemps) {\n        return false;\n    }\n    if (forbidTemps) {\n        Map\u003cString, Node\u003e args \u003d FunctionArgumentInjector.getFunctionCallParameterMap(fnNode, callNode, this.safeNameIdSupplier);\n        boolean hasArgs \u003d !args.isEmpty();\n        if (hasArgs) {\n            Set\u003cString\u003e allNamesToAlias \u003d Sets.newHashSet(namesToAlias);\n            FunctionArgumentInjector.maybeAddTempsForCallArguments(fnNode, args, allNamesToAlias, compiler.getCodingConvention());\n            if (!allNamesToAlias.isEmpty()) {\n                return false;\n            }\n        }\n    }\n    return true;\n}",
      "path": "src/com/google/javascript/jscomp/FunctionInjector.java",
      "functionStartLine": 585,
      "functionName": "callMeetsBlockInliningRequirements",
      "functionAnnotation": "",
      "functionDoc": "Determines whether a function can be inlined at a particular call site.\n- Don\u0027t inline if the calling function contains an inner function and\ninlining would introduce new globals.\n",
      "diff": "",
      "extendedDetails": {}
    },
    "ec324a9bb23eb78c76f537f4c4170ba88d542f1c": {
      "type": "Ybodychange",
      "commitMessage": "\nReplace the bulk of the Node.getType() \u003d\u003d Token.XXX calls with\nNode.isXXX calls.\n\nR\u003dnicksantos\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3677\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1582 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/10/11, 8:36 AM",
      "commitName": "ec324a9bb23eb78c76f537f4c4170ba88d542f1c",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "8/22/11, 5:34 PM",
      "commitNameOld": "de20cf30dfdf0f885c9b97dfb75f8425df0280b9",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 79.67,
      "commitsBetweenForRepo": 187,
      "commitsBetweenForFile": 1,
      "actualSource": "private boolean callMeetsBlockInliningRequirements(NodeTraversal t, Node callNode, final Node fnNode, Set\u003cString\u003e namesToAlias) {\n    final boolean assumeMinimumCapture \u003d this.assumeMinimumCapture;\n    boolean fnContainsVars \u003d NodeUtil.has(NodeUtil.getFunctionBody(fnNode), new NodeUtil.MatchDeclaration(), new NodeUtil.MatchShallowStatement());\n    boolean forbidTemps \u003d false;\n    if (!t.inGlobalScope()) {\n        Node fnCaller \u003d t.getScopeRoot();\n        Node fnCallerBody \u003d fnCaller.getLastChild();\n        Predicate\u003cNode\u003e match \u003d new Predicate\u003cNode\u003e() {\n\n            @Override\n            public boolean apply(Node n) {\n                if (n.isName()) {\n                    return n.getString().equals(\"eval\");\n                }\n                if (!assumeMinimumCapture \u0026\u0026 n.isFunction()) {\n                    return n !\u003d fnNode;\n                }\n                return false;\n            }\n        };\n        forbidTemps \u003d NodeUtil.has(fnCallerBody, match, NodeUtil.MATCH_NOT_FUNCTION);\n    }\n    if (fnContainsVars \u0026\u0026 forbidTemps) {\n        return false;\n    }\n    if (forbidTemps) {\n        Map\u003cString, Node\u003e args \u003d FunctionArgumentInjector.getFunctionCallParameterMap(fnNode, callNode, this.safeNameIdSupplier);\n        boolean hasArgs \u003d !args.isEmpty();\n        if (hasArgs) {\n            Set\u003cString\u003e allNamesToAlias \u003d Sets.newHashSet(namesToAlias);\n            FunctionArgumentInjector.maybeAddTempsForCallArguments(fnNode, args, allNamesToAlias, compiler.getCodingConvention());\n            if (!allNamesToAlias.isEmpty()) {\n                return false;\n            }\n        }\n    }\n    return true;\n}",
      "path": "src/com/google/javascript/jscomp/FunctionInjector.java",
      "functionStartLine": 579,
      "functionName": "callMeetsBlockInliningRequirements",
      "functionAnnotation": "",
      "functionDoc": "Determines whether a function can be inlined at a particular call site.\n- Don\u0027t inline if the calling function contains an inner function and\ninlining would introduce new globals.\n",
      "diff": "@@ -1,38 +1,38 @@\n private boolean callMeetsBlockInliningRequirements(NodeTraversal t, Node callNode, final Node fnNode, Set\u003cString\u003e namesToAlias) {\n     final boolean assumeMinimumCapture \u003d this.assumeMinimumCapture;\n     boolean fnContainsVars \u003d NodeUtil.has(NodeUtil.getFunctionBody(fnNode), new NodeUtil.MatchDeclaration(), new NodeUtil.MatchShallowStatement());\n     boolean forbidTemps \u003d false;\n     if (!t.inGlobalScope()) {\n         Node fnCaller \u003d t.getScopeRoot();\n         Node fnCallerBody \u003d fnCaller.getLastChild();\n         Predicate\u003cNode\u003e match \u003d new Predicate\u003cNode\u003e() {\n \n             @Override\n             public boolean apply(Node n) {\n-                if (n.getType() \u003d\u003d Token.NAME) {\n+                if (n.isName()) {\n                     return n.getString().equals(\"eval\");\n                 }\n-                if (!assumeMinimumCapture \u0026\u0026 n.getType() \u003d\u003d Token.FUNCTION) {\n+                if (!assumeMinimumCapture \u0026\u0026 n.isFunction()) {\n                     return n !\u003d fnNode;\n                 }\n                 return false;\n             }\n         };\n         forbidTemps \u003d NodeUtil.has(fnCallerBody, match, NodeUtil.MATCH_NOT_FUNCTION);\n     }\n     if (fnContainsVars \u0026\u0026 forbidTemps) {\n         return false;\n     }\n     if (forbidTemps) {\n         Map\u003cString, Node\u003e args \u003d FunctionArgumentInjector.getFunctionCallParameterMap(fnNode, callNode, this.safeNameIdSupplier);\n         boolean hasArgs \u003d !args.isEmpty();\n         if (hasArgs) {\n             Set\u003cString\u003e allNamesToAlias \u003d Sets.newHashSet(namesToAlias);\n             FunctionArgumentInjector.maybeAddTempsForCallArguments(fnNode, args, allNamesToAlias, compiler.getCodingConvention());\n             if (!allNamesToAlias.isEmpty()) {\n                 return false;\n             }\n         }\n     }\n     return true;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "de20cf30dfdf0f885c9b97dfb75f8425df0280b9": {
      "type": "Ybodychange",
      "commitMessage": "\nAdd an inliner option to inline function without considering whether \"capture\" of variables. Traditionally, we have avoiding inlining function with closure into scope (because they might capture unintended values) or inline functions that require temporaries into scopes that contain closures (because the temps might leak into the closure scopes).\nThis CL does not include a means of enabling the option.\n\nR\u003dacleung\nDELTA\u003d332  (313 added, 0 deleted, 19 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3089\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1378 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "8/22/11, 5:34 PM",
      "commitName": "de20cf30dfdf0f885c9b97dfb75f8425df0280b9",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "8/22/11, 2:35 PM",
      "commitNameOld": "f791e3a7a172728b54a337c94bff4bc27c7adc43",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 0.12,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "private boolean callMeetsBlockInliningRequirements(NodeTraversal t, Node callNode, final Node fnNode, Set\u003cString\u003e namesToAlias) {\n    final boolean assumeMinimumCapture \u003d this.assumeMinimumCapture;\n    boolean fnContainsVars \u003d NodeUtil.has(NodeUtil.getFunctionBody(fnNode), new NodeUtil.MatchDeclaration(), new NodeUtil.MatchShallowStatement());\n    boolean forbidTemps \u003d false;\n    if (!t.inGlobalScope()) {\n        Node fnCaller \u003d t.getScopeRoot();\n        Node fnCallerBody \u003d fnCaller.getLastChild();\n        Predicate\u003cNode\u003e match \u003d new Predicate\u003cNode\u003e() {\n\n            @Override\n            public boolean apply(Node n) {\n                if (n.getType() \u003d\u003d Token.NAME) {\n                    return n.getString().equals(\"eval\");\n                }\n                if (!assumeMinimumCapture \u0026\u0026 n.getType() \u003d\u003d Token.FUNCTION) {\n                    return n !\u003d fnNode;\n                }\n                return false;\n            }\n        };\n        forbidTemps \u003d NodeUtil.has(fnCallerBody, match, NodeUtil.MATCH_NOT_FUNCTION);\n    }\n    if (fnContainsVars \u0026\u0026 forbidTemps) {\n        return false;\n    }\n    if (forbidTemps) {\n        Map\u003cString, Node\u003e args \u003d FunctionArgumentInjector.getFunctionCallParameterMap(fnNode, callNode, this.safeNameIdSupplier);\n        boolean hasArgs \u003d !args.isEmpty();\n        if (hasArgs) {\n            Set\u003cString\u003e allNamesToAlias \u003d Sets.newHashSet(namesToAlias);\n            FunctionArgumentInjector.maybeAddTempsForCallArguments(fnNode, args, allNamesToAlias, compiler.getCodingConvention());\n            if (!allNamesToAlias.isEmpty()) {\n                return false;\n            }\n        }\n    }\n    return true;\n}",
      "path": "src/com/google/javascript/jscomp/FunctionInjector.java",
      "functionStartLine": 579,
      "functionName": "callMeetsBlockInliningRequirements",
      "functionAnnotation": "",
      "functionDoc": "Determines whether a function can be inlined at a particular call site.\n- Don\u0027t inline if the calling function contains an inner function and\ninlining would introduce new globals.\n",
      "diff": "@@ -1,37 +1,38 @@\n private boolean callMeetsBlockInliningRequirements(NodeTraversal t, Node callNode, final Node fnNode, Set\u003cString\u003e namesToAlias) {\n+    final boolean assumeMinimumCapture \u003d this.assumeMinimumCapture;\n     boolean fnContainsVars \u003d NodeUtil.has(NodeUtil.getFunctionBody(fnNode), new NodeUtil.MatchDeclaration(), new NodeUtil.MatchShallowStatement());\n     boolean forbidTemps \u003d false;\n     if (!t.inGlobalScope()) {\n         Node fnCaller \u003d t.getScopeRoot();\n         Node fnCallerBody \u003d fnCaller.getLastChild();\n         Predicate\u003cNode\u003e match \u003d new Predicate\u003cNode\u003e() {\n \n             @Override\n             public boolean apply(Node n) {\n                 if (n.getType() \u003d\u003d Token.NAME) {\n                     return n.getString().equals(\"eval\");\n                 }\n-                if (n.getType() \u003d\u003d Token.FUNCTION) {\n+                if (!assumeMinimumCapture \u0026\u0026 n.getType() \u003d\u003d Token.FUNCTION) {\n                     return n !\u003d fnNode;\n                 }\n                 return false;\n             }\n         };\n         forbidTemps \u003d NodeUtil.has(fnCallerBody, match, NodeUtil.MATCH_NOT_FUNCTION);\n     }\n     if (fnContainsVars \u0026\u0026 forbidTemps) {\n         return false;\n     }\n     if (forbidTemps) {\n         Map\u003cString, Node\u003e args \u003d FunctionArgumentInjector.getFunctionCallParameterMap(fnNode, callNode, this.safeNameIdSupplier);\n         boolean hasArgs \u003d !args.isEmpty();\n         if (hasArgs) {\n             Set\u003cString\u003e allNamesToAlias \u003d Sets.newHashSet(namesToAlias);\n             FunctionArgumentInjector.maybeAddTempsForCallArguments(fnNode, args, allNamesToAlias, compiler.getCodingConvention());\n             if (!allNamesToAlias.isEmpty()) {\n                 return false;\n             }\n         }\n     }\n     return true;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "869c65d5c43d96526d90c7ea9a186df9edd67eb0": {
      "type": "Ymultichange(Ybodychange,Yparametermetachange)",
      "commitMessage": "\nAutomated g4 rollback.\n\n*** Reason for rollback ***\n\nBe less aggressive about inlining functions contains inner function\n(go back to limiting this to global scope).\nFrom the the original change:\n\nTweaks to function inlining:\n- an unnamed function expression containing a inner unnamed function\nexpression should not be disallow because the names are the same.\n- a caller that contains the function definition to be inlined\nshould not consider the candidate to be a capturing function.\n- allow inlining a function containing an inner function that\nreferences arguments.\n- disallow inlining a function into a function containing\neval if intoducing names.\n- when inlining a function containing a function declaration, rewrite\nit a var declarations and function expressions to avoid introducing\nfunction declaraions into contexts disallowed by ES5 strict.\n\n*** Original change description ***\n\nAutomated g4 rollback of changelist 23059472.\n\n*** Reason for rollback ***\n\nBreaks things\n\nR\u003dacleung\nDELTA\u003d149  (127 added, 0 deleted, 22 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3079\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1368 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "8/19/11, 11:37 AM",
      "commitName": "869c65d5c43d96526d90c7ea9a186df9edd67eb0",
      "commitAuthor": "johnlenz@google.com",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "\nAutomated g4 rollback.\n\n*** Reason for rollback ***\n\nBe less aggressive about inlining functions contains inner function\n(go back to limiting this to global scope).\nFrom the the original change:\n\nTweaks to function inlining:\n- an unnamed function expression containing a inner unnamed function\nexpression should not be disallow because the names are the same.\n- a caller that contains the function definition to be inlined\nshould not consider the candidate to be a capturing function.\n- allow inlining a function containing an inner function that\nreferences arguments.\n- disallow inlining a function into a function containing\neval if intoducing names.\n- when inlining a function containing a function declaration, rewrite\nit a var declarations and function expressions to avoid introducing\nfunction declaraions into contexts disallowed by ES5 strict.\n\n*** Original change description ***\n\nAutomated g4 rollback of changelist 23059472.\n\n*** Reason for rollback ***\n\nBreaks things\n\nR\u003dacleung\nDELTA\u003d149  (127 added, 0 deleted, 22 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3079\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1368 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "8/19/11, 11:37 AM",
          "commitName": "869c65d5c43d96526d90c7ea9a186df9edd67eb0",
          "commitAuthor": "johnlenz@google.com",
          "commitDateOld": "8/17/11, 10:46 AM",
          "commitNameOld": "4d05d82cb3f7f4f0a06852927798c6039fb4f50d",
          "commitAuthorOld": "johnlenz@google.com",
          "daysBetweenCommits": 2.04,
          "commitsBetweenForRepo": 7,
          "commitsBetweenForFile": 1,
          "actualSource": "private boolean callMeetsBlockInliningRequirements(NodeTraversal t, Node callNode, final Node fnNode, Set\u003cString\u003e namesToAlias) {\n    boolean fnContainsVars \u003d NodeUtil.has(NodeUtil.getFunctionBody(fnNode), new NodeUtil.MatchDeclaration(), new NodeUtil.MatchShallowStatement());\n    boolean forbidTemps \u003d false;\n    if (!t.inGlobalScope()) {\n        Node fnCaller \u003d t.getScopeRoot();\n        Node fnCallerBody \u003d fnCaller.getLastChild();\n        Predicate\u003cNode\u003e match \u003d new Predicate\u003cNode\u003e() {\n\n            @Override\n            public boolean apply(Node n) {\n                if (n.getType() \u003d\u003d Token.NAME) {\n                    return n.getString().equals(\"eval\");\n                }\n                if (n.getType() \u003d\u003d Token.FUNCTION) {\n                    return n !\u003d fnNode;\n                }\n                return false;\n            }\n        };\n        forbidTemps \u003d NodeUtil.has(fnCallerBody, match, NodeUtil.MATCH_NOT_FUNCTION);\n    }\n    if (fnContainsVars \u0026\u0026 forbidTemps) {\n        return false;\n    }\n    if (forbidTemps) {\n        Map\u003cString, Node\u003e args \u003d FunctionArgumentInjector.getFunctionCallParameterMap(fnNode, callNode, this.safeNameIdSupplier);\n        boolean hasArgs \u003d !args.isEmpty();\n        if (hasArgs) {\n            Set\u003cString\u003e allNamesToAlias \u003d Sets.newHashSet(namesToAlias);\n            FunctionArgumentInjector.maybeAddTempsForCallArguments(fnNode, args, allNamesToAlias, compiler.getCodingConvention());\n            if (!allNamesToAlias.isEmpty()) {\n                return false;\n            }\n        }\n    }\n    return true;\n}",
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java",
          "functionStartLine": 570,
          "functionName": "callMeetsBlockInliningRequirements",
          "functionAnnotation": "",
          "functionDoc": "Determines whether a function can be inlined at a particular call site.\n- Don\u0027t inline if the calling function contains an inner function and\ninlining would introduce new globals.\n",
          "diff": "@@ -1,24 +1,37 @@\n-private boolean callMeetsBlockInliningRequirements(NodeTraversal t, Node callNode, Node fnNode, Set\u003cString\u003e namesToAlias) {\n+private boolean callMeetsBlockInliningRequirements(NodeTraversal t, Node callNode, final Node fnNode, Set\u003cString\u003e namesToAlias) {\n     boolean fnContainsVars \u003d NodeUtil.has(NodeUtil.getFunctionBody(fnNode), new NodeUtil.MatchDeclaration(), new NodeUtil.MatchShallowStatement());\n-    boolean callerContainsFunction \u003d false;\n+    boolean forbidTemps \u003d false;\n     if (!t.inGlobalScope()) {\n         Node fnCaller \u003d t.getScopeRoot();\n         Node fnCallerBody \u003d fnCaller.getLastChild();\n-        callerContainsFunction \u003d NodeUtil.containsFunction(fnCallerBody);\n+        Predicate\u003cNode\u003e match \u003d new Predicate\u003cNode\u003e() {\n+\n+            @Override\n+            public boolean apply(Node n) {\n+                if (n.getType() \u003d\u003d Token.NAME) {\n+                    return n.getString().equals(\"eval\");\n+                }\n+                if (n.getType() \u003d\u003d Token.FUNCTION) {\n+                    return n !\u003d fnNode;\n+                }\n+                return false;\n+            }\n+        };\n+        forbidTemps \u003d NodeUtil.has(fnCallerBody, match, NodeUtil.MATCH_NOT_FUNCTION);\n     }\n-    if (fnContainsVars \u0026\u0026 callerContainsFunction) {\n+    if (fnContainsVars \u0026\u0026 forbidTemps) {\n         return false;\n     }\n-    if (callerContainsFunction) {\n+    if (forbidTemps) {\n         Map\u003cString, Node\u003e args \u003d FunctionArgumentInjector.getFunctionCallParameterMap(fnNode, callNode, this.safeNameIdSupplier);\n         boolean hasArgs \u003d !args.isEmpty();\n         if (hasArgs) {\n             Set\u003cString\u003e allNamesToAlias \u003d Sets.newHashSet(namesToAlias);\n             FunctionArgumentInjector.maybeAddTempsForCallArguments(fnNode, args, allNamesToAlias, compiler.getCodingConvention());\n             if (!allNamesToAlias.isEmpty()) {\n                 return false;\n             }\n         }\n     }\n     return true;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Yparametermetachange",
          "commitMessage": "\nAutomated g4 rollback.\n\n*** Reason for rollback ***\n\nBe less aggressive about inlining functions contains inner function\n(go back to limiting this to global scope).\nFrom the the original change:\n\nTweaks to function inlining:\n- an unnamed function expression containing a inner unnamed function\nexpression should not be disallow because the names are the same.\n- a caller that contains the function definition to be inlined\nshould not consider the candidate to be a capturing function.\n- allow inlining a function containing an inner function that\nreferences arguments.\n- disallow inlining a function into a function containing\neval if intoducing names.\n- when inlining a function containing a function declaration, rewrite\nit a var declarations and function expressions to avoid introducing\nfunction declaraions into contexts disallowed by ES5 strict.\n\n*** Original change description ***\n\nAutomated g4 rollback of changelist 23059472.\n\n*** Reason for rollback ***\n\nBreaks things\n\nR\u003dacleung\nDELTA\u003d149  (127 added, 0 deleted, 22 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3079\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1368 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "8/19/11, 11:37 AM",
          "commitName": "869c65d5c43d96526d90c7ea9a186df9edd67eb0",
          "commitAuthor": "johnlenz@google.com",
          "commitDateOld": "8/17/11, 10:46 AM",
          "commitNameOld": "4d05d82cb3f7f4f0a06852927798c6039fb4f50d",
          "commitAuthorOld": "johnlenz@google.com",
          "daysBetweenCommits": 2.04,
          "commitsBetweenForRepo": 7,
          "commitsBetweenForFile": 1,
          "actualSource": "private boolean callMeetsBlockInliningRequirements(NodeTraversal t, Node callNode, final Node fnNode, Set\u003cString\u003e namesToAlias) {\n    boolean fnContainsVars \u003d NodeUtil.has(NodeUtil.getFunctionBody(fnNode), new NodeUtil.MatchDeclaration(), new NodeUtil.MatchShallowStatement());\n    boolean forbidTemps \u003d false;\n    if (!t.inGlobalScope()) {\n        Node fnCaller \u003d t.getScopeRoot();\n        Node fnCallerBody \u003d fnCaller.getLastChild();\n        Predicate\u003cNode\u003e match \u003d new Predicate\u003cNode\u003e() {\n\n            @Override\n            public boolean apply(Node n) {\n                if (n.getType() \u003d\u003d Token.NAME) {\n                    return n.getString().equals(\"eval\");\n                }\n                if (n.getType() \u003d\u003d Token.FUNCTION) {\n                    return n !\u003d fnNode;\n                }\n                return false;\n            }\n        };\n        forbidTemps \u003d NodeUtil.has(fnCallerBody, match, NodeUtil.MATCH_NOT_FUNCTION);\n    }\n    if (fnContainsVars \u0026\u0026 forbidTemps) {\n        return false;\n    }\n    if (forbidTemps) {\n        Map\u003cString, Node\u003e args \u003d FunctionArgumentInjector.getFunctionCallParameterMap(fnNode, callNode, this.safeNameIdSupplier);\n        boolean hasArgs \u003d !args.isEmpty();\n        if (hasArgs) {\n            Set\u003cString\u003e allNamesToAlias \u003d Sets.newHashSet(namesToAlias);\n            FunctionArgumentInjector.maybeAddTempsForCallArguments(fnNode, args, allNamesToAlias, compiler.getCodingConvention());\n            if (!allNamesToAlias.isEmpty()) {\n                return false;\n            }\n        }\n    }\n    return true;\n}",
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java",
          "functionStartLine": 570,
          "functionName": "callMeetsBlockInliningRequirements",
          "functionAnnotation": "",
          "functionDoc": "Determines whether a function can be inlined at a particular call site.\n- Don\u0027t inline if the calling function contains an inner function and\ninlining would introduce new globals.\n",
          "diff": "@@ -1,24 +1,37 @@\n-private boolean callMeetsBlockInliningRequirements(NodeTraversal t, Node callNode, Node fnNode, Set\u003cString\u003e namesToAlias) {\n+private boolean callMeetsBlockInliningRequirements(NodeTraversal t, Node callNode, final Node fnNode, Set\u003cString\u003e namesToAlias) {\n     boolean fnContainsVars \u003d NodeUtil.has(NodeUtil.getFunctionBody(fnNode), new NodeUtil.MatchDeclaration(), new NodeUtil.MatchShallowStatement());\n-    boolean callerContainsFunction \u003d false;\n+    boolean forbidTemps \u003d false;\n     if (!t.inGlobalScope()) {\n         Node fnCaller \u003d t.getScopeRoot();\n         Node fnCallerBody \u003d fnCaller.getLastChild();\n-        callerContainsFunction \u003d NodeUtil.containsFunction(fnCallerBody);\n+        Predicate\u003cNode\u003e match \u003d new Predicate\u003cNode\u003e() {\n+\n+            @Override\n+            public boolean apply(Node n) {\n+                if (n.getType() \u003d\u003d Token.NAME) {\n+                    return n.getString().equals(\"eval\");\n+                }\n+                if (n.getType() \u003d\u003d Token.FUNCTION) {\n+                    return n !\u003d fnNode;\n+                }\n+                return false;\n+            }\n+        };\n+        forbidTemps \u003d NodeUtil.has(fnCallerBody, match, NodeUtil.MATCH_NOT_FUNCTION);\n     }\n-    if (fnContainsVars \u0026\u0026 callerContainsFunction) {\n+    if (fnContainsVars \u0026\u0026 forbidTemps) {\n         return false;\n     }\n-    if (callerContainsFunction) {\n+    if (forbidTemps) {\n         Map\u003cString, Node\u003e args \u003d FunctionArgumentInjector.getFunctionCallParameterMap(fnNode, callNode, this.safeNameIdSupplier);\n         boolean hasArgs \u003d !args.isEmpty();\n         if (hasArgs) {\n             Set\u003cString\u003e allNamesToAlias \u003d Sets.newHashSet(namesToAlias);\n             FunctionArgumentInjector.maybeAddTempsForCallArguments(fnNode, args, allNamesToAlias, compiler.getCodingConvention());\n             if (!allNamesToAlias.isEmpty()) {\n                 return false;\n             }\n         }\n     }\n     return true;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[t-NodeTraversal, callNode-Node, fnNode-Node, namesToAlias-Set\u003cString\u003e]",
            "newValue": "[t-NodeTraversal, callNode-Node, fnNode-Node(modifiers-final), namesToAlias-Set\u003cString\u003e]"
          }
        }
      ]
    },
    "43cece8ccf72521faa04fc79fddfc5f7d661a787": {
      "type": "Ymultichange(Yparameterchange,Ybodychange,Yparametermetachange)",
      "commitMessage": "\nAutomated g4 rollback.\n\n*** Reason for rollback ***\n\nBreaks tests\n\n*** Original change description ***\n\nTweaks to function inlining:\n- an unnamed function expression containing a inner unnamed function\nexpression should not be disallow because the names are the same.\n- a caller that only contains the function definition to be inlined should\nnot consider the candidate to be a capturing function.\n- allow inlining a function containing an inner function that\nreferences arguments.\n- disallow inlining a function into a function containing eval.\n- when inlining a function containing a function dec\n\n... description truncated by g4 rollback ...\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d2930\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1339 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "8/8/11, 2:51 PM",
      "commitName": "43cece8ccf72521faa04fc79fddfc5f7d661a787",
      "commitAuthor": "johnlenz@google.com",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "\nAutomated g4 rollback.\n\n*** Reason for rollback ***\n\nBreaks tests\n\n*** Original change description ***\n\nTweaks to function inlining:\n- an unnamed function expression containing a inner unnamed function\nexpression should not be disallow because the names are the same.\n- a caller that only contains the function definition to be inlined should\nnot consider the candidate to be a capturing function.\n- allow inlining a function containing an inner function that\nreferences arguments.\n- disallow inlining a function into a function containing eval.\n- when inlining a function containing a function dec\n\n... description truncated by g4 rollback ...\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d2930\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1339 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "8/8/11, 2:51 PM",
          "commitName": "43cece8ccf72521faa04fc79fddfc5f7d661a787",
          "commitAuthor": "johnlenz@google.com",
          "commitDateOld": "8/8/11, 2:03 PM",
          "commitNameOld": "0b05c26eefae171f9b4d0e1f8eba4249088207fa",
          "commitAuthorOld": "johnlenz@google.com",
          "daysBetweenCommits": 0.03,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "private boolean callMeetsBlockInliningRequirements(NodeTraversal t, Node callNode, Node fnNode, Set\u003cString\u003e namesToAlias) {\n    boolean fnContainsVars \u003d NodeUtil.has(NodeUtil.getFunctionBody(fnNode), new NodeUtil.MatchDeclaration(), new NodeUtil.MatchShallowStatement());\n    boolean callerContainsFunction \u003d false;\n    if (!t.inGlobalScope()) {\n        Node fnCaller \u003d t.getScopeRoot();\n        Node fnCallerBody \u003d fnCaller.getLastChild();\n        callerContainsFunction \u003d NodeUtil.containsFunction(fnCallerBody);\n    }\n    if (fnContainsVars \u0026\u0026 callerContainsFunction) {\n        return false;\n    }\n    if (callerContainsFunction) {\n        Map\u003cString, Node\u003e args \u003d FunctionArgumentInjector.getFunctionCallParameterMap(fnNode, callNode, this.safeNameIdSupplier);\n        boolean hasArgs \u003d !args.isEmpty();\n        if (hasArgs) {\n            Set\u003cString\u003e allNamesToAlias \u003d Sets.newHashSet(namesToAlias);\n            FunctionArgumentInjector.maybeAddTempsForCallArguments(fnNode, args, allNamesToAlias, compiler.getCodingConvention());\n            if (!allNamesToAlias.isEmpty()) {\n                return false;\n            }\n        }\n    }\n    return true;\n}",
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java",
          "functionStartLine": 562,
          "functionName": "callMeetsBlockInliningRequirements",
          "functionAnnotation": "",
          "functionDoc": "Determines whether a function can be inlined at a particular call site.\n- Don\u0027t inline if the calling function contains an inner function and\ninlining would introduce new globals.\n",
          "diff": "@@ -1,37 +1,24 @@\n-private boolean callMeetsBlockInliningRequirements(NodeTraversal t, Node callNode, final Node fnNode, Set\u003cString\u003e namesToAlias, boolean containsFunctions) {\n-    boolean hasLocalNames \u003d hasLocalNames(fnNode);\n-    boolean forbidTemps \u003d false;\n+private boolean callMeetsBlockInliningRequirements(NodeTraversal t, Node callNode, Node fnNode, Set\u003cString\u003e namesToAlias) {\n+    boolean fnContainsVars \u003d NodeUtil.has(NodeUtil.getFunctionBody(fnNode), new NodeUtil.MatchDeclaration(), new NodeUtil.MatchShallowStatement());\n+    boolean callerContainsFunction \u003d false;\n     if (!t.inGlobalScope()) {\n         Node fnCaller \u003d t.getScopeRoot();\n         Node fnCallerBody \u003d fnCaller.getLastChild();\n-        forbidTemps \u003d NodeUtil.isNameReferenced(fnCallerBody, \"eval\", NodeUtil.MATCH_NOT_FUNCTION);\n-        if (!forbidTemps \u0026\u0026 containsFunctions) {\n-            Predicate\u003cNode\u003e match \u003d new Predicate\u003cNode\u003e() {\n-\n-                @Override\n-                public boolean apply(Node n) {\n-                    if (n.getType() \u003d\u003d Token.FUNCTION) {\n-                        return n !\u003d fnNode;\n-                    }\n-                    return false;\n-                }\n-            };\n-            forbidTemps \u003d NodeUtil.has(fnCallerBody, match, NodeUtil.MATCH_NOT_FUNCTION);\n-        }\n+        callerContainsFunction \u003d NodeUtil.containsFunction(fnCallerBody);\n     }\n-    if (forbidTemps) {\n-        if (hasLocalNames) {\n-            return false;\n-        }\n+    if (fnContainsVars \u0026\u0026 callerContainsFunction) {\n+        return false;\n+    }\n+    if (callerContainsFunction) {\n         Map\u003cString, Node\u003e args \u003d FunctionArgumentInjector.getFunctionCallParameterMap(fnNode, callNode, this.safeNameIdSupplier);\n         boolean hasArgs \u003d !args.isEmpty();\n         if (hasArgs) {\n             Set\u003cString\u003e allNamesToAlias \u003d Sets.newHashSet(namesToAlias);\n             FunctionArgumentInjector.maybeAddTempsForCallArguments(fnNode, args, allNamesToAlias, compiler.getCodingConvention());\n             if (!allNamesToAlias.isEmpty()) {\n                 return false;\n             }\n         }\n     }\n     return true;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[t-NodeTraversal, callNode-Node, fnNode-Node(modifiers-final), namesToAlias-Set\u003cString\u003e, containsFunctions-boolean]",
            "newValue": "[t-NodeTraversal, callNode-Node, fnNode-Node, namesToAlias-Set\u003cString\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "\nAutomated g4 rollback.\n\n*** Reason for rollback ***\n\nBreaks tests\n\n*** Original change description ***\n\nTweaks to function inlining:\n- an unnamed function expression containing a inner unnamed function\nexpression should not be disallow because the names are the same.\n- a caller that only contains the function definition to be inlined should\nnot consider the candidate to be a capturing function.\n- allow inlining a function containing an inner function that\nreferences arguments.\n- disallow inlining a function into a function containing eval.\n- when inlining a function containing a function dec\n\n... description truncated by g4 rollback ...\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d2930\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1339 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "8/8/11, 2:51 PM",
          "commitName": "43cece8ccf72521faa04fc79fddfc5f7d661a787",
          "commitAuthor": "johnlenz@google.com",
          "commitDateOld": "8/8/11, 2:03 PM",
          "commitNameOld": "0b05c26eefae171f9b4d0e1f8eba4249088207fa",
          "commitAuthorOld": "johnlenz@google.com",
          "daysBetweenCommits": 0.03,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "private boolean callMeetsBlockInliningRequirements(NodeTraversal t, Node callNode, Node fnNode, Set\u003cString\u003e namesToAlias) {\n    boolean fnContainsVars \u003d NodeUtil.has(NodeUtil.getFunctionBody(fnNode), new NodeUtil.MatchDeclaration(), new NodeUtil.MatchShallowStatement());\n    boolean callerContainsFunction \u003d false;\n    if (!t.inGlobalScope()) {\n        Node fnCaller \u003d t.getScopeRoot();\n        Node fnCallerBody \u003d fnCaller.getLastChild();\n        callerContainsFunction \u003d NodeUtil.containsFunction(fnCallerBody);\n    }\n    if (fnContainsVars \u0026\u0026 callerContainsFunction) {\n        return false;\n    }\n    if (callerContainsFunction) {\n        Map\u003cString, Node\u003e args \u003d FunctionArgumentInjector.getFunctionCallParameterMap(fnNode, callNode, this.safeNameIdSupplier);\n        boolean hasArgs \u003d !args.isEmpty();\n        if (hasArgs) {\n            Set\u003cString\u003e allNamesToAlias \u003d Sets.newHashSet(namesToAlias);\n            FunctionArgumentInjector.maybeAddTempsForCallArguments(fnNode, args, allNamesToAlias, compiler.getCodingConvention());\n            if (!allNamesToAlias.isEmpty()) {\n                return false;\n            }\n        }\n    }\n    return true;\n}",
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java",
          "functionStartLine": 562,
          "functionName": "callMeetsBlockInliningRequirements",
          "functionAnnotation": "",
          "functionDoc": "Determines whether a function can be inlined at a particular call site.\n- Don\u0027t inline if the calling function contains an inner function and\ninlining would introduce new globals.\n",
          "diff": "@@ -1,37 +1,24 @@\n-private boolean callMeetsBlockInliningRequirements(NodeTraversal t, Node callNode, final Node fnNode, Set\u003cString\u003e namesToAlias, boolean containsFunctions) {\n-    boolean hasLocalNames \u003d hasLocalNames(fnNode);\n-    boolean forbidTemps \u003d false;\n+private boolean callMeetsBlockInliningRequirements(NodeTraversal t, Node callNode, Node fnNode, Set\u003cString\u003e namesToAlias) {\n+    boolean fnContainsVars \u003d NodeUtil.has(NodeUtil.getFunctionBody(fnNode), new NodeUtil.MatchDeclaration(), new NodeUtil.MatchShallowStatement());\n+    boolean callerContainsFunction \u003d false;\n     if (!t.inGlobalScope()) {\n         Node fnCaller \u003d t.getScopeRoot();\n         Node fnCallerBody \u003d fnCaller.getLastChild();\n-        forbidTemps \u003d NodeUtil.isNameReferenced(fnCallerBody, \"eval\", NodeUtil.MATCH_NOT_FUNCTION);\n-        if (!forbidTemps \u0026\u0026 containsFunctions) {\n-            Predicate\u003cNode\u003e match \u003d new Predicate\u003cNode\u003e() {\n-\n-                @Override\n-                public boolean apply(Node n) {\n-                    if (n.getType() \u003d\u003d Token.FUNCTION) {\n-                        return n !\u003d fnNode;\n-                    }\n-                    return false;\n-                }\n-            };\n-            forbidTemps \u003d NodeUtil.has(fnCallerBody, match, NodeUtil.MATCH_NOT_FUNCTION);\n-        }\n+        callerContainsFunction \u003d NodeUtil.containsFunction(fnCallerBody);\n     }\n-    if (forbidTemps) {\n-        if (hasLocalNames) {\n-            return false;\n-        }\n+    if (fnContainsVars \u0026\u0026 callerContainsFunction) {\n+        return false;\n+    }\n+    if (callerContainsFunction) {\n         Map\u003cString, Node\u003e args \u003d FunctionArgumentInjector.getFunctionCallParameterMap(fnNode, callNode, this.safeNameIdSupplier);\n         boolean hasArgs \u003d !args.isEmpty();\n         if (hasArgs) {\n             Set\u003cString\u003e allNamesToAlias \u003d Sets.newHashSet(namesToAlias);\n             FunctionArgumentInjector.maybeAddTempsForCallArguments(fnNode, args, allNamesToAlias, compiler.getCodingConvention());\n             if (!allNamesToAlias.isEmpty()) {\n                 return false;\n             }\n         }\n     }\n     return true;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Yparametermetachange",
          "commitMessage": "\nAutomated g4 rollback.\n\n*** Reason for rollback ***\n\nBreaks tests\n\n*** Original change description ***\n\nTweaks to function inlining:\n- an unnamed function expression containing a inner unnamed function\nexpression should not be disallow because the names are the same.\n- a caller that only contains the function definition to be inlined should\nnot consider the candidate to be a capturing function.\n- allow inlining a function containing an inner function that\nreferences arguments.\n- disallow inlining a function into a function containing eval.\n- when inlining a function containing a function dec\n\n... description truncated by g4 rollback ...\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d2930\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1339 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "8/8/11, 2:51 PM",
          "commitName": "43cece8ccf72521faa04fc79fddfc5f7d661a787",
          "commitAuthor": "johnlenz@google.com",
          "commitDateOld": "8/8/11, 2:03 PM",
          "commitNameOld": "0b05c26eefae171f9b4d0e1f8eba4249088207fa",
          "commitAuthorOld": "johnlenz@google.com",
          "daysBetweenCommits": 0.03,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "private boolean callMeetsBlockInliningRequirements(NodeTraversal t, Node callNode, Node fnNode, Set\u003cString\u003e namesToAlias) {\n    boolean fnContainsVars \u003d NodeUtil.has(NodeUtil.getFunctionBody(fnNode), new NodeUtil.MatchDeclaration(), new NodeUtil.MatchShallowStatement());\n    boolean callerContainsFunction \u003d false;\n    if (!t.inGlobalScope()) {\n        Node fnCaller \u003d t.getScopeRoot();\n        Node fnCallerBody \u003d fnCaller.getLastChild();\n        callerContainsFunction \u003d NodeUtil.containsFunction(fnCallerBody);\n    }\n    if (fnContainsVars \u0026\u0026 callerContainsFunction) {\n        return false;\n    }\n    if (callerContainsFunction) {\n        Map\u003cString, Node\u003e args \u003d FunctionArgumentInjector.getFunctionCallParameterMap(fnNode, callNode, this.safeNameIdSupplier);\n        boolean hasArgs \u003d !args.isEmpty();\n        if (hasArgs) {\n            Set\u003cString\u003e allNamesToAlias \u003d Sets.newHashSet(namesToAlias);\n            FunctionArgumentInjector.maybeAddTempsForCallArguments(fnNode, args, allNamesToAlias, compiler.getCodingConvention());\n            if (!allNamesToAlias.isEmpty()) {\n                return false;\n            }\n        }\n    }\n    return true;\n}",
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java",
          "functionStartLine": 562,
          "functionName": "callMeetsBlockInliningRequirements",
          "functionAnnotation": "",
          "functionDoc": "Determines whether a function can be inlined at a particular call site.\n- Don\u0027t inline if the calling function contains an inner function and\ninlining would introduce new globals.\n",
          "diff": "@@ -1,37 +1,24 @@\n-private boolean callMeetsBlockInliningRequirements(NodeTraversal t, Node callNode, final Node fnNode, Set\u003cString\u003e namesToAlias, boolean containsFunctions) {\n-    boolean hasLocalNames \u003d hasLocalNames(fnNode);\n-    boolean forbidTemps \u003d false;\n+private boolean callMeetsBlockInliningRequirements(NodeTraversal t, Node callNode, Node fnNode, Set\u003cString\u003e namesToAlias) {\n+    boolean fnContainsVars \u003d NodeUtil.has(NodeUtil.getFunctionBody(fnNode), new NodeUtil.MatchDeclaration(), new NodeUtil.MatchShallowStatement());\n+    boolean callerContainsFunction \u003d false;\n     if (!t.inGlobalScope()) {\n         Node fnCaller \u003d t.getScopeRoot();\n         Node fnCallerBody \u003d fnCaller.getLastChild();\n-        forbidTemps \u003d NodeUtil.isNameReferenced(fnCallerBody, \"eval\", NodeUtil.MATCH_NOT_FUNCTION);\n-        if (!forbidTemps \u0026\u0026 containsFunctions) {\n-            Predicate\u003cNode\u003e match \u003d new Predicate\u003cNode\u003e() {\n-\n-                @Override\n-                public boolean apply(Node n) {\n-                    if (n.getType() \u003d\u003d Token.FUNCTION) {\n-                        return n !\u003d fnNode;\n-                    }\n-                    return false;\n-                }\n-            };\n-            forbidTemps \u003d NodeUtil.has(fnCallerBody, match, NodeUtil.MATCH_NOT_FUNCTION);\n-        }\n+        callerContainsFunction \u003d NodeUtil.containsFunction(fnCallerBody);\n     }\n-    if (forbidTemps) {\n-        if (hasLocalNames) {\n-            return false;\n-        }\n+    if (fnContainsVars \u0026\u0026 callerContainsFunction) {\n+        return false;\n+    }\n+    if (callerContainsFunction) {\n         Map\u003cString, Node\u003e args \u003d FunctionArgumentInjector.getFunctionCallParameterMap(fnNode, callNode, this.safeNameIdSupplier);\n         boolean hasArgs \u003d !args.isEmpty();\n         if (hasArgs) {\n             Set\u003cString\u003e allNamesToAlias \u003d Sets.newHashSet(namesToAlias);\n             FunctionArgumentInjector.maybeAddTempsForCallArguments(fnNode, args, allNamesToAlias, compiler.getCodingConvention());\n             if (!allNamesToAlias.isEmpty()) {\n                 return false;\n             }\n         }\n     }\n     return true;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[t-NodeTraversal, callNode-Node, fnNode-Node(modifiers-final), namesToAlias-Set\u003cString\u003e, containsFunctions-boolean]",
            "newValue": "[t-NodeTraversal, callNode-Node, fnNode-Node, namesToAlias-Set\u003cString\u003e]"
          }
        }
      ]
    },
    "0b05c26eefae171f9b4d0e1f8eba4249088207fa": {
      "type": "Ymultichange(Yparameterchange,Ybodychange,Yparametermetachange)",
      "commitMessage": "\nTweaks to function inlining:\n- an unnamed function expression containing a inner unnamed function\nexpression should not be disallow because the names are the same.\n- a caller that only contains the function definition to be inlined should\nnot consider the candidate to be a capturing function.\n- allow inlining a function containing an inner function that\nreferences arguments.\n- disallow inlining a function into a function containing eval.\n- when inlining a function containing a function declaration, rewrite\nit a var declarations and function expressions to avoid introducing\nfunction declaraions into contexts disallowed by ES5 strict.\n\nR\u003dacleung\nDELTA\u003d228  (182 added, 14 deleted, 32 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d2929\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1338 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "8/8/11, 2:03 PM",
      "commitName": "0b05c26eefae171f9b4d0e1f8eba4249088207fa",
      "commitAuthor": "johnlenz@google.com",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "\nTweaks to function inlining:\n- an unnamed function expression containing a inner unnamed function\nexpression should not be disallow because the names are the same.\n- a caller that only contains the function definition to be inlined should\nnot consider the candidate to be a capturing function.\n- allow inlining a function containing an inner function that\nreferences arguments.\n- disallow inlining a function into a function containing eval.\n- when inlining a function containing a function declaration, rewrite\nit a var declarations and function expressions to avoid introducing\nfunction declaraions into contexts disallowed by ES5 strict.\n\nR\u003dacleung\nDELTA\u003d228  (182 added, 14 deleted, 32 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d2929\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1338 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "8/8/11, 2:03 PM",
          "commitName": "0b05c26eefae171f9b4d0e1f8eba4249088207fa",
          "commitAuthor": "johnlenz@google.com",
          "commitDateOld": "7/28/11, 4:19 PM",
          "commitNameOld": "76abdf11394c0e7515ae63335676ea3657badb45",
          "commitAuthorOld": "johnlenz@google.com",
          "daysBetweenCommits": 10.91,
          "commitsBetweenForRepo": 29,
          "commitsBetweenForFile": 1,
          "actualSource": "private boolean callMeetsBlockInliningRequirements(NodeTraversal t, Node callNode, final Node fnNode, Set\u003cString\u003e namesToAlias, boolean containsFunctions) {\n    boolean hasLocalNames \u003d hasLocalNames(fnNode);\n    boolean forbidTemps \u003d false;\n    if (!t.inGlobalScope()) {\n        Node fnCaller \u003d t.getScopeRoot();\n        Node fnCallerBody \u003d fnCaller.getLastChild();\n        forbidTemps \u003d NodeUtil.isNameReferenced(fnCallerBody, \"eval\", NodeUtil.MATCH_NOT_FUNCTION);\n        if (!forbidTemps \u0026\u0026 containsFunctions) {\n            Predicate\u003cNode\u003e match \u003d new Predicate\u003cNode\u003e() {\n\n                @Override\n                public boolean apply(Node n) {\n                    if (n.getType() \u003d\u003d Token.FUNCTION) {\n                        return n !\u003d fnNode;\n                    }\n                    return false;\n                }\n            };\n            forbidTemps \u003d NodeUtil.has(fnCallerBody, match, NodeUtil.MATCH_NOT_FUNCTION);\n        }\n    }\n    if (forbidTemps) {\n        if (hasLocalNames) {\n            return false;\n        }\n        Map\u003cString, Node\u003e args \u003d FunctionArgumentInjector.getFunctionCallParameterMap(fnNode, callNode, this.safeNameIdSupplier);\n        boolean hasArgs \u003d !args.isEmpty();\n        if (hasArgs) {\n            Set\u003cString\u003e allNamesToAlias \u003d Sets.newHashSet(namesToAlias);\n            FunctionArgumentInjector.maybeAddTempsForCallArguments(fnNode, args, allNamesToAlias, compiler.getCodingConvention());\n            if (!allNamesToAlias.isEmpty()) {\n                return false;\n            }\n        }\n    }\n    return true;\n}",
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java",
          "functionStartLine": 560,
          "functionName": "callMeetsBlockInliningRequirements",
          "functionAnnotation": "",
          "functionDoc": "Determines whether a function can be inlined at a particular call site.\n- Don\u0027t inline if the calling function contains an inner function and\ninlining would introduce new globals.\n",
          "diff": "@@ -1,24 +1,37 @@\n-private boolean callMeetsBlockInliningRequirements(NodeTraversal t, Node callNode, Node fnNode, Set\u003cString\u003e namesToAlias) {\n-    boolean fnContainsVars \u003d NodeUtil.has(NodeUtil.getFunctionBody(fnNode), new NodeUtil.MatchDeclaration(), new NodeUtil.MatchShallowStatement());\n-    boolean callerContainsFunction \u003d false;\n+private boolean callMeetsBlockInliningRequirements(NodeTraversal t, Node callNode, final Node fnNode, Set\u003cString\u003e namesToAlias, boolean containsFunctions) {\n+    boolean hasLocalNames \u003d hasLocalNames(fnNode);\n+    boolean forbidTemps \u003d false;\n     if (!t.inGlobalScope()) {\n         Node fnCaller \u003d t.getScopeRoot();\n         Node fnCallerBody \u003d fnCaller.getLastChild();\n-        callerContainsFunction \u003d NodeUtil.containsFunction(fnCallerBody);\n+        forbidTemps \u003d NodeUtil.isNameReferenced(fnCallerBody, \"eval\", NodeUtil.MATCH_NOT_FUNCTION);\n+        if (!forbidTemps \u0026\u0026 containsFunctions) {\n+            Predicate\u003cNode\u003e match \u003d new Predicate\u003cNode\u003e() {\n+\n+                @Override\n+                public boolean apply(Node n) {\n+                    if (n.getType() \u003d\u003d Token.FUNCTION) {\n+                        return n !\u003d fnNode;\n+                    }\n+                    return false;\n+                }\n+            };\n+            forbidTemps \u003d NodeUtil.has(fnCallerBody, match, NodeUtil.MATCH_NOT_FUNCTION);\n+        }\n     }\n-    if (fnContainsVars \u0026\u0026 callerContainsFunction) {\n-        return false;\n-    }\n-    if (callerContainsFunction) {\n+    if (forbidTemps) {\n+        if (hasLocalNames) {\n+            return false;\n+        }\n         Map\u003cString, Node\u003e args \u003d FunctionArgumentInjector.getFunctionCallParameterMap(fnNode, callNode, this.safeNameIdSupplier);\n         boolean hasArgs \u003d !args.isEmpty();\n         if (hasArgs) {\n             Set\u003cString\u003e allNamesToAlias \u003d Sets.newHashSet(namesToAlias);\n             FunctionArgumentInjector.maybeAddTempsForCallArguments(fnNode, args, allNamesToAlias, compiler.getCodingConvention());\n             if (!allNamesToAlias.isEmpty()) {\n                 return false;\n             }\n         }\n     }\n     return true;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[t-NodeTraversal, callNode-Node, fnNode-Node, namesToAlias-Set\u003cString\u003e]",
            "newValue": "[t-NodeTraversal, callNode-Node, fnNode-Node(modifiers-final), namesToAlias-Set\u003cString\u003e, containsFunctions-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "\nTweaks to function inlining:\n- an unnamed function expression containing a inner unnamed function\nexpression should not be disallow because the names are the same.\n- a caller that only contains the function definition to be inlined should\nnot consider the candidate to be a capturing function.\n- allow inlining a function containing an inner function that\nreferences arguments.\n- disallow inlining a function into a function containing eval.\n- when inlining a function containing a function declaration, rewrite\nit a var declarations and function expressions to avoid introducing\nfunction declaraions into contexts disallowed by ES5 strict.\n\nR\u003dacleung\nDELTA\u003d228  (182 added, 14 deleted, 32 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d2929\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1338 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "8/8/11, 2:03 PM",
          "commitName": "0b05c26eefae171f9b4d0e1f8eba4249088207fa",
          "commitAuthor": "johnlenz@google.com",
          "commitDateOld": "7/28/11, 4:19 PM",
          "commitNameOld": "76abdf11394c0e7515ae63335676ea3657badb45",
          "commitAuthorOld": "johnlenz@google.com",
          "daysBetweenCommits": 10.91,
          "commitsBetweenForRepo": 29,
          "commitsBetweenForFile": 1,
          "actualSource": "private boolean callMeetsBlockInliningRequirements(NodeTraversal t, Node callNode, final Node fnNode, Set\u003cString\u003e namesToAlias, boolean containsFunctions) {\n    boolean hasLocalNames \u003d hasLocalNames(fnNode);\n    boolean forbidTemps \u003d false;\n    if (!t.inGlobalScope()) {\n        Node fnCaller \u003d t.getScopeRoot();\n        Node fnCallerBody \u003d fnCaller.getLastChild();\n        forbidTemps \u003d NodeUtil.isNameReferenced(fnCallerBody, \"eval\", NodeUtil.MATCH_NOT_FUNCTION);\n        if (!forbidTemps \u0026\u0026 containsFunctions) {\n            Predicate\u003cNode\u003e match \u003d new Predicate\u003cNode\u003e() {\n\n                @Override\n                public boolean apply(Node n) {\n                    if (n.getType() \u003d\u003d Token.FUNCTION) {\n                        return n !\u003d fnNode;\n                    }\n                    return false;\n                }\n            };\n            forbidTemps \u003d NodeUtil.has(fnCallerBody, match, NodeUtil.MATCH_NOT_FUNCTION);\n        }\n    }\n    if (forbidTemps) {\n        if (hasLocalNames) {\n            return false;\n        }\n        Map\u003cString, Node\u003e args \u003d FunctionArgumentInjector.getFunctionCallParameterMap(fnNode, callNode, this.safeNameIdSupplier);\n        boolean hasArgs \u003d !args.isEmpty();\n        if (hasArgs) {\n            Set\u003cString\u003e allNamesToAlias \u003d Sets.newHashSet(namesToAlias);\n            FunctionArgumentInjector.maybeAddTempsForCallArguments(fnNode, args, allNamesToAlias, compiler.getCodingConvention());\n            if (!allNamesToAlias.isEmpty()) {\n                return false;\n            }\n        }\n    }\n    return true;\n}",
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java",
          "functionStartLine": 560,
          "functionName": "callMeetsBlockInliningRequirements",
          "functionAnnotation": "",
          "functionDoc": "Determines whether a function can be inlined at a particular call site.\n- Don\u0027t inline if the calling function contains an inner function and\ninlining would introduce new globals.\n",
          "diff": "@@ -1,24 +1,37 @@\n-private boolean callMeetsBlockInliningRequirements(NodeTraversal t, Node callNode, Node fnNode, Set\u003cString\u003e namesToAlias) {\n-    boolean fnContainsVars \u003d NodeUtil.has(NodeUtil.getFunctionBody(fnNode), new NodeUtil.MatchDeclaration(), new NodeUtil.MatchShallowStatement());\n-    boolean callerContainsFunction \u003d false;\n+private boolean callMeetsBlockInliningRequirements(NodeTraversal t, Node callNode, final Node fnNode, Set\u003cString\u003e namesToAlias, boolean containsFunctions) {\n+    boolean hasLocalNames \u003d hasLocalNames(fnNode);\n+    boolean forbidTemps \u003d false;\n     if (!t.inGlobalScope()) {\n         Node fnCaller \u003d t.getScopeRoot();\n         Node fnCallerBody \u003d fnCaller.getLastChild();\n-        callerContainsFunction \u003d NodeUtil.containsFunction(fnCallerBody);\n+        forbidTemps \u003d NodeUtil.isNameReferenced(fnCallerBody, \"eval\", NodeUtil.MATCH_NOT_FUNCTION);\n+        if (!forbidTemps \u0026\u0026 containsFunctions) {\n+            Predicate\u003cNode\u003e match \u003d new Predicate\u003cNode\u003e() {\n+\n+                @Override\n+                public boolean apply(Node n) {\n+                    if (n.getType() \u003d\u003d Token.FUNCTION) {\n+                        return n !\u003d fnNode;\n+                    }\n+                    return false;\n+                }\n+            };\n+            forbidTemps \u003d NodeUtil.has(fnCallerBody, match, NodeUtil.MATCH_NOT_FUNCTION);\n+        }\n     }\n-    if (fnContainsVars \u0026\u0026 callerContainsFunction) {\n-        return false;\n-    }\n-    if (callerContainsFunction) {\n+    if (forbidTemps) {\n+        if (hasLocalNames) {\n+            return false;\n+        }\n         Map\u003cString, Node\u003e args \u003d FunctionArgumentInjector.getFunctionCallParameterMap(fnNode, callNode, this.safeNameIdSupplier);\n         boolean hasArgs \u003d !args.isEmpty();\n         if (hasArgs) {\n             Set\u003cString\u003e allNamesToAlias \u003d Sets.newHashSet(namesToAlias);\n             FunctionArgumentInjector.maybeAddTempsForCallArguments(fnNode, args, allNamesToAlias, compiler.getCodingConvention());\n             if (!allNamesToAlias.isEmpty()) {\n                 return false;\n             }\n         }\n     }\n     return true;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Yparametermetachange",
          "commitMessage": "\nTweaks to function inlining:\n- an unnamed function expression containing a inner unnamed function\nexpression should not be disallow because the names are the same.\n- a caller that only contains the function definition to be inlined should\nnot consider the candidate to be a capturing function.\n- allow inlining a function containing an inner function that\nreferences arguments.\n- disallow inlining a function into a function containing eval.\n- when inlining a function containing a function declaration, rewrite\nit a var declarations and function expressions to avoid introducing\nfunction declaraions into contexts disallowed by ES5 strict.\n\nR\u003dacleung\nDELTA\u003d228  (182 added, 14 deleted, 32 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d2929\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1338 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "8/8/11, 2:03 PM",
          "commitName": "0b05c26eefae171f9b4d0e1f8eba4249088207fa",
          "commitAuthor": "johnlenz@google.com",
          "commitDateOld": "7/28/11, 4:19 PM",
          "commitNameOld": "76abdf11394c0e7515ae63335676ea3657badb45",
          "commitAuthorOld": "johnlenz@google.com",
          "daysBetweenCommits": 10.91,
          "commitsBetweenForRepo": 29,
          "commitsBetweenForFile": 1,
          "actualSource": "private boolean callMeetsBlockInliningRequirements(NodeTraversal t, Node callNode, final Node fnNode, Set\u003cString\u003e namesToAlias, boolean containsFunctions) {\n    boolean hasLocalNames \u003d hasLocalNames(fnNode);\n    boolean forbidTemps \u003d false;\n    if (!t.inGlobalScope()) {\n        Node fnCaller \u003d t.getScopeRoot();\n        Node fnCallerBody \u003d fnCaller.getLastChild();\n        forbidTemps \u003d NodeUtil.isNameReferenced(fnCallerBody, \"eval\", NodeUtil.MATCH_NOT_FUNCTION);\n        if (!forbidTemps \u0026\u0026 containsFunctions) {\n            Predicate\u003cNode\u003e match \u003d new Predicate\u003cNode\u003e() {\n\n                @Override\n                public boolean apply(Node n) {\n                    if (n.getType() \u003d\u003d Token.FUNCTION) {\n                        return n !\u003d fnNode;\n                    }\n                    return false;\n                }\n            };\n            forbidTemps \u003d NodeUtil.has(fnCallerBody, match, NodeUtil.MATCH_NOT_FUNCTION);\n        }\n    }\n    if (forbidTemps) {\n        if (hasLocalNames) {\n            return false;\n        }\n        Map\u003cString, Node\u003e args \u003d FunctionArgumentInjector.getFunctionCallParameterMap(fnNode, callNode, this.safeNameIdSupplier);\n        boolean hasArgs \u003d !args.isEmpty();\n        if (hasArgs) {\n            Set\u003cString\u003e allNamesToAlias \u003d Sets.newHashSet(namesToAlias);\n            FunctionArgumentInjector.maybeAddTempsForCallArguments(fnNode, args, allNamesToAlias, compiler.getCodingConvention());\n            if (!allNamesToAlias.isEmpty()) {\n                return false;\n            }\n        }\n    }\n    return true;\n}",
          "path": "src/com/google/javascript/jscomp/FunctionInjector.java",
          "functionStartLine": 560,
          "functionName": "callMeetsBlockInliningRequirements",
          "functionAnnotation": "",
          "functionDoc": "Determines whether a function can be inlined at a particular call site.\n- Don\u0027t inline if the calling function contains an inner function and\ninlining would introduce new globals.\n",
          "diff": "@@ -1,24 +1,37 @@\n-private boolean callMeetsBlockInliningRequirements(NodeTraversal t, Node callNode, Node fnNode, Set\u003cString\u003e namesToAlias) {\n-    boolean fnContainsVars \u003d NodeUtil.has(NodeUtil.getFunctionBody(fnNode), new NodeUtil.MatchDeclaration(), new NodeUtil.MatchShallowStatement());\n-    boolean callerContainsFunction \u003d false;\n+private boolean callMeetsBlockInliningRequirements(NodeTraversal t, Node callNode, final Node fnNode, Set\u003cString\u003e namesToAlias, boolean containsFunctions) {\n+    boolean hasLocalNames \u003d hasLocalNames(fnNode);\n+    boolean forbidTemps \u003d false;\n     if (!t.inGlobalScope()) {\n         Node fnCaller \u003d t.getScopeRoot();\n         Node fnCallerBody \u003d fnCaller.getLastChild();\n-        callerContainsFunction \u003d NodeUtil.containsFunction(fnCallerBody);\n+        forbidTemps \u003d NodeUtil.isNameReferenced(fnCallerBody, \"eval\", NodeUtil.MATCH_NOT_FUNCTION);\n+        if (!forbidTemps \u0026\u0026 containsFunctions) {\n+            Predicate\u003cNode\u003e match \u003d new Predicate\u003cNode\u003e() {\n+\n+                @Override\n+                public boolean apply(Node n) {\n+                    if (n.getType() \u003d\u003d Token.FUNCTION) {\n+                        return n !\u003d fnNode;\n+                    }\n+                    return false;\n+                }\n+            };\n+            forbidTemps \u003d NodeUtil.has(fnCallerBody, match, NodeUtil.MATCH_NOT_FUNCTION);\n+        }\n     }\n-    if (fnContainsVars \u0026\u0026 callerContainsFunction) {\n-        return false;\n-    }\n-    if (callerContainsFunction) {\n+    if (forbidTemps) {\n+        if (hasLocalNames) {\n+            return false;\n+        }\n         Map\u003cString, Node\u003e args \u003d FunctionArgumentInjector.getFunctionCallParameterMap(fnNode, callNode, this.safeNameIdSupplier);\n         boolean hasArgs \u003d !args.isEmpty();\n         if (hasArgs) {\n             Set\u003cString\u003e allNamesToAlias \u003d Sets.newHashSet(namesToAlias);\n             FunctionArgumentInjector.maybeAddTempsForCallArguments(fnNode, args, allNamesToAlias, compiler.getCodingConvention());\n             if (!allNamesToAlias.isEmpty()) {\n                 return false;\n             }\n         }\n     }\n     return true;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[t-NodeTraversal, callNode-Node, fnNode-Node, namesToAlias-Set\u003cString\u003e]",
            "newValue": "[t-NodeTraversal, callNode-Node, fnNode-Node(modifiers-final), namesToAlias-Set\u003cString\u003e, containsFunctions-boolean]"
          }
        }
      ]
    },
    "b4801b28ceea8db0f63da7440d6769cb9b7cce8a": {
      "type": "Ybodychange",
      "commitMessage": "\nChange on 2010/05/28 by johnlenz\n\n        Inline functions with inner functions into global scope if they don\u0027t\n        declare any names.\n\n        R\u003dacleung\n        DELTA\u003d329  (244 added, 27 deleted, 58 changed)\n\nChange on 2010/05/28 by dcc\n\n        First pass on refactoring FoldConstants into separate peephole optimizations. This changelist adds the notion of an AbstractPeepholeOptimization and adds a PeepholeOptimizationsPass that runs them. In this go around the minimization aspects of FoldConstants have been factored out into PeepholeMinimize. A future change will factor out the other components of FoldConstants into their own PeepholeOptimizations. DefaultPassConfig has also been updated to run the new PeepholeOptimizationPass.\n\n        This change does not move the minimization-related unit tests from FoldConstantsTest to PeepholeMinimizeTest -- a future, separate, change will do so. Hopefully this will make it easier to review.\n\n        R\u003dacleung\n        DELTA\u003d1966  (1271 added, 675 deleted, 20 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d13010\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@235 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "5/29/10, 1:07 PM",
      "commitName": "b4801b28ceea8db0f63da7440d6769cb9b7cce8a",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "4/16/10, 10:20 AM",
      "commitNameOld": "6e3eb4f7619179ba6c23db2af7549ef02f588c35",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 43.12,
      "commitsBetweenForRepo": 36,
      "commitsBetweenForFile": 1,
      "actualSource": "private boolean callMeetsBlockInliningRequirements(NodeTraversal t, Node callNode, Node fnNode, Set\u003cString\u003e namesToAlias) {\n    boolean fnContainsVars \u003d NodeUtil.has(NodeUtil.getFunctionBody(fnNode), new NodeUtil.MatchDeclaration(), new NodeUtil.MatchShallowStatement());\n    boolean callerContainsFunction \u003d false;\n    if (!t.inGlobalScope()) {\n        Node fnCaller \u003d t.getScopeRoot();\n        Node fnCallerBody \u003d fnCaller.getLastChild();\n        callerContainsFunction \u003d NodeUtil.containsFunction(fnCallerBody);\n    }\n    if (fnContainsVars \u0026\u0026 callerContainsFunction) {\n        return false;\n    }\n    if (callerContainsFunction) {\n        Map\u003cString, Node\u003e args \u003d FunctionArgumentInjector.getFunctionCallParameterMap(fnNode, callNode, this.safeNameIdSupplier);\n        boolean hasArgs \u003d !args.isEmpty();\n        if (hasArgs) {\n            Set\u003cString\u003e allNamesToAlias \u003d Sets.newHashSet(namesToAlias);\n            FunctionArgumentInjector.maybeAddTempsForCallArguments(fnNode, args, allNamesToAlias, compiler.getCodingConvention());\n            if (!allNamesToAlias.isEmpty()) {\n                return false;\n            }\n        }\n    }\n    return true;\n}",
      "path": "src/com/google/javascript/jscomp/FunctionInjector.java",
      "functionStartLine": 567,
      "functionName": "callMeetsBlockInliningRequirements",
      "functionAnnotation": "",
      "functionDoc": "Determines whether a function can be inlined at a particular call site.\n- Don\u0027t inline if the calling function contains an inner function and\ninlining would introduce new globals.\n",
      "diff": "@@ -1,24 +1,24 @@\n private boolean callMeetsBlockInliningRequirements(NodeTraversal t, Node callNode, Node fnNode, Set\u003cString\u003e namesToAlias) {\n-    boolean fnContainsVars \u003d NodeUtil.isNodeTypeReferenced(NodeUtil.getFunctionBody(fnNode), Token.VAR);\n+    boolean fnContainsVars \u003d NodeUtil.has(NodeUtil.getFunctionBody(fnNode), new NodeUtil.MatchDeclaration(), new NodeUtil.MatchShallowStatement());\n     boolean callerContainsFunction \u003d false;\n     if (!t.inGlobalScope()) {\n         Node fnCaller \u003d t.getScopeRoot();\n         Node fnCallerBody \u003d fnCaller.getLastChild();\n-        callerContainsFunction \u003d NodeUtil.containsFunctionDeclaration(fnCallerBody);\n+        callerContainsFunction \u003d NodeUtil.containsFunction(fnCallerBody);\n     }\n     if (fnContainsVars \u0026\u0026 callerContainsFunction) {\n         return false;\n     }\n     if (callerContainsFunction) {\n         Map\u003cString, Node\u003e args \u003d FunctionArgumentInjector.getFunctionCallParameterMap(fnNode, callNode, this.safeNameIdSupplier);\n         boolean hasArgs \u003d !args.isEmpty();\n         if (hasArgs) {\n             Set\u003cString\u003e allNamesToAlias \u003d Sets.newHashSet(namesToAlias);\n             FunctionArgumentInjector.maybeAddTempsForCallArguments(fnNode, args, allNamesToAlias, compiler.getCodingConvention());\n             if (!allNamesToAlias.isEmpty()) {\n                 return false;\n             }\n         }\n     }\n     return true;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": {
      "type": "Yintroduced",
      "commitMessage": "Initial commit.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/3/09, 3:51 PM",
      "commitName": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "diff": "@@ -0,0 +1,24 @@\n+private boolean callMeetsBlockInliningRequirements(NodeTraversal t, Node callNode, Node fnNode, Set\u003cString\u003e namesToAlias) {\n+    boolean fnContainsVars \u003d NodeUtil.isNodeTypeReferenced(NodeUtil.getFunctionBody(fnNode), Token.VAR);\n+    boolean callerContainsFunction \u003d false;\n+    if (!t.inGlobalScope()) {\n+        Node fnCaller \u003d t.getScopeRoot();\n+        Node fnCallerBody \u003d fnCaller.getLastChild();\n+        callerContainsFunction \u003d NodeUtil.containsFunctionDeclaration(fnCallerBody);\n+    }\n+    if (fnContainsVars \u0026\u0026 callerContainsFunction) {\n+        return false;\n+    }\n+    if (callerContainsFunction) {\n+        Map\u003cString, Node\u003e args \u003d FunctionArgumentInjector.getFunctionCallParameterMap(fnNode, callNode, this.safeNameIdSupplier);\n+        boolean hasArgs \u003d !args.isEmpty();\n+        if (hasArgs) {\n+            Set\u003cString\u003e allNamesToAlias \u003d Sets.newHashSet(namesToAlias);\n+            FunctionArgumentInjector.maybeAddTempsForCallArguments(fnNode, args, allNamesToAlias, compiler.getCodingConvention());\n+            if (!allNamesToAlias.isEmpty()) {\n+                return false;\n+            }\n+        }\n+    }\n+    return true;\n+}\n\\ No newline at end of file\n",
      "actualSource": "private boolean callMeetsBlockInliningRequirements(NodeTraversal t, Node callNode, Node fnNode, Set\u003cString\u003e namesToAlias) {\n    boolean fnContainsVars \u003d NodeUtil.isNodeTypeReferenced(NodeUtil.getFunctionBody(fnNode), Token.VAR);\n    boolean callerContainsFunction \u003d false;\n    if (!t.inGlobalScope()) {\n        Node fnCaller \u003d t.getScopeRoot();\n        Node fnCallerBody \u003d fnCaller.getLastChild();\n        callerContainsFunction \u003d NodeUtil.containsFunctionDeclaration(fnCallerBody);\n    }\n    if (fnContainsVars \u0026\u0026 callerContainsFunction) {\n        return false;\n    }\n    if (callerContainsFunction) {\n        Map\u003cString, Node\u003e args \u003d FunctionArgumentInjector.getFunctionCallParameterMap(fnNode, callNode, this.safeNameIdSupplier);\n        boolean hasArgs \u003d !args.isEmpty();\n        if (hasArgs) {\n            Set\u003cString\u003e allNamesToAlias \u003d Sets.newHashSet(namesToAlias);\n            FunctionArgumentInjector.maybeAddTempsForCallArguments(fnNode, args, allNamesToAlias, compiler.getCodingConvention());\n            if (!allNamesToAlias.isEmpty()) {\n                return false;\n            }\n        }\n    }\n    return true;\n}",
      "path": "src/com/google/javascript/jscomp/FunctionInjector.java",
      "functionStartLine": 558,
      "functionName": "callMeetsBlockInliningRequirements",
      "functionAnnotation": "",
      "functionDoc": "Determines whether a function can be inlined at a particular call site.\n- Don\u0027t inline if the calling function contains an inner function and\ninlining would introduce new globals.\n"
    }
  }
}