{
  "origin": "codeshovel",
  "repositoryName": "Math-54b",
  "repositoryPath": "/tmp/Math-54b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "Dfp.java",
  "functionName": "divide",
  "functionId": "divide___divisor-Dfp",
  "sourceFilePath": "src/main/java/org/apache/commons/math/dfp/Dfp.java",
  "functionAnnotation": "",
  "functionDoc": "Divide this by divisor.\n\n@param divisor divisor\n@return quotient of this by divisor\n",
  "functionStartLine": 1578,
  "functionEndLine": 1786,
  "numCommitsSeen": 4,
  "timeTaken": 674,
  "changeHistory": [
    "1eb0c0d7421823470de3a901643ae3be2c9e0a8e"
  ],
  "changeHistoryShort": {
    "1eb0c0d7421823470de3a901643ae3be2c9e0a8e": "Yintroduced"
  },
  "changeHistoryDetails": {
    "1eb0c0d7421823470de3a901643ae3be2c9e0a8e": {
      "type": "Yintroduced",
      "commitMessage": "added the dfp library\nThe Dfp class represent the high precision numbers, it implements our existing Field interface and hence each instance is associated with a DfpField that provides the constants at the required precision as well as factory methods. This allowed to remove the compile-time constraint in the library. Users can even use at the same time a field for 20 decimals digits precision and another field for 100 digits precision. Dfp instances with different precision CANNOT be mixed in the same computation (doing so creates a NaN). A few utility methods have been added, like constructors from integral types, isInfinite and isNaN methods, equal has been renames to equals and its signature changed to match the general Object method (a hashcode method has been added too).\nJIRA: MATH-412\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@992697 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "9/4/10, 3:59 PM",
      "commitName": "1eb0c0d7421823470de3a901643ae3be2c9e0a8e",
      "commitAuthor": "Luc Maisonobe",
      "diff": "@@ -0,0 +1,150 @@\n+public Dfp divide(Dfp divisor) {\n+    int[] dividend;\n+    int[] quotient;\n+    int[] remainder;\n+    int qd;\n+    int nsqd;\n+    int trial \u003d 0;\n+    int minadj;\n+    boolean trialgood;\n+    int md \u003d 0;\n+    int excp;\n+    if (field.getRadixDigits() !\u003d divisor.field.getRadixDigits()) {\n+        field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n+        final Dfp result \u003d newInstance(getZero());\n+        result.nans \u003d QNAN;\n+        return dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, divisor, result);\n+    }\n+    Dfp result \u003d newInstance(getZero());\n+    if (nans !\u003d FINITE || divisor.nans !\u003d FINITE) {\n+        if (isNaN()) {\n+            return this;\n+        }\n+        if (divisor.isNaN()) {\n+            return divisor;\n+        }\n+        if (nans \u003d\u003d INFINITE \u0026\u0026 divisor.nans \u003d\u003d FINITE) {\n+            result \u003d newInstance(this);\n+            result.sign \u003d (byte) (sign * divisor.sign);\n+            return result;\n+        }\n+        if (divisor.nans \u003d\u003d INFINITE \u0026\u0026 nans \u003d\u003d FINITE) {\n+            result \u003d newInstance(getZero());\n+            result.sign \u003d (byte) (sign * divisor.sign);\n+            return result;\n+        }\n+        if (divisor.nans \u003d\u003d INFINITE \u0026\u0026 nans \u003d\u003d INFINITE) {\n+            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n+            result \u003d newInstance(getZero());\n+            result.nans \u003d QNAN;\n+            result \u003d dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, divisor, result);\n+            return result;\n+        }\n+    }\n+    if (divisor.mant[mant.length - 1] \u003d\u003d 0) {\n+        field.setIEEEFlagsBits(DfpField.FLAG_DIV_ZERO);\n+        result \u003d newInstance(getZero());\n+        result.sign \u003d (byte) (sign * divisor.sign);\n+        result.nans \u003d INFINITE;\n+        result \u003d dotrap(DfpField.FLAG_DIV_ZERO, DIVIDE_TRAP, divisor, result);\n+        return result;\n+    }\n+    dividend \u003d new int[mant.length + 1];\n+    quotient \u003d new int[mant.length + 2];\n+    remainder \u003d new int[mant.length + 1];\n+    dividend[mant.length] \u003d 0;\n+    quotient[mant.length] \u003d 0;\n+    quotient[mant.length + 1] \u003d 0;\n+    remainder[mant.length] \u003d 0;\n+    for (int i \u003d 0; i \u003c mant.length; i++) {\n+        dividend[i] \u003d mant[i];\n+        quotient[i] \u003d 0;\n+        remainder[i] \u003d 0;\n+    }\n+    nsqd \u003d 0;\n+    for (qd \u003d mant.length + 1; qd \u003e\u003d 0; qd--) {\n+        final int divMsb \u003d dividend[mant.length] * RADIX + dividend[mant.length - 1];\n+        int min \u003d divMsb / (divisor.mant[mant.length - 1] + 1);\n+        int max \u003d (divMsb + 1) / divisor.mant[mant.length - 1];\n+        trialgood \u003d false;\n+        while (!trialgood) {\n+            trial \u003d (min + max) / 2;\n+            int rh \u003d 0;\n+            for (int i \u003d 0; i \u003c mant.length + 1; i++) {\n+                int dm \u003d (i \u003c mant.length) ? divisor.mant[i] : 0;\n+                final int r \u003d (dm * trial) + rh;\n+                rh \u003d r / RADIX;\n+                remainder[i] \u003d r - rh * RADIX;\n+            }\n+            rh \u003d 1;\n+            for (int i \u003d 0; i \u003c mant.length + 1; i++) {\n+                final int r \u003d ((RADIX - 1) - remainder[i]) + dividend[i] + rh;\n+                rh \u003d r / RADIX;\n+                remainder[i] \u003d r - rh * RADIX;\n+            }\n+            if (rh \u003d\u003d 0) {\n+                max \u003d trial - 1;\n+                continue;\n+            }\n+            minadj \u003d (remainder[mant.length] * RADIX) + remainder[mant.length - 1];\n+            minadj \u003d minadj / (divisor.mant[mant.length - 1] + 1);\n+            if (minadj \u003e\u003d 2) {\n+                min \u003d trial + minadj;\n+                continue;\n+            }\n+            trialgood \u003d false;\n+            for (int i \u003d mant.length - 1; i \u003e\u003d 0; i--) {\n+                if (divisor.mant[i] \u003e remainder[i]) {\n+                    trialgood \u003d true;\n+                }\n+                if (divisor.mant[i] \u003c remainder[i]) {\n+                    break;\n+                }\n+            }\n+            if (remainder[mant.length] !\u003d 0) {\n+                trialgood \u003d false;\n+            }\n+            if (trialgood \u003d\u003d false) {\n+                min \u003d trial + 1;\n+            }\n+        }\n+        quotient[qd] \u003d trial;\n+        if (trial !\u003d 0 || nsqd !\u003d 0) {\n+            nsqd++;\n+        }\n+        if (field.getRoundingMode() \u003d\u003d DfpField.RoundingMode.ROUND_DOWN \u0026\u0026 nsqd \u003d\u003d mant.length) {\n+            break;\n+        }\n+        if (nsqd \u003e mant.length) {\n+            break;\n+        }\n+        dividend[0] \u003d 0;\n+        for (int i \u003d 0; i \u003c mant.length; i++) {\n+            dividend[i + 1] \u003d remainder[i];\n+        }\n+    }\n+    md \u003d mant.length;\n+    for (int i \u003d mant.length + 1; i \u003e\u003d 0; i--) {\n+        if (quotient[i] !\u003d 0) {\n+            md \u003d i;\n+            break;\n+        }\n+    }\n+    for (int i \u003d 0; i \u003c mant.length; i++) {\n+        result.mant[mant.length - i - 1] \u003d quotient[md - i];\n+    }\n+    result.exp \u003d exp - divisor.exp + md - mant.length;\n+    result.sign \u003d (byte) ((sign \u003d\u003d divisor.sign) ? 1 : -1);\n+    if (result.mant[mant.length - 1] \u003d\u003d 0) {\n+        result.exp \u003d 0;\n+    }\n+    if (md \u003e (mant.length - 1)) {\n+        excp \u003d result.round(quotient[md - mant.length]);\n+    } else {\n+        excp \u003d result.round(0);\n+    }\n+    if (excp !\u003d 0) {\n+        result \u003d dotrap(excp, DIVIDE_TRAP, divisor, result);\n+    }\n+    return result;\n+}\n\\ No newline at end of file\n",
      "actualSource": "public Dfp divide(Dfp divisor) {\n    int[] dividend;\n    int[] quotient;\n    int[] remainder;\n    int qd;\n    int nsqd;\n    int trial \u003d 0;\n    int minadj;\n    boolean trialgood;\n    int md \u003d 0;\n    int excp;\n    if (field.getRadixDigits() !\u003d divisor.field.getRadixDigits()) {\n        field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n        final Dfp result \u003d newInstance(getZero());\n        result.nans \u003d QNAN;\n        return dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, divisor, result);\n    }\n    Dfp result \u003d newInstance(getZero());\n    if (nans !\u003d FINITE || divisor.nans !\u003d FINITE) {\n        if (isNaN()) {\n            return this;\n        }\n        if (divisor.isNaN()) {\n            return divisor;\n        }\n        if (nans \u003d\u003d INFINITE \u0026\u0026 divisor.nans \u003d\u003d FINITE) {\n            result \u003d newInstance(this);\n            result.sign \u003d (byte) (sign * divisor.sign);\n            return result;\n        }\n        if (divisor.nans \u003d\u003d INFINITE \u0026\u0026 nans \u003d\u003d FINITE) {\n            result \u003d newInstance(getZero());\n            result.sign \u003d (byte) (sign * divisor.sign);\n            return result;\n        }\n        if (divisor.nans \u003d\u003d INFINITE \u0026\u0026 nans \u003d\u003d INFINITE) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result \u003d newInstance(getZero());\n            result.nans \u003d QNAN;\n            result \u003d dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, divisor, result);\n            return result;\n        }\n    }\n    if (divisor.mant[mant.length - 1] \u003d\u003d 0) {\n        field.setIEEEFlagsBits(DfpField.FLAG_DIV_ZERO);\n        result \u003d newInstance(getZero());\n        result.sign \u003d (byte) (sign * divisor.sign);\n        result.nans \u003d INFINITE;\n        result \u003d dotrap(DfpField.FLAG_DIV_ZERO, DIVIDE_TRAP, divisor, result);\n        return result;\n    }\n    dividend \u003d new int[mant.length + 1];\n    quotient \u003d new int[mant.length + 2];\n    remainder \u003d new int[mant.length + 1];\n    dividend[mant.length] \u003d 0;\n    quotient[mant.length] \u003d 0;\n    quotient[mant.length + 1] \u003d 0;\n    remainder[mant.length] \u003d 0;\n    for (int i \u003d 0; i \u003c mant.length; i++) {\n        dividend[i] \u003d mant[i];\n        quotient[i] \u003d 0;\n        remainder[i] \u003d 0;\n    }\n    nsqd \u003d 0;\n    for (qd \u003d mant.length + 1; qd \u003e\u003d 0; qd--) {\n        final int divMsb \u003d dividend[mant.length] * RADIX + dividend[mant.length - 1];\n        int min \u003d divMsb / (divisor.mant[mant.length - 1] + 1);\n        int max \u003d (divMsb + 1) / divisor.mant[mant.length - 1];\n        trialgood \u003d false;\n        while (!trialgood) {\n            trial \u003d (min + max) / 2;\n            int rh \u003d 0;\n            for (int i \u003d 0; i \u003c mant.length + 1; i++) {\n                int dm \u003d (i \u003c mant.length) ? divisor.mant[i] : 0;\n                final int r \u003d (dm * trial) + rh;\n                rh \u003d r / RADIX;\n                remainder[i] \u003d r - rh * RADIX;\n            }\n            rh \u003d 1;\n            for (int i \u003d 0; i \u003c mant.length + 1; i++) {\n                final int r \u003d ((RADIX - 1) - remainder[i]) + dividend[i] + rh;\n                rh \u003d r / RADIX;\n                remainder[i] \u003d r - rh * RADIX;\n            }\n            if (rh \u003d\u003d 0) {\n                max \u003d trial - 1;\n                continue;\n            }\n            minadj \u003d (remainder[mant.length] * RADIX) + remainder[mant.length - 1];\n            minadj \u003d minadj / (divisor.mant[mant.length - 1] + 1);\n            if (minadj \u003e\u003d 2) {\n                min \u003d trial + minadj;\n                continue;\n            }\n            trialgood \u003d false;\n            for (int i \u003d mant.length - 1; i \u003e\u003d 0; i--) {\n                if (divisor.mant[i] \u003e remainder[i]) {\n                    trialgood \u003d true;\n                }\n                if (divisor.mant[i] \u003c remainder[i]) {\n                    break;\n                }\n            }\n            if (remainder[mant.length] !\u003d 0) {\n                trialgood \u003d false;\n            }\n            if (trialgood \u003d\u003d false) {\n                min \u003d trial + 1;\n            }\n        }\n        quotient[qd] \u003d trial;\n        if (trial !\u003d 0 || nsqd !\u003d 0) {\n            nsqd++;\n        }\n        if (field.getRoundingMode() \u003d\u003d DfpField.RoundingMode.ROUND_DOWN \u0026\u0026 nsqd \u003d\u003d mant.length) {\n            break;\n        }\n        if (nsqd \u003e mant.length) {\n            break;\n        }\n        dividend[0] \u003d 0;\n        for (int i \u003d 0; i \u003c mant.length; i++) {\n            dividend[i + 1] \u003d remainder[i];\n        }\n    }\n    md \u003d mant.length;\n    for (int i \u003d mant.length + 1; i \u003e\u003d 0; i--) {\n        if (quotient[i] !\u003d 0) {\n            md \u003d i;\n            break;\n        }\n    }\n    for (int i \u003d 0; i \u003c mant.length; i++) {\n        result.mant[mant.length - i - 1] \u003d quotient[md - i];\n    }\n    result.exp \u003d exp - divisor.exp + md - mant.length;\n    result.sign \u003d (byte) ((sign \u003d\u003d divisor.sign) ? 1 : -1);\n    if (result.mant[mant.length - 1] \u003d\u003d 0) {\n        result.exp \u003d 0;\n    }\n    if (md \u003e (mant.length - 1)) {\n        excp \u003d result.round(quotient[md - mant.length]);\n    } else {\n        excp \u003d result.round(0);\n    }\n    if (excp !\u003d 0) {\n        result \u003d dotrap(excp, DIVIDE_TRAP, divisor, result);\n    }\n    return result;\n}",
      "path": "src/main/java/org/apache/commons/math/dfp/Dfp.java",
      "functionStartLine": 1578,
      "functionName": "divide",
      "functionAnnotation": "",
      "functionDoc": "Divide this by divisor.\n\n@param divisor divisor\n@return quotient of this by divisor\n"
    }
  }
}