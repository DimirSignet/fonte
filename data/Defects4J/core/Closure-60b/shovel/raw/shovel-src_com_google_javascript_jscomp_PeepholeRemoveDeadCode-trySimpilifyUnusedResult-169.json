{
  "origin": "codeshovel",
  "repositoryName": "Closure-60b",
  "repositoryPath": "/tmp/Closure-60b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "PeepholeRemoveDeadCode.java",
  "functionName": "trySimpilifyUnusedResult",
  "functionId": "trySimpilifyUnusedResult___n-Node__removeUnused-boolean",
  "sourceFilePath": "src/com/google/javascript/jscomp/PeepholeRemoveDeadCode.java",
  "functionAnnotation": "",
  "functionDoc": "General cascading unused operation node removal.\n\n@param n The root of the expression to simplify.\n@param removeUnused If true, the node is removed from the AST if\n    it is not useful, otherwise it replaced with an EMPTY node.\n@return The replacement node, or null if the node was is not useful.\n",
  "functionStartLine": 169,
  "functionEndLine": 279,
  "numCommitsSeen": 24,
  "timeTaken": 1769,
  "changeHistory": [
    "48701cc70fde194c05ecd008fc1015b9d82921d1"
  ],
  "changeHistoryShort": {
    "48701cc70fde194c05ecd008fc1015b9d82921d1": "Yintroduced"
  },
  "changeHistoryDetails": {
    "48701cc70fde194c05ecd008fc1015b9d82921d1": {
      "type": "Yintroduced",
      "commitMessage": "\n- Generalize unused operation removal and remove a couple of special cases (HOOK, NOT).\n- Add handling for other AST locations that can have unused ops removed (COMMA lhs and FOR increment expressions).\n\nR\u003dacleung\nDELTA\u003d358  (260 added, 80 deleted, 18 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d197245\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@390 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "8/27/10, 3:09 PM",
      "commitName": "48701cc70fde194c05ecd008fc1015b9d82921d1",
      "commitAuthor": "johnlenz@google.com",
      "diff": "@@ -0,0 +1,79 @@\n+private Node trySimpilifyUnusedResult(Node n, boolean removeUnused) {\n+    Node result \u003d n;\n+    switch(n.getType()) {\n+        case Token.HOOK:\n+            Node trueNode \u003d trySimpilifyUnusedResult(n.getFirstChild().getNext());\n+            Node falseNode \u003d trySimpilifyUnusedResult(n.getLastChild());\n+            if (trueNode \u003d\u003d null \u0026\u0026 falseNode !\u003d null) {\n+                n.setType(Token.OR);\n+                Preconditions.checkState(n.getChildCount() \u003d\u003d 2);\n+            } else if (trueNode !\u003d null \u0026\u0026 falseNode \u003d\u003d null) {\n+                n.setType(Token.AND);\n+                Preconditions.checkState(n.getChildCount() \u003d\u003d 2);\n+            } else if (trueNode \u003d\u003d null \u0026\u0026 falseNode \u003d\u003d null) {\n+                result \u003d trySimpilifyUnusedResult(n.getFirstChild());\n+            } else {\n+                result \u003d n;\n+            }\n+            break;\n+        case Token.AND:\n+        case Token.OR:\n+            Node conditionalResultNode \u003d trySimpilifyUnusedResult(n.getLastChild());\n+            if (conditionalResultNode \u003d\u003d null) {\n+                Preconditions.checkState(n.hasOneChild());\n+                result \u003d trySimpilifyUnusedResult(n.getFirstChild());\n+            }\n+            break;\n+        case Token.FUNCTION:\n+            result \u003d null;\n+            break;\n+        case Token.COMMA:\n+            Node left \u003d trySimpilifyUnusedResult(n.getFirstChild());\n+            Node right \u003d trySimpilifyUnusedResult(n.getLastChild());\n+            if (left \u003d\u003d null \u0026\u0026 right \u003d\u003d null) {\n+                result \u003d null;\n+            } else if (left \u003d\u003d null) {\n+                result \u003d right;\n+            } else if (right \u003d\u003d null) {\n+                result \u003d left;\n+            } else {\n+                result \u003d n;\n+            }\n+            break;\n+        default:\n+            if (!NodeUtil.nodeTypeMayHaveSideEffects(n)) {\n+                Node resultList \u003d null;\n+                for (Node next, c \u003d n.getFirstChild(); c !\u003d null; c \u003d next) {\n+                    next \u003d c.getNext();\n+                    c \u003d trySimpilifyUnusedResult(c);\n+                    if (c !\u003d null) {\n+                        c.detachFromParent();\n+                        if (resultList \u003d\u003d null) {\n+                            resultList \u003d c;\n+                        } else {\n+                            resultList \u003d new Node(Token.COMMA, resultList, c).copyInformationFrom(c);\n+                        }\n+                    }\n+                }\n+                result \u003d resultList;\n+            }\n+    }\n+    if (n !\u003d result) {\n+        Node parent \u003d n.getParent();\n+        if (result \u003d\u003d null) {\n+            if (removeUnused) {\n+                parent.removeChild(n);\n+            } else {\n+                result \u003d new Node(Token.EMPTY).copyInformationFrom(n);\n+                parent.replaceChild(n, result);\n+            }\n+        } else {\n+            if (result.getParent() !\u003d null) {\n+                result.detachFromParent();\n+            }\n+            n.getParent().replaceChild(n, result);\n+        }\n+        reportCodeChange();\n+    }\n+    return result;\n+}\n\\ No newline at end of file\n",
      "actualSource": "private Node trySimpilifyUnusedResult(Node n, boolean removeUnused) {\n    Node result \u003d n;\n    switch(n.getType()) {\n        case Token.HOOK:\n            Node trueNode \u003d trySimpilifyUnusedResult(n.getFirstChild().getNext());\n            Node falseNode \u003d trySimpilifyUnusedResult(n.getLastChild());\n            if (trueNode \u003d\u003d null \u0026\u0026 falseNode !\u003d null) {\n                n.setType(Token.OR);\n                Preconditions.checkState(n.getChildCount() \u003d\u003d 2);\n            } else if (trueNode !\u003d null \u0026\u0026 falseNode \u003d\u003d null) {\n                n.setType(Token.AND);\n                Preconditions.checkState(n.getChildCount() \u003d\u003d 2);\n            } else if (trueNode \u003d\u003d null \u0026\u0026 falseNode \u003d\u003d null) {\n                result \u003d trySimpilifyUnusedResult(n.getFirstChild());\n            } else {\n                result \u003d n;\n            }\n            break;\n        case Token.AND:\n        case Token.OR:\n            Node conditionalResultNode \u003d trySimpilifyUnusedResult(n.getLastChild());\n            if (conditionalResultNode \u003d\u003d null) {\n                Preconditions.checkState(n.hasOneChild());\n                result \u003d trySimpilifyUnusedResult(n.getFirstChild());\n            }\n            break;\n        case Token.FUNCTION:\n            result \u003d null;\n            break;\n        case Token.COMMA:\n            Node left \u003d trySimpilifyUnusedResult(n.getFirstChild());\n            Node right \u003d trySimpilifyUnusedResult(n.getLastChild());\n            if (left \u003d\u003d null \u0026\u0026 right \u003d\u003d null) {\n                result \u003d null;\n            } else if (left \u003d\u003d null) {\n                result \u003d right;\n            } else if (right \u003d\u003d null) {\n                result \u003d left;\n            } else {\n                result \u003d n;\n            }\n            break;\n        default:\n            if (!NodeUtil.nodeTypeMayHaveSideEffects(n)) {\n                Node resultList \u003d null;\n                for (Node next, c \u003d n.getFirstChild(); c !\u003d null; c \u003d next) {\n                    next \u003d c.getNext();\n                    c \u003d trySimpilifyUnusedResult(c);\n                    if (c !\u003d null) {\n                        c.detachFromParent();\n                        if (resultList \u003d\u003d null) {\n                            resultList \u003d c;\n                        } else {\n                            resultList \u003d new Node(Token.COMMA, resultList, c).copyInformationFrom(c);\n                        }\n                    }\n                }\n                result \u003d resultList;\n            }\n    }\n    if (n !\u003d result) {\n        Node parent \u003d n.getParent();\n        if (result \u003d\u003d null) {\n            if (removeUnused) {\n                parent.removeChild(n);\n            } else {\n                result \u003d new Node(Token.EMPTY).copyInformationFrom(n);\n                parent.replaceChild(n, result);\n            }\n        } else {\n            if (result.getParent() !\u003d null) {\n                result.detachFromParent();\n            }\n            n.getParent().replaceChild(n, result);\n        }\n        reportCodeChange();\n    }\n    return result;\n}",
      "path": "src/com/google/javascript/jscomp/PeepholeRemoveDeadCode.java",
      "functionStartLine": 106,
      "functionName": "trySimpilifyUnusedResult",
      "functionAnnotation": "",
      "functionDoc": "General cascading unused operation node removal.\n\n@param n The root of the expression to simplify.\n@param removeUnused If true, the node is removed from the AST if\n    it is not useful, otherwise it replaced with an EMPTY node.\n@return The replacement node, or null if the node was is not useful.\n"
    }
  }
}