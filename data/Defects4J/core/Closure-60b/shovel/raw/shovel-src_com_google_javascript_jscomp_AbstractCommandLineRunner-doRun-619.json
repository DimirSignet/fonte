{
  "origin": "codeshovel",
  "repositoryName": "Closure-60b",
  "repositoryPath": "/tmp/Closure-60b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "AbstractCommandLineRunner.java",
  "functionName": "doRun",
  "functionId": "doRun",
  "sourceFilePath": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
  "functionAnnotation": "",
  "functionDoc": "Parses command-line arguments and runs the compiler.\n\n@return system exit status\n",
  "functionStartLine": 619,
  "functionEndLine": 665,
  "numCommitsSeen": 68,
  "timeTaken": 3661,
  "changeHistory": [
    "1a400824eb5299485e84d40698d811c4e284511e",
    "d6ac4fe53569b1415f66db221d7511c74f4a965b",
    "4b5d62920ef4606fd30dfa42eb72df2785415533",
    "4cede4f156740b7ce93d92d824066e9a42257541",
    "61b5204064333144810c184d38b4dc78f947bd62",
    "053636cbd1a8fb97e55b4f82bc4b5bee8beaf47e",
    "82a9956c6337d2f5d4a94ebe624d64faa54d9182",
    "6a94702f5cf769973528adc8b3dc3e9cf56277c8",
    "6f2539acd3c37bd7f0d031b43364f75a5cd6d5f7",
    "c080c668a4ccd9eb151cbb4f90980ddbbfbaba44",
    "848ace840362a1f5558bec065cb40548ff66587a",
    "915752b8e4ffd312eea298fb749dddd0edc0db2e",
    "847b296c23a63aa0a0b38cc3e63883e1688288e3",
    "6a6ea480bae01f40f9795218ac911bb7de18d34a",
    "2acd6c1986e36bfdbae85c09eb83ac1940b86c73",
    "8354dcb5eb30240c82c08d060779809d9137c46f",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3"
  ],
  "changeHistoryShort": {
    "1a400824eb5299485e84d40698d811c4e284511e": "Ybodychange",
    "d6ac4fe53569b1415f66db221d7511c74f4a965b": "Ybodychange",
    "4b5d62920ef4606fd30dfa42eb72df2785415533": "Yformatchange",
    "4cede4f156740b7ce93d92d824066e9a42257541": "Ybodychange",
    "61b5204064333144810c184d38b4dc78f947bd62": "Ybodychange",
    "053636cbd1a8fb97e55b4f82bc4b5bee8beaf47e": "Ybodychange",
    "82a9956c6337d2f5d4a94ebe624d64faa54d9182": "Ybodychange",
    "6a94702f5cf769973528adc8b3dc3e9cf56277c8": "Ybodychange",
    "6f2539acd3c37bd7f0d031b43364f75a5cd6d5f7": "Ybodychange",
    "c080c668a4ccd9eb151cbb4f90980ddbbfbaba44": "Ybodychange",
    "848ace840362a1f5558bec065cb40548ff66587a": "Yfilerename",
    "915752b8e4ffd312eea298fb749dddd0edc0db2e": "Ybodychange",
    "847b296c23a63aa0a0b38cc3e63883e1688288e3": "Ybodychange",
    "6a6ea480bae01f40f9795218ac911bb7de18d34a": "Ybodychange",
    "2acd6c1986e36bfdbae85c09eb83ac1940b86c73": "Ybodychange",
    "8354dcb5eb30240c82c08d060779809d9137c46f": "Ybodychange",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "1a400824eb5299485e84d40698d811c4e284511e": {
      "type": "Ybodychange",
      "commitMessage": "\nAdd skip_normal_outputs to do dummy compilation (initialize modules and check dependency), used when we want to generate MF/bundle files but compile \u003d 0\n\nR\u003dnicksantos\nDELTA\u003d151  (144 added, 1 deleted, 6 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d2254\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1175 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "6/13/11, 11:04 AM",
      "commitName": "1a400824eb5299485e84d40698d811c4e284511e",
      "commitAuthor": "zhuyi@google.com",
      "commitDateOld": "5/18/11, 12:14 PM",
      "commitNameOld": "e4e139965fccdb7dbe55d04151fa4305bb4bac48",
      "commitAuthorOld": "rsturgell@google.com",
      "daysBetweenCommits": 25.95,
      "commitsBetweenForRepo": 60,
      "commitsBetweenForFile": 1,
      "actualSource": "protected int doRun() throws FlagUsageException, IOException {\n    Compiler.setLoggingLevel(Level.parse(config.loggingLevel));\n    List\u003cJSSourceFile\u003e externs \u003d createExterns();\n    compiler \u003d createCompiler();\n    B options \u003d createOptions();\n    List\u003cJSModule\u003e modules \u003d null;\n    Result result \u003d null;\n    setRunOptions(options);\n    boolean writeOutputToFile \u003d !options.jsOutputFile.isEmpty();\n    if (writeOutputToFile) {\n        jsOutput \u003d fileNameToOutputWriter(options.jsOutputFile);\n    } else if (jsOutput instanceof OutputStream) {\n        jsOutput \u003d streamToOutputWriter((OutputStream) jsOutput);\n    }\n    List\u003cString\u003e jsFiles \u003d config.js;\n    List\u003cString\u003e moduleSpecs \u003d config.module;\n    if (!moduleSpecs.isEmpty()) {\n        modules \u003d createJsModules(moduleSpecs, jsFiles);\n        if (config.skipNormalOutputs) {\n            compiler.initModules(externs, modules, options);\n        } else {\n            result \u003d compiler.compileModules(externs, modules, options);\n        }\n    } else {\n        List\u003cJSSourceFile\u003e inputs \u003d createSourceInputs(jsFiles);\n        if (config.skipNormalOutputs) {\n            compiler.init(externs, inputs, options);\n        } else {\n            result \u003d compiler.compile(externs, inputs, options);\n        }\n    }\n    int errCode \u003d processResults(result, modules, options);\n    if (jsOutput instanceof Flushable) {\n        ((Flushable) jsOutput).flush();\n    }\n    return errCode;\n}",
      "path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
      "functionStartLine": 618,
      "functionName": "doRun",
      "functionAnnotation": "",
      "functionDoc": "Parses command-line arguments and runs the compiler.\n\n@return system exit status\n",
      "diff": "@@ -1,29 +1,37 @@\n protected int doRun() throws FlagUsageException, IOException {\n     Compiler.setLoggingLevel(Level.parse(config.loggingLevel));\n     List\u003cJSSourceFile\u003e externs \u003d createExterns();\n     compiler \u003d createCompiler();\n     B options \u003d createOptions();\n     List\u003cJSModule\u003e modules \u003d null;\n-    Result result;\n+    Result result \u003d null;\n     setRunOptions(options);\n     boolean writeOutputToFile \u003d !options.jsOutputFile.isEmpty();\n     if (writeOutputToFile) {\n         jsOutput \u003d fileNameToOutputWriter(options.jsOutputFile);\n     } else if (jsOutput instanceof OutputStream) {\n         jsOutput \u003d streamToOutputWriter((OutputStream) jsOutput);\n     }\n     List\u003cString\u003e jsFiles \u003d config.js;\n     List\u003cString\u003e moduleSpecs \u003d config.module;\n     if (!moduleSpecs.isEmpty()) {\n         modules \u003d createJsModules(moduleSpecs, jsFiles);\n-        result \u003d compiler.compileModules(externs, modules, options);\n+        if (config.skipNormalOutputs) {\n+            compiler.initModules(externs, modules, options);\n+        } else {\n+            result \u003d compiler.compileModules(externs, modules, options);\n+        }\n     } else {\n         List\u003cJSSourceFile\u003e inputs \u003d createSourceInputs(jsFiles);\n-        result \u003d compiler.compile(externs, inputs, options);\n+        if (config.skipNormalOutputs) {\n+            compiler.init(externs, inputs, options);\n+        } else {\n+            result \u003d compiler.compile(externs, inputs, options);\n+        }\n     }\n     int errCode \u003d processResults(result, modules, options);\n     if (jsOutput instanceof Flushable) {\n         ((Flushable) jsOutput).flush();\n     }\n     return errCode;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d6ac4fe53569b1415f66db221d7511c74f4a965b": {
      "type": "Ybodychange",
      "commitMessage": "\nClean up stream-handing a bit\nRemove compute_phase_ordering flag\nFixes issue 412\n\nR\u003djohnlenz\nDELTA\u003d43  (16 added, 7 deleted, 20 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d1315\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@989 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/11/11, 10:28 AM",
      "commitName": "d6ac4fe53569b1415f66db221d7511c74f4a965b",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "4/6/11, 11:16 AM",
      "commitNameOld": "fcccf543e85a214f0948d1ac5cab3fa05363e845",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 4.97,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "actualSource": "protected int doRun() throws FlagUsageException, IOException {\n    Compiler.setLoggingLevel(Level.parse(config.loggingLevel));\n    List\u003cJSSourceFile\u003e externs \u003d createExterns();\n    compiler \u003d createCompiler();\n    B options \u003d createOptions();\n    List\u003cJSModule\u003e modules \u003d null;\n    Result result;\n    setRunOptions(options);\n    boolean writeOutputToFile \u003d !options.jsOutputFile.isEmpty();\n    if (writeOutputToFile) {\n        jsOutput \u003d fileNameToOutputWriter(options.jsOutputFile);\n    } else if (jsOutput instanceof OutputStream) {\n        jsOutput \u003d streamToOutputWriter((OutputStream) jsOutput);\n    }\n    List\u003cString\u003e jsFiles \u003d config.js;\n    List\u003cString\u003e moduleSpecs \u003d config.module;\n    if (!moduleSpecs.isEmpty()) {\n        modules \u003d createJsModules(moduleSpecs, jsFiles);\n        result \u003d compiler.compileModules(externs, modules, options);\n    } else {\n        List\u003cJSSourceFile\u003e inputs \u003d createSourceInputs(jsFiles);\n        result \u003d compiler.compile(externs, inputs, options);\n    }\n    int errCode \u003d processResults(result, modules, options);\n    if (jsOutput instanceof Flushable) {\n        ((Flushable) jsOutput).flush();\n    }\n    return errCode;\n}",
      "path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
      "functionStartLine": 603,
      "functionName": "doRun",
      "functionAnnotation": "",
      "functionDoc": "Parses command-line arguments and runs the compiler.\n\n@return system exit status\n",
      "diff": "@@ -1,29 +1,29 @@\n protected int doRun() throws FlagUsageException, IOException {\n     Compiler.setLoggingLevel(Level.parse(config.loggingLevel));\n     List\u003cJSSourceFile\u003e externs \u003d createExterns();\n     compiler \u003d createCompiler();\n     B options \u003d createOptions();\n     List\u003cJSModule\u003e modules \u003d null;\n     Result result;\n     setRunOptions(options);\n     boolean writeOutputToFile \u003d !options.jsOutputFile.isEmpty();\n     if (writeOutputToFile) {\n-        out \u003d fileNameToOutputWriter(options.jsOutputFile);\n-    } else if (out instanceof OutputStream) {\n-        out \u003d streamToOutputWriter((OutputStream) out);\n+        jsOutput \u003d fileNameToOutputWriter(options.jsOutputFile);\n+    } else if (jsOutput instanceof OutputStream) {\n+        jsOutput \u003d streamToOutputWriter((OutputStream) jsOutput);\n     }\n     List\u003cString\u003e jsFiles \u003d config.js;\n     List\u003cString\u003e moduleSpecs \u003d config.module;\n     if (!moduleSpecs.isEmpty()) {\n         modules \u003d createJsModules(moduleSpecs, jsFiles);\n         result \u003d compiler.compileModules(externs, modules, options);\n     } else {\n         List\u003cJSSourceFile\u003e inputs \u003d createSourceInputs(jsFiles);\n         result \u003d compiler.compile(externs, inputs, options);\n     }\n     int errCode \u003d processResults(result, modules, options);\n-    if (out instanceof Closeable) {\n-        ((Closeable) out).close();\n+    if (jsOutput instanceof Flushable) {\n+        ((Flushable) jsOutput).flush();\n     }\n     return errCode;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4b5d62920ef4606fd30dfa42eb72df2785415533": {
      "type": "Yformatchange",
      "commitMessage": "\ndon\u0027t print the externs files in --print_ast.\n\nR\u003dacleung\nDELTA\u003d23  (18 added, 3 deleted, 2 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d235672\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@447 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "9/20/10, 9:35 PM",
      "commitName": "4b5d62920ef4606fd30dfa42eb72df2785415533",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "8/30/10, 4:16 PM",
      "commitNameOld": "4cede4f156740b7ce93d92d824066e9a42257541",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 21.22,
      "commitsBetweenForRepo": 49,
      "commitsBetweenForFile": 1,
      "actualSource": "protected int doRun() throws FlagUsageException, IOException {\n    Compiler.setLoggingLevel(Level.parse(config.loggingLevel));\n    List\u003cJSSourceFile\u003e externs \u003d createExterns();\n    compiler \u003d createCompiler();\n    B options \u003d createOptions();\n    List\u003cJSModule\u003e modules \u003d null;\n    Result result;\n    setRunOptions(options);\n    boolean writeOutputToFile \u003d !options.jsOutputFile.isEmpty();\n    if (writeOutputToFile) {\n        out \u003d fileNameToOutputWriter(options.jsOutputFile);\n    } else if (out instanceof OutputStream) {\n        out \u003d streamToOutputWriter((OutputStream) out);\n    }\n    List\u003cString\u003e jsFiles \u003d config.js;\n    List\u003cString\u003e moduleSpecs \u003d config.module;\n    if (!moduleSpecs.isEmpty()) {\n        modules \u003d createJsModules(moduleSpecs, jsFiles);\n        result \u003d compiler.compileModules(externs, modules, options);\n    } else {\n        List\u003cJSSourceFile\u003e inputs \u003d createSourceInputs(jsFiles);\n        result \u003d compiler.compile(externs, inputs, options);\n    }\n    int errCode \u003d processResults(result, modules, options);\n    if (out instanceof Closeable) {\n        ((Closeable) out).close();\n    }\n    return errCode;\n}",
      "path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
      "functionStartLine": 553,
      "functionName": "doRun",
      "functionAnnotation": "",
      "functionDoc": "Parses command-line arguments and runs the compiler.\n\n@return system exit status\n",
      "diff": "",
      "extendedDetails": {}
    },
    "4cede4f156740b7ce93d92d824066e9a42257541": {
      "type": "Ybodychange",
      "commitMessage": "\nUnify output encoding for real this time\nFixes issue 224.\n\nRevision created by MOE tool push_codebase.\n\nR\u003djohnlenz\nDELTA\u003d39  (5 added, 5 deleted, 29 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d196345\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@394 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "8/30/10, 4:16 PM",
      "commitName": "4cede4f156740b7ce93d92d824066e9a42257541",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "8/27/10, 3:52 PM",
      "commitNameOld": "e152ec001d2c6a9bbd6e0d9443552371d11e461f",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 3.02,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "protected int doRun() throws FlagUsageException, IOException {\n    Compiler.setLoggingLevel(Level.parse(config.loggingLevel));\n    List\u003cJSSourceFile\u003e externs \u003d createExterns();\n    compiler \u003d createCompiler();\n    B options \u003d createOptions();\n    List\u003cJSModule\u003e modules \u003d null;\n    Result result;\n    setRunOptions(options);\n    boolean writeOutputToFile \u003d !options.jsOutputFile.isEmpty();\n    if (writeOutputToFile) {\n        out \u003d fileNameToOutputWriter(options.jsOutputFile);\n    } else if (out instanceof OutputStream) {\n        out \u003d streamToOutputWriter((OutputStream) out);\n    }\n    List\u003cString\u003e jsFiles \u003d config.js;\n    List\u003cString\u003e moduleSpecs \u003d config.module;\n    if (!moduleSpecs.isEmpty()) {\n        modules \u003d createJsModules(moduleSpecs, jsFiles);\n        result \u003d compiler.compileModules(externs, modules, options);\n    } else {\n        List\u003cJSSourceFile\u003e inputs \u003d createSourceInputs(jsFiles);\n        result \u003d compiler.compile(externs, inputs, options);\n    }\n    int errCode \u003d processResults(result, modules, options);\n    if (out instanceof Closeable) {\n        ((Closeable) out).close();\n    }\n    return errCode;\n}",
      "path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
      "functionStartLine": 553,
      "functionName": "doRun",
      "functionAnnotation": "",
      "functionDoc": "Parses command-line arguments and runs the compiler.\n\n@return system exit status\n",
      "diff": "@@ -1,27 +1,29 @@\n protected int doRun() throws FlagUsageException, IOException {\n     Compiler.setLoggingLevel(Level.parse(config.loggingLevel));\n     List\u003cJSSourceFile\u003e externs \u003d createExterns();\n     compiler \u003d createCompiler();\n     B options \u003d createOptions();\n     List\u003cJSModule\u003e modules \u003d null;\n     Result result;\n     setRunOptions(options);\n     boolean writeOutputToFile \u003d !options.jsOutputFile.isEmpty();\n     if (writeOutputToFile) {\n-        out \u003d toWriter(options.jsOutputFile, inputCharset.name());\n+        out \u003d fileNameToOutputWriter(options.jsOutputFile);\n+    } else if (out instanceof OutputStream) {\n+        out \u003d streamToOutputWriter((OutputStream) out);\n     }\n     List\u003cString\u003e jsFiles \u003d config.js;\n     List\u003cString\u003e moduleSpecs \u003d config.module;\n     if (!moduleSpecs.isEmpty()) {\n         modules \u003d createJsModules(moduleSpecs, jsFiles);\n         result \u003d compiler.compileModules(externs, modules, options);\n     } else {\n         List\u003cJSSourceFile\u003e inputs \u003d createSourceInputs(jsFiles);\n         result \u003d compiler.compile(externs, inputs, options);\n     }\n     int errCode \u003d processResults(result, modules, options);\n-    if (writeOutputToFile) {\n-        ((Writer) out).close();\n+    if (out instanceof Closeable) {\n+        ((Closeable) out).close();\n     }\n     return errCode;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "61b5204064333144810c184d38b4dc78f947bd62": {
      "type": "Ybodychange",
      "commitMessage": "\nCreate a much better integration test for CommandLineRunner.\n\nR\u003dacleung\nDELTA\u003d188  (118 added, 33 deleted, 37 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d181025\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@375 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "8/20/10, 4:46 PM",
      "commitName": "61b5204064333144810c184d38b4dc78f947bd62",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "8/19/10, 6:17 PM",
      "commitNameOld": "e859f6f557d0ac39f3bf45949691b2a0e150a2e4",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 0.94,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "protected int doRun() throws FlagUsageException, IOException {\n    Compiler.setLoggingLevel(Level.parse(config.loggingLevel));\n    List\u003cJSSourceFile\u003e externs \u003d createExterns();\n    compiler \u003d createCompiler();\n    B options \u003d createOptions();\n    List\u003cJSModule\u003e modules \u003d null;\n    Result result;\n    setRunOptions(options);\n    boolean writeOutputToFile \u003d !options.jsOutputFile.isEmpty();\n    if (writeOutputToFile) {\n        out \u003d toWriter(options.jsOutputFile, inputCharset.name());\n    }\n    List\u003cString\u003e jsFiles \u003d config.js;\n    List\u003cString\u003e moduleSpecs \u003d config.module;\n    if (!moduleSpecs.isEmpty()) {\n        modules \u003d createJsModules(moduleSpecs, jsFiles);\n        result \u003d compiler.compileModules(externs, modules, options);\n    } else {\n        List\u003cJSSourceFile\u003e inputs \u003d createSourceInputs(jsFiles);\n        result \u003d compiler.compile(externs, inputs, options);\n    }\n    int errCode \u003d processResults(result, modules, options);\n    if (writeOutputToFile) {\n        ((Writer) out).close();\n    }\n    return errCode;\n}",
      "path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
      "functionStartLine": 551,
      "functionName": "doRun",
      "functionAnnotation": "",
      "functionDoc": "Parses command-line arguments and runs the compiler.\n\n@return system exit status\n",
      "diff": "@@ -1,31 +1,27 @@\n protected int doRun() throws FlagUsageException, IOException {\n     Compiler.setLoggingLevel(Level.parse(config.loggingLevel));\n-    List\u003cJSSourceFile\u003e externsList \u003d createExterns();\n-    JSSourceFile[] externs \u003d new JSSourceFile[externsList.size()];\n-    externsList.toArray(externs);\n+    List\u003cJSSourceFile\u003e externs \u003d createExterns();\n     compiler \u003d createCompiler();\n     B options \u003d createOptions();\n-    JSModule[] modules \u003d null;\n+    List\u003cJSModule\u003e modules \u003d null;\n     Result result;\n     setRunOptions(options);\n     boolean writeOutputToFile \u003d !options.jsOutputFile.isEmpty();\n     if (writeOutputToFile) {\n         out \u003d toWriter(options.jsOutputFile, inputCharset.name());\n     }\n     List\u003cString\u003e jsFiles \u003d config.js;\n     List\u003cString\u003e moduleSpecs \u003d config.module;\n     if (!moduleSpecs.isEmpty()) {\n         modules \u003d createJsModules(moduleSpecs, jsFiles);\n-        result \u003d compiler.compile(externs, modules, options);\n+        result \u003d compiler.compileModules(externs, modules, options);\n     } else {\n-        List\u003cJSSourceFile\u003e inputList \u003d createSourceInputs(jsFiles);\n-        JSSourceFile[] inputs \u003d new JSSourceFile[inputList.size()];\n-        inputList.toArray(inputs);\n+        List\u003cJSSourceFile\u003e inputs \u003d createSourceInputs(jsFiles);\n         result \u003d compiler.compile(externs, inputs, options);\n     }\n     int errCode \u003d processResults(result, modules, options);\n     if (writeOutputToFile) {\n         ((Writer) out).close();\n     }\n     return errCode;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "053636cbd1a8fb97e55b4f82bc4b5bee8beaf47e": {
      "type": "Ybodychange",
      "commitMessage": "\nClean up the command-line runner api, which uncovered a bunch\nof bugs in Options serialization.\nSet the output charset to US-ASCII by default, but let the user\nset it to UTF-8.\nFixes Issue 205\n\nR\u003dbowdidge\nDELTA\u003d107  (69 added, 17 deleted, 21 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d87017\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@344 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "8/5/10, 7:38 PM",
      "commitName": "053636cbd1a8fb97e55b4f82bc4b5bee8beaf47e",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "8/5/10, 4:13 PM",
      "commitNameOld": "114620510958121ebec3dd8d037d70571fb7da20",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 0.14,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "protected int doRun() throws FlagUsageException, IOException {\n    Compiler.setLoggingLevel(Level.parse(config.loggingLevel));\n    List\u003cJSSourceFile\u003e externsList \u003d createExterns();\n    JSSourceFile[] externs \u003d new JSSourceFile[externsList.size()];\n    externsList.toArray(externs);\n    compiler \u003d createCompiler();\n    B options \u003d createOptions();\n    JSModule[] modules \u003d null;\n    Result result;\n    setRunOptions(options);\n    boolean writeOutputToFile \u003d !options.jsOutputFile.isEmpty();\n    if (writeOutputToFile) {\n        out \u003d toWriter(options.jsOutputFile, inputCharset.name());\n    }\n    List\u003cString\u003e jsFiles \u003d config.js;\n    List\u003cString\u003e moduleSpecs \u003d config.module;\n    if (!moduleSpecs.isEmpty()) {\n        modules \u003d createJsModules(moduleSpecs, jsFiles);\n        result \u003d compiler.compile(externs, modules, options);\n    } else {\n        List\u003cJSSourceFile\u003e inputList \u003d createSourceInputs(jsFiles);\n        JSSourceFile[] inputs \u003d new JSSourceFile[inputList.size()];\n        inputList.toArray(inputs);\n        result \u003d compiler.compile(externs, inputs, options);\n    }\n    int errCode \u003d processResults(result, modules, options);\n    if (writeOutputToFile) {\n        ((Writer) out).close();\n    }\n    return errCode;\n}",
      "path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
      "functionStartLine": 505,
      "functionName": "doRun",
      "functionAnnotation": "",
      "functionDoc": "Parses command-line arguments and runs the compiler.\n\n@return system exit status\n",
      "diff": "@@ -1,36 +1,31 @@\n protected int doRun() throws FlagUsageException, IOException {\n     Compiler.setLoggingLevel(Level.parse(config.loggingLevel));\n     List\u003cJSSourceFile\u003e externsList \u003d createExterns();\n     JSSourceFile[] externs \u003d new JSSourceFile[externsList.size()];\n     externsList.toArray(externs);\n     compiler \u003d createCompiler();\n     B options \u003d createOptions();\n     JSModule[] modules \u003d null;\n     Result result;\n     setRunOptions(options);\n-    if (inputCharset \u003d\u003d Charsets.UTF_8) {\n-        options.outputCharset \u003d Charsets.US_ASCII;\n-    } else {\n-        options.outputCharset \u003d inputCharset;\n-    }\n     boolean writeOutputToFile \u003d !options.jsOutputFile.isEmpty();\n     if (writeOutputToFile) {\n         out \u003d toWriter(options.jsOutputFile, inputCharset.name());\n     }\n     List\u003cString\u003e jsFiles \u003d config.js;\n     List\u003cString\u003e moduleSpecs \u003d config.module;\n     if (!moduleSpecs.isEmpty()) {\n         modules \u003d createJsModules(moduleSpecs, jsFiles);\n         result \u003d compiler.compile(externs, modules, options);\n     } else {\n         List\u003cJSSourceFile\u003e inputList \u003d createSourceInputs(jsFiles);\n         JSSourceFile[] inputs \u003d new JSSourceFile[inputList.size()];\n         inputList.toArray(inputs);\n         result \u003d compiler.compile(externs, inputs, options);\n     }\n     int errCode \u003d processResults(result, modules, options);\n     if (writeOutputToFile) {\n         ((Writer) out).close();\n     }\n     return errCode;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "82a9956c6337d2f5d4a94ebe624d64faa54d9182": {
      "type": "Ybodychange",
      "commitMessage": "\nChange on 2010/07/09 08:36:29 by nicksantos\n\n        when injecting param checks, do not inject them before any function\n        declarations, because that will break normalization constraints.\n\n        R\u003djohnlenz\n        DELTA\u003d22  (18 added, 0 deleted, 4 changed)\n\nChange on 2010/07/09 09:36:54 by johnlenz\n\n        Prefer FileWriter to PrintStream when charset translation isn\u0027t needed.\n\n        R\u003dacleung\n        DELTA\u003d68  (13 added, 2 deleted, 53 changed)\n\nChange on 2010/07/09 10:54:42 by nicksantos\n\n        our mechanism for injecting boilerplate does not work\n        for code that uses @const externs. So just don\u0027t use\n        any @const externs.\n\n        R\u003djohnlenz\n        DELTA\u003d3  (1 added, 0 deleted, 2 changed)\n\nChange on 2010/07/09 11:30:29 by nicksantos\n\n        Scan functional properties of object literals for invalid use\n        of \"this\".\n        Fixes issue 182.\n\n        R\u003dacleung\n        DELTA\u003d21  (19 added, 0 deleted, 2 changed)\n\nChange on 2010/07/09 12:40:16 by dcc\n\n        Separate pass instance for peephole preprocessing.\n        Now that I\u0027m writing instructions for how people can add their own\n        peephole passes, I want to make sure that the preprocessing\n        peephole optimizations that relies on don\u0027t get disturbed.\n\n        R\u003djohnlenz\n        DELTA\u003d18  (15 added, 0 deleted, 3 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d49008\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@270 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "7/9/10, 4:02 PM",
      "commitName": "82a9956c6337d2f5d4a94ebe624d64faa54d9182",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "7/8/10, 5:15 PM",
      "commitNameOld": "0c8a0c53b2124d05b017a63bdbc720a57c89ead2",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 0.95,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "protected int doRun() throws FlagUsageException, IOException {\n    Compiler.setLoggingLevel(Level.parse(config.loggingLevel));\n    List\u003cJSSourceFile\u003e externsList \u003d createExterns();\n    JSSourceFile[] externs \u003d new JSSourceFile[externsList.size()];\n    externsList.toArray(externs);\n    compiler \u003d createCompiler();\n    B options \u003d createOptions();\n    JSModule[] modules \u003d null;\n    Result result;\n    setRunOptions(options);\n    if (inputCharset \u003d\u003d Charsets.UTF_8) {\n        options.outputCharset \u003d Charsets.US_ASCII;\n    } else {\n        options.outputCharset \u003d inputCharset;\n    }\n    boolean writeOutputToFile \u003d !options.jsOutputFile.isEmpty();\n    if (writeOutputToFile) {\n        out \u003d toWriter(options.jsOutputFile, inputCharset.name());\n    }\n    List\u003cString\u003e jsFiles \u003d config.js;\n    List\u003cString\u003e moduleSpecs \u003d config.module;\n    if (!moduleSpecs.isEmpty()) {\n        modules \u003d createJsModules(moduleSpecs, jsFiles);\n        result \u003d compiler.compile(externs, modules, options);\n    } else {\n        List\u003cJSSourceFile\u003e inputList \u003d createSourceInputs(jsFiles);\n        JSSourceFile[] inputs \u003d new JSSourceFile[inputList.size()];\n        inputList.toArray(inputs);\n        result \u003d compiler.compile(externs, inputs, options);\n    }\n    int errCode \u003d processResults(result, modules, options);\n    if (writeOutputToFile) {\n        ((Writer) out).close();\n    }\n    return errCode;\n}",
      "path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
      "functionStartLine": 480,
      "functionName": "doRun",
      "functionAnnotation": "",
      "functionDoc": "Parses command-line arguments and runs the compiler.\n\n@return system exit status\n",
      "diff": "@@ -1,36 +1,36 @@\n protected int doRun() throws FlagUsageException, IOException {\n     Compiler.setLoggingLevel(Level.parse(config.loggingLevel));\n     List\u003cJSSourceFile\u003e externsList \u003d createExterns();\n     JSSourceFile[] externs \u003d new JSSourceFile[externsList.size()];\n     externsList.toArray(externs);\n     compiler \u003d createCompiler();\n     B options \u003d createOptions();\n     JSModule[] modules \u003d null;\n     Result result;\n     setRunOptions(options);\n     if (inputCharset \u003d\u003d Charsets.UTF_8) {\n         options.outputCharset \u003d Charsets.US_ASCII;\n     } else {\n         options.outputCharset \u003d inputCharset;\n     }\n     boolean writeOutputToFile \u003d !options.jsOutputFile.isEmpty();\n     if (writeOutputToFile) {\n-        out \u003d toPrintStream(options.jsOutputFile, inputCharset.name());\n+        out \u003d toWriter(options.jsOutputFile, inputCharset.name());\n     }\n     List\u003cString\u003e jsFiles \u003d config.js;\n     List\u003cString\u003e moduleSpecs \u003d config.module;\n     if (!moduleSpecs.isEmpty()) {\n         modules \u003d createJsModules(moduleSpecs, jsFiles);\n         result \u003d compiler.compile(externs, modules, options);\n     } else {\n         List\u003cJSSourceFile\u003e inputList \u003d createSourceInputs(jsFiles);\n         JSSourceFile[] inputs \u003d new JSSourceFile[inputList.size()];\n         inputList.toArray(inputs);\n         result \u003d compiler.compile(externs, inputs, options);\n     }\n     int errCode \u003d processResults(result, modules, options);\n     if (writeOutputToFile) {\n-        out.close();\n+        ((Writer) out).close();\n     }\n     return errCode;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6a94702f5cf769973528adc8b3dc3e9cf56277c8": {
      "type": "Ybodychange",
      "commitMessage": "\nChange on 2010/07/07 15:59:31 by johnlenz\n\n        Automated g4 rollback.\n\n        *** Reason for rollback ***\n\n          If an output file is openned, close it to be sure it is flushed.\n\n        *** Original change description ***\n\n        Automated g4 rollback.\n\n        *** Reason for rollback ***\n\n          \u003center reason for rollback\u003e\n\n        *** Original change description ***\n\n        Buffer file stream to improve file system performance.\n\n        R\u003dacleung\n        DELTA\u003d36  (26 added, 1 deleted, 9 changed)\n\nChange on 2010/07/07 16:31:41 by nicksantos\n\n        Sort and namespace the baked-in externs files, so that\n        they do not conflict with the user\u0027s file names.\n        Fixes issue 194\n\n        R\u003dacleung\n        DELTA\u003d90  (69 added, 17 deleted, 4 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d50002\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@266 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "7/8/10, 4:28 PM",
      "commitName": "6a94702f5cf769973528adc8b3dc3e9cf56277c8",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "5/27/10, 10:18 PM",
      "commitNameOld": "6d00ac1a68612aade8a19d7ecc9b180f00ae5234",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 41.76,
      "commitsBetweenForRepo": 31,
      "commitsBetweenForFile": 1,
      "actualSource": "protected int doRun() throws FlagUsageException, IOException {\n    Compiler.setLoggingLevel(Level.parse(config.loggingLevel));\n    List\u003cJSSourceFile\u003e externsList \u003d createExterns();\n    JSSourceFile[] externs \u003d new JSSourceFile[externsList.size()];\n    externsList.toArray(externs);\n    compiler \u003d createCompiler();\n    B options \u003d createOptions();\n    JSModule[] modules \u003d null;\n    Result result;\n    setRunOptions(options);\n    if (inputCharset \u003d\u003d Charsets.UTF_8) {\n        options.outputCharset \u003d Charsets.US_ASCII;\n    } else {\n        options.outputCharset \u003d inputCharset;\n    }\n    boolean writeOutputToFile \u003d !options.jsOutputFile.isEmpty();\n    if (writeOutputToFile) {\n        out \u003d toPrintStream(options.jsOutputFile, inputCharset.name());\n    }\n    List\u003cString\u003e jsFiles \u003d config.js;\n    List\u003cString\u003e moduleSpecs \u003d config.module;\n    if (!moduleSpecs.isEmpty()) {\n        modules \u003d createJsModules(moduleSpecs, jsFiles);\n        result \u003d compiler.compile(externs, modules, options);\n    } else {\n        List\u003cJSSourceFile\u003e inputList \u003d createSourceInputs(jsFiles);\n        JSSourceFile[] inputs \u003d new JSSourceFile[inputList.size()];\n        inputList.toArray(inputs);\n        result \u003d compiler.compile(externs, inputs, options);\n    }\n    int errCode \u003d processResults(result, modules, options);\n    if (writeOutputToFile) {\n        out.close();\n    }\n    return errCode;\n}",
      "path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
      "functionStartLine": 477,
      "functionName": "doRun",
      "functionAnnotation": "",
      "functionDoc": "Parses command-line arguments and runs the compiler.\n\n@return system exit status\n",
      "diff": "@@ -1,31 +1,36 @@\n protected int doRun() throws FlagUsageException, IOException {\n     Compiler.setLoggingLevel(Level.parse(config.loggingLevel));\n     List\u003cJSSourceFile\u003e externsList \u003d createExterns();\n     JSSourceFile[] externs \u003d new JSSourceFile[externsList.size()];\n     externsList.toArray(externs);\n     compiler \u003d createCompiler();\n     B options \u003d createOptions();\n     JSModule[] modules \u003d null;\n     Result result;\n     setRunOptions(options);\n     if (inputCharset \u003d\u003d Charsets.UTF_8) {\n         options.outputCharset \u003d Charsets.US_ASCII;\n     } else {\n         options.outputCharset \u003d inputCharset;\n     }\n-    if (!options.jsOutputFile.isEmpty()) {\n-        out \u003d new PrintStream(options.jsOutputFile, inputCharset.name());\n+    boolean writeOutputToFile \u003d !options.jsOutputFile.isEmpty();\n+    if (writeOutputToFile) {\n+        out \u003d toPrintStream(options.jsOutputFile, inputCharset.name());\n     }\n     List\u003cString\u003e jsFiles \u003d config.js;\n     List\u003cString\u003e moduleSpecs \u003d config.module;\n     if (!moduleSpecs.isEmpty()) {\n         modules \u003d createJsModules(moduleSpecs, jsFiles);\n         result \u003d compiler.compile(externs, modules, options);\n     } else {\n         List\u003cJSSourceFile\u003e inputList \u003d createSourceInputs(jsFiles);\n         JSSourceFile[] inputs \u003d new JSSourceFile[inputList.size()];\n         inputList.toArray(inputs);\n         result \u003d compiler.compile(externs, inputs, options);\n     }\n-    return processResults(result, modules, options);\n+    int errCode \u003d processResults(result, modules, options);\n+    if (writeOutputToFile) {\n+        out.close();\n+    }\n+    return errCode;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6f2539acd3c37bd7f0d031b43364f75a5cd6d5f7": {
      "type": "Ybodychange",
      "commitMessage": "fix some code that was initializing options from flags twice.\n(and thus re-parsing the js messages bundles)\nas it turns out, there are a lot of ways to not initialize options. (Nick)\nR\u003djohn\nDELTA\u003d99  (72 added, 24 deleted, 3 changed)\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@147 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "3/22/10, 10:41 AM",
      "commitName": "6f2539acd3c37bd7f0d031b43364f75a5cd6d5f7",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "3/11/10, 9:31 PM",
      "commitNameOld": "7bfdbd9164601af44d17edd51be829fde2cc51aa",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 10.51,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "actualSource": "protected int doRun() throws FlagUsageException, IOException {\n    Compiler.setLoggingLevel(Level.parse(config.loggingLevel));\n    List\u003cJSSourceFile\u003e externsList \u003d createExterns();\n    JSSourceFile[] externs \u003d new JSSourceFile[externsList.size()];\n    externsList.toArray(externs);\n    compiler \u003d createCompiler();\n    B options \u003d createOptions();\n    JSModule[] modules \u003d null;\n    Result result;\n    setRunOptions(options);\n    if (inputCharset \u003d\u003d Charsets.UTF_8) {\n        options.outputCharset \u003d Charsets.US_ASCII;\n    } else {\n        options.outputCharset \u003d inputCharset;\n    }\n    if (!options.jsOutputFile.isEmpty()) {\n        out \u003d new PrintStream(options.jsOutputFile, inputCharset.name());\n    }\n    List\u003cString\u003e jsFiles \u003d config.js;\n    List\u003cString\u003e moduleSpecs \u003d config.module;\n    if (!moduleSpecs.isEmpty()) {\n        modules \u003d createJsModules(moduleSpecs, jsFiles);\n        result \u003d compiler.compile(externs, modules, options);\n    } else {\n        List\u003cJSSourceFile\u003e inputList \u003d createSourceInputs(jsFiles);\n        JSSourceFile[] inputs \u003d new JSSourceFile[inputList.size()];\n        inputList.toArray(inputs);\n        result \u003d compiler.compile(externs, inputs, options);\n    }\n    return processResults(result, modules, options);\n}",
      "path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
      "functionStartLine": 476,
      "functionName": "doRun",
      "functionAnnotation": "",
      "functionDoc": "Parses command-line arguments and runs the compiler.\n\n@return system exit status\n",
      "diff": "@@ -1,32 +1,31 @@\n protected int doRun() throws FlagUsageException, IOException {\n     Compiler.setLoggingLevel(Level.parse(config.loggingLevel));\n     List\u003cJSSourceFile\u003e externsList \u003d createExterns();\n     JSSourceFile[] externs \u003d new JSSourceFile[externsList.size()];\n     externsList.toArray(externs);\n     compiler \u003d createCompiler();\n     B options \u003d createOptions();\n     JSModule[] modules \u003d null;\n     Result result;\n     setRunOptions(options);\n     if (inputCharset \u003d\u003d Charsets.UTF_8) {\n         options.outputCharset \u003d Charsets.US_ASCII;\n     } else {\n         options.outputCharset \u003d inputCharset;\n     }\n     if (!options.jsOutputFile.isEmpty()) {\n         out \u003d new PrintStream(options.jsOutputFile, inputCharset.name());\n     }\n-    ((PrintStreamErrorManager) compiler.getErrorManager()).setSummaryDetailLevel(config.summaryDetailLevel);\n     List\u003cString\u003e jsFiles \u003d config.js;\n     List\u003cString\u003e moduleSpecs \u003d config.module;\n     if (!moduleSpecs.isEmpty()) {\n         modules \u003d createJsModules(moduleSpecs, jsFiles);\n         result \u003d compiler.compile(externs, modules, options);\n     } else {\n         List\u003cJSSourceFile\u003e inputList \u003d createSourceInputs(jsFiles);\n         JSSourceFile[] inputs \u003d new JSSourceFile[inputList.size()];\n         inputList.toArray(inputs);\n         result \u003d compiler.compile(externs, inputs, options);\n     }\n     return processResults(result, modules, options);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c080c668a4ccd9eb151cbb4f90980ddbbfbaba44": {
      "type": "Ybodychange",
      "commitMessage": "rolling back the EventTarget changes for a little bit\n\ndecouple command-line options from command-line parsing. (Nick)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@127 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "3/4/10, 10:33 AM",
      "commitName": "c080c668a4ccd9eb151cbb4f90980ddbbfbaba44",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "2/26/10, 6:04 PM",
      "commitNameOld": "848ace840362a1f5558bec065cb40548ff66587a",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 5.69,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "protected int doRun() throws FlagUsageException, IOException {\n    Compiler.setLoggingLevel(Level.parse(config.loggingLevel));\n    List\u003cJSSourceFile\u003e externsList \u003d createExterns();\n    JSSourceFile[] externs \u003d new JSSourceFile[externsList.size()];\n    externsList.toArray(externs);\n    compiler \u003d createCompiler();\n    B options \u003d createOptions();\n    JSModule[] modules \u003d null;\n    Result result;\n    setRunOptions(options);\n    if (inputCharset \u003d\u003d Charsets.UTF_8) {\n        options.outputCharset \u003d Charsets.US_ASCII;\n    } else {\n        options.outputCharset \u003d inputCharset;\n    }\n    if (!options.jsOutputFile.isEmpty()) {\n        out \u003d new PrintStream(options.jsOutputFile, inputCharset.name());\n    }\n    ((PrintStreamErrorManager) compiler.getErrorManager()).setSummaryDetailLevel(config.summaryDetailLevel);\n    List\u003cString\u003e jsFiles \u003d config.js;\n    List\u003cString\u003e moduleSpecs \u003d config.module;\n    if (!moduleSpecs.isEmpty()) {\n        modules \u003d createJsModules(moduleSpecs, jsFiles);\n        result \u003d compiler.compile(externs, modules, options);\n    } else {\n        List\u003cJSSourceFile\u003e inputList \u003d createSourceInputs(jsFiles);\n        JSSourceFile[] inputs \u003d new JSSourceFile[inputList.size()];\n        inputList.toArray(inputs);\n        result \u003d compiler.compile(externs, inputs, options);\n    }\n    return processResults(result, modules, options);\n}",
      "path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
      "functionStartLine": 472,
      "functionName": "doRun",
      "functionAnnotation": "",
      "functionDoc": "Parses command-line arguments and runs the compiler.\n\n@return system exit status\n",
      "diff": "@@ -1,32 +1,32 @@\n protected int doRun() throws FlagUsageException, IOException {\n-    Compiler.setLoggingLevel(Level.parse(FLAG_logging_level.get()));\n+    Compiler.setLoggingLevel(Level.parse(config.loggingLevel));\n     List\u003cJSSourceFile\u003e externsList \u003d createExterns();\n     JSSourceFile[] externs \u003d new JSSourceFile[externsList.size()];\n     externsList.toArray(externs);\n     compiler \u003d createCompiler();\n     B options \u003d createOptions();\n     JSModule[] modules \u003d null;\n     Result result;\n     setRunOptions(options);\n     if (inputCharset \u003d\u003d Charsets.UTF_8) {\n         options.outputCharset \u003d Charsets.US_ASCII;\n     } else {\n         options.outputCharset \u003d inputCharset;\n     }\n     if (!options.jsOutputFile.isEmpty()) {\n         out \u003d new PrintStream(options.jsOutputFile, inputCharset.name());\n     }\n-    ((PrintStreamErrorManager) compiler.getErrorManager()).setSummaryDetailLevel(FLAG_summary_detail_level.get());\n-    List\u003cString\u003e jsFiles \u003d FLAG_js.get();\n-    List\u003cString\u003e moduleSpecs \u003d FLAG_module.get();\n+    ((PrintStreamErrorManager) compiler.getErrorManager()).setSummaryDetailLevel(config.summaryDetailLevel);\n+    List\u003cString\u003e jsFiles \u003d config.js;\n+    List\u003cString\u003e moduleSpecs \u003d config.module;\n     if (!moduleSpecs.isEmpty()) {\n         modules \u003d createJsModules(moduleSpecs, jsFiles);\n         result \u003d compiler.compile(externs, modules, options);\n     } else {\n         List\u003cJSSourceFile\u003e inputList \u003d createSourceInputs(jsFiles);\n         JSSourceFile[] inputs \u003d new JSSourceFile[inputList.size()];\n         inputList.toArray(inputs);\n         result \u003d compiler.compile(externs, inputs, options);\n     }\n     return processResults(result, modules, options);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "848ace840362a1f5558bec065cb40548ff66587a": {
      "type": "Yfilerename",
      "commitMessage": "Rename CompilerRunner -\u003e CommandLineRunner.\nI\u0027ll also do this for JSCompilerRunner, but it will be a much\nbigger change. (Nick)\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@119 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "2/26/10, 6:04 PM",
      "commitName": "848ace840362a1f5558bec065cb40548ff66587a",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "2/26/10, 3:45 PM",
      "commitNameOld": "50c1b3d39ff5b17c956a2235f97f7b5da05ab6f0",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "protected int doRun() throws FlagUsageException, IOException {\n    Compiler.setLoggingLevel(Level.parse(FLAG_logging_level.get()));\n    List\u003cJSSourceFile\u003e externsList \u003d createExterns();\n    JSSourceFile[] externs \u003d new JSSourceFile[externsList.size()];\n    externsList.toArray(externs);\n    compiler \u003d createCompiler();\n    B options \u003d createOptions();\n    JSModule[] modules \u003d null;\n    Result result;\n    setRunOptions(options);\n    if (inputCharset \u003d\u003d Charsets.UTF_8) {\n        options.outputCharset \u003d Charsets.US_ASCII;\n    } else {\n        options.outputCharset \u003d inputCharset;\n    }\n    if (!options.jsOutputFile.isEmpty()) {\n        out \u003d new PrintStream(options.jsOutputFile, inputCharset.name());\n    }\n    ((PrintStreamErrorManager) compiler.getErrorManager()).setSummaryDetailLevel(FLAG_summary_detail_level.get());\n    List\u003cString\u003e jsFiles \u003d FLAG_js.get();\n    List\u003cString\u003e moduleSpecs \u003d FLAG_module.get();\n    if (!moduleSpecs.isEmpty()) {\n        modules \u003d createJsModules(moduleSpecs, jsFiles);\n        result \u003d compiler.compile(externs, modules, options);\n    } else {\n        List\u003cJSSourceFile\u003e inputList \u003d createSourceInputs(jsFiles);\n        JSSourceFile[] inputs \u003d new JSSourceFile[inputList.size()];\n        inputList.toArray(inputs);\n        result \u003d compiler.compile(externs, inputs, options);\n    }\n    return processResults(result, modules, options);\n}",
      "path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
      "functionStartLine": 625,
      "functionName": "doRun",
      "functionAnnotation": "",
      "functionDoc": "Parses command-line arguments and runs the compiler.\n\n@return system exit status\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/com/google/javascript/jscomp/AbstractCompilerRunner.java",
        "newPath": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java"
      }
    },
    "915752b8e4ffd312eea298fb749dddd0edc0db2e": {
      "type": "Ybodychange",
      "commitMessage": "Add boatloads of tests.\n\nAdd support for --jscomp_warning\u003dcheckTypes\n\nAdd phase optimization improvements.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@49 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "12/23/09, 9:33 AM",
      "commitName": "915752b8e4ffd312eea298fb749dddd0edc0db2e",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "commitDateOld": "12/17/09, 5:17 PM",
      "commitNameOld": "4191b88449010266e7e3f9b7f27f5a1cfbfa7ce7",
      "commitAuthorOld": "nicholas.j.santos@gmail.com",
      "daysBetweenCommits": 5.68,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "protected int doRun() throws FlagUsageException, IOException {\n    Compiler.setLoggingLevel(Level.parse(FLAG_logging_level.get()));\n    List\u003cJSSourceFile\u003e externsList \u003d createExterns();\n    JSSourceFile[] externs \u003d new JSSourceFile[externsList.size()];\n    externsList.toArray(externs);\n    compiler \u003d createCompiler();\n    B options \u003d createOptions();\n    JSModule[] modules \u003d null;\n    Result result;\n    setRunOptions(options);\n    if (inputCharset \u003d\u003d Charsets.UTF_8) {\n        options.outputCharset \u003d Charsets.US_ASCII;\n    } else {\n        options.outputCharset \u003d inputCharset;\n    }\n    if (!options.jsOutputFile.isEmpty()) {\n        out \u003d new PrintStream(options.jsOutputFile, inputCharset.name());\n    }\n    ((PrintStreamErrorManager) compiler.getErrorManager()).setSummaryDetailLevel(FLAG_summary_detail_level.get());\n    List\u003cString\u003e jsFiles \u003d FLAG_js.get();\n    List\u003cString\u003e moduleSpecs \u003d FLAG_module.get();\n    if (!moduleSpecs.isEmpty()) {\n        modules \u003d createJsModules(moduleSpecs, jsFiles);\n        result \u003d compiler.compile(externs, modules, options);\n    } else {\n        List\u003cJSSourceFile\u003e inputList \u003d createSourceInputs(jsFiles);\n        JSSourceFile[] inputs \u003d new JSSourceFile[inputList.size()];\n        inputList.toArray(inputs);\n        result \u003d compiler.compile(externs, inputs, options);\n    }\n    return processResults(result, modules, options);\n}",
      "path": "src/com/google/javascript/jscomp/AbstractCompilerRunner.java",
      "functionStartLine": 616,
      "functionName": "doRun",
      "functionAnnotation": "",
      "functionDoc": "Parses command-line arguments and runs the compiler.\n\n@return system exit status\n",
      "diff": "@@ -1,93 +1,32 @@\n protected int doRun() throws FlagUsageException, IOException {\n     Compiler.setLoggingLevel(Level.parse(FLAG_logging_level.get()));\n     List\u003cJSSourceFile\u003e externsList \u003d createExterns();\n     JSSourceFile[] externs \u003d new JSSourceFile[externsList.size()];\n     externsList.toArray(externs);\n     compiler \u003d createCompiler();\n     B options \u003d createOptions();\n     JSModule[] modules \u003d null;\n     Result result;\n     setRunOptions(options);\n     if (inputCharset \u003d\u003d Charsets.UTF_8) {\n         options.outputCharset \u003d Charsets.US_ASCII;\n     } else {\n         options.outputCharset \u003d inputCharset;\n     }\n     if (!options.jsOutputFile.isEmpty()) {\n         out \u003d new PrintStream(options.jsOutputFile, inputCharset.name());\n     }\n     ((PrintStreamErrorManager) compiler.getErrorManager()).setSummaryDetailLevel(FLAG_summary_detail_level.get());\n     List\u003cString\u003e jsFiles \u003d FLAG_js.get();\n     List\u003cString\u003e moduleSpecs \u003d FLAG_module.get();\n     if (!moduleSpecs.isEmpty()) {\n         modules \u003d createJsModules(moduleSpecs, jsFiles);\n         result \u003d compiler.compile(externs, modules, options);\n     } else {\n         List\u003cJSSourceFile\u003e inputList \u003d createSourceInputs(jsFiles);\n         JSSourceFile[] inputs \u003d new JSSourceFile[inputList.size()];\n         inputList.toArray(inputs);\n         result \u003d compiler.compile(externs, inputs, options);\n     }\n-    if (FLAG_print_ast.get()) {\n-        if (compiler.getRoot() \u003d\u003d null) {\n-            return 1;\n-        } else {\n-            ControlFlowGraph\u003cNode\u003e cfg \u003d compiler.computeCFG();\n-            DotFormatter.appendDot(compiler.getRoot(), cfg, out);\n-            out.println();\n-            return 0;\n-        }\n-    }\n-    if (FLAG_print_tree.get()) {\n-        if (compiler.getRoot() \u003d\u003d null) {\n-            out.println(\"Code contains errors; no tree was generated.\");\n-            return 1;\n-        } else {\n-            compiler.getRoot().appendStringTree(out);\n-            out.println(\"\");\n-            return 0;\n-        }\n-    }\n-    if (result.success) {\n-        if (modules \u003d\u003d null) {\n-            writeOutput(out, compiler, compiler.toSource(), FLAG_output_wrapper.get(), FLAG_output_wrapper_marker.get());\n-            outputSourceMap(options, options.jsOutputFile);\n-        } else {\n-            String moduleFilePrefix \u003d FLAG_module_output_path_prefix.get();\n-            maybeCreateDirsForPath(moduleFilePrefix);\n-            Map\u003cString, String\u003e moduleWrappers \u003d parseModuleWrappers(FLAG_module_wrapper.get(), modules);\n-            PrintStream mapOut \u003d null;\n-            if (!shouldGenerateMapPerModule(options)) {\n-                mapOut \u003d openSourceMapStream(options, moduleFilePrefix, null);\n-            }\n-            for (JSModule m : modules) {\n-                if (shouldGenerateMapPerModule(options)) {\n-                    mapOut \u003d openSourceMapStream(options, moduleFilePrefix, m.getName());\n-                }\n-                PrintStream ps \u003d new PrintStream(new FileOutputStream(moduleFilePrefix + m.getName() + \".js\"));\n-                if (options.sourceMapOutputPath !\u003d null) {\n-                    compiler.getSourceMap().reset();\n-                }\n-                writeOutput(ps, compiler, compiler.toSource(m), moduleWrappers.get(m.getName()), \"%s\");\n-                if (options.sourceMapOutputPath !\u003d null) {\n-                    compiler.getSourceMap().appendTo(mapOut, m.getName());\n-                }\n-                ps.close();\n-                if (shouldGenerateMapPerModule(options) \u0026\u0026 mapOut !\u003d null) {\n-                    mapOut.close();\n-                    mapOut \u003d null;\n-                }\n-            }\n-            if (mapOut !\u003d null) {\n-                mapOut.close();\n-            }\n-        }\n-        if (options.externExportsPath !\u003d null) {\n-            PrintStream eeOut \u003d openExternExportsStream(options, options.jsOutputFile);\n-            eeOut.append(result.externExport);\n-            eeOut.close();\n-        }\n-        outputNameMaps(options);\n-    }\n-    return Math.min(result.errors.length, 0x7f);\n+    return processResults(result, modules, options);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "847b296c23a63aa0a0b38cc3e63883e1688288e3": {
      "type": "Ybodychange",
      "commitMessage": "Add support for other charset types.\n\nAdd support for ES5 directives.\n\nFork unit tests, so that they run more hermetically.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@21 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "12/8/09, 3:50 PM",
      "commitName": "847b296c23a63aa0a0b38cc3e63883e1688288e3",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "commitDateOld": "12/7/09, 1:53 PM",
      "commitNameOld": "845f5ff65858fd0d1829f3d2f16f758725e8028f",
      "commitAuthorOld": "nicholas.j.santos@gmail.com",
      "daysBetweenCommits": 1.08,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "protected int doRun() throws FlagUsageException, IOException {\n    Compiler.setLoggingLevel(Level.parse(FLAG_logging_level.get()));\n    List\u003cJSSourceFile\u003e externsList \u003d createExterns();\n    JSSourceFile[] externs \u003d new JSSourceFile[externsList.size()];\n    externsList.toArray(externs);\n    compiler \u003d createCompiler();\n    B options \u003d createOptions();\n    JSModule[] modules \u003d null;\n    Result result;\n    setRunOptions(options);\n    if (inputCharset \u003d\u003d Charsets.UTF_8) {\n        options.outputCharset \u003d Charsets.US_ASCII;\n    } else {\n        options.outputCharset \u003d inputCharset;\n    }\n    if (!options.jsOutputFile.isEmpty()) {\n        out \u003d new PrintStream(options.jsOutputFile, inputCharset.name());\n    }\n    ((PrintStreamErrorManager) compiler.getErrorManager()).setSummaryDetailLevel(FLAG_summary_detail_level.get());\n    List\u003cString\u003e jsFiles \u003d FLAG_js.get();\n    List\u003cString\u003e moduleSpecs \u003d FLAG_module.get();\n    if (!moduleSpecs.isEmpty()) {\n        modules \u003d createJsModules(moduleSpecs, jsFiles);\n        result \u003d compiler.compile(externs, modules, options);\n    } else {\n        List\u003cJSSourceFile\u003e inputList \u003d createSourceInputs(jsFiles);\n        JSSourceFile[] inputs \u003d new JSSourceFile[inputList.size()];\n        inputList.toArray(inputs);\n        result \u003d compiler.compile(externs, inputs, options);\n    }\n    if (FLAG_print_ast.get()) {\n        if (compiler.getRoot() \u003d\u003d null) {\n            return 1;\n        } else {\n            ControlFlowGraph\u003cNode\u003e cfg \u003d compiler.computeCFG();\n            DotFormatter.appendDot(compiler.getRoot(), cfg, out);\n            out.println();\n            return 0;\n        }\n    }\n    if (FLAG_print_tree.get()) {\n        if (compiler.getRoot() \u003d\u003d null) {\n            out.println(\"Code contains errors; no tree was generated.\");\n            return 1;\n        } else {\n            compiler.getRoot().appendStringTree(out);\n            out.println(\"\");\n            return 0;\n        }\n    }\n    if (result.success) {\n        if (modules \u003d\u003d null) {\n            writeOutput(out, compiler, compiler.toSource(), FLAG_output_wrapper.get(), FLAG_output_wrapper_marker.get());\n            outputSourceMap(options, options.jsOutputFile);\n        } else {\n            String moduleFilePrefix \u003d FLAG_module_output_path_prefix.get();\n            maybeCreateDirsForPath(moduleFilePrefix);\n            Map\u003cString, String\u003e moduleWrappers \u003d parseModuleWrappers(FLAG_module_wrapper.get(), modules);\n            PrintStream mapOut \u003d null;\n            if (!shouldGenerateMapPerModule(options)) {\n                mapOut \u003d openSourceMapStream(options, moduleFilePrefix, null);\n            }\n            for (JSModule m : modules) {\n                if (shouldGenerateMapPerModule(options)) {\n                    mapOut \u003d openSourceMapStream(options, moduleFilePrefix, m.getName());\n                }\n                PrintStream ps \u003d new PrintStream(new FileOutputStream(moduleFilePrefix + m.getName() + \".js\"));\n                if (options.sourceMapOutputPath !\u003d null) {\n                    compiler.getSourceMap().reset();\n                }\n                writeOutput(ps, compiler, compiler.toSource(m), moduleWrappers.get(m.getName()), \"%s\");\n                if (options.sourceMapOutputPath !\u003d null) {\n                    compiler.getSourceMap().appendTo(mapOut, m.getName());\n                }\n                ps.close();\n                if (shouldGenerateMapPerModule(options) \u0026\u0026 mapOut !\u003d null) {\n                    mapOut.close();\n                    mapOut \u003d null;\n                }\n            }\n            if (mapOut !\u003d null) {\n                mapOut.close();\n            }\n        }\n        if (options.externExportsPath !\u003d null) {\n            PrintStream eeOut \u003d openExternExportsStream(options, options.jsOutputFile);\n            eeOut.append(result.externExport);\n            eeOut.close();\n        }\n        outputNameMaps(options);\n    }\n    return Math.min(result.errors.length, 0x7f);\n}",
      "path": "src/com/google/javascript/jscomp/AbstractCompilerRunner.java",
      "functionStartLine": 590,
      "functionName": "doRun",
      "functionAnnotation": "",
      "functionDoc": "Parses command-line arguments and runs the compiler.\n\n@return system exit status\n",
      "diff": "@@ -1,88 +1,93 @@\n protected int doRun() throws FlagUsageException, IOException {\n     Compiler.setLoggingLevel(Level.parse(FLAG_logging_level.get()));\n     List\u003cJSSourceFile\u003e externsList \u003d createExterns();\n     JSSourceFile[] externs \u003d new JSSourceFile[externsList.size()];\n     externsList.toArray(externs);\n     compiler \u003d createCompiler();\n     B options \u003d createOptions();\n     JSModule[] modules \u003d null;\n     Result result;\n     setRunOptions(options);\n-    if (!options.jsOutputFile.equals(\"\")) {\n-        out \u003d new PrintStream(options.jsOutputFile);\n+    if (inputCharset \u003d\u003d Charsets.UTF_8) {\n+        options.outputCharset \u003d Charsets.US_ASCII;\n+    } else {\n+        options.outputCharset \u003d inputCharset;\n+    }\n+    if (!options.jsOutputFile.isEmpty()) {\n+        out \u003d new PrintStream(options.jsOutputFile, inputCharset.name());\n     }\n     ((PrintStreamErrorManager) compiler.getErrorManager()).setSummaryDetailLevel(FLAG_summary_detail_level.get());\n     List\u003cString\u003e jsFiles \u003d FLAG_js.get();\n     List\u003cString\u003e moduleSpecs \u003d FLAG_module.get();\n     if (!moduleSpecs.isEmpty()) {\n         modules \u003d createJsModules(moduleSpecs, jsFiles);\n         result \u003d compiler.compile(externs, modules, options);\n     } else {\n         List\u003cJSSourceFile\u003e inputList \u003d createSourceInputs(jsFiles);\n         JSSourceFile[] inputs \u003d new JSSourceFile[inputList.size()];\n         inputList.toArray(inputs);\n         result \u003d compiler.compile(externs, inputs, options);\n     }\n     if (FLAG_print_ast.get()) {\n         if (compiler.getRoot() \u003d\u003d null) {\n             return 1;\n         } else {\n             ControlFlowGraph\u003cNode\u003e cfg \u003d compiler.computeCFG();\n             DotFormatter.appendDot(compiler.getRoot(), cfg, out);\n             out.println();\n             return 0;\n         }\n     }\n     if (FLAG_print_tree.get()) {\n         if (compiler.getRoot() \u003d\u003d null) {\n             out.println(\"Code contains errors; no tree was generated.\");\n             return 1;\n         } else {\n             compiler.getRoot().appendStringTree(out);\n             out.println(\"\");\n             return 0;\n         }\n     }\n     if (result.success) {\n         if (modules \u003d\u003d null) {\n             writeOutput(out, compiler, compiler.toSource(), FLAG_output_wrapper.get(), FLAG_output_wrapper_marker.get());\n             outputSourceMap(options, options.jsOutputFile);\n         } else {\n             String moduleFilePrefix \u003d FLAG_module_output_path_prefix.get();\n             maybeCreateDirsForPath(moduleFilePrefix);\n             Map\u003cString, String\u003e moduleWrappers \u003d parseModuleWrappers(FLAG_module_wrapper.get(), modules);\n             PrintStream mapOut \u003d null;\n             if (!shouldGenerateMapPerModule(options)) {\n                 mapOut \u003d openSourceMapStream(options, moduleFilePrefix, null);\n             }\n             for (JSModule m : modules) {\n                 if (shouldGenerateMapPerModule(options)) {\n                     mapOut \u003d openSourceMapStream(options, moduleFilePrefix, m.getName());\n                 }\n                 PrintStream ps \u003d new PrintStream(new FileOutputStream(moduleFilePrefix + m.getName() + \".js\"));\n                 if (options.sourceMapOutputPath !\u003d null) {\n                     compiler.getSourceMap().reset();\n                 }\n                 writeOutput(ps, compiler, compiler.toSource(m), moduleWrappers.get(m.getName()), \"%s\");\n                 if (options.sourceMapOutputPath !\u003d null) {\n                     compiler.getSourceMap().appendTo(mapOut, m.getName());\n                 }\n                 ps.close();\n                 if (shouldGenerateMapPerModule(options) \u0026\u0026 mapOut !\u003d null) {\n                     mapOut.close();\n                     mapOut \u003d null;\n                 }\n             }\n             if (mapOut !\u003d null) {\n                 mapOut.close();\n             }\n         }\n         if (options.externExportsPath !\u003d null) {\n             PrintStream eeOut \u003d openExternExportsStream(options, options.jsOutputFile);\n             eeOut.append(result.externExport);\n             eeOut.close();\n         }\n         outputNameMaps(options);\n     }\n     return Math.min(result.errors.length, 0x7f);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6a6ea480bae01f40f9795218ac911bb7de18d34a": {
      "type": "Ybodychange",
      "commitMessage": "Don\u0027t warn about duplicate variable declarations unless warning_level is\nset to VERBOSE.\n\nImplementation of libary function goog.base.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@13 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/19/09, 1:23 PM",
      "commitName": "6a6ea480bae01f40f9795218ac911bb7de18d34a",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "commitDateOld": "11/16/09, 4:04 PM",
      "commitNameOld": "2acd6c1986e36bfdbae85c09eb83ac1940b86c73",
      "commitAuthorOld": "nicholas.j.santos@gmail.com",
      "daysBetweenCommits": 2.89,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "protected int doRun() throws FlagUsageException, IOException {\n    Compiler.setLoggingLevel(Level.parse(FLAG_logging_level.get()));\n    List\u003cJSSourceFile\u003e externsList \u003d createExterns();\n    JSSourceFile[] externs \u003d new JSSourceFile[externsList.size()];\n    externsList.toArray(externs);\n    compiler \u003d createCompiler();\n    B options \u003d createOptions();\n    JSModule[] modules \u003d null;\n    Result result;\n    setRunOptions(options);\n    if (!options.jsOutputFile.equals(\"\")) {\n        out \u003d new PrintStream(options.jsOutputFile);\n    }\n    ((PrintStreamErrorManager) compiler.getErrorManager()).setSummaryDetailLevel(FLAG_summary_detail_level.get());\n    List\u003cString\u003e jsFiles \u003d FLAG_js.get();\n    List\u003cString\u003e moduleSpecs \u003d FLAG_module.get();\n    if (!moduleSpecs.isEmpty()) {\n        modules \u003d createJsModules(moduleSpecs, jsFiles);\n        result \u003d compiler.compile(externs, modules, options);\n    } else {\n        List\u003cJSSourceFile\u003e inputList \u003d createSourceInputs(jsFiles);\n        JSSourceFile[] inputs \u003d new JSSourceFile[inputList.size()];\n        inputList.toArray(inputs);\n        result \u003d compiler.compile(externs, inputs, options);\n    }\n    if (FLAG_print_ast.get()) {\n        if (compiler.getRoot() \u003d\u003d null) {\n            return 1;\n        } else {\n            ControlFlowGraph\u003cNode\u003e cfg \u003d compiler.computeCFG();\n            DotFormatter.appendDot(compiler.getRoot(), cfg, out);\n            out.println();\n            return 0;\n        }\n    }\n    if (FLAG_print_tree.get()) {\n        if (compiler.getRoot() \u003d\u003d null) {\n            out.println(\"Code contains errors; no tree was generated.\");\n            return 1;\n        } else {\n            compiler.getRoot().appendStringTree(out);\n            out.println(\"\");\n            return 0;\n        }\n    }\n    if (result.success) {\n        if (modules \u003d\u003d null) {\n            writeOutput(out, compiler, compiler.toSource(), FLAG_output_wrapper.get(), FLAG_output_wrapper_marker.get());\n            outputSourceMap(options, options.jsOutputFile);\n        } else {\n            String moduleFilePrefix \u003d FLAG_module_output_path_prefix.get();\n            maybeCreateDirsForPath(moduleFilePrefix);\n            Map\u003cString, String\u003e moduleWrappers \u003d parseModuleWrappers(FLAG_module_wrapper.get(), modules);\n            PrintStream mapOut \u003d null;\n            if (!shouldGenerateMapPerModule(options)) {\n                mapOut \u003d openSourceMapStream(options, moduleFilePrefix, null);\n            }\n            for (JSModule m : modules) {\n                if (shouldGenerateMapPerModule(options)) {\n                    mapOut \u003d openSourceMapStream(options, moduleFilePrefix, m.getName());\n                }\n                PrintStream ps \u003d new PrintStream(new FileOutputStream(moduleFilePrefix + m.getName() + \".js\"));\n                if (options.sourceMapOutputPath !\u003d null) {\n                    compiler.getSourceMap().reset();\n                }\n                writeOutput(ps, compiler, compiler.toSource(m), moduleWrappers.get(m.getName()), \"%s\");\n                if (options.sourceMapOutputPath !\u003d null) {\n                    compiler.getSourceMap().appendTo(mapOut, m.getName());\n                }\n                ps.close();\n                if (shouldGenerateMapPerModule(options) \u0026\u0026 mapOut !\u003d null) {\n                    mapOut.close();\n                    mapOut \u003d null;\n                }\n            }\n            if (mapOut !\u003d null) {\n                mapOut.close();\n            }\n        }\n        if (options.externExportsPath !\u003d null) {\n            PrintStream eeOut \u003d openExternExportsStream(options, options.jsOutputFile);\n            eeOut.append(result.externExport);\n            eeOut.close();\n        }\n        outputNameMaps(options);\n    }\n    return Math.min(result.errors.length, 0x7f);\n}",
      "path": "src/com/google/javascript/jscomp/AbstractCompilerRunner.java",
      "functionStartLine": 550,
      "functionName": "doRun",
      "functionAnnotation": "",
      "functionDoc": "Parses command-line arguments and runs the compiler.\n\n@return system exit status\n",
      "diff": "@@ -1,102 +1,88 @@\n protected int doRun() throws FlagUsageException, IOException {\n     Compiler.setLoggingLevel(Level.parse(FLAG_logging_level.get()));\n     List\u003cJSSourceFile\u003e externsList \u003d createExterns();\n     JSSourceFile[] externs \u003d new JSSourceFile[externsList.size()];\n     externsList.toArray(externs);\n     compiler \u003d createCompiler();\n     B options \u003d createOptions();\n     JSModule[] modules \u003d null;\n     Result result;\n-    if (FLAG_js_output_file.get().length() \u003e 0) {\n-        options.jsOutputFile \u003d FLAG_js_output_file.get();\n-    }\n-    if (FLAG_create_source_map.get().length() \u003e 0) {\n-        options.sourceMapOutputPath \u003d FLAG_create_source_map.get();\n-    }\n-    if (!FLAG_variable_map_input_file.get().equals(\"\")) {\n-        options.inputVariableMapSerialized \u003d VariableMap.load(FLAG_variable_map_input_file.get()).toBytes();\n-    }\n-    if (!FLAG_property_map_input_file.get().equals(\"\")) {\n-        options.inputPropertyMapSerialized \u003d VariableMap.load(FLAG_property_map_input_file.get()).toBytes();\n-    }\n+    setRunOptions(options);\n     if (!options.jsOutputFile.equals(\"\")) {\n         out \u003d new PrintStream(options.jsOutputFile);\n     }\n-    if (FLAG_third_party.get()) {\n-        compiler.setCodingConvention(new DefaultCodingConvention());\n-    }\n     ((PrintStreamErrorManager) compiler.getErrorManager()).setSummaryDetailLevel(FLAG_summary_detail_level.get());\n     List\u003cString\u003e jsFiles \u003d FLAG_js.get();\n     List\u003cString\u003e moduleSpecs \u003d FLAG_module.get();\n     if (!moduleSpecs.isEmpty()) {\n         modules \u003d createJsModules(moduleSpecs, jsFiles);\n         result \u003d compiler.compile(externs, modules, options);\n     } else {\n         List\u003cJSSourceFile\u003e inputList \u003d createSourceInputs(jsFiles);\n         JSSourceFile[] inputs \u003d new JSSourceFile[inputList.size()];\n         inputList.toArray(inputs);\n         result \u003d compiler.compile(externs, inputs, options);\n     }\n     if (FLAG_print_ast.get()) {\n         if (compiler.getRoot() \u003d\u003d null) {\n             return 1;\n         } else {\n             ControlFlowGraph\u003cNode\u003e cfg \u003d compiler.computeCFG();\n             DotFormatter.appendDot(compiler.getRoot(), cfg, out);\n             out.println();\n             return 0;\n         }\n     }\n     if (FLAG_print_tree.get()) {\n         if (compiler.getRoot() \u003d\u003d null) {\n             out.println(\"Code contains errors; no tree was generated.\");\n             return 1;\n         } else {\n             compiler.getRoot().appendStringTree(out);\n             out.println(\"\");\n             return 0;\n         }\n     }\n     if (result.success) {\n         if (modules \u003d\u003d null) {\n             writeOutput(out, compiler, compiler.toSource(), FLAG_output_wrapper.get(), FLAG_output_wrapper_marker.get());\n             outputSourceMap(options, options.jsOutputFile);\n         } else {\n             String moduleFilePrefix \u003d FLAG_module_output_path_prefix.get();\n             maybeCreateDirsForPath(moduleFilePrefix);\n             Map\u003cString, String\u003e moduleWrappers \u003d parseModuleWrappers(FLAG_module_wrapper.get(), modules);\n             PrintStream mapOut \u003d null;\n             if (!shouldGenerateMapPerModule(options)) {\n                 mapOut \u003d openSourceMapStream(options, moduleFilePrefix, null);\n             }\n             for (JSModule m : modules) {\n                 if (shouldGenerateMapPerModule(options)) {\n                     mapOut \u003d openSourceMapStream(options, moduleFilePrefix, m.getName());\n                 }\n                 PrintStream ps \u003d new PrintStream(new FileOutputStream(moduleFilePrefix + m.getName() + \".js\"));\n                 if (options.sourceMapOutputPath !\u003d null) {\n                     compiler.getSourceMap().reset();\n                 }\n                 writeOutput(ps, compiler, compiler.toSource(m), moduleWrappers.get(m.getName()), \"%s\");\n                 if (options.sourceMapOutputPath !\u003d null) {\n                     compiler.getSourceMap().appendTo(mapOut, m.getName());\n                 }\n                 ps.close();\n                 if (shouldGenerateMapPerModule(options) \u0026\u0026 mapOut !\u003d null) {\n                     mapOut.close();\n                     mapOut \u003d null;\n                 }\n             }\n             if (mapOut !\u003d null) {\n                 mapOut.close();\n             }\n         }\n         if (options.externExportsPath !\u003d null) {\n             PrintStream eeOut \u003d openExternExportsStream(options, options.jsOutputFile);\n             eeOut.append(result.externExport);\n             eeOut.close();\n         }\n         outputNameMaps(options);\n     }\n     return Math.min(result.errors.length, 0x7f);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2acd6c1986e36bfdbae85c09eb83ac1940b86c73": {
      "type": "Ybodychange",
      "commitMessage": "Fix if-folding compiler crash (issue 43)\nFix property-collapsing compiler crash (issue 34)\nFix labeled VAR compiler crash (issue 41)\nMake [paramName] syntax denote optionality (issue #26)\nBetter function inlining.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@11 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/16/09, 4:04 PM",
      "commitName": "2acd6c1986e36bfdbae85c09eb83ac1940b86c73",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "commitDateOld": "11/13/09, 11:38 AM",
      "commitNameOld": "efd3c178e471df6a689c1a50fbd7c404e778bfaa",
      "commitAuthorOld": "nicholas.j.santos@gmail.com",
      "daysBetweenCommits": 3.18,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "protected int doRun() throws FlagUsageException, IOException {\n    Compiler.setLoggingLevel(Level.parse(FLAG_logging_level.get()));\n    List\u003cJSSourceFile\u003e externsList \u003d createExterns();\n    JSSourceFile[] externs \u003d new JSSourceFile[externsList.size()];\n    externsList.toArray(externs);\n    compiler \u003d createCompiler();\n    B options \u003d createOptions();\n    JSModule[] modules \u003d null;\n    Result result;\n    if (FLAG_js_output_file.get().length() \u003e 0) {\n        options.jsOutputFile \u003d FLAG_js_output_file.get();\n    }\n    if (FLAG_create_source_map.get().length() \u003e 0) {\n        options.sourceMapOutputPath \u003d FLAG_create_source_map.get();\n    }\n    if (!FLAG_variable_map_input_file.get().equals(\"\")) {\n        options.inputVariableMapSerialized \u003d VariableMap.load(FLAG_variable_map_input_file.get()).toBytes();\n    }\n    if (!FLAG_property_map_input_file.get().equals(\"\")) {\n        options.inputPropertyMapSerialized \u003d VariableMap.load(FLAG_property_map_input_file.get()).toBytes();\n    }\n    if (!options.jsOutputFile.equals(\"\")) {\n        out \u003d new PrintStream(options.jsOutputFile);\n    }\n    if (FLAG_third_party.get()) {\n        compiler.setCodingConvention(new DefaultCodingConvention());\n    }\n    ((PrintStreamErrorManager) compiler.getErrorManager()).setSummaryDetailLevel(FLAG_summary_detail_level.get());\n    List\u003cString\u003e jsFiles \u003d FLAG_js.get();\n    List\u003cString\u003e moduleSpecs \u003d FLAG_module.get();\n    if (!moduleSpecs.isEmpty()) {\n        modules \u003d createJsModules(moduleSpecs, jsFiles);\n        result \u003d compiler.compile(externs, modules, options);\n    } else {\n        List\u003cJSSourceFile\u003e inputList \u003d createSourceInputs(jsFiles);\n        JSSourceFile[] inputs \u003d new JSSourceFile[inputList.size()];\n        inputList.toArray(inputs);\n        result \u003d compiler.compile(externs, inputs, options);\n    }\n    if (FLAG_print_ast.get()) {\n        if (compiler.getRoot() \u003d\u003d null) {\n            return 1;\n        } else {\n            ControlFlowGraph\u003cNode\u003e cfg \u003d compiler.computeCFG();\n            DotFormatter.appendDot(compiler.getRoot(), cfg, out);\n            out.println();\n            return 0;\n        }\n    }\n    if (FLAG_print_tree.get()) {\n        if (compiler.getRoot() \u003d\u003d null) {\n            out.println(\"Code contains errors; no tree was generated.\");\n            return 1;\n        } else {\n            compiler.getRoot().appendStringTree(out);\n            out.println(\"\");\n            return 0;\n        }\n    }\n    if (result.success) {\n        if (modules \u003d\u003d null) {\n            writeOutput(out, compiler, compiler.toSource(), FLAG_output_wrapper.get(), FLAG_output_wrapper_marker.get());\n            outputSourceMap(options, options.jsOutputFile);\n        } else {\n            String moduleFilePrefix \u003d FLAG_module_output_path_prefix.get();\n            maybeCreateDirsForPath(moduleFilePrefix);\n            Map\u003cString, String\u003e moduleWrappers \u003d parseModuleWrappers(FLAG_module_wrapper.get(), modules);\n            PrintStream mapOut \u003d null;\n            if (!shouldGenerateMapPerModule(options)) {\n                mapOut \u003d openSourceMapStream(options, moduleFilePrefix, null);\n            }\n            for (JSModule m : modules) {\n                if (shouldGenerateMapPerModule(options)) {\n                    mapOut \u003d openSourceMapStream(options, moduleFilePrefix, m.getName());\n                }\n                PrintStream ps \u003d new PrintStream(new FileOutputStream(moduleFilePrefix + m.getName() + \".js\"));\n                if (options.sourceMapOutputPath !\u003d null) {\n                    compiler.getSourceMap().reset();\n                }\n                writeOutput(ps, compiler, compiler.toSource(m), moduleWrappers.get(m.getName()), \"%s\");\n                if (options.sourceMapOutputPath !\u003d null) {\n                    compiler.getSourceMap().appendTo(mapOut, m.getName());\n                }\n                ps.close();\n                if (shouldGenerateMapPerModule(options) \u0026\u0026 mapOut !\u003d null) {\n                    mapOut.close();\n                    mapOut \u003d null;\n                }\n            }\n            if (mapOut !\u003d null) {\n                mapOut.close();\n            }\n        }\n        if (options.externExportsPath !\u003d null) {\n            PrintStream eeOut \u003d openExternExportsStream(options, options.jsOutputFile);\n            eeOut.append(result.externExport);\n            eeOut.close();\n        }\n        outputNameMaps(options);\n    }\n    return Math.min(result.errors.length, 0x7f);\n}",
      "path": "src/com/google/javascript/jscomp/AbstractCompilerRunner.java",
      "functionStartLine": 526,
      "functionName": "doRun",
      "functionAnnotation": "",
      "functionDoc": "Parses command-line arguments and runs the compiler.\n\n@return system exit status\n",
      "diff": "@@ -1,105 +1,102 @@\n protected int doRun() throws FlagUsageException, IOException {\n     Compiler.setLoggingLevel(Level.parse(FLAG_logging_level.get()));\n     List\u003cJSSourceFile\u003e externsList \u003d createExterns();\n     JSSourceFile[] externs \u003d new JSSourceFile[externsList.size()];\n     externsList.toArray(externs);\n     compiler \u003d createCompiler();\n     B options \u003d createOptions();\n     JSModule[] modules \u003d null;\n     Result result;\n     if (FLAG_js_output_file.get().length() \u003e 0) {\n         options.jsOutputFile \u003d FLAG_js_output_file.get();\n     }\n     if (FLAG_create_source_map.get().length() \u003e 0) {\n         options.sourceMapOutputPath \u003d FLAG_create_source_map.get();\n     }\n     if (!FLAG_variable_map_input_file.get().equals(\"\")) {\n         options.inputVariableMapSerialized \u003d VariableMap.load(FLAG_variable_map_input_file.get()).toBytes();\n     }\n     if (!FLAG_property_map_input_file.get().equals(\"\")) {\n         options.inputPropertyMapSerialized \u003d VariableMap.load(FLAG_property_map_input_file.get()).toBytes();\n     }\n-    if (FLAG_check_types.get()) {\n-        options.checkTypes \u003d true;\n-    }\n     if (!options.jsOutputFile.equals(\"\")) {\n         out \u003d new PrintStream(options.jsOutputFile);\n     }\n     if (FLAG_third_party.get()) {\n         compiler.setCodingConvention(new DefaultCodingConvention());\n     }\n     ((PrintStreamErrorManager) compiler.getErrorManager()).setSummaryDetailLevel(FLAG_summary_detail_level.get());\n     List\u003cString\u003e jsFiles \u003d FLAG_js.get();\n     List\u003cString\u003e moduleSpecs \u003d FLAG_module.get();\n     if (!moduleSpecs.isEmpty()) {\n         modules \u003d createJsModules(moduleSpecs, jsFiles);\n         result \u003d compiler.compile(externs, modules, options);\n     } else {\n         List\u003cJSSourceFile\u003e inputList \u003d createSourceInputs(jsFiles);\n         JSSourceFile[] inputs \u003d new JSSourceFile[inputList.size()];\n         inputList.toArray(inputs);\n         result \u003d compiler.compile(externs, inputs, options);\n     }\n     if (FLAG_print_ast.get()) {\n         if (compiler.getRoot() \u003d\u003d null) {\n             return 1;\n         } else {\n             ControlFlowGraph\u003cNode\u003e cfg \u003d compiler.computeCFG();\n             DotFormatter.appendDot(compiler.getRoot(), cfg, out);\n             out.println();\n             return 0;\n         }\n     }\n     if (FLAG_print_tree.get()) {\n         if (compiler.getRoot() \u003d\u003d null) {\n             out.println(\"Code contains errors; no tree was generated.\");\n             return 1;\n         } else {\n             compiler.getRoot().appendStringTree(out);\n             out.println(\"\");\n             return 0;\n         }\n     }\n     if (result.success) {\n         if (modules \u003d\u003d null) {\n             writeOutput(out, compiler, compiler.toSource(), FLAG_output_wrapper.get(), FLAG_output_wrapper_marker.get());\n             outputSourceMap(options, options.jsOutputFile);\n         } else {\n             String moduleFilePrefix \u003d FLAG_module_output_path_prefix.get();\n             maybeCreateDirsForPath(moduleFilePrefix);\n             Map\u003cString, String\u003e moduleWrappers \u003d parseModuleWrappers(FLAG_module_wrapper.get(), modules);\n             PrintStream mapOut \u003d null;\n             if (!shouldGenerateMapPerModule(options)) {\n                 mapOut \u003d openSourceMapStream(options, moduleFilePrefix, null);\n             }\n             for (JSModule m : modules) {\n                 if (shouldGenerateMapPerModule(options)) {\n                     mapOut \u003d openSourceMapStream(options, moduleFilePrefix, m.getName());\n                 }\n                 PrintStream ps \u003d new PrintStream(new FileOutputStream(moduleFilePrefix + m.getName() + \".js\"));\n                 if (options.sourceMapOutputPath !\u003d null) {\n                     compiler.getSourceMap().reset();\n                 }\n                 writeOutput(ps, compiler, compiler.toSource(m), moduleWrappers.get(m.getName()), \"%s\");\n                 if (options.sourceMapOutputPath !\u003d null) {\n                     compiler.getSourceMap().appendTo(mapOut, m.getName());\n                 }\n                 ps.close();\n                 if (shouldGenerateMapPerModule(options) \u0026\u0026 mapOut !\u003d null) {\n                     mapOut.close();\n                     mapOut \u003d null;\n                 }\n             }\n             if (mapOut !\u003d null) {\n                 mapOut.close();\n             }\n         }\n         if (options.externExportsPath !\u003d null) {\n             PrintStream eeOut \u003d openExternExportsStream(options, options.jsOutputFile);\n             eeOut.append(result.externExport);\n             eeOut.close();\n         }\n         outputNameMaps(options);\n     }\n     return Math.min(result.errors.length, 0x7f);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8354dcb5eb30240c82c08d060779809d9137c46f": {
      "type": "Ybodychange",
      "commitMessage": "Adding missing --check_types option. Hello type checker!\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@9 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/12/09, 11:36 PM",
      "commitName": "8354dcb5eb30240c82c08d060779809d9137c46f",
      "commitAuthor": "pascallouisperez",
      "commitDateOld": "11/10/09, 11:16 AM",
      "commitNameOld": "78995bf9e88599055a8c4165d89c09dc92a44b30",
      "commitAuthorOld": "nicholas.j.santos@gmail.com",
      "daysBetweenCommits": 2.51,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "protected int doRun() throws FlagUsageException, IOException {\n    Compiler.setLoggingLevel(Level.parse(FLAG_logging_level.get()));\n    List\u003cJSSourceFile\u003e externsList \u003d createExterns();\n    JSSourceFile[] externs \u003d new JSSourceFile[externsList.size()];\n    externsList.toArray(externs);\n    compiler \u003d createCompiler();\n    B options \u003d createOptions();\n    JSModule[] modules \u003d null;\n    Result result;\n    if (FLAG_js_output_file.get().length() \u003e 0) {\n        options.jsOutputFile \u003d FLAG_js_output_file.get();\n    }\n    if (FLAG_create_source_map.get().length() \u003e 0) {\n        options.sourceMapOutputPath \u003d FLAG_create_source_map.get();\n    }\n    if (!FLAG_variable_map_input_file.get().equals(\"\")) {\n        options.inputVariableMapSerialized \u003d VariableMap.load(FLAG_variable_map_input_file.get()).toBytes();\n    }\n    if (!FLAG_property_map_input_file.get().equals(\"\")) {\n        options.inputPropertyMapSerialized \u003d VariableMap.load(FLAG_property_map_input_file.get()).toBytes();\n    }\n    if (FLAG_check_types.get()) {\n        options.checkTypes \u003d true;\n    }\n    if (!options.jsOutputFile.equals(\"\")) {\n        out \u003d new PrintStream(options.jsOutputFile);\n    }\n    if (FLAG_third_party.get()) {\n        compiler.setCodingConvention(new DefaultCodingConvention());\n    }\n    ((PrintStreamErrorManager) compiler.getErrorManager()).setSummaryDetailLevel(FLAG_summary_detail_level.get());\n    List\u003cString\u003e jsFiles \u003d FLAG_js.get();\n    List\u003cString\u003e moduleSpecs \u003d FLAG_module.get();\n    if (!moduleSpecs.isEmpty()) {\n        modules \u003d createJsModules(moduleSpecs, jsFiles);\n        result \u003d compiler.compile(externs, modules, options);\n    } else {\n        List\u003cJSSourceFile\u003e inputList \u003d createSourceInputs(jsFiles);\n        JSSourceFile[] inputs \u003d new JSSourceFile[inputList.size()];\n        inputList.toArray(inputs);\n        result \u003d compiler.compile(externs, inputs, options);\n    }\n    if (FLAG_print_ast.get()) {\n        if (compiler.getRoot() \u003d\u003d null) {\n            return 1;\n        } else {\n            ControlFlowGraph\u003cNode\u003e cfg \u003d compiler.computeCFG();\n            DotFormatter.appendDot(compiler.getRoot(), cfg, out);\n            out.println();\n            return 0;\n        }\n    }\n    if (FLAG_print_tree.get()) {\n        if (compiler.getRoot() \u003d\u003d null) {\n            out.println(\"Code contains errors; no tree was generated.\");\n            return 1;\n        } else {\n            compiler.getRoot().appendStringTree(out);\n            out.println(\"\");\n            return 0;\n        }\n    }\n    if (result.success) {\n        if (modules \u003d\u003d null) {\n            writeOutput(out, compiler, compiler.toSource(), FLAG_output_wrapper.get(), FLAG_output_wrapper_marker.get());\n            outputSourceMap(options, options.jsOutputFile);\n        } else {\n            String moduleFilePrefix \u003d FLAG_module_output_path_prefix.get();\n            maybeCreateDirsForPath(moduleFilePrefix);\n            Map\u003cString, String\u003e moduleWrappers \u003d parseModuleWrappers(FLAG_module_wrapper.get(), modules);\n            PrintStream mapOut \u003d null;\n            if (!shouldGenerateMapPerModule(options)) {\n                mapOut \u003d openSourceMapStream(options, moduleFilePrefix, null);\n            }\n            for (JSModule m : modules) {\n                if (shouldGenerateMapPerModule(options)) {\n                    mapOut \u003d openSourceMapStream(options, moduleFilePrefix, m.getName());\n                }\n                PrintStream ps \u003d new PrintStream(new FileOutputStream(moduleFilePrefix + m.getName() + \".js\"));\n                if (options.sourceMapOutputPath !\u003d null) {\n                    compiler.getSourceMap().reset();\n                }\n                writeOutput(ps, compiler, compiler.toSource(m), moduleWrappers.get(m.getName()), \"%s\");\n                if (options.sourceMapOutputPath !\u003d null) {\n                    compiler.getSourceMap().appendTo(mapOut, m.getName());\n                }\n                ps.close();\n                if (shouldGenerateMapPerModule(options) \u0026\u0026 mapOut !\u003d null) {\n                    mapOut.close();\n                    mapOut \u003d null;\n                }\n            }\n            if (mapOut !\u003d null) {\n                mapOut.close();\n            }\n        }\n        if (options.externExportsPath !\u003d null) {\n            PrintStream eeOut \u003d openExternExportsStream(options, options.jsOutputFile);\n            eeOut.append(result.externExport);\n            eeOut.close();\n        }\n        outputNameMaps(options);\n    }\n    return Math.min(result.errors.length, 0x7f);\n}",
      "path": "src/com/google/javascript/jscomp/AbstractCompilerRunner.java",
      "functionStartLine": 510,
      "functionName": "doRun",
      "functionAnnotation": "",
      "functionDoc": "Parses command-line arguments and runs the compiler.\n\n@return system exit status\n",
      "diff": "@@ -1,102 +1,105 @@\n protected int doRun() throws FlagUsageException, IOException {\n     Compiler.setLoggingLevel(Level.parse(FLAG_logging_level.get()));\n     List\u003cJSSourceFile\u003e externsList \u003d createExterns();\n     JSSourceFile[] externs \u003d new JSSourceFile[externsList.size()];\n     externsList.toArray(externs);\n     compiler \u003d createCompiler();\n     B options \u003d createOptions();\n     JSModule[] modules \u003d null;\n     Result result;\n     if (FLAG_js_output_file.get().length() \u003e 0) {\n         options.jsOutputFile \u003d FLAG_js_output_file.get();\n     }\n     if (FLAG_create_source_map.get().length() \u003e 0) {\n         options.sourceMapOutputPath \u003d FLAG_create_source_map.get();\n     }\n     if (!FLAG_variable_map_input_file.get().equals(\"\")) {\n         options.inputVariableMapSerialized \u003d VariableMap.load(FLAG_variable_map_input_file.get()).toBytes();\n     }\n     if (!FLAG_property_map_input_file.get().equals(\"\")) {\n         options.inputPropertyMapSerialized \u003d VariableMap.load(FLAG_property_map_input_file.get()).toBytes();\n     }\n+    if (FLAG_check_types.get()) {\n+        options.checkTypes \u003d true;\n+    }\n     if (!options.jsOutputFile.equals(\"\")) {\n         out \u003d new PrintStream(options.jsOutputFile);\n     }\n     if (FLAG_third_party.get()) {\n         compiler.setCodingConvention(new DefaultCodingConvention());\n     }\n     ((PrintStreamErrorManager) compiler.getErrorManager()).setSummaryDetailLevel(FLAG_summary_detail_level.get());\n     List\u003cString\u003e jsFiles \u003d FLAG_js.get();\n     List\u003cString\u003e moduleSpecs \u003d FLAG_module.get();\n     if (!moduleSpecs.isEmpty()) {\n         modules \u003d createJsModules(moduleSpecs, jsFiles);\n         result \u003d compiler.compile(externs, modules, options);\n     } else {\n         List\u003cJSSourceFile\u003e inputList \u003d createSourceInputs(jsFiles);\n         JSSourceFile[] inputs \u003d new JSSourceFile[inputList.size()];\n         inputList.toArray(inputs);\n         result \u003d compiler.compile(externs, inputs, options);\n     }\n     if (FLAG_print_ast.get()) {\n         if (compiler.getRoot() \u003d\u003d null) {\n             return 1;\n         } else {\n             ControlFlowGraph\u003cNode\u003e cfg \u003d compiler.computeCFG();\n             DotFormatter.appendDot(compiler.getRoot(), cfg, out);\n             out.println();\n             return 0;\n         }\n     }\n     if (FLAG_print_tree.get()) {\n         if (compiler.getRoot() \u003d\u003d null) {\n             out.println(\"Code contains errors; no tree was generated.\");\n             return 1;\n         } else {\n             compiler.getRoot().appendStringTree(out);\n             out.println(\"\");\n             return 0;\n         }\n     }\n     if (result.success) {\n         if (modules \u003d\u003d null) {\n             writeOutput(out, compiler, compiler.toSource(), FLAG_output_wrapper.get(), FLAG_output_wrapper_marker.get());\n             outputSourceMap(options, options.jsOutputFile);\n         } else {\n             String moduleFilePrefix \u003d FLAG_module_output_path_prefix.get();\n             maybeCreateDirsForPath(moduleFilePrefix);\n             Map\u003cString, String\u003e moduleWrappers \u003d parseModuleWrappers(FLAG_module_wrapper.get(), modules);\n             PrintStream mapOut \u003d null;\n             if (!shouldGenerateMapPerModule(options)) {\n                 mapOut \u003d openSourceMapStream(options, moduleFilePrefix, null);\n             }\n             for (JSModule m : modules) {\n                 if (shouldGenerateMapPerModule(options)) {\n                     mapOut \u003d openSourceMapStream(options, moduleFilePrefix, m.getName());\n                 }\n                 PrintStream ps \u003d new PrintStream(new FileOutputStream(moduleFilePrefix + m.getName() + \".js\"));\n                 if (options.sourceMapOutputPath !\u003d null) {\n                     compiler.getSourceMap().reset();\n                 }\n                 writeOutput(ps, compiler, compiler.toSource(m), moduleWrappers.get(m.getName()), \"%s\");\n                 if (options.sourceMapOutputPath !\u003d null) {\n                     compiler.getSourceMap().appendTo(mapOut, m.getName());\n                 }\n                 ps.close();\n                 if (shouldGenerateMapPerModule(options) \u0026\u0026 mapOut !\u003d null) {\n                     mapOut.close();\n                     mapOut \u003d null;\n                 }\n             }\n             if (mapOut !\u003d null) {\n                 mapOut.close();\n             }\n         }\n         if (options.externExportsPath !\u003d null) {\n             PrintStream eeOut \u003d openExternExportsStream(options, options.jsOutputFile);\n             eeOut.append(result.externExport);\n             eeOut.close();\n         }\n         outputNameMaps(options);\n     }\n     return Math.min(result.errors.length, 0x7f);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": {
      "type": "Yintroduced",
      "commitMessage": "Initial commit.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/3/09, 3:51 PM",
      "commitName": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "diff": "@@ -0,0 +1,102 @@\n+protected int doRun() throws FlagUsageException, IOException {\n+    Compiler.setLoggingLevel(Level.parse(FLAG_logging_level.get()));\n+    List\u003cJSSourceFile\u003e externsList \u003d createExterns();\n+    JSSourceFile[] externs \u003d new JSSourceFile[externsList.size()];\n+    externsList.toArray(externs);\n+    compiler \u003d createCompiler();\n+    B options \u003d createOptions();\n+    JSModule[] modules \u003d null;\n+    Result result;\n+    if (FLAG_js_output_file.get().length() \u003e 0) {\n+        options.jsOutputFile \u003d FLAG_js_output_file.get();\n+    }\n+    if (FLAG_create_source_map.get().length() \u003e 0) {\n+        options.sourceMapOutputPath \u003d FLAG_create_source_map.get();\n+    }\n+    if (!FLAG_variable_map_input_file.get().equals(\"\")) {\n+        options.inputVariableMapSerialized \u003d VariableMap.load(FLAG_variable_map_input_file.get()).toBytes();\n+    }\n+    if (!FLAG_property_map_input_file.get().equals(\"\")) {\n+        options.inputPropertyMapSerialized \u003d VariableMap.load(FLAG_property_map_input_file.get()).toBytes();\n+    }\n+    if (!options.jsOutputFile.equals(\"\")) {\n+        out \u003d new PrintStream(options.jsOutputFile);\n+    }\n+    if (FLAG_third_party.get()) {\n+        compiler.setCodingConvention(new DefaultCodingConvention());\n+    }\n+    ((PrintStreamErrorManager) compiler.getErrorManager()).setSummaryDetailLevel(FLAG_summary_detail_level.get());\n+    List\u003cString\u003e jsFiles \u003d FLAG_js.get();\n+    List\u003cString\u003e moduleSpecs \u003d FLAG_module.get();\n+    if (!moduleSpecs.isEmpty()) {\n+        modules \u003d createJsModules(moduleSpecs, jsFiles);\n+        result \u003d compiler.compile(externs, modules, options);\n+    } else {\n+        List\u003cJSSourceFile\u003e inputList \u003d createSourceInputs(jsFiles);\n+        JSSourceFile[] inputs \u003d new JSSourceFile[inputList.size()];\n+        inputList.toArray(inputs);\n+        result \u003d compiler.compile(externs, inputs, options);\n+    }\n+    if (FLAG_print_ast.get()) {\n+        if (compiler.getRoot() \u003d\u003d null) {\n+            return 1;\n+        } else {\n+            ControlFlowGraph\u003cNode\u003e cfg \u003d compiler.computeCFG();\n+            DotFormatter.appendDot(compiler.getRoot(), cfg, out);\n+            out.println();\n+            return 0;\n+        }\n+    }\n+    if (FLAG_print_tree.get()) {\n+        if (compiler.getRoot() \u003d\u003d null) {\n+            out.println(\"Code contains errors; no tree was generated.\");\n+            return 1;\n+        } else {\n+            compiler.getRoot().appendStringTree(out);\n+            out.println(\"\");\n+            return 0;\n+        }\n+    }\n+    if (result.success) {\n+        if (modules \u003d\u003d null) {\n+            writeOutput(out, compiler, compiler.toSource(), FLAG_output_wrapper.get(), FLAG_output_wrapper_marker.get());\n+            outputSourceMap(options, options.jsOutputFile);\n+        } else {\n+            String moduleFilePrefix \u003d FLAG_module_output_path_prefix.get();\n+            maybeCreateDirsForPath(moduleFilePrefix);\n+            Map\u003cString, String\u003e moduleWrappers \u003d parseModuleWrappers(FLAG_module_wrapper.get(), modules);\n+            PrintStream mapOut \u003d null;\n+            if (!shouldGenerateMapPerModule(options)) {\n+                mapOut \u003d openSourceMapStream(options, moduleFilePrefix, null);\n+            }\n+            for (JSModule m : modules) {\n+                if (shouldGenerateMapPerModule(options)) {\n+                    mapOut \u003d openSourceMapStream(options, moduleFilePrefix, m.getName());\n+                }\n+                PrintStream ps \u003d new PrintStream(new FileOutputStream(moduleFilePrefix + m.getName() + \".js\"));\n+                if (options.sourceMapOutputPath !\u003d null) {\n+                    compiler.getSourceMap().reset();\n+                }\n+                writeOutput(ps, compiler, compiler.toSource(m), moduleWrappers.get(m.getName()), \"%s\");\n+                if (options.sourceMapOutputPath !\u003d null) {\n+                    compiler.getSourceMap().appendTo(mapOut, m.getName());\n+                }\n+                ps.close();\n+                if (shouldGenerateMapPerModule(options) \u0026\u0026 mapOut !\u003d null) {\n+                    mapOut.close();\n+                    mapOut \u003d null;\n+                }\n+            }\n+            if (mapOut !\u003d null) {\n+                mapOut.close();\n+            }\n+        }\n+        if (options.externExportsPath !\u003d null) {\n+            PrintStream eeOut \u003d openExternExportsStream(options, options.jsOutputFile);\n+            eeOut.append(result.externExport);\n+            eeOut.close();\n+        }\n+        outputNameMaps(options);\n+    }\n+    return Math.min(result.errors.length, 0x7f);\n+}\n\\ No newline at end of file\n",
      "actualSource": "protected int doRun() throws FlagUsageException, IOException {\n    Compiler.setLoggingLevel(Level.parse(FLAG_logging_level.get()));\n    List\u003cJSSourceFile\u003e externsList \u003d createExterns();\n    JSSourceFile[] externs \u003d new JSSourceFile[externsList.size()];\n    externsList.toArray(externs);\n    compiler \u003d createCompiler();\n    B options \u003d createOptions();\n    JSModule[] modules \u003d null;\n    Result result;\n    if (FLAG_js_output_file.get().length() \u003e 0) {\n        options.jsOutputFile \u003d FLAG_js_output_file.get();\n    }\n    if (FLAG_create_source_map.get().length() \u003e 0) {\n        options.sourceMapOutputPath \u003d FLAG_create_source_map.get();\n    }\n    if (!FLAG_variable_map_input_file.get().equals(\"\")) {\n        options.inputVariableMapSerialized \u003d VariableMap.load(FLAG_variable_map_input_file.get()).toBytes();\n    }\n    if (!FLAG_property_map_input_file.get().equals(\"\")) {\n        options.inputPropertyMapSerialized \u003d VariableMap.load(FLAG_property_map_input_file.get()).toBytes();\n    }\n    if (!options.jsOutputFile.equals(\"\")) {\n        out \u003d new PrintStream(options.jsOutputFile);\n    }\n    if (FLAG_third_party.get()) {\n        compiler.setCodingConvention(new DefaultCodingConvention());\n    }\n    ((PrintStreamErrorManager) compiler.getErrorManager()).setSummaryDetailLevel(FLAG_summary_detail_level.get());\n    List\u003cString\u003e jsFiles \u003d FLAG_js.get();\n    List\u003cString\u003e moduleSpecs \u003d FLAG_module.get();\n    if (!moduleSpecs.isEmpty()) {\n        modules \u003d createJsModules(moduleSpecs, jsFiles);\n        result \u003d compiler.compile(externs, modules, options);\n    } else {\n        List\u003cJSSourceFile\u003e inputList \u003d createSourceInputs(jsFiles);\n        JSSourceFile[] inputs \u003d new JSSourceFile[inputList.size()];\n        inputList.toArray(inputs);\n        result \u003d compiler.compile(externs, inputs, options);\n    }\n    if (FLAG_print_ast.get()) {\n        if (compiler.getRoot() \u003d\u003d null) {\n            return 1;\n        } else {\n            ControlFlowGraph\u003cNode\u003e cfg \u003d compiler.computeCFG();\n            DotFormatter.appendDot(compiler.getRoot(), cfg, out);\n            out.println();\n            return 0;\n        }\n    }\n    if (FLAG_print_tree.get()) {\n        if (compiler.getRoot() \u003d\u003d null) {\n            out.println(\"Code contains errors; no tree was generated.\");\n            return 1;\n        } else {\n            compiler.getRoot().appendStringTree(out);\n            out.println(\"\");\n            return 0;\n        }\n    }\n    if (result.success) {\n        if (modules \u003d\u003d null) {\n            writeOutput(out, compiler, compiler.toSource(), FLAG_output_wrapper.get(), FLAG_output_wrapper_marker.get());\n            outputSourceMap(options, options.jsOutputFile);\n        } else {\n            String moduleFilePrefix \u003d FLAG_module_output_path_prefix.get();\n            maybeCreateDirsForPath(moduleFilePrefix);\n            Map\u003cString, String\u003e moduleWrappers \u003d parseModuleWrappers(FLAG_module_wrapper.get(), modules);\n            PrintStream mapOut \u003d null;\n            if (!shouldGenerateMapPerModule(options)) {\n                mapOut \u003d openSourceMapStream(options, moduleFilePrefix, null);\n            }\n            for (JSModule m : modules) {\n                if (shouldGenerateMapPerModule(options)) {\n                    mapOut \u003d openSourceMapStream(options, moduleFilePrefix, m.getName());\n                }\n                PrintStream ps \u003d new PrintStream(new FileOutputStream(moduleFilePrefix + m.getName() + \".js\"));\n                if (options.sourceMapOutputPath !\u003d null) {\n                    compiler.getSourceMap().reset();\n                }\n                writeOutput(ps, compiler, compiler.toSource(m), moduleWrappers.get(m.getName()), \"%s\");\n                if (options.sourceMapOutputPath !\u003d null) {\n                    compiler.getSourceMap().appendTo(mapOut, m.getName());\n                }\n                ps.close();\n                if (shouldGenerateMapPerModule(options) \u0026\u0026 mapOut !\u003d null) {\n                    mapOut.close();\n                    mapOut \u003d null;\n                }\n            }\n            if (mapOut !\u003d null) {\n                mapOut.close();\n            }\n        }\n        if (options.externExportsPath !\u003d null) {\n            PrintStream eeOut \u003d openExternExportsStream(options, options.jsOutputFile);\n            eeOut.append(result.externExport);\n            eeOut.close();\n        }\n        outputNameMaps(options);\n    }\n    return Math.min(result.errors.length, 0x7f);\n}",
      "path": "src/com/google/javascript/jscomp/AbstractCompilerRunner.java",
      "functionStartLine": 506,
      "functionName": "doRun",
      "functionAnnotation": "",
      "functionDoc": "Parses command-line arguments and runs the compiler.\n\n@return system exit status\n"
    }
  }
}