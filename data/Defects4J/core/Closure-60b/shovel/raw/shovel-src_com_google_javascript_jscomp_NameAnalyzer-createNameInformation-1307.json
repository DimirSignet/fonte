{
  "origin": "codeshovel",
  "repositoryName": "Closure-60b",
  "repositoryPath": "/tmp/Closure-60b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "NameAnalyzer.java",
  "functionName": "createNameInformation",
  "functionId": "createNameInformation___t-NodeTraversal__n-Node__parent-Node",
  "sourceFilePath": "src/com/google/javascript/jscomp/NameAnalyzer.java",
  "functionAnnotation": "",
  "functionDoc": "Creates name information for the current node during a traversal.\n\n@param t The node traversal\n@param n The current node\n@param parent The parent of n\n@return The name information, or null if the name is irrelevant to this\n    pass\n",
  "functionStartLine": 1307,
  "functionEndLine": 1407,
  "numCommitsSeen": 28,
  "timeTaken": 2088,
  "changeHistory": [
    "b7d0c3ee8b19c4e9387984ed6bab561929093eed",
    "bea4e626a55e934ee9a81897069d4a05414c9c57",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3"
  ],
  "changeHistoryShort": {
    "b7d0c3ee8b19c4e9387984ed6bab561929093eed": "Ybodychange",
    "bea4e626a55e934ee9a81897069d4a05414c9c57": "Ybodychange",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "b7d0c3ee8b19c4e9387984ed6bab561929093eed": {
      "type": "Ybodychange",
      "commitMessage": "\nMake sure NameAnalyzer can handle constructors defined\nin object literals, now that the peephole passes\nwill fold them together\n\nR\u003djohnlenz\nDELTA\u003d101  (85 added, 6 deleted, 10 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d1524\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1027 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/20/11, 3:25 PM",
      "commitName": "b7d0c3ee8b19c4e9387984ed6bab561929093eed",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "4/12/11, 12:15 PM",
      "commitNameOld": "f322be0e576d5e2114cb59c0a6537197997b9c59",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 8.13,
      "commitsBetweenForRepo": 27,
      "commitsBetweenForFile": 1,
      "actualSource": "private NameInformation createNameInformation(NodeTraversal t, Node n, Node parent) {\n    String name \u003d \"\";\n    Node rootNameNode \u003d n;\n    boolean bNameWasShortened \u003d false;\n    while (true) {\n        if (NodeUtil.isGet(rootNameNode)) {\n            Node prop \u003d rootNameNode.getLastChild();\n            if (rootNameNode.getType() \u003d\u003d Token.GETPROP) {\n                name \u003d \".\" + prop.getString() + name;\n            } else {\n                bNameWasShortened \u003d true;\n                name \u003d \"\";\n            }\n            rootNameNode \u003d rootNameNode.getFirstChild();\n        } else if (NodeUtil.isObjectLitKey(rootNameNode, rootNameNode.getParent())) {\n            name \u003d \".\" + rootNameNode.getString() + name;\n            Node objLit \u003d rootNameNode.getParent();\n            Node objLitParent \u003d objLit.getParent();\n            if (objLitParent.getType() \u003d\u003d Token.ASSIGN) {\n                rootNameNode \u003d objLitParent.getFirstChild();\n            } else if (objLitParent.getType() \u003d\u003d Token.NAME) {\n                rootNameNode \u003d objLitParent;\n            } else if (objLitParent.getType() \u003d\u003d Token.STRING) {\n                rootNameNode \u003d objLitParent;\n            } else {\n                return null;\n            }\n        } else {\n            break;\n        }\n    }\n    if (NodeUtil.isCall(parent) \u0026\u0026 t.inGlobalScope()) {\n        CodingConvention convention \u003d compiler.getCodingConvention();\n        SubclassRelationship classes \u003d convention.getClassesDefinedByCall(parent);\n        if (classes !\u003d null) {\n            NameInformation nameInfo \u003d new NameInformation();\n            nameInfo.name \u003d classes.subclassName;\n            nameInfo.onlyAffectsClassDef \u003d true;\n            nameInfo.superclass \u003d classes.superclassName;\n            return nameInfo;\n        }\n        String singletonGetterClass \u003d convention.getSingletonGetterClassName(parent);\n        if (singletonGetterClass !\u003d null) {\n            NameInformation nameInfo \u003d new NameInformation();\n            nameInfo.name \u003d singletonGetterClass;\n            nameInfo.onlyAffectsClassDef \u003d true;\n            return nameInfo;\n        }\n    }\n    switch(rootNameNode.getType()) {\n        case Token.NAME:\n            if (!bNameWasShortened \u0026\u0026 n.getType() \u003d\u003d Token.GETPROP \u0026\u0026 parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 \"prototype\".equals(n.getLastChild().getString())) {\n                if (createNameInformation(t, n.getFirstChild(), n) !\u003d null) {\n                    name \u003d rootNameNode.getString() + name;\n                    name \u003d name.substring(0, name.length() - PROTOTYPE_SUFFIX_LEN);\n                    NameInformation nameInfo \u003d new NameInformation();\n                    nameInfo.name \u003d name;\n                    return nameInfo;\n                } else {\n                    return null;\n                }\n            }\n            return createNameInformation(rootNameNode.getString() + name, t.getScope(), rootNameNode);\n        case Token.THIS:\n            if (t.inGlobalScope()) {\n                NameInformation nameInfo \u003d new NameInformation();\n                if (name.indexOf(\u0027.\u0027) \u003d\u003d 0) {\n                    nameInfo.name \u003d name.substring(1);\n                } else {\n                    nameInfo.name \u003d name;\n                }\n                nameInfo.isExternallyReferenceable \u003d true;\n                return nameInfo;\n            }\n            return null;\n        default:\n            return null;\n    }\n}",
      "path": "src/com/google/javascript/jscomp/NameAnalyzer.java",
      "functionStartLine": 1299,
      "functionName": "createNameInformation",
      "functionAnnotation": "",
      "functionDoc": "Creates name information for the current node during a traversal.\n\n@param t The node traversal\n@param n The current node\n@param parent The parent of n\n@return The name information, or null if the name is irrelevant to this\n    pass\n",
      "diff": "@@ -1,62 +1,79 @@\n private NameInformation createNameInformation(NodeTraversal t, Node n, Node parent) {\n     String name \u003d \"\";\n     Node rootNameNode \u003d n;\n     boolean bNameWasShortened \u003d false;\n-    while (NodeUtil.isGet(rootNameNode)) {\n-        Node prop \u003d rootNameNode.getLastChild();\n-        if (rootNameNode.getType() \u003d\u003d Token.GETPROP) {\n-            name \u003d \".\" + prop.getString() + name;\n+    while (true) {\n+        if (NodeUtil.isGet(rootNameNode)) {\n+            Node prop \u003d rootNameNode.getLastChild();\n+            if (rootNameNode.getType() \u003d\u003d Token.GETPROP) {\n+                name \u003d \".\" + prop.getString() + name;\n+            } else {\n+                bNameWasShortened \u003d true;\n+                name \u003d \"\";\n+            }\n+            rootNameNode \u003d rootNameNode.getFirstChild();\n+        } else if (NodeUtil.isObjectLitKey(rootNameNode, rootNameNode.getParent())) {\n+            name \u003d \".\" + rootNameNode.getString() + name;\n+            Node objLit \u003d rootNameNode.getParent();\n+            Node objLitParent \u003d objLit.getParent();\n+            if (objLitParent.getType() \u003d\u003d Token.ASSIGN) {\n+                rootNameNode \u003d objLitParent.getFirstChild();\n+            } else if (objLitParent.getType() \u003d\u003d Token.NAME) {\n+                rootNameNode \u003d objLitParent;\n+            } else if (objLitParent.getType() \u003d\u003d Token.STRING) {\n+                rootNameNode \u003d objLitParent;\n+            } else {\n+                return null;\n+            }\n         } else {\n-            bNameWasShortened \u003d true;\n-            name \u003d \"\";\n+            break;\n         }\n-        rootNameNode \u003d rootNameNode.getFirstChild();\n     }\n     if (NodeUtil.isCall(parent) \u0026\u0026 t.inGlobalScope()) {\n         CodingConvention convention \u003d compiler.getCodingConvention();\n         SubclassRelationship classes \u003d convention.getClassesDefinedByCall(parent);\n         if (classes !\u003d null) {\n             NameInformation nameInfo \u003d new NameInformation();\n             nameInfo.name \u003d classes.subclassName;\n             nameInfo.onlyAffectsClassDef \u003d true;\n             nameInfo.superclass \u003d classes.superclassName;\n             return nameInfo;\n         }\n         String singletonGetterClass \u003d convention.getSingletonGetterClassName(parent);\n         if (singletonGetterClass !\u003d null) {\n             NameInformation nameInfo \u003d new NameInformation();\n             nameInfo.name \u003d singletonGetterClass;\n             nameInfo.onlyAffectsClassDef \u003d true;\n             return nameInfo;\n         }\n     }\n     switch(rootNameNode.getType()) {\n         case Token.NAME:\n             if (!bNameWasShortened \u0026\u0026 n.getType() \u003d\u003d Token.GETPROP \u0026\u0026 parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 \"prototype\".equals(n.getLastChild().getString())) {\n                 if (createNameInformation(t, n.getFirstChild(), n) !\u003d null) {\n                     name \u003d rootNameNode.getString() + name;\n                     name \u003d name.substring(0, name.length() - PROTOTYPE_SUFFIX_LEN);\n                     NameInformation nameInfo \u003d new NameInformation();\n                     nameInfo.name \u003d name;\n                     return nameInfo;\n                 } else {\n                     return null;\n                 }\n             }\n             return createNameInformation(rootNameNode.getString() + name, t.getScope(), rootNameNode);\n         case Token.THIS:\n             if (t.inGlobalScope()) {\n                 NameInformation nameInfo \u003d new NameInformation();\n                 if (name.indexOf(\u0027.\u0027) \u003d\u003d 0) {\n                     nameInfo.name \u003d name.substring(1);\n                 } else {\n                     nameInfo.name \u003d name;\n                 }\n                 nameInfo.isExternallyReferenceable \u003d true;\n                 return nameInfo;\n             }\n             return null;\n         default:\n             return null;\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "bea4e626a55e934ee9a81897069d4a05414c9c57": {
      "type": "Ybodychange",
      "commitMessage": "\nChange on 2010/04/16 by nick\n\n        Move the topological dependency sort into jscomp/deps\n\n        R\u003dalan\n        DELTA\u003d246  (161 added, 75 deleted, 10 changed)\n\nChange on 2010/04/16 by john\n\n        Enable decompose expressions the open source compiler.\n\n        R\u003dalan\n        DELTA\u003d2  (2 added, 0 deleted, 0 changed)\n\nChange on 2010/04/16 by alan\n\n        Update flow sensitive inlining flow to be tri state. This should not change the behavior\n           of the compiler.\n\n        R\u003djohn,nassar\n        DELTA\u003d11  (1 added, 2 deleted, 8 changed)\n\nChange on 2010/04/16 by nick\n\n        treat goog.addSingletonGetter as a class-defining function.\n\n        R\u003dantonio\n        DELTA\u003d39  (26 added, 5 deleted, 8 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003dolbuid\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@190 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/19/10, 10:45 AM",
      "commitName": "bea4e626a55e934ee9a81897069d4a05414c9c57",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "4/16/10, 10:20 AM",
      "commitNameOld": "6e3eb4f7619179ba6c23db2af7549ef02f588c35",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 3.02,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "private NameInformation createNameInformation(NodeTraversal t, Node n, Node parent) {\n    String name \u003d \"\";\n    Node rootNameNode \u003d n;\n    boolean bNameWasShortened \u003d false;\n    while (NodeUtil.isGet(rootNameNode)) {\n        Node prop \u003d rootNameNode.getLastChild();\n        if (rootNameNode.getType() \u003d\u003d Token.GETPROP) {\n            name \u003d \".\" + prop.getString() + name;\n        } else {\n            bNameWasShortened \u003d true;\n            name \u003d \"\";\n        }\n        rootNameNode \u003d rootNameNode.getFirstChild();\n    }\n    if (NodeUtil.isCall(parent) \u0026\u0026 t.inGlobalScope()) {\n        CodingConvention convention \u003d compiler.getCodingConvention();\n        SubclassRelationship classes \u003d convention.getClassesDefinedByCall(parent);\n        if (classes !\u003d null) {\n            NameInformation nameInfo \u003d new NameInformation();\n            nameInfo.name \u003d classes.subclassName;\n            nameInfo.onlyAffectsClassDef \u003d true;\n            nameInfo.superclass \u003d classes.superclassName;\n            return nameInfo;\n        }\n        String singletonGetterClass \u003d convention.getSingletonGetterClassName(parent);\n        if (singletonGetterClass !\u003d null) {\n            NameInformation nameInfo \u003d new NameInformation();\n            nameInfo.name \u003d singletonGetterClass;\n            nameInfo.onlyAffectsClassDef \u003d true;\n            return nameInfo;\n        }\n    }\n    switch(rootNameNode.getType()) {\n        case Token.NAME:\n            if (!bNameWasShortened \u0026\u0026 n.getType() \u003d\u003d Token.GETPROP \u0026\u0026 parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 \"prototype\".equals(n.getLastChild().getString())) {\n                if (createNameInformation(t, n.getFirstChild(), n) !\u003d null) {\n                    name \u003d rootNameNode.getString() + name;\n                    name \u003d name.substring(0, name.length() - PROTOTYPE_SUFFIX_LEN);\n                    NameInformation nameInfo \u003d new NameInformation();\n                    nameInfo.name \u003d name;\n                    return nameInfo;\n                } else {\n                    return null;\n                }\n            }\n            return createNameInformation(rootNameNode.getString() + name, t.getScope(), rootNameNode);\n        case Token.THIS:\n            if (t.inGlobalScope()) {\n                NameInformation nameInfo \u003d new NameInformation();\n                if (name.indexOf(\u0027.\u0027) \u003d\u003d 0) {\n                    nameInfo.name \u003d name.substring(1);\n                } else {\n                    nameInfo.name \u003d name;\n                }\n                nameInfo.isExternallyReferenceable \u003d true;\n                return nameInfo;\n            }\n            return null;\n        default:\n            return null;\n    }\n}",
      "path": "src/com/google/javascript/jscomp/NameAnalyzer.java",
      "functionStartLine": 1236,
      "functionName": "createNameInformation",
      "functionAnnotation": "",
      "functionDoc": "Creates name information for the current node during a traversal.\n\n@param t The node traversal\n@param n The current node\n@param parent The parent of n\n@return The name information, or null if the name is irrelevant to this\n    pass\n",
      "diff": "@@ -1,54 +1,62 @@\n private NameInformation createNameInformation(NodeTraversal t, Node n, Node parent) {\n     String name \u003d \"\";\n     Node rootNameNode \u003d n;\n     boolean bNameWasShortened \u003d false;\n     while (NodeUtil.isGet(rootNameNode)) {\n         Node prop \u003d rootNameNode.getLastChild();\n         if (rootNameNode.getType() \u003d\u003d Token.GETPROP) {\n             name \u003d \".\" + prop.getString() + name;\n         } else {\n             bNameWasShortened \u003d true;\n             name \u003d \"\";\n         }\n         rootNameNode \u003d rootNameNode.getFirstChild();\n     }\n     if (NodeUtil.isCall(parent) \u0026\u0026 t.inGlobalScope()) {\n-        SubclassRelationship classes \u003d compiler.getCodingConvention().getClassesDefinedByCall(parent);\n+        CodingConvention convention \u003d compiler.getCodingConvention();\n+        SubclassRelationship classes \u003d convention.getClassesDefinedByCall(parent);\n         if (classes !\u003d null) {\n             NameInformation nameInfo \u003d new NameInformation();\n             nameInfo.name \u003d classes.subclassName;\n             nameInfo.onlyAffectsClassDef \u003d true;\n             nameInfo.superclass \u003d classes.superclassName;\n             return nameInfo;\n         }\n+        String singletonGetterClass \u003d convention.getSingletonGetterClassName(parent);\n+        if (singletonGetterClass !\u003d null) {\n+            NameInformation nameInfo \u003d new NameInformation();\n+            nameInfo.name \u003d singletonGetterClass;\n+            nameInfo.onlyAffectsClassDef \u003d true;\n+            return nameInfo;\n+        }\n     }\n     switch(rootNameNode.getType()) {\n         case Token.NAME:\n             if (!bNameWasShortened \u0026\u0026 n.getType() \u003d\u003d Token.GETPROP \u0026\u0026 parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 \"prototype\".equals(n.getLastChild().getString())) {\n                 if (createNameInformation(t, n.getFirstChild(), n) !\u003d null) {\n                     name \u003d rootNameNode.getString() + name;\n                     name \u003d name.substring(0, name.length() - PROTOTYPE_SUFFIX_LEN);\n                     NameInformation nameInfo \u003d new NameInformation();\n                     nameInfo.name \u003d name;\n                     return nameInfo;\n                 } else {\n                     return null;\n                 }\n             }\n             return createNameInformation(rootNameNode.getString() + name, t.getScope(), rootNameNode);\n         case Token.THIS:\n             if (t.inGlobalScope()) {\n                 NameInformation nameInfo \u003d new NameInformation();\n                 if (name.indexOf(\u0027.\u0027) \u003d\u003d 0) {\n                     nameInfo.name \u003d name.substring(1);\n                 } else {\n                     nameInfo.name \u003d name;\n                 }\n                 nameInfo.isExternallyReferenceable \u003d true;\n                 return nameInfo;\n             }\n             return null;\n         default:\n             return null;\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": {
      "type": "Yintroduced",
      "commitMessage": "Initial commit.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/3/09, 3:51 PM",
      "commitName": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "diff": "@@ -0,0 +1,54 @@\n+private NameInformation createNameInformation(NodeTraversal t, Node n, Node parent) {\n+    String name \u003d \"\";\n+    Node rootNameNode \u003d n;\n+    boolean bNameWasShortened \u003d false;\n+    while (NodeUtil.isGet(rootNameNode)) {\n+        Node prop \u003d rootNameNode.getLastChild();\n+        if (rootNameNode.getType() \u003d\u003d Token.GETPROP) {\n+            name \u003d \".\" + prop.getString() + name;\n+        } else {\n+            bNameWasShortened \u003d true;\n+            name \u003d \"\";\n+        }\n+        rootNameNode \u003d rootNameNode.getFirstChild();\n+    }\n+    if (NodeUtil.isCall(parent) \u0026\u0026 t.inGlobalScope()) {\n+        SubclassRelationship classes \u003d compiler.getCodingConvention().getClassesDefinedByCall(parent);\n+        if (classes !\u003d null) {\n+            NameInformation nameInfo \u003d new NameInformation();\n+            nameInfo.name \u003d classes.subclassName;\n+            nameInfo.onlyAffectsClassDef \u003d true;\n+            nameInfo.superclass \u003d classes.superclassName;\n+            return nameInfo;\n+        }\n+    }\n+    switch(rootNameNode.getType()) {\n+        case Token.NAME:\n+            if (!bNameWasShortened \u0026\u0026 n.getType() \u003d\u003d Token.GETPROP \u0026\u0026 parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 \"prototype\".equals(n.getLastChild().getString())) {\n+                if (createNameInformation(t, n.getFirstChild(), n) !\u003d null) {\n+                    name \u003d rootNameNode.getString() + name;\n+                    name \u003d name.substring(0, name.length() - PROTOTYPE_SUFFIX_LEN);\n+                    NameInformation nameInfo \u003d new NameInformation();\n+                    nameInfo.name \u003d name;\n+                    return nameInfo;\n+                } else {\n+                    return null;\n+                }\n+            }\n+            return createNameInformation(rootNameNode.getString() + name, t.getScope(), rootNameNode);\n+        case Token.THIS:\n+            if (t.inGlobalScope()) {\n+                NameInformation nameInfo \u003d new NameInformation();\n+                if (name.indexOf(\u0027.\u0027) \u003d\u003d 0) {\n+                    nameInfo.name \u003d name.substring(1);\n+                } else {\n+                    nameInfo.name \u003d name;\n+                }\n+                nameInfo.isExternallyReferenceable \u003d true;\n+                return nameInfo;\n+            }\n+            return null;\n+        default:\n+            return null;\n+    }\n+}\n\\ No newline at end of file\n",
      "actualSource": "private NameInformation createNameInformation(NodeTraversal t, Node n, Node parent) {\n    String name \u003d \"\";\n    Node rootNameNode \u003d n;\n    boolean bNameWasShortened \u003d false;\n    while (NodeUtil.isGet(rootNameNode)) {\n        Node prop \u003d rootNameNode.getLastChild();\n        if (rootNameNode.getType() \u003d\u003d Token.GETPROP) {\n            name \u003d \".\" + prop.getString() + name;\n        } else {\n            bNameWasShortened \u003d true;\n            name \u003d \"\";\n        }\n        rootNameNode \u003d rootNameNode.getFirstChild();\n    }\n    if (NodeUtil.isCall(parent) \u0026\u0026 t.inGlobalScope()) {\n        SubclassRelationship classes \u003d compiler.getCodingConvention().getClassesDefinedByCall(parent);\n        if (classes !\u003d null) {\n            NameInformation nameInfo \u003d new NameInformation();\n            nameInfo.name \u003d classes.subclassName;\n            nameInfo.onlyAffectsClassDef \u003d true;\n            nameInfo.superclass \u003d classes.superclassName;\n            return nameInfo;\n        }\n    }\n    switch(rootNameNode.getType()) {\n        case Token.NAME:\n            if (!bNameWasShortened \u0026\u0026 n.getType() \u003d\u003d Token.GETPROP \u0026\u0026 parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 \"prototype\".equals(n.getLastChild().getString())) {\n                if (createNameInformation(t, n.getFirstChild(), n) !\u003d null) {\n                    name \u003d rootNameNode.getString() + name;\n                    name \u003d name.substring(0, name.length() - PROTOTYPE_SUFFIX_LEN);\n                    NameInformation nameInfo \u003d new NameInformation();\n                    nameInfo.name \u003d name;\n                    return nameInfo;\n                } else {\n                    return null;\n                }\n            }\n            return createNameInformation(rootNameNode.getString() + name, t.getScope(), rootNameNode);\n        case Token.THIS:\n            if (t.inGlobalScope()) {\n                NameInformation nameInfo \u003d new NameInformation();\n                if (name.indexOf(\u0027.\u0027) \u003d\u003d 0) {\n                    nameInfo.name \u003d name.substring(1);\n                } else {\n                    nameInfo.name \u003d name;\n                }\n                nameInfo.isExternallyReferenceable \u003d true;\n                return nameInfo;\n            }\n            return null;\n        default:\n            return null;\n    }\n}",
      "path": "src/com/google/javascript/jscomp/NameAnalyzer.java",
      "functionStartLine": 1119,
      "functionName": "createNameInformation",
      "functionAnnotation": "",
      "functionDoc": "Creates name information for the current node during a traversal.\n\n@param t The node traversal\n@param n The current node\n@param parent The parent of n\n@return The name information, or null if the name is irrelevant to this\n    pass\n"
    }
  }
}