{
  "origin": "codeshovel",
  "repositoryName": "Closure-60b",
  "repositoryPath": "/tmp/Closure-60b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "CollapseProperties.java",
  "functionName": "inlineAliases",
  "functionId": "inlineAliases___namespace-GlobalNamespace",
  "sourceFilePath": "src/com/google/javascript/jscomp/CollapseProperties.java",
  "functionAnnotation": "",
  "functionDoc": "For each qualified name N in the global scope, we check if:\n(a) No ancestor of N is ever aliased or assigned an unknown value type.\n    (If N \u003d \"a.b.c\", \"a\" and \"a.b\" are never aliased).\n(b) N has exactly one write, and it lives in the global scope.\n(c) N is aliased in a local scope.\n\nIf (a) is true, then GlobalNamespace must know all the writes to N.\nIf (a) and (b) are true, then N cannot change during the execution of\n   a local scope.\nIf (a) and (b) and (c) are true, then the alias can be inlined if the\n   alias obeys the usual rules for how we decide whether a variable is\n   inlineable.\n\n@see InlineVariables\n",
  "functionStartLine": 160,
  "functionEndLine": 196,
  "numCommitsSeen": 34,
  "timeTaken": 1957,
  "changeHistory": [
    "8be3896c7639f91d83ac220531cc5cbdc5a029d4",
    "d68322323aa52d943b9dc5618ef8ea81d43d7b4f",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3"
  ],
  "changeHistoryShort": {
    "8be3896c7639f91d83ac220531cc5cbdc5a029d4": "Ybodychange",
    "d68322323aa52d943b9dc5618ef8ea81d43d7b4f": "Ybodychange",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "8be3896c7639f91d83ac220531cc5cbdc5a029d4": {
      "type": "Ybodychange",
      "commitMessage": "\nClean up global namespacing a bit, to make way for additional\nchecks.\nI\u0027m not quite sure if the change w/r/t \u0027declaration\u0027 and \u0027refs\u0027\nis an improvement or not--i think it will allow us to get rid\nof special cases down the line, but am not sure.\n\nR\u003dacleung\nDELTA\u003d117  (40 added, 9 deleted, 68 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d1542\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1031 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/25/11, 9:07 AM",
      "commitName": "8be3896c7639f91d83ac220531cc5cbdc5a029d4",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "4/12/11, 12:15 PM",
      "commitNameOld": "f322be0e576d5e2114cb59c0a6537197997b9c59",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 12.87,
      "commitsBetweenForRepo": 31,
      "commitsBetweenForFile": 1,
      "actualSource": "private void inlineAliases(GlobalNamespace namespace) {\n    Deque\u003cName\u003e workList \u003d new ArrayDeque\u003cName\u003e(namespace.getNameForest());\n    while (!workList.isEmpty()) {\n        Name name \u003d workList.pop();\n        if (name.type \u003d\u003d Name.Type.GET || name.type \u003d\u003d Name.Type.SET) {\n            continue;\n        }\n        if (name.globalSets \u003d\u003d 1 \u0026\u0026 name.localSets \u003d\u003d 0 \u0026\u0026 name.aliasingGets \u003e 0) {\n            List\u003cRef\u003e refs \u003d Lists.newArrayList(name.getRefs());\n            for (Ref ref : refs) {\n                if (ref.type \u003d\u003d Type.ALIASING_GET \u0026\u0026 ref.scope.isLocal()) {\n                    if (inlineAliasIfPossible(ref, namespace)) {\n                        name.removeRef(ref);\n                    }\n                }\n            }\n        }\n        if ((name.type \u003d\u003d Name.Type.OBJECTLIT || name.type \u003d\u003d Name.Type.FUNCTION) \u0026\u0026 name.aliasingGets \u003d\u003d 0 \u0026\u0026 name.props !\u003d null) {\n            workList.addAll(name.props);\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/CollapseProperties.java",
      "functionStartLine": 159,
      "functionName": "inlineAliases",
      "functionAnnotation": "",
      "functionDoc": "For each qualified name N in the global scope, we check if:\n(a) No ancestor of N is ever aliased or assigned an unknown value type.\n    (If N \u003d \"a.b.c\", \"a\" and \"a.b\" are never aliased).\n(b) N has exactly one write, and it lives in the global scope.\n(c) N is aliased in a local scope.\n\nIf (a) is true, then GlobalNamespace must know all the writes to N.\nIf (a) and (b) are true, then N cannot change during the execution of\n   a local scope.\nIf (a) and (b) and (c) are true, then the alias can be inlined if the\n   alias obeys the usual rules for how we decide whether a variable is\n   inlineable.\n\n@see InlineVariables\n",
      "diff": "@@ -1,22 +1,22 @@\n private void inlineAliases(GlobalNamespace namespace) {\n     Deque\u003cName\u003e workList \u003d new ArrayDeque\u003cName\u003e(namespace.getNameForest());\n     while (!workList.isEmpty()) {\n         Name name \u003d workList.pop();\n         if (name.type \u003d\u003d Name.Type.GET || name.type \u003d\u003d Name.Type.SET) {\n             continue;\n         }\n         if (name.globalSets \u003d\u003d 1 \u0026\u0026 name.localSets \u003d\u003d 0 \u0026\u0026 name.aliasingGets \u003e 0) {\n-            List\u003cRef\u003e refs \u003d Lists.newArrayList(name.refs);\n+            List\u003cRef\u003e refs \u003d Lists.newArrayList(name.getRefs());\n             for (Ref ref : refs) {\n                 if (ref.type \u003d\u003d Type.ALIASING_GET \u0026\u0026 ref.scope.isLocal()) {\n                     if (inlineAliasIfPossible(ref, namespace)) {\n                         name.removeRef(ref);\n                     }\n                 }\n             }\n         }\n         if ((name.type \u003d\u003d Name.Type.OBJECTLIT || name.type \u003d\u003d Name.Type.FUNCTION) \u0026\u0026 name.aliasingGets \u003d\u003d 0 \u0026\u0026 name.props !\u003d null) {\n             workList.addAll(name.props);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d68322323aa52d943b9dc5618ef8ea81d43d7b4f": {
      "type": "Ybodychange",
      "commitMessage": "\nUpdate the global namespace for get and set properties.\n\nR\u003dnicksantos\nDELTA\u003d117  (111 added, 0 deleted, 6 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d131\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@628 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "12/14/10, 8:19 AM",
      "commitName": "d68322323aa52d943b9dc5618ef8ea81d43d7b4f",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "12/3/10, 1:27 PM",
      "commitNameOld": "5e63746459b65c508dbeab01bebac3a4b89ef43a",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 10.79,
      "commitsBetweenForRepo": 36,
      "commitsBetweenForFile": 1,
      "actualSource": "private void inlineAliases(GlobalNamespace namespace) {\n    Deque\u003cName\u003e workList \u003d new ArrayDeque\u003cName\u003e(namespace.getNameForest());\n    while (!workList.isEmpty()) {\n        Name name \u003d workList.pop();\n        if (name.type \u003d\u003d Name.Type.GET || name.type \u003d\u003d Name.Type.SET) {\n            continue;\n        }\n        if (name.globalSets \u003d\u003d 1 \u0026\u0026 name.localSets \u003d\u003d 0 \u0026\u0026 name.aliasingGets \u003e 0) {\n            List\u003cRef\u003e refs \u003d Lists.newArrayList(name.refs);\n            for (Ref ref : refs) {\n                if (ref.type \u003d\u003d Type.ALIASING_GET \u0026\u0026 ref.scope.isLocal()) {\n                    if (inlineAliasIfPossible(ref, namespace)) {\n                        name.removeRef(ref);\n                    }\n                }\n            }\n        }\n        if ((name.type \u003d\u003d Name.Type.OBJECTLIT || name.type \u003d\u003d Name.Type.FUNCTION) \u0026\u0026 name.aliasingGets \u003d\u003d 0 \u0026\u0026 name.props !\u003d null) {\n            workList.addAll(name.props);\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/CollapseProperties.java",
      "functionStartLine": 159,
      "functionName": "inlineAliases",
      "functionAnnotation": "",
      "functionDoc": "For each qualified name N in the global scope, we check if:\n(a) No ancestor of N is ever aliased or assigned an unknown value type.\n    (If N \u003d \"a.b.c\", \"a\" and \"a.b\" are never aliased).\n(b) N has exactly one write, and it lives in the global scope.\n(c) N is aliased in a local scope.\n\nIf (a) is true, then GlobalNamespace must know all the writes to N.\nIf (a) and (b) are true, then N cannot change during the execution of\n   a local scope.\nIf (a) and (b) and (c) are true, then the alias can be inlined if the\n   alias obeys the usual rules for how we decide whether a variable is\n   inlineable.\n\n@see InlineVariables\n",
      "diff": "@@ -1,19 +1,22 @@\n private void inlineAliases(GlobalNamespace namespace) {\n     Deque\u003cName\u003e workList \u003d new ArrayDeque\u003cName\u003e(namespace.getNameForest());\n     while (!workList.isEmpty()) {\n         Name name \u003d workList.pop();\n+        if (name.type \u003d\u003d Name.Type.GET || name.type \u003d\u003d Name.Type.SET) {\n+            continue;\n+        }\n         if (name.globalSets \u003d\u003d 1 \u0026\u0026 name.localSets \u003d\u003d 0 \u0026\u0026 name.aliasingGets \u003e 0) {\n             List\u003cRef\u003e refs \u003d Lists.newArrayList(name.refs);\n             for (Ref ref : refs) {\n                 if (ref.type \u003d\u003d Type.ALIASING_GET \u0026\u0026 ref.scope.isLocal()) {\n                     if (inlineAliasIfPossible(ref, namespace)) {\n                         name.removeRef(ref);\n                     }\n                 }\n             }\n         }\n         if ((name.type \u003d\u003d Name.Type.OBJECTLIT || name.type \u003d\u003d Name.Type.FUNCTION) \u0026\u0026 name.aliasingGets \u003d\u003d 0 \u0026\u0026 name.props !\u003d null) {\n             workList.addAll(name.props);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": {
      "type": "Yintroduced",
      "commitMessage": "Initial commit.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/3/09, 3:51 PM",
      "commitName": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "diff": "@@ -0,0 +1,19 @@\n+private void inlineAliases(GlobalNamespace namespace) {\n+    Deque\u003cName\u003e workList \u003d new ArrayDeque\u003cName\u003e(namespace.getNameForest());\n+    while (!workList.isEmpty()) {\n+        Name name \u003d workList.pop();\n+        if (name.globalSets \u003d\u003d 1 \u0026\u0026 name.localSets \u003d\u003d 0 \u0026\u0026 name.aliasingGets \u003e 0) {\n+            List\u003cRef\u003e refs \u003d Lists.newArrayList(name.refs);\n+            for (Ref ref : refs) {\n+                if (ref.type \u003d\u003d Type.ALIASING_GET \u0026\u0026 ref.scope.isLocal()) {\n+                    if (inlineAliasIfPossible(ref, namespace)) {\n+                        name.removeRef(ref);\n+                    }\n+                }\n+            }\n+        }\n+        if ((name.type \u003d\u003d Name.Type.OBJECTLIT || name.type \u003d\u003d Name.Type.FUNCTION) \u0026\u0026 name.aliasingGets \u003d\u003d 0 \u0026\u0026 name.props !\u003d null) {\n+            workList.addAll(name.props);\n+        }\n+    }\n+}\n\\ No newline at end of file\n",
      "actualSource": "private void inlineAliases(GlobalNamespace namespace) {\n    Deque\u003cName\u003e workList \u003d new ArrayDeque\u003cName\u003e(namespace.getNameForest());\n    while (!workList.isEmpty()) {\n        Name name \u003d workList.pop();\n        if (name.globalSets \u003d\u003d 1 \u0026\u0026 name.localSets \u003d\u003d 0 \u0026\u0026 name.aliasingGets \u003e 0) {\n            List\u003cRef\u003e refs \u003d Lists.newArrayList(name.refs);\n            for (Ref ref : refs) {\n                if (ref.type \u003d\u003d Type.ALIASING_GET \u0026\u0026 ref.scope.isLocal()) {\n                    if (inlineAliasIfPossible(ref, namespace)) {\n                        name.removeRef(ref);\n                    }\n                }\n            }\n        }\n        if ((name.type \u003d\u003d Name.Type.OBJECTLIT || name.type \u003d\u003d Name.Type.FUNCTION) \u0026\u0026 name.aliasingGets \u003d\u003d 0 \u0026\u0026 name.props !\u003d null) {\n            workList.addAll(name.props);\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/CollapseProperties.java",
      "functionStartLine": 162,
      "functionName": "inlineAliases",
      "functionAnnotation": "",
      "functionDoc": "For each qualified name N in the global scope, we check if:\n(a) No ancestor of N is ever aliased or assigned an unknown value type.\n    (If N \u003d \"a.b.c\", \"a\" and \"a.b\" are never aliased).\n(b) N has exactly one write, and it lives in the global scope.\n(c) N is aliased in a local scope.\n\nIf (a) is true, then GlobalNamespace must know all the writes to N.\nIf (a) and (b) are true, then N cannot change during the execution of\n   a local scope.\nIf (a) and (b) and (c) are true, then the alias can be inlined if the\n   alias obeys the usual rules for how we decide whether a variable is\n   inlineable.\n\n@see InlineVariables\n"
    }
  }
}