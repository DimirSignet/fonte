{
  "origin": "codeshovel",
  "repositoryName": "Closure-60b",
  "repositoryPath": "/tmp/Closure-60b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "RemoveUnusedVars.java",
  "functionName": "removeUnreferencedVars",
  "functionId": "removeUnreferencedVars",
  "sourceFilePath": "src/com/google/javascript/jscomp/RemoveUnusedVars.java",
  "functionAnnotation": "",
  "functionDoc": "Removes any vars in the scope that were not referenced. Removes any\nassignments to those variables as well.\n",
  "functionStartLine": 779,
  "functionEndLine": 845,
  "numCommitsSeen": 49,
  "timeTaken": 2051,
  "changeHistory": [
    "6a30daa5450a77c66a704bc11a78d12b5e7eee31",
    "24507d99ee74582adac5ea3cd2d971679dd73567",
    "0d3b4994ebd199eb7dc76278c31656db9c2afb56",
    "747f2504d98e2d37c933ead6e40a0a1a1e36d6af",
    "833cd72a268c1161194038faf0d98ec6b1f203eb",
    "b2c12cd9f4284d58450d1a487e29d6b6a065105e",
    "ebb59a97610015bc41bda7f458dd1428a3a3e335",
    "14ddcfdc0b8d1cece3c79221b1870b84f055d419",
    "3bee5d740c96572faea4b9fb8b632e0e07b13cbb",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3"
  ],
  "changeHistoryShort": {
    "6a30daa5450a77c66a704bc11a78d12b5e7eee31": "Ymultichange(Ybodychange,Ydocchange)",
    "24507d99ee74582adac5ea3cd2d971679dd73567": "Ymultichange(Ybodychange,Ydocchange)",
    "0d3b4994ebd199eb7dc76278c31656db9c2afb56": "Ymultichange(Ybodychange,Ydocchange)",
    "747f2504d98e2d37c933ead6e40a0a1a1e36d6af": "Ymultichange(Yparameterchange,Ybodychange,Ydocchange)",
    "833cd72a268c1161194038faf0d98ec6b1f203eb": "Ybodychange",
    "b2c12cd9f4284d58450d1a487e29d6b6a065105e": "Ybodychange",
    "ebb59a97610015bc41bda7f458dd1428a3a3e335": "Ybodychange",
    "14ddcfdc0b8d1cece3c79221b1870b84f055d419": "Ybodychange",
    "3bee5d740c96572faea4b9fb8b632e0e07b13cbb": "Ybodychange",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "6a30daa5450a77c66a704bc11a78d12b5e7eee31": {
      "type": "Ymultichange(Ybodychange,Ydocchange)",
      "commitMessage": "\nMake RemoveUnusedVars know about goog.inherits (Attempt #2)\n\nR\u003dnicksantos\nDELTA\u003d153  (150 added, 0 deleted, 3 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d476\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@767 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "2/8/11, 2:27 PM",
      "commitName": "6a30daa5450a77c66a704bc11a78d12b5e7eee31",
      "commitAuthor": "agrieve@google.com",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "\nMake RemoveUnusedVars know about goog.inherits (Attempt #2)\n\nR\u003dnicksantos\nDELTA\u003d153  (150 added, 0 deleted, 3 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d476\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@767 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "2/8/11, 2:27 PM",
          "commitName": "6a30daa5450a77c66a704bc11a78d12b5e7eee31",
          "commitAuthor": "agrieve@google.com",
          "commitDateOld": "2/7/11, 10:20 AM",
          "commitNameOld": "24507d99ee74582adac5ea3cd2d971679dd73567",
          "commitAuthorOld": "agrieve@google.com",
          "daysBetweenCommits": 1.17,
          "commitsBetweenForRepo": 5,
          "commitsBetweenForFile": 1,
          "actualSource": "private void removeUnreferencedVars() {\n    CodingConvention convention \u003d codingConvention;\n    for (Iterator\u003cVar\u003e it \u003d maybeUnreferenced.iterator(); it.hasNext(); ) {\n        Var var \u003d it.next();\n        for (Node exprCallNode : inheritsCalls.get(var)) {\n            NodeUtil.removeChild(exprCallNode.getParent(), exprCallNode);\n            compiler.reportCodeChange();\n        }\n        removeAllAssigns(var);\n        compiler.addToDebugLog(\"Unreferenced var: \" + var.name);\n        Node nameNode \u003d var.nameNode;\n        Node toRemove \u003d nameNode.getParent();\n        Node parent \u003d toRemove.getParent();\n        Preconditions.checkState(toRemove.getType() \u003d\u003d Token.VAR || toRemove.getType() \u003d\u003d Token.FUNCTION || toRemove.getType() \u003d\u003d Token.LP \u0026\u0026 parent.getType() \u003d\u003d Token.FUNCTION, \"We should only declare vars and functions and function args\");\n        if (toRemove.getType() \u003d\u003d Token.LP \u0026\u0026 parent.getType() \u003d\u003d Token.FUNCTION) {\n        } else if (NodeUtil.isFunctionExpression(toRemove)) {\n            if (!preserveFunctionExpressionNames) {\n                toRemove.getFirstChild().setString(\"\");\n                compiler.reportCodeChange();\n            }\n        } else if (parent !\u003d null \u0026\u0026 parent.getType() \u003d\u003d Token.FOR \u0026\u0026 parent.getChildCount() \u003c 4) {\n        } else if (toRemove.getType() \u003d\u003d Token.VAR \u0026\u0026 nameNode.hasChildren() \u0026\u0026 NodeUtil.mayHaveSideEffects(nameNode.getFirstChild())) {\n            if (toRemove.getChildCount() \u003d\u003d 1) {\n                parent.replaceChild(toRemove, new Node(Token.EXPR_RESULT, nameNode.removeFirstChild()));\n                compiler.reportCodeChange();\n            }\n        } else if (toRemove.getType() \u003d\u003d Token.VAR \u0026\u0026 toRemove.getChildCount() \u003e 1) {\n            toRemove.removeChild(nameNode);\n            compiler.reportCodeChange();\n        } else if (parent !\u003d null) {\n            NodeUtil.removeChild(parent, toRemove);\n            compiler.reportCodeChange();\n        }\n    }\n}",
          "path": "src/com/google/javascript/jscomp/RemoveUnusedVars.java",
          "functionStartLine": 748,
          "functionName": "removeUnreferencedVars",
          "functionAnnotation": "",
          "functionDoc": "Removes any vars in the scope that were not referenced. Removes any\nassignments to those variables as well.\n",
          "diff": "@@ -1,31 +1,35 @@\n private void removeUnreferencedVars() {\n-    CodingConvention convention \u003d compiler.getCodingConvention();\n+    CodingConvention convention \u003d codingConvention;\n     for (Iterator\u003cVar\u003e it \u003d maybeUnreferenced.iterator(); it.hasNext(); ) {\n         Var var \u003d it.next();\n+        for (Node exprCallNode : inheritsCalls.get(var)) {\n+            NodeUtil.removeChild(exprCallNode.getParent(), exprCallNode);\n+            compiler.reportCodeChange();\n+        }\n         removeAllAssigns(var);\n         compiler.addToDebugLog(\"Unreferenced var: \" + var.name);\n         Node nameNode \u003d var.nameNode;\n         Node toRemove \u003d nameNode.getParent();\n         Node parent \u003d toRemove.getParent();\n         Preconditions.checkState(toRemove.getType() \u003d\u003d Token.VAR || toRemove.getType() \u003d\u003d Token.FUNCTION || toRemove.getType() \u003d\u003d Token.LP \u0026\u0026 parent.getType() \u003d\u003d Token.FUNCTION, \"We should only declare vars and functions and function args\");\n         if (toRemove.getType() \u003d\u003d Token.LP \u0026\u0026 parent.getType() \u003d\u003d Token.FUNCTION) {\n         } else if (NodeUtil.isFunctionExpression(toRemove)) {\n             if (!preserveFunctionExpressionNames) {\n                 toRemove.getFirstChild().setString(\"\");\n                 compiler.reportCodeChange();\n             }\n         } else if (parent !\u003d null \u0026\u0026 parent.getType() \u003d\u003d Token.FOR \u0026\u0026 parent.getChildCount() \u003c 4) {\n         } else if (toRemove.getType() \u003d\u003d Token.VAR \u0026\u0026 nameNode.hasChildren() \u0026\u0026 NodeUtil.mayHaveSideEffects(nameNode.getFirstChild())) {\n             if (toRemove.getChildCount() \u003d\u003d 1) {\n                 parent.replaceChild(toRemove, new Node(Token.EXPR_RESULT, nameNode.removeFirstChild()));\n                 compiler.reportCodeChange();\n             }\n         } else if (toRemove.getType() \u003d\u003d Token.VAR \u0026\u0026 toRemove.getChildCount() \u003e 1) {\n             toRemove.removeChild(nameNode);\n             compiler.reportCodeChange();\n         } else if (parent !\u003d null) {\n             NodeUtil.removeChild(parent, toRemove);\n             compiler.reportCodeChange();\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "\nMake RemoveUnusedVars know about goog.inherits (Attempt #2)\n\nR\u003dnicksantos\nDELTA\u003d153  (150 added, 0 deleted, 3 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d476\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@767 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "2/8/11, 2:27 PM",
          "commitName": "6a30daa5450a77c66a704bc11a78d12b5e7eee31",
          "commitAuthor": "agrieve@google.com",
          "commitDateOld": "2/7/11, 10:20 AM",
          "commitNameOld": "24507d99ee74582adac5ea3cd2d971679dd73567",
          "commitAuthorOld": "agrieve@google.com",
          "daysBetweenCommits": 1.17,
          "commitsBetweenForRepo": 5,
          "commitsBetweenForFile": 1,
          "actualSource": "private void removeUnreferencedVars() {\n    CodingConvention convention \u003d codingConvention;\n    for (Iterator\u003cVar\u003e it \u003d maybeUnreferenced.iterator(); it.hasNext(); ) {\n        Var var \u003d it.next();\n        for (Node exprCallNode : inheritsCalls.get(var)) {\n            NodeUtil.removeChild(exprCallNode.getParent(), exprCallNode);\n            compiler.reportCodeChange();\n        }\n        removeAllAssigns(var);\n        compiler.addToDebugLog(\"Unreferenced var: \" + var.name);\n        Node nameNode \u003d var.nameNode;\n        Node toRemove \u003d nameNode.getParent();\n        Node parent \u003d toRemove.getParent();\n        Preconditions.checkState(toRemove.getType() \u003d\u003d Token.VAR || toRemove.getType() \u003d\u003d Token.FUNCTION || toRemove.getType() \u003d\u003d Token.LP \u0026\u0026 parent.getType() \u003d\u003d Token.FUNCTION, \"We should only declare vars and functions and function args\");\n        if (toRemove.getType() \u003d\u003d Token.LP \u0026\u0026 parent.getType() \u003d\u003d Token.FUNCTION) {\n        } else if (NodeUtil.isFunctionExpression(toRemove)) {\n            if (!preserveFunctionExpressionNames) {\n                toRemove.getFirstChild().setString(\"\");\n                compiler.reportCodeChange();\n            }\n        } else if (parent !\u003d null \u0026\u0026 parent.getType() \u003d\u003d Token.FOR \u0026\u0026 parent.getChildCount() \u003c 4) {\n        } else if (toRemove.getType() \u003d\u003d Token.VAR \u0026\u0026 nameNode.hasChildren() \u0026\u0026 NodeUtil.mayHaveSideEffects(nameNode.getFirstChild())) {\n            if (toRemove.getChildCount() \u003d\u003d 1) {\n                parent.replaceChild(toRemove, new Node(Token.EXPR_RESULT, nameNode.removeFirstChild()));\n                compiler.reportCodeChange();\n            }\n        } else if (toRemove.getType() \u003d\u003d Token.VAR \u0026\u0026 toRemove.getChildCount() \u003e 1) {\n            toRemove.removeChild(nameNode);\n            compiler.reportCodeChange();\n        } else if (parent !\u003d null) {\n            NodeUtil.removeChild(parent, toRemove);\n            compiler.reportCodeChange();\n        }\n    }\n}",
          "path": "src/com/google/javascript/jscomp/RemoveUnusedVars.java",
          "functionStartLine": 748,
          "functionName": "removeUnreferencedVars",
          "functionAnnotation": "",
          "functionDoc": "Removes any vars in the scope that were not referenced. Removes any\nassignments to those variables as well.\n",
          "diff": "@@ -1,31 +1,35 @@\n private void removeUnreferencedVars() {\n-    CodingConvention convention \u003d compiler.getCodingConvention();\n+    CodingConvention convention \u003d codingConvention;\n     for (Iterator\u003cVar\u003e it \u003d maybeUnreferenced.iterator(); it.hasNext(); ) {\n         Var var \u003d it.next();\n+        for (Node exprCallNode : inheritsCalls.get(var)) {\n+            NodeUtil.removeChild(exprCallNode.getParent(), exprCallNode);\n+            compiler.reportCodeChange();\n+        }\n         removeAllAssigns(var);\n         compiler.addToDebugLog(\"Unreferenced var: \" + var.name);\n         Node nameNode \u003d var.nameNode;\n         Node toRemove \u003d nameNode.getParent();\n         Node parent \u003d toRemove.getParent();\n         Preconditions.checkState(toRemove.getType() \u003d\u003d Token.VAR || toRemove.getType() \u003d\u003d Token.FUNCTION || toRemove.getType() \u003d\u003d Token.LP \u0026\u0026 parent.getType() \u003d\u003d Token.FUNCTION, \"We should only declare vars and functions and function args\");\n         if (toRemove.getType() \u003d\u003d Token.LP \u0026\u0026 parent.getType() \u003d\u003d Token.FUNCTION) {\n         } else if (NodeUtil.isFunctionExpression(toRemove)) {\n             if (!preserveFunctionExpressionNames) {\n                 toRemove.getFirstChild().setString(\"\");\n                 compiler.reportCodeChange();\n             }\n         } else if (parent !\u003d null \u0026\u0026 parent.getType() \u003d\u003d Token.FOR \u0026\u0026 parent.getChildCount() \u003c 4) {\n         } else if (toRemove.getType() \u003d\u003d Token.VAR \u0026\u0026 nameNode.hasChildren() \u0026\u0026 NodeUtil.mayHaveSideEffects(nameNode.getFirstChild())) {\n             if (toRemove.getChildCount() \u003d\u003d 1) {\n                 parent.replaceChild(toRemove, new Node(Token.EXPR_RESULT, nameNode.removeFirstChild()));\n                 compiler.reportCodeChange();\n             }\n         } else if (toRemove.getType() \u003d\u003d Token.VAR \u0026\u0026 toRemove.getChildCount() \u003e 1) {\n             toRemove.removeChild(nameNode);\n             compiler.reportCodeChange();\n         } else if (parent !\u003d null) {\n             NodeUtil.removeChild(parent, toRemove);\n             compiler.reportCodeChange();\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Removes any vars in the scope that were not referenced. Removes any\nassigments to those variables as well.\n",
            "newValue": "Removes any vars in the scope that were not referenced. Removes any\nassignments to those variables as well.\n"
          }
        }
      ]
    },
    "24507d99ee74582adac5ea3cd2d971679dd73567": {
      "type": "Ymultichange(Ybodychange,Ydocchange)",
      "commitMessage": "\nAutomated g4 rollback.\n\n*** Reason for rollback ***\n\n-Broke gmail\n\n*** Original change description ***\n\n-Make RemoveUnusedVars know about goog.inherits\n\nR\u003dnicksantos\nDELTA\u003d135  (0 added, 132 deleted, 3 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d451\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@762 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "2/7/11, 10:20 AM",
      "commitName": "24507d99ee74582adac5ea3cd2d971679dd73567",
      "commitAuthor": "agrieve@google.com",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "\nAutomated g4 rollback.\n\n*** Reason for rollback ***\n\n-Broke gmail\n\n*** Original change description ***\n\n-Make RemoveUnusedVars know about goog.inherits\n\nR\u003dnicksantos\nDELTA\u003d135  (0 added, 132 deleted, 3 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d451\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@762 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "2/7/11, 10:20 AM",
          "commitName": "24507d99ee74582adac5ea3cd2d971679dd73567",
          "commitAuthor": "agrieve@google.com",
          "commitDateOld": "2/7/11, 9:18 AM",
          "commitNameOld": "0d3b4994ebd199eb7dc76278c31656db9c2afb56",
          "commitAuthorOld": "agrieve@google.com",
          "daysBetweenCommits": 0.04,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "private void removeUnreferencedVars() {\n    CodingConvention convention \u003d compiler.getCodingConvention();\n    for (Iterator\u003cVar\u003e it \u003d maybeUnreferenced.iterator(); it.hasNext(); ) {\n        Var var \u003d it.next();\n        removeAllAssigns(var);\n        compiler.addToDebugLog(\"Unreferenced var: \" + var.name);\n        Node nameNode \u003d var.nameNode;\n        Node toRemove \u003d nameNode.getParent();\n        Node parent \u003d toRemove.getParent();\n        Preconditions.checkState(toRemove.getType() \u003d\u003d Token.VAR || toRemove.getType() \u003d\u003d Token.FUNCTION || toRemove.getType() \u003d\u003d Token.LP \u0026\u0026 parent.getType() \u003d\u003d Token.FUNCTION, \"We should only declare vars and functions and function args\");\n        if (toRemove.getType() \u003d\u003d Token.LP \u0026\u0026 parent.getType() \u003d\u003d Token.FUNCTION) {\n        } else if (NodeUtil.isFunctionExpression(toRemove)) {\n            if (!preserveFunctionExpressionNames) {\n                toRemove.getFirstChild().setString(\"\");\n                compiler.reportCodeChange();\n            }\n        } else if (parent !\u003d null \u0026\u0026 parent.getType() \u003d\u003d Token.FOR \u0026\u0026 parent.getChildCount() \u003c 4) {\n        } else if (toRemove.getType() \u003d\u003d Token.VAR \u0026\u0026 nameNode.hasChildren() \u0026\u0026 NodeUtil.mayHaveSideEffects(nameNode.getFirstChild())) {\n            if (toRemove.getChildCount() \u003d\u003d 1) {\n                parent.replaceChild(toRemove, new Node(Token.EXPR_RESULT, nameNode.removeFirstChild()));\n                compiler.reportCodeChange();\n            }\n        } else if (toRemove.getType() \u003d\u003d Token.VAR \u0026\u0026 toRemove.getChildCount() \u003e 1) {\n            toRemove.removeChild(nameNode);\n            compiler.reportCodeChange();\n        } else if (parent !\u003d null) {\n            NodeUtil.removeChild(parent, toRemove);\n            compiler.reportCodeChange();\n        }\n    }\n}",
          "path": "src/com/google/javascript/jscomp/RemoveUnusedVars.java",
          "functionStartLine": 716,
          "functionName": "removeUnreferencedVars",
          "functionAnnotation": "",
          "functionDoc": "Removes any vars in the scope that were not referenced. Removes any\nassigments to those variables as well.\n",
          "diff": "@@ -1,35 +1,31 @@\n private void removeUnreferencedVars() {\n-    CodingConvention convention \u003d codingConvention;\n+    CodingConvention convention \u003d compiler.getCodingConvention();\n     for (Iterator\u003cVar\u003e it \u003d maybeUnreferenced.iterator(); it.hasNext(); ) {\n         Var var \u003d it.next();\n-        for (Node exprCallNode : inheritsCalls.get(var)) {\n-            NodeUtil.removeChild(exprCallNode.getParent(), exprCallNode);\n-            compiler.reportCodeChange();\n-        }\n         removeAllAssigns(var);\n         compiler.addToDebugLog(\"Unreferenced var: \" + var.name);\n         Node nameNode \u003d var.nameNode;\n         Node toRemove \u003d nameNode.getParent();\n         Node parent \u003d toRemove.getParent();\n         Preconditions.checkState(toRemove.getType() \u003d\u003d Token.VAR || toRemove.getType() \u003d\u003d Token.FUNCTION || toRemove.getType() \u003d\u003d Token.LP \u0026\u0026 parent.getType() \u003d\u003d Token.FUNCTION, \"We should only declare vars and functions and function args\");\n         if (toRemove.getType() \u003d\u003d Token.LP \u0026\u0026 parent.getType() \u003d\u003d Token.FUNCTION) {\n         } else if (NodeUtil.isFunctionExpression(toRemove)) {\n             if (!preserveFunctionExpressionNames) {\n                 toRemove.getFirstChild().setString(\"\");\n                 compiler.reportCodeChange();\n             }\n         } else if (parent !\u003d null \u0026\u0026 parent.getType() \u003d\u003d Token.FOR \u0026\u0026 parent.getChildCount() \u003c 4) {\n         } else if (toRemove.getType() \u003d\u003d Token.VAR \u0026\u0026 nameNode.hasChildren() \u0026\u0026 NodeUtil.mayHaveSideEffects(nameNode.getFirstChild())) {\n             if (toRemove.getChildCount() \u003d\u003d 1) {\n                 parent.replaceChild(toRemove, new Node(Token.EXPR_RESULT, nameNode.removeFirstChild()));\n                 compiler.reportCodeChange();\n             }\n         } else if (toRemove.getType() \u003d\u003d Token.VAR \u0026\u0026 toRemove.getChildCount() \u003e 1) {\n             toRemove.removeChild(nameNode);\n             compiler.reportCodeChange();\n         } else if (parent !\u003d null) {\n             NodeUtil.removeChild(parent, toRemove);\n             compiler.reportCodeChange();\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "\nAutomated g4 rollback.\n\n*** Reason for rollback ***\n\n-Broke gmail\n\n*** Original change description ***\n\n-Make RemoveUnusedVars know about goog.inherits\n\nR\u003dnicksantos\nDELTA\u003d135  (0 added, 132 deleted, 3 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d451\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@762 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "2/7/11, 10:20 AM",
          "commitName": "24507d99ee74582adac5ea3cd2d971679dd73567",
          "commitAuthor": "agrieve@google.com",
          "commitDateOld": "2/7/11, 9:18 AM",
          "commitNameOld": "0d3b4994ebd199eb7dc76278c31656db9c2afb56",
          "commitAuthorOld": "agrieve@google.com",
          "daysBetweenCommits": 0.04,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "private void removeUnreferencedVars() {\n    CodingConvention convention \u003d compiler.getCodingConvention();\n    for (Iterator\u003cVar\u003e it \u003d maybeUnreferenced.iterator(); it.hasNext(); ) {\n        Var var \u003d it.next();\n        removeAllAssigns(var);\n        compiler.addToDebugLog(\"Unreferenced var: \" + var.name);\n        Node nameNode \u003d var.nameNode;\n        Node toRemove \u003d nameNode.getParent();\n        Node parent \u003d toRemove.getParent();\n        Preconditions.checkState(toRemove.getType() \u003d\u003d Token.VAR || toRemove.getType() \u003d\u003d Token.FUNCTION || toRemove.getType() \u003d\u003d Token.LP \u0026\u0026 parent.getType() \u003d\u003d Token.FUNCTION, \"We should only declare vars and functions and function args\");\n        if (toRemove.getType() \u003d\u003d Token.LP \u0026\u0026 parent.getType() \u003d\u003d Token.FUNCTION) {\n        } else if (NodeUtil.isFunctionExpression(toRemove)) {\n            if (!preserveFunctionExpressionNames) {\n                toRemove.getFirstChild().setString(\"\");\n                compiler.reportCodeChange();\n            }\n        } else if (parent !\u003d null \u0026\u0026 parent.getType() \u003d\u003d Token.FOR \u0026\u0026 parent.getChildCount() \u003c 4) {\n        } else if (toRemove.getType() \u003d\u003d Token.VAR \u0026\u0026 nameNode.hasChildren() \u0026\u0026 NodeUtil.mayHaveSideEffects(nameNode.getFirstChild())) {\n            if (toRemove.getChildCount() \u003d\u003d 1) {\n                parent.replaceChild(toRemove, new Node(Token.EXPR_RESULT, nameNode.removeFirstChild()));\n                compiler.reportCodeChange();\n            }\n        } else if (toRemove.getType() \u003d\u003d Token.VAR \u0026\u0026 toRemove.getChildCount() \u003e 1) {\n            toRemove.removeChild(nameNode);\n            compiler.reportCodeChange();\n        } else if (parent !\u003d null) {\n            NodeUtil.removeChild(parent, toRemove);\n            compiler.reportCodeChange();\n        }\n    }\n}",
          "path": "src/com/google/javascript/jscomp/RemoveUnusedVars.java",
          "functionStartLine": 716,
          "functionName": "removeUnreferencedVars",
          "functionAnnotation": "",
          "functionDoc": "Removes any vars in the scope that were not referenced. Removes any\nassigments to those variables as well.\n",
          "diff": "@@ -1,35 +1,31 @@\n private void removeUnreferencedVars() {\n-    CodingConvention convention \u003d codingConvention;\n+    CodingConvention convention \u003d compiler.getCodingConvention();\n     for (Iterator\u003cVar\u003e it \u003d maybeUnreferenced.iterator(); it.hasNext(); ) {\n         Var var \u003d it.next();\n-        for (Node exprCallNode : inheritsCalls.get(var)) {\n-            NodeUtil.removeChild(exprCallNode.getParent(), exprCallNode);\n-            compiler.reportCodeChange();\n-        }\n         removeAllAssigns(var);\n         compiler.addToDebugLog(\"Unreferenced var: \" + var.name);\n         Node nameNode \u003d var.nameNode;\n         Node toRemove \u003d nameNode.getParent();\n         Node parent \u003d toRemove.getParent();\n         Preconditions.checkState(toRemove.getType() \u003d\u003d Token.VAR || toRemove.getType() \u003d\u003d Token.FUNCTION || toRemove.getType() \u003d\u003d Token.LP \u0026\u0026 parent.getType() \u003d\u003d Token.FUNCTION, \"We should only declare vars and functions and function args\");\n         if (toRemove.getType() \u003d\u003d Token.LP \u0026\u0026 parent.getType() \u003d\u003d Token.FUNCTION) {\n         } else if (NodeUtil.isFunctionExpression(toRemove)) {\n             if (!preserveFunctionExpressionNames) {\n                 toRemove.getFirstChild().setString(\"\");\n                 compiler.reportCodeChange();\n             }\n         } else if (parent !\u003d null \u0026\u0026 parent.getType() \u003d\u003d Token.FOR \u0026\u0026 parent.getChildCount() \u003c 4) {\n         } else if (toRemove.getType() \u003d\u003d Token.VAR \u0026\u0026 nameNode.hasChildren() \u0026\u0026 NodeUtil.mayHaveSideEffects(nameNode.getFirstChild())) {\n             if (toRemove.getChildCount() \u003d\u003d 1) {\n                 parent.replaceChild(toRemove, new Node(Token.EXPR_RESULT, nameNode.removeFirstChild()));\n                 compiler.reportCodeChange();\n             }\n         } else if (toRemove.getType() \u003d\u003d Token.VAR \u0026\u0026 toRemove.getChildCount() \u003e 1) {\n             toRemove.removeChild(nameNode);\n             compiler.reportCodeChange();\n         } else if (parent !\u003d null) {\n             NodeUtil.removeChild(parent, toRemove);\n             compiler.reportCodeChange();\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Removes any vars in the scope that were not referenced. Removes any\nassignments to those variables as well.\n",
            "newValue": "Removes any vars in the scope that were not referenced. Removes any\nassigments to those variables as well.\n"
          }
        }
      ]
    },
    "0d3b4994ebd199eb7dc76278c31656db9c2afb56": {
      "type": "Ymultichange(Ybodychange,Ydocchange)",
      "commitMessage": "\n-Make RemoveUnusedVars know about goog.inherits\n\nR\u003dnicksantos\nDELTA\u003d135  (132 added, 0 deleted, 3 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d449\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@760 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "2/7/11, 9:18 AM",
      "commitName": "0d3b4994ebd199eb7dc76278c31656db9c2afb56",
      "commitAuthor": "agrieve@google.com",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "\n-Make RemoveUnusedVars know about goog.inherits\n\nR\u003dnicksantos\nDELTA\u003d135  (132 added, 0 deleted, 3 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d449\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@760 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "2/7/11, 9:18 AM",
          "commitName": "0d3b4994ebd199eb7dc76278c31656db9c2afb56",
          "commitAuthor": "agrieve@google.com",
          "commitDateOld": "12/16/10, 12:17 PM",
          "commitNameOld": "81a77a269d5a9cd6b9baf34812b17fd22933b46e",
          "commitAuthorOld": "johnlenz@google.com",
          "daysBetweenCommits": 52.88,
          "commitsBetweenForRepo": 110,
          "commitsBetweenForFile": 1,
          "actualSource": "private void removeUnreferencedVars() {\n    CodingConvention convention \u003d codingConvention;\n    for (Iterator\u003cVar\u003e it \u003d maybeUnreferenced.iterator(); it.hasNext(); ) {\n        Var var \u003d it.next();\n        for (Node exprCallNode : inheritsCalls.get(var)) {\n            NodeUtil.removeChild(exprCallNode.getParent(), exprCallNode);\n            compiler.reportCodeChange();\n        }\n        removeAllAssigns(var);\n        compiler.addToDebugLog(\"Unreferenced var: \" + var.name);\n        Node nameNode \u003d var.nameNode;\n        Node toRemove \u003d nameNode.getParent();\n        Node parent \u003d toRemove.getParent();\n        Preconditions.checkState(toRemove.getType() \u003d\u003d Token.VAR || toRemove.getType() \u003d\u003d Token.FUNCTION || toRemove.getType() \u003d\u003d Token.LP \u0026\u0026 parent.getType() \u003d\u003d Token.FUNCTION, \"We should only declare vars and functions and function args\");\n        if (toRemove.getType() \u003d\u003d Token.LP \u0026\u0026 parent.getType() \u003d\u003d Token.FUNCTION) {\n        } else if (NodeUtil.isFunctionExpression(toRemove)) {\n            if (!preserveFunctionExpressionNames) {\n                toRemove.getFirstChild().setString(\"\");\n                compiler.reportCodeChange();\n            }\n        } else if (parent !\u003d null \u0026\u0026 parent.getType() \u003d\u003d Token.FOR \u0026\u0026 parent.getChildCount() \u003c 4) {\n        } else if (toRemove.getType() \u003d\u003d Token.VAR \u0026\u0026 nameNode.hasChildren() \u0026\u0026 NodeUtil.mayHaveSideEffects(nameNode.getFirstChild())) {\n            if (toRemove.getChildCount() \u003d\u003d 1) {\n                parent.replaceChild(toRemove, new Node(Token.EXPR_RESULT, nameNode.removeFirstChild()));\n                compiler.reportCodeChange();\n            }\n        } else if (toRemove.getType() \u003d\u003d Token.VAR \u0026\u0026 toRemove.getChildCount() \u003e 1) {\n            toRemove.removeChild(nameNode);\n            compiler.reportCodeChange();\n        } else if (parent !\u003d null) {\n            NodeUtil.removeChild(parent, toRemove);\n            compiler.reportCodeChange();\n        }\n    }\n}",
          "path": "src/com/google/javascript/jscomp/RemoveUnusedVars.java",
          "functionStartLine": 744,
          "functionName": "removeUnreferencedVars",
          "functionAnnotation": "",
          "functionDoc": "Removes any vars in the scope that were not referenced. Removes any\nassignments to those variables as well.\n",
          "diff": "@@ -1,31 +1,35 @@\n private void removeUnreferencedVars() {\n-    CodingConvention convention \u003d compiler.getCodingConvention();\n+    CodingConvention convention \u003d codingConvention;\n     for (Iterator\u003cVar\u003e it \u003d maybeUnreferenced.iterator(); it.hasNext(); ) {\n         Var var \u003d it.next();\n+        for (Node exprCallNode : inheritsCalls.get(var)) {\n+            NodeUtil.removeChild(exprCallNode.getParent(), exprCallNode);\n+            compiler.reportCodeChange();\n+        }\n         removeAllAssigns(var);\n         compiler.addToDebugLog(\"Unreferenced var: \" + var.name);\n         Node nameNode \u003d var.nameNode;\n         Node toRemove \u003d nameNode.getParent();\n         Node parent \u003d toRemove.getParent();\n         Preconditions.checkState(toRemove.getType() \u003d\u003d Token.VAR || toRemove.getType() \u003d\u003d Token.FUNCTION || toRemove.getType() \u003d\u003d Token.LP \u0026\u0026 parent.getType() \u003d\u003d Token.FUNCTION, \"We should only declare vars and functions and function args\");\n         if (toRemove.getType() \u003d\u003d Token.LP \u0026\u0026 parent.getType() \u003d\u003d Token.FUNCTION) {\n         } else if (NodeUtil.isFunctionExpression(toRemove)) {\n             if (!preserveFunctionExpressionNames) {\n                 toRemove.getFirstChild().setString(\"\");\n                 compiler.reportCodeChange();\n             }\n         } else if (parent !\u003d null \u0026\u0026 parent.getType() \u003d\u003d Token.FOR \u0026\u0026 parent.getChildCount() \u003c 4) {\n         } else if (toRemove.getType() \u003d\u003d Token.VAR \u0026\u0026 nameNode.hasChildren() \u0026\u0026 NodeUtil.mayHaveSideEffects(nameNode.getFirstChild())) {\n             if (toRemove.getChildCount() \u003d\u003d 1) {\n                 parent.replaceChild(toRemove, new Node(Token.EXPR_RESULT, nameNode.removeFirstChild()));\n                 compiler.reportCodeChange();\n             }\n         } else if (toRemove.getType() \u003d\u003d Token.VAR \u0026\u0026 toRemove.getChildCount() \u003e 1) {\n             toRemove.removeChild(nameNode);\n             compiler.reportCodeChange();\n         } else if (parent !\u003d null) {\n             NodeUtil.removeChild(parent, toRemove);\n             compiler.reportCodeChange();\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "\n-Make RemoveUnusedVars know about goog.inherits\n\nR\u003dnicksantos\nDELTA\u003d135  (132 added, 0 deleted, 3 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d449\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@760 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "2/7/11, 9:18 AM",
          "commitName": "0d3b4994ebd199eb7dc76278c31656db9c2afb56",
          "commitAuthor": "agrieve@google.com",
          "commitDateOld": "12/16/10, 12:17 PM",
          "commitNameOld": "81a77a269d5a9cd6b9baf34812b17fd22933b46e",
          "commitAuthorOld": "johnlenz@google.com",
          "daysBetweenCommits": 52.88,
          "commitsBetweenForRepo": 110,
          "commitsBetweenForFile": 1,
          "actualSource": "private void removeUnreferencedVars() {\n    CodingConvention convention \u003d codingConvention;\n    for (Iterator\u003cVar\u003e it \u003d maybeUnreferenced.iterator(); it.hasNext(); ) {\n        Var var \u003d it.next();\n        for (Node exprCallNode : inheritsCalls.get(var)) {\n            NodeUtil.removeChild(exprCallNode.getParent(), exprCallNode);\n            compiler.reportCodeChange();\n        }\n        removeAllAssigns(var);\n        compiler.addToDebugLog(\"Unreferenced var: \" + var.name);\n        Node nameNode \u003d var.nameNode;\n        Node toRemove \u003d nameNode.getParent();\n        Node parent \u003d toRemove.getParent();\n        Preconditions.checkState(toRemove.getType() \u003d\u003d Token.VAR || toRemove.getType() \u003d\u003d Token.FUNCTION || toRemove.getType() \u003d\u003d Token.LP \u0026\u0026 parent.getType() \u003d\u003d Token.FUNCTION, \"We should only declare vars and functions and function args\");\n        if (toRemove.getType() \u003d\u003d Token.LP \u0026\u0026 parent.getType() \u003d\u003d Token.FUNCTION) {\n        } else if (NodeUtil.isFunctionExpression(toRemove)) {\n            if (!preserveFunctionExpressionNames) {\n                toRemove.getFirstChild().setString(\"\");\n                compiler.reportCodeChange();\n            }\n        } else if (parent !\u003d null \u0026\u0026 parent.getType() \u003d\u003d Token.FOR \u0026\u0026 parent.getChildCount() \u003c 4) {\n        } else if (toRemove.getType() \u003d\u003d Token.VAR \u0026\u0026 nameNode.hasChildren() \u0026\u0026 NodeUtil.mayHaveSideEffects(nameNode.getFirstChild())) {\n            if (toRemove.getChildCount() \u003d\u003d 1) {\n                parent.replaceChild(toRemove, new Node(Token.EXPR_RESULT, nameNode.removeFirstChild()));\n                compiler.reportCodeChange();\n            }\n        } else if (toRemove.getType() \u003d\u003d Token.VAR \u0026\u0026 toRemove.getChildCount() \u003e 1) {\n            toRemove.removeChild(nameNode);\n            compiler.reportCodeChange();\n        } else if (parent !\u003d null) {\n            NodeUtil.removeChild(parent, toRemove);\n            compiler.reportCodeChange();\n        }\n    }\n}",
          "path": "src/com/google/javascript/jscomp/RemoveUnusedVars.java",
          "functionStartLine": 744,
          "functionName": "removeUnreferencedVars",
          "functionAnnotation": "",
          "functionDoc": "Removes any vars in the scope that were not referenced. Removes any\nassignments to those variables as well.\n",
          "diff": "@@ -1,31 +1,35 @@\n private void removeUnreferencedVars() {\n-    CodingConvention convention \u003d compiler.getCodingConvention();\n+    CodingConvention convention \u003d codingConvention;\n     for (Iterator\u003cVar\u003e it \u003d maybeUnreferenced.iterator(); it.hasNext(); ) {\n         Var var \u003d it.next();\n+        for (Node exprCallNode : inheritsCalls.get(var)) {\n+            NodeUtil.removeChild(exprCallNode.getParent(), exprCallNode);\n+            compiler.reportCodeChange();\n+        }\n         removeAllAssigns(var);\n         compiler.addToDebugLog(\"Unreferenced var: \" + var.name);\n         Node nameNode \u003d var.nameNode;\n         Node toRemove \u003d nameNode.getParent();\n         Node parent \u003d toRemove.getParent();\n         Preconditions.checkState(toRemove.getType() \u003d\u003d Token.VAR || toRemove.getType() \u003d\u003d Token.FUNCTION || toRemove.getType() \u003d\u003d Token.LP \u0026\u0026 parent.getType() \u003d\u003d Token.FUNCTION, \"We should only declare vars and functions and function args\");\n         if (toRemove.getType() \u003d\u003d Token.LP \u0026\u0026 parent.getType() \u003d\u003d Token.FUNCTION) {\n         } else if (NodeUtil.isFunctionExpression(toRemove)) {\n             if (!preserveFunctionExpressionNames) {\n                 toRemove.getFirstChild().setString(\"\");\n                 compiler.reportCodeChange();\n             }\n         } else if (parent !\u003d null \u0026\u0026 parent.getType() \u003d\u003d Token.FOR \u0026\u0026 parent.getChildCount() \u003c 4) {\n         } else if (toRemove.getType() \u003d\u003d Token.VAR \u0026\u0026 nameNode.hasChildren() \u0026\u0026 NodeUtil.mayHaveSideEffects(nameNode.getFirstChild())) {\n             if (toRemove.getChildCount() \u003d\u003d 1) {\n                 parent.replaceChild(toRemove, new Node(Token.EXPR_RESULT, nameNode.removeFirstChild()));\n                 compiler.reportCodeChange();\n             }\n         } else if (toRemove.getType() \u003d\u003d Token.VAR \u0026\u0026 toRemove.getChildCount() \u003e 1) {\n             toRemove.removeChild(nameNode);\n             compiler.reportCodeChange();\n         } else if (parent !\u003d null) {\n             NodeUtil.removeChild(parent, toRemove);\n             compiler.reportCodeChange();\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Removes any vars in the scope that were not referenced. Removes any\nassigments to those variables as well.\n",
            "newValue": "Removes any vars in the scope that were not referenced. Removes any\nassignments to those variables as well.\n"
          }
        }
      ]
    },
    "747f2504d98e2d37c933ead6e40a0a1a1e36d6af": {
      "type": "Ymultichange(Yparameterchange,Ybodychange,Ydocchange)",
      "commitMessage": "\nChange on 2010/08/04 13:06:31 by nicksantos\n\n\tA new var-collection mechanism for RemoveUnusedVars.  In the\n\tnew mechanism, we only traverse a subtree for references if it\n\tmight have side-effects, or if its return value is used.  If\n\tits return value is stored in a variable, then we store a\n\tcontinuation, and execute the continuation iff that variable\n\tis referenced.\n\n\tThis is a more general formulation of RemoveUnusedVars\u0027s current\n\tstrategy (\"traverse a function iff it\u0027s referenced\").\n\n\tR\u003dacleung\n\tDELTA\u003d560  (326 added, 63 deleted, 171 changed)\n\nChange on 2010/08/04 13:09:34 by rjfioravanti\n\n\tCreating externs for CSSMatrix and WebKitCSSMatrix.\n\n\tBased on documentation from the following locations:\n\thttp://www.w3.org/TR/css3-3d-transforms/#cssmatrix-interface\n\thttp://developer.apple.com/safari/library/documentation/AudioVideo/Reference/WebKitCSSMatrixClassReference/WebKitCSSMatrix/WebKitCSSMatrix.html#//apple_ref/javascript/instm/WebKitCSSMatrix/setMatrixValue\n\n\tR\u003dnicksantos\n\tDELTA\u003d193  (193 added, 0 deleted, 0 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d90012\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@335 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "8/4/10, 5:48 PM",
      "commitName": "747f2504d98e2d37c933ead6e40a0a1a1e36d6af",
      "commitAuthor": "Nicholas.J.Santos",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "\nChange on 2010/08/04 13:06:31 by nicksantos\n\n\tA new var-collection mechanism for RemoveUnusedVars.  In the\n\tnew mechanism, we only traverse a subtree for references if it\n\tmight have side-effects, or if its return value is used.  If\n\tits return value is stored in a variable, then we store a\n\tcontinuation, and execute the continuation iff that variable\n\tis referenced.\n\n\tThis is a more general formulation of RemoveUnusedVars\u0027s current\n\tstrategy (\"traverse a function iff it\u0027s referenced\").\n\n\tR\u003dacleung\n\tDELTA\u003d560  (326 added, 63 deleted, 171 changed)\n\nChange on 2010/08/04 13:09:34 by rjfioravanti\n\n\tCreating externs for CSSMatrix and WebKitCSSMatrix.\n\n\tBased on documentation from the following locations:\n\thttp://www.w3.org/TR/css3-3d-transforms/#cssmatrix-interface\n\thttp://developer.apple.com/safari/library/documentation/AudioVideo/Reference/WebKitCSSMatrixClassReference/WebKitCSSMatrix/WebKitCSSMatrix.html#//apple_ref/javascript/instm/WebKitCSSMatrix/setMatrixValue\n\n\tR\u003dnicksantos\n\tDELTA\u003d193  (193 added, 0 deleted, 0 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d90012\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@335 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "8/4/10, 5:48 PM",
          "commitName": "747f2504d98e2d37c933ead6e40a0a1a1e36d6af",
          "commitAuthor": "Nicholas.J.Santos",
          "commitDateOld": "7/23/10, 2:49 PM",
          "commitNameOld": "f0362b1ab1ae1339e017b1d04f016980e3fa6cb6",
          "commitAuthorOld": "nicksantos@google.com",
          "daysBetweenCommits": 12.12,
          "commitsBetweenForRepo": 26,
          "commitsBetweenForFile": 1,
          "actualSource": "private void removeUnreferencedVars() {\n    CodingConvention convention \u003d compiler.getCodingConvention();\n    for (Iterator\u003cVar\u003e it \u003d maybeUnreferenced.iterator(); it.hasNext(); ) {\n        Var var \u003d it.next();\n        removeAllAssigns(var);\n        compiler.addToDebugLog(\"Unreferenced var: \" + var.name);\n        Node nameNode \u003d var.nameNode;\n        Node toRemove \u003d nameNode.getParent();\n        Node parent \u003d toRemove.getParent();\n        Preconditions.checkState(toRemove.getType() \u003d\u003d Token.VAR || toRemove.getType() \u003d\u003d Token.FUNCTION || toRemove.getType() \u003d\u003d Token.LP \u0026\u0026 parent.getType() \u003d\u003d Token.FUNCTION, \"We should only declare vars and functions and function args\");\n        if (toRemove.getType() \u003d\u003d Token.LP \u0026\u0026 parent.getType() \u003d\u003d Token.FUNCTION) {\n        } else if (NodeUtil.isFunctionExpression(toRemove)) {\n            if (!preserveFunctionExpressionNames) {\n                toRemove.getFirstChild().setString(\"\");\n                compiler.reportCodeChange();\n            }\n        } else if (parent !\u003d null \u0026\u0026 parent.getType() \u003d\u003d Token.FOR \u0026\u0026 parent.getChildCount() \u003c 4) {\n        } else if (toRemove.getType() \u003d\u003d Token.VAR \u0026\u0026 nameNode.hasChildren() \u0026\u0026 NodeUtil.mayHaveSideEffects(nameNode.getFirstChild())) {\n            if (toRemove.getChildCount() \u003d\u003d 1) {\n                parent.replaceChild(toRemove, new Node(Token.EXPR_RESULT, nameNode.removeFirstChild()));\n                compiler.reportCodeChange();\n            }\n        } else if (toRemove.getType() \u003d\u003d Token.VAR \u0026\u0026 toRemove.getChildCount() \u003e 1) {\n            toRemove.removeChild(nameNode);\n            compiler.reportCodeChange();\n        } else if (parent !\u003d null) {\n            NodeUtil.removeChild(parent, toRemove);\n            compiler.reportCodeChange();\n        }\n    }\n}",
          "path": "src/com/google/javascript/jscomp/RemoveUnusedVars.java",
          "functionStartLine": 410,
          "functionName": "removeUnreferencedVars",
          "functionAnnotation": "",
          "functionDoc": "Removes any vars in the scope that were not referenced. Removes any\nassigments to those variables as well.\n",
          "diff": "@@ -1,32 +1,31 @@\n-private void removeUnreferencedVars(Scope scope) {\n+private void removeUnreferencedVars() {\n     CodingConvention convention \u003d compiler.getCodingConvention();\n-    for (Iterator\u003cVar\u003e it \u003d scope.getVars(); it.hasNext(); ) {\n+    for (Iterator\u003cVar\u003e it \u003d maybeUnreferenced.iterator(); it.hasNext(); ) {\n         Var var \u003d it.next();\n-        if (!referenced.contains(var) \u0026\u0026 (var.isLocal() || !convention.isExported(var.name))) {\n-            compiler.addToDebugLog(\"Unreferenced var: \" + var.name);\n-            Node nameNode \u003d var.nameNode;\n-            Node toRemove \u003d nameNode.getParent();\n-            Node parent \u003d toRemove.getParent();\n-            Preconditions.checkState(toRemove.getType() \u003d\u003d Token.VAR || toRemove.getType() \u003d\u003d Token.FUNCTION || toRemove.getType() \u003d\u003d Token.LP \u0026\u0026 parent.getType() \u003d\u003d Token.FUNCTION, \"We should only declare vars and functions and function args\");\n-            if (toRemove.getType() \u003d\u003d Token.LP \u0026\u0026 parent.getType() \u003d\u003d Token.FUNCTION) {\n-            } else if (NodeUtil.isFunctionExpression(toRemove)) {\n-                if (!preserveFunctionExpressionNames) {\n-                    toRemove.getFirstChild().setString(\"\");\n-                    finishRemove(var);\n-                }\n-            } else if (parent !\u003d null \u0026\u0026 parent.getType() \u003d\u003d Token.FOR \u0026\u0026 parent.getChildCount() \u003c 4) {\n-            } else if (toRemove.getType() \u003d\u003d Token.VAR \u0026\u0026 nameNode.hasChildren() \u0026\u0026 NodeUtil.mayHaveSideEffects(nameNode.getFirstChild())) {\n-                if (toRemove.getChildCount() \u003d\u003d 1) {\n-                    parent.replaceChild(toRemove, new Node(Token.EXPR_RESULT, nameNode.removeFirstChild()));\n-                    finishRemove(var);\n-                }\n-            } else if (toRemove.getType() \u003d\u003d Token.VAR \u0026\u0026 toRemove.getChildCount() \u003e 1) {\n-                toRemove.removeChild(nameNode);\n-                finishRemove(var);\n-            } else if (parent !\u003d null) {\n-                NodeUtil.removeChild(parent, toRemove);\n-                finishRemove(var);\n+        removeAllAssigns(var);\n+        compiler.addToDebugLog(\"Unreferenced var: \" + var.name);\n+        Node nameNode \u003d var.nameNode;\n+        Node toRemove \u003d nameNode.getParent();\n+        Node parent \u003d toRemove.getParent();\n+        Preconditions.checkState(toRemove.getType() \u003d\u003d Token.VAR || toRemove.getType() \u003d\u003d Token.FUNCTION || toRemove.getType() \u003d\u003d Token.LP \u0026\u0026 parent.getType() \u003d\u003d Token.FUNCTION, \"We should only declare vars and functions and function args\");\n+        if (toRemove.getType() \u003d\u003d Token.LP \u0026\u0026 parent.getType() \u003d\u003d Token.FUNCTION) {\n+        } else if (NodeUtil.isFunctionExpression(toRemove)) {\n+            if (!preserveFunctionExpressionNames) {\n+                toRemove.getFirstChild().setString(\"\");\n+                compiler.reportCodeChange();\n             }\n+        } else if (parent !\u003d null \u0026\u0026 parent.getType() \u003d\u003d Token.FOR \u0026\u0026 parent.getChildCount() \u003c 4) {\n+        } else if (toRemove.getType() \u003d\u003d Token.VAR \u0026\u0026 nameNode.hasChildren() \u0026\u0026 NodeUtil.mayHaveSideEffects(nameNode.getFirstChild())) {\n+            if (toRemove.getChildCount() \u003d\u003d 1) {\n+                parent.replaceChild(toRemove, new Node(Token.EXPR_RESULT, nameNode.removeFirstChild()));\n+                compiler.reportCodeChange();\n+            }\n+        } else if (toRemove.getType() \u003d\u003d Token.VAR \u0026\u0026 toRemove.getChildCount() \u003e 1) {\n+            toRemove.removeChild(nameNode);\n+            compiler.reportCodeChange();\n+        } else if (parent !\u003d null) {\n+            NodeUtil.removeChild(parent, toRemove);\n+            compiler.reportCodeChange();\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[scope-Scope]",
            "newValue": "[]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "\nChange on 2010/08/04 13:06:31 by nicksantos\n\n\tA new var-collection mechanism for RemoveUnusedVars.  In the\n\tnew mechanism, we only traverse a subtree for references if it\n\tmight have side-effects, or if its return value is used.  If\n\tits return value is stored in a variable, then we store a\n\tcontinuation, and execute the continuation iff that variable\n\tis referenced.\n\n\tThis is a more general formulation of RemoveUnusedVars\u0027s current\n\tstrategy (\"traverse a function iff it\u0027s referenced\").\n\n\tR\u003dacleung\n\tDELTA\u003d560  (326 added, 63 deleted, 171 changed)\n\nChange on 2010/08/04 13:09:34 by rjfioravanti\n\n\tCreating externs for CSSMatrix and WebKitCSSMatrix.\n\n\tBased on documentation from the following locations:\n\thttp://www.w3.org/TR/css3-3d-transforms/#cssmatrix-interface\n\thttp://developer.apple.com/safari/library/documentation/AudioVideo/Reference/WebKitCSSMatrixClassReference/WebKitCSSMatrix/WebKitCSSMatrix.html#//apple_ref/javascript/instm/WebKitCSSMatrix/setMatrixValue\n\n\tR\u003dnicksantos\n\tDELTA\u003d193  (193 added, 0 deleted, 0 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d90012\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@335 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "8/4/10, 5:48 PM",
          "commitName": "747f2504d98e2d37c933ead6e40a0a1a1e36d6af",
          "commitAuthor": "Nicholas.J.Santos",
          "commitDateOld": "7/23/10, 2:49 PM",
          "commitNameOld": "f0362b1ab1ae1339e017b1d04f016980e3fa6cb6",
          "commitAuthorOld": "nicksantos@google.com",
          "daysBetweenCommits": 12.12,
          "commitsBetweenForRepo": 26,
          "commitsBetweenForFile": 1,
          "actualSource": "private void removeUnreferencedVars() {\n    CodingConvention convention \u003d compiler.getCodingConvention();\n    for (Iterator\u003cVar\u003e it \u003d maybeUnreferenced.iterator(); it.hasNext(); ) {\n        Var var \u003d it.next();\n        removeAllAssigns(var);\n        compiler.addToDebugLog(\"Unreferenced var: \" + var.name);\n        Node nameNode \u003d var.nameNode;\n        Node toRemove \u003d nameNode.getParent();\n        Node parent \u003d toRemove.getParent();\n        Preconditions.checkState(toRemove.getType() \u003d\u003d Token.VAR || toRemove.getType() \u003d\u003d Token.FUNCTION || toRemove.getType() \u003d\u003d Token.LP \u0026\u0026 parent.getType() \u003d\u003d Token.FUNCTION, \"We should only declare vars and functions and function args\");\n        if (toRemove.getType() \u003d\u003d Token.LP \u0026\u0026 parent.getType() \u003d\u003d Token.FUNCTION) {\n        } else if (NodeUtil.isFunctionExpression(toRemove)) {\n            if (!preserveFunctionExpressionNames) {\n                toRemove.getFirstChild().setString(\"\");\n                compiler.reportCodeChange();\n            }\n        } else if (parent !\u003d null \u0026\u0026 parent.getType() \u003d\u003d Token.FOR \u0026\u0026 parent.getChildCount() \u003c 4) {\n        } else if (toRemove.getType() \u003d\u003d Token.VAR \u0026\u0026 nameNode.hasChildren() \u0026\u0026 NodeUtil.mayHaveSideEffects(nameNode.getFirstChild())) {\n            if (toRemove.getChildCount() \u003d\u003d 1) {\n                parent.replaceChild(toRemove, new Node(Token.EXPR_RESULT, nameNode.removeFirstChild()));\n                compiler.reportCodeChange();\n            }\n        } else if (toRemove.getType() \u003d\u003d Token.VAR \u0026\u0026 toRemove.getChildCount() \u003e 1) {\n            toRemove.removeChild(nameNode);\n            compiler.reportCodeChange();\n        } else if (parent !\u003d null) {\n            NodeUtil.removeChild(parent, toRemove);\n            compiler.reportCodeChange();\n        }\n    }\n}",
          "path": "src/com/google/javascript/jscomp/RemoveUnusedVars.java",
          "functionStartLine": 410,
          "functionName": "removeUnreferencedVars",
          "functionAnnotation": "",
          "functionDoc": "Removes any vars in the scope that were not referenced. Removes any\nassigments to those variables as well.\n",
          "diff": "@@ -1,32 +1,31 @@\n-private void removeUnreferencedVars(Scope scope) {\n+private void removeUnreferencedVars() {\n     CodingConvention convention \u003d compiler.getCodingConvention();\n-    for (Iterator\u003cVar\u003e it \u003d scope.getVars(); it.hasNext(); ) {\n+    for (Iterator\u003cVar\u003e it \u003d maybeUnreferenced.iterator(); it.hasNext(); ) {\n         Var var \u003d it.next();\n-        if (!referenced.contains(var) \u0026\u0026 (var.isLocal() || !convention.isExported(var.name))) {\n-            compiler.addToDebugLog(\"Unreferenced var: \" + var.name);\n-            Node nameNode \u003d var.nameNode;\n-            Node toRemove \u003d nameNode.getParent();\n-            Node parent \u003d toRemove.getParent();\n-            Preconditions.checkState(toRemove.getType() \u003d\u003d Token.VAR || toRemove.getType() \u003d\u003d Token.FUNCTION || toRemove.getType() \u003d\u003d Token.LP \u0026\u0026 parent.getType() \u003d\u003d Token.FUNCTION, \"We should only declare vars and functions and function args\");\n-            if (toRemove.getType() \u003d\u003d Token.LP \u0026\u0026 parent.getType() \u003d\u003d Token.FUNCTION) {\n-            } else if (NodeUtil.isFunctionExpression(toRemove)) {\n-                if (!preserveFunctionExpressionNames) {\n-                    toRemove.getFirstChild().setString(\"\");\n-                    finishRemove(var);\n-                }\n-            } else if (parent !\u003d null \u0026\u0026 parent.getType() \u003d\u003d Token.FOR \u0026\u0026 parent.getChildCount() \u003c 4) {\n-            } else if (toRemove.getType() \u003d\u003d Token.VAR \u0026\u0026 nameNode.hasChildren() \u0026\u0026 NodeUtil.mayHaveSideEffects(nameNode.getFirstChild())) {\n-                if (toRemove.getChildCount() \u003d\u003d 1) {\n-                    parent.replaceChild(toRemove, new Node(Token.EXPR_RESULT, nameNode.removeFirstChild()));\n-                    finishRemove(var);\n-                }\n-            } else if (toRemove.getType() \u003d\u003d Token.VAR \u0026\u0026 toRemove.getChildCount() \u003e 1) {\n-                toRemove.removeChild(nameNode);\n-                finishRemove(var);\n-            } else if (parent !\u003d null) {\n-                NodeUtil.removeChild(parent, toRemove);\n-                finishRemove(var);\n+        removeAllAssigns(var);\n+        compiler.addToDebugLog(\"Unreferenced var: \" + var.name);\n+        Node nameNode \u003d var.nameNode;\n+        Node toRemove \u003d nameNode.getParent();\n+        Node parent \u003d toRemove.getParent();\n+        Preconditions.checkState(toRemove.getType() \u003d\u003d Token.VAR || toRemove.getType() \u003d\u003d Token.FUNCTION || toRemove.getType() \u003d\u003d Token.LP \u0026\u0026 parent.getType() \u003d\u003d Token.FUNCTION, \"We should only declare vars and functions and function args\");\n+        if (toRemove.getType() \u003d\u003d Token.LP \u0026\u0026 parent.getType() \u003d\u003d Token.FUNCTION) {\n+        } else if (NodeUtil.isFunctionExpression(toRemove)) {\n+            if (!preserveFunctionExpressionNames) {\n+                toRemove.getFirstChild().setString(\"\");\n+                compiler.reportCodeChange();\n             }\n+        } else if (parent !\u003d null \u0026\u0026 parent.getType() \u003d\u003d Token.FOR \u0026\u0026 parent.getChildCount() \u003c 4) {\n+        } else if (toRemove.getType() \u003d\u003d Token.VAR \u0026\u0026 nameNode.hasChildren() \u0026\u0026 NodeUtil.mayHaveSideEffects(nameNode.getFirstChild())) {\n+            if (toRemove.getChildCount() \u003d\u003d 1) {\n+                parent.replaceChild(toRemove, new Node(Token.EXPR_RESULT, nameNode.removeFirstChild()));\n+                compiler.reportCodeChange();\n+            }\n+        } else if (toRemove.getType() \u003d\u003d Token.VAR \u0026\u0026 toRemove.getChildCount() \u003e 1) {\n+            toRemove.removeChild(nameNode);\n+            compiler.reportCodeChange();\n+        } else if (parent !\u003d null) {\n+            NodeUtil.removeChild(parent, toRemove);\n+            compiler.reportCodeChange();\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "\nChange on 2010/08/04 13:06:31 by nicksantos\n\n\tA new var-collection mechanism for RemoveUnusedVars.  In the\n\tnew mechanism, we only traverse a subtree for references if it\n\tmight have side-effects, or if its return value is used.  If\n\tits return value is stored in a variable, then we store a\n\tcontinuation, and execute the continuation iff that variable\n\tis referenced.\n\n\tThis is a more general formulation of RemoveUnusedVars\u0027s current\n\tstrategy (\"traverse a function iff it\u0027s referenced\").\n\n\tR\u003dacleung\n\tDELTA\u003d560  (326 added, 63 deleted, 171 changed)\n\nChange on 2010/08/04 13:09:34 by rjfioravanti\n\n\tCreating externs for CSSMatrix and WebKitCSSMatrix.\n\n\tBased on documentation from the following locations:\n\thttp://www.w3.org/TR/css3-3d-transforms/#cssmatrix-interface\n\thttp://developer.apple.com/safari/library/documentation/AudioVideo/Reference/WebKitCSSMatrixClassReference/WebKitCSSMatrix/WebKitCSSMatrix.html#//apple_ref/javascript/instm/WebKitCSSMatrix/setMatrixValue\n\n\tR\u003dnicksantos\n\tDELTA\u003d193  (193 added, 0 deleted, 0 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d90012\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@335 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "8/4/10, 5:48 PM",
          "commitName": "747f2504d98e2d37c933ead6e40a0a1a1e36d6af",
          "commitAuthor": "Nicholas.J.Santos",
          "commitDateOld": "7/23/10, 2:49 PM",
          "commitNameOld": "f0362b1ab1ae1339e017b1d04f016980e3fa6cb6",
          "commitAuthorOld": "nicksantos@google.com",
          "daysBetweenCommits": 12.12,
          "commitsBetweenForRepo": 26,
          "commitsBetweenForFile": 1,
          "actualSource": "private void removeUnreferencedVars() {\n    CodingConvention convention \u003d compiler.getCodingConvention();\n    for (Iterator\u003cVar\u003e it \u003d maybeUnreferenced.iterator(); it.hasNext(); ) {\n        Var var \u003d it.next();\n        removeAllAssigns(var);\n        compiler.addToDebugLog(\"Unreferenced var: \" + var.name);\n        Node nameNode \u003d var.nameNode;\n        Node toRemove \u003d nameNode.getParent();\n        Node parent \u003d toRemove.getParent();\n        Preconditions.checkState(toRemove.getType() \u003d\u003d Token.VAR || toRemove.getType() \u003d\u003d Token.FUNCTION || toRemove.getType() \u003d\u003d Token.LP \u0026\u0026 parent.getType() \u003d\u003d Token.FUNCTION, \"We should only declare vars and functions and function args\");\n        if (toRemove.getType() \u003d\u003d Token.LP \u0026\u0026 parent.getType() \u003d\u003d Token.FUNCTION) {\n        } else if (NodeUtil.isFunctionExpression(toRemove)) {\n            if (!preserveFunctionExpressionNames) {\n                toRemove.getFirstChild().setString(\"\");\n                compiler.reportCodeChange();\n            }\n        } else if (parent !\u003d null \u0026\u0026 parent.getType() \u003d\u003d Token.FOR \u0026\u0026 parent.getChildCount() \u003c 4) {\n        } else if (toRemove.getType() \u003d\u003d Token.VAR \u0026\u0026 nameNode.hasChildren() \u0026\u0026 NodeUtil.mayHaveSideEffects(nameNode.getFirstChild())) {\n            if (toRemove.getChildCount() \u003d\u003d 1) {\n                parent.replaceChild(toRemove, new Node(Token.EXPR_RESULT, nameNode.removeFirstChild()));\n                compiler.reportCodeChange();\n            }\n        } else if (toRemove.getType() \u003d\u003d Token.VAR \u0026\u0026 toRemove.getChildCount() \u003e 1) {\n            toRemove.removeChild(nameNode);\n            compiler.reportCodeChange();\n        } else if (parent !\u003d null) {\n            NodeUtil.removeChild(parent, toRemove);\n            compiler.reportCodeChange();\n        }\n    }\n}",
          "path": "src/com/google/javascript/jscomp/RemoveUnusedVars.java",
          "functionStartLine": 410,
          "functionName": "removeUnreferencedVars",
          "functionAnnotation": "",
          "functionDoc": "Removes any vars in the scope that were not referenced. Removes any\nassigments to those variables as well.\n",
          "diff": "@@ -1,32 +1,31 @@\n-private void removeUnreferencedVars(Scope scope) {\n+private void removeUnreferencedVars() {\n     CodingConvention convention \u003d compiler.getCodingConvention();\n-    for (Iterator\u003cVar\u003e it \u003d scope.getVars(); it.hasNext(); ) {\n+    for (Iterator\u003cVar\u003e it \u003d maybeUnreferenced.iterator(); it.hasNext(); ) {\n         Var var \u003d it.next();\n-        if (!referenced.contains(var) \u0026\u0026 (var.isLocal() || !convention.isExported(var.name))) {\n-            compiler.addToDebugLog(\"Unreferenced var: \" + var.name);\n-            Node nameNode \u003d var.nameNode;\n-            Node toRemove \u003d nameNode.getParent();\n-            Node parent \u003d toRemove.getParent();\n-            Preconditions.checkState(toRemove.getType() \u003d\u003d Token.VAR || toRemove.getType() \u003d\u003d Token.FUNCTION || toRemove.getType() \u003d\u003d Token.LP \u0026\u0026 parent.getType() \u003d\u003d Token.FUNCTION, \"We should only declare vars and functions and function args\");\n-            if (toRemove.getType() \u003d\u003d Token.LP \u0026\u0026 parent.getType() \u003d\u003d Token.FUNCTION) {\n-            } else if (NodeUtil.isFunctionExpression(toRemove)) {\n-                if (!preserveFunctionExpressionNames) {\n-                    toRemove.getFirstChild().setString(\"\");\n-                    finishRemove(var);\n-                }\n-            } else if (parent !\u003d null \u0026\u0026 parent.getType() \u003d\u003d Token.FOR \u0026\u0026 parent.getChildCount() \u003c 4) {\n-            } else if (toRemove.getType() \u003d\u003d Token.VAR \u0026\u0026 nameNode.hasChildren() \u0026\u0026 NodeUtil.mayHaveSideEffects(nameNode.getFirstChild())) {\n-                if (toRemove.getChildCount() \u003d\u003d 1) {\n-                    parent.replaceChild(toRemove, new Node(Token.EXPR_RESULT, nameNode.removeFirstChild()));\n-                    finishRemove(var);\n-                }\n-            } else if (toRemove.getType() \u003d\u003d Token.VAR \u0026\u0026 toRemove.getChildCount() \u003e 1) {\n-                toRemove.removeChild(nameNode);\n-                finishRemove(var);\n-            } else if (parent !\u003d null) {\n-                NodeUtil.removeChild(parent, toRemove);\n-                finishRemove(var);\n+        removeAllAssigns(var);\n+        compiler.addToDebugLog(\"Unreferenced var: \" + var.name);\n+        Node nameNode \u003d var.nameNode;\n+        Node toRemove \u003d nameNode.getParent();\n+        Node parent \u003d toRemove.getParent();\n+        Preconditions.checkState(toRemove.getType() \u003d\u003d Token.VAR || toRemove.getType() \u003d\u003d Token.FUNCTION || toRemove.getType() \u003d\u003d Token.LP \u0026\u0026 parent.getType() \u003d\u003d Token.FUNCTION, \"We should only declare vars and functions and function args\");\n+        if (toRemove.getType() \u003d\u003d Token.LP \u0026\u0026 parent.getType() \u003d\u003d Token.FUNCTION) {\n+        } else if (NodeUtil.isFunctionExpression(toRemove)) {\n+            if (!preserveFunctionExpressionNames) {\n+                toRemove.getFirstChild().setString(\"\");\n+                compiler.reportCodeChange();\n             }\n+        } else if (parent !\u003d null \u0026\u0026 parent.getType() \u003d\u003d Token.FOR \u0026\u0026 parent.getChildCount() \u003c 4) {\n+        } else if (toRemove.getType() \u003d\u003d Token.VAR \u0026\u0026 nameNode.hasChildren() \u0026\u0026 NodeUtil.mayHaveSideEffects(nameNode.getFirstChild())) {\n+            if (toRemove.getChildCount() \u003d\u003d 1) {\n+                parent.replaceChild(toRemove, new Node(Token.EXPR_RESULT, nameNode.removeFirstChild()));\n+                compiler.reportCodeChange();\n+            }\n+        } else if (toRemove.getType() \u003d\u003d Token.VAR \u0026\u0026 toRemove.getChildCount() \u003e 1) {\n+            toRemove.removeChild(nameNode);\n+            compiler.reportCodeChange();\n+        } else if (parent !\u003d null) {\n+            NodeUtil.removeChild(parent, toRemove);\n+            compiler.reportCodeChange();\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Removes any vars in the scope that were not referenced.\n",
            "newValue": "Removes any vars in the scope that were not referenced. Removes any\nassigments to those variables as well.\n"
          }
        }
      ]
    },
    "833cd72a268c1161194038faf0d98ec6b1f203eb": {
      "type": "Ybodychange",
      "commitMessage": "\nMake RemoveUnusedVars a lot smarter about dead assigns.\nGranted, it\u0027s still nowhere near as smart as the real dead-assignment\npass, so maybe it\u0027d be better to say that this makes the pass\nless dumb.\n\nR\u003dacleung\nDELTA\u003d251  (222 added, 15 deleted, 14 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d52002\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@281 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "7/15/10, 2:02 PM",
      "commitName": "833cd72a268c1161194038faf0d98ec6b1f203eb",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "7/12/10, 3:20 PM",
      "commitNameOld": "b2c12cd9f4284d58450d1a487e29d6b6a065105e",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 2.95,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "actualSource": "private void removeUnreferencedVars(Scope scope) {\n    CodingConvention convention \u003d compiler.getCodingConvention();\n    for (Iterator\u003cVar\u003e it \u003d scope.getVars(); it.hasNext(); ) {\n        Var var \u003d it.next();\n        if (!referenced.contains(var) \u0026\u0026 (var.isLocal() || !convention.isExported(var.name))) {\n            compiler.addToDebugLog(\"Unreferenced var: \" + var.name);\n            Node nameNode \u003d var.nameNode;\n            Node toRemove \u003d nameNode.getParent();\n            Node parent \u003d toRemove.getParent();\n            Preconditions.checkState(toRemove.getType() \u003d\u003d Token.VAR || toRemove.getType() \u003d\u003d Token.FUNCTION || toRemove.getType() \u003d\u003d Token.LP \u0026\u0026 parent.getType() \u003d\u003d Token.FUNCTION, \"We should only declare vars and functions and function args\");\n            if (toRemove.getType() \u003d\u003d Token.LP \u0026\u0026 parent.getType() \u003d\u003d Token.FUNCTION) {\n            } else if (NodeUtil.isFunctionExpression(toRemove)) {\n                if (!preserveFunctionExpressionNames) {\n                    toRemove.getFirstChild().setString(\"\");\n                    finishRemove(var);\n                }\n            } else if (parent !\u003d null \u0026\u0026 parent.getType() \u003d\u003d Token.FOR \u0026\u0026 parent.getChildCount() \u003c 4) {\n            } else if (toRemove.getType() \u003d\u003d Token.VAR \u0026\u0026 nameNode.hasChildren() \u0026\u0026 NodeUtil.mayHaveSideEffects(nameNode.getFirstChild())) {\n                if (toRemove.getChildCount() \u003d\u003d 1) {\n                    parent.replaceChild(toRemove, new Node(Token.EXPR_RESULT, nameNode.removeFirstChild()));\n                    finishRemove(var);\n                }\n            } else if (toRemove.getType() \u003d\u003d Token.VAR \u0026\u0026 toRemove.getChildCount() \u003e 1) {\n                toRemove.removeChild(nameNode);\n                finishRemove(var);\n            } else if (parent !\u003d null) {\n                NodeUtil.removeChild(parent, toRemove);\n                finishRemove(var);\n            }\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/RemoveUnusedVars.java",
      "functionStartLine": 292,
      "functionName": "removeUnreferencedVars",
      "functionAnnotation": "",
      "functionDoc": "Removes any vars in the scope that were not referenced.\n",
      "diff": "@@ -1,32 +1,32 @@\n private void removeUnreferencedVars(Scope scope) {\n     CodingConvention convention \u003d compiler.getCodingConvention();\n     for (Iterator\u003cVar\u003e it \u003d scope.getVars(); it.hasNext(); ) {\n         Var var \u003d it.next();\n         if (!referenced.contains(var) \u0026\u0026 (var.isLocal() || !convention.isExported(var.name))) {\n             compiler.addToDebugLog(\"Unreferenced var: \" + var.name);\n             Node nameNode \u003d var.nameNode;\n             Node toRemove \u003d nameNode.getParent();\n             Node parent \u003d toRemove.getParent();\n             Preconditions.checkState(toRemove.getType() \u003d\u003d Token.VAR || toRemove.getType() \u003d\u003d Token.FUNCTION || toRemove.getType() \u003d\u003d Token.LP \u0026\u0026 parent.getType() \u003d\u003d Token.FUNCTION, \"We should only declare vars and functions and function args\");\n             if (toRemove.getType() \u003d\u003d Token.LP \u0026\u0026 parent.getType() \u003d\u003d Token.FUNCTION) {\n             } else if (NodeUtil.isFunctionExpression(toRemove)) {\n                 if (!preserveFunctionExpressionNames) {\n                     toRemove.getFirstChild().setString(\"\");\n-                    compiler.reportCodeChange();\n+                    finishRemove(var);\n                 }\n             } else if (parent !\u003d null \u0026\u0026 parent.getType() \u003d\u003d Token.FOR \u0026\u0026 parent.getChildCount() \u003c 4) {\n             } else if (toRemove.getType() \u003d\u003d Token.VAR \u0026\u0026 nameNode.hasChildren() \u0026\u0026 NodeUtil.mayHaveSideEffects(nameNode.getFirstChild())) {\n                 if (toRemove.getChildCount() \u003d\u003d 1) {\n                     parent.replaceChild(toRemove, new Node(Token.EXPR_RESULT, nameNode.removeFirstChild()));\n-                    numRemoved++;\n+                    finishRemove(var);\n                 }\n             } else if (toRemove.getType() \u003d\u003d Token.VAR \u0026\u0026 toRemove.getChildCount() \u003e 1) {\n                 toRemove.removeChild(nameNode);\n-                numRemoved++;\n+                finishRemove(var);\n             } else if (parent !\u003d null) {\n                 NodeUtil.removeChild(parent, toRemove);\n-                numRemoved++;\n+                finishRemove(var);\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b2c12cd9f4284d58450d1a487e29d6b6a065105e": {
      "type": "Ybodychange",
      "commitMessage": "\nChange on 2010/07/12 11:35:39 by nicksantos\n\n\tclean up RemoveUnusedVars. Update old naming conventions,\n\tand remove a logger that was no longer really accurate.\n\n\tR\u003djohnlenz\n\tDELTA\u003d35  (0 added, 18 deleted, 17 changed)\n\nChange on 2010/07/12 11:37:59 by johnlenz\n\n\tStub out an unused section of the source map, which results in\n\tslightly smaller, faster, and simplified logic.\n\n\tR\u003djschorr\n\tDELTA\u003d68  (18 added, 41 deleted, 9 changed)\n\nChange on 2010/07/12 11:39:24 by gboyer\n\n\tClipboardData is a property of Event in IE.\n\n\tDefinition copied from ie_dom.js.  I added a |undefined because it is\n\tnot defined in other browsers.\n\n\tFixes warning in Trog\u0027s paste interceptor.\n\n\tR\u003dnicksantos,skobes\n\tDELTA\u003d5  (5 added, 0 deleted, 0 changed)\n\nChange on 2010/07/12 12:42:29 by nicksantos\n\n\tClean up AliasExternals and make it work with normalization.\n\n\tR\u003djohnlenz\n\tDELTA\u003d43  (24 added, 0 deleted, 19 changed)\n\nChange on 2010/07/12 12:58:26 by nicksantos\n\n\tfix ScopedAliases when the type of a parameter is null.\n\n\tR\u003drobbyw\n\tDELTA\u003d13  (11 added, 0 deleted, 2 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d48008\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@272 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "7/12/10, 3:20 PM",
      "commitName": "b2c12cd9f4284d58450d1a487e29d6b6a065105e",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "6/2/10, 7:10 AM",
      "commitNameOld": "4672a1aca15e6d5c3e7c2e00e31767f3c8327335",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 40.34,
      "commitsBetweenForRepo": 34,
      "commitsBetweenForFile": 1,
      "actualSource": "private void removeUnreferencedVars(Scope scope) {\n    CodingConvention convention \u003d compiler.getCodingConvention();\n    for (Iterator\u003cVar\u003e it \u003d scope.getVars(); it.hasNext(); ) {\n        Var var \u003d it.next();\n        if (!referenced.contains(var) \u0026\u0026 (var.isLocal() || !convention.isExported(var.name))) {\n            compiler.addToDebugLog(\"Unreferenced var: \" + var.name);\n            Node nameNode \u003d var.nameNode;\n            Node toRemove \u003d nameNode.getParent();\n            Node parent \u003d toRemove.getParent();\n            Preconditions.checkState(toRemove.getType() \u003d\u003d Token.VAR || toRemove.getType() \u003d\u003d Token.FUNCTION || toRemove.getType() \u003d\u003d Token.LP \u0026\u0026 parent.getType() \u003d\u003d Token.FUNCTION, \"We should only declare vars and functions and function args\");\n            if (toRemove.getType() \u003d\u003d Token.LP \u0026\u0026 parent.getType() \u003d\u003d Token.FUNCTION) {\n            } else if (NodeUtil.isFunctionExpression(toRemove)) {\n                if (!preserveFunctionExpressionNames) {\n                    toRemove.getFirstChild().setString(\"\");\n                    compiler.reportCodeChange();\n                }\n            } else if (parent !\u003d null \u0026\u0026 parent.getType() \u003d\u003d Token.FOR \u0026\u0026 parent.getChildCount() \u003c 4) {\n            } else if (toRemove.getType() \u003d\u003d Token.VAR \u0026\u0026 nameNode.hasChildren() \u0026\u0026 NodeUtil.mayHaveSideEffects(nameNode.getFirstChild())) {\n                if (toRemove.getChildCount() \u003d\u003d 1) {\n                    parent.replaceChild(toRemove, new Node(Token.EXPR_RESULT, nameNode.removeFirstChild()));\n                    numRemoved++;\n                }\n            } else if (toRemove.getType() \u003d\u003d Token.VAR \u0026\u0026 toRemove.getChildCount() \u003e 1) {\n                toRemove.removeChild(nameNode);\n                numRemoved++;\n            } else if (parent !\u003d null) {\n                NodeUtil.removeChild(parent, toRemove);\n                numRemoved++;\n            }\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/RemoveUnusedVars.java",
      "functionStartLine": 234,
      "functionName": "removeUnreferencedVars",
      "functionAnnotation": "",
      "functionDoc": "Removes any vars in the scope that were not referenced.\n",
      "diff": "@@ -1,37 +1,32 @@\n private void removeUnreferencedVars(Scope scope) {\n-    CodingConvention convention \u003d compiler_.getCodingConvention();\n+    CodingConvention convention \u003d compiler.getCodingConvention();\n     for (Iterator\u003cVar\u003e it \u003d scope.getVars(); it.hasNext(); ) {\n         Var var \u003d it.next();\n         if (!referenced.contains(var) \u0026\u0026 (var.isLocal() || !convention.isExported(var.name))) {\n-            compiler_.addToDebugLog(\"Unreferenced var: \" + var.name);\n+            compiler.addToDebugLog(\"Unreferenced var: \" + var.name);\n             Node nameNode \u003d var.nameNode;\n             Node toRemove \u003d nameNode.getParent();\n             Node parent \u003d toRemove.getParent();\n             Preconditions.checkState(toRemove.getType() \u003d\u003d Token.VAR || toRemove.getType() \u003d\u003d Token.FUNCTION || toRemove.getType() \u003d\u003d Token.LP \u0026\u0026 parent.getType() \u003d\u003d Token.FUNCTION, \"We should only declare vars and functions and function args\");\n             if (toRemove.getType() \u003d\u003d Token.LP \u0026\u0026 parent.getType() \u003d\u003d Token.FUNCTION) {\n             } else if (NodeUtil.isFunctionExpression(toRemove)) {\n                 if (!preserveFunctionExpressionNames) {\n                     toRemove.getFirstChild().setString(\"\");\n-                    compiler_.reportCodeChange();\n+                    compiler.reportCodeChange();\n                 }\n             } else if (parent !\u003d null \u0026\u0026 parent.getType() \u003d\u003d Token.FOR \u0026\u0026 parent.getChildCount() \u003c 4) {\n             } else if (toRemove.getType() \u003d\u003d Token.VAR \u0026\u0026 nameNode.hasChildren() \u0026\u0026 NodeUtil.mayHaveSideEffects(nameNode.getFirstChild())) {\n-                if (!warnedVars_.contains(var)) {\n-                    warnedVars_.add(var);\n-                    String inputName \u003d var.input !\u003d null ? var.input.getName() : \"\u003cunknown\u003e\";\n-                    logger_.info(\"Unused var \" + var.name + \" declared in \" + inputName + \" at line \" + toRemove.getLineno() + \" may have side effects and can\u0027t be removed\");\n-                }\n                 if (toRemove.getChildCount() \u003d\u003d 1) {\n                     parent.replaceChild(toRemove, new Node(Token.EXPR_RESULT, nameNode.removeFirstChild()));\n-                    numRemoved_++;\n+                    numRemoved++;\n                 }\n             } else if (toRemove.getType() \u003d\u003d Token.VAR \u0026\u0026 toRemove.getChildCount() \u003e 1) {\n                 toRemove.removeChild(nameNode);\n-                numRemoved_++;\n+                numRemoved++;\n             } else if (parent !\u003d null) {\n                 NodeUtil.removeChild(parent, toRemove);\n-                numRemoved_++;\n+                numRemoved++;\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ebb59a97610015bc41bda7f458dd1428a3a3e335": {
      "type": "Ybodychange",
      "commitMessage": "\nChange on 2010/04/22 by nick\n\n        fix the extern definition of Window.prototype.stop\n\n        R\u003dsiggy\n        DELTA\u003d1  (0 added, 0 deleted, 1 changed)\n\nChange on 2010/04/22 by john\n\n        \"Anonymous function\" is a confusing term for functions with names.\n        Properly we are usually distinguishing between functions statements\n        (function declarations) and function expressions.\n\n        R\u003dalan\n        DELTA\u003d172  (7 added, 14 deleted, 151 changed)\n\nChange on 2010/04/22 by john\n\n        Standardize the definition of setTimeout/setInterval.\n        Fix for Issue 137\n\n        R\u003dnick\n        DELTA\u003d6  (2 added, 2 deleted, 2 changed)\n\nChange on 2010/04/22 by mark\n\n        Various delegate fixes.\n\n        Give the delegate proxy a name unique from the delegate base so that\n        InstanceObjectType#equals distinguishes them. This is necessary for\n        AmbiguateProperties to work.\n\n        Fix the prototype of the delegate proxy. This makes\n        DisambiguateProperties continue to work.\n\n        Add superclass methods of the delegate base to the delegate proxy.\n\n\n        R\u003dandrew,nada\n        DELTA\u003d526  (383 added, 104 deleted, 39 changed)\n\nChange on 2010/04/23 by john\n\n        Allow variable inlining of function statements. For simplicity  limited to functions defined before first use.\n\n        R\u003dnick\n        DELTA\u003d79  (49 added, 3 deleted, 27 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003dhakjvx\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@197 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/23/10, 11:31 AM",
      "commitName": "ebb59a97610015bc41bda7f458dd1428a3a3e335",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "3/31/10, 2:45 PM",
      "commitNameOld": "fbf47bd6fe52121c22d9c1fa6764e6686221df99",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 22.87,
      "commitsBetweenForRepo": 30,
      "commitsBetweenForFile": 1,
      "actualSource": "private void removeUnreferencedVars(Scope scope) {\n    CodingConvention convention \u003d compiler_.getCodingConvention();\n    for (Iterator\u003cVar\u003e it \u003d scope.getVars(); it.hasNext(); ) {\n        Var var \u003d it.next();\n        if (!referenced.contains(var) \u0026\u0026 (var.isLocal() || !convention.isExported(var.name))) {\n            compiler_.addToDebugLog(\"Unreferenced var: \" + var.name);\n            Node nameNode \u003d var.nameNode;\n            Node toRemove \u003d nameNode.getParent();\n            Node parent \u003d toRemove.getParent();\n            Preconditions.checkState(toRemove.getType() \u003d\u003d Token.VAR || toRemove.getType() \u003d\u003d Token.FUNCTION || toRemove.getType() \u003d\u003d Token.LP \u0026\u0026 parent.getType() \u003d\u003d Token.FUNCTION, \"We should only declare vars and functions and function args\");\n            if (toRemove.getType() \u003d\u003d Token.LP \u0026\u0026 parent.getType() \u003d\u003d Token.FUNCTION) {\n            } else if (NodeUtil.isFunctionExpression(toRemove)) {\n                if (!preserveFunctionExpressionNames) {\n                    toRemove.getFirstChild().setString(\"\");\n                    compiler_.reportCodeChange();\n                }\n            } else if (parent !\u003d null \u0026\u0026 parent.getType() \u003d\u003d Token.FOR \u0026\u0026 parent.getChildCount() \u003c 4) {\n            } else if (toRemove.getType() \u003d\u003d Token.VAR \u0026\u0026 nameNode.hasChildren() \u0026\u0026 NodeUtil.mayHaveSideEffects(nameNode.getFirstChild())) {\n                if (!warnedVars_.contains(var)) {\n                    warnedVars_.add(var);\n                    String inputName \u003d var.input !\u003d null ? var.input.getName() : \"\u003cunknown\u003e\";\n                    logger_.info(\"Unused var \" + var.name + \" declared in \" + inputName + \" at line \" + toRemove.getLineno() + \" may have side effects and can\u0027t be removed\");\n                }\n                if (toRemove.getChildCount() \u003d\u003d 1) {\n                    parent.replaceChild(toRemove, new Node(Token.EXPR_RESULT, nameNode.removeFirstChild()));\n                    numRemoved_++;\n                }\n            } else if (toRemove.getType() \u003d\u003d Token.VAR \u0026\u0026 toRemove.getChildCount() \u003e 1) {\n                toRemove.removeChild(nameNode);\n                numRemoved_++;\n            } else if (parent !\u003d null) {\n                NodeUtil.removeChild(parent, toRemove);\n                numRemoved_++;\n            }\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/RemoveUnusedVars.java",
      "functionStartLine": 223,
      "functionName": "removeUnreferencedVars",
      "functionAnnotation": "",
      "functionDoc": "Removes any vars in the scope that were not referenced.\n",
      "diff": "@@ -1,37 +1,37 @@\n private void removeUnreferencedVars(Scope scope) {\n     CodingConvention convention \u003d compiler_.getCodingConvention();\n     for (Iterator\u003cVar\u003e it \u003d scope.getVars(); it.hasNext(); ) {\n         Var var \u003d it.next();\n         if (!referenced.contains(var) \u0026\u0026 (var.isLocal() || !convention.isExported(var.name))) {\n             compiler_.addToDebugLog(\"Unreferenced var: \" + var.name);\n             Node nameNode \u003d var.nameNode;\n             Node toRemove \u003d nameNode.getParent();\n             Node parent \u003d toRemove.getParent();\n             Preconditions.checkState(toRemove.getType() \u003d\u003d Token.VAR || toRemove.getType() \u003d\u003d Token.FUNCTION || toRemove.getType() \u003d\u003d Token.LP \u0026\u0026 parent.getType() \u003d\u003d Token.FUNCTION, \"We should only declare vars and functions and function args\");\n             if (toRemove.getType() \u003d\u003d Token.LP \u0026\u0026 parent.getType() \u003d\u003d Token.FUNCTION) {\n-            } else if (toRemove.getType() \u003d\u003d Token.FUNCTION \u0026\u0026 NodeUtil.isFunctionAnonymous(toRemove)) {\n-                if (!preserveAnonymousFunctionNames) {\n+            } else if (NodeUtil.isFunctionExpression(toRemove)) {\n+                if (!preserveFunctionExpressionNames) {\n                     toRemove.getFirstChild().setString(\"\");\n                     compiler_.reportCodeChange();\n                 }\n             } else if (parent !\u003d null \u0026\u0026 parent.getType() \u003d\u003d Token.FOR \u0026\u0026 parent.getChildCount() \u003c 4) {\n             } else if (toRemove.getType() \u003d\u003d Token.VAR \u0026\u0026 nameNode.hasChildren() \u0026\u0026 NodeUtil.mayHaveSideEffects(nameNode.getFirstChild())) {\n                 if (!warnedVars_.contains(var)) {\n                     warnedVars_.add(var);\n                     String inputName \u003d var.input !\u003d null ? var.input.getName() : \"\u003cunknown\u003e\";\n                     logger_.info(\"Unused var \" + var.name + \" declared in \" + inputName + \" at line \" + toRemove.getLineno() + \" may have side effects and can\u0027t be removed\");\n                 }\n                 if (toRemove.getChildCount() \u003d\u003d 1) {\n                     parent.replaceChild(toRemove, new Node(Token.EXPR_RESULT, nameNode.removeFirstChild()));\n                     numRemoved_++;\n                 }\n             } else if (toRemove.getType() \u003d\u003d Token.VAR \u0026\u0026 toRemove.getChildCount() \u003e 1) {\n                 toRemove.removeChild(nameNode);\n                 numRemoved_++;\n             } else if (parent !\u003d null) {\n                 NodeUtil.removeChild(parent, toRemove);\n                 numRemoved_++;\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "14ddcfdc0b8d1cece3c79221b1870b84f055d419": {
      "type": "Ybodychange",
      "commitMessage": "Change the internal representation of constant variables.\n\nRun inline-variables before smart-name-removal.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@37 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "12/17/09, 4:20 PM",
      "commitName": "14ddcfdc0b8d1cece3c79221b1870b84f055d419",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "commitDateOld": "11/25/09, 6:53 AM",
      "commitNameOld": "3bee5d740c96572faea4b9fb8b632e0e07b13cbb",
      "commitAuthorOld": "nicholas.j.santos@gmail.com",
      "daysBetweenCommits": 22.39,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "actualSource": "private void removeUnreferencedVars(Scope scope) {\n    CodingConvention convention \u003d compiler_.getCodingConvention();\n    for (Iterator\u003cVar\u003e it \u003d scope.getVars(); it.hasNext(); ) {\n        Var var \u003d it.next();\n        if (!referenced.contains(var) \u0026\u0026 (var.isLocal() || !convention.isExported(var.name))) {\n            compiler_.addToDebugLog(\"Unreferenced var: \" + var.name);\n            Node nameNode \u003d var.nameNode;\n            Node toRemove \u003d nameNode.getParent();\n            Node parent \u003d toRemove.getParent();\n            Preconditions.checkState(toRemove.getType() \u003d\u003d Token.VAR || toRemove.getType() \u003d\u003d Token.FUNCTION || toRemove.getType() \u003d\u003d Token.LP \u0026\u0026 parent.getType() \u003d\u003d Token.FUNCTION, \"We should only declare vars and functions and function args\");\n            if (toRemove.getType() \u003d\u003d Token.LP \u0026\u0026 parent.getType() \u003d\u003d Token.FUNCTION) {\n            } else if (toRemove.getType() \u003d\u003d Token.FUNCTION \u0026\u0026 NodeUtil.isFunctionAnonymous(toRemove)) {\n                if (!preserveAnonymousFunctionNames) {\n                    toRemove.getFirstChild().setString(\"\");\n                    compiler_.reportCodeChange();\n                }\n            } else if (parent !\u003d null \u0026\u0026 parent.getType() \u003d\u003d Token.FOR \u0026\u0026 parent.getChildCount() \u003c 4) {\n            } else if (toRemove.getType() \u003d\u003d Token.VAR \u0026\u0026 nameNode.hasChildren() \u0026\u0026 NodeUtil.mayHaveSideEffects(nameNode.getFirstChild())) {\n                if (!warnedVars_.contains(var)) {\n                    warnedVars_.add(var);\n                    String inputName \u003d var.input !\u003d null ? var.input.getName() : \"\u003cunknown\u003e\";\n                    logger_.info(\"Unused var \" + var.name + \" declared in \" + inputName + \" at line \" + toRemove.getLineno() + \" may have side effects and can\u0027t be removed\");\n                }\n                if (toRemove.getChildCount() \u003d\u003d 1) {\n                    parent.replaceChild(toRemove, new Node(Token.EXPR_RESULT, nameNode.removeFirstChild()));\n                    numRemoved_++;\n                }\n            } else if (toRemove.getType() \u003d\u003d Token.VAR \u0026\u0026 toRemove.getChildCount() \u003e 1) {\n                toRemove.removeChild(nameNode);\n                numRemoved_++;\n            } else if (parent !\u003d null) {\n                NodeUtil.removeChild(parent, toRemove);\n                numRemoved_++;\n            }\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/RemoveUnusedVars.java",
      "functionStartLine": 231,
      "functionName": "removeUnreferencedVars",
      "functionAnnotation": "",
      "functionDoc": "Removes any vars in the scope that were not referenced.\n",
      "diff": "@@ -1,37 +1,37 @@\n private void removeUnreferencedVars(Scope scope) {\n     CodingConvention convention \u003d compiler_.getCodingConvention();\n-    for (Iterator\u003cScope.Var\u003e it \u003d scope.getVars(); it.hasNext(); ) {\n-        Scope.Var var \u003d it.next();\n-        if (!var.referenced \u0026\u0026 (var.isLocal() || !convention.isExported(var.name))) {\n+    for (Iterator\u003cVar\u003e it \u003d scope.getVars(); it.hasNext(); ) {\n+        Var var \u003d it.next();\n+        if (!referenced.contains(var) \u0026\u0026 (var.isLocal() || !convention.isExported(var.name))) {\n             compiler_.addToDebugLog(\"Unreferenced var: \" + var.name);\n             Node nameNode \u003d var.nameNode;\n             Node toRemove \u003d nameNode.getParent();\n             Node parent \u003d toRemove.getParent();\n             Preconditions.checkState(toRemove.getType() \u003d\u003d Token.VAR || toRemove.getType() \u003d\u003d Token.FUNCTION || toRemove.getType() \u003d\u003d Token.LP \u0026\u0026 parent.getType() \u003d\u003d Token.FUNCTION, \"We should only declare vars and functions and function args\");\n             if (toRemove.getType() \u003d\u003d Token.LP \u0026\u0026 parent.getType() \u003d\u003d Token.FUNCTION) {\n             } else if (toRemove.getType() \u003d\u003d Token.FUNCTION \u0026\u0026 NodeUtil.isFunctionAnonymous(toRemove)) {\n                 if (!preserveAnonymousFunctionNames) {\n                     toRemove.getFirstChild().setString(\"\");\n                     compiler_.reportCodeChange();\n                 }\n             } else if (parent !\u003d null \u0026\u0026 parent.getType() \u003d\u003d Token.FOR \u0026\u0026 parent.getChildCount() \u003c 4) {\n             } else if (toRemove.getType() \u003d\u003d Token.VAR \u0026\u0026 nameNode.hasChildren() \u0026\u0026 NodeUtil.mayHaveSideEffects(nameNode.getFirstChild())) {\n                 if (!warnedVars_.contains(var)) {\n                     warnedVars_.add(var);\n                     String inputName \u003d var.input !\u003d null ? var.input.getName() : \"\u003cunknown\u003e\";\n                     logger_.info(\"Unused var \" + var.name + \" declared in \" + inputName + \" at line \" + toRemove.getLineno() + \" may have side effects and can\u0027t be removed\");\n                 }\n                 if (toRemove.getChildCount() \u003d\u003d 1) {\n                     parent.replaceChild(toRemove, new Node(Token.EXPR_RESULT, nameNode.removeFirstChild()));\n                     numRemoved_++;\n                 }\n             } else if (toRemove.getType() \u003d\u003d Token.VAR \u0026\u0026 toRemove.getChildCount() \u003e 1) {\n                 toRemove.removeChild(nameNode);\n                 numRemoved_++;\n             } else if (parent !\u003d null) {\n                 NodeUtil.removeChild(parent, toRemove);\n                 numRemoved_++;\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3bee5d740c96572faea4b9fb8b632e0e07b13cbb": {
      "type": "Ybodychange",
      "commitMessage": "Add a mechanism for inlining local vars, and turn it on by default.\nWarnings for \"ambiguous\" function definitions.\nRefactoring and renaming of some method names.\nUse \"\u003d\" optionality annotation in externs.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@15 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/25/09, 6:53 AM",
      "commitName": "3bee5d740c96572faea4b9fb8b632e0e07b13cbb",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "commitDateOld": "11/3/09, 3:51 PM",
      "commitNameOld": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthorOld": "nicholas.j.santos@gmail.com",
      "daysBetweenCommits": 21.63,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "actualSource": "private void removeUnreferencedVars(Scope scope) {\n    CodingConvention convention \u003d compiler_.getCodingConvention();\n    for (Iterator\u003cScope.Var\u003e it \u003d scope.getVars(); it.hasNext(); ) {\n        Scope.Var var \u003d it.next();\n        if (!var.referenced \u0026\u0026 (var.isLocal() || !convention.isExported(var.name))) {\n            compiler_.addToDebugLog(\"Unreferenced var: \" + var.name);\n            Node nameNode \u003d var.nameNode;\n            Node toRemove \u003d nameNode.getParent();\n            Node parent \u003d toRemove.getParent();\n            Preconditions.checkState(toRemove.getType() \u003d\u003d Token.VAR || toRemove.getType() \u003d\u003d Token.FUNCTION || toRemove.getType() \u003d\u003d Token.LP \u0026\u0026 parent.getType() \u003d\u003d Token.FUNCTION, \"We should only declare vars and functions and function args\");\n            if (toRemove.getType() \u003d\u003d Token.LP \u0026\u0026 parent.getType() \u003d\u003d Token.FUNCTION) {\n            } else if (toRemove.getType() \u003d\u003d Token.FUNCTION \u0026\u0026 NodeUtil.isFunctionAnonymous(toRemove)) {\n                if (!preserveAnonymousFunctionNames) {\n                    toRemove.getFirstChild().setString(\"\");\n                    compiler_.reportCodeChange();\n                }\n            } else if (parent !\u003d null \u0026\u0026 parent.getType() \u003d\u003d Token.FOR \u0026\u0026 parent.getChildCount() \u003c 4) {\n            } else if (toRemove.getType() \u003d\u003d Token.VAR \u0026\u0026 nameNode.hasChildren() \u0026\u0026 NodeUtil.mayHaveSideEffects(nameNode.getFirstChild())) {\n                if (!warnedVars_.contains(var)) {\n                    warnedVars_.add(var);\n                    String inputName \u003d var.input !\u003d null ? var.input.getName() : \"\u003cunknown\u003e\";\n                    logger_.info(\"Unused var \" + var.name + \" declared in \" + inputName + \" at line \" + toRemove.getLineno() + \" may have side effects and can\u0027t be removed\");\n                }\n                if (toRemove.getChildCount() \u003d\u003d 1) {\n                    parent.replaceChild(toRemove, new Node(Token.EXPR_RESULT, nameNode.removeFirstChild()));\n                    numRemoved_++;\n                }\n            } else if (toRemove.getType() \u003d\u003d Token.VAR \u0026\u0026 toRemove.getChildCount() \u003e 1) {\n                toRemove.removeChild(nameNode);\n                numRemoved_++;\n            } else if (parent !\u003d null) {\n                NodeUtil.removeChild(parent, toRemove);\n                numRemoved_++;\n            }\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/RemoveUnusedVars.java",
      "functionStartLine": 224,
      "functionName": "removeUnreferencedVars",
      "functionAnnotation": "",
      "functionDoc": "Removes any vars in the scope that were not referenced.\n",
      "diff": "@@ -1,33 +1,37 @@\n private void removeUnreferencedVars(Scope scope) {\n     CodingConvention convention \u003d compiler_.getCodingConvention();\n     for (Iterator\u003cScope.Var\u003e it \u003d scope.getVars(); it.hasNext(); ) {\n         Scope.Var var \u003d it.next();\n         if (!var.referenced \u0026\u0026 (var.isLocal() || !convention.isExported(var.name))) {\n             compiler_.addToDebugLog(\"Unreferenced var: \" + var.name);\n             Node nameNode \u003d var.nameNode;\n             Node toRemove \u003d nameNode.getParent();\n             Node parent \u003d toRemove.getParent();\n             Preconditions.checkState(toRemove.getType() \u003d\u003d Token.VAR || toRemove.getType() \u003d\u003d Token.FUNCTION || toRemove.getType() \u003d\u003d Token.LP \u0026\u0026 parent.getType() \u003d\u003d Token.FUNCTION, \"We should only declare vars and functions and function args\");\n             if (toRemove.getType() \u003d\u003d Token.LP \u0026\u0026 parent.getType() \u003d\u003d Token.FUNCTION) {\n             } else if (toRemove.getType() \u003d\u003d Token.FUNCTION \u0026\u0026 NodeUtil.isFunctionAnonymous(toRemove)) {\n+                if (!preserveAnonymousFunctionNames) {\n+                    toRemove.getFirstChild().setString(\"\");\n+                    compiler_.reportCodeChange();\n+                }\n             } else if (parent !\u003d null \u0026\u0026 parent.getType() \u003d\u003d Token.FOR \u0026\u0026 parent.getChildCount() \u003c 4) {\n             } else if (toRemove.getType() \u003d\u003d Token.VAR \u0026\u0026 nameNode.hasChildren() \u0026\u0026 NodeUtil.mayHaveSideEffects(nameNode.getFirstChild())) {\n                 if (!warnedVars_.contains(var)) {\n                     warnedVars_.add(var);\n                     String inputName \u003d var.input !\u003d null ? var.input.getName() : \"\u003cunknown\u003e\";\n                     logger_.info(\"Unused var \" + var.name + \" declared in \" + inputName + \" at line \" + toRemove.getLineno() + \" may have side effects and can\u0027t be removed\");\n                 }\n                 if (toRemove.getChildCount() \u003d\u003d 1) {\n                     parent.replaceChild(toRemove, new Node(Token.EXPR_RESULT, nameNode.removeFirstChild()));\n                     numRemoved_++;\n                 }\n             } else if (toRemove.getType() \u003d\u003d Token.VAR \u0026\u0026 toRemove.getChildCount() \u003e 1) {\n                 toRemove.removeChild(nameNode);\n                 numRemoved_++;\n             } else if (parent !\u003d null) {\n                 NodeUtil.removeChild(parent, toRemove);\n                 numRemoved_++;\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": {
      "type": "Yintroduced",
      "commitMessage": "Initial commit.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/3/09, 3:51 PM",
      "commitName": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "diff": "@@ -0,0 +1,33 @@\n+private void removeUnreferencedVars(Scope scope) {\n+    CodingConvention convention \u003d compiler_.getCodingConvention();\n+    for (Iterator\u003cScope.Var\u003e it \u003d scope.getVars(); it.hasNext(); ) {\n+        Scope.Var var \u003d it.next();\n+        if (!var.referenced \u0026\u0026 (var.isLocal() || !convention.isExported(var.name))) {\n+            compiler_.addToDebugLog(\"Unreferenced var: \" + var.name);\n+            Node nameNode \u003d var.nameNode;\n+            Node toRemove \u003d nameNode.getParent();\n+            Node parent \u003d toRemove.getParent();\n+            Preconditions.checkState(toRemove.getType() \u003d\u003d Token.VAR || toRemove.getType() \u003d\u003d Token.FUNCTION || toRemove.getType() \u003d\u003d Token.LP \u0026\u0026 parent.getType() \u003d\u003d Token.FUNCTION, \"We should only declare vars and functions and function args\");\n+            if (toRemove.getType() \u003d\u003d Token.LP \u0026\u0026 parent.getType() \u003d\u003d Token.FUNCTION) {\n+            } else if (toRemove.getType() \u003d\u003d Token.FUNCTION \u0026\u0026 NodeUtil.isFunctionAnonymous(toRemove)) {\n+            } else if (parent !\u003d null \u0026\u0026 parent.getType() \u003d\u003d Token.FOR \u0026\u0026 parent.getChildCount() \u003c 4) {\n+            } else if (toRemove.getType() \u003d\u003d Token.VAR \u0026\u0026 nameNode.hasChildren() \u0026\u0026 NodeUtil.mayHaveSideEffects(nameNode.getFirstChild())) {\n+                if (!warnedVars_.contains(var)) {\n+                    warnedVars_.add(var);\n+                    String inputName \u003d var.input !\u003d null ? var.input.getName() : \"\u003cunknown\u003e\";\n+                    logger_.info(\"Unused var \" + var.name + \" declared in \" + inputName + \" at line \" + toRemove.getLineno() + \" may have side effects and can\u0027t be removed\");\n+                }\n+                if (toRemove.getChildCount() \u003d\u003d 1) {\n+                    parent.replaceChild(toRemove, new Node(Token.EXPR_RESULT, nameNode.removeFirstChild()));\n+                    numRemoved_++;\n+                }\n+            } else if (toRemove.getType() \u003d\u003d Token.VAR \u0026\u0026 toRemove.getChildCount() \u003e 1) {\n+                toRemove.removeChild(nameNode);\n+                numRemoved_++;\n+            } else if (parent !\u003d null) {\n+                NodeUtil.removeChild(parent, toRemove);\n+                numRemoved_++;\n+            }\n+        }\n+    }\n+}\n\\ No newline at end of file\n",
      "actualSource": "private void removeUnreferencedVars(Scope scope) {\n    CodingConvention convention \u003d compiler_.getCodingConvention();\n    for (Iterator\u003cScope.Var\u003e it \u003d scope.getVars(); it.hasNext(); ) {\n        Scope.Var var \u003d it.next();\n        if (!var.referenced \u0026\u0026 (var.isLocal() || !convention.isExported(var.name))) {\n            compiler_.addToDebugLog(\"Unreferenced var: \" + var.name);\n            Node nameNode \u003d var.nameNode;\n            Node toRemove \u003d nameNode.getParent();\n            Node parent \u003d toRemove.getParent();\n            Preconditions.checkState(toRemove.getType() \u003d\u003d Token.VAR || toRemove.getType() \u003d\u003d Token.FUNCTION || toRemove.getType() \u003d\u003d Token.LP \u0026\u0026 parent.getType() \u003d\u003d Token.FUNCTION, \"We should only declare vars and functions and function args\");\n            if (toRemove.getType() \u003d\u003d Token.LP \u0026\u0026 parent.getType() \u003d\u003d Token.FUNCTION) {\n            } else if (toRemove.getType() \u003d\u003d Token.FUNCTION \u0026\u0026 NodeUtil.isFunctionAnonymous(toRemove)) {\n            } else if (parent !\u003d null \u0026\u0026 parent.getType() \u003d\u003d Token.FOR \u0026\u0026 parent.getChildCount() \u003c 4) {\n            } else if (toRemove.getType() \u003d\u003d Token.VAR \u0026\u0026 nameNode.hasChildren() \u0026\u0026 NodeUtil.mayHaveSideEffects(nameNode.getFirstChild())) {\n                if (!warnedVars_.contains(var)) {\n                    warnedVars_.add(var);\n                    String inputName \u003d var.input !\u003d null ? var.input.getName() : \"\u003cunknown\u003e\";\n                    logger_.info(\"Unused var \" + var.name + \" declared in \" + inputName + \" at line \" + toRemove.getLineno() + \" may have side effects and can\u0027t be removed\");\n                }\n                if (toRemove.getChildCount() \u003d\u003d 1) {\n                    parent.replaceChild(toRemove, new Node(Token.EXPR_RESULT, nameNode.removeFirstChild()));\n                    numRemoved_++;\n                }\n            } else if (toRemove.getType() \u003d\u003d Token.VAR \u0026\u0026 toRemove.getChildCount() \u003e 1) {\n                toRemove.removeChild(nameNode);\n                numRemoved_++;\n            } else if (parent !\u003d null) {\n                NodeUtil.removeChild(parent, toRemove);\n                numRemoved_++;\n            }\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/RemoveUnusedVars.java",
      "functionStartLine": 222,
      "functionName": "removeUnreferencedVars",
      "functionAnnotation": "",
      "functionDoc": "Removes any vars in the scope that were not referenced.\n"
    }
  }
}