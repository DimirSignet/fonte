{
  "origin": "codeshovel",
  "repositoryName": "Closure-60b",
  "repositoryPath": "/tmp/Closure-60b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "PeepholeReplaceKnownMethods.java",
  "functionName": "tryFoldArrayJoin",
  "functionId": "tryFoldArrayJoin___n-Node",
  "sourceFilePath": "src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java",
  "functionAnnotation": "",
  "functionDoc": "Try to fold an array join: [\u0027a\u0027, \u0027b\u0027, \u0027c\u0027].join(\u0027\u0027) -\u003e \u0027abc\u0027;\n",
  "functionStartLine": 363,
  "functionEndLine": 468,
  "numCommitsSeen": 76,
  "timeTaken": 6794,
  "changeHistory": [
    "3fc66a99d98015dc798215a666f6b5ad268028c2",
    "653599e7c3922059a78958ea32b216ff9c42800e",
    "8bcffc6d81ab00eaf25a963d8f8b206410fad225",
    "cf3fcbbc124d5b8948d7bef5215c45d80dbeae8e",
    "db7e51f90e44be275b568d0b512e9778d6d6b253",
    "7a1286edcf9328ad70b0afddd552a62d93aad1be",
    "9de5e9b4671773bb3f2d5932e57c1b4186b9b777",
    "c9e89727dc8063d087d28e42629606f4fd74a6e5",
    "43859717972907dd1ecebd8dca6e05036386e28b",
    "113a08f59e8116fb11a7d4ceb11d5bb09b74ac3c",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3"
  ],
  "changeHistoryShort": {
    "3fc66a99d98015dc798215a666f6b5ad268028c2": "Ymovefromfile",
    "653599e7c3922059a78958ea32b216ff9c42800e": "Ybodychange",
    "8bcffc6d81ab00eaf25a963d8f8b206410fad225": "Ybodychange",
    "cf3fcbbc124d5b8948d7bef5215c45d80dbeae8e": "Ybodychange",
    "db7e51f90e44be275b568d0b512e9778d6d6b253": "Ybodychange",
    "7a1286edcf9328ad70b0afddd552a62d93aad1be": "Ymultichange(Yrename,Ybodychange)",
    "9de5e9b4671773bb3f2d5932e57c1b4186b9b777": "Yformatchange",
    "c9e89727dc8063d087d28e42629606f4fd74a6e5": "Ymultichange(Ymovefromfile,Yreturntypechange,Ymodifierchange,Ybodychange,Yparameterchange)",
    "43859717972907dd1ecebd8dca6e05036386e28b": "Ybodychange",
    "113a08f59e8116fb11a7d4ceb11d5bb09b74ac3c": "Ybodychange",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "3fc66a99d98015dc798215a666f6b5ad268028c2": {
      "type": "Ymovefromfile",
      "commitMessage": "\nRefactor out of replace known methods.\n\nR\u003dzhuyi\nDELTA\u003d1555  (825 added, 729 deleted, 1 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d2281\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1180 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "6/14/11, 5:29 PM",
      "commitName": "3fc66a99d98015dc798215a666f6b5ad268028c2",
      "commitAuthor": "acleung@google.com",
      "commitDateOld": "6/14/11, 5:09 PM",
      "commitNameOld": "48aea0ff7d027507362007415963a4b662fb10a7",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private Node tryFoldArrayJoin(Node n) {\n    Node callTarget \u003d n.getFirstChild();\n    if (callTarget \u003d\u003d null || !NodeUtil.isGetProp(callTarget)) {\n        return n;\n    }\n    Node right \u003d callTarget.getNext();\n    if (right !\u003d null \u0026\u0026 !NodeUtil.isImmutableValue(right)) {\n        return n;\n    }\n    Node arrayNode \u003d callTarget.getFirstChild();\n    Node functionName \u003d arrayNode.getNext();\n    if ((arrayNode.getType() !\u003d Token.ARRAYLIT) || !functionName.getString().equals(\"join\")) {\n        return n;\n    }\n    String joinString \u003d (right \u003d\u003d null) ? \",\" : NodeUtil.getStringValue(right);\n    List\u003cNode\u003e arrayFoldedChildren \u003d Lists.newLinkedList();\n    StringBuilder sb \u003d null;\n    int foldedSize \u003d 0;\n    Node prev \u003d null;\n    Node elem \u003d arrayNode.getFirstChild();\n    while (elem !\u003d null) {\n        if (NodeUtil.isImmutableValue(elem) || elem.getType() \u003d\u003d Token.EMPTY) {\n            if (sb \u003d\u003d null) {\n                sb \u003d new StringBuilder();\n            } else {\n                sb.append(joinString);\n            }\n            sb.append(NodeUtil.getArrayElementStringValue(elem));\n        } else {\n            if (sb !\u003d null) {\n                Preconditions.checkNotNull(prev);\n                foldedSize +\u003d sb.length() + 2;\n                arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(prev));\n                sb \u003d null;\n            }\n            foldedSize +\u003d InlineCostEstimator.getCost(elem);\n            arrayFoldedChildren.add(elem);\n        }\n        prev \u003d elem;\n        elem \u003d elem.getNext();\n    }\n    if (sb !\u003d null) {\n        Preconditions.checkNotNull(prev);\n        foldedSize +\u003d sb.length() + 2;\n        arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(prev));\n    }\n    foldedSize +\u003d arrayFoldedChildren.size() - 1;\n    int originalSize \u003d InlineCostEstimator.getCost(n);\n    switch(arrayFoldedChildren.size()) {\n        case 0:\n            Node emptyStringNode \u003d Node.newString(\"\");\n            n.getParent().replaceChild(n, emptyStringNode);\n            reportCodeChange();\n            return emptyStringNode;\n        case 1:\n            Node foldedStringNode \u003d arrayFoldedChildren.remove(0);\n            if (foldedSize \u003e originalSize) {\n                return n;\n            }\n            arrayNode.detachChildren();\n            if (foldedStringNode.getType() !\u003d Token.STRING) {\n                Node replacement \u003d new Node(Token.ADD, Node.newString(\"\").copyInformationFrom(n), foldedStringNode);\n                foldedStringNode \u003d replacement;\n            }\n            n.getParent().replaceChild(n, foldedStringNode);\n            reportCodeChange();\n            return foldedStringNode;\n        default:\n            if (arrayFoldedChildren.size() \u003d\u003d arrayNode.getChildCount()) {\n                return n;\n            }\n            int kJoinOverhead \u003d \"[].join()\".length();\n            foldedSize +\u003d kJoinOverhead;\n            foldedSize +\u003d (right !\u003d null) ? InlineCostEstimator.getCost(right) : 0;\n            if (foldedSize \u003e originalSize) {\n                return n;\n            }\n            arrayNode.detachChildren();\n            for (Node node : arrayFoldedChildren) {\n                arrayNode.addChildToBack(node);\n            }\n            reportCodeChange();\n            break;\n    }\n    return n;\n}",
      "path": "src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java",
      "functionStartLine": 363,
      "functionName": "tryFoldArrayJoin",
      "functionAnnotation": "",
      "functionDoc": "Try to fold an array join: [\u0027a\u0027, \u0027b\u0027, \u0027c\u0027].join(\u0027\u0027) -\u003e \u0027abc\u0027;\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/com/google/javascript/jscomp/PeepholeFoldConstants.java",
        "newPath": "src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java",
        "oldMethodName": "tryFoldArrayJoin",
        "newMethodName": "tryFoldArrayJoin"
      }
    },
    "653599e7c3922059a78958ea32b216ff9c42800e": {
      "type": "Ybodychange",
      "commitMessage": "\nFixup sparse array handling.\n- Replace sparse array annotation with EMPTY nodes.\n- Fix handling of arrays ending with an EMPTY node\n- Fix handling of arrays that are completely empty\n- Support PeepFoldConstant folding of arrays containing EMPTY nodes.\n\nR\u003dacleung\nDELTA\u003d163  (53 added, 92 deleted, 18 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d879\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@887 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "3/15/11, 12:33 PM",
      "commitName": "653599e7c3922059a78958ea32b216ff9c42800e",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "3/8/11, 8:50 AM",
      "commitNameOld": "8bcffc6d81ab00eaf25a963d8f8b206410fad225",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 7.11,
      "commitsBetweenForRepo": 24,
      "commitsBetweenForFile": 1,
      "actualSource": "private Node tryFoldArrayJoin(Node n) {\n    Node callTarget \u003d n.getFirstChild();\n    if (callTarget \u003d\u003d null || !NodeUtil.isGetProp(callTarget)) {\n        return n;\n    }\n    Node right \u003d callTarget.getNext();\n    if (right !\u003d null \u0026\u0026 !NodeUtil.isImmutableValue(right)) {\n        return n;\n    }\n    Node arrayNode \u003d callTarget.getFirstChild();\n    Node functionName \u003d arrayNode.getNext();\n    if ((arrayNode.getType() !\u003d Token.ARRAYLIT) || !functionName.getString().equals(\"join\")) {\n        return n;\n    }\n    String joinString \u003d (right \u003d\u003d null) ? \",\" : NodeUtil.getStringValue(right);\n    List\u003cNode\u003e arrayFoldedChildren \u003d Lists.newLinkedList();\n    StringBuilder sb \u003d null;\n    int foldedSize \u003d 0;\n    Node prev \u003d null;\n    Node elem \u003d arrayNode.getFirstChild();\n    while (elem !\u003d null) {\n        if (NodeUtil.isImmutableValue(elem) || elem.getType() \u003d\u003d Token.EMPTY) {\n            if (sb \u003d\u003d null) {\n                sb \u003d new StringBuilder();\n            } else {\n                sb.append(joinString);\n            }\n            sb.append(NodeUtil.getArrayElementStringValue(elem));\n        } else {\n            if (sb !\u003d null) {\n                Preconditions.checkNotNull(prev);\n                foldedSize +\u003d sb.length() + 2;\n                arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(prev));\n                sb \u003d null;\n            }\n            foldedSize +\u003d InlineCostEstimator.getCost(elem);\n            arrayFoldedChildren.add(elem);\n        }\n        prev \u003d elem;\n        elem \u003d elem.getNext();\n    }\n    if (sb !\u003d null) {\n        Preconditions.checkNotNull(prev);\n        foldedSize +\u003d sb.length() + 2;\n        arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(prev));\n    }\n    foldedSize +\u003d arrayFoldedChildren.size() - 1;\n    int originalSize \u003d InlineCostEstimator.getCost(n);\n    switch(arrayFoldedChildren.size()) {\n        case 0:\n            Node emptyStringNode \u003d Node.newString(\"\");\n            n.getParent().replaceChild(n, emptyStringNode);\n            reportCodeChange();\n            return emptyStringNode;\n        case 1:\n            Node foldedStringNode \u003d arrayFoldedChildren.remove(0);\n            if (foldedSize \u003e originalSize) {\n                return n;\n            }\n            arrayNode.detachChildren();\n            if (foldedStringNode.getType() !\u003d Token.STRING) {\n                Node replacement \u003d new Node(Token.ADD, Node.newString(\"\").copyInformationFrom(n), foldedStringNode);\n                foldedStringNode \u003d replacement;\n            }\n            n.getParent().replaceChild(n, foldedStringNode);\n            reportCodeChange();\n            return foldedStringNode;\n        default:\n            if (arrayFoldedChildren.size() \u003d\u003d arrayNode.getChildCount()) {\n                return n;\n            }\n            int kJoinOverhead \u003d \"[].join()\".length();\n            foldedSize +\u003d kJoinOverhead;\n            foldedSize +\u003d (right !\u003d null) ? InlineCostEstimator.getCost(right) : 0;\n            if (foldedSize \u003e originalSize) {\n                return n;\n            }\n            arrayNode.detachChildren();\n            for (Node node : arrayFoldedChildren) {\n                arrayNode.addChildToBack(node);\n            }\n            reportCodeChange();\n            break;\n    }\n    return n;\n}",
      "path": "src/com/google/javascript/jscomp/PeepholeFoldConstants.java",
      "functionStartLine": 1304,
      "functionName": "tryFoldArrayJoin",
      "functionAnnotation": "",
      "functionDoc": "Try to fold an array join: [\u0027a\u0027, \u0027b\u0027, \u0027c\u0027].join(\u0027\u0027) -\u003e \u0027abc\u0027;\n",
      "diff": "@@ -1,86 +1,86 @@\n private Node tryFoldArrayJoin(Node n) {\n     Node callTarget \u003d n.getFirstChild();\n     if (callTarget \u003d\u003d null || !NodeUtil.isGetProp(callTarget)) {\n         return n;\n     }\n     Node right \u003d callTarget.getNext();\n     if (right !\u003d null \u0026\u0026 !NodeUtil.isImmutableValue(right)) {\n         return n;\n     }\n     Node arrayNode \u003d callTarget.getFirstChild();\n     Node functionName \u003d arrayNode.getNext();\n-    if ((arrayNode.getType() !\u003d Token.ARRAYLIT) || NodeUtil.isSparseArray(arrayNode) || !functionName.getString().equals(\"join\")) {\n+    if ((arrayNode.getType() !\u003d Token.ARRAYLIT) || !functionName.getString().equals(\"join\")) {\n         return n;\n     }\n     String joinString \u003d (right \u003d\u003d null) ? \",\" : NodeUtil.getStringValue(right);\n     List\u003cNode\u003e arrayFoldedChildren \u003d Lists.newLinkedList();\n     StringBuilder sb \u003d null;\n     int foldedSize \u003d 0;\n     Node prev \u003d null;\n     Node elem \u003d arrayNode.getFirstChild();\n     while (elem !\u003d null) {\n-        if (NodeUtil.isImmutableValue(elem)) {\n+        if (NodeUtil.isImmutableValue(elem) || elem.getType() \u003d\u003d Token.EMPTY) {\n             if (sb \u003d\u003d null) {\n                 sb \u003d new StringBuilder();\n             } else {\n                 sb.append(joinString);\n             }\n             sb.append(NodeUtil.getArrayElementStringValue(elem));\n         } else {\n             if (sb !\u003d null) {\n                 Preconditions.checkNotNull(prev);\n                 foldedSize +\u003d sb.length() + 2;\n                 arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(prev));\n                 sb \u003d null;\n             }\n             foldedSize +\u003d InlineCostEstimator.getCost(elem);\n             arrayFoldedChildren.add(elem);\n         }\n         prev \u003d elem;\n         elem \u003d elem.getNext();\n     }\n     if (sb !\u003d null) {\n         Preconditions.checkNotNull(prev);\n         foldedSize +\u003d sb.length() + 2;\n         arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(prev));\n     }\n     foldedSize +\u003d arrayFoldedChildren.size() - 1;\n     int originalSize \u003d InlineCostEstimator.getCost(n);\n     switch(arrayFoldedChildren.size()) {\n         case 0:\n             Node emptyStringNode \u003d Node.newString(\"\");\n             n.getParent().replaceChild(n, emptyStringNode);\n             reportCodeChange();\n             return emptyStringNode;\n         case 1:\n             Node foldedStringNode \u003d arrayFoldedChildren.remove(0);\n             if (foldedSize \u003e originalSize) {\n                 return n;\n             }\n             arrayNode.detachChildren();\n             if (foldedStringNode.getType() !\u003d Token.STRING) {\n                 Node replacement \u003d new Node(Token.ADD, Node.newString(\"\").copyInformationFrom(n), foldedStringNode);\n                 foldedStringNode \u003d replacement;\n             }\n             n.getParent().replaceChild(n, foldedStringNode);\n             reportCodeChange();\n             return foldedStringNode;\n         default:\n             if (arrayFoldedChildren.size() \u003d\u003d arrayNode.getChildCount()) {\n                 return n;\n             }\n             int kJoinOverhead \u003d \"[].join()\".length();\n             foldedSize +\u003d kJoinOverhead;\n             foldedSize +\u003d (right !\u003d null) ? InlineCostEstimator.getCost(right) : 0;\n             if (foldedSize \u003e originalSize) {\n                 return n;\n             }\n             arrayNode.detachChildren();\n             for (Node node : arrayFoldedChildren) {\n                 arrayNode.addChildToBack(node);\n             }\n             reportCodeChange();\n             break;\n     }\n     return n;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8bcffc6d81ab00eaf25a963d8f8b206410fad225": {
      "type": "Ybodychange",
      "commitMessage": "\nFix .join folding blocking the next release.\n\nR\u003dacleung\nDELTA\u003d18  (16 added, 0 deleted, 2 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d799\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@863 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "3/8/11, 8:50 AM",
      "commitName": "8bcffc6d81ab00eaf25a963d8f8b206410fad225",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "2/16/11, 1:24 PM",
      "commitNameOld": "fc66128defd24dd67a02b1bdd87d1968126f02ea",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 19.81,
      "commitsBetweenForRepo": 69,
      "commitsBetweenForFile": 1,
      "actualSource": "private Node tryFoldArrayJoin(Node n) {\n    Node callTarget \u003d n.getFirstChild();\n    if (callTarget \u003d\u003d null || !NodeUtil.isGetProp(callTarget)) {\n        return n;\n    }\n    Node right \u003d callTarget.getNext();\n    if (right !\u003d null \u0026\u0026 !NodeUtil.isImmutableValue(right)) {\n        return n;\n    }\n    Node arrayNode \u003d callTarget.getFirstChild();\n    Node functionName \u003d arrayNode.getNext();\n    if ((arrayNode.getType() !\u003d Token.ARRAYLIT) || NodeUtil.isSparseArray(arrayNode) || !functionName.getString().equals(\"join\")) {\n        return n;\n    }\n    String joinString \u003d (right \u003d\u003d null) ? \",\" : NodeUtil.getStringValue(right);\n    List\u003cNode\u003e arrayFoldedChildren \u003d Lists.newLinkedList();\n    StringBuilder sb \u003d null;\n    int foldedSize \u003d 0;\n    Node prev \u003d null;\n    Node elem \u003d arrayNode.getFirstChild();\n    while (elem !\u003d null) {\n        if (NodeUtil.isImmutableValue(elem)) {\n            if (sb \u003d\u003d null) {\n                sb \u003d new StringBuilder();\n            } else {\n                sb.append(joinString);\n            }\n            sb.append(NodeUtil.getArrayElementStringValue(elem));\n        } else {\n            if (sb !\u003d null) {\n                Preconditions.checkNotNull(prev);\n                foldedSize +\u003d sb.length() + 2;\n                arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(prev));\n                sb \u003d null;\n            }\n            foldedSize +\u003d InlineCostEstimator.getCost(elem);\n            arrayFoldedChildren.add(elem);\n        }\n        prev \u003d elem;\n        elem \u003d elem.getNext();\n    }\n    if (sb !\u003d null) {\n        Preconditions.checkNotNull(prev);\n        foldedSize +\u003d sb.length() + 2;\n        arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(prev));\n    }\n    foldedSize +\u003d arrayFoldedChildren.size() - 1;\n    int originalSize \u003d InlineCostEstimator.getCost(n);\n    switch(arrayFoldedChildren.size()) {\n        case 0:\n            Node emptyStringNode \u003d Node.newString(\"\");\n            n.getParent().replaceChild(n, emptyStringNode);\n            reportCodeChange();\n            return emptyStringNode;\n        case 1:\n            Node foldedStringNode \u003d arrayFoldedChildren.remove(0);\n            if (foldedSize \u003e originalSize) {\n                return n;\n            }\n            arrayNode.detachChildren();\n            if (foldedStringNode.getType() !\u003d Token.STRING) {\n                Node replacement \u003d new Node(Token.ADD, Node.newString(\"\").copyInformationFrom(n), foldedStringNode);\n                foldedStringNode \u003d replacement;\n            }\n            n.getParent().replaceChild(n, foldedStringNode);\n            reportCodeChange();\n            return foldedStringNode;\n        default:\n            if (arrayFoldedChildren.size() \u003d\u003d arrayNode.getChildCount()) {\n                return n;\n            }\n            int kJoinOverhead \u003d \"[].join()\".length();\n            foldedSize +\u003d kJoinOverhead;\n            foldedSize +\u003d (right !\u003d null) ? InlineCostEstimator.getCost(right) : 0;\n            if (foldedSize \u003e originalSize) {\n                return n;\n            }\n            arrayNode.detachChildren();\n            for (Node node : arrayFoldedChildren) {\n                arrayNode.addChildToBack(node);\n            }\n            reportCodeChange();\n            break;\n    }\n    return n;\n}",
      "path": "src/com/google/javascript/jscomp/PeepholeFoldConstants.java",
      "functionStartLine": 1304,
      "functionName": "tryFoldArrayJoin",
      "functionAnnotation": "",
      "functionDoc": "Try to fold an array join: [\u0027a\u0027, \u0027b\u0027, \u0027c\u0027].join(\u0027\u0027) -\u003e \u0027abc\u0027;\n",
      "diff": "@@ -1,86 +1,86 @@\n private Node tryFoldArrayJoin(Node n) {\n     Node callTarget \u003d n.getFirstChild();\n     if (callTarget \u003d\u003d null || !NodeUtil.isGetProp(callTarget)) {\n         return n;\n     }\n     Node right \u003d callTarget.getNext();\n     if (right !\u003d null \u0026\u0026 !NodeUtil.isImmutableValue(right)) {\n         return n;\n     }\n     Node arrayNode \u003d callTarget.getFirstChild();\n     Node functionName \u003d arrayNode.getNext();\n     if ((arrayNode.getType() !\u003d Token.ARRAYLIT) || NodeUtil.isSparseArray(arrayNode) || !functionName.getString().equals(\"join\")) {\n         return n;\n     }\n     String joinString \u003d (right \u003d\u003d null) ? \",\" : NodeUtil.getStringValue(right);\n     List\u003cNode\u003e arrayFoldedChildren \u003d Lists.newLinkedList();\n     StringBuilder sb \u003d null;\n     int foldedSize \u003d 0;\n     Node prev \u003d null;\n     Node elem \u003d arrayNode.getFirstChild();\n     while (elem !\u003d null) {\n         if (NodeUtil.isImmutableValue(elem)) {\n             if (sb \u003d\u003d null) {\n                 sb \u003d new StringBuilder();\n             } else {\n                 sb.append(joinString);\n             }\n             sb.append(NodeUtil.getArrayElementStringValue(elem));\n         } else {\n             if (sb !\u003d null) {\n                 Preconditions.checkNotNull(prev);\n                 foldedSize +\u003d sb.length() + 2;\n                 arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(prev));\n                 sb \u003d null;\n             }\n             foldedSize +\u003d InlineCostEstimator.getCost(elem);\n             arrayFoldedChildren.add(elem);\n         }\n         prev \u003d elem;\n         elem \u003d elem.getNext();\n     }\n     if (sb !\u003d null) {\n         Preconditions.checkNotNull(prev);\n         foldedSize +\u003d sb.length() + 2;\n         arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(prev));\n     }\n     foldedSize +\u003d arrayFoldedChildren.size() - 1;\n     int originalSize \u003d InlineCostEstimator.getCost(n);\n     switch(arrayFoldedChildren.size()) {\n         case 0:\n             Node emptyStringNode \u003d Node.newString(\"\");\n             n.getParent().replaceChild(n, emptyStringNode);\n             reportCodeChange();\n             return emptyStringNode;\n         case 1:\n             Node foldedStringNode \u003d arrayFoldedChildren.remove(0);\n             if (foldedSize \u003e originalSize) {\n                 return n;\n             }\n             arrayNode.detachChildren();\n             if (foldedStringNode.getType() !\u003d Token.STRING) {\n-                Node replacement \u003d new Node(Token.ADD, Node.newString(\"\").copyInformationFrom(right), foldedStringNode);\n+                Node replacement \u003d new Node(Token.ADD, Node.newString(\"\").copyInformationFrom(n), foldedStringNode);\n                 foldedStringNode \u003d replacement;\n             }\n             n.getParent().replaceChild(n, foldedStringNode);\n             reportCodeChange();\n             return foldedStringNode;\n         default:\n             if (arrayFoldedChildren.size() \u003d\u003d arrayNode.getChildCount()) {\n                 return n;\n             }\n             int kJoinOverhead \u003d \"[].join()\".length();\n             foldedSize +\u003d kJoinOverhead;\n-            foldedSize +\u003d InlineCostEstimator.getCost(right);\n+            foldedSize +\u003d (right !\u003d null) ? InlineCostEstimator.getCost(right) : 0;\n             if (foldedSize \u003e originalSize) {\n                 return n;\n             }\n             arrayNode.detachChildren();\n             for (Node node : arrayFoldedChildren) {\n                 arrayNode.addChildToBack(node);\n             }\n             reportCodeChange();\n             break;\n     }\n     return n;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "cf3fcbbc124d5b8948d7bef5215c45d80dbeae8e": {
      "type": "Ybodychange",
      "commitMessage": "\nCorrect handling of sparse arrays.\n\nR\u003dnicksantos\nDELTA\u003d37  (28 added, 2 deleted, 7 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d529\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@785 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "2/15/11, 1:06 PM",
      "commitName": "cf3fcbbc124d5b8948d7bef5215c45d80dbeae8e",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "2/15/11, 10:52 AM",
      "commitNameOld": "db7e51f90e44be275b568d0b512e9778d6d6b253",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 0.09,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "private Node tryFoldArrayJoin(Node n) {\n    Node callTarget \u003d n.getFirstChild();\n    if (callTarget \u003d\u003d null || !NodeUtil.isGetProp(callTarget)) {\n        return n;\n    }\n    Node right \u003d callTarget.getNext();\n    if (right !\u003d null \u0026\u0026 !NodeUtil.isImmutableValue(right)) {\n        return n;\n    }\n    Node arrayNode \u003d callTarget.getFirstChild();\n    Node functionName \u003d arrayNode.getNext();\n    if ((arrayNode.getType() !\u003d Token.ARRAYLIT) || NodeUtil.isSparseArray(arrayNode) || !functionName.getString().equals(\"join\")) {\n        return n;\n    }\n    String joinString \u003d (right \u003d\u003d null) ? \",\" : NodeUtil.getStringValue(right);\n    List\u003cNode\u003e arrayFoldedChildren \u003d Lists.newLinkedList();\n    StringBuilder sb \u003d null;\n    int foldedSize \u003d 0;\n    Node prev \u003d null;\n    Node elem \u003d arrayNode.getFirstChild();\n    while (elem !\u003d null) {\n        if (NodeUtil.isImmutableValue(elem)) {\n            if (sb \u003d\u003d null) {\n                sb \u003d new StringBuilder();\n            } else {\n                sb.append(joinString);\n            }\n            sb.append(NodeUtil.getArrayElementStringValue(elem));\n        } else {\n            if (sb !\u003d null) {\n                Preconditions.checkNotNull(prev);\n                foldedSize +\u003d sb.length() + 2;\n                arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(prev));\n                sb \u003d null;\n            }\n            foldedSize +\u003d InlineCostEstimator.getCost(elem);\n            arrayFoldedChildren.add(elem);\n        }\n        prev \u003d elem;\n        elem \u003d elem.getNext();\n    }\n    if (sb !\u003d null) {\n        Preconditions.checkNotNull(prev);\n        foldedSize +\u003d sb.length() + 2;\n        arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(prev));\n    }\n    foldedSize +\u003d arrayFoldedChildren.size() - 1;\n    int originalSize \u003d InlineCostEstimator.getCost(n);\n    switch(arrayFoldedChildren.size()) {\n        case 0:\n            Node emptyStringNode \u003d Node.newString(\"\");\n            n.getParent().replaceChild(n, emptyStringNode);\n            reportCodeChange();\n            return emptyStringNode;\n        case 1:\n            Node foldedStringNode \u003d arrayFoldedChildren.remove(0);\n            if (foldedSize \u003e originalSize) {\n                return n;\n            }\n            arrayNode.detachChildren();\n            if (foldedStringNode.getType() !\u003d Token.STRING) {\n                Node replacement \u003d new Node(Token.ADD, Node.newString(\"\").copyInformationFrom(right), foldedStringNode);\n                foldedStringNode \u003d replacement;\n            }\n            n.getParent().replaceChild(n, foldedStringNode);\n            reportCodeChange();\n            return foldedStringNode;\n        default:\n            if (arrayFoldedChildren.size() \u003d\u003d arrayNode.getChildCount()) {\n                return n;\n            }\n            int kJoinOverhead \u003d \"[].join()\".length();\n            foldedSize +\u003d kJoinOverhead;\n            foldedSize +\u003d InlineCostEstimator.getCost(right);\n            if (foldedSize \u003e originalSize) {\n                return n;\n            }\n            arrayNode.detachChildren();\n            for (Node node : arrayFoldedChildren) {\n                arrayNode.addChildToBack(node);\n            }\n            reportCodeChange();\n            break;\n    }\n    return n;\n}",
      "path": "src/com/google/javascript/jscomp/PeepholeFoldConstants.java",
      "functionStartLine": 1290,
      "functionName": "tryFoldArrayJoin",
      "functionAnnotation": "",
      "functionDoc": "Try to fold an array join: [\u0027a\u0027, \u0027b\u0027, \u0027c\u0027].join(\u0027\u0027) -\u003e \u0027abc\u0027;\n",
      "diff": "@@ -1,86 +1,86 @@\n private Node tryFoldArrayJoin(Node n) {\n     Node callTarget \u003d n.getFirstChild();\n     if (callTarget \u003d\u003d null || !NodeUtil.isGetProp(callTarget)) {\n         return n;\n     }\n     Node right \u003d callTarget.getNext();\n     if (right !\u003d null \u0026\u0026 !NodeUtil.isImmutableValue(right)) {\n         return n;\n     }\n     Node arrayNode \u003d callTarget.getFirstChild();\n     Node functionName \u003d arrayNode.getNext();\n-    if ((arrayNode.getType() !\u003d Token.ARRAYLIT) || !functionName.getString().equals(\"join\")) {\n+    if ((arrayNode.getType() !\u003d Token.ARRAYLIT) || NodeUtil.isSparseArray(arrayNode) || !functionName.getString().equals(\"join\")) {\n         return n;\n     }\n     String joinString \u003d (right \u003d\u003d null) ? \",\" : NodeUtil.getStringValue(right);\n     List\u003cNode\u003e arrayFoldedChildren \u003d Lists.newLinkedList();\n     StringBuilder sb \u003d null;\n     int foldedSize \u003d 0;\n     Node prev \u003d null;\n     Node elem \u003d arrayNode.getFirstChild();\n     while (elem !\u003d null) {\n         if (NodeUtil.isImmutableValue(elem)) {\n             if (sb \u003d\u003d null) {\n                 sb \u003d new StringBuilder();\n             } else {\n                 sb.append(joinString);\n             }\n             sb.append(NodeUtil.getArrayElementStringValue(elem));\n         } else {\n             if (sb !\u003d null) {\n                 Preconditions.checkNotNull(prev);\n                 foldedSize +\u003d sb.length() + 2;\n                 arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(prev));\n                 sb \u003d null;\n             }\n             foldedSize +\u003d InlineCostEstimator.getCost(elem);\n             arrayFoldedChildren.add(elem);\n         }\n         prev \u003d elem;\n         elem \u003d elem.getNext();\n     }\n     if (sb !\u003d null) {\n         Preconditions.checkNotNull(prev);\n         foldedSize +\u003d sb.length() + 2;\n         arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(prev));\n     }\n     foldedSize +\u003d arrayFoldedChildren.size() - 1;\n     int originalSize \u003d InlineCostEstimator.getCost(n);\n     switch(arrayFoldedChildren.size()) {\n         case 0:\n             Node emptyStringNode \u003d Node.newString(\"\");\n             n.getParent().replaceChild(n, emptyStringNode);\n             reportCodeChange();\n             return emptyStringNode;\n         case 1:\n             Node foldedStringNode \u003d arrayFoldedChildren.remove(0);\n             if (foldedSize \u003e originalSize) {\n                 return n;\n             }\n             arrayNode.detachChildren();\n             if (foldedStringNode.getType() !\u003d Token.STRING) {\n                 Node replacement \u003d new Node(Token.ADD, Node.newString(\"\").copyInformationFrom(right), foldedStringNode);\n                 foldedStringNode \u003d replacement;\n             }\n             n.getParent().replaceChild(n, foldedStringNode);\n             reportCodeChange();\n             return foldedStringNode;\n         default:\n             if (arrayFoldedChildren.size() \u003d\u003d arrayNode.getChildCount()) {\n                 return n;\n             }\n             int kJoinOverhead \u003d \"[].join()\".length();\n             foldedSize +\u003d kJoinOverhead;\n             foldedSize +\u003d InlineCostEstimator.getCost(right);\n             if (foldedSize \u003e originalSize) {\n                 return n;\n             }\n             arrayNode.detachChildren();\n             for (Node node : arrayFoldedChildren) {\n                 arrayNode.addChildToBack(node);\n             }\n             reportCodeChange();\n             break;\n     }\n     return n;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "db7e51f90e44be275b568d0b512e9778d6d6b253": {
      "type": "Ybodychange",
      "commitMessage": "\nFix issue with improper join of strings containing null and undefined.\nDefine a method for converting array literals to strings.\n\nR\u003dacleung\nDELTA\u003d174  (122 added, 38 deleted, 14 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d522\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@783 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "2/15/11, 10:52 AM",
      "commitName": "db7e51f90e44be275b568d0b512e9778d6d6b253",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "2/10/11, 4:32 PM",
      "commitNameOld": "e7ce7f710e1bf297f1a4258b53f22f550fc1f2e3",
      "commitAuthorOld": "acleung@google.com",
      "daysBetweenCommits": 4.76,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "private Node tryFoldArrayJoin(Node n) {\n    Node callTarget \u003d n.getFirstChild();\n    if (callTarget \u003d\u003d null || !NodeUtil.isGetProp(callTarget)) {\n        return n;\n    }\n    Node right \u003d callTarget.getNext();\n    if (right !\u003d null \u0026\u0026 !NodeUtil.isImmutableValue(right)) {\n        return n;\n    }\n    Node arrayNode \u003d callTarget.getFirstChild();\n    Node functionName \u003d arrayNode.getNext();\n    if ((arrayNode.getType() !\u003d Token.ARRAYLIT) || !functionName.getString().equals(\"join\")) {\n        return n;\n    }\n    String joinString \u003d (right \u003d\u003d null) ? \",\" : NodeUtil.getStringValue(right);\n    List\u003cNode\u003e arrayFoldedChildren \u003d Lists.newLinkedList();\n    StringBuilder sb \u003d null;\n    int foldedSize \u003d 0;\n    Node prev \u003d null;\n    Node elem \u003d arrayNode.getFirstChild();\n    while (elem !\u003d null) {\n        if (NodeUtil.isImmutableValue(elem)) {\n            if (sb \u003d\u003d null) {\n                sb \u003d new StringBuilder();\n            } else {\n                sb.append(joinString);\n            }\n            sb.append(NodeUtil.getArrayElementStringValue(elem));\n        } else {\n            if (sb !\u003d null) {\n                Preconditions.checkNotNull(prev);\n                foldedSize +\u003d sb.length() + 2;\n                arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(prev));\n                sb \u003d null;\n            }\n            foldedSize +\u003d InlineCostEstimator.getCost(elem);\n            arrayFoldedChildren.add(elem);\n        }\n        prev \u003d elem;\n        elem \u003d elem.getNext();\n    }\n    if (sb !\u003d null) {\n        Preconditions.checkNotNull(prev);\n        foldedSize +\u003d sb.length() + 2;\n        arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(prev));\n    }\n    foldedSize +\u003d arrayFoldedChildren.size() - 1;\n    int originalSize \u003d InlineCostEstimator.getCost(n);\n    switch(arrayFoldedChildren.size()) {\n        case 0:\n            Node emptyStringNode \u003d Node.newString(\"\");\n            n.getParent().replaceChild(n, emptyStringNode);\n            reportCodeChange();\n            return emptyStringNode;\n        case 1:\n            Node foldedStringNode \u003d arrayFoldedChildren.remove(0);\n            if (foldedSize \u003e originalSize) {\n                return n;\n            }\n            arrayNode.detachChildren();\n            if (foldedStringNode.getType() !\u003d Token.STRING) {\n                Node replacement \u003d new Node(Token.ADD, Node.newString(\"\").copyInformationFrom(right), foldedStringNode);\n                foldedStringNode \u003d replacement;\n            }\n            n.getParent().replaceChild(n, foldedStringNode);\n            reportCodeChange();\n            return foldedStringNode;\n        default:\n            if (arrayFoldedChildren.size() \u003d\u003d arrayNode.getChildCount()) {\n                return n;\n            }\n            int kJoinOverhead \u003d \"[].join()\".length();\n            foldedSize +\u003d kJoinOverhead;\n            foldedSize +\u003d InlineCostEstimator.getCost(right);\n            if (foldedSize \u003e originalSize) {\n                return n;\n            }\n            arrayNode.detachChildren();\n            for (Node node : arrayFoldedChildren) {\n                arrayNode.addChildToBack(node);\n            }\n            reportCodeChange();\n            break;\n    }\n    return n;\n}",
      "path": "src/com/google/javascript/jscomp/PeepholeFoldConstants.java",
      "functionStartLine": 1290,
      "functionName": "tryFoldArrayJoin",
      "functionAnnotation": "",
      "functionDoc": "Try to fold an array join: [\u0027a\u0027, \u0027b\u0027, \u0027c\u0027].join(\u0027\u0027) -\u003e \u0027abc\u0027;\n",
      "diff": "@@ -1,89 +1,86 @@\n private Node tryFoldArrayJoin(Node n) {\n     Node callTarget \u003d n.getFirstChild();\n-    if (callTarget \u003d\u003d null) {\n+    if (callTarget \u003d\u003d null || !NodeUtil.isGetProp(callTarget)) {\n         return n;\n     }\n     Node right \u003d callTarget.getNext();\n-    if (right \u003d\u003d null) {\n-        return n;\n-    }\n-    if (!NodeUtil.isGetProp(callTarget) || !NodeUtil.isImmutableValue(right)) {\n+    if (right !\u003d null \u0026\u0026 !NodeUtil.isImmutableValue(right)) {\n         return n;\n     }\n     Node arrayNode \u003d callTarget.getFirstChild();\n     Node functionName \u003d arrayNode.getNext();\n     if ((arrayNode.getType() !\u003d Token.ARRAYLIT) || !functionName.getString().equals(\"join\")) {\n         return n;\n     }\n-    String joinString \u003d NodeUtil.getStringValue(right);\n+    String joinString \u003d (right \u003d\u003d null) ? \",\" : NodeUtil.getStringValue(right);\n     List\u003cNode\u003e arrayFoldedChildren \u003d Lists.newLinkedList();\n     StringBuilder sb \u003d null;\n     int foldedSize \u003d 0;\n     Node prev \u003d null;\n     Node elem \u003d arrayNode.getFirstChild();\n     while (elem !\u003d null) {\n         if (NodeUtil.isImmutableValue(elem)) {\n             if (sb \u003d\u003d null) {\n                 sb \u003d new StringBuilder();\n             } else {\n                 sb.append(joinString);\n             }\n-            sb.append(NodeUtil.getStringValue(elem));\n+            sb.append(NodeUtil.getArrayElementStringValue(elem));\n         } else {\n             if (sb !\u003d null) {\n                 Preconditions.checkNotNull(prev);\n                 foldedSize +\u003d sb.length() + 2;\n                 arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(prev));\n                 sb \u003d null;\n             }\n             foldedSize +\u003d InlineCostEstimator.getCost(elem);\n             arrayFoldedChildren.add(elem);\n         }\n         prev \u003d elem;\n         elem \u003d elem.getNext();\n     }\n     if (sb !\u003d null) {\n         Preconditions.checkNotNull(prev);\n         foldedSize +\u003d sb.length() + 2;\n         arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(prev));\n     }\n     foldedSize +\u003d arrayFoldedChildren.size() - 1;\n     int originalSize \u003d InlineCostEstimator.getCost(n);\n     switch(arrayFoldedChildren.size()) {\n         case 0:\n             Node emptyStringNode \u003d Node.newString(\"\");\n             n.getParent().replaceChild(n, emptyStringNode);\n             reportCodeChange();\n             return emptyStringNode;\n         case 1:\n             Node foldedStringNode \u003d arrayFoldedChildren.remove(0);\n             if (foldedSize \u003e originalSize) {\n                 return n;\n             }\n             arrayNode.detachChildren();\n             if (foldedStringNode.getType() !\u003d Token.STRING) {\n                 Node replacement \u003d new Node(Token.ADD, Node.newString(\"\").copyInformationFrom(right), foldedStringNode);\n                 foldedStringNode \u003d replacement;\n             }\n             n.getParent().replaceChild(n, foldedStringNode);\n             reportCodeChange();\n             return foldedStringNode;\n         default:\n             if (arrayFoldedChildren.size() \u003d\u003d arrayNode.getChildCount()) {\n                 return n;\n             }\n             int kJoinOverhead \u003d \"[].join()\".length();\n             foldedSize +\u003d kJoinOverhead;\n             foldedSize +\u003d InlineCostEstimator.getCost(right);\n             if (foldedSize \u003e originalSize) {\n                 return n;\n             }\n             arrayNode.detachChildren();\n             for (Node node : arrayFoldedChildren) {\n                 arrayNode.addChildToBack(node);\n             }\n             reportCodeChange();\n             break;\n     }\n     return n;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7a1286edcf9328ad70b0afddd552a62d93aad1be": {
      "type": "Ymultichange(Yrename,Ybodychange)",
      "commitMessage": "\nFold String::substr and String::stribtring.\nContributed by Tim Wintle.\nFixes issue 239.\nCode review at:\nhttp://codereview.appspot.com/2240041\n\nRevision created by MOE tool push_codebase.\n\nR\u003djohnlenz\nDELTA\u003d227  (181 added, 25 deleted, 21 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d238142\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@446 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "9/20/10, 5:32 PM",
      "commitName": "7a1286edcf9328ad70b0afddd552a62d93aad1be",
      "commitAuthor": "nicksantos@google.com",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "\nFold String::substr and String::stribtring.\nContributed by Tim Wintle.\nFixes issue 239.\nCode review at:\nhttp://codereview.appspot.com/2240041\n\nRevision created by MOE tool push_codebase.\n\nR\u003djohnlenz\nDELTA\u003d227  (181 added, 25 deleted, 21 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d238142\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@446 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "9/20/10, 5:32 PM",
          "commitName": "7a1286edcf9328ad70b0afddd552a62d93aad1be",
          "commitAuthor": "nicksantos@google.com",
          "commitDateOld": "9/15/10, 2:45 PM",
          "commitNameOld": "edc9ea8c17c95cbf32d2373fa7bf8c4dec614326",
          "commitAuthorOld": "nicksantos@google.com",
          "daysBetweenCommits": 5.12,
          "commitsBetweenForRepo": 12,
          "commitsBetweenForFile": 1,
          "actualSource": "private Node tryFoldArrayJoin(Node n) {\n    Node callTarget \u003d n.getFirstChild();\n    if (callTarget \u003d\u003d null) {\n        return n;\n    }\n    Node right \u003d callTarget.getNext();\n    if (right \u003d\u003d null) {\n        return n;\n    }\n    if (!NodeUtil.isGetProp(callTarget) || !NodeUtil.isImmutableValue(right)) {\n        return n;\n    }\n    Node arrayNode \u003d callTarget.getFirstChild();\n    Node functionName \u003d arrayNode.getNext();\n    if ((arrayNode.getType() !\u003d Token.ARRAYLIT) || !functionName.getString().equals(\"join\")) {\n        return n;\n    }\n    String joinString \u003d NodeUtil.getStringValue(right);\n    List\u003cNode\u003e arrayFoldedChildren \u003d Lists.newLinkedList();\n    StringBuilder sb \u003d null;\n    int foldedSize \u003d 0;\n    Node prev \u003d null;\n    Node elem \u003d arrayNode.getFirstChild();\n    while (elem !\u003d null) {\n        if (NodeUtil.isImmutableValue(elem)) {\n            if (sb \u003d\u003d null) {\n                sb \u003d new StringBuilder();\n            } else {\n                sb.append(joinString);\n            }\n            sb.append(NodeUtil.getStringValue(elem));\n        } else {\n            if (sb !\u003d null) {\n                Preconditions.checkNotNull(prev);\n                foldedSize +\u003d sb.length() + 2;\n                arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(prev));\n                sb \u003d null;\n            }\n            foldedSize +\u003d InlineCostEstimator.getCost(elem);\n            arrayFoldedChildren.add(elem);\n        }\n        prev \u003d elem;\n        elem \u003d elem.getNext();\n    }\n    if (sb !\u003d null) {\n        Preconditions.checkNotNull(prev);\n        foldedSize +\u003d sb.length() + 2;\n        arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(prev));\n    }\n    foldedSize +\u003d arrayFoldedChildren.size() - 1;\n    int originalSize \u003d InlineCostEstimator.getCost(n);\n    switch(arrayFoldedChildren.size()) {\n        case 0:\n            Node emptyStringNode \u003d Node.newString(\"\");\n            n.getParent().replaceChild(n, emptyStringNode);\n            reportCodeChange();\n            return emptyStringNode;\n        case 1:\n            Node foldedStringNode \u003d arrayFoldedChildren.remove(0);\n            if (foldedSize \u003e originalSize) {\n                return n;\n            }\n            arrayNode.detachChildren();\n            if (foldedStringNode.getType() !\u003d Token.STRING) {\n                Node replacement \u003d new Node(Token.ADD, Node.newString(\"\").copyInformationFrom(right), foldedStringNode);\n                foldedStringNode \u003d replacement;\n            }\n            n.getParent().replaceChild(n, foldedStringNode);\n            reportCodeChange();\n            return foldedStringNode;\n        default:\n            if (arrayFoldedChildren.size() \u003d\u003d arrayNode.getChildCount()) {\n                return n;\n            }\n            int kJoinOverhead \u003d \"[].join()\".length();\n            foldedSize +\u003d kJoinOverhead;\n            foldedSize +\u003d InlineCostEstimator.getCost(right);\n            if (foldedSize \u003e originalSize) {\n                return n;\n            }\n            arrayNode.detachChildren();\n            for (Node node : arrayFoldedChildren) {\n                arrayNode.addChildToBack(node);\n            }\n            reportCodeChange();\n            break;\n    }\n    return n;\n}",
          "path": "src/com/google/javascript/jscomp/PeepholeFoldConstants.java",
          "functionStartLine": 1078,
          "functionName": "tryFoldArrayJoin",
          "functionAnnotation": "",
          "functionDoc": "Try to fold an array join: [\u0027a\u0027, \u0027b\u0027, \u0027c\u0027].join(\u0027\u0027) -\u003e \u0027abc\u0027;\n",
          "diff": "@@ -1,89 +1,89 @@\n-private Node tryFoldStringJoin(Node n) {\n-    Node left \u003d n.getFirstChild();\n-    if (left \u003d\u003d null) {\n+private Node tryFoldArrayJoin(Node n) {\n+    Node callTarget \u003d n.getFirstChild();\n+    if (callTarget \u003d\u003d null) {\n         return n;\n     }\n-    Node right \u003d left.getNext();\n+    Node right \u003d callTarget.getNext();\n     if (right \u003d\u003d null) {\n         return n;\n     }\n-    if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {\n+    if (!NodeUtil.isGetProp(callTarget) || !NodeUtil.isImmutableValue(right)) {\n         return n;\n     }\n-    Node arrayNode \u003d left.getFirstChild();\n+    Node arrayNode \u003d callTarget.getFirstChild();\n     Node functionName \u003d arrayNode.getNext();\n     if ((arrayNode.getType() !\u003d Token.ARRAYLIT) || !functionName.getString().equals(\"join\")) {\n         return n;\n     }\n     String joinString \u003d NodeUtil.getStringValue(right);\n     List\u003cNode\u003e arrayFoldedChildren \u003d Lists.newLinkedList();\n     StringBuilder sb \u003d null;\n     int foldedSize \u003d 0;\n     Node prev \u003d null;\n     Node elem \u003d arrayNode.getFirstChild();\n     while (elem !\u003d null) {\n         if (NodeUtil.isImmutableValue(elem)) {\n             if (sb \u003d\u003d null) {\n                 sb \u003d new StringBuilder();\n             } else {\n                 sb.append(joinString);\n             }\n             sb.append(NodeUtil.getStringValue(elem));\n         } else {\n             if (sb !\u003d null) {\n                 Preconditions.checkNotNull(prev);\n                 foldedSize +\u003d sb.length() + 2;\n                 arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(prev));\n                 sb \u003d null;\n             }\n             foldedSize +\u003d InlineCostEstimator.getCost(elem);\n             arrayFoldedChildren.add(elem);\n         }\n         prev \u003d elem;\n         elem \u003d elem.getNext();\n     }\n     if (sb !\u003d null) {\n         Preconditions.checkNotNull(prev);\n         foldedSize +\u003d sb.length() + 2;\n         arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(prev));\n     }\n     foldedSize +\u003d arrayFoldedChildren.size() - 1;\n     int originalSize \u003d InlineCostEstimator.getCost(n);\n     switch(arrayFoldedChildren.size()) {\n         case 0:\n             Node emptyStringNode \u003d Node.newString(\"\");\n             n.getParent().replaceChild(n, emptyStringNode);\n             reportCodeChange();\n             return emptyStringNode;\n         case 1:\n             Node foldedStringNode \u003d arrayFoldedChildren.remove(0);\n             if (foldedSize \u003e originalSize) {\n                 return n;\n             }\n             arrayNode.detachChildren();\n             if (foldedStringNode.getType() !\u003d Token.STRING) {\n                 Node replacement \u003d new Node(Token.ADD, Node.newString(\"\").copyInformationFrom(right), foldedStringNode);\n                 foldedStringNode \u003d replacement;\n             }\n             n.getParent().replaceChild(n, foldedStringNode);\n             reportCodeChange();\n             return foldedStringNode;\n         default:\n             if (arrayFoldedChildren.size() \u003d\u003d arrayNode.getChildCount()) {\n                 return n;\n             }\n             int kJoinOverhead \u003d \"[].join()\".length();\n             foldedSize +\u003d kJoinOverhead;\n             foldedSize +\u003d InlineCostEstimator.getCost(right);\n             if (foldedSize \u003e originalSize) {\n                 return n;\n             }\n             arrayNode.detachChildren();\n             for (Node node : arrayFoldedChildren) {\n                 arrayNode.addChildToBack(node);\n             }\n             reportCodeChange();\n             break;\n     }\n     return n;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "tryFoldStringJoin",
            "newValue": "tryFoldArrayJoin"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "\nFold String::substr and String::stribtring.\nContributed by Tim Wintle.\nFixes issue 239.\nCode review at:\nhttp://codereview.appspot.com/2240041\n\nRevision created by MOE tool push_codebase.\n\nR\u003djohnlenz\nDELTA\u003d227  (181 added, 25 deleted, 21 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d238142\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@446 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "9/20/10, 5:32 PM",
          "commitName": "7a1286edcf9328ad70b0afddd552a62d93aad1be",
          "commitAuthor": "nicksantos@google.com",
          "commitDateOld": "9/15/10, 2:45 PM",
          "commitNameOld": "edc9ea8c17c95cbf32d2373fa7bf8c4dec614326",
          "commitAuthorOld": "nicksantos@google.com",
          "daysBetweenCommits": 5.12,
          "commitsBetweenForRepo": 12,
          "commitsBetweenForFile": 1,
          "actualSource": "private Node tryFoldArrayJoin(Node n) {\n    Node callTarget \u003d n.getFirstChild();\n    if (callTarget \u003d\u003d null) {\n        return n;\n    }\n    Node right \u003d callTarget.getNext();\n    if (right \u003d\u003d null) {\n        return n;\n    }\n    if (!NodeUtil.isGetProp(callTarget) || !NodeUtil.isImmutableValue(right)) {\n        return n;\n    }\n    Node arrayNode \u003d callTarget.getFirstChild();\n    Node functionName \u003d arrayNode.getNext();\n    if ((arrayNode.getType() !\u003d Token.ARRAYLIT) || !functionName.getString().equals(\"join\")) {\n        return n;\n    }\n    String joinString \u003d NodeUtil.getStringValue(right);\n    List\u003cNode\u003e arrayFoldedChildren \u003d Lists.newLinkedList();\n    StringBuilder sb \u003d null;\n    int foldedSize \u003d 0;\n    Node prev \u003d null;\n    Node elem \u003d arrayNode.getFirstChild();\n    while (elem !\u003d null) {\n        if (NodeUtil.isImmutableValue(elem)) {\n            if (sb \u003d\u003d null) {\n                sb \u003d new StringBuilder();\n            } else {\n                sb.append(joinString);\n            }\n            sb.append(NodeUtil.getStringValue(elem));\n        } else {\n            if (sb !\u003d null) {\n                Preconditions.checkNotNull(prev);\n                foldedSize +\u003d sb.length() + 2;\n                arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(prev));\n                sb \u003d null;\n            }\n            foldedSize +\u003d InlineCostEstimator.getCost(elem);\n            arrayFoldedChildren.add(elem);\n        }\n        prev \u003d elem;\n        elem \u003d elem.getNext();\n    }\n    if (sb !\u003d null) {\n        Preconditions.checkNotNull(prev);\n        foldedSize +\u003d sb.length() + 2;\n        arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(prev));\n    }\n    foldedSize +\u003d arrayFoldedChildren.size() - 1;\n    int originalSize \u003d InlineCostEstimator.getCost(n);\n    switch(arrayFoldedChildren.size()) {\n        case 0:\n            Node emptyStringNode \u003d Node.newString(\"\");\n            n.getParent().replaceChild(n, emptyStringNode);\n            reportCodeChange();\n            return emptyStringNode;\n        case 1:\n            Node foldedStringNode \u003d arrayFoldedChildren.remove(0);\n            if (foldedSize \u003e originalSize) {\n                return n;\n            }\n            arrayNode.detachChildren();\n            if (foldedStringNode.getType() !\u003d Token.STRING) {\n                Node replacement \u003d new Node(Token.ADD, Node.newString(\"\").copyInformationFrom(right), foldedStringNode);\n                foldedStringNode \u003d replacement;\n            }\n            n.getParent().replaceChild(n, foldedStringNode);\n            reportCodeChange();\n            return foldedStringNode;\n        default:\n            if (arrayFoldedChildren.size() \u003d\u003d arrayNode.getChildCount()) {\n                return n;\n            }\n            int kJoinOverhead \u003d \"[].join()\".length();\n            foldedSize +\u003d kJoinOverhead;\n            foldedSize +\u003d InlineCostEstimator.getCost(right);\n            if (foldedSize \u003e originalSize) {\n                return n;\n            }\n            arrayNode.detachChildren();\n            for (Node node : arrayFoldedChildren) {\n                arrayNode.addChildToBack(node);\n            }\n            reportCodeChange();\n            break;\n    }\n    return n;\n}",
          "path": "src/com/google/javascript/jscomp/PeepholeFoldConstants.java",
          "functionStartLine": 1078,
          "functionName": "tryFoldArrayJoin",
          "functionAnnotation": "",
          "functionDoc": "Try to fold an array join: [\u0027a\u0027, \u0027b\u0027, \u0027c\u0027].join(\u0027\u0027) -\u003e \u0027abc\u0027;\n",
          "diff": "@@ -1,89 +1,89 @@\n-private Node tryFoldStringJoin(Node n) {\n-    Node left \u003d n.getFirstChild();\n-    if (left \u003d\u003d null) {\n+private Node tryFoldArrayJoin(Node n) {\n+    Node callTarget \u003d n.getFirstChild();\n+    if (callTarget \u003d\u003d null) {\n         return n;\n     }\n-    Node right \u003d left.getNext();\n+    Node right \u003d callTarget.getNext();\n     if (right \u003d\u003d null) {\n         return n;\n     }\n-    if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {\n+    if (!NodeUtil.isGetProp(callTarget) || !NodeUtil.isImmutableValue(right)) {\n         return n;\n     }\n-    Node arrayNode \u003d left.getFirstChild();\n+    Node arrayNode \u003d callTarget.getFirstChild();\n     Node functionName \u003d arrayNode.getNext();\n     if ((arrayNode.getType() !\u003d Token.ARRAYLIT) || !functionName.getString().equals(\"join\")) {\n         return n;\n     }\n     String joinString \u003d NodeUtil.getStringValue(right);\n     List\u003cNode\u003e arrayFoldedChildren \u003d Lists.newLinkedList();\n     StringBuilder sb \u003d null;\n     int foldedSize \u003d 0;\n     Node prev \u003d null;\n     Node elem \u003d arrayNode.getFirstChild();\n     while (elem !\u003d null) {\n         if (NodeUtil.isImmutableValue(elem)) {\n             if (sb \u003d\u003d null) {\n                 sb \u003d new StringBuilder();\n             } else {\n                 sb.append(joinString);\n             }\n             sb.append(NodeUtil.getStringValue(elem));\n         } else {\n             if (sb !\u003d null) {\n                 Preconditions.checkNotNull(prev);\n                 foldedSize +\u003d sb.length() + 2;\n                 arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(prev));\n                 sb \u003d null;\n             }\n             foldedSize +\u003d InlineCostEstimator.getCost(elem);\n             arrayFoldedChildren.add(elem);\n         }\n         prev \u003d elem;\n         elem \u003d elem.getNext();\n     }\n     if (sb !\u003d null) {\n         Preconditions.checkNotNull(prev);\n         foldedSize +\u003d sb.length() + 2;\n         arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(prev));\n     }\n     foldedSize +\u003d arrayFoldedChildren.size() - 1;\n     int originalSize \u003d InlineCostEstimator.getCost(n);\n     switch(arrayFoldedChildren.size()) {\n         case 0:\n             Node emptyStringNode \u003d Node.newString(\"\");\n             n.getParent().replaceChild(n, emptyStringNode);\n             reportCodeChange();\n             return emptyStringNode;\n         case 1:\n             Node foldedStringNode \u003d arrayFoldedChildren.remove(0);\n             if (foldedSize \u003e originalSize) {\n                 return n;\n             }\n             arrayNode.detachChildren();\n             if (foldedStringNode.getType() !\u003d Token.STRING) {\n                 Node replacement \u003d new Node(Token.ADD, Node.newString(\"\").copyInformationFrom(right), foldedStringNode);\n                 foldedStringNode \u003d replacement;\n             }\n             n.getParent().replaceChild(n, foldedStringNode);\n             reportCodeChange();\n             return foldedStringNode;\n         default:\n             if (arrayFoldedChildren.size() \u003d\u003d arrayNode.getChildCount()) {\n                 return n;\n             }\n             int kJoinOverhead \u003d \"[].join()\".length();\n             foldedSize +\u003d kJoinOverhead;\n             foldedSize +\u003d InlineCostEstimator.getCost(right);\n             if (foldedSize \u003e originalSize) {\n                 return n;\n             }\n             arrayNode.detachChildren();\n             for (Node node : arrayFoldedChildren) {\n                 arrayNode.addChildToBack(node);\n             }\n             reportCodeChange();\n             break;\n     }\n     return n;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "9de5e9b4671773bb3f2d5932e57c1b4186b9b777": {
      "type": "Yformatchange",
      "commitMessage": "\nChange on 2010/06/30 15:06:33 by johnlenz\n\n\tAdd a diagnostic group so that projects with weird externs can opt-out of the stricter extern checks.\n\n\tR\u003dnicksantos\n\tDELTA\u003d54  (52 added, 0 deleted, 2 changed)\n\nChange on 2010/06/30 17:56:51 by johnlenz\n\n\tRevert warning levels until after a release is put out to control them.\n\n\tR\u003dnicksantos\n\tDELTA\u003d4  (2 added, 0 deleted, 2 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d47002\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@260 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "7/1/10, 7:38 AM",
      "commitName": "9de5e9b4671773bb3f2d5932e57c1b4186b9b777",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "6/28/10, 5:30 PM",
      "commitNameOld": "9925370292834ea846727f1f9db76af0d40261df",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 2.59,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "private Node tryFoldStringJoin(Node n) {\n    Node left \u003d n.getFirstChild();\n    if (left \u003d\u003d null) {\n        return n;\n    }\n    Node right \u003d left.getNext();\n    if (right \u003d\u003d null) {\n        return n;\n    }\n    if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {\n        return n;\n    }\n    Node arrayNode \u003d left.getFirstChild();\n    Node functionName \u003d arrayNode.getNext();\n    if ((arrayNode.getType() !\u003d Token.ARRAYLIT) || !functionName.getString().equals(\"join\")) {\n        return n;\n    }\n    String joinString \u003d NodeUtil.getStringValue(right);\n    List\u003cNode\u003e arrayFoldedChildren \u003d Lists.newLinkedList();\n    StringBuilder sb \u003d null;\n    int foldedSize \u003d 0;\n    Node prev \u003d null;\n    Node elem \u003d arrayNode.getFirstChild();\n    while (elem !\u003d null) {\n        if (NodeUtil.isImmutableValue(elem)) {\n            if (sb \u003d\u003d null) {\n                sb \u003d new StringBuilder();\n            } else {\n                sb.append(joinString);\n            }\n            sb.append(NodeUtil.getStringValue(elem));\n        } else {\n            if (sb !\u003d null) {\n                Preconditions.checkNotNull(prev);\n                foldedSize +\u003d sb.length() + 2;\n                arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(prev));\n                sb \u003d null;\n            }\n            foldedSize +\u003d InlineCostEstimator.getCost(elem);\n            arrayFoldedChildren.add(elem);\n        }\n        prev \u003d elem;\n        elem \u003d elem.getNext();\n    }\n    if (sb !\u003d null) {\n        Preconditions.checkNotNull(prev);\n        foldedSize +\u003d sb.length() + 2;\n        arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(prev));\n    }\n    foldedSize +\u003d arrayFoldedChildren.size() - 1;\n    int originalSize \u003d InlineCostEstimator.getCost(n);\n    switch(arrayFoldedChildren.size()) {\n        case 0:\n            Node emptyStringNode \u003d Node.newString(\"\");\n            n.getParent().replaceChild(n, emptyStringNode);\n            reportCodeChange();\n            return emptyStringNode;\n        case 1:\n            Node foldedStringNode \u003d arrayFoldedChildren.remove(0);\n            if (foldedSize \u003e originalSize) {\n                return n;\n            }\n            arrayNode.detachChildren();\n            if (foldedStringNode.getType() !\u003d Token.STRING) {\n                Node replacement \u003d new Node(Token.ADD, Node.newString(\"\").copyInformationFrom(right), foldedStringNode);\n                foldedStringNode \u003d replacement;\n            }\n            n.getParent().replaceChild(n, foldedStringNode);\n            reportCodeChange();\n            return foldedStringNode;\n        default:\n            if (arrayFoldedChildren.size() \u003d\u003d arrayNode.getChildCount()) {\n                return n;\n            }\n            int kJoinOverhead \u003d \"[].join()\".length();\n            foldedSize +\u003d kJoinOverhead;\n            foldedSize +\u003d InlineCostEstimator.getCost(right);\n            if (foldedSize \u003e originalSize) {\n                return n;\n            }\n            arrayNode.detachChildren();\n            for (Node node : arrayFoldedChildren) {\n                arrayNode.addChildToBack(node);\n            }\n            reportCodeChange();\n            break;\n    }\n    return n;\n}",
      "path": "src/com/google/javascript/jscomp/PeepholeFoldConstants.java",
      "functionStartLine": 996,
      "functionName": "tryFoldStringJoin",
      "functionAnnotation": "",
      "functionDoc": "Try to fold an array join: [\u0027a\u0027, \u0027b\u0027, \u0027c\u0027].join(\u0027\u0027) -\u003e \u0027abc\u0027;\n",
      "diff": "",
      "extendedDetails": {}
    },
    "c9e89727dc8063d087d28e42629606f4fd74a6e5": {
      "type": "Ymultichange(Ymovefromfile,Yreturntypechange,Ymodifierchange,Ybodychange,Yparameterchange)",
      "commitMessage": "\nChange on 2010/06/22 by nicksantos\n\n\tvariable coalescing better be run AFTER ambiguate properties, and\n\tafter denormalization.\n\n\tR\u003djohnlenz\n\tDELTA\u003d36  (20 added, 16 deleted, 0 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d34005\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@248 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "6/22/10, 4:00 PM",
      "commitName": "c9e89727dc8063d087d28e42629606f4fd74a6e5",
      "commitAuthor": "Nicholas.J.Santos",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "\nChange on 2010/06/22 by nicksantos\n\n\tvariable coalescing better be run AFTER ambiguate properties, and\n\tafter denormalization.\n\n\tR\u003djohnlenz\n\tDELTA\u003d36  (20 added, 16 deleted, 0 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d34005\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@248 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "6/22/10, 4:00 PM",
          "commitName": "c9e89727dc8063d087d28e42629606f4fd74a6e5",
          "commitAuthor": "Nicholas.J.Santos",
          "commitDateOld": "6/21/10, 12:59 PM",
          "commitNameOld": "5f09a76531fb4f6e182238411017e6fc7e74ad16",
          "commitAuthorOld": "Nicholas.J.Santos",
          "daysBetweenCommits": 1.13,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "private Node tryFoldStringJoin(Node n) {\n    Node left \u003d n.getFirstChild();\n    if (left \u003d\u003d null) {\n        return n;\n    }\n    Node right \u003d left.getNext();\n    if (right \u003d\u003d null) {\n        return n;\n    }\n    if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {\n        return n;\n    }\n    Node arrayNode \u003d left.getFirstChild();\n    Node functionName \u003d arrayNode.getNext();\n    if ((arrayNode.getType() !\u003d Token.ARRAYLIT) || !functionName.getString().equals(\"join\")) {\n        return n;\n    }\n    String joinString \u003d NodeUtil.getStringValue(right);\n    List\u003cNode\u003e arrayFoldedChildren \u003d Lists.newLinkedList();\n    StringBuilder sb \u003d null;\n    int foldedSize \u003d 0;\n    Node prev \u003d null;\n    Node elem \u003d arrayNode.getFirstChild();\n    while (elem !\u003d null) {\n        if (NodeUtil.isImmutableValue(elem)) {\n            if (sb \u003d\u003d null) {\n                sb \u003d new StringBuilder();\n            } else {\n                sb.append(joinString);\n            }\n            sb.append(NodeUtil.getStringValue(elem));\n        } else {\n            if (sb !\u003d null) {\n                Preconditions.checkNotNull(prev);\n                foldedSize +\u003d sb.length() + 2;\n                arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(prev));\n                sb \u003d null;\n            }\n            foldedSize +\u003d InlineCostEstimator.getCost(elem);\n            arrayFoldedChildren.add(elem);\n        }\n        prev \u003d elem;\n        elem \u003d elem.getNext();\n    }\n    if (sb !\u003d null) {\n        Preconditions.checkNotNull(prev);\n        foldedSize +\u003d sb.length() + 2;\n        arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(prev));\n    }\n    foldedSize +\u003d arrayFoldedChildren.size() - 1;\n    int originalSize \u003d InlineCostEstimator.getCost(n);\n    switch(arrayFoldedChildren.size()) {\n        case 0:\n            Node emptyStringNode \u003d Node.newString(\"\");\n            n.getParent().replaceChild(n, emptyStringNode);\n            reportCodeChange();\n            return emptyStringNode;\n        case 1:\n            Node foldedStringNode \u003d arrayFoldedChildren.remove(0);\n            if (foldedSize \u003e originalSize) {\n                return n;\n            }\n            arrayNode.detachChildren();\n            if (foldedStringNode.getType() !\u003d Token.STRING) {\n                Node replacement \u003d new Node(Token.ADD, Node.newString(\"\").copyInformationFrom(right), foldedStringNode);\n                foldedStringNode \u003d replacement;\n            }\n            n.getParent().replaceChild(n, foldedStringNode);\n            reportCodeChange();\n            return foldedStringNode;\n        default:\n            if (arrayFoldedChildren.size() \u003d\u003d arrayNode.getChildCount()) {\n                return n;\n            }\n            int kJoinOverhead \u003d \"[].join()\".length();\n            foldedSize +\u003d kJoinOverhead;\n            foldedSize +\u003d InlineCostEstimator.getCost(right);\n            if (foldedSize \u003e originalSize) {\n                return n;\n            }\n            arrayNode.detachChildren();\n            for (Node node : arrayFoldedChildren) {\n                arrayNode.addChildToBack(node);\n            }\n            reportCodeChange();\n            break;\n    }\n    return n;\n}",
          "path": "src/com/google/javascript/jscomp/PeepholeFoldConstants.java",
          "functionStartLine": 985,
          "functionName": "tryFoldStringJoin",
          "functionAnnotation": "",
          "functionDoc": "Try to fold an array join: [\u0027a\u0027, \u0027b\u0027, \u0027c\u0027].join(\u0027\u0027) -\u003e \u0027abc\u0027;\n",
          "diff": "@@ -1,78 +1,89 @@\n-void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right, Node parent) {\n+private Node tryFoldStringJoin(Node n) {\n+    Node left \u003d n.getFirstChild();\n+    if (left \u003d\u003d null) {\n+        return n;\n+    }\n+    Node right \u003d left.getNext();\n+    if (right \u003d\u003d null) {\n+        return n;\n+    }\n     if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {\n-        return;\n+        return n;\n     }\n     Node arrayNode \u003d left.getFirstChild();\n     Node functionName \u003d arrayNode.getNext();\n     if ((arrayNode.getType() !\u003d Token.ARRAYLIT) || !functionName.getString().equals(\"join\")) {\n-        return;\n+        return n;\n     }\n     String joinString \u003d NodeUtil.getStringValue(right);\n     List\u003cNode\u003e arrayFoldedChildren \u003d Lists.newLinkedList();\n     StringBuilder sb \u003d null;\n     int foldedSize \u003d 0;\n     Node prev \u003d null;\n     Node elem \u003d arrayNode.getFirstChild();\n     while (elem !\u003d null) {\n         if (NodeUtil.isImmutableValue(elem)) {\n             if (sb \u003d\u003d null) {\n                 sb \u003d new StringBuilder();\n             } else {\n                 sb.append(joinString);\n             }\n             sb.append(NodeUtil.getStringValue(elem));\n         } else {\n             if (sb !\u003d null) {\n                 Preconditions.checkNotNull(prev);\n                 foldedSize +\u003d sb.length() + 2;\n                 arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(prev));\n                 sb \u003d null;\n             }\n             foldedSize +\u003d InlineCostEstimator.getCost(elem);\n             arrayFoldedChildren.add(elem);\n         }\n         prev \u003d elem;\n         elem \u003d elem.getNext();\n     }\n     if (sb !\u003d null) {\n         Preconditions.checkNotNull(prev);\n         foldedSize +\u003d sb.length() + 2;\n         arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(prev));\n     }\n     foldedSize +\u003d arrayFoldedChildren.size() - 1;\n     int originalSize \u003d InlineCostEstimator.getCost(n);\n     switch(arrayFoldedChildren.size()) {\n         case 0:\n             Node emptyStringNode \u003d Node.newString(\"\");\n-            parent.replaceChild(n, emptyStringNode);\n-            break;\n+            n.getParent().replaceChild(n, emptyStringNode);\n+            reportCodeChange();\n+            return emptyStringNode;\n         case 1:\n             Node foldedStringNode \u003d arrayFoldedChildren.remove(0);\n             if (foldedSize \u003e originalSize) {\n-                return;\n+                return n;\n             }\n             arrayNode.detachChildren();\n             if (foldedStringNode.getType() !\u003d Token.STRING) {\n                 Node replacement \u003d new Node(Token.ADD, Node.newString(\"\").copyInformationFrom(right), foldedStringNode);\n                 foldedStringNode \u003d replacement;\n             }\n-            parent.replaceChild(n, foldedStringNode);\n-            break;\n+            n.getParent().replaceChild(n, foldedStringNode);\n+            reportCodeChange();\n+            return foldedStringNode;\n         default:\n             if (arrayFoldedChildren.size() \u003d\u003d arrayNode.getChildCount()) {\n-                return;\n+                return n;\n             }\n             int kJoinOverhead \u003d \"[].join()\".length();\n             foldedSize +\u003d kJoinOverhead;\n             foldedSize +\u003d InlineCostEstimator.getCost(right);\n             if (foldedSize \u003e originalSize) {\n-                return;\n+                return n;\n             }\n             arrayNode.detachChildren();\n             for (Node node : arrayFoldedChildren) {\n                 arrayNode.addChildToBack(node);\n             }\n+            reportCodeChange();\n             break;\n     }\n-    t.getCompiler().reportCodeChange();\n+    return n;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldPath": "src/com/google/javascript/jscomp/FoldConstants.java",
            "newPath": "src/com/google/javascript/jscomp/PeepholeFoldConstants.java",
            "oldMethodName": "tryFoldStringJoin",
            "newMethodName": "tryFoldStringJoin"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "\nChange on 2010/06/22 by nicksantos\n\n\tvariable coalescing better be run AFTER ambiguate properties, and\n\tafter denormalization.\n\n\tR\u003djohnlenz\n\tDELTA\u003d36  (20 added, 16 deleted, 0 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d34005\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@248 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "6/22/10, 4:00 PM",
          "commitName": "c9e89727dc8063d087d28e42629606f4fd74a6e5",
          "commitAuthor": "Nicholas.J.Santos",
          "commitDateOld": "6/21/10, 12:59 PM",
          "commitNameOld": "5f09a76531fb4f6e182238411017e6fc7e74ad16",
          "commitAuthorOld": "Nicholas.J.Santos",
          "daysBetweenCommits": 1.13,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "private Node tryFoldStringJoin(Node n) {\n    Node left \u003d n.getFirstChild();\n    if (left \u003d\u003d null) {\n        return n;\n    }\n    Node right \u003d left.getNext();\n    if (right \u003d\u003d null) {\n        return n;\n    }\n    if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {\n        return n;\n    }\n    Node arrayNode \u003d left.getFirstChild();\n    Node functionName \u003d arrayNode.getNext();\n    if ((arrayNode.getType() !\u003d Token.ARRAYLIT) || !functionName.getString().equals(\"join\")) {\n        return n;\n    }\n    String joinString \u003d NodeUtil.getStringValue(right);\n    List\u003cNode\u003e arrayFoldedChildren \u003d Lists.newLinkedList();\n    StringBuilder sb \u003d null;\n    int foldedSize \u003d 0;\n    Node prev \u003d null;\n    Node elem \u003d arrayNode.getFirstChild();\n    while (elem !\u003d null) {\n        if (NodeUtil.isImmutableValue(elem)) {\n            if (sb \u003d\u003d null) {\n                sb \u003d new StringBuilder();\n            } else {\n                sb.append(joinString);\n            }\n            sb.append(NodeUtil.getStringValue(elem));\n        } else {\n            if (sb !\u003d null) {\n                Preconditions.checkNotNull(prev);\n                foldedSize +\u003d sb.length() + 2;\n                arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(prev));\n                sb \u003d null;\n            }\n            foldedSize +\u003d InlineCostEstimator.getCost(elem);\n            arrayFoldedChildren.add(elem);\n        }\n        prev \u003d elem;\n        elem \u003d elem.getNext();\n    }\n    if (sb !\u003d null) {\n        Preconditions.checkNotNull(prev);\n        foldedSize +\u003d sb.length() + 2;\n        arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(prev));\n    }\n    foldedSize +\u003d arrayFoldedChildren.size() - 1;\n    int originalSize \u003d InlineCostEstimator.getCost(n);\n    switch(arrayFoldedChildren.size()) {\n        case 0:\n            Node emptyStringNode \u003d Node.newString(\"\");\n            n.getParent().replaceChild(n, emptyStringNode);\n            reportCodeChange();\n            return emptyStringNode;\n        case 1:\n            Node foldedStringNode \u003d arrayFoldedChildren.remove(0);\n            if (foldedSize \u003e originalSize) {\n                return n;\n            }\n            arrayNode.detachChildren();\n            if (foldedStringNode.getType() !\u003d Token.STRING) {\n                Node replacement \u003d new Node(Token.ADD, Node.newString(\"\").copyInformationFrom(right), foldedStringNode);\n                foldedStringNode \u003d replacement;\n            }\n            n.getParent().replaceChild(n, foldedStringNode);\n            reportCodeChange();\n            return foldedStringNode;\n        default:\n            if (arrayFoldedChildren.size() \u003d\u003d arrayNode.getChildCount()) {\n                return n;\n            }\n            int kJoinOverhead \u003d \"[].join()\".length();\n            foldedSize +\u003d kJoinOverhead;\n            foldedSize +\u003d InlineCostEstimator.getCost(right);\n            if (foldedSize \u003e originalSize) {\n                return n;\n            }\n            arrayNode.detachChildren();\n            for (Node node : arrayFoldedChildren) {\n                arrayNode.addChildToBack(node);\n            }\n            reportCodeChange();\n            break;\n    }\n    return n;\n}",
          "path": "src/com/google/javascript/jscomp/PeepholeFoldConstants.java",
          "functionStartLine": 985,
          "functionName": "tryFoldStringJoin",
          "functionAnnotation": "",
          "functionDoc": "Try to fold an array join: [\u0027a\u0027, \u0027b\u0027, \u0027c\u0027].join(\u0027\u0027) -\u003e \u0027abc\u0027;\n",
          "diff": "@@ -1,78 +1,89 @@\n-void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right, Node parent) {\n+private Node tryFoldStringJoin(Node n) {\n+    Node left \u003d n.getFirstChild();\n+    if (left \u003d\u003d null) {\n+        return n;\n+    }\n+    Node right \u003d left.getNext();\n+    if (right \u003d\u003d null) {\n+        return n;\n+    }\n     if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {\n-        return;\n+        return n;\n     }\n     Node arrayNode \u003d left.getFirstChild();\n     Node functionName \u003d arrayNode.getNext();\n     if ((arrayNode.getType() !\u003d Token.ARRAYLIT) || !functionName.getString().equals(\"join\")) {\n-        return;\n+        return n;\n     }\n     String joinString \u003d NodeUtil.getStringValue(right);\n     List\u003cNode\u003e arrayFoldedChildren \u003d Lists.newLinkedList();\n     StringBuilder sb \u003d null;\n     int foldedSize \u003d 0;\n     Node prev \u003d null;\n     Node elem \u003d arrayNode.getFirstChild();\n     while (elem !\u003d null) {\n         if (NodeUtil.isImmutableValue(elem)) {\n             if (sb \u003d\u003d null) {\n                 sb \u003d new StringBuilder();\n             } else {\n                 sb.append(joinString);\n             }\n             sb.append(NodeUtil.getStringValue(elem));\n         } else {\n             if (sb !\u003d null) {\n                 Preconditions.checkNotNull(prev);\n                 foldedSize +\u003d sb.length() + 2;\n                 arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(prev));\n                 sb \u003d null;\n             }\n             foldedSize +\u003d InlineCostEstimator.getCost(elem);\n             arrayFoldedChildren.add(elem);\n         }\n         prev \u003d elem;\n         elem \u003d elem.getNext();\n     }\n     if (sb !\u003d null) {\n         Preconditions.checkNotNull(prev);\n         foldedSize +\u003d sb.length() + 2;\n         arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(prev));\n     }\n     foldedSize +\u003d arrayFoldedChildren.size() - 1;\n     int originalSize \u003d InlineCostEstimator.getCost(n);\n     switch(arrayFoldedChildren.size()) {\n         case 0:\n             Node emptyStringNode \u003d Node.newString(\"\");\n-            parent.replaceChild(n, emptyStringNode);\n-            break;\n+            n.getParent().replaceChild(n, emptyStringNode);\n+            reportCodeChange();\n+            return emptyStringNode;\n         case 1:\n             Node foldedStringNode \u003d arrayFoldedChildren.remove(0);\n             if (foldedSize \u003e originalSize) {\n-                return;\n+                return n;\n             }\n             arrayNode.detachChildren();\n             if (foldedStringNode.getType() !\u003d Token.STRING) {\n                 Node replacement \u003d new Node(Token.ADD, Node.newString(\"\").copyInformationFrom(right), foldedStringNode);\n                 foldedStringNode \u003d replacement;\n             }\n-            parent.replaceChild(n, foldedStringNode);\n-            break;\n+            n.getParent().replaceChild(n, foldedStringNode);\n+            reportCodeChange();\n+            return foldedStringNode;\n         default:\n             if (arrayFoldedChildren.size() \u003d\u003d arrayNode.getChildCount()) {\n-                return;\n+                return n;\n             }\n             int kJoinOverhead \u003d \"[].join()\".length();\n             foldedSize +\u003d kJoinOverhead;\n             foldedSize +\u003d InlineCostEstimator.getCost(right);\n             if (foldedSize \u003e originalSize) {\n-                return;\n+                return n;\n             }\n             arrayNode.detachChildren();\n             for (Node node : arrayFoldedChildren) {\n                 arrayNode.addChildToBack(node);\n             }\n+            reportCodeChange();\n             break;\n     }\n-    t.getCompiler().reportCodeChange();\n+    return n;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "void",
            "newValue": "Node"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "\nChange on 2010/06/22 by nicksantos\n\n\tvariable coalescing better be run AFTER ambiguate properties, and\n\tafter denormalization.\n\n\tR\u003djohnlenz\n\tDELTA\u003d36  (20 added, 16 deleted, 0 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d34005\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@248 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "6/22/10, 4:00 PM",
          "commitName": "c9e89727dc8063d087d28e42629606f4fd74a6e5",
          "commitAuthor": "Nicholas.J.Santos",
          "commitDateOld": "6/21/10, 12:59 PM",
          "commitNameOld": "5f09a76531fb4f6e182238411017e6fc7e74ad16",
          "commitAuthorOld": "Nicholas.J.Santos",
          "daysBetweenCommits": 1.13,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "private Node tryFoldStringJoin(Node n) {\n    Node left \u003d n.getFirstChild();\n    if (left \u003d\u003d null) {\n        return n;\n    }\n    Node right \u003d left.getNext();\n    if (right \u003d\u003d null) {\n        return n;\n    }\n    if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {\n        return n;\n    }\n    Node arrayNode \u003d left.getFirstChild();\n    Node functionName \u003d arrayNode.getNext();\n    if ((arrayNode.getType() !\u003d Token.ARRAYLIT) || !functionName.getString().equals(\"join\")) {\n        return n;\n    }\n    String joinString \u003d NodeUtil.getStringValue(right);\n    List\u003cNode\u003e arrayFoldedChildren \u003d Lists.newLinkedList();\n    StringBuilder sb \u003d null;\n    int foldedSize \u003d 0;\n    Node prev \u003d null;\n    Node elem \u003d arrayNode.getFirstChild();\n    while (elem !\u003d null) {\n        if (NodeUtil.isImmutableValue(elem)) {\n            if (sb \u003d\u003d null) {\n                sb \u003d new StringBuilder();\n            } else {\n                sb.append(joinString);\n            }\n            sb.append(NodeUtil.getStringValue(elem));\n        } else {\n            if (sb !\u003d null) {\n                Preconditions.checkNotNull(prev);\n                foldedSize +\u003d sb.length() + 2;\n                arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(prev));\n                sb \u003d null;\n            }\n            foldedSize +\u003d InlineCostEstimator.getCost(elem);\n            arrayFoldedChildren.add(elem);\n        }\n        prev \u003d elem;\n        elem \u003d elem.getNext();\n    }\n    if (sb !\u003d null) {\n        Preconditions.checkNotNull(prev);\n        foldedSize +\u003d sb.length() + 2;\n        arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(prev));\n    }\n    foldedSize +\u003d arrayFoldedChildren.size() - 1;\n    int originalSize \u003d InlineCostEstimator.getCost(n);\n    switch(arrayFoldedChildren.size()) {\n        case 0:\n            Node emptyStringNode \u003d Node.newString(\"\");\n            n.getParent().replaceChild(n, emptyStringNode);\n            reportCodeChange();\n            return emptyStringNode;\n        case 1:\n            Node foldedStringNode \u003d arrayFoldedChildren.remove(0);\n            if (foldedSize \u003e originalSize) {\n                return n;\n            }\n            arrayNode.detachChildren();\n            if (foldedStringNode.getType() !\u003d Token.STRING) {\n                Node replacement \u003d new Node(Token.ADD, Node.newString(\"\").copyInformationFrom(right), foldedStringNode);\n                foldedStringNode \u003d replacement;\n            }\n            n.getParent().replaceChild(n, foldedStringNode);\n            reportCodeChange();\n            return foldedStringNode;\n        default:\n            if (arrayFoldedChildren.size() \u003d\u003d arrayNode.getChildCount()) {\n                return n;\n            }\n            int kJoinOverhead \u003d \"[].join()\".length();\n            foldedSize +\u003d kJoinOverhead;\n            foldedSize +\u003d InlineCostEstimator.getCost(right);\n            if (foldedSize \u003e originalSize) {\n                return n;\n            }\n            arrayNode.detachChildren();\n            for (Node node : arrayFoldedChildren) {\n                arrayNode.addChildToBack(node);\n            }\n            reportCodeChange();\n            break;\n    }\n    return n;\n}",
          "path": "src/com/google/javascript/jscomp/PeepholeFoldConstants.java",
          "functionStartLine": 985,
          "functionName": "tryFoldStringJoin",
          "functionAnnotation": "",
          "functionDoc": "Try to fold an array join: [\u0027a\u0027, \u0027b\u0027, \u0027c\u0027].join(\u0027\u0027) -\u003e \u0027abc\u0027;\n",
          "diff": "@@ -1,78 +1,89 @@\n-void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right, Node parent) {\n+private Node tryFoldStringJoin(Node n) {\n+    Node left \u003d n.getFirstChild();\n+    if (left \u003d\u003d null) {\n+        return n;\n+    }\n+    Node right \u003d left.getNext();\n+    if (right \u003d\u003d null) {\n+        return n;\n+    }\n     if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {\n-        return;\n+        return n;\n     }\n     Node arrayNode \u003d left.getFirstChild();\n     Node functionName \u003d arrayNode.getNext();\n     if ((arrayNode.getType() !\u003d Token.ARRAYLIT) || !functionName.getString().equals(\"join\")) {\n-        return;\n+        return n;\n     }\n     String joinString \u003d NodeUtil.getStringValue(right);\n     List\u003cNode\u003e arrayFoldedChildren \u003d Lists.newLinkedList();\n     StringBuilder sb \u003d null;\n     int foldedSize \u003d 0;\n     Node prev \u003d null;\n     Node elem \u003d arrayNode.getFirstChild();\n     while (elem !\u003d null) {\n         if (NodeUtil.isImmutableValue(elem)) {\n             if (sb \u003d\u003d null) {\n                 sb \u003d new StringBuilder();\n             } else {\n                 sb.append(joinString);\n             }\n             sb.append(NodeUtil.getStringValue(elem));\n         } else {\n             if (sb !\u003d null) {\n                 Preconditions.checkNotNull(prev);\n                 foldedSize +\u003d sb.length() + 2;\n                 arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(prev));\n                 sb \u003d null;\n             }\n             foldedSize +\u003d InlineCostEstimator.getCost(elem);\n             arrayFoldedChildren.add(elem);\n         }\n         prev \u003d elem;\n         elem \u003d elem.getNext();\n     }\n     if (sb !\u003d null) {\n         Preconditions.checkNotNull(prev);\n         foldedSize +\u003d sb.length() + 2;\n         arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(prev));\n     }\n     foldedSize +\u003d arrayFoldedChildren.size() - 1;\n     int originalSize \u003d InlineCostEstimator.getCost(n);\n     switch(arrayFoldedChildren.size()) {\n         case 0:\n             Node emptyStringNode \u003d Node.newString(\"\");\n-            parent.replaceChild(n, emptyStringNode);\n-            break;\n+            n.getParent().replaceChild(n, emptyStringNode);\n+            reportCodeChange();\n+            return emptyStringNode;\n         case 1:\n             Node foldedStringNode \u003d arrayFoldedChildren.remove(0);\n             if (foldedSize \u003e originalSize) {\n-                return;\n+                return n;\n             }\n             arrayNode.detachChildren();\n             if (foldedStringNode.getType() !\u003d Token.STRING) {\n                 Node replacement \u003d new Node(Token.ADD, Node.newString(\"\").copyInformationFrom(right), foldedStringNode);\n                 foldedStringNode \u003d replacement;\n             }\n-            parent.replaceChild(n, foldedStringNode);\n-            break;\n+            n.getParent().replaceChild(n, foldedStringNode);\n+            reportCodeChange();\n+            return foldedStringNode;\n         default:\n             if (arrayFoldedChildren.size() \u003d\u003d arrayNode.getChildCount()) {\n-                return;\n+                return n;\n             }\n             int kJoinOverhead \u003d \"[].join()\".length();\n             foldedSize +\u003d kJoinOverhead;\n             foldedSize +\u003d InlineCostEstimator.getCost(right);\n             if (foldedSize \u003e originalSize) {\n-                return;\n+                return n;\n             }\n             arrayNode.detachChildren();\n             for (Node node : arrayFoldedChildren) {\n                 arrayNode.addChildToBack(node);\n             }\n+            reportCodeChange();\n             break;\n     }\n-    t.getCompiler().reportCodeChange();\n+    return n;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[private]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "\nChange on 2010/06/22 by nicksantos\n\n\tvariable coalescing better be run AFTER ambiguate properties, and\n\tafter denormalization.\n\n\tR\u003djohnlenz\n\tDELTA\u003d36  (20 added, 16 deleted, 0 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d34005\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@248 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "6/22/10, 4:00 PM",
          "commitName": "c9e89727dc8063d087d28e42629606f4fd74a6e5",
          "commitAuthor": "Nicholas.J.Santos",
          "commitDateOld": "6/21/10, 12:59 PM",
          "commitNameOld": "5f09a76531fb4f6e182238411017e6fc7e74ad16",
          "commitAuthorOld": "Nicholas.J.Santos",
          "daysBetweenCommits": 1.13,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "private Node tryFoldStringJoin(Node n) {\n    Node left \u003d n.getFirstChild();\n    if (left \u003d\u003d null) {\n        return n;\n    }\n    Node right \u003d left.getNext();\n    if (right \u003d\u003d null) {\n        return n;\n    }\n    if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {\n        return n;\n    }\n    Node arrayNode \u003d left.getFirstChild();\n    Node functionName \u003d arrayNode.getNext();\n    if ((arrayNode.getType() !\u003d Token.ARRAYLIT) || !functionName.getString().equals(\"join\")) {\n        return n;\n    }\n    String joinString \u003d NodeUtil.getStringValue(right);\n    List\u003cNode\u003e arrayFoldedChildren \u003d Lists.newLinkedList();\n    StringBuilder sb \u003d null;\n    int foldedSize \u003d 0;\n    Node prev \u003d null;\n    Node elem \u003d arrayNode.getFirstChild();\n    while (elem !\u003d null) {\n        if (NodeUtil.isImmutableValue(elem)) {\n            if (sb \u003d\u003d null) {\n                sb \u003d new StringBuilder();\n            } else {\n                sb.append(joinString);\n            }\n            sb.append(NodeUtil.getStringValue(elem));\n        } else {\n            if (sb !\u003d null) {\n                Preconditions.checkNotNull(prev);\n                foldedSize +\u003d sb.length() + 2;\n                arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(prev));\n                sb \u003d null;\n            }\n            foldedSize +\u003d InlineCostEstimator.getCost(elem);\n            arrayFoldedChildren.add(elem);\n        }\n        prev \u003d elem;\n        elem \u003d elem.getNext();\n    }\n    if (sb !\u003d null) {\n        Preconditions.checkNotNull(prev);\n        foldedSize +\u003d sb.length() + 2;\n        arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(prev));\n    }\n    foldedSize +\u003d arrayFoldedChildren.size() - 1;\n    int originalSize \u003d InlineCostEstimator.getCost(n);\n    switch(arrayFoldedChildren.size()) {\n        case 0:\n            Node emptyStringNode \u003d Node.newString(\"\");\n            n.getParent().replaceChild(n, emptyStringNode);\n            reportCodeChange();\n            return emptyStringNode;\n        case 1:\n            Node foldedStringNode \u003d arrayFoldedChildren.remove(0);\n            if (foldedSize \u003e originalSize) {\n                return n;\n            }\n            arrayNode.detachChildren();\n            if (foldedStringNode.getType() !\u003d Token.STRING) {\n                Node replacement \u003d new Node(Token.ADD, Node.newString(\"\").copyInformationFrom(right), foldedStringNode);\n                foldedStringNode \u003d replacement;\n            }\n            n.getParent().replaceChild(n, foldedStringNode);\n            reportCodeChange();\n            return foldedStringNode;\n        default:\n            if (arrayFoldedChildren.size() \u003d\u003d arrayNode.getChildCount()) {\n                return n;\n            }\n            int kJoinOverhead \u003d \"[].join()\".length();\n            foldedSize +\u003d kJoinOverhead;\n            foldedSize +\u003d InlineCostEstimator.getCost(right);\n            if (foldedSize \u003e originalSize) {\n                return n;\n            }\n            arrayNode.detachChildren();\n            for (Node node : arrayFoldedChildren) {\n                arrayNode.addChildToBack(node);\n            }\n            reportCodeChange();\n            break;\n    }\n    return n;\n}",
          "path": "src/com/google/javascript/jscomp/PeepholeFoldConstants.java",
          "functionStartLine": 985,
          "functionName": "tryFoldStringJoin",
          "functionAnnotation": "",
          "functionDoc": "Try to fold an array join: [\u0027a\u0027, \u0027b\u0027, \u0027c\u0027].join(\u0027\u0027) -\u003e \u0027abc\u0027;\n",
          "diff": "@@ -1,78 +1,89 @@\n-void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right, Node parent) {\n+private Node tryFoldStringJoin(Node n) {\n+    Node left \u003d n.getFirstChild();\n+    if (left \u003d\u003d null) {\n+        return n;\n+    }\n+    Node right \u003d left.getNext();\n+    if (right \u003d\u003d null) {\n+        return n;\n+    }\n     if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {\n-        return;\n+        return n;\n     }\n     Node arrayNode \u003d left.getFirstChild();\n     Node functionName \u003d arrayNode.getNext();\n     if ((arrayNode.getType() !\u003d Token.ARRAYLIT) || !functionName.getString().equals(\"join\")) {\n-        return;\n+        return n;\n     }\n     String joinString \u003d NodeUtil.getStringValue(right);\n     List\u003cNode\u003e arrayFoldedChildren \u003d Lists.newLinkedList();\n     StringBuilder sb \u003d null;\n     int foldedSize \u003d 0;\n     Node prev \u003d null;\n     Node elem \u003d arrayNode.getFirstChild();\n     while (elem !\u003d null) {\n         if (NodeUtil.isImmutableValue(elem)) {\n             if (sb \u003d\u003d null) {\n                 sb \u003d new StringBuilder();\n             } else {\n                 sb.append(joinString);\n             }\n             sb.append(NodeUtil.getStringValue(elem));\n         } else {\n             if (sb !\u003d null) {\n                 Preconditions.checkNotNull(prev);\n                 foldedSize +\u003d sb.length() + 2;\n                 arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(prev));\n                 sb \u003d null;\n             }\n             foldedSize +\u003d InlineCostEstimator.getCost(elem);\n             arrayFoldedChildren.add(elem);\n         }\n         prev \u003d elem;\n         elem \u003d elem.getNext();\n     }\n     if (sb !\u003d null) {\n         Preconditions.checkNotNull(prev);\n         foldedSize +\u003d sb.length() + 2;\n         arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(prev));\n     }\n     foldedSize +\u003d arrayFoldedChildren.size() - 1;\n     int originalSize \u003d InlineCostEstimator.getCost(n);\n     switch(arrayFoldedChildren.size()) {\n         case 0:\n             Node emptyStringNode \u003d Node.newString(\"\");\n-            parent.replaceChild(n, emptyStringNode);\n-            break;\n+            n.getParent().replaceChild(n, emptyStringNode);\n+            reportCodeChange();\n+            return emptyStringNode;\n         case 1:\n             Node foldedStringNode \u003d arrayFoldedChildren.remove(0);\n             if (foldedSize \u003e originalSize) {\n-                return;\n+                return n;\n             }\n             arrayNode.detachChildren();\n             if (foldedStringNode.getType() !\u003d Token.STRING) {\n                 Node replacement \u003d new Node(Token.ADD, Node.newString(\"\").copyInformationFrom(right), foldedStringNode);\n                 foldedStringNode \u003d replacement;\n             }\n-            parent.replaceChild(n, foldedStringNode);\n-            break;\n+            n.getParent().replaceChild(n, foldedStringNode);\n+            reportCodeChange();\n+            return foldedStringNode;\n         default:\n             if (arrayFoldedChildren.size() \u003d\u003d arrayNode.getChildCount()) {\n-                return;\n+                return n;\n             }\n             int kJoinOverhead \u003d \"[].join()\".length();\n             foldedSize +\u003d kJoinOverhead;\n             foldedSize +\u003d InlineCostEstimator.getCost(right);\n             if (foldedSize \u003e originalSize) {\n-                return;\n+                return n;\n             }\n             arrayNode.detachChildren();\n             for (Node node : arrayFoldedChildren) {\n                 arrayNode.addChildToBack(node);\n             }\n+            reportCodeChange();\n             break;\n     }\n-    t.getCompiler().reportCodeChange();\n+    return n;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "\nChange on 2010/06/22 by nicksantos\n\n\tvariable coalescing better be run AFTER ambiguate properties, and\n\tafter denormalization.\n\n\tR\u003djohnlenz\n\tDELTA\u003d36  (20 added, 16 deleted, 0 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d34005\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@248 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "6/22/10, 4:00 PM",
          "commitName": "c9e89727dc8063d087d28e42629606f4fd74a6e5",
          "commitAuthor": "Nicholas.J.Santos",
          "commitDateOld": "6/21/10, 12:59 PM",
          "commitNameOld": "5f09a76531fb4f6e182238411017e6fc7e74ad16",
          "commitAuthorOld": "Nicholas.J.Santos",
          "daysBetweenCommits": 1.13,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "private Node tryFoldStringJoin(Node n) {\n    Node left \u003d n.getFirstChild();\n    if (left \u003d\u003d null) {\n        return n;\n    }\n    Node right \u003d left.getNext();\n    if (right \u003d\u003d null) {\n        return n;\n    }\n    if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {\n        return n;\n    }\n    Node arrayNode \u003d left.getFirstChild();\n    Node functionName \u003d arrayNode.getNext();\n    if ((arrayNode.getType() !\u003d Token.ARRAYLIT) || !functionName.getString().equals(\"join\")) {\n        return n;\n    }\n    String joinString \u003d NodeUtil.getStringValue(right);\n    List\u003cNode\u003e arrayFoldedChildren \u003d Lists.newLinkedList();\n    StringBuilder sb \u003d null;\n    int foldedSize \u003d 0;\n    Node prev \u003d null;\n    Node elem \u003d arrayNode.getFirstChild();\n    while (elem !\u003d null) {\n        if (NodeUtil.isImmutableValue(elem)) {\n            if (sb \u003d\u003d null) {\n                sb \u003d new StringBuilder();\n            } else {\n                sb.append(joinString);\n            }\n            sb.append(NodeUtil.getStringValue(elem));\n        } else {\n            if (sb !\u003d null) {\n                Preconditions.checkNotNull(prev);\n                foldedSize +\u003d sb.length() + 2;\n                arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(prev));\n                sb \u003d null;\n            }\n            foldedSize +\u003d InlineCostEstimator.getCost(elem);\n            arrayFoldedChildren.add(elem);\n        }\n        prev \u003d elem;\n        elem \u003d elem.getNext();\n    }\n    if (sb !\u003d null) {\n        Preconditions.checkNotNull(prev);\n        foldedSize +\u003d sb.length() + 2;\n        arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(prev));\n    }\n    foldedSize +\u003d arrayFoldedChildren.size() - 1;\n    int originalSize \u003d InlineCostEstimator.getCost(n);\n    switch(arrayFoldedChildren.size()) {\n        case 0:\n            Node emptyStringNode \u003d Node.newString(\"\");\n            n.getParent().replaceChild(n, emptyStringNode);\n            reportCodeChange();\n            return emptyStringNode;\n        case 1:\n            Node foldedStringNode \u003d arrayFoldedChildren.remove(0);\n            if (foldedSize \u003e originalSize) {\n                return n;\n            }\n            arrayNode.detachChildren();\n            if (foldedStringNode.getType() !\u003d Token.STRING) {\n                Node replacement \u003d new Node(Token.ADD, Node.newString(\"\").copyInformationFrom(right), foldedStringNode);\n                foldedStringNode \u003d replacement;\n            }\n            n.getParent().replaceChild(n, foldedStringNode);\n            reportCodeChange();\n            return foldedStringNode;\n        default:\n            if (arrayFoldedChildren.size() \u003d\u003d arrayNode.getChildCount()) {\n                return n;\n            }\n            int kJoinOverhead \u003d \"[].join()\".length();\n            foldedSize +\u003d kJoinOverhead;\n            foldedSize +\u003d InlineCostEstimator.getCost(right);\n            if (foldedSize \u003e originalSize) {\n                return n;\n            }\n            arrayNode.detachChildren();\n            for (Node node : arrayFoldedChildren) {\n                arrayNode.addChildToBack(node);\n            }\n            reportCodeChange();\n            break;\n    }\n    return n;\n}",
          "path": "src/com/google/javascript/jscomp/PeepholeFoldConstants.java",
          "functionStartLine": 985,
          "functionName": "tryFoldStringJoin",
          "functionAnnotation": "",
          "functionDoc": "Try to fold an array join: [\u0027a\u0027, \u0027b\u0027, \u0027c\u0027].join(\u0027\u0027) -\u003e \u0027abc\u0027;\n",
          "diff": "@@ -1,78 +1,89 @@\n-void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right, Node parent) {\n+private Node tryFoldStringJoin(Node n) {\n+    Node left \u003d n.getFirstChild();\n+    if (left \u003d\u003d null) {\n+        return n;\n+    }\n+    Node right \u003d left.getNext();\n+    if (right \u003d\u003d null) {\n+        return n;\n+    }\n     if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {\n-        return;\n+        return n;\n     }\n     Node arrayNode \u003d left.getFirstChild();\n     Node functionName \u003d arrayNode.getNext();\n     if ((arrayNode.getType() !\u003d Token.ARRAYLIT) || !functionName.getString().equals(\"join\")) {\n-        return;\n+        return n;\n     }\n     String joinString \u003d NodeUtil.getStringValue(right);\n     List\u003cNode\u003e arrayFoldedChildren \u003d Lists.newLinkedList();\n     StringBuilder sb \u003d null;\n     int foldedSize \u003d 0;\n     Node prev \u003d null;\n     Node elem \u003d arrayNode.getFirstChild();\n     while (elem !\u003d null) {\n         if (NodeUtil.isImmutableValue(elem)) {\n             if (sb \u003d\u003d null) {\n                 sb \u003d new StringBuilder();\n             } else {\n                 sb.append(joinString);\n             }\n             sb.append(NodeUtil.getStringValue(elem));\n         } else {\n             if (sb !\u003d null) {\n                 Preconditions.checkNotNull(prev);\n                 foldedSize +\u003d sb.length() + 2;\n                 arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(prev));\n                 sb \u003d null;\n             }\n             foldedSize +\u003d InlineCostEstimator.getCost(elem);\n             arrayFoldedChildren.add(elem);\n         }\n         prev \u003d elem;\n         elem \u003d elem.getNext();\n     }\n     if (sb !\u003d null) {\n         Preconditions.checkNotNull(prev);\n         foldedSize +\u003d sb.length() + 2;\n         arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(prev));\n     }\n     foldedSize +\u003d arrayFoldedChildren.size() - 1;\n     int originalSize \u003d InlineCostEstimator.getCost(n);\n     switch(arrayFoldedChildren.size()) {\n         case 0:\n             Node emptyStringNode \u003d Node.newString(\"\");\n-            parent.replaceChild(n, emptyStringNode);\n-            break;\n+            n.getParent().replaceChild(n, emptyStringNode);\n+            reportCodeChange();\n+            return emptyStringNode;\n         case 1:\n             Node foldedStringNode \u003d arrayFoldedChildren.remove(0);\n             if (foldedSize \u003e originalSize) {\n-                return;\n+                return n;\n             }\n             arrayNode.detachChildren();\n             if (foldedStringNode.getType() !\u003d Token.STRING) {\n                 Node replacement \u003d new Node(Token.ADD, Node.newString(\"\").copyInformationFrom(right), foldedStringNode);\n                 foldedStringNode \u003d replacement;\n             }\n-            parent.replaceChild(n, foldedStringNode);\n-            break;\n+            n.getParent().replaceChild(n, foldedStringNode);\n+            reportCodeChange();\n+            return foldedStringNode;\n         default:\n             if (arrayFoldedChildren.size() \u003d\u003d arrayNode.getChildCount()) {\n-                return;\n+                return n;\n             }\n             int kJoinOverhead \u003d \"[].join()\".length();\n             foldedSize +\u003d kJoinOverhead;\n             foldedSize +\u003d InlineCostEstimator.getCost(right);\n             if (foldedSize \u003e originalSize) {\n-                return;\n+                return n;\n             }\n             arrayNode.detachChildren();\n             for (Node node : arrayFoldedChildren) {\n                 arrayNode.addChildToBack(node);\n             }\n+            reportCodeChange();\n             break;\n     }\n-    t.getCompiler().reportCodeChange();\n+    return n;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[t-NodeTraversal, n-Node, left-Node, right-Node, parent-Node]",
            "newValue": "[n-Node]"
          }
        }
      ]
    },
    "43859717972907dd1ecebd8dca6e05036386e28b": {
      "type": "Ybodychange",
      "commitMessage": "\nChange on 2010/04/14 by john\n\n        Stop creating specialized Node types for FUNCTION and SCRIPT as the added functionality isn\u0027t used anywhere.\n\n        Also correct some formatting issue with Node (as it won\u0027t need to be merged with anything else anymore).\n\n        R\u003dsteve,robert\n        DELTA\u003d3969  (1913 added, 1925 deleted, 131 changed)\n\nChange on 2010/04/14 by john\n\n        Fix source information in MinimizeExitPoints.\n\n        R\u003drobert\n        DELTA\u003d10  (5 added, 2 deleted, 3 changed)\n\nChange on 2010/04/14 by john\n\n        Maintain source information.\n\n        R\u003dantonio\n        DELTA\u003d17  (11 added, 0 deleted, 6 changed)\n\nChange on 2010/04/14 by john\n\n        Maintain source information through FoldConstants.\n\n        R\u003drobert\n        DELTA\u003d42  (22 added, 0 deleted, 20 changed)\n\nChange on 2010/04/14 by nick\n\n        lock down function type construction\n\n        R\u003djohn\n        DELTA\u003d111  (83 added, 9 deleted, 19 changed)\n\nChange on 2010/04/14 by john\n\n        Fix source info in CollapseProperties.\n\n        R\u003dnick\n        DELTA\u003d17  (8 added, 3 deleted, 6 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003dmbevwz\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@184 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/14/10, 4:53 PM",
      "commitName": "43859717972907dd1ecebd8dca6e05036386e28b",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "3/29/10, 7:04 AM",
      "commitNameOld": "3cc8b3a5889f8b88ef7a2bd0b8ccea8cb0d916c4",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 16.41,
      "commitsBetweenForRepo": 23,
      "commitsBetweenForFile": 1,
      "actualSource": "void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right, Node parent) {\n    if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {\n        return;\n    }\n    Node arrayNode \u003d left.getFirstChild();\n    Node functionName \u003d arrayNode.getNext();\n    if ((arrayNode.getType() !\u003d Token.ARRAYLIT) || !functionName.getString().equals(\"join\")) {\n        return;\n    }\n    String joinString \u003d NodeUtil.getStringValue(right);\n    List\u003cNode\u003e arrayFoldedChildren \u003d Lists.newLinkedList();\n    StringBuilder sb \u003d null;\n    int foldedSize \u003d 0;\n    Node prev \u003d null;\n    Node elem \u003d arrayNode.getFirstChild();\n    while (elem !\u003d null) {\n        if (NodeUtil.isImmutableValue(elem)) {\n            if (sb \u003d\u003d null) {\n                sb \u003d new StringBuilder();\n            } else {\n                sb.append(joinString);\n            }\n            sb.append(NodeUtil.getStringValue(elem));\n        } else {\n            if (sb !\u003d null) {\n                Preconditions.checkNotNull(prev);\n                foldedSize +\u003d sb.length() + 2;\n                arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(prev));\n                sb \u003d null;\n            }\n            foldedSize +\u003d InlineCostEstimator.getCost(elem);\n            arrayFoldedChildren.add(elem);\n        }\n        prev \u003d elem;\n        elem \u003d elem.getNext();\n    }\n    if (sb !\u003d null) {\n        Preconditions.checkNotNull(prev);\n        foldedSize +\u003d sb.length() + 2;\n        arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(prev));\n    }\n    foldedSize +\u003d arrayFoldedChildren.size() - 1;\n    int originalSize \u003d InlineCostEstimator.getCost(n);\n    switch(arrayFoldedChildren.size()) {\n        case 0:\n            Node emptyStringNode \u003d Node.newString(\"\");\n            parent.replaceChild(n, emptyStringNode);\n            break;\n        case 1:\n            Node foldedStringNode \u003d arrayFoldedChildren.remove(0);\n            if (foldedSize \u003e originalSize) {\n                return;\n            }\n            arrayNode.detachChildren();\n            if (foldedStringNode.getType() !\u003d Token.STRING) {\n                Node replacement \u003d new Node(Token.ADD, Node.newString(\"\").copyInformationFrom(right), foldedStringNode);\n                foldedStringNode \u003d replacement;\n            }\n            parent.replaceChild(n, foldedStringNode);\n            break;\n        default:\n            if (arrayFoldedChildren.size() \u003d\u003d arrayNode.getChildCount()) {\n                return;\n            }\n            int kJoinOverhead \u003d \"[].join()\".length();\n            foldedSize +\u003d kJoinOverhead;\n            foldedSize +\u003d InlineCostEstimator.getCost(right);\n            if (foldedSize \u003e originalSize) {\n                return;\n            }\n            arrayNode.detachChildren();\n            for (Node node : arrayFoldedChildren) {\n                arrayNode.addChildToBack(node);\n            }\n            break;\n    }\n    t.getCompiler().reportCodeChange();\n}",
      "path": "src/com/google/javascript/jscomp/FoldConstants.java",
      "functionStartLine": 1502,
      "functionName": "tryFoldStringJoin",
      "functionAnnotation": "",
      "functionDoc": "Try to fold an array join: [\u0027a\u0027, \u0027b\u0027, \u0027c\u0027].join(\u0027\u0027) -\u003e \u0027abc\u0027;\n",
      "diff": "@@ -1,74 +1,78 @@\n void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right, Node parent) {\n     if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {\n         return;\n     }\n     Node arrayNode \u003d left.getFirstChild();\n     Node functionName \u003d arrayNode.getNext();\n     if ((arrayNode.getType() !\u003d Token.ARRAYLIT) || !functionName.getString().equals(\"join\")) {\n         return;\n     }\n     String joinString \u003d NodeUtil.getStringValue(right);\n     List\u003cNode\u003e arrayFoldedChildren \u003d Lists.newLinkedList();\n     StringBuilder sb \u003d null;\n     int foldedSize \u003d 0;\n+    Node prev \u003d null;\n     Node elem \u003d arrayNode.getFirstChild();\n     while (elem !\u003d null) {\n         if (NodeUtil.isImmutableValue(elem)) {\n             if (sb \u003d\u003d null) {\n                 sb \u003d new StringBuilder();\n             } else {\n                 sb.append(joinString);\n             }\n             sb.append(NodeUtil.getStringValue(elem));\n         } else {\n             if (sb !\u003d null) {\n+                Preconditions.checkNotNull(prev);\n                 foldedSize +\u003d sb.length() + 2;\n-                arrayFoldedChildren.add(Node.newString(sb.toString()));\n+                arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(prev));\n                 sb \u003d null;\n             }\n             foldedSize +\u003d InlineCostEstimator.getCost(elem);\n             arrayFoldedChildren.add(elem);\n         }\n+        prev \u003d elem;\n         elem \u003d elem.getNext();\n     }\n     if (sb !\u003d null) {\n+        Preconditions.checkNotNull(prev);\n         foldedSize +\u003d sb.length() + 2;\n-        arrayFoldedChildren.add(Node.newString(sb.toString()));\n+        arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(prev));\n     }\n     foldedSize +\u003d arrayFoldedChildren.size() - 1;\n     int originalSize \u003d InlineCostEstimator.getCost(n);\n     switch(arrayFoldedChildren.size()) {\n         case 0:\n             Node emptyStringNode \u003d Node.newString(\"\");\n             parent.replaceChild(n, emptyStringNode);\n             break;\n         case 1:\n             Node foldedStringNode \u003d arrayFoldedChildren.remove(0);\n             if (foldedSize \u003e originalSize) {\n                 return;\n             }\n             arrayNode.detachChildren();\n             if (foldedStringNode.getType() !\u003d Token.STRING) {\n-                Node replacement \u003d new Node(Token.ADD, Node.newString(\"\"), foldedStringNode);\n+                Node replacement \u003d new Node(Token.ADD, Node.newString(\"\").copyInformationFrom(right), foldedStringNode);\n                 foldedStringNode \u003d replacement;\n             }\n             parent.replaceChild(n, foldedStringNode);\n             break;\n         default:\n             if (arrayFoldedChildren.size() \u003d\u003d arrayNode.getChildCount()) {\n                 return;\n             }\n             int kJoinOverhead \u003d \"[].join()\".length();\n             foldedSize +\u003d kJoinOverhead;\n             foldedSize +\u003d InlineCostEstimator.getCost(right);\n             if (foldedSize \u003e originalSize) {\n                 return;\n             }\n             arrayNode.detachChildren();\n             for (Node node : arrayFoldedChildren) {\n                 arrayNode.addChildToBack(node);\n             }\n             break;\n     }\n     t.getCompiler().reportCodeChange();\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "113a08f59e8116fb11a7d4ceb11d5bb09b74ac3c": {
      "type": "Ybodychange",
      "commitMessage": "Fix an edge case in how Array.prototype.join is collapsed.\nFixes issue 106.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@99 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "2/9/10, 1:33 PM",
      "commitName": "113a08f59e8116fb11a7d4ceb11d5bb09b74ac3c",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "2/8/10, 11:30 AM",
      "commitNameOld": "45f2bdf91ad3c2f2ac901c72efe9e26148b08d2b",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 1.08,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right, Node parent) {\n    if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {\n        return;\n    }\n    Node arrayNode \u003d left.getFirstChild();\n    Node functionName \u003d arrayNode.getNext();\n    if ((arrayNode.getType() !\u003d Token.ARRAYLIT) || !functionName.getString().equals(\"join\")) {\n        return;\n    }\n    String joinString \u003d NodeUtil.getStringValue(right);\n    List\u003cNode\u003e arrayFoldedChildren \u003d Lists.newLinkedList();\n    StringBuilder sb \u003d null;\n    int foldedSize \u003d 0;\n    Node elem \u003d arrayNode.getFirstChild();\n    while (elem !\u003d null) {\n        if (NodeUtil.isImmutableValue(elem)) {\n            if (sb \u003d\u003d null) {\n                sb \u003d new StringBuilder();\n            } else {\n                sb.append(joinString);\n            }\n            sb.append(NodeUtil.getStringValue(elem));\n        } else {\n            if (sb !\u003d null) {\n                foldedSize +\u003d sb.length() + 2;\n                arrayFoldedChildren.add(Node.newString(sb.toString()));\n                sb \u003d null;\n            }\n            foldedSize +\u003d InlineCostEstimator.getCost(elem);\n            arrayFoldedChildren.add(elem);\n        }\n        elem \u003d elem.getNext();\n    }\n    if (sb !\u003d null) {\n        foldedSize +\u003d sb.length() + 2;\n        arrayFoldedChildren.add(Node.newString(sb.toString()));\n    }\n    foldedSize +\u003d arrayFoldedChildren.size() - 1;\n    int originalSize \u003d InlineCostEstimator.getCost(n);\n    switch(arrayFoldedChildren.size()) {\n        case 0:\n            Node emptyStringNode \u003d Node.newString(\"\");\n            parent.replaceChild(n, emptyStringNode);\n            break;\n        case 1:\n            Node foldedStringNode \u003d arrayFoldedChildren.remove(0);\n            if (foldedSize \u003e originalSize) {\n                return;\n            }\n            arrayNode.detachChildren();\n            if (foldedStringNode.getType() !\u003d Token.STRING) {\n                Node replacement \u003d new Node(Token.ADD, Node.newString(\"\"), foldedStringNode);\n                foldedStringNode \u003d replacement;\n            }\n            parent.replaceChild(n, foldedStringNode);\n            break;\n        default:\n            if (arrayFoldedChildren.size() \u003d\u003d arrayNode.getChildCount()) {\n                return;\n            }\n            int kJoinOverhead \u003d \"[].join()\".length();\n            foldedSize +\u003d kJoinOverhead;\n            foldedSize +\u003d InlineCostEstimator.getCost(right);\n            if (foldedSize \u003e originalSize) {\n                return;\n            }\n            arrayNode.detachChildren();\n            for (Node node : arrayFoldedChildren) {\n                arrayNode.addChildToBack(node);\n            }\n            break;\n    }\n    t.getCompiler().reportCodeChange();\n}",
      "path": "src/com/google/javascript/jscomp/FoldConstants.java",
      "functionStartLine": 1461,
      "functionName": "tryFoldStringJoin",
      "functionAnnotation": "",
      "functionDoc": "Try to fold an array join: [\u0027a\u0027, \u0027b\u0027, \u0027c\u0027].join(\u0027\u0027) -\u003e \u0027abc\u0027;\n",
      "diff": "@@ -1,72 +1,74 @@\n void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right, Node parent) {\n     if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {\n         return;\n     }\n     Node arrayNode \u003d left.getFirstChild();\n     Node functionName \u003d arrayNode.getNext();\n     if ((arrayNode.getType() !\u003d Token.ARRAYLIT) || !functionName.getString().equals(\"join\")) {\n         return;\n     }\n     String joinString \u003d NodeUtil.getStringValue(right);\n     List\u003cNode\u003e arrayFoldedChildren \u003d Lists.newLinkedList();\n-    StringBuilder sb \u003d new StringBuilder();\n+    StringBuilder sb \u003d null;\n     int foldedSize \u003d 0;\n     Node elem \u003d arrayNode.getFirstChild();\n     while (elem !\u003d null) {\n         if (NodeUtil.isImmutableValue(elem)) {\n-            if (sb.length() \u003e 0) {\n+            if (sb \u003d\u003d null) {\n+                sb \u003d new StringBuilder();\n+            } else {\n                 sb.append(joinString);\n             }\n             sb.append(NodeUtil.getStringValue(elem));\n         } else {\n-            if (sb.length() \u003e 0) {\n+            if (sb !\u003d null) {\n                 foldedSize +\u003d sb.length() + 2;\n                 arrayFoldedChildren.add(Node.newString(sb.toString()));\n-                sb \u003d new StringBuilder();\n+                sb \u003d null;\n             }\n             foldedSize +\u003d InlineCostEstimator.getCost(elem);\n             arrayFoldedChildren.add(elem);\n         }\n         elem \u003d elem.getNext();\n     }\n-    if (sb.length() \u003e 0) {\n+    if (sb !\u003d null) {\n         foldedSize +\u003d sb.length() + 2;\n         arrayFoldedChildren.add(Node.newString(sb.toString()));\n     }\n     foldedSize +\u003d arrayFoldedChildren.size() - 1;\n     int originalSize \u003d InlineCostEstimator.getCost(n);\n     switch(arrayFoldedChildren.size()) {\n         case 0:\n             Node emptyStringNode \u003d Node.newString(\"\");\n             parent.replaceChild(n, emptyStringNode);\n             break;\n         case 1:\n             Node foldedStringNode \u003d arrayFoldedChildren.remove(0);\n             if (foldedSize \u003e originalSize) {\n                 return;\n             }\n             arrayNode.detachChildren();\n             if (foldedStringNode.getType() !\u003d Token.STRING) {\n                 Node replacement \u003d new Node(Token.ADD, Node.newString(\"\"), foldedStringNode);\n                 foldedStringNode \u003d replacement;\n             }\n             parent.replaceChild(n, foldedStringNode);\n             break;\n         default:\n             if (arrayFoldedChildren.size() \u003d\u003d arrayNode.getChildCount()) {\n                 return;\n             }\n             int kJoinOverhead \u003d \"[].join()\".length();\n             foldedSize +\u003d kJoinOverhead;\n             foldedSize +\u003d InlineCostEstimator.getCost(right);\n             if (foldedSize \u003e originalSize) {\n                 return;\n             }\n             arrayNode.detachChildren();\n             for (Node node : arrayFoldedChildren) {\n                 arrayNode.addChildToBack(node);\n             }\n             break;\n     }\n     t.getCompiler().reportCodeChange();\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": {
      "type": "Yintroduced",
      "commitMessage": "Initial commit.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/3/09, 3:51 PM",
      "commitName": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "diff": "@@ -0,0 +1,72 @@\n+void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right, Node parent) {\n+    if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {\n+        return;\n+    }\n+    Node arrayNode \u003d left.getFirstChild();\n+    Node functionName \u003d arrayNode.getNext();\n+    if ((arrayNode.getType() !\u003d Token.ARRAYLIT) || !functionName.getString().equals(\"join\")) {\n+        return;\n+    }\n+    String joinString \u003d NodeUtil.getStringValue(right);\n+    List\u003cNode\u003e arrayFoldedChildren \u003d Lists.newLinkedList();\n+    StringBuilder sb \u003d new StringBuilder();\n+    int foldedSize \u003d 0;\n+    Node elem \u003d arrayNode.getFirstChild();\n+    while (elem !\u003d null) {\n+        if (NodeUtil.isImmutableValue(elem)) {\n+            if (sb.length() \u003e 0) {\n+                sb.append(joinString);\n+            }\n+            sb.append(NodeUtil.getStringValue(elem));\n+        } else {\n+            if (sb.length() \u003e 0) {\n+                foldedSize +\u003d sb.length() + 2;\n+                arrayFoldedChildren.add(Node.newString(sb.toString()));\n+                sb \u003d new StringBuilder();\n+            }\n+            foldedSize +\u003d InlineCostEstimator.getCost(elem);\n+            arrayFoldedChildren.add(elem);\n+        }\n+        elem \u003d elem.getNext();\n+    }\n+    if (sb.length() \u003e 0) {\n+        foldedSize +\u003d sb.length() + 2;\n+        arrayFoldedChildren.add(Node.newString(sb.toString()));\n+    }\n+    foldedSize +\u003d arrayFoldedChildren.size() - 1;\n+    int originalSize \u003d InlineCostEstimator.getCost(n);\n+    switch(arrayFoldedChildren.size()) {\n+        case 0:\n+            Node emptyStringNode \u003d Node.newString(\"\");\n+            parent.replaceChild(n, emptyStringNode);\n+            break;\n+        case 1:\n+            Node foldedStringNode \u003d arrayFoldedChildren.remove(0);\n+            if (foldedSize \u003e originalSize) {\n+                return;\n+            }\n+            arrayNode.detachChildren();\n+            if (foldedStringNode.getType() !\u003d Token.STRING) {\n+                Node replacement \u003d new Node(Token.ADD, Node.newString(\"\"), foldedStringNode);\n+                foldedStringNode \u003d replacement;\n+            }\n+            parent.replaceChild(n, foldedStringNode);\n+            break;\n+        default:\n+            if (arrayFoldedChildren.size() \u003d\u003d arrayNode.getChildCount()) {\n+                return;\n+            }\n+            int kJoinOverhead \u003d \"[].join()\".length();\n+            foldedSize +\u003d kJoinOverhead;\n+            foldedSize +\u003d InlineCostEstimator.getCost(right);\n+            if (foldedSize \u003e originalSize) {\n+                return;\n+            }\n+            arrayNode.detachChildren();\n+            for (Node node : arrayFoldedChildren) {\n+                arrayNode.addChildToBack(node);\n+            }\n+            break;\n+    }\n+    t.getCompiler().reportCodeChange();\n+}\n\\ No newline at end of file\n",
      "actualSource": "void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right, Node parent) {\n    if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {\n        return;\n    }\n    Node arrayNode \u003d left.getFirstChild();\n    Node functionName \u003d arrayNode.getNext();\n    if ((arrayNode.getType() !\u003d Token.ARRAYLIT) || !functionName.getString().equals(\"join\")) {\n        return;\n    }\n    String joinString \u003d NodeUtil.getStringValue(right);\n    List\u003cNode\u003e arrayFoldedChildren \u003d Lists.newLinkedList();\n    StringBuilder sb \u003d new StringBuilder();\n    int foldedSize \u003d 0;\n    Node elem \u003d arrayNode.getFirstChild();\n    while (elem !\u003d null) {\n        if (NodeUtil.isImmutableValue(elem)) {\n            if (sb.length() \u003e 0) {\n                sb.append(joinString);\n            }\n            sb.append(NodeUtil.getStringValue(elem));\n        } else {\n            if (sb.length() \u003e 0) {\n                foldedSize +\u003d sb.length() + 2;\n                arrayFoldedChildren.add(Node.newString(sb.toString()));\n                sb \u003d new StringBuilder();\n            }\n            foldedSize +\u003d InlineCostEstimator.getCost(elem);\n            arrayFoldedChildren.add(elem);\n        }\n        elem \u003d elem.getNext();\n    }\n    if (sb.length() \u003e 0) {\n        foldedSize +\u003d sb.length() + 2;\n        arrayFoldedChildren.add(Node.newString(sb.toString()));\n    }\n    foldedSize +\u003d arrayFoldedChildren.size() - 1;\n    int originalSize \u003d InlineCostEstimator.getCost(n);\n    switch(arrayFoldedChildren.size()) {\n        case 0:\n            Node emptyStringNode \u003d Node.newString(\"\");\n            parent.replaceChild(n, emptyStringNode);\n            break;\n        case 1:\n            Node foldedStringNode \u003d arrayFoldedChildren.remove(0);\n            if (foldedSize \u003e originalSize) {\n                return;\n            }\n            arrayNode.detachChildren();\n            if (foldedStringNode.getType() !\u003d Token.STRING) {\n                Node replacement \u003d new Node(Token.ADD, Node.newString(\"\"), foldedStringNode);\n                foldedStringNode \u003d replacement;\n            }\n            parent.replaceChild(n, foldedStringNode);\n            break;\n        default:\n            if (arrayFoldedChildren.size() \u003d\u003d arrayNode.getChildCount()) {\n                return;\n            }\n            int kJoinOverhead \u003d \"[].join()\".length();\n            foldedSize +\u003d kJoinOverhead;\n            foldedSize +\u003d InlineCostEstimator.getCost(right);\n            if (foldedSize \u003e originalSize) {\n                return;\n            }\n            arrayNode.detachChildren();\n            for (Node node : arrayFoldedChildren) {\n                arrayNode.addChildToBack(node);\n            }\n            break;\n    }\n    t.getCompiler().reportCodeChange();\n}",
      "path": "src/com/google/javascript/jscomp/FoldConstants.java",
      "functionStartLine": 1453,
      "functionName": "tryFoldStringJoin",
      "functionAnnotation": "",
      "functionDoc": "Try to fold an array join: [\u0027a\u0027, \u0027b\u0027, \u0027c\u0027].join(\u0027\u0027) -\u003e \u0027abc\u0027;\n"
    }
  }
}