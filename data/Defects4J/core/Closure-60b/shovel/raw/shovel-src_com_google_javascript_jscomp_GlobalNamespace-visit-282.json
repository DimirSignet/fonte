{
  "origin": "codeshovel",
  "repositoryName": "Closure-60b",
  "repositoryPath": "/tmp/Closure-60b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "GlobalNamespace.java",
  "functionName": "visit",
  "functionId": "$visit___t-NodeTraversal__n-Node__parent-Node",
  "sourceFilePath": "src/com/google/javascript/jscomp/GlobalNamespace.java",
  "functionAnnotation": "@Override",
  "functionDoc": "",
  "functionStartLine": 282,
  "functionEndLine": 282,
  "numCommitsSeen": 25,
  "timeTaken": 1743,
  "changeHistory": [
    "d6f92e5de267c39d29182cfa89b2f01b7710b607",
    "d68322323aa52d943b9dc5618ef8ea81d43d7b4f",
    "34fd5f8275ae69fc772c2283a3c5fd13b93a7c42",
    "ebb59a97610015bc41bda7f458dd1428a3a3e335",
    "5da32cba7b68d69acfc535f57f21d652475d256f",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3"
  ],
  "changeHistoryShort": {
    "d6f92e5de267c39d29182cfa89b2f01b7710b607": "Ybodychange",
    "d68322323aa52d943b9dc5618ef8ea81d43d7b4f": "Ybodychange",
    "34fd5f8275ae69fc772c2283a3c5fd13b93a7c42": "Ybodychange",
    "ebb59a97610015bc41bda7f458dd1428a3a3e335": "Ybodychange",
    "5da32cba7b68d69acfc535f57f21d652475d256f": "Ymultichange(Yannotationchange,Ydocchange)",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "d6f92e5de267c39d29182cfa89b2f01b7710b607": {
      "type": "Ybodychange",
      "commitMessage": "\nMake sure that properties are not defined on objects before\nthey\u0027re defined\nFixes issue 312.\n\nR\u003dacleung\nDELTA\u003d97  (72 added, 5 deleted, 20 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d1676\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1045 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/28/11, 4:29 PM",
      "commitName": "d6f92e5de267c39d29182cfa89b2f01b7710b607",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "4/25/11, 9:07 AM",
      "commitNameOld": "8be3896c7639f91d83ac220531cc5cbdc5a029d4",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 3.31,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n}",
      "path": "src/com/google/javascript/jscomp/GlobalNamespace.java",
      "functionStartLine": 237,
      "functionName": "visit",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,99 +1,3 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (nodeFilter !\u003d null \u0026\u0026 !nodeFilter.apply(n)) {\n-        return;\n-    }\n-    if (externsRoot !\u003d null \u0026\u0026 n \u003d\u003d externsRoot) {\n-        externsScope \u003d t.getScope();\n-    }\n-    String name;\n-    boolean isSet \u003d false;\n-    Name.Type type \u003d Name.Type.OTHER;\n-    boolean isPropAssign \u003d false;\n-    switch(n.getType()) {\n-        case Token.GET:\n-        case Token.SET:\n-        case Token.STRING:\n-            name \u003d null;\n-            if (parent !\u003d null \u0026\u0026 parent.getType() \u003d\u003d Token.OBJECTLIT) {\n-                name \u003d getNameForObjLitKey(n);\n-            }\n-            if (name \u003d\u003d null)\n-                return;\n-            isSet \u003d true;\n-            switch(n.getType()) {\n-                case Token.STRING:\n-                    type \u003d getValueType(n.getFirstChild());\n-                    break;\n-                case Token.GET:\n-                    type \u003d Name.Type.GET;\n-                    break;\n-                case Token.SET:\n-                    type \u003d Name.Type.SET;\n-                    break;\n-                default:\n-                    throw new IllegalStateException(\"unexpected:\" + n);\n-            }\n-            break;\n-        case Token.NAME:\n-            if (parent !\u003d null) {\n-                switch(parent.getType()) {\n-                    case Token.VAR:\n-                        isSet \u003d true;\n-                        Node rvalue \u003d n.getFirstChild();\n-                        type \u003d rvalue \u003d\u003d null ? Name.Type.OTHER : getValueType(rvalue);\n-                        break;\n-                    case Token.ASSIGN:\n-                        if (parent.getFirstChild() \u003d\u003d n) {\n-                            isSet \u003d true;\n-                            type \u003d getValueType(n.getNext());\n-                        }\n-                        break;\n-                    case Token.GETPROP:\n-                        return;\n-                    case Token.FUNCTION:\n-                        Node gramps \u003d parent.getParent();\n-                        if (gramps \u003d\u003d null || NodeUtil.isFunctionExpression(parent))\n-                            return;\n-                        isSet \u003d true;\n-                        type \u003d Name.Type.FUNCTION;\n-                        break;\n-                }\n-            }\n-            name \u003d n.getString();\n-            break;\n-        case Token.GETPROP:\n-            if (parent !\u003d null) {\n-                switch(parent.getType()) {\n-                    case Token.ASSIGN:\n-                        if (parent.getFirstChild() \u003d\u003d n) {\n-                            isSet \u003d true;\n-                            type \u003d getValueType(n.getNext());\n-                            isPropAssign \u003d true;\n-                        }\n-                        break;\n-                    case Token.GETPROP:\n-                        return;\n-                }\n-            }\n-            name \u003d n.getQualifiedName();\n-            if (name \u003d\u003d null)\n-                return;\n-            break;\n-        default:\n-            return;\n-    }\n-    Scope scope \u003d t.getScope();\n-    if (!isGlobalNameReference(name, scope)) {\n-        return;\n-    }\n-    if (isSet) {\n-        if (isGlobalScope(scope)) {\n-            handleSetFromGlobal(t, n, parent, name, isPropAssign, type);\n-        } else {\n-            handleSetFromLocal(t, n, parent, name);\n-        }\n-    } else {\n-        handleGet(t, n, parent, name);\n-    }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d68322323aa52d943b9dc5618ef8ea81d43d7b4f": {
      "type": "Ybodychange",
      "commitMessage": "\nUpdate the global namespace for get and set properties.\n\nR\u003dnicksantos\nDELTA\u003d117  (111 added, 0 deleted, 6 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d131\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@628 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "12/14/10, 8:19 AM",
      "commitName": "d68322323aa52d943b9dc5618ef8ea81d43d7b4f",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "11/30/10, 5:36 PM",
      "commitNameOld": "4b065734d8afb5ab0d241ee5da22af0fa9d75ec3",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 13.61,
      "commitsBetweenForRepo": 46,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (nodeFilter !\u003d null \u0026\u0026 !nodeFilter.apply(n)) {\n        return;\n    }\n    if (externsRoot !\u003d null \u0026\u0026 n \u003d\u003d externsRoot) {\n        externsScope \u003d t.getScope();\n    }\n    String name;\n    boolean isSet \u003d false;\n    Name.Type type \u003d Name.Type.OTHER;\n    boolean isPropAssign \u003d false;\n    switch(n.getType()) {\n        case Token.GET:\n        case Token.SET:\n        case Token.STRING:\n            name \u003d null;\n            if (parent !\u003d null \u0026\u0026 parent.getType() \u003d\u003d Token.OBJECTLIT) {\n                name \u003d getNameForObjLitKey(n);\n            }\n            if (name \u003d\u003d null)\n                return;\n            isSet \u003d true;\n            switch(n.getType()) {\n                case Token.STRING:\n                    type \u003d getValueType(n.getFirstChild());\n                    break;\n                case Token.GET:\n                    type \u003d Name.Type.GET;\n                    break;\n                case Token.SET:\n                    type \u003d Name.Type.SET;\n                    break;\n                default:\n                    throw new IllegalStateException(\"unexpected:\" + n);\n            }\n            break;\n        case Token.NAME:\n            if (parent !\u003d null) {\n                switch(parent.getType()) {\n                    case Token.VAR:\n                        isSet \u003d true;\n                        Node rvalue \u003d n.getFirstChild();\n                        type \u003d rvalue \u003d\u003d null ? Name.Type.OTHER : getValueType(rvalue);\n                        break;\n                    case Token.ASSIGN:\n                        if (parent.getFirstChild() \u003d\u003d n) {\n                            isSet \u003d true;\n                            type \u003d getValueType(n.getNext());\n                        }\n                        break;\n                    case Token.GETPROP:\n                        return;\n                    case Token.FUNCTION:\n                        Node gramps \u003d parent.getParent();\n                        if (gramps \u003d\u003d null || NodeUtil.isFunctionExpression(parent))\n                            return;\n                        isSet \u003d true;\n                        type \u003d Name.Type.FUNCTION;\n                        break;\n                }\n            }\n            name \u003d n.getString();\n            break;\n        case Token.GETPROP:\n            if (parent !\u003d null) {\n                switch(parent.getType()) {\n                    case Token.ASSIGN:\n                        if (parent.getFirstChild() \u003d\u003d n) {\n                            isSet \u003d true;\n                            type \u003d getValueType(n.getNext());\n                            isPropAssign \u003d true;\n                        }\n                        break;\n                    case Token.GETPROP:\n                        return;\n                }\n            }\n            name \u003d n.getQualifiedName();\n            if (name \u003d\u003d null)\n                return;\n            break;\n        default:\n            return;\n    }\n    Scope scope \u003d t.getScope();\n    if (!isGlobalNameReference(name, scope)) {\n        return;\n    }\n    if (isSet) {\n        if (isGlobalScope(scope)) {\n            handleSetFromGlobal(t, n, parent, name, isPropAssign, type);\n        } else {\n            handleSetFromLocal(t, n, parent, name);\n        }\n    } else {\n        handleGet(t, n, parent, name);\n    }\n}",
      "path": "src/com/google/javascript/jscomp/GlobalNamespace.java",
      "functionStartLine": 231,
      "functionName": "visit",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,85 +1,99 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n     if (nodeFilter !\u003d null \u0026\u0026 !nodeFilter.apply(n)) {\n         return;\n     }\n     if (externsRoot !\u003d null \u0026\u0026 n \u003d\u003d externsRoot) {\n         externsScope \u003d t.getScope();\n     }\n     String name;\n     boolean isSet \u003d false;\n     Name.Type type \u003d Name.Type.OTHER;\n     boolean isPropAssign \u003d false;\n     switch(n.getType()) {\n+        case Token.GET:\n+        case Token.SET:\n         case Token.STRING:\n             name \u003d null;\n             if (parent !\u003d null \u0026\u0026 parent.getType() \u003d\u003d Token.OBJECTLIT) {\n                 name \u003d getNameForObjLitKey(n);\n             }\n             if (name \u003d\u003d null)\n                 return;\n             isSet \u003d true;\n-            type \u003d getValueType(n.getFirstChild());\n+            switch(n.getType()) {\n+                case Token.STRING:\n+                    type \u003d getValueType(n.getFirstChild());\n+                    break;\n+                case Token.GET:\n+                    type \u003d Name.Type.GET;\n+                    break;\n+                case Token.SET:\n+                    type \u003d Name.Type.SET;\n+                    break;\n+                default:\n+                    throw new IllegalStateException(\"unexpected:\" + n);\n+            }\n             break;\n         case Token.NAME:\n             if (parent !\u003d null) {\n                 switch(parent.getType()) {\n                     case Token.VAR:\n                         isSet \u003d true;\n                         Node rvalue \u003d n.getFirstChild();\n                         type \u003d rvalue \u003d\u003d null ? Name.Type.OTHER : getValueType(rvalue);\n                         break;\n                     case Token.ASSIGN:\n                         if (parent.getFirstChild() \u003d\u003d n) {\n                             isSet \u003d true;\n                             type \u003d getValueType(n.getNext());\n                         }\n                         break;\n                     case Token.GETPROP:\n                         return;\n                     case Token.FUNCTION:\n                         Node gramps \u003d parent.getParent();\n                         if (gramps \u003d\u003d null || NodeUtil.isFunctionExpression(parent))\n                             return;\n                         isSet \u003d true;\n                         type \u003d Name.Type.FUNCTION;\n                         break;\n                 }\n             }\n             name \u003d n.getString();\n             break;\n         case Token.GETPROP:\n             if (parent !\u003d null) {\n                 switch(parent.getType()) {\n                     case Token.ASSIGN:\n                         if (parent.getFirstChild() \u003d\u003d n) {\n                             isSet \u003d true;\n                             type \u003d getValueType(n.getNext());\n                             isPropAssign \u003d true;\n                         }\n                         break;\n                     case Token.GETPROP:\n                         return;\n                 }\n             }\n             name \u003d n.getQualifiedName();\n             if (name \u003d\u003d null)\n                 return;\n             break;\n         default:\n             return;\n     }\n     Scope scope \u003d t.getScope();\n     if (!isGlobalNameReference(name, scope)) {\n         return;\n     }\n     if (isSet) {\n         if (isGlobalScope(scope)) {\n             handleSetFromGlobal(t, n, parent, name, isPropAssign, type);\n         } else {\n             handleSetFromLocal(t, n, parent, name);\n         }\n     } else {\n         handleGet(t, n, parent, name);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "34fd5f8275ae69fc772c2283a3c5fd13b93a7c42": {
      "type": "Ybodychange",
      "commitMessage": "\nChange the OBJECTLIT AST structure from:\n\nOBJECTLIT\n  KEY1\n  VALUE1\n\nto\n\nOBJECTLIT\n  KEY1\n    VALUE1\n\nFixes issue 241\n\nR\u003dacleung,johnlenz,stevey\nDELTA\u003d268  (101 added, 51 deleted, 116 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d356416\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@494 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "10/18/10, 2:55 PM",
      "commitName": "34fd5f8275ae69fc772c2283a3c5fd13b93a7c42",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "9/13/10, 11:12 AM",
      "commitNameOld": "4c6e1039b80859f17de5f3cbcfeba61ed8ea0485",
      "commitAuthorOld": "elbaum@google.com",
      "daysBetweenCommits": 35.15,
      "commitsBetweenForRepo": 69,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (nodeFilter !\u003d null \u0026\u0026 !nodeFilter.apply(n)) {\n        return;\n    }\n    if (externsRoot !\u003d null \u0026\u0026 n \u003d\u003d externsRoot) {\n        externsScope \u003d t.getScope();\n    }\n    String name;\n    boolean isSet \u003d false;\n    Name.Type type \u003d Name.Type.OTHER;\n    boolean isPropAssign \u003d false;\n    switch(n.getType()) {\n        case Token.STRING:\n            name \u003d null;\n            if (parent !\u003d null \u0026\u0026 parent.getType() \u003d\u003d Token.OBJECTLIT) {\n                name \u003d getNameForObjLitKey(n);\n            }\n            if (name \u003d\u003d null)\n                return;\n            isSet \u003d true;\n            type \u003d getValueType(n.getFirstChild());\n            break;\n        case Token.NAME:\n            if (parent !\u003d null) {\n                switch(parent.getType()) {\n                    case Token.VAR:\n                        isSet \u003d true;\n                        Node rvalue \u003d n.getFirstChild();\n                        type \u003d rvalue \u003d\u003d null ? Name.Type.OTHER : getValueType(rvalue);\n                        break;\n                    case Token.ASSIGN:\n                        if (parent.getFirstChild() \u003d\u003d n) {\n                            isSet \u003d true;\n                            type \u003d getValueType(n.getNext());\n                        }\n                        break;\n                    case Token.GETPROP:\n                        return;\n                    case Token.FUNCTION:\n                        Node gramps \u003d parent.getParent();\n                        if (gramps \u003d\u003d null || NodeUtil.isFunctionExpression(parent))\n                            return;\n                        isSet \u003d true;\n                        type \u003d Name.Type.FUNCTION;\n                        break;\n                }\n            }\n            name \u003d n.getString();\n            break;\n        case Token.GETPROP:\n            if (parent !\u003d null) {\n                switch(parent.getType()) {\n                    case Token.ASSIGN:\n                        if (parent.getFirstChild() \u003d\u003d n) {\n                            isSet \u003d true;\n                            type \u003d getValueType(n.getNext());\n                            isPropAssign \u003d true;\n                        }\n                        break;\n                    case Token.GETPROP:\n                        return;\n                }\n            }\n            name \u003d n.getQualifiedName();\n            if (name \u003d\u003d null)\n                return;\n            break;\n        default:\n            return;\n    }\n    Scope scope \u003d t.getScope();\n    if (!isGlobalNameReference(name, scope)) {\n        return;\n    }\n    if (isSet) {\n        if (isGlobalScope(scope)) {\n            handleSetFromGlobal(t, n, parent, name, isPropAssign, type);\n        } else {\n            handleSetFromLocal(t, n, parent, name);\n        }\n    } else {\n        handleGet(t, n, parent, name);\n    }\n}",
      "path": "src/com/google/javascript/jscomp/GlobalNamespace.java",
      "functionStartLine": 231,
      "functionName": "visit",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,85 +1,85 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n     if (nodeFilter !\u003d null \u0026\u0026 !nodeFilter.apply(n)) {\n         return;\n     }\n     if (externsRoot !\u003d null \u0026\u0026 n \u003d\u003d externsRoot) {\n         externsScope \u003d t.getScope();\n     }\n     String name;\n     boolean isSet \u003d false;\n     Name.Type type \u003d Name.Type.OTHER;\n     boolean isPropAssign \u003d false;\n     switch(n.getType()) {\n         case Token.STRING:\n             name \u003d null;\n             if (parent !\u003d null \u0026\u0026 parent.getType() \u003d\u003d Token.OBJECTLIT) {\n                 name \u003d getNameForObjLitKey(n);\n             }\n             if (name \u003d\u003d null)\n                 return;\n             isSet \u003d true;\n-            type \u003d getValueType(n.getNext());\n+            type \u003d getValueType(n.getFirstChild());\n             break;\n         case Token.NAME:\n             if (parent !\u003d null) {\n                 switch(parent.getType()) {\n                     case Token.VAR:\n                         isSet \u003d true;\n                         Node rvalue \u003d n.getFirstChild();\n                         type \u003d rvalue \u003d\u003d null ? Name.Type.OTHER : getValueType(rvalue);\n                         break;\n                     case Token.ASSIGN:\n                         if (parent.getFirstChild() \u003d\u003d n) {\n                             isSet \u003d true;\n                             type \u003d getValueType(n.getNext());\n                         }\n                         break;\n                     case Token.GETPROP:\n                         return;\n                     case Token.FUNCTION:\n                         Node gramps \u003d parent.getParent();\n                         if (gramps \u003d\u003d null || NodeUtil.isFunctionExpression(parent))\n                             return;\n                         isSet \u003d true;\n                         type \u003d Name.Type.FUNCTION;\n                         break;\n                 }\n             }\n             name \u003d n.getString();\n             break;\n         case Token.GETPROP:\n             if (parent !\u003d null) {\n                 switch(parent.getType()) {\n                     case Token.ASSIGN:\n                         if (parent.getFirstChild() \u003d\u003d n) {\n                             isSet \u003d true;\n                             type \u003d getValueType(n.getNext());\n                             isPropAssign \u003d true;\n                         }\n                         break;\n                     case Token.GETPROP:\n                         return;\n                 }\n             }\n             name \u003d n.getQualifiedName();\n             if (name \u003d\u003d null)\n                 return;\n             break;\n         default:\n             return;\n     }\n     Scope scope \u003d t.getScope();\n     if (!isGlobalNameReference(name, scope)) {\n         return;\n     }\n     if (isSet) {\n         if (isGlobalScope(scope)) {\n             handleSetFromGlobal(t, n, parent, name, isPropAssign, type);\n         } else {\n             handleSetFromLocal(t, n, parent, name);\n         }\n     } else {\n         handleGet(t, n, parent, name);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ebb59a97610015bc41bda7f458dd1428a3a3e335": {
      "type": "Ybodychange",
      "commitMessage": "\nChange on 2010/04/22 by nick\n\n        fix the extern definition of Window.prototype.stop\n\n        R\u003dsiggy\n        DELTA\u003d1  (0 added, 0 deleted, 1 changed)\n\nChange on 2010/04/22 by john\n\n        \"Anonymous function\" is a confusing term for functions with names.\n        Properly we are usually distinguishing between functions statements\n        (function declarations) and function expressions.\n\n        R\u003dalan\n        DELTA\u003d172  (7 added, 14 deleted, 151 changed)\n\nChange on 2010/04/22 by john\n\n        Standardize the definition of setTimeout/setInterval.\n        Fix for Issue 137\n\n        R\u003dnick\n        DELTA\u003d6  (2 added, 2 deleted, 2 changed)\n\nChange on 2010/04/22 by mark\n\n        Various delegate fixes.\n\n        Give the delegate proxy a name unique from the delegate base so that\n        InstanceObjectType#equals distinguishes them. This is necessary for\n        AmbiguateProperties to work.\n\n        Fix the prototype of the delegate proxy. This makes\n        DisambiguateProperties continue to work.\n\n        Add superclass methods of the delegate base to the delegate proxy.\n\n\n        R\u003dandrew,nada\n        DELTA\u003d526  (383 added, 104 deleted, 39 changed)\n\nChange on 2010/04/23 by john\n\n        Allow variable inlining of function statements. For simplicity  limited to functions defined before first use.\n\n        R\u003dnick\n        DELTA\u003d79  (49 added, 3 deleted, 27 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003dhakjvx\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@197 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/23/10, 11:31 AM",
      "commitName": "ebb59a97610015bc41bda7f458dd1428a3a3e335",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "4/19/10, 4:28 PM",
      "commitNameOld": "5da32cba7b68d69acfc535f57f21d652475d256f",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 3.79,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (nodeFilter !\u003d null \u0026\u0026 !nodeFilter.apply(n)) {\n        return;\n    }\n    if (externsRoot !\u003d null \u0026\u0026 n \u003d\u003d externsRoot) {\n        externsScope \u003d t.getScope();\n    }\n    String name;\n    boolean isSet \u003d false;\n    Name.Type type \u003d Name.Type.OTHER;\n    boolean isPropAssign \u003d false;\n    switch(n.getType()) {\n        case Token.STRING:\n            name \u003d null;\n            if (parent !\u003d null \u0026\u0026 parent.getType() \u003d\u003d Token.OBJECTLIT) {\n                name \u003d getNameForObjLitKey(n);\n            }\n            if (name \u003d\u003d null)\n                return;\n            isSet \u003d true;\n            type \u003d getValueType(n.getNext());\n            break;\n        case Token.NAME:\n            if (parent !\u003d null) {\n                switch(parent.getType()) {\n                    case Token.VAR:\n                        isSet \u003d true;\n                        Node rvalue \u003d n.getFirstChild();\n                        type \u003d rvalue \u003d\u003d null ? Name.Type.OTHER : getValueType(rvalue);\n                        break;\n                    case Token.ASSIGN:\n                        if (parent.getFirstChild() \u003d\u003d n) {\n                            isSet \u003d true;\n                            type \u003d getValueType(n.getNext());\n                        }\n                        break;\n                    case Token.GETPROP:\n                        return;\n                    case Token.FUNCTION:\n                        Node gramps \u003d parent.getParent();\n                        if (gramps \u003d\u003d null || NodeUtil.isFunctionExpression(parent))\n                            return;\n                        isSet \u003d true;\n                        type \u003d Name.Type.FUNCTION;\n                        break;\n                }\n            }\n            name \u003d n.getString();\n            break;\n        case Token.GETPROP:\n            if (parent !\u003d null) {\n                switch(parent.getType()) {\n                    case Token.ASSIGN:\n                        if (parent.getFirstChild() \u003d\u003d n) {\n                            isSet \u003d true;\n                            type \u003d getValueType(n.getNext());\n                            isPropAssign \u003d true;\n                        }\n                        break;\n                    case Token.GETPROP:\n                        return;\n                }\n            }\n            name \u003d n.getQualifiedName();\n            if (name \u003d\u003d null)\n                return;\n            break;\n        default:\n            return;\n    }\n    Scope scope \u003d t.getScope();\n    if (!isGlobalNameReference(name, scope)) {\n        return;\n    }\n    if (isSet) {\n        if (isGlobalScope(scope)) {\n            handleSetFromGlobal(t, n, parent, name, isPropAssign, type);\n        } else {\n            handleSetFromLocal(t, n, parent, name);\n        }\n    } else {\n        handleGet(t, n, parent, name);\n    }\n}",
      "path": "src/com/google/javascript/jscomp/GlobalNamespace.java",
      "functionStartLine": 234,
      "functionName": "visit",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,85 +1,85 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n     if (nodeFilter !\u003d null \u0026\u0026 !nodeFilter.apply(n)) {\n         return;\n     }\n     if (externsRoot !\u003d null \u0026\u0026 n \u003d\u003d externsRoot) {\n         externsScope \u003d t.getScope();\n     }\n     String name;\n     boolean isSet \u003d false;\n     Name.Type type \u003d Name.Type.OTHER;\n     boolean isPropAssign \u003d false;\n     switch(n.getType()) {\n         case Token.STRING:\n             name \u003d null;\n             if (parent !\u003d null \u0026\u0026 parent.getType() \u003d\u003d Token.OBJECTLIT) {\n                 name \u003d getNameForObjLitKey(n);\n             }\n             if (name \u003d\u003d null)\n                 return;\n             isSet \u003d true;\n             type \u003d getValueType(n.getNext());\n             break;\n         case Token.NAME:\n             if (parent !\u003d null) {\n                 switch(parent.getType()) {\n                     case Token.VAR:\n                         isSet \u003d true;\n                         Node rvalue \u003d n.getFirstChild();\n                         type \u003d rvalue \u003d\u003d null ? Name.Type.OTHER : getValueType(rvalue);\n                         break;\n                     case Token.ASSIGN:\n                         if (parent.getFirstChild() \u003d\u003d n) {\n                             isSet \u003d true;\n                             type \u003d getValueType(n.getNext());\n                         }\n                         break;\n                     case Token.GETPROP:\n                         return;\n                     case Token.FUNCTION:\n                         Node gramps \u003d parent.getParent();\n-                        if (gramps \u003d\u003d null || NodeUtil.isFunctionAnonymous(parent))\n+                        if (gramps \u003d\u003d null || NodeUtil.isFunctionExpression(parent))\n                             return;\n                         isSet \u003d true;\n                         type \u003d Name.Type.FUNCTION;\n                         break;\n                 }\n             }\n             name \u003d n.getString();\n             break;\n         case Token.GETPROP:\n             if (parent !\u003d null) {\n                 switch(parent.getType()) {\n                     case Token.ASSIGN:\n                         if (parent.getFirstChild() \u003d\u003d n) {\n                             isSet \u003d true;\n                             type \u003d getValueType(n.getNext());\n                             isPropAssign \u003d true;\n                         }\n                         break;\n                     case Token.GETPROP:\n                         return;\n                 }\n             }\n             name \u003d n.getQualifiedName();\n             if (name \u003d\u003d null)\n                 return;\n             break;\n         default:\n             return;\n     }\n     Scope scope \u003d t.getScope();\n     if (!isGlobalNameReference(name, scope)) {\n         return;\n     }\n     if (isSet) {\n         if (isGlobalScope(scope)) {\n             handleSetFromGlobal(t, n, parent, name, isPropAssign, type);\n         } else {\n             handleSetFromLocal(t, n, parent, name);\n         }\n     } else {\n         handleGet(t, n, parent, name);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5da32cba7b68d69acfc535f57f21d652475d256f": {
      "type": "Ymultichange(Yannotationchange,Ydocchange)",
      "commitMessage": "\nChange on 2010/04/19 by anatol\n\n        Replace {@inheritDoc} javadoc annotation with @Override.\n        @Override is better as it implies documentation inheritance plus checks\n        that the parent method exists at the compile-time.\n\n        R\u003dnick\n        DELTA\u003d137  (0 added, 70 deleted, 67 changed)\n\nChange on 2010/04/19 by nick\n\n        Change how we resolve types.\n        Instead of leaving shell proxy types around, unbox the proxy types.\n\n        R\u003dandrew,john\n        DELTA\u003d103  (84 added, 5 deleted, 14 changed)\n\nChange on 2010/04/19 by acleung\n\n        Enable Flow Sensitive Inlining by default.\n\n        R\u003djohn\n        DELTA\u003d1  (0 added, 0 deleted, 1 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003dpqvliw\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@191 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/19/10, 4:28 PM",
      "commitName": "5da32cba7b68d69acfc535f57f21d652475d256f",
      "commitAuthor": "Nicholas.J.Santos",
      "subchanges": [
        {
          "type": "Yannotationchange",
          "commitMessage": "\nChange on 2010/04/19 by anatol\n\n        Replace {@inheritDoc} javadoc annotation with @Override.\n        @Override is better as it implies documentation inheritance plus checks\n        that the parent method exists at the compile-time.\n\n        R\u003dnick\n        DELTA\u003d137  (0 added, 70 deleted, 67 changed)\n\nChange on 2010/04/19 by nick\n\n        Change how we resolve types.\n        Instead of leaving shell proxy types around, unbox the proxy types.\n\n        R\u003dandrew,john\n        DELTA\u003d103  (84 added, 5 deleted, 14 changed)\n\nChange on 2010/04/19 by acleung\n\n        Enable Flow Sensitive Inlining by default.\n\n        R\u003djohn\n        DELTA\u003d1  (0 added, 0 deleted, 1 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003dpqvliw\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@191 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "4/19/10, 4:28 PM",
          "commitName": "5da32cba7b68d69acfc535f57f21d652475d256f",
          "commitAuthor": "Nicholas.J.Santos",
          "commitDateOld": "3/11/10, 9:31 PM",
          "commitNameOld": "7bfdbd9164601af44d17edd51be829fde2cc51aa",
          "commitAuthorOld": "Nicholas.J.Santos",
          "daysBetweenCommits": 38.75,
          "commitsBetweenForRepo": 54,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (nodeFilter !\u003d null \u0026\u0026 !nodeFilter.apply(n)) {\n        return;\n    }\n    if (externsRoot !\u003d null \u0026\u0026 n \u003d\u003d externsRoot) {\n        externsScope \u003d t.getScope();\n    }\n    String name;\n    boolean isSet \u003d false;\n    Name.Type type \u003d Name.Type.OTHER;\n    boolean isPropAssign \u003d false;\n    switch(n.getType()) {\n        case Token.STRING:\n            name \u003d null;\n            if (parent !\u003d null \u0026\u0026 parent.getType() \u003d\u003d Token.OBJECTLIT) {\n                name \u003d getNameForObjLitKey(n);\n            }\n            if (name \u003d\u003d null)\n                return;\n            isSet \u003d true;\n            type \u003d getValueType(n.getNext());\n            break;\n        case Token.NAME:\n            if (parent !\u003d null) {\n                switch(parent.getType()) {\n                    case Token.VAR:\n                        isSet \u003d true;\n                        Node rvalue \u003d n.getFirstChild();\n                        type \u003d rvalue \u003d\u003d null ? Name.Type.OTHER : getValueType(rvalue);\n                        break;\n                    case Token.ASSIGN:\n                        if (parent.getFirstChild() \u003d\u003d n) {\n                            isSet \u003d true;\n                            type \u003d getValueType(n.getNext());\n                        }\n                        break;\n                    case Token.GETPROP:\n                        return;\n                    case Token.FUNCTION:\n                        Node gramps \u003d parent.getParent();\n                        if (gramps \u003d\u003d null || NodeUtil.isFunctionAnonymous(parent))\n                            return;\n                        isSet \u003d true;\n                        type \u003d Name.Type.FUNCTION;\n                        break;\n                }\n            }\n            name \u003d n.getString();\n            break;\n        case Token.GETPROP:\n            if (parent !\u003d null) {\n                switch(parent.getType()) {\n                    case Token.ASSIGN:\n                        if (parent.getFirstChild() \u003d\u003d n) {\n                            isSet \u003d true;\n                            type \u003d getValueType(n.getNext());\n                            isPropAssign \u003d true;\n                        }\n                        break;\n                    case Token.GETPROP:\n                        return;\n                }\n            }\n            name \u003d n.getQualifiedName();\n            if (name \u003d\u003d null)\n                return;\n            break;\n        default:\n            return;\n    }\n    Scope scope \u003d t.getScope();\n    if (!isGlobalNameReference(name, scope)) {\n        return;\n    }\n    if (isSet) {\n        if (isGlobalScope(scope)) {\n            handleSetFromGlobal(t, n, parent, name, isPropAssign, type);\n        } else {\n            handleSetFromLocal(t, n, parent, name);\n        }\n    } else {\n        handleGet(t, n, parent, name);\n    }\n}",
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java",
          "functionStartLine": 234,
          "functionName": "visit",
          "functionAnnotation": "@Override",
          "functionDoc": "",
          "diff": "@@ -1,84 +1,85 @@\n+@Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n     if (nodeFilter !\u003d null \u0026\u0026 !nodeFilter.apply(n)) {\n         return;\n     }\n     if (externsRoot !\u003d null \u0026\u0026 n \u003d\u003d externsRoot) {\n         externsScope \u003d t.getScope();\n     }\n     String name;\n     boolean isSet \u003d false;\n     Name.Type type \u003d Name.Type.OTHER;\n     boolean isPropAssign \u003d false;\n     switch(n.getType()) {\n         case Token.STRING:\n             name \u003d null;\n             if (parent !\u003d null \u0026\u0026 parent.getType() \u003d\u003d Token.OBJECTLIT) {\n                 name \u003d getNameForObjLitKey(n);\n             }\n             if (name \u003d\u003d null)\n                 return;\n             isSet \u003d true;\n             type \u003d getValueType(n.getNext());\n             break;\n         case Token.NAME:\n             if (parent !\u003d null) {\n                 switch(parent.getType()) {\n                     case Token.VAR:\n                         isSet \u003d true;\n                         Node rvalue \u003d n.getFirstChild();\n                         type \u003d rvalue \u003d\u003d null ? Name.Type.OTHER : getValueType(rvalue);\n                         break;\n                     case Token.ASSIGN:\n                         if (parent.getFirstChild() \u003d\u003d n) {\n                             isSet \u003d true;\n                             type \u003d getValueType(n.getNext());\n                         }\n                         break;\n                     case Token.GETPROP:\n                         return;\n                     case Token.FUNCTION:\n                         Node gramps \u003d parent.getParent();\n                         if (gramps \u003d\u003d null || NodeUtil.isFunctionAnonymous(parent))\n                             return;\n                         isSet \u003d true;\n                         type \u003d Name.Type.FUNCTION;\n                         break;\n                 }\n             }\n             name \u003d n.getString();\n             break;\n         case Token.GETPROP:\n             if (parent !\u003d null) {\n                 switch(parent.getType()) {\n                     case Token.ASSIGN:\n                         if (parent.getFirstChild() \u003d\u003d n) {\n                             isSet \u003d true;\n                             type \u003d getValueType(n.getNext());\n                             isPropAssign \u003d true;\n                         }\n                         break;\n                     case Token.GETPROP:\n                         return;\n                 }\n             }\n             name \u003d n.getQualifiedName();\n             if (name \u003d\u003d null)\n                 return;\n             break;\n         default:\n             return;\n     }\n     Scope scope \u003d t.getScope();\n     if (!isGlobalNameReference(name, scope)) {\n         return;\n     }\n     if (isSet) {\n         if (isGlobalScope(scope)) {\n             handleSetFromGlobal(t, n, parent, name, isPropAssign, type);\n         } else {\n             handleSetFromLocal(t, n, parent, name);\n         }\n     } else {\n         handleGet(t, n, parent, name);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "",
            "newValue": "@Override"
          }
        },
        {
          "type": "Ydocchange",
          "commitMessage": "\nChange on 2010/04/19 by anatol\n\n        Replace {@inheritDoc} javadoc annotation with @Override.\n        @Override is better as it implies documentation inheritance plus checks\n        that the parent method exists at the compile-time.\n\n        R\u003dnick\n        DELTA\u003d137  (0 added, 70 deleted, 67 changed)\n\nChange on 2010/04/19 by nick\n\n        Change how we resolve types.\n        Instead of leaving shell proxy types around, unbox the proxy types.\n\n        R\u003dandrew,john\n        DELTA\u003d103  (84 added, 5 deleted, 14 changed)\n\nChange on 2010/04/19 by acleung\n\n        Enable Flow Sensitive Inlining by default.\n\n        R\u003djohn\n        DELTA\u003d1  (0 added, 0 deleted, 1 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003dpqvliw\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@191 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "4/19/10, 4:28 PM",
          "commitName": "5da32cba7b68d69acfc535f57f21d652475d256f",
          "commitAuthor": "Nicholas.J.Santos",
          "commitDateOld": "3/11/10, 9:31 PM",
          "commitNameOld": "7bfdbd9164601af44d17edd51be829fde2cc51aa",
          "commitAuthorOld": "Nicholas.J.Santos",
          "daysBetweenCommits": 38.75,
          "commitsBetweenForRepo": 54,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (nodeFilter !\u003d null \u0026\u0026 !nodeFilter.apply(n)) {\n        return;\n    }\n    if (externsRoot !\u003d null \u0026\u0026 n \u003d\u003d externsRoot) {\n        externsScope \u003d t.getScope();\n    }\n    String name;\n    boolean isSet \u003d false;\n    Name.Type type \u003d Name.Type.OTHER;\n    boolean isPropAssign \u003d false;\n    switch(n.getType()) {\n        case Token.STRING:\n            name \u003d null;\n            if (parent !\u003d null \u0026\u0026 parent.getType() \u003d\u003d Token.OBJECTLIT) {\n                name \u003d getNameForObjLitKey(n);\n            }\n            if (name \u003d\u003d null)\n                return;\n            isSet \u003d true;\n            type \u003d getValueType(n.getNext());\n            break;\n        case Token.NAME:\n            if (parent !\u003d null) {\n                switch(parent.getType()) {\n                    case Token.VAR:\n                        isSet \u003d true;\n                        Node rvalue \u003d n.getFirstChild();\n                        type \u003d rvalue \u003d\u003d null ? Name.Type.OTHER : getValueType(rvalue);\n                        break;\n                    case Token.ASSIGN:\n                        if (parent.getFirstChild() \u003d\u003d n) {\n                            isSet \u003d true;\n                            type \u003d getValueType(n.getNext());\n                        }\n                        break;\n                    case Token.GETPROP:\n                        return;\n                    case Token.FUNCTION:\n                        Node gramps \u003d parent.getParent();\n                        if (gramps \u003d\u003d null || NodeUtil.isFunctionAnonymous(parent))\n                            return;\n                        isSet \u003d true;\n                        type \u003d Name.Type.FUNCTION;\n                        break;\n                }\n            }\n            name \u003d n.getString();\n            break;\n        case Token.GETPROP:\n            if (parent !\u003d null) {\n                switch(parent.getType()) {\n                    case Token.ASSIGN:\n                        if (parent.getFirstChild() \u003d\u003d n) {\n                            isSet \u003d true;\n                            type \u003d getValueType(n.getNext());\n                            isPropAssign \u003d true;\n                        }\n                        break;\n                    case Token.GETPROP:\n                        return;\n                }\n            }\n            name \u003d n.getQualifiedName();\n            if (name \u003d\u003d null)\n                return;\n            break;\n        default:\n            return;\n    }\n    Scope scope \u003d t.getScope();\n    if (!isGlobalNameReference(name, scope)) {\n        return;\n    }\n    if (isSet) {\n        if (isGlobalScope(scope)) {\n            handleSetFromGlobal(t, n, parent, name, isPropAssign, type);\n        } else {\n            handleSetFromLocal(t, n, parent, name);\n        }\n    } else {\n        handleGet(t, n, parent, name);\n    }\n}",
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java",
          "functionStartLine": 234,
          "functionName": "visit",
          "functionAnnotation": "@Override",
          "functionDoc": "",
          "diff": "@@ -1,84 +1,85 @@\n+@Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n     if (nodeFilter !\u003d null \u0026\u0026 !nodeFilter.apply(n)) {\n         return;\n     }\n     if (externsRoot !\u003d null \u0026\u0026 n \u003d\u003d externsRoot) {\n         externsScope \u003d t.getScope();\n     }\n     String name;\n     boolean isSet \u003d false;\n     Name.Type type \u003d Name.Type.OTHER;\n     boolean isPropAssign \u003d false;\n     switch(n.getType()) {\n         case Token.STRING:\n             name \u003d null;\n             if (parent !\u003d null \u0026\u0026 parent.getType() \u003d\u003d Token.OBJECTLIT) {\n                 name \u003d getNameForObjLitKey(n);\n             }\n             if (name \u003d\u003d null)\n                 return;\n             isSet \u003d true;\n             type \u003d getValueType(n.getNext());\n             break;\n         case Token.NAME:\n             if (parent !\u003d null) {\n                 switch(parent.getType()) {\n                     case Token.VAR:\n                         isSet \u003d true;\n                         Node rvalue \u003d n.getFirstChild();\n                         type \u003d rvalue \u003d\u003d null ? Name.Type.OTHER : getValueType(rvalue);\n                         break;\n                     case Token.ASSIGN:\n                         if (parent.getFirstChild() \u003d\u003d n) {\n                             isSet \u003d true;\n                             type \u003d getValueType(n.getNext());\n                         }\n                         break;\n                     case Token.GETPROP:\n                         return;\n                     case Token.FUNCTION:\n                         Node gramps \u003d parent.getParent();\n                         if (gramps \u003d\u003d null || NodeUtil.isFunctionAnonymous(parent))\n                             return;\n                         isSet \u003d true;\n                         type \u003d Name.Type.FUNCTION;\n                         break;\n                 }\n             }\n             name \u003d n.getString();\n             break;\n         case Token.GETPROP:\n             if (parent !\u003d null) {\n                 switch(parent.getType()) {\n                     case Token.ASSIGN:\n                         if (parent.getFirstChild() \u003d\u003d n) {\n                             isSet \u003d true;\n                             type \u003d getValueType(n.getNext());\n                             isPropAssign \u003d true;\n                         }\n                         break;\n                     case Token.GETPROP:\n                         return;\n                 }\n             }\n             name \u003d n.getQualifiedName();\n             if (name \u003d\u003d null)\n                 return;\n             break;\n         default:\n             return;\n     }\n     Scope scope \u003d t.getScope();\n     if (!isGlobalNameReference(name, scope)) {\n         return;\n     }\n     if (isSet) {\n         if (isGlobalScope(scope)) {\n             handleSetFromGlobal(t, n, parent, name, isPropAssign, type);\n         } else {\n             handleSetFromLocal(t, n, parent, name);\n         }\n     } else {\n         handleGet(t, n, parent, name);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "@inheritDoc}\n",
            "newValue": ""
          }
        }
      ]
    },
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": {
      "type": "Yintroduced",
      "commitMessage": "Initial commit.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/3/09, 3:51 PM",
      "commitName": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "diff": "@@ -0,0 +1,84 @@\n+public void visit(NodeTraversal t, Node n, Node parent) {\n+    if (nodeFilter !\u003d null \u0026\u0026 !nodeFilter.apply(n)) {\n+        return;\n+    }\n+    if (externsRoot !\u003d null \u0026\u0026 n \u003d\u003d externsRoot) {\n+        externsScope \u003d t.getScope();\n+    }\n+    String name;\n+    boolean isSet \u003d false;\n+    Name.Type type \u003d Name.Type.OTHER;\n+    boolean isPropAssign \u003d false;\n+    switch(n.getType()) {\n+        case Token.STRING:\n+            name \u003d null;\n+            if (parent !\u003d null \u0026\u0026 parent.getType() \u003d\u003d Token.OBJECTLIT) {\n+                name \u003d getNameForObjLitKey(n);\n+            }\n+            if (name \u003d\u003d null)\n+                return;\n+            isSet \u003d true;\n+            type \u003d getValueType(n.getNext());\n+            break;\n+        case Token.NAME:\n+            if (parent !\u003d null) {\n+                switch(parent.getType()) {\n+                    case Token.VAR:\n+                        isSet \u003d true;\n+                        Node rvalue \u003d n.getFirstChild();\n+                        type \u003d rvalue \u003d\u003d null ? Name.Type.OTHER : getValueType(rvalue);\n+                        break;\n+                    case Token.ASSIGN:\n+                        if (parent.getFirstChild() \u003d\u003d n) {\n+                            isSet \u003d true;\n+                            type \u003d getValueType(n.getNext());\n+                        }\n+                        break;\n+                    case Token.GETPROP:\n+                        return;\n+                    case Token.FUNCTION:\n+                        Node gramps \u003d parent.getParent();\n+                        if (gramps \u003d\u003d null || NodeUtil.isFunctionAnonymous(parent))\n+                            return;\n+                        isSet \u003d true;\n+                        type \u003d Name.Type.FUNCTION;\n+                        break;\n+                }\n+            }\n+            name \u003d n.getString();\n+            break;\n+        case Token.GETPROP:\n+            if (parent !\u003d null) {\n+                switch(parent.getType()) {\n+                    case Token.ASSIGN:\n+                        if (parent.getFirstChild() \u003d\u003d n) {\n+                            isSet \u003d true;\n+                            type \u003d getValueType(n.getNext());\n+                            isPropAssign \u003d true;\n+                        }\n+                        break;\n+                    case Token.GETPROP:\n+                        return;\n+                }\n+            }\n+            name \u003d n.getQualifiedName();\n+            if (name \u003d\u003d null)\n+                return;\n+            break;\n+        default:\n+            return;\n+    }\n+    Scope scope \u003d t.getScope();\n+    if (!isGlobalNameReference(name, scope)) {\n+        return;\n+    }\n+    if (isSet) {\n+        if (isGlobalScope(scope)) {\n+            handleSetFromGlobal(t, n, parent, name, isPropAssign, type);\n+        } else {\n+            handleSetFromLocal(t, n, parent, name);\n+        }\n+    } else {\n+        handleGet(t, n, parent, name);\n+    }\n+}\n\\ No newline at end of file\n",
      "actualSource": "public void visit(NodeTraversal t, Node n, Node parent) {\n    if (nodeFilter !\u003d null \u0026\u0026 !nodeFilter.apply(n)) {\n        return;\n    }\n    if (externsRoot !\u003d null \u0026\u0026 n \u003d\u003d externsRoot) {\n        externsScope \u003d t.getScope();\n    }\n    String name;\n    boolean isSet \u003d false;\n    Name.Type type \u003d Name.Type.OTHER;\n    boolean isPropAssign \u003d false;\n    switch(n.getType()) {\n        case Token.STRING:\n            name \u003d null;\n            if (parent !\u003d null \u0026\u0026 parent.getType() \u003d\u003d Token.OBJECTLIT) {\n                name \u003d getNameForObjLitKey(n);\n            }\n            if (name \u003d\u003d null)\n                return;\n            isSet \u003d true;\n            type \u003d getValueType(n.getNext());\n            break;\n        case Token.NAME:\n            if (parent !\u003d null) {\n                switch(parent.getType()) {\n                    case Token.VAR:\n                        isSet \u003d true;\n                        Node rvalue \u003d n.getFirstChild();\n                        type \u003d rvalue \u003d\u003d null ? Name.Type.OTHER : getValueType(rvalue);\n                        break;\n                    case Token.ASSIGN:\n                        if (parent.getFirstChild() \u003d\u003d n) {\n                            isSet \u003d true;\n                            type \u003d getValueType(n.getNext());\n                        }\n                        break;\n                    case Token.GETPROP:\n                        return;\n                    case Token.FUNCTION:\n                        Node gramps \u003d parent.getParent();\n                        if (gramps \u003d\u003d null || NodeUtil.isFunctionAnonymous(parent))\n                            return;\n                        isSet \u003d true;\n                        type \u003d Name.Type.FUNCTION;\n                        break;\n                }\n            }\n            name \u003d n.getString();\n            break;\n        case Token.GETPROP:\n            if (parent !\u003d null) {\n                switch(parent.getType()) {\n                    case Token.ASSIGN:\n                        if (parent.getFirstChild() \u003d\u003d n) {\n                            isSet \u003d true;\n                            type \u003d getValueType(n.getNext());\n                            isPropAssign \u003d true;\n                        }\n                        break;\n                    case Token.GETPROP:\n                        return;\n                }\n            }\n            name \u003d n.getQualifiedName();\n            if (name \u003d\u003d null)\n                return;\n            break;\n        default:\n            return;\n    }\n    Scope scope \u003d t.getScope();\n    if (!isGlobalNameReference(name, scope)) {\n        return;\n    }\n    if (isSet) {\n        if (isGlobalScope(scope)) {\n            handleSetFromGlobal(t, n, parent, name, isPropAssign, type);\n        } else {\n            handleSetFromLocal(t, n, parent, name);\n        }\n    } else {\n        handleGet(t, n, parent, name);\n    }\n}",
      "path": "src/com/google/javascript/jscomp/GlobalNamespace.java",
      "functionStartLine": 234,
      "functionName": "visit",
      "functionAnnotation": "",
      "functionDoc": "@inheritDoc}\n"
    }
  }
}