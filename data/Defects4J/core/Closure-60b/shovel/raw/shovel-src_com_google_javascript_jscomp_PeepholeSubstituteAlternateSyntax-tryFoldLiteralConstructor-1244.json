{
  "origin": "codeshovel",
  "repositoryName": "Closure-60b",
  "repositoryPath": "/tmp/Closure-60b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "PeepholeSubstituteAlternateSyntax.java",
  "functionName": "tryFoldLiteralConstructor",
  "functionId": "tryFoldLiteralConstructor___n-Node",
  "sourceFilePath": "src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java",
  "functionAnnotation": "",
  "functionDoc": "Replaces a new Array or Object node with an object literal, unless the\ncall to Array or Object is to a local function with the same name.\n",
  "functionStartLine": 1244,
  "functionEndLine": 1292,
  "numCommitsSeen": 39,
  "timeTaken": 3719,
  "changeHistory": [
    "9de5e9b4671773bb3f2d5932e57c1b4186b9b777",
    "541402929a600a95bf099513908b4efd8b0e1c5b",
    "c9e89727dc8063d087d28e42629606f4fd74a6e5"
  ],
  "changeHistoryShort": {
    "9de5e9b4671773bb3f2d5932e57c1b4186b9b777": "Yformatchange",
    "541402929a600a95bf099513908b4efd8b0e1c5b": "Ybodychange",
    "c9e89727dc8063d087d28e42629606f4fd74a6e5": "Yintroduced"
  },
  "changeHistoryDetails": {
    "9de5e9b4671773bb3f2d5932e57c1b4186b9b777": {
      "type": "Yformatchange",
      "commitMessage": "\nChange on 2010/06/30 15:06:33 by johnlenz\n\n\tAdd a diagnostic group so that projects with weird externs can opt-out of the stricter extern checks.\n\n\tR\u003dnicksantos\n\tDELTA\u003d54  (52 added, 0 deleted, 2 changed)\n\nChange on 2010/06/30 17:56:51 by johnlenz\n\n\tRevert warning levels until after a release is put out to control them.\n\n\tR\u003dnicksantos\n\tDELTA\u003d4  (2 added, 0 deleted, 2 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d47002\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@260 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "7/1/10, 7:38 AM",
      "commitName": "9de5e9b4671773bb3f2d5932e57c1b4186b9b777",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "6/29/10, 2:10 PM",
      "commitNameOld": "541402929a600a95bf099513908b4efd8b0e1c5b",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 1.73,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "private Node tryFoldLiteralConstructor(Node n) {\n    Preconditions.checkArgument(n.getType() \u003d\u003d Token.CALL || n.getType() \u003d\u003d Token.NEW);\n    Node constructorNameNode \u003d n.getFirstChild();\n    Node newLiteralNode \u003d null;\n    if (isASTNormalized() \u0026\u0026 Token.NAME \u003d\u003d constructorNameNode.getType()) {\n        String className \u003d constructorNameNode.getString();\n        if (\"RegExp\".equals(className)) {\n            return tryFoldRegularExpressionConstructor(n);\n        } else {\n            boolean constructorHasArgs \u003d constructorNameNode.getNext() !\u003d null;\n            if (\"Object\".equals(className) \u0026\u0026 !constructorHasArgs) {\n                newLiteralNode \u003d new Node(Token.OBJECTLIT);\n            } else if (\"Array\".equals(className)) {\n                Node arg0 \u003d constructorNameNode.getNext();\n                FoldArrayAction action \u003d isSafeToFoldArrayConstructor(arg0);\n                if (action \u003d\u003d FoldArrayAction.SAFE_TO_FOLD_WITH_ARGS || action \u003d\u003d FoldArrayAction.SAFE_TO_FOLD_WITHOUT_ARGS) {\n                    newLiteralNode \u003d new Node(Token.ARRAYLIT);\n                    n.removeChildren();\n                    if (action \u003d\u003d FoldArrayAction.SAFE_TO_FOLD_WITH_ARGS) {\n                        newLiteralNode.addChildrenToFront(arg0);\n                    }\n                }\n            }\n            if (newLiteralNode !\u003d null) {\n                n.getParent().replaceChild(n, newLiteralNode);\n                reportCodeChange();\n                return newLiteralNode;\n            }\n        }\n    }\n    return n;\n}",
      "path": "src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java",
      "functionStartLine": 703,
      "functionName": "tryFoldLiteralConstructor",
      "functionAnnotation": "",
      "functionDoc": "Replaces a new Array or Object node with an object literal, unless the\ncall to Array or Object is to a local function with the same name.\n",
      "diff": "",
      "extendedDetails": {}
    },
    "541402929a600a95bf099513908b4efd8b0e1c5b": {
      "type": "Ybodychange",
      "commitMessage": "\nChange on 2010/06/28 16:56:22 by dhans\n\n        Array(arg0, arg1, ...) folds into [arg0, arg1, ...] if\n        possible.\n\n        R\u003djohnlenz\n        DELTA\u003d126  (101 added, 0 deleted, 25 changed)\n\nChange on 2010/06/28 17:36:40 by johnlenz\n\n        Modify the AST construction so that \"-2\" is a single Node instead of a\n        \"NEG\" and a \"NUMBER\" node. Simplifies unit testing in some cases.\n        Update and enable a couple of disable tests while I\u0027m here.\n\n        R\u003dbowdidge\n        DELTA\u003d82  (63 added, 3 deleted, 16 changed)\n\nChange on 2010/06/29 00:59:44 by lukaszo\n\n        Adding adoptNode to the Document prototype.\n\n        R\u003dacleung\n        DELTA\u003d7  (7 added, 0 deleted, 0 changed)\n\nChange on 2010/06/29 08:30:43 by dcc\n\n        Remove the (now empty) FoldConstants pass and all references to it.\n\n        R\u003dacleung\n        DELTA\u003d64  (0 added, 64 deleted, 0 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d46001\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@258 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "6/29/10, 2:10 PM",
      "commitName": "541402929a600a95bf099513908b4efd8b0e1c5b",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "6/22/10, 4:00 PM",
      "commitNameOld": "c9e89727dc8063d087d28e42629606f4fd74a6e5",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 6.92,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "actualSource": "private Node tryFoldLiteralConstructor(Node n) {\n    Preconditions.checkArgument(n.getType() \u003d\u003d Token.CALL || n.getType() \u003d\u003d Token.NEW);\n    Node constructorNameNode \u003d n.getFirstChild();\n    Node newLiteralNode \u003d null;\n    if (isASTNormalized() \u0026\u0026 Token.NAME \u003d\u003d constructorNameNode.getType()) {\n        String className \u003d constructorNameNode.getString();\n        if (\"RegExp\".equals(className)) {\n            return tryFoldRegularExpressionConstructor(n);\n        } else {\n            boolean constructorHasArgs \u003d constructorNameNode.getNext() !\u003d null;\n            if (\"Object\".equals(className) \u0026\u0026 !constructorHasArgs) {\n                newLiteralNode \u003d new Node(Token.OBJECTLIT);\n            } else if (\"Array\".equals(className)) {\n                Node arg0 \u003d constructorNameNode.getNext();\n                FoldArrayAction action \u003d isSafeToFoldArrayConstructor(arg0);\n                if (action \u003d\u003d FoldArrayAction.SAFE_TO_FOLD_WITH_ARGS || action \u003d\u003d FoldArrayAction.SAFE_TO_FOLD_WITHOUT_ARGS) {\n                    newLiteralNode \u003d new Node(Token.ARRAYLIT);\n                    n.removeChildren();\n                    if (action \u003d\u003d FoldArrayAction.SAFE_TO_FOLD_WITH_ARGS) {\n                        newLiteralNode.addChildrenToFront(arg0);\n                    }\n                }\n            }\n            if (newLiteralNode !\u003d null) {\n                n.getParent().replaceChild(n, newLiteralNode);\n                reportCodeChange();\n                return newLiteralNode;\n            }\n        }\n    }\n    return n;\n}",
      "path": "src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java",
      "functionStartLine": 703,
      "functionName": "tryFoldLiteralConstructor",
      "functionAnnotation": "",
      "functionDoc": "Replaces a new Array or Object node with an object literal, unless the\ncall to Array or Object is to a local function with the same name.\n",
      "diff": "@@ -1,26 +1,32 @@\n private Node tryFoldLiteralConstructor(Node n) {\n     Preconditions.checkArgument(n.getType() \u003d\u003d Token.CALL || n.getType() \u003d\u003d Token.NEW);\n     Node constructorNameNode \u003d n.getFirstChild();\n     Node newLiteralNode \u003d null;\n     if (isASTNormalized() \u0026\u0026 Token.NAME \u003d\u003d constructorNameNode.getType()) {\n         String className \u003d constructorNameNode.getString();\n         if (\"RegExp\".equals(className)) {\n             return tryFoldRegularExpressionConstructor(n);\n         } else {\n-            boolean constructorHasArguments \u003d constructorNameNode.getNext() !\u003d null;\n-            if (!constructorHasArguments) {\n-                if (\"Array\".equals(className)) {\n+            boolean constructorHasArgs \u003d constructorNameNode.getNext() !\u003d null;\n+            if (\"Object\".equals(className) \u0026\u0026 !constructorHasArgs) {\n+                newLiteralNode \u003d new Node(Token.OBJECTLIT);\n+            } else if (\"Array\".equals(className)) {\n+                Node arg0 \u003d constructorNameNode.getNext();\n+                FoldArrayAction action \u003d isSafeToFoldArrayConstructor(arg0);\n+                if (action \u003d\u003d FoldArrayAction.SAFE_TO_FOLD_WITH_ARGS || action \u003d\u003d FoldArrayAction.SAFE_TO_FOLD_WITHOUT_ARGS) {\n                     newLiteralNode \u003d new Node(Token.ARRAYLIT);\n-                } else if (\"Object\".equals(className)) {\n-                    newLiteralNode \u003d new Node(Token.OBJECTLIT);\n+                    n.removeChildren();\n+                    if (action \u003d\u003d FoldArrayAction.SAFE_TO_FOLD_WITH_ARGS) {\n+                        newLiteralNode.addChildrenToFront(arg0);\n+                    }\n                 }\n             }\n             if (newLiteralNode !\u003d null) {\n                 n.getParent().replaceChild(n, newLiteralNode);\n                 reportCodeChange();\n                 return newLiteralNode;\n             }\n         }\n     }\n     return n;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c9e89727dc8063d087d28e42629606f4fd74a6e5": {
      "type": "Yintroduced",
      "commitMessage": "\nChange on 2010/06/22 by nicksantos\n\n\tvariable coalescing better be run AFTER ambiguate properties, and\n\tafter denormalization.\n\n\tR\u003djohnlenz\n\tDELTA\u003d36  (20 added, 16 deleted, 0 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d34005\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@248 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "6/22/10, 4:00 PM",
      "commitName": "c9e89727dc8063d087d28e42629606f4fd74a6e5",
      "commitAuthor": "Nicholas.J.Santos",
      "diff": "@@ -0,0 +1,26 @@\n+private Node tryFoldLiteralConstructor(Node n) {\n+    Preconditions.checkArgument(n.getType() \u003d\u003d Token.CALL || n.getType() \u003d\u003d Token.NEW);\n+    Node constructorNameNode \u003d n.getFirstChild();\n+    Node newLiteralNode \u003d null;\n+    if (isASTNormalized() \u0026\u0026 Token.NAME \u003d\u003d constructorNameNode.getType()) {\n+        String className \u003d constructorNameNode.getString();\n+        if (\"RegExp\".equals(className)) {\n+            return tryFoldRegularExpressionConstructor(n);\n+        } else {\n+            boolean constructorHasArguments \u003d constructorNameNode.getNext() !\u003d null;\n+            if (!constructorHasArguments) {\n+                if (\"Array\".equals(className)) {\n+                    newLiteralNode \u003d new Node(Token.ARRAYLIT);\n+                } else if (\"Object\".equals(className)) {\n+                    newLiteralNode \u003d new Node(Token.OBJECTLIT);\n+                }\n+            }\n+            if (newLiteralNode !\u003d null) {\n+                n.getParent().replaceChild(n, newLiteralNode);\n+                reportCodeChange();\n+                return newLiteralNode;\n+            }\n+        }\n+    }\n+    return n;\n+}\n\\ No newline at end of file\n",
      "actualSource": "private Node tryFoldLiteralConstructor(Node n) {\n    Preconditions.checkArgument(n.getType() \u003d\u003d Token.CALL || n.getType() \u003d\u003d Token.NEW);\n    Node constructorNameNode \u003d n.getFirstChild();\n    Node newLiteralNode \u003d null;\n    if (isASTNormalized() \u0026\u0026 Token.NAME \u003d\u003d constructorNameNode.getType()) {\n        String className \u003d constructorNameNode.getString();\n        if (\"RegExp\".equals(className)) {\n            return tryFoldRegularExpressionConstructor(n);\n        } else {\n            boolean constructorHasArguments \u003d constructorNameNode.getNext() !\u003d null;\n            if (!constructorHasArguments) {\n                if (\"Array\".equals(className)) {\n                    newLiteralNode \u003d new Node(Token.ARRAYLIT);\n                } else if (\"Object\".equals(className)) {\n                    newLiteralNode \u003d new Node(Token.OBJECTLIT);\n                }\n            }\n            if (newLiteralNode !\u003d null) {\n                n.getParent().replaceChild(n, newLiteralNode);\n                reportCodeChange();\n                return newLiteralNode;\n            }\n        }\n    }\n    return n;\n}",
      "path": "src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java",
      "functionStartLine": 703,
      "functionName": "tryFoldLiteralConstructor",
      "functionAnnotation": "",
      "functionDoc": "Replaces a new Array or Object node with an object literal, unless the\ncall to Array or Object is to a local function with the same name.\n"
    }
  }
}