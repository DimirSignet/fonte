{
  "origin": "codeshovel",
  "repositoryName": "Closure-60b",
  "repositoryPath": "/tmp/Closure-60b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "PeepholeSubstituteAlternateSyntax.java",
  "functionName": "tryMinimizeCondition",
  "functionId": "tryMinimizeCondition___n-Node",
  "sourceFilePath": "src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java",
  "functionAnnotation": "",
  "functionDoc": "Try to minimize conditions expressions, as there are additional\nassumptions that can be made when it is known that the final result\nis a boolean.\n\nThe following transformations are done recursively:\n  !(x||y) --\u003e !x\u0026\u0026!y\n  !(x\u0026\u0026y) --\u003e !x||!y\n  !!x     --\u003e x\nThus:\n  !(x\u0026\u0026!y) --\u003e !x||!!y --\u003e !x||y\n\n  Returns the replacement for n, or the original if no change was made\n",
  "functionStartLine": 1004,
  "functionEndLine": 1186,
  "numCommitsSeen": 51,
  "timeTaken": 4767,
  "changeHistory": [
    "86a7d25f3cc1177f35dc6480260fb807912c03fa",
    "2d0aac92183a4b6bac01d67cfe0114ab96bd908c",
    "e7ce7f710e1bf297f1a4258b53f22f550fc1f2e3",
    "b7ad2fb211e62adfb260852fd03e4d17ff51226e",
    "9de5e9b4671773bb3f2d5932e57c1b4186b9b777",
    "c9e89727dc8063d087d28e42629606f4fd74a6e5",
    "e33e925eea3a8e4de958864e531e1adc4da62e18",
    "b4801b28ceea8db0f63da7440d6769cb9b7cce8a",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3"
  ],
  "changeHistoryShort": {
    "86a7d25f3cc1177f35dc6480260fb807912c03fa": "Ybodychange",
    "2d0aac92183a4b6bac01d67cfe0114ab96bd908c": "Ybodychange",
    "e7ce7f710e1bf297f1a4258b53f22f550fc1f2e3": "Ybodychange",
    "b7ad2fb211e62adfb260852fd03e4d17ff51226e": "Ybodychange",
    "9de5e9b4671773bb3f2d5932e57c1b4186b9b777": "Yformatchange",
    "c9e89727dc8063d087d28e42629606f4fd74a6e5": "Ymodifierchange",
    "e33e925eea3a8e4de958864e531e1adc4da62e18": "Ybodychange",
    "b4801b28ceea8db0f63da7440d6769cb9b7cce8a": "Ymultichange(Ymovefromfile,Yreturntypechange,Ybodychange,Ydocchange,Yparameterchange)",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "86a7d25f3cc1177f35dc6480260fb807912c03fa": {
      "type": "Ybodychange",
      "commitMessage": "\nFix bad folding of expressions containing object and array literals with side-effects.\n\nR\u003dnicksantos\nDELTA\u003d144  (94 added, 0 deleted, 50 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d1088\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@941 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "3/25/11, 4:27 PM",
      "commitName": "86a7d25f3cc1177f35dc6480260fb807912c03fa",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "3/7/11, 4:19 PM",
      "commitNameOld": "b326ab0a322d0ece76e61955852ada034122192b",
      "commitAuthorOld": "acleung@google.com",
      "daysBetweenCommits": 17.96,
      "commitsBetweenForRepo": 72,
      "commitsBetweenForFile": 1,
      "actualSource": "private Node tryMinimizeCondition(Node n) {\n    Node parent \u003d n.getParent();\n    switch(n.getType()) {\n        case Token.NOT:\n            Node first \u003d n.getFirstChild();\n            switch(first.getType()) {\n                case Token.NOT:\n                    {\n                        Node newRoot \u003d first.removeFirstChild();\n                        parent.replaceChild(n, newRoot);\n                        reportCodeChange();\n                        return newRoot;\n                    }\n                case Token.AND:\n                case Token.OR:\n                    {\n                        Node leftParent \u003d first.getFirstChild();\n                        Node rightParent \u003d first.getLastChild();\n                        Node left, right;\n                        if (leftParent.getType() !\u003d Token.NOT \u0026\u0026 rightParent.getType() !\u003d Token.NOT) {\n                            int op_precedence \u003d NodeUtil.precedence(first.getType());\n                            if ((isLowerPrecedence(leftParent, NOT_PRECEDENCE) \u0026\u0026 isHigherPrecedence(leftParent, op_precedence)) || (isLowerPrecedence(rightParent, NOT_PRECEDENCE) \u0026\u0026 isHigherPrecedence(rightParent, op_precedence))) {\n                                return n;\n                            }\n                        }\n                        if (leftParent.getType() \u003d\u003d Token.NOT) {\n                            left \u003d leftParent.removeFirstChild();\n                        } else {\n                            leftParent.detachFromParent();\n                            left \u003d new Node(Token.NOT, leftParent).copyInformationFrom(leftParent);\n                        }\n                        if (rightParent.getType() \u003d\u003d Token.NOT) {\n                            right \u003d rightParent.removeFirstChild();\n                        } else {\n                            rightParent.detachFromParent();\n                            right \u003d new Node(Token.NOT, rightParent).copyInformationFrom(rightParent);\n                        }\n                        int newOp \u003d (first.getType() \u003d\u003d Token.AND) ? Token.OR : Token.AND;\n                        Node newRoot \u003d new Node(newOp, left, right);\n                        parent.replaceChild(n, newRoot);\n                        reportCodeChange();\n                        return newRoot;\n                    }\n                default:\n                    TernaryValue nVal \u003d NodeUtil.getPureBooleanValue(first);\n                    if (nVal !\u003d TernaryValue.UNKNOWN) {\n                        boolean result \u003d nVal.not().toBoolean(true);\n                        int equivalentResult \u003d result ? 1 : 0;\n                        return maybeReplaceChildWithNumber(n, parent, equivalentResult);\n                    }\n            }\n            return n;\n        case Token.OR:\n        case Token.AND:\n            {\n                Node left \u003d n.getFirstChild();\n                Node right \u003d n.getLastChild();\n                left \u003d tryMinimizeCondition(left);\n                right \u003d tryMinimizeCondition(right);\n                TernaryValue rightVal \u003d NodeUtil.getPureBooleanValue(right);\n                if (NodeUtil.getPureBooleanValue(right) !\u003d TernaryValue.UNKNOWN) {\n                    int type \u003d n.getType();\n                    Node replacement \u003d null;\n                    boolean rval \u003d rightVal.toBoolean(true);\n                    if (type \u003d\u003d Token.OR \u0026\u0026 !rval || type \u003d\u003d Token.AND \u0026\u0026 rval) {\n                        replacement \u003d left;\n                    } else if (!mayHaveSideEffects(left)) {\n                        replacement \u003d right;\n                    }\n                    if (replacement !\u003d null) {\n                        n.detachChildren();\n                        parent.replaceChild(n, replacement);\n                        reportCodeChange();\n                        return replacement;\n                    }\n                }\n                return n;\n            }\n        case Token.HOOK:\n            {\n                Node condition \u003d n.getFirstChild();\n                Node trueNode \u003d n.getFirstChild().getNext();\n                Node falseNode \u003d n.getLastChild();\n                trueNode \u003d tryMinimizeCondition(trueNode);\n                falseNode \u003d tryMinimizeCondition(falseNode);\n                Node replacement \u003d null;\n                TernaryValue trueNodeVal \u003d NodeUtil.getPureBooleanValue(trueNode);\n                TernaryValue falseNodeVal \u003d NodeUtil.getPureBooleanValue(falseNode);\n                if (trueNodeVal \u003d\u003d TernaryValue.TRUE \u0026\u0026 falseNodeVal \u003d\u003d TernaryValue.FALSE) {\n                    condition.detachFromParent();\n                    replacement \u003d condition;\n                } else if (trueNodeVal \u003d\u003d TernaryValue.FALSE \u0026\u0026 falseNodeVal \u003d\u003d TernaryValue.TRUE) {\n                    condition.detachFromParent();\n                    replacement \u003d new Node(Token.NOT, condition);\n                } else if (trueNodeVal \u003d\u003d TernaryValue.TRUE) {\n                    n.detachChildren();\n                    replacement \u003d new Node(Token.OR, condition, falseNode);\n                } else if (falseNodeVal \u003d\u003d TernaryValue.FALSE) {\n                    n.detachChildren();\n                    replacement \u003d new Node(Token.AND, condition, trueNode);\n                }\n                if (replacement !\u003d null) {\n                    parent.replaceChild(n, replacement);\n                    n \u003d replacement;\n                    reportCodeChange();\n                }\n                return n;\n            }\n        default:\n            TernaryValue nVal \u003d NodeUtil.getPureBooleanValue(n);\n            if (nVal !\u003d TernaryValue.UNKNOWN) {\n                boolean result \u003d nVal.toBoolean(true);\n                int equivalentResult \u003d result ? 1 : 0;\n                return maybeReplaceChildWithNumber(n, parent, equivalentResult);\n            }\n            return n;\n    }\n}",
      "path": "src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java",
      "functionStartLine": 877,
      "functionName": "tryMinimizeCondition",
      "functionAnnotation": "",
      "functionDoc": "Try to minimize conditions expressions, as there are additional\nassumptions that can be made when it is known that the final result\nis a boolean.\n\nThe following transformations are done recursively:\n  !(x||y) --\u003e !x\u0026\u0026!y\n  !(x\u0026\u0026y) --\u003e !x||!y\n  !!x     --\u003e x\nThus:\n  !(x\u0026\u0026!y) --\u003e !x||!!y --\u003e !x||y\n\n  Returns the replacement for n, or the original if no change was made\n",
      "diff": "@@ -1,116 +1,118 @@\n private Node tryMinimizeCondition(Node n) {\n     Node parent \u003d n.getParent();\n     switch(n.getType()) {\n         case Token.NOT:\n             Node first \u003d n.getFirstChild();\n             switch(first.getType()) {\n                 case Token.NOT:\n                     {\n                         Node newRoot \u003d first.removeFirstChild();\n                         parent.replaceChild(n, newRoot);\n                         reportCodeChange();\n                         return newRoot;\n                     }\n                 case Token.AND:\n                 case Token.OR:\n                     {\n                         Node leftParent \u003d first.getFirstChild();\n                         Node rightParent \u003d first.getLastChild();\n                         Node left, right;\n                         if (leftParent.getType() !\u003d Token.NOT \u0026\u0026 rightParent.getType() !\u003d Token.NOT) {\n                             int op_precedence \u003d NodeUtil.precedence(first.getType());\n                             if ((isLowerPrecedence(leftParent, NOT_PRECEDENCE) \u0026\u0026 isHigherPrecedence(leftParent, op_precedence)) || (isLowerPrecedence(rightParent, NOT_PRECEDENCE) \u0026\u0026 isHigherPrecedence(rightParent, op_precedence))) {\n                                 return n;\n                             }\n                         }\n                         if (leftParent.getType() \u003d\u003d Token.NOT) {\n                             left \u003d leftParent.removeFirstChild();\n                         } else {\n                             leftParent.detachFromParent();\n                             left \u003d new Node(Token.NOT, leftParent).copyInformationFrom(leftParent);\n                         }\n                         if (rightParent.getType() \u003d\u003d Token.NOT) {\n                             right \u003d rightParent.removeFirstChild();\n                         } else {\n                             rightParent.detachFromParent();\n                             right \u003d new Node(Token.NOT, rightParent).copyInformationFrom(rightParent);\n                         }\n                         int newOp \u003d (first.getType() \u003d\u003d Token.AND) ? Token.OR : Token.AND;\n                         Node newRoot \u003d new Node(newOp, left, right);\n                         parent.replaceChild(n, newRoot);\n                         reportCodeChange();\n                         return newRoot;\n                     }\n                 default:\n-                    TernaryValue nVal \u003d NodeUtil.getBooleanValue(first);\n+                    TernaryValue nVal \u003d NodeUtil.getPureBooleanValue(first);\n                     if (nVal !\u003d TernaryValue.UNKNOWN) {\n                         boolean result \u003d nVal.not().toBoolean(true);\n                         int equivalentResult \u003d result ? 1 : 0;\n                         return maybeReplaceChildWithNumber(n, parent, equivalentResult);\n                     }\n             }\n             return n;\n         case Token.OR:\n         case Token.AND:\n             {\n                 Node left \u003d n.getFirstChild();\n                 Node right \u003d n.getLastChild();\n                 left \u003d tryMinimizeCondition(left);\n                 right \u003d tryMinimizeCondition(right);\n-                TernaryValue rightVal \u003d NodeUtil.getBooleanValue(right);\n-                if (NodeUtil.getBooleanValue(right) !\u003d TernaryValue.UNKNOWN) {\n+                TernaryValue rightVal \u003d NodeUtil.getPureBooleanValue(right);\n+                if (NodeUtil.getPureBooleanValue(right) !\u003d TernaryValue.UNKNOWN) {\n                     int type \u003d n.getType();\n                     Node replacement \u003d null;\n                     boolean rval \u003d rightVal.toBoolean(true);\n                     if (type \u003d\u003d Token.OR \u0026\u0026 !rval || type \u003d\u003d Token.AND \u0026\u0026 rval) {\n                         replacement \u003d left;\n                     } else if (!mayHaveSideEffects(left)) {\n                         replacement \u003d right;\n                     }\n                     if (replacement !\u003d null) {\n                         n.detachChildren();\n                         parent.replaceChild(n, replacement);\n                         reportCodeChange();\n                         return replacement;\n                     }\n                 }\n                 return n;\n             }\n         case Token.HOOK:\n             {\n                 Node condition \u003d n.getFirstChild();\n                 Node trueNode \u003d n.getFirstChild().getNext();\n                 Node falseNode \u003d n.getLastChild();\n                 trueNode \u003d tryMinimizeCondition(trueNode);\n                 falseNode \u003d tryMinimizeCondition(falseNode);\n                 Node replacement \u003d null;\n-                if (NodeUtil.getBooleanValue(trueNode) \u003d\u003d TernaryValue.TRUE \u0026\u0026 NodeUtil.getBooleanValue(falseNode) \u003d\u003d TernaryValue.FALSE) {\n+                TernaryValue trueNodeVal \u003d NodeUtil.getPureBooleanValue(trueNode);\n+                TernaryValue falseNodeVal \u003d NodeUtil.getPureBooleanValue(falseNode);\n+                if (trueNodeVal \u003d\u003d TernaryValue.TRUE \u0026\u0026 falseNodeVal \u003d\u003d TernaryValue.FALSE) {\n                     condition.detachFromParent();\n                     replacement \u003d condition;\n-                } else if (NodeUtil.getBooleanValue(trueNode) \u003d\u003d TernaryValue.FALSE \u0026\u0026 NodeUtil.getBooleanValue(falseNode) \u003d\u003d TernaryValue.TRUE) {\n+                } else if (trueNodeVal \u003d\u003d TernaryValue.FALSE \u0026\u0026 falseNodeVal \u003d\u003d TernaryValue.TRUE) {\n                     condition.detachFromParent();\n                     replacement \u003d new Node(Token.NOT, condition);\n-                } else if (NodeUtil.getBooleanValue(trueNode) \u003d\u003d TernaryValue.TRUE) {\n+                } else if (trueNodeVal \u003d\u003d TernaryValue.TRUE) {\n                     n.detachChildren();\n                     replacement \u003d new Node(Token.OR, condition, falseNode);\n-                } else if (NodeUtil.getBooleanValue(falseNode) \u003d\u003d TernaryValue.FALSE) {\n+                } else if (falseNodeVal \u003d\u003d TernaryValue.FALSE) {\n                     n.detachChildren();\n                     replacement \u003d new Node(Token.AND, condition, trueNode);\n                 }\n                 if (replacement !\u003d null) {\n                     parent.replaceChild(n, replacement);\n                     n \u003d replacement;\n                     reportCodeChange();\n                 }\n                 return n;\n             }\n         default:\n-            TernaryValue nVal \u003d NodeUtil.getBooleanValue(n);\n+            TernaryValue nVal \u003d NodeUtil.getPureBooleanValue(n);\n             if (nVal !\u003d TernaryValue.UNKNOWN) {\n                 boolean result \u003d nVal.toBoolean(true);\n                 int equivalentResult \u003d result ? 1 : 0;\n                 return maybeReplaceChildWithNumber(n, parent, equivalentResult);\n             }\n             return n;\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2d0aac92183a4b6bac01d67cfe0114ab96bd908c": {
      "type": "Ybodychange",
      "commitMessage": "\nFixes Issue 3424764\n\nR\u003dacleung\nDELTA\u003d74  (59 added, 1 deleted, 14 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d520\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@781 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "2/14/11, 1:54 PM",
      "commitName": "2d0aac92183a4b6bac01d67cfe0114ab96bd908c",
      "commitAuthor": "zhuyi@google.com",
      "commitDateOld": "2/10/11, 4:32 PM",
      "commitNameOld": "e7ce7f710e1bf297f1a4258b53f22f550fc1f2e3",
      "commitAuthorOld": "acleung@google.com",
      "daysBetweenCommits": 3.89,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "private Node tryMinimizeCondition(Node n) {\n    Node parent \u003d n.getParent();\n    switch(n.getType()) {\n        case Token.NOT:\n            Node first \u003d n.getFirstChild();\n            switch(first.getType()) {\n                case Token.NOT:\n                    {\n                        Node newRoot \u003d first.removeFirstChild();\n                        parent.replaceChild(n, newRoot);\n                        reportCodeChange();\n                        return newRoot;\n                    }\n                case Token.AND:\n                case Token.OR:\n                    {\n                        Node leftParent \u003d first.getFirstChild();\n                        Node rightParent \u003d first.getLastChild();\n                        Node left, right;\n                        if (leftParent.getType() !\u003d Token.NOT \u0026\u0026 rightParent.getType() !\u003d Token.NOT) {\n                            int op_precedence \u003d NodeUtil.precedence(first.getType());\n                            if ((isLowerPrecedence(leftParent, NOT_PRECEDENCE) \u0026\u0026 isHigherPrecedence(leftParent, op_precedence)) || (isLowerPrecedence(rightParent, NOT_PRECEDENCE) \u0026\u0026 isHigherPrecedence(rightParent, op_precedence))) {\n                                return n;\n                            }\n                        }\n                        if (leftParent.getType() \u003d\u003d Token.NOT) {\n                            left \u003d leftParent.removeFirstChild();\n                        } else {\n                            leftParent.detachFromParent();\n                            left \u003d new Node(Token.NOT, leftParent).copyInformationFrom(leftParent);\n                        }\n                        if (rightParent.getType() \u003d\u003d Token.NOT) {\n                            right \u003d rightParent.removeFirstChild();\n                        } else {\n                            rightParent.detachFromParent();\n                            right \u003d new Node(Token.NOT, rightParent).copyInformationFrom(rightParent);\n                        }\n                        int newOp \u003d (first.getType() \u003d\u003d Token.AND) ? Token.OR : Token.AND;\n                        Node newRoot \u003d new Node(newOp, left, right);\n                        parent.replaceChild(n, newRoot);\n                        reportCodeChange();\n                        return newRoot;\n                    }\n                default:\n                    TernaryValue nVal \u003d NodeUtil.getBooleanValue(first);\n                    if (nVal !\u003d TernaryValue.UNKNOWN) {\n                        boolean result \u003d nVal.not().toBoolean(true);\n                        int equivalentResult \u003d result ? 1 : 0;\n                        return maybeReplaceChildWithNumber(n, parent, equivalentResult);\n                    }\n            }\n            return n;\n        case Token.OR:\n        case Token.AND:\n            {\n                Node left \u003d n.getFirstChild();\n                Node right \u003d n.getLastChild();\n                left \u003d tryMinimizeCondition(left);\n                right \u003d tryMinimizeCondition(right);\n                TernaryValue rightVal \u003d NodeUtil.getBooleanValue(right);\n                if (NodeUtil.getBooleanValue(right) !\u003d TernaryValue.UNKNOWN) {\n                    int type \u003d n.getType();\n                    Node replacement \u003d null;\n                    boolean rval \u003d rightVal.toBoolean(true);\n                    if (type \u003d\u003d Token.OR \u0026\u0026 !rval || type \u003d\u003d Token.AND \u0026\u0026 rval) {\n                        replacement \u003d left;\n                    } else if (!mayHaveSideEffects(left)) {\n                        replacement \u003d right;\n                    }\n                    if (replacement !\u003d null) {\n                        n.detachChildren();\n                        parent.replaceChild(n, replacement);\n                        reportCodeChange();\n                        return replacement;\n                    }\n                }\n                return n;\n            }\n        case Token.HOOK:\n            {\n                Node condition \u003d n.getFirstChild();\n                Node trueNode \u003d n.getFirstChild().getNext();\n                Node falseNode \u003d n.getLastChild();\n                trueNode \u003d tryMinimizeCondition(trueNode);\n                falseNode \u003d tryMinimizeCondition(falseNode);\n                Node replacement \u003d null;\n                if (NodeUtil.getBooleanValue(trueNode) \u003d\u003d TernaryValue.TRUE \u0026\u0026 NodeUtil.getBooleanValue(falseNode) \u003d\u003d TernaryValue.FALSE) {\n                    condition.detachFromParent();\n                    replacement \u003d condition;\n                } else if (NodeUtil.getBooleanValue(trueNode) \u003d\u003d TernaryValue.FALSE \u0026\u0026 NodeUtil.getBooleanValue(falseNode) \u003d\u003d TernaryValue.TRUE) {\n                    condition.detachFromParent();\n                    replacement \u003d new Node(Token.NOT, condition);\n                } else if (NodeUtil.getBooleanValue(trueNode) \u003d\u003d TernaryValue.TRUE) {\n                    n.detachChildren();\n                    replacement \u003d new Node(Token.OR, condition, falseNode);\n                } else if (NodeUtil.getBooleanValue(falseNode) \u003d\u003d TernaryValue.FALSE) {\n                    n.detachChildren();\n                    replacement \u003d new Node(Token.AND, condition, trueNode);\n                }\n                if (replacement !\u003d null) {\n                    parent.replaceChild(n, replacement);\n                    n \u003d replacement;\n                    reportCodeChange();\n                }\n                return n;\n            }\n        default:\n            TernaryValue nVal \u003d NodeUtil.getBooleanValue(n);\n            if (nVal !\u003d TernaryValue.UNKNOWN) {\n                boolean result \u003d nVal.toBoolean(true);\n                int equivalentResult \u003d result ? 1 : 0;\n                return maybeReplaceChildWithNumber(n, parent, equivalentResult);\n            }\n            return n;\n    }\n}",
      "path": "src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java",
      "functionStartLine": 824,
      "functionName": "tryMinimizeCondition",
      "functionAnnotation": "",
      "functionDoc": "Try to minimize conditions expressions, as there are additional\nassumptions that can be made when it is known that the final result\nis a boolean.\n\nThe following transformations are done recursively:\n  !(x||y) --\u003e !x\u0026\u0026!y\n  !(x\u0026\u0026y) --\u003e !x||!y\n  !!x     --\u003e x\nThus:\n  !(x\u0026\u0026!y) --\u003e !x||!!y --\u003e !x||y\n\n  Returns the replacement for n, or the original if no change was made\n",
      "diff": "@@ -1,102 +1,116 @@\n private Node tryMinimizeCondition(Node n) {\n     Node parent \u003d n.getParent();\n     switch(n.getType()) {\n         case Token.NOT:\n             Node first \u003d n.getFirstChild();\n             switch(first.getType()) {\n                 case Token.NOT:\n                     {\n                         Node newRoot \u003d first.removeFirstChild();\n                         parent.replaceChild(n, newRoot);\n                         reportCodeChange();\n                         return newRoot;\n                     }\n                 case Token.AND:\n                 case Token.OR:\n                     {\n                         Node leftParent \u003d first.getFirstChild();\n                         Node rightParent \u003d first.getLastChild();\n-                        if (leftParent.getType() \u003d\u003d Token.NOT \u0026\u0026 rightParent.getType() \u003d\u003d Token.NOT) {\n-                            Node left \u003d leftParent.removeFirstChild();\n-                            Node right \u003d rightParent.removeFirstChild();\n-                            int newOp \u003d (first.getType() \u003d\u003d Token.AND) ? Token.OR : Token.AND;\n-                            Node newRoot \u003d new Node(newOp, left, right);\n-                            parent.replaceChild(n, newRoot);\n-                            reportCodeChange();\n-                            return newRoot;\n+                        Node left, right;\n+                        if (leftParent.getType() !\u003d Token.NOT \u0026\u0026 rightParent.getType() !\u003d Token.NOT) {\n+                            int op_precedence \u003d NodeUtil.precedence(first.getType());\n+                            if ((isLowerPrecedence(leftParent, NOT_PRECEDENCE) \u0026\u0026 isHigherPrecedence(leftParent, op_precedence)) || (isLowerPrecedence(rightParent, NOT_PRECEDENCE) \u0026\u0026 isHigherPrecedence(rightParent, op_precedence))) {\n+                                return n;\n+                            }\n                         }\n+                        if (leftParent.getType() \u003d\u003d Token.NOT) {\n+                            left \u003d leftParent.removeFirstChild();\n+                        } else {\n+                            leftParent.detachFromParent();\n+                            left \u003d new Node(Token.NOT, leftParent).copyInformationFrom(leftParent);\n+                        }\n+                        if (rightParent.getType() \u003d\u003d Token.NOT) {\n+                            right \u003d rightParent.removeFirstChild();\n+                        } else {\n+                            rightParent.detachFromParent();\n+                            right \u003d new Node(Token.NOT, rightParent).copyInformationFrom(rightParent);\n+                        }\n+                        int newOp \u003d (first.getType() \u003d\u003d Token.AND) ? Token.OR : Token.AND;\n+                        Node newRoot \u003d new Node(newOp, left, right);\n+                        parent.replaceChild(n, newRoot);\n+                        reportCodeChange();\n+                        return newRoot;\n                     }\n-                    break;\n                 default:\n                     TernaryValue nVal \u003d NodeUtil.getBooleanValue(first);\n                     if (nVal !\u003d TernaryValue.UNKNOWN) {\n                         boolean result \u003d nVal.not().toBoolean(true);\n                         int equivalentResult \u003d result ? 1 : 0;\n                         return maybeReplaceChildWithNumber(n, parent, equivalentResult);\n                     }\n             }\n             return n;\n         case Token.OR:\n         case Token.AND:\n             {\n                 Node left \u003d n.getFirstChild();\n                 Node right \u003d n.getLastChild();\n                 left \u003d tryMinimizeCondition(left);\n                 right \u003d tryMinimizeCondition(right);\n                 TernaryValue rightVal \u003d NodeUtil.getBooleanValue(right);\n                 if (NodeUtil.getBooleanValue(right) !\u003d TernaryValue.UNKNOWN) {\n                     int type \u003d n.getType();\n                     Node replacement \u003d null;\n                     boolean rval \u003d rightVal.toBoolean(true);\n                     if (type \u003d\u003d Token.OR \u0026\u0026 !rval || type \u003d\u003d Token.AND \u0026\u0026 rval) {\n                         replacement \u003d left;\n                     } else if (!mayHaveSideEffects(left)) {\n                         replacement \u003d right;\n                     }\n                     if (replacement !\u003d null) {\n                         n.detachChildren();\n                         parent.replaceChild(n, replacement);\n                         reportCodeChange();\n                         return replacement;\n                     }\n                 }\n                 return n;\n             }\n         case Token.HOOK:\n             {\n                 Node condition \u003d n.getFirstChild();\n                 Node trueNode \u003d n.getFirstChild().getNext();\n                 Node falseNode \u003d n.getLastChild();\n                 trueNode \u003d tryMinimizeCondition(trueNode);\n                 falseNode \u003d tryMinimizeCondition(falseNode);\n                 Node replacement \u003d null;\n                 if (NodeUtil.getBooleanValue(trueNode) \u003d\u003d TernaryValue.TRUE \u0026\u0026 NodeUtil.getBooleanValue(falseNode) \u003d\u003d TernaryValue.FALSE) {\n                     condition.detachFromParent();\n                     replacement \u003d condition;\n                 } else if (NodeUtil.getBooleanValue(trueNode) \u003d\u003d TernaryValue.FALSE \u0026\u0026 NodeUtil.getBooleanValue(falseNode) \u003d\u003d TernaryValue.TRUE) {\n                     condition.detachFromParent();\n                     replacement \u003d new Node(Token.NOT, condition);\n                 } else if (NodeUtil.getBooleanValue(trueNode) \u003d\u003d TernaryValue.TRUE) {\n                     n.detachChildren();\n                     replacement \u003d new Node(Token.OR, condition, falseNode);\n                 } else if (NodeUtil.getBooleanValue(falseNode) \u003d\u003d TernaryValue.FALSE) {\n                     n.detachChildren();\n                     replacement \u003d new Node(Token.AND, condition, trueNode);\n                 }\n                 if (replacement !\u003d null) {\n                     parent.replaceChild(n, replacement);\n                     n \u003d replacement;\n                     reportCodeChange();\n                 }\n                 return n;\n             }\n         default:\n             TernaryValue nVal \u003d NodeUtil.getBooleanValue(n);\n             if (nVal !\u003d TernaryValue.UNKNOWN) {\n                 boolean result \u003d nVal.toBoolean(true);\n                 int equivalentResult \u003d result ? 1 : 0;\n                 return maybeReplaceChildWithNumber(n, parent, equivalentResult);\n             }\n             return n;\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e7ce7f710e1bf297f1a4258b53f22f550fc1f2e3": {
      "type": "Ybodychange",
      "commitMessage": "\nUse !0 and !1 for true and false.\n\nR\u003djohnlenz\nDELTA\u003d97  (81 added, 0 deleted, 16 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d500\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@775 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "2/10/11, 4:32 PM",
      "commitName": "e7ce7f710e1bf297f1a4258b53f22f550fc1f2e3",
      "commitAuthor": "acleung@google.com",
      "commitDateOld": "2/4/11, 2:17 PM",
      "commitNameOld": "4b5575897834707871a359b3b7183c856dd301a8",
      "commitAuthorOld": "acleung@google.com",
      "daysBetweenCommits": 6.09,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "actualSource": "private Node tryMinimizeCondition(Node n) {\n    Node parent \u003d n.getParent();\n    switch(n.getType()) {\n        case Token.NOT:\n            Node first \u003d n.getFirstChild();\n            switch(first.getType()) {\n                case Token.NOT:\n                    {\n                        Node newRoot \u003d first.removeFirstChild();\n                        parent.replaceChild(n, newRoot);\n                        reportCodeChange();\n                        return newRoot;\n                    }\n                case Token.AND:\n                case Token.OR:\n                    {\n                        Node leftParent \u003d first.getFirstChild();\n                        Node rightParent \u003d first.getLastChild();\n                        if (leftParent.getType() \u003d\u003d Token.NOT \u0026\u0026 rightParent.getType() \u003d\u003d Token.NOT) {\n                            Node left \u003d leftParent.removeFirstChild();\n                            Node right \u003d rightParent.removeFirstChild();\n                            int newOp \u003d (first.getType() \u003d\u003d Token.AND) ? Token.OR : Token.AND;\n                            Node newRoot \u003d new Node(newOp, left, right);\n                            parent.replaceChild(n, newRoot);\n                            reportCodeChange();\n                            return newRoot;\n                        }\n                    }\n                    break;\n                default:\n                    TernaryValue nVal \u003d NodeUtil.getBooleanValue(first);\n                    if (nVal !\u003d TernaryValue.UNKNOWN) {\n                        boolean result \u003d nVal.not().toBoolean(true);\n                        int equivalentResult \u003d result ? 1 : 0;\n                        return maybeReplaceChildWithNumber(n, parent, equivalentResult);\n                    }\n            }\n            return n;\n        case Token.OR:\n        case Token.AND:\n            {\n                Node left \u003d n.getFirstChild();\n                Node right \u003d n.getLastChild();\n                left \u003d tryMinimizeCondition(left);\n                right \u003d tryMinimizeCondition(right);\n                TernaryValue rightVal \u003d NodeUtil.getBooleanValue(right);\n                if (NodeUtil.getBooleanValue(right) !\u003d TernaryValue.UNKNOWN) {\n                    int type \u003d n.getType();\n                    Node replacement \u003d null;\n                    boolean rval \u003d rightVal.toBoolean(true);\n                    if (type \u003d\u003d Token.OR \u0026\u0026 !rval || type \u003d\u003d Token.AND \u0026\u0026 rval) {\n                        replacement \u003d left;\n                    } else if (!mayHaveSideEffects(left)) {\n                        replacement \u003d right;\n                    }\n                    if (replacement !\u003d null) {\n                        n.detachChildren();\n                        parent.replaceChild(n, replacement);\n                        reportCodeChange();\n                        return replacement;\n                    }\n                }\n                return n;\n            }\n        case Token.HOOK:\n            {\n                Node condition \u003d n.getFirstChild();\n                Node trueNode \u003d n.getFirstChild().getNext();\n                Node falseNode \u003d n.getLastChild();\n                trueNode \u003d tryMinimizeCondition(trueNode);\n                falseNode \u003d tryMinimizeCondition(falseNode);\n                Node replacement \u003d null;\n                if (NodeUtil.getBooleanValue(trueNode) \u003d\u003d TernaryValue.TRUE \u0026\u0026 NodeUtil.getBooleanValue(falseNode) \u003d\u003d TernaryValue.FALSE) {\n                    condition.detachFromParent();\n                    replacement \u003d condition;\n                } else if (NodeUtil.getBooleanValue(trueNode) \u003d\u003d TernaryValue.FALSE \u0026\u0026 NodeUtil.getBooleanValue(falseNode) \u003d\u003d TernaryValue.TRUE) {\n                    condition.detachFromParent();\n                    replacement \u003d new Node(Token.NOT, condition);\n                } else if (NodeUtil.getBooleanValue(trueNode) \u003d\u003d TernaryValue.TRUE) {\n                    n.detachChildren();\n                    replacement \u003d new Node(Token.OR, condition, falseNode);\n                } else if (NodeUtil.getBooleanValue(falseNode) \u003d\u003d TernaryValue.FALSE) {\n                    n.detachChildren();\n                    replacement \u003d new Node(Token.AND, condition, trueNode);\n                }\n                if (replacement !\u003d null) {\n                    parent.replaceChild(n, replacement);\n                    n \u003d replacement;\n                    reportCodeChange();\n                }\n                return n;\n            }\n        default:\n            TernaryValue nVal \u003d NodeUtil.getBooleanValue(n);\n            if (nVal !\u003d TernaryValue.UNKNOWN) {\n                boolean result \u003d nVal.toBoolean(true);\n                int equivalentResult \u003d result ? 1 : 0;\n                return maybeReplaceChildWithNumber(n, parent, equivalentResult);\n            }\n            return n;\n    }\n}",
      "path": "src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java",
      "functionStartLine": 810,
      "functionName": "tryMinimizeCondition",
      "functionAnnotation": "",
      "functionDoc": "Try to minimize conditions expressions, as there are additional\nassumptions that can be made when it is known that the final result\nis a boolean.\n\nThe following transformations are done recursively:\n  !(x||y) --\u003e !x\u0026\u0026!y\n  !(x\u0026\u0026y) --\u003e !x||!y\n  !!x     --\u003e x\nThus:\n  !(x\u0026\u0026!y) --\u003e !x||!!y --\u003e !x||y\n\n  Returns the replacement for n, or the original if no change was made\n",
      "diff": "@@ -1,95 +1,102 @@\n private Node tryMinimizeCondition(Node n) {\n     Node parent \u003d n.getParent();\n     switch(n.getType()) {\n         case Token.NOT:\n             Node first \u003d n.getFirstChild();\n             switch(first.getType()) {\n                 case Token.NOT:\n                     {\n                         Node newRoot \u003d first.removeFirstChild();\n                         parent.replaceChild(n, newRoot);\n                         reportCodeChange();\n                         return newRoot;\n                     }\n                 case Token.AND:\n                 case Token.OR:\n                     {\n                         Node leftParent \u003d first.getFirstChild();\n                         Node rightParent \u003d first.getLastChild();\n                         if (leftParent.getType() \u003d\u003d Token.NOT \u0026\u0026 rightParent.getType() \u003d\u003d Token.NOT) {\n                             Node left \u003d leftParent.removeFirstChild();\n                             Node right \u003d rightParent.removeFirstChild();\n                             int newOp \u003d (first.getType() \u003d\u003d Token.AND) ? Token.OR : Token.AND;\n                             Node newRoot \u003d new Node(newOp, left, right);\n                             parent.replaceChild(n, newRoot);\n                             reportCodeChange();\n                             return newRoot;\n                         }\n                     }\n                     break;\n+                default:\n+                    TernaryValue nVal \u003d NodeUtil.getBooleanValue(first);\n+                    if (nVal !\u003d TernaryValue.UNKNOWN) {\n+                        boolean result \u003d nVal.not().toBoolean(true);\n+                        int equivalentResult \u003d result ? 1 : 0;\n+                        return maybeReplaceChildWithNumber(n, parent, equivalentResult);\n+                    }\n             }\n             return n;\n         case Token.OR:\n         case Token.AND:\n             {\n                 Node left \u003d n.getFirstChild();\n                 Node right \u003d n.getLastChild();\n                 left \u003d tryMinimizeCondition(left);\n                 right \u003d tryMinimizeCondition(right);\n                 TernaryValue rightVal \u003d NodeUtil.getBooleanValue(right);\n                 if (NodeUtil.getBooleanValue(right) !\u003d TernaryValue.UNKNOWN) {\n                     int type \u003d n.getType();\n                     Node replacement \u003d null;\n                     boolean rval \u003d rightVal.toBoolean(true);\n                     if (type \u003d\u003d Token.OR \u0026\u0026 !rval || type \u003d\u003d Token.AND \u0026\u0026 rval) {\n                         replacement \u003d left;\n                     } else if (!mayHaveSideEffects(left)) {\n                         replacement \u003d right;\n                     }\n                     if (replacement !\u003d null) {\n                         n.detachChildren();\n                         parent.replaceChild(n, replacement);\n                         reportCodeChange();\n                         return replacement;\n                     }\n                 }\n                 return n;\n             }\n         case Token.HOOK:\n             {\n                 Node condition \u003d n.getFirstChild();\n                 Node trueNode \u003d n.getFirstChild().getNext();\n                 Node falseNode \u003d n.getLastChild();\n                 trueNode \u003d tryMinimizeCondition(trueNode);\n                 falseNode \u003d tryMinimizeCondition(falseNode);\n                 Node replacement \u003d null;\n                 if (NodeUtil.getBooleanValue(trueNode) \u003d\u003d TernaryValue.TRUE \u0026\u0026 NodeUtil.getBooleanValue(falseNode) \u003d\u003d TernaryValue.FALSE) {\n                     condition.detachFromParent();\n                     replacement \u003d condition;\n                 } else if (NodeUtil.getBooleanValue(trueNode) \u003d\u003d TernaryValue.FALSE \u0026\u0026 NodeUtil.getBooleanValue(falseNode) \u003d\u003d TernaryValue.TRUE) {\n                     condition.detachFromParent();\n                     replacement \u003d new Node(Token.NOT, condition);\n                 } else if (NodeUtil.getBooleanValue(trueNode) \u003d\u003d TernaryValue.TRUE) {\n                     n.detachChildren();\n                     replacement \u003d new Node(Token.OR, condition, falseNode);\n                 } else if (NodeUtil.getBooleanValue(falseNode) \u003d\u003d TernaryValue.FALSE) {\n                     n.detachChildren();\n                     replacement \u003d new Node(Token.AND, condition, trueNode);\n                 }\n                 if (replacement !\u003d null) {\n                     parent.replaceChild(n, replacement);\n                     n \u003d replacement;\n                     reportCodeChange();\n                 }\n                 return n;\n             }\n         default:\n             TernaryValue nVal \u003d NodeUtil.getBooleanValue(n);\n             if (nVal !\u003d TernaryValue.UNKNOWN) {\n                 boolean result \u003d nVal.toBoolean(true);\n                 int equivalentResult \u003d result ? 1 : 0;\n                 return maybeReplaceChildWithNumber(n, parent, equivalentResult);\n             }\n             return n;\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b7ad2fb211e62adfb260852fd03e4d17ff51226e": {
      "type": "Ybodychange",
      "commitMessage": "\nGeneralze folding of the operands of AND, OR, HOOK in conditions.\nFixes issue 244.\n\nR\u003dacleung\nDELTA\u003d195  (118 added, 56 deleted, 21 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d236991\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@448 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "9/21/10, 9:21 AM",
      "commitName": "b7ad2fb211e62adfb260852fd03e4d17ff51226e",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "9/13/10, 11:12 AM",
      "commitNameOld": "4c6e1039b80859f17de5f3cbcfeba61ed8ea0485",
      "commitAuthorOld": "elbaum@google.com",
      "daysBetweenCommits": 7.92,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "actualSource": "private Node tryMinimizeCondition(Node n) {\n    Node parent \u003d n.getParent();\n    switch(n.getType()) {\n        case Token.NOT:\n            Node first \u003d n.getFirstChild();\n            switch(first.getType()) {\n                case Token.NOT:\n                    {\n                        Node newRoot \u003d first.removeFirstChild();\n                        parent.replaceChild(n, newRoot);\n                        reportCodeChange();\n                        return newRoot;\n                    }\n                case Token.AND:\n                case Token.OR:\n                    {\n                        Node leftParent \u003d first.getFirstChild();\n                        Node rightParent \u003d first.getLastChild();\n                        if (leftParent.getType() \u003d\u003d Token.NOT \u0026\u0026 rightParent.getType() \u003d\u003d Token.NOT) {\n                            Node left \u003d leftParent.removeFirstChild();\n                            Node right \u003d rightParent.removeFirstChild();\n                            int newOp \u003d (first.getType() \u003d\u003d Token.AND) ? Token.OR : Token.AND;\n                            Node newRoot \u003d new Node(newOp, left, right);\n                            parent.replaceChild(n, newRoot);\n                            reportCodeChange();\n                            return newRoot;\n                        }\n                    }\n                    break;\n            }\n            return n;\n        case Token.OR:\n        case Token.AND:\n            {\n                Node left \u003d n.getFirstChild();\n                Node right \u003d n.getLastChild();\n                left \u003d tryMinimizeCondition(left);\n                right \u003d tryMinimizeCondition(right);\n                TernaryValue rightVal \u003d NodeUtil.getBooleanValue(right);\n                if (NodeUtil.getBooleanValue(right) !\u003d TernaryValue.UNKNOWN) {\n                    int type \u003d n.getType();\n                    Node replacement \u003d null;\n                    boolean rval \u003d rightVal.toBoolean(true);\n                    if (type \u003d\u003d Token.OR \u0026\u0026 !rval || type \u003d\u003d Token.AND \u0026\u0026 rval) {\n                        replacement \u003d left;\n                    } else if (!mayHaveSideEffects(left)) {\n                        replacement \u003d right;\n                    }\n                    if (replacement !\u003d null) {\n                        n.detachChildren();\n                        parent.replaceChild(n, replacement);\n                        reportCodeChange();\n                        return replacement;\n                    }\n                }\n                return n;\n            }\n        case Token.HOOK:\n            {\n                Node condition \u003d n.getFirstChild();\n                Node trueNode \u003d n.getFirstChild().getNext();\n                Node falseNode \u003d n.getLastChild();\n                trueNode \u003d tryMinimizeCondition(trueNode);\n                falseNode \u003d tryMinimizeCondition(falseNode);\n                Node replacement \u003d null;\n                if (NodeUtil.getBooleanValue(trueNode) \u003d\u003d TernaryValue.TRUE \u0026\u0026 NodeUtil.getBooleanValue(falseNode) \u003d\u003d TernaryValue.FALSE) {\n                    condition.detachFromParent();\n                    replacement \u003d condition;\n                } else if (NodeUtil.getBooleanValue(trueNode) \u003d\u003d TernaryValue.FALSE \u0026\u0026 NodeUtil.getBooleanValue(falseNode) \u003d\u003d TernaryValue.TRUE) {\n                    condition.detachFromParent();\n                    replacement \u003d new Node(Token.NOT, condition);\n                } else if (NodeUtil.getBooleanValue(trueNode) \u003d\u003d TernaryValue.TRUE) {\n                    n.detachChildren();\n                    replacement \u003d new Node(Token.OR, condition, falseNode);\n                } else if (NodeUtil.getBooleanValue(falseNode) \u003d\u003d TernaryValue.FALSE) {\n                    n.detachChildren();\n                    replacement \u003d new Node(Token.AND, condition, trueNode);\n                }\n                if (replacement !\u003d null) {\n                    parent.replaceChild(n, replacement);\n                    n \u003d replacement;\n                    reportCodeChange();\n                }\n                return n;\n            }\n        default:\n            TernaryValue nVal \u003d NodeUtil.getBooleanValue(n);\n            if (nVal !\u003d TernaryValue.UNKNOWN) {\n                boolean result \u003d nVal.toBoolean(true);\n                int equivalentResult \u003d result ? 1 : 0;\n                return maybeReplaceChildWithNumber(n, parent, equivalentResult);\n            }\n            return n;\n    }\n}",
      "path": "src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java",
      "functionStartLine": 661,
      "functionName": "tryMinimizeCondition",
      "functionAnnotation": "",
      "functionDoc": "Try to minimize conditions expressions, as there are additional\nassumptions that can be made when it is known that the final result\nis a boolean.\n\nThe following transformations are done recursively:\n  !(x||y) --\u003e !x\u0026\u0026!y\n  !(x\u0026\u0026y) --\u003e !x||!y\n  !!x     --\u003e x\nThus:\n  !(x\u0026\u0026!y) --\u003e !x||!!y --\u003e !x||y\n\n  Returns the replacement for n, or the original if no change was made\n",
      "diff": "@@ -1,52 +1,95 @@\n private Node tryMinimizeCondition(Node n) {\n     Node parent \u003d n.getParent();\n     switch(n.getType()) {\n         case Token.NOT:\n             Node first \u003d n.getFirstChild();\n             switch(first.getType()) {\n                 case Token.NOT:\n                     {\n                         Node newRoot \u003d first.removeFirstChild();\n                         parent.replaceChild(n, newRoot);\n-                        n \u003d newRoot;\n                         reportCodeChange();\n-                        return tryMinimizeCondition(n);\n+                        return newRoot;\n                     }\n                 case Token.AND:\n                 case Token.OR:\n                     {\n                         Node leftParent \u003d first.getFirstChild();\n                         Node rightParent \u003d first.getLastChild();\n-                        if (leftParent.getType() !\u003d Token.NOT || rightParent.getType() !\u003d Token.NOT) {\n-                            break;\n+                        if (leftParent.getType() \u003d\u003d Token.NOT \u0026\u0026 rightParent.getType() \u003d\u003d Token.NOT) {\n+                            Node left \u003d leftParent.removeFirstChild();\n+                            Node right \u003d rightParent.removeFirstChild();\n+                            int newOp \u003d (first.getType() \u003d\u003d Token.AND) ? Token.OR : Token.AND;\n+                            Node newRoot \u003d new Node(newOp, left, right);\n+                            parent.replaceChild(n, newRoot);\n+                            reportCodeChange();\n+                            return newRoot;\n                         }\n-                        Node left \u003d leftParent.removeFirstChild();\n-                        Node right \u003d rightParent.removeFirstChild();\n-                        int newOp \u003d (first.getType() \u003d\u003d Token.AND) ? Token.OR : Token.AND;\n-                        Node newRoot \u003d new Node(newOp, left, right);\n-                        parent.replaceChild(n, newRoot);\n-                        n \u003d newRoot;\n-                        reportCodeChange();\n                     }\n                     break;\n             }\n-            break;\n+            return n;\n         case Token.OR:\n         case Token.AND:\n-            break;\n+            {\n+                Node left \u003d n.getFirstChild();\n+                Node right \u003d n.getLastChild();\n+                left \u003d tryMinimizeCondition(left);\n+                right \u003d tryMinimizeCondition(right);\n+                TernaryValue rightVal \u003d NodeUtil.getBooleanValue(right);\n+                if (NodeUtil.getBooleanValue(right) !\u003d TernaryValue.UNKNOWN) {\n+                    int type \u003d n.getType();\n+                    Node replacement \u003d null;\n+                    boolean rval \u003d rightVal.toBoolean(true);\n+                    if (type \u003d\u003d Token.OR \u0026\u0026 !rval || type \u003d\u003d Token.AND \u0026\u0026 rval) {\n+                        replacement \u003d left;\n+                    } else if (!mayHaveSideEffects(left)) {\n+                        replacement \u003d right;\n+                    }\n+                    if (replacement !\u003d null) {\n+                        n.detachChildren();\n+                        parent.replaceChild(n, replacement);\n+                        reportCodeChange();\n+                        return replacement;\n+                    }\n+                }\n+                return n;\n+            }\n+        case Token.HOOK:\n+            {\n+                Node condition \u003d n.getFirstChild();\n+                Node trueNode \u003d n.getFirstChild().getNext();\n+                Node falseNode \u003d n.getLastChild();\n+                trueNode \u003d tryMinimizeCondition(trueNode);\n+                falseNode \u003d tryMinimizeCondition(falseNode);\n+                Node replacement \u003d null;\n+                if (NodeUtil.getBooleanValue(trueNode) \u003d\u003d TernaryValue.TRUE \u0026\u0026 NodeUtil.getBooleanValue(falseNode) \u003d\u003d TernaryValue.FALSE) {\n+                    condition.detachFromParent();\n+                    replacement \u003d condition;\n+                } else if (NodeUtil.getBooleanValue(trueNode) \u003d\u003d TernaryValue.FALSE \u0026\u0026 NodeUtil.getBooleanValue(falseNode) \u003d\u003d TernaryValue.TRUE) {\n+                    condition.detachFromParent();\n+                    replacement \u003d new Node(Token.NOT, condition);\n+                } else if (NodeUtil.getBooleanValue(trueNode) \u003d\u003d TernaryValue.TRUE) {\n+                    n.detachChildren();\n+                    replacement \u003d new Node(Token.OR, condition, falseNode);\n+                } else if (NodeUtil.getBooleanValue(falseNode) \u003d\u003d TernaryValue.FALSE) {\n+                    n.detachChildren();\n+                    replacement \u003d new Node(Token.AND, condition, trueNode);\n+                }\n+                if (replacement !\u003d null) {\n+                    parent.replaceChild(n, replacement);\n+                    n \u003d replacement;\n+                    reportCodeChange();\n+                }\n+                return n;\n+            }\n         default:\n             TernaryValue nVal \u003d NodeUtil.getBooleanValue(n);\n             if (nVal !\u003d TernaryValue.UNKNOWN) {\n                 boolean result \u003d nVal.toBoolean(true);\n                 int equivalentResult \u003d result ? 1 : 0;\n                 return maybeReplaceChildWithNumber(n, parent, equivalentResult);\n             }\n             return n;\n     }\n-    for (Node c \u003d n.getFirstChild(); c !\u003d null; ) {\n-        Node next \u003d c.getNext();\n-        tryMinimizeCondition(c);\n-        c \u003d next;\n-    }\n-    return n;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9de5e9b4671773bb3f2d5932e57c1b4186b9b777": {
      "type": "Yformatchange",
      "commitMessage": "\nChange on 2010/06/30 15:06:33 by johnlenz\n\n\tAdd a diagnostic group so that projects with weird externs can opt-out of the stricter extern checks.\n\n\tR\u003dnicksantos\n\tDELTA\u003d54  (52 added, 0 deleted, 2 changed)\n\nChange on 2010/06/30 17:56:51 by johnlenz\n\n\tRevert warning levels until after a release is put out to control them.\n\n\tR\u003dnicksantos\n\tDELTA\u003d4  (2 added, 0 deleted, 2 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d47002\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@260 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "7/1/10, 7:38 AM",
      "commitName": "9de5e9b4671773bb3f2d5932e57c1b4186b9b777",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "6/29/10, 2:10 PM",
      "commitNameOld": "541402929a600a95bf099513908b4efd8b0e1c5b",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 1.73,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "private Node tryMinimizeCondition(Node n) {\n    Node parent \u003d n.getParent();\n    switch(n.getType()) {\n        case Token.NOT:\n            Node first \u003d n.getFirstChild();\n            switch(first.getType()) {\n                case Token.NOT:\n                    {\n                        Node newRoot \u003d first.removeFirstChild();\n                        parent.replaceChild(n, newRoot);\n                        n \u003d newRoot;\n                        reportCodeChange();\n                        return tryMinimizeCondition(n);\n                    }\n                case Token.AND:\n                case Token.OR:\n                    {\n                        Node leftParent \u003d first.getFirstChild();\n                        Node rightParent \u003d first.getLastChild();\n                        if (leftParent.getType() !\u003d Token.NOT || rightParent.getType() !\u003d Token.NOT) {\n                            break;\n                        }\n                        Node left \u003d leftParent.removeFirstChild();\n                        Node right \u003d rightParent.removeFirstChild();\n                        int newOp \u003d (first.getType() \u003d\u003d Token.AND) ? Token.OR : Token.AND;\n                        Node newRoot \u003d new Node(newOp, left, right);\n                        parent.replaceChild(n, newRoot);\n                        n \u003d newRoot;\n                        reportCodeChange();\n                    }\n                    break;\n            }\n            break;\n        case Token.OR:\n        case Token.AND:\n            break;\n        default:\n            TernaryValue nVal \u003d NodeUtil.getBooleanValue(n);\n            if (nVal !\u003d TernaryValue.UNKNOWN) {\n                boolean result \u003d nVal.toBoolean(true);\n                int equivalentResult \u003d result ? 1 : 0;\n                return maybeReplaceChildWithNumber(n, parent, equivalentResult);\n            }\n            return n;\n    }\n    for (Node c \u003d n.getFirstChild(); c !\u003d null; ) {\n        Node next \u003d c.getNext();\n        tryMinimizeCondition(c);\n        c \u003d next;\n    }\n    return n;\n}",
      "path": "src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java",
      "functionStartLine": 579,
      "functionName": "tryMinimizeCondition",
      "functionAnnotation": "",
      "functionDoc": "Try to minimize conditions expressions, as there are additional\nassumptions that can be made when it is known that the final result\nis a boolean.\n\nThe following transformations are done recursively:\n  !(x||y) --\u003e !x\u0026\u0026!y\n  !(x\u0026\u0026y) --\u003e !x||!y\n  !!x     --\u003e x\nThus:\n  !(x\u0026\u0026!y) --\u003e !x||!!y --\u003e !x||y\n\n  Returns the replacement for n, or the original if no change was made\n",
      "diff": "",
      "extendedDetails": {}
    },
    "c9e89727dc8063d087d28e42629606f4fd74a6e5": {
      "type": "Ymodifierchange",
      "commitMessage": "\nChange on 2010/06/22 by nicksantos\n\n\tvariable coalescing better be run AFTER ambiguate properties, and\n\tafter denormalization.\n\n\tR\u003djohnlenz\n\tDELTA\u003d36  (20 added, 16 deleted, 0 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d34005\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@248 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "6/22/10, 4:00 PM",
      "commitName": "c9e89727dc8063d087d28e42629606f4fd74a6e5",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "6/16/10, 12:33 PM",
      "commitNameOld": "e33e925eea3a8e4de958864e531e1adc4da62e18",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 6.14,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "private Node tryMinimizeCondition(Node n) {\n    Node parent \u003d n.getParent();\n    switch(n.getType()) {\n        case Token.NOT:\n            Node first \u003d n.getFirstChild();\n            switch(first.getType()) {\n                case Token.NOT:\n                    {\n                        Node newRoot \u003d first.removeFirstChild();\n                        parent.replaceChild(n, newRoot);\n                        n \u003d newRoot;\n                        reportCodeChange();\n                        return tryMinimizeCondition(n);\n                    }\n                case Token.AND:\n                case Token.OR:\n                    {\n                        Node leftParent \u003d first.getFirstChild();\n                        Node rightParent \u003d first.getLastChild();\n                        if (leftParent.getType() !\u003d Token.NOT || rightParent.getType() !\u003d Token.NOT) {\n                            break;\n                        }\n                        Node left \u003d leftParent.removeFirstChild();\n                        Node right \u003d rightParent.removeFirstChild();\n                        int newOp \u003d (first.getType() \u003d\u003d Token.AND) ? Token.OR : Token.AND;\n                        Node newRoot \u003d new Node(newOp, left, right);\n                        parent.replaceChild(n, newRoot);\n                        n \u003d newRoot;\n                        reportCodeChange();\n                    }\n                    break;\n            }\n            break;\n        case Token.OR:\n        case Token.AND:\n            break;\n        default:\n            TernaryValue nVal \u003d NodeUtil.getBooleanValue(n);\n            if (nVal !\u003d TernaryValue.UNKNOWN) {\n                boolean result \u003d nVal.toBoolean(true);\n                int equivalentResult \u003d result ? 1 : 0;\n                return maybeReplaceChildWithNumber(n, parent, equivalentResult);\n            }\n            return n;\n    }\n    for (Node c \u003d n.getFirstChild(); c !\u003d null; ) {\n        Node next \u003d c.getNext();\n        tryMinimizeCondition(c);\n        c \u003d next;\n    }\n    return n;\n}",
      "path": "src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java",
      "functionStartLine": 579,
      "functionName": "tryMinimizeCondition",
      "functionAnnotation": "",
      "functionDoc": "Try to minimize conditions expressions, as there are additional\nassumptions that can be made when it is known that the final result\nis a boolean.\n\nThe following transformations are done recursively:\n  !(x||y) --\u003e !x\u0026\u0026!y\n  !(x\u0026\u0026y) --\u003e !x||!y\n  !!x     --\u003e x\nThus:\n  !(x\u0026\u0026!y) --\u003e !x||!!y --\u003e !x||y\n\n  Returns the replacement for n, or the original if no change was made\n",
      "diff": "@@ -1,52 +1,52 @@\n-Node tryMinimizeCondition(Node n) {\n+private Node tryMinimizeCondition(Node n) {\n     Node parent \u003d n.getParent();\n     switch(n.getType()) {\n         case Token.NOT:\n             Node first \u003d n.getFirstChild();\n             switch(first.getType()) {\n                 case Token.NOT:\n                     {\n                         Node newRoot \u003d first.removeFirstChild();\n                         parent.replaceChild(n, newRoot);\n                         n \u003d newRoot;\n                         reportCodeChange();\n                         return tryMinimizeCondition(n);\n                     }\n                 case Token.AND:\n                 case Token.OR:\n                     {\n                         Node leftParent \u003d first.getFirstChild();\n                         Node rightParent \u003d first.getLastChild();\n                         if (leftParent.getType() !\u003d Token.NOT || rightParent.getType() !\u003d Token.NOT) {\n                             break;\n                         }\n                         Node left \u003d leftParent.removeFirstChild();\n                         Node right \u003d rightParent.removeFirstChild();\n                         int newOp \u003d (first.getType() \u003d\u003d Token.AND) ? Token.OR : Token.AND;\n                         Node newRoot \u003d new Node(newOp, left, right);\n                         parent.replaceChild(n, newRoot);\n                         n \u003d newRoot;\n                         reportCodeChange();\n                     }\n                     break;\n             }\n             break;\n         case Token.OR:\n         case Token.AND:\n             break;\n         default:\n             TernaryValue nVal \u003d NodeUtil.getBooleanValue(n);\n             if (nVal !\u003d TernaryValue.UNKNOWN) {\n                 boolean result \u003d nVal.toBoolean(true);\n                 int equivalentResult \u003d result ? 1 : 0;\n                 return maybeReplaceChildWithNumber(n, parent, equivalentResult);\n             }\n             return n;\n     }\n     for (Node c \u003d n.getFirstChild(); c !\u003d null; ) {\n         Node next \u003d c.getNext();\n         tryMinimizeCondition(c);\n         c \u003d next;\n     }\n     return n;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[]",
        "newValue": "[private]"
      }
    },
    "e33e925eea3a8e4de958864e531e1adc4da62e18": {
      "type": "Ybodychange",
      "commitMessage": "\nChange on 2010/06/14 by johnlenz\n\n        Remove unneed parenthese from hook expressions.\n\n        R\u003dacleung\n        DELTA\u003d76  (20 added, 4 deleted, 52 changed)\n\nChange on 2010/06/14 by johnlenz\n\n        Fix non-determinisim.\n\n        R\u003djschorr\n        DELTA\u003d5  (3 added, 0 deleted, 2 changed)\n\nChange on 2010/06/15 by nicksantos\n\n        fix a regression caused by a change in the ordering in which\n        constant folding is done.\n        parts of PeepholeSubstituteAlternateSyntax will crash if they\n        see a NEG node with a NUMBER child.\n        They were assuming that FoldConstants would fold these into one node.\n\n        R\u003ddcc,acleung\n        DELTA\u003d153  (70 added, 6 deleted, 77 changed)\n\nChange on 2010/06/15 by johnlenz\n\n        More debug diffing improvements: convert unique globally unique names\n        to locally unique names for reproduciblity.\n\n        R\u003dacleung\n        DELTA\u003d222  (44 added, 7 deleted, 171 changed)\n\nChange on 2010/06/15 by nicksantos\n\n        Add the @nocompile annotation as a signal that this file should\n        be dropped silently if it gets pulled into a --manage_closure_dependencies\n        build.\n\n        R\u003dbowdidge,gboyer\n        DELTA\u003d82  (60 added, 1 deleted, 21 changed)\n\nChange on 2010/06/15 by dcc\n\n        Refactor FoldConstants dead code removal into PeepholeRemoveDeadCode.\n\n        R\u003dacleung\n        DELTA\u003d744  (403 added, 307 deleted, 34 changed)\n\nChange on 2010/06/15 by dcc\n\n        ExternExports test now emits type annotation for exported externs.\n                - Changed ExternExportsPass to generate the externs as an AST and then print\n        to a String rather than ad hoc with a StringBuilder.\n                - Changed TypedCodeGenerator to generate \u0027*\u0027 (AllType) for parameters with unknown types rather than \u0027?\u0027 (UnknownType) since \u0027?\u0027 is not valid JSDoc.\n\n        R\u003dacleung\n        DELTA\u003d643  (496 added, 66 deleted, 81 changed)\n\nChange on 2010/06/16 by johnlenz\n\n        Tweak to PureFunctionIndentifier to propagate the side-effects for\n        anonymous function expressions like: (Date.now||function(){return\n        +new Date})()\n\n        R\u003davd\n        DELTA\u003d42  (39 added, 0 deleted, 3 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d29010\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@243 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "6/16/10, 12:33 PM",
      "commitName": "e33e925eea3a8e4de958864e531e1adc4da62e18",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "5/29/10, 1:07 PM",
      "commitNameOld": "b4801b28ceea8db0f63da7440d6769cb9b7cce8a",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 17.98,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "Node tryMinimizeCondition(Node n) {\n    Node parent \u003d n.getParent();\n    switch(n.getType()) {\n        case Token.NOT:\n            Node first \u003d n.getFirstChild();\n            switch(first.getType()) {\n                case Token.NOT:\n                    {\n                        Node newRoot \u003d first.removeFirstChild();\n                        parent.replaceChild(n, newRoot);\n                        n \u003d newRoot;\n                        reportCodeChange();\n                        return tryMinimizeCondition(n);\n                    }\n                case Token.AND:\n                case Token.OR:\n                    {\n                        Node leftParent \u003d first.getFirstChild();\n                        Node rightParent \u003d first.getLastChild();\n                        if (leftParent.getType() !\u003d Token.NOT || rightParent.getType() !\u003d Token.NOT) {\n                            break;\n                        }\n                        Node left \u003d leftParent.removeFirstChild();\n                        Node right \u003d rightParent.removeFirstChild();\n                        int newOp \u003d (first.getType() \u003d\u003d Token.AND) ? Token.OR : Token.AND;\n                        Node newRoot \u003d new Node(newOp, left, right);\n                        parent.replaceChild(n, newRoot);\n                        n \u003d newRoot;\n                        reportCodeChange();\n                    }\n                    break;\n            }\n            break;\n        case Token.OR:\n        case Token.AND:\n            break;\n        default:\n            TernaryValue nVal \u003d NodeUtil.getBooleanValue(n);\n            if (nVal !\u003d TernaryValue.UNKNOWN) {\n                boolean result \u003d nVal.toBoolean(true);\n                int equivalentResult \u003d result ? 1 : 0;\n                return maybeReplaceChildWithNumber(n, parent, equivalentResult);\n            }\n            return n;\n    }\n    for (Node c \u003d n.getFirstChild(); c !\u003d null; ) {\n        Node next \u003d c.getNext();\n        tryMinimizeCondition(c);\n        c \u003d next;\n    }\n    return n;\n}",
      "path": "src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java",
      "functionStartLine": 575,
      "functionName": "tryMinimizeCondition",
      "functionAnnotation": "",
      "functionDoc": "Try to minimize conditions expressions, as there are additional\nassumptions that can be made when it is known that the final result\nis a boolean.\n\nThe following transformations are done recursively:\n  !(x||y) --\u003e !x\u0026\u0026!y\n  !(x\u0026\u0026y) --\u003e !x||!y\n  !!x     --\u003e x\nThus:\n  !(x\u0026\u0026!y) --\u003e !x||!!y --\u003e !x||y\n\n  Returns the replacement for n, or the original if no change was made\n",
      "diff": "@@ -1,51 +1,52 @@\n Node tryMinimizeCondition(Node n) {\n     Node parent \u003d n.getParent();\n     switch(n.getType()) {\n         case Token.NOT:\n             Node first \u003d n.getFirstChild();\n             switch(first.getType()) {\n                 case Token.NOT:\n                     {\n                         Node newRoot \u003d first.removeFirstChild();\n                         parent.replaceChild(n, newRoot);\n                         n \u003d newRoot;\n                         reportCodeChange();\n                         return tryMinimizeCondition(n);\n                     }\n                 case Token.AND:\n                 case Token.OR:\n                     {\n                         Node leftParent \u003d first.getFirstChild();\n                         Node rightParent \u003d first.getLastChild();\n                         if (leftParent.getType() !\u003d Token.NOT || rightParent.getType() !\u003d Token.NOT) {\n                             break;\n                         }\n                         Node left \u003d leftParent.removeFirstChild();\n                         Node right \u003d rightParent.removeFirstChild();\n                         int newOp \u003d (first.getType() \u003d\u003d Token.AND) ? Token.OR : Token.AND;\n                         Node newRoot \u003d new Node(newOp, left, right);\n                         parent.replaceChild(n, newRoot);\n                         n \u003d newRoot;\n                         reportCodeChange();\n                     }\n                     break;\n             }\n             break;\n         case Token.OR:\n         case Token.AND:\n             break;\n         default:\n-            if (NodeUtil.isLiteralValue(n)) {\n-                boolean result \u003d NodeUtil.getBooleanValue(n);\n+            TernaryValue nVal \u003d NodeUtil.getBooleanValue(n);\n+            if (nVal !\u003d TernaryValue.UNKNOWN) {\n+                boolean result \u003d nVal.toBoolean(true);\n                 int equivalentResult \u003d result ? 1 : 0;\n                 return maybeReplaceChildWithNumber(n, parent, equivalentResult);\n             }\n             return n;\n     }\n     for (Node c \u003d n.getFirstChild(); c !\u003d null; ) {\n         Node next \u003d c.getNext();\n         tryMinimizeCondition(c);\n         c \u003d next;\n     }\n     return n;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b4801b28ceea8db0f63da7440d6769cb9b7cce8a": {
      "type": "Ymultichange(Ymovefromfile,Yreturntypechange,Ybodychange,Ydocchange,Yparameterchange)",
      "commitMessage": "\nChange on 2010/05/28 by johnlenz\n\n        Inline functions with inner functions into global scope if they don\u0027t\n        declare any names.\n\n        R\u003dacleung\n        DELTA\u003d329  (244 added, 27 deleted, 58 changed)\n\nChange on 2010/05/28 by dcc\n\n        First pass on refactoring FoldConstants into separate peephole optimizations. This changelist adds the notion of an AbstractPeepholeOptimization and adds a PeepholeOptimizationsPass that runs them. In this go around the minimization aspects of FoldConstants have been factored out into PeepholeMinimize. A future change will factor out the other components of FoldConstants into their own PeepholeOptimizations. DefaultPassConfig has also been updated to run the new PeepholeOptimizationPass.\n\n        This change does not move the minimization-related unit tests from FoldConstantsTest to PeepholeMinimizeTest -- a future, separate, change will do so. Hopefully this will make it easier to review.\n\n        R\u003dacleung\n        DELTA\u003d1966  (1271 added, 675 deleted, 20 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d13010\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@235 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "5/29/10, 1:07 PM",
      "commitName": "b4801b28ceea8db0f63da7440d6769cb9b7cce8a",
      "commitAuthor": "Nicholas.J.Santos",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "\nChange on 2010/05/28 by johnlenz\n\n        Inline functions with inner functions into global scope if they don\u0027t\n        declare any names.\n\n        R\u003dacleung\n        DELTA\u003d329  (244 added, 27 deleted, 58 changed)\n\nChange on 2010/05/28 by dcc\n\n        First pass on refactoring FoldConstants into separate peephole optimizations. This changelist adds the notion of an AbstractPeepholeOptimization and adds a PeepholeOptimizationsPass that runs them. In this go around the minimization aspects of FoldConstants have been factored out into PeepholeMinimize. A future change will factor out the other components of FoldConstants into their own PeepholeOptimizations. DefaultPassConfig has also been updated to run the new PeepholeOptimizationPass.\n\n        This change does not move the minimization-related unit tests from FoldConstantsTest to PeepholeMinimizeTest -- a future, separate, change will do so. Hopefully this will make it easier to review.\n\n        R\u003dacleung\n        DELTA\u003d1966  (1271 added, 675 deleted, 20 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d13010\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@235 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "5/29/10, 1:07 PM",
          "commitName": "b4801b28ceea8db0f63da7440d6769cb9b7cce8a",
          "commitAuthor": "Nicholas.J.Santos",
          "commitDateOld": "5/27/10, 10:18 PM",
          "commitNameOld": "6d00ac1a68612aade8a19d7ecc9b180f00ae5234",
          "commitAuthorOld": "Nicholas.J.Santos",
          "daysBetweenCommits": 1.62,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "Node tryMinimizeCondition(Node n) {\n    Node parent \u003d n.getParent();\n    switch(n.getType()) {\n        case Token.NOT:\n            Node first \u003d n.getFirstChild();\n            switch(first.getType()) {\n                case Token.NOT:\n                    {\n                        Node newRoot \u003d first.removeFirstChild();\n                        parent.replaceChild(n, newRoot);\n                        n \u003d newRoot;\n                        reportCodeChange();\n                        return tryMinimizeCondition(n);\n                    }\n                case Token.AND:\n                case Token.OR:\n                    {\n                        Node leftParent \u003d first.getFirstChild();\n                        Node rightParent \u003d first.getLastChild();\n                        if (leftParent.getType() !\u003d Token.NOT || rightParent.getType() !\u003d Token.NOT) {\n                            break;\n                        }\n                        Node left \u003d leftParent.removeFirstChild();\n                        Node right \u003d rightParent.removeFirstChild();\n                        int newOp \u003d (first.getType() \u003d\u003d Token.AND) ? Token.OR : Token.AND;\n                        Node newRoot \u003d new Node(newOp, left, right);\n                        parent.replaceChild(n, newRoot);\n                        n \u003d newRoot;\n                        reportCodeChange();\n                    }\n                    break;\n            }\n            break;\n        case Token.OR:\n        case Token.AND:\n            break;\n        default:\n            if (NodeUtil.isLiteralValue(n)) {\n                boolean result \u003d NodeUtil.getBooleanValue(n);\n                int equivalentResult \u003d result ? 1 : 0;\n                return maybeReplaceChildWithNumber(n, parent, equivalentResult);\n            }\n            return n;\n    }\n    for (Node c \u003d n.getFirstChild(); c !\u003d null; ) {\n        Node next \u003d c.getNext();\n        tryMinimizeCondition(c);\n        c \u003d next;\n    }\n    return n;\n}",
          "path": "src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java",
          "functionStartLine": 566,
          "functionName": "tryMinimizeCondition",
          "functionAnnotation": "",
          "functionDoc": "Try to minimize conditions expressions, as there are additional\nassumptions that can be made when it is known that the final result\nis a boolean.\n\nThe following transformations are done recursively:\n  !(x||y) --\u003e !x\u0026\u0026!y\n  !(x\u0026\u0026y) --\u003e !x||!y\n  !!x     --\u003e x\nThus:\n  !(x\u0026\u0026!y) --\u003e !x||!!y --\u003e !x||y\n\n  Returns the replacement for n, or the original if no change was made\n",
          "diff": "@@ -1,50 +1,51 @@\n-void tryMinimizeCondition(NodeTraversal t, Node n, Node parent) {\n+Node tryMinimizeCondition(Node n) {\n+    Node parent \u003d n.getParent();\n     switch(n.getType()) {\n         case Token.NOT:\n             Node first \u003d n.getFirstChild();\n             switch(first.getType()) {\n                 case Token.NOT:\n                     {\n                         Node newRoot \u003d first.removeFirstChild();\n                         parent.replaceChild(n, newRoot);\n                         n \u003d newRoot;\n-                        t.getCompiler().reportCodeChange();\n-                        tryMinimizeCondition(t, n, parent);\n-                        return;\n+                        reportCodeChange();\n+                        return tryMinimizeCondition(n);\n                     }\n                 case Token.AND:\n                 case Token.OR:\n                     {\n                         Node leftParent \u003d first.getFirstChild();\n                         Node rightParent \u003d first.getLastChild();\n                         if (leftParent.getType() !\u003d Token.NOT || rightParent.getType() !\u003d Token.NOT) {\n                             break;\n                         }\n                         Node left \u003d leftParent.removeFirstChild();\n                         Node right \u003d rightParent.removeFirstChild();\n                         int newOp \u003d (first.getType() \u003d\u003d Token.AND) ? Token.OR : Token.AND;\n                         Node newRoot \u003d new Node(newOp, left, right);\n                         parent.replaceChild(n, newRoot);\n                         n \u003d newRoot;\n-                        t.getCompiler().reportCodeChange();\n+                        reportCodeChange();\n                     }\n                     break;\n             }\n             break;\n         case Token.OR:\n         case Token.AND:\n             break;\n         default:\n             if (NodeUtil.isLiteralValue(n)) {\n                 boolean result \u003d NodeUtil.getBooleanValue(n);\n                 int equivalentResult \u003d result ? 1 : 0;\n-                maybeReplaceChildWithNumber(t, n, parent, equivalentResult);\n+                return maybeReplaceChildWithNumber(n, parent, equivalentResult);\n             }\n-            return;\n+            return n;\n     }\n     for (Node c \u003d n.getFirstChild(); c !\u003d null; ) {\n         Node next \u003d c.getNext();\n-        tryMinimizeCondition(t, c, n);\n+        tryMinimizeCondition(c);\n         c \u003d next;\n     }\n+    return n;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldPath": "src/com/google/javascript/jscomp/FoldConstants.java",
            "newPath": "src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java",
            "oldMethodName": "tryMinimizeCondition",
            "newMethodName": "tryMinimizeCondition"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "\nChange on 2010/05/28 by johnlenz\n\n        Inline functions with inner functions into global scope if they don\u0027t\n        declare any names.\n\n        R\u003dacleung\n        DELTA\u003d329  (244 added, 27 deleted, 58 changed)\n\nChange on 2010/05/28 by dcc\n\n        First pass on refactoring FoldConstants into separate peephole optimizations. This changelist adds the notion of an AbstractPeepholeOptimization and adds a PeepholeOptimizationsPass that runs them. In this go around the minimization aspects of FoldConstants have been factored out into PeepholeMinimize. A future change will factor out the other components of FoldConstants into their own PeepholeOptimizations. DefaultPassConfig has also been updated to run the new PeepholeOptimizationPass.\n\n        This change does not move the minimization-related unit tests from FoldConstantsTest to PeepholeMinimizeTest -- a future, separate, change will do so. Hopefully this will make it easier to review.\n\n        R\u003dacleung\n        DELTA\u003d1966  (1271 added, 675 deleted, 20 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d13010\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@235 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "5/29/10, 1:07 PM",
          "commitName": "b4801b28ceea8db0f63da7440d6769cb9b7cce8a",
          "commitAuthor": "Nicholas.J.Santos",
          "commitDateOld": "5/27/10, 10:18 PM",
          "commitNameOld": "6d00ac1a68612aade8a19d7ecc9b180f00ae5234",
          "commitAuthorOld": "Nicholas.J.Santos",
          "daysBetweenCommits": 1.62,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "Node tryMinimizeCondition(Node n) {\n    Node parent \u003d n.getParent();\n    switch(n.getType()) {\n        case Token.NOT:\n            Node first \u003d n.getFirstChild();\n            switch(first.getType()) {\n                case Token.NOT:\n                    {\n                        Node newRoot \u003d first.removeFirstChild();\n                        parent.replaceChild(n, newRoot);\n                        n \u003d newRoot;\n                        reportCodeChange();\n                        return tryMinimizeCondition(n);\n                    }\n                case Token.AND:\n                case Token.OR:\n                    {\n                        Node leftParent \u003d first.getFirstChild();\n                        Node rightParent \u003d first.getLastChild();\n                        if (leftParent.getType() !\u003d Token.NOT || rightParent.getType() !\u003d Token.NOT) {\n                            break;\n                        }\n                        Node left \u003d leftParent.removeFirstChild();\n                        Node right \u003d rightParent.removeFirstChild();\n                        int newOp \u003d (first.getType() \u003d\u003d Token.AND) ? Token.OR : Token.AND;\n                        Node newRoot \u003d new Node(newOp, left, right);\n                        parent.replaceChild(n, newRoot);\n                        n \u003d newRoot;\n                        reportCodeChange();\n                    }\n                    break;\n            }\n            break;\n        case Token.OR:\n        case Token.AND:\n            break;\n        default:\n            if (NodeUtil.isLiteralValue(n)) {\n                boolean result \u003d NodeUtil.getBooleanValue(n);\n                int equivalentResult \u003d result ? 1 : 0;\n                return maybeReplaceChildWithNumber(n, parent, equivalentResult);\n            }\n            return n;\n    }\n    for (Node c \u003d n.getFirstChild(); c !\u003d null; ) {\n        Node next \u003d c.getNext();\n        tryMinimizeCondition(c);\n        c \u003d next;\n    }\n    return n;\n}",
          "path": "src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java",
          "functionStartLine": 566,
          "functionName": "tryMinimizeCondition",
          "functionAnnotation": "",
          "functionDoc": "Try to minimize conditions expressions, as there are additional\nassumptions that can be made when it is known that the final result\nis a boolean.\n\nThe following transformations are done recursively:\n  !(x||y) --\u003e !x\u0026\u0026!y\n  !(x\u0026\u0026y) --\u003e !x||!y\n  !!x     --\u003e x\nThus:\n  !(x\u0026\u0026!y) --\u003e !x||!!y --\u003e !x||y\n\n  Returns the replacement for n, or the original if no change was made\n",
          "diff": "@@ -1,50 +1,51 @@\n-void tryMinimizeCondition(NodeTraversal t, Node n, Node parent) {\n+Node tryMinimizeCondition(Node n) {\n+    Node parent \u003d n.getParent();\n     switch(n.getType()) {\n         case Token.NOT:\n             Node first \u003d n.getFirstChild();\n             switch(first.getType()) {\n                 case Token.NOT:\n                     {\n                         Node newRoot \u003d first.removeFirstChild();\n                         parent.replaceChild(n, newRoot);\n                         n \u003d newRoot;\n-                        t.getCompiler().reportCodeChange();\n-                        tryMinimizeCondition(t, n, parent);\n-                        return;\n+                        reportCodeChange();\n+                        return tryMinimizeCondition(n);\n                     }\n                 case Token.AND:\n                 case Token.OR:\n                     {\n                         Node leftParent \u003d first.getFirstChild();\n                         Node rightParent \u003d first.getLastChild();\n                         if (leftParent.getType() !\u003d Token.NOT || rightParent.getType() !\u003d Token.NOT) {\n                             break;\n                         }\n                         Node left \u003d leftParent.removeFirstChild();\n                         Node right \u003d rightParent.removeFirstChild();\n                         int newOp \u003d (first.getType() \u003d\u003d Token.AND) ? Token.OR : Token.AND;\n                         Node newRoot \u003d new Node(newOp, left, right);\n                         parent.replaceChild(n, newRoot);\n                         n \u003d newRoot;\n-                        t.getCompiler().reportCodeChange();\n+                        reportCodeChange();\n                     }\n                     break;\n             }\n             break;\n         case Token.OR:\n         case Token.AND:\n             break;\n         default:\n             if (NodeUtil.isLiteralValue(n)) {\n                 boolean result \u003d NodeUtil.getBooleanValue(n);\n                 int equivalentResult \u003d result ? 1 : 0;\n-                maybeReplaceChildWithNumber(t, n, parent, equivalentResult);\n+                return maybeReplaceChildWithNumber(n, parent, equivalentResult);\n             }\n-            return;\n+            return n;\n     }\n     for (Node c \u003d n.getFirstChild(); c !\u003d null; ) {\n         Node next \u003d c.getNext();\n-        tryMinimizeCondition(t, c, n);\n+        tryMinimizeCondition(c);\n         c \u003d next;\n     }\n+    return n;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "void",
            "newValue": "Node"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "\nChange on 2010/05/28 by johnlenz\n\n        Inline functions with inner functions into global scope if they don\u0027t\n        declare any names.\n\n        R\u003dacleung\n        DELTA\u003d329  (244 added, 27 deleted, 58 changed)\n\nChange on 2010/05/28 by dcc\n\n        First pass on refactoring FoldConstants into separate peephole optimizations. This changelist adds the notion of an AbstractPeepholeOptimization and adds a PeepholeOptimizationsPass that runs them. In this go around the minimization aspects of FoldConstants have been factored out into PeepholeMinimize. A future change will factor out the other components of FoldConstants into their own PeepholeOptimizations. DefaultPassConfig has also been updated to run the new PeepholeOptimizationPass.\n\n        This change does not move the minimization-related unit tests from FoldConstantsTest to PeepholeMinimizeTest -- a future, separate, change will do so. Hopefully this will make it easier to review.\n\n        R\u003dacleung\n        DELTA\u003d1966  (1271 added, 675 deleted, 20 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d13010\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@235 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "5/29/10, 1:07 PM",
          "commitName": "b4801b28ceea8db0f63da7440d6769cb9b7cce8a",
          "commitAuthor": "Nicholas.J.Santos",
          "commitDateOld": "5/27/10, 10:18 PM",
          "commitNameOld": "6d00ac1a68612aade8a19d7ecc9b180f00ae5234",
          "commitAuthorOld": "Nicholas.J.Santos",
          "daysBetweenCommits": 1.62,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "Node tryMinimizeCondition(Node n) {\n    Node parent \u003d n.getParent();\n    switch(n.getType()) {\n        case Token.NOT:\n            Node first \u003d n.getFirstChild();\n            switch(first.getType()) {\n                case Token.NOT:\n                    {\n                        Node newRoot \u003d first.removeFirstChild();\n                        parent.replaceChild(n, newRoot);\n                        n \u003d newRoot;\n                        reportCodeChange();\n                        return tryMinimizeCondition(n);\n                    }\n                case Token.AND:\n                case Token.OR:\n                    {\n                        Node leftParent \u003d first.getFirstChild();\n                        Node rightParent \u003d first.getLastChild();\n                        if (leftParent.getType() !\u003d Token.NOT || rightParent.getType() !\u003d Token.NOT) {\n                            break;\n                        }\n                        Node left \u003d leftParent.removeFirstChild();\n                        Node right \u003d rightParent.removeFirstChild();\n                        int newOp \u003d (first.getType() \u003d\u003d Token.AND) ? Token.OR : Token.AND;\n                        Node newRoot \u003d new Node(newOp, left, right);\n                        parent.replaceChild(n, newRoot);\n                        n \u003d newRoot;\n                        reportCodeChange();\n                    }\n                    break;\n            }\n            break;\n        case Token.OR:\n        case Token.AND:\n            break;\n        default:\n            if (NodeUtil.isLiteralValue(n)) {\n                boolean result \u003d NodeUtil.getBooleanValue(n);\n                int equivalentResult \u003d result ? 1 : 0;\n                return maybeReplaceChildWithNumber(n, parent, equivalentResult);\n            }\n            return n;\n    }\n    for (Node c \u003d n.getFirstChild(); c !\u003d null; ) {\n        Node next \u003d c.getNext();\n        tryMinimizeCondition(c);\n        c \u003d next;\n    }\n    return n;\n}",
          "path": "src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java",
          "functionStartLine": 566,
          "functionName": "tryMinimizeCondition",
          "functionAnnotation": "",
          "functionDoc": "Try to minimize conditions expressions, as there are additional\nassumptions that can be made when it is known that the final result\nis a boolean.\n\nThe following transformations are done recursively:\n  !(x||y) --\u003e !x\u0026\u0026!y\n  !(x\u0026\u0026y) --\u003e !x||!y\n  !!x     --\u003e x\nThus:\n  !(x\u0026\u0026!y) --\u003e !x||!!y --\u003e !x||y\n\n  Returns the replacement for n, or the original if no change was made\n",
          "diff": "@@ -1,50 +1,51 @@\n-void tryMinimizeCondition(NodeTraversal t, Node n, Node parent) {\n+Node tryMinimizeCondition(Node n) {\n+    Node parent \u003d n.getParent();\n     switch(n.getType()) {\n         case Token.NOT:\n             Node first \u003d n.getFirstChild();\n             switch(first.getType()) {\n                 case Token.NOT:\n                     {\n                         Node newRoot \u003d first.removeFirstChild();\n                         parent.replaceChild(n, newRoot);\n                         n \u003d newRoot;\n-                        t.getCompiler().reportCodeChange();\n-                        tryMinimizeCondition(t, n, parent);\n-                        return;\n+                        reportCodeChange();\n+                        return tryMinimizeCondition(n);\n                     }\n                 case Token.AND:\n                 case Token.OR:\n                     {\n                         Node leftParent \u003d first.getFirstChild();\n                         Node rightParent \u003d first.getLastChild();\n                         if (leftParent.getType() !\u003d Token.NOT || rightParent.getType() !\u003d Token.NOT) {\n                             break;\n                         }\n                         Node left \u003d leftParent.removeFirstChild();\n                         Node right \u003d rightParent.removeFirstChild();\n                         int newOp \u003d (first.getType() \u003d\u003d Token.AND) ? Token.OR : Token.AND;\n                         Node newRoot \u003d new Node(newOp, left, right);\n                         parent.replaceChild(n, newRoot);\n                         n \u003d newRoot;\n-                        t.getCompiler().reportCodeChange();\n+                        reportCodeChange();\n                     }\n                     break;\n             }\n             break;\n         case Token.OR:\n         case Token.AND:\n             break;\n         default:\n             if (NodeUtil.isLiteralValue(n)) {\n                 boolean result \u003d NodeUtil.getBooleanValue(n);\n                 int equivalentResult \u003d result ? 1 : 0;\n-                maybeReplaceChildWithNumber(t, n, parent, equivalentResult);\n+                return maybeReplaceChildWithNumber(n, parent, equivalentResult);\n             }\n-            return;\n+            return n;\n     }\n     for (Node c \u003d n.getFirstChild(); c !\u003d null; ) {\n         Node next \u003d c.getNext();\n-        tryMinimizeCondition(t, c, n);\n+        tryMinimizeCondition(c);\n         c \u003d next;\n     }\n+    return n;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "\nChange on 2010/05/28 by johnlenz\n\n        Inline functions with inner functions into global scope if they don\u0027t\n        declare any names.\n\n        R\u003dacleung\n        DELTA\u003d329  (244 added, 27 deleted, 58 changed)\n\nChange on 2010/05/28 by dcc\n\n        First pass on refactoring FoldConstants into separate peephole optimizations. This changelist adds the notion of an AbstractPeepholeOptimization and adds a PeepholeOptimizationsPass that runs them. In this go around the minimization aspects of FoldConstants have been factored out into PeepholeMinimize. A future change will factor out the other components of FoldConstants into their own PeepholeOptimizations. DefaultPassConfig has also been updated to run the new PeepholeOptimizationPass.\n\n        This change does not move the minimization-related unit tests from FoldConstantsTest to PeepholeMinimizeTest -- a future, separate, change will do so. Hopefully this will make it easier to review.\n\n        R\u003dacleung\n        DELTA\u003d1966  (1271 added, 675 deleted, 20 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d13010\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@235 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "5/29/10, 1:07 PM",
          "commitName": "b4801b28ceea8db0f63da7440d6769cb9b7cce8a",
          "commitAuthor": "Nicholas.J.Santos",
          "commitDateOld": "5/27/10, 10:18 PM",
          "commitNameOld": "6d00ac1a68612aade8a19d7ecc9b180f00ae5234",
          "commitAuthorOld": "Nicholas.J.Santos",
          "daysBetweenCommits": 1.62,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "Node tryMinimizeCondition(Node n) {\n    Node parent \u003d n.getParent();\n    switch(n.getType()) {\n        case Token.NOT:\n            Node first \u003d n.getFirstChild();\n            switch(first.getType()) {\n                case Token.NOT:\n                    {\n                        Node newRoot \u003d first.removeFirstChild();\n                        parent.replaceChild(n, newRoot);\n                        n \u003d newRoot;\n                        reportCodeChange();\n                        return tryMinimizeCondition(n);\n                    }\n                case Token.AND:\n                case Token.OR:\n                    {\n                        Node leftParent \u003d first.getFirstChild();\n                        Node rightParent \u003d first.getLastChild();\n                        if (leftParent.getType() !\u003d Token.NOT || rightParent.getType() !\u003d Token.NOT) {\n                            break;\n                        }\n                        Node left \u003d leftParent.removeFirstChild();\n                        Node right \u003d rightParent.removeFirstChild();\n                        int newOp \u003d (first.getType() \u003d\u003d Token.AND) ? Token.OR : Token.AND;\n                        Node newRoot \u003d new Node(newOp, left, right);\n                        parent.replaceChild(n, newRoot);\n                        n \u003d newRoot;\n                        reportCodeChange();\n                    }\n                    break;\n            }\n            break;\n        case Token.OR:\n        case Token.AND:\n            break;\n        default:\n            if (NodeUtil.isLiteralValue(n)) {\n                boolean result \u003d NodeUtil.getBooleanValue(n);\n                int equivalentResult \u003d result ? 1 : 0;\n                return maybeReplaceChildWithNumber(n, parent, equivalentResult);\n            }\n            return n;\n    }\n    for (Node c \u003d n.getFirstChild(); c !\u003d null; ) {\n        Node next \u003d c.getNext();\n        tryMinimizeCondition(c);\n        c \u003d next;\n    }\n    return n;\n}",
          "path": "src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java",
          "functionStartLine": 566,
          "functionName": "tryMinimizeCondition",
          "functionAnnotation": "",
          "functionDoc": "Try to minimize conditions expressions, as there are additional\nassumptions that can be made when it is known that the final result\nis a boolean.\n\nThe following transformations are done recursively:\n  !(x||y) --\u003e !x\u0026\u0026!y\n  !(x\u0026\u0026y) --\u003e !x||!y\n  !!x     --\u003e x\nThus:\n  !(x\u0026\u0026!y) --\u003e !x||!!y --\u003e !x||y\n\n  Returns the replacement for n, or the original if no change was made\n",
          "diff": "@@ -1,50 +1,51 @@\n-void tryMinimizeCondition(NodeTraversal t, Node n, Node parent) {\n+Node tryMinimizeCondition(Node n) {\n+    Node parent \u003d n.getParent();\n     switch(n.getType()) {\n         case Token.NOT:\n             Node first \u003d n.getFirstChild();\n             switch(first.getType()) {\n                 case Token.NOT:\n                     {\n                         Node newRoot \u003d first.removeFirstChild();\n                         parent.replaceChild(n, newRoot);\n                         n \u003d newRoot;\n-                        t.getCompiler().reportCodeChange();\n-                        tryMinimizeCondition(t, n, parent);\n-                        return;\n+                        reportCodeChange();\n+                        return tryMinimizeCondition(n);\n                     }\n                 case Token.AND:\n                 case Token.OR:\n                     {\n                         Node leftParent \u003d first.getFirstChild();\n                         Node rightParent \u003d first.getLastChild();\n                         if (leftParent.getType() !\u003d Token.NOT || rightParent.getType() !\u003d Token.NOT) {\n                             break;\n                         }\n                         Node left \u003d leftParent.removeFirstChild();\n                         Node right \u003d rightParent.removeFirstChild();\n                         int newOp \u003d (first.getType() \u003d\u003d Token.AND) ? Token.OR : Token.AND;\n                         Node newRoot \u003d new Node(newOp, left, right);\n                         parent.replaceChild(n, newRoot);\n                         n \u003d newRoot;\n-                        t.getCompiler().reportCodeChange();\n+                        reportCodeChange();\n                     }\n                     break;\n             }\n             break;\n         case Token.OR:\n         case Token.AND:\n             break;\n         default:\n             if (NodeUtil.isLiteralValue(n)) {\n                 boolean result \u003d NodeUtil.getBooleanValue(n);\n                 int equivalentResult \u003d result ? 1 : 0;\n-                maybeReplaceChildWithNumber(t, n, parent, equivalentResult);\n+                return maybeReplaceChildWithNumber(n, parent, equivalentResult);\n             }\n-            return;\n+            return n;\n     }\n     for (Node c \u003d n.getFirstChild(); c !\u003d null; ) {\n         Node next \u003d c.getNext();\n-        tryMinimizeCondition(t, c, n);\n+        tryMinimizeCondition(c);\n         c \u003d next;\n     }\n+    return n;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Try to minimize conditions expressions, as there are additional\nassumptions that can be made when it is known that the final result\nis a boolean.\n\nThe following transformations are done recursively:\n  !(x||y) --\u003e !x\u0026\u0026!y\n  !(x\u0026\u0026y) --\u003e !x||!y\n  !!x     --\u003e x\nThus:\n  !(x\u0026\u0026!y) --\u003e !x||!!y --\u003e !x||y\n",
            "newValue": "Try to minimize conditions expressions, as there are additional\nassumptions that can be made when it is known that the final result\nis a boolean.\n\nThe following transformations are done recursively:\n  !(x||y) --\u003e !x\u0026\u0026!y\n  !(x\u0026\u0026y) --\u003e !x||!y\n  !!x     --\u003e x\nThus:\n  !(x\u0026\u0026!y) --\u003e !x||!!y --\u003e !x||y\n\n  Returns the replacement for n, or the original if no change was made\n"
          }
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "\nChange on 2010/05/28 by johnlenz\n\n        Inline functions with inner functions into global scope if they don\u0027t\n        declare any names.\n\n        R\u003dacleung\n        DELTA\u003d329  (244 added, 27 deleted, 58 changed)\n\nChange on 2010/05/28 by dcc\n\n        First pass on refactoring FoldConstants into separate peephole optimizations. This changelist adds the notion of an AbstractPeepholeOptimization and adds a PeepholeOptimizationsPass that runs them. In this go around the minimization aspects of FoldConstants have been factored out into PeepholeMinimize. A future change will factor out the other components of FoldConstants into their own PeepholeOptimizations. DefaultPassConfig has also been updated to run the new PeepholeOptimizationPass.\n\n        This change does not move the minimization-related unit tests from FoldConstantsTest to PeepholeMinimizeTest -- a future, separate, change will do so. Hopefully this will make it easier to review.\n\n        R\u003dacleung\n        DELTA\u003d1966  (1271 added, 675 deleted, 20 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d13010\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@235 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "5/29/10, 1:07 PM",
          "commitName": "b4801b28ceea8db0f63da7440d6769cb9b7cce8a",
          "commitAuthor": "Nicholas.J.Santos",
          "commitDateOld": "5/27/10, 10:18 PM",
          "commitNameOld": "6d00ac1a68612aade8a19d7ecc9b180f00ae5234",
          "commitAuthorOld": "Nicholas.J.Santos",
          "daysBetweenCommits": 1.62,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "Node tryMinimizeCondition(Node n) {\n    Node parent \u003d n.getParent();\n    switch(n.getType()) {\n        case Token.NOT:\n            Node first \u003d n.getFirstChild();\n            switch(first.getType()) {\n                case Token.NOT:\n                    {\n                        Node newRoot \u003d first.removeFirstChild();\n                        parent.replaceChild(n, newRoot);\n                        n \u003d newRoot;\n                        reportCodeChange();\n                        return tryMinimizeCondition(n);\n                    }\n                case Token.AND:\n                case Token.OR:\n                    {\n                        Node leftParent \u003d first.getFirstChild();\n                        Node rightParent \u003d first.getLastChild();\n                        if (leftParent.getType() !\u003d Token.NOT || rightParent.getType() !\u003d Token.NOT) {\n                            break;\n                        }\n                        Node left \u003d leftParent.removeFirstChild();\n                        Node right \u003d rightParent.removeFirstChild();\n                        int newOp \u003d (first.getType() \u003d\u003d Token.AND) ? Token.OR : Token.AND;\n                        Node newRoot \u003d new Node(newOp, left, right);\n                        parent.replaceChild(n, newRoot);\n                        n \u003d newRoot;\n                        reportCodeChange();\n                    }\n                    break;\n            }\n            break;\n        case Token.OR:\n        case Token.AND:\n            break;\n        default:\n            if (NodeUtil.isLiteralValue(n)) {\n                boolean result \u003d NodeUtil.getBooleanValue(n);\n                int equivalentResult \u003d result ? 1 : 0;\n                return maybeReplaceChildWithNumber(n, parent, equivalentResult);\n            }\n            return n;\n    }\n    for (Node c \u003d n.getFirstChild(); c !\u003d null; ) {\n        Node next \u003d c.getNext();\n        tryMinimizeCondition(c);\n        c \u003d next;\n    }\n    return n;\n}",
          "path": "src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java",
          "functionStartLine": 566,
          "functionName": "tryMinimizeCondition",
          "functionAnnotation": "",
          "functionDoc": "Try to minimize conditions expressions, as there are additional\nassumptions that can be made when it is known that the final result\nis a boolean.\n\nThe following transformations are done recursively:\n  !(x||y) --\u003e !x\u0026\u0026!y\n  !(x\u0026\u0026y) --\u003e !x||!y\n  !!x     --\u003e x\nThus:\n  !(x\u0026\u0026!y) --\u003e !x||!!y --\u003e !x||y\n\n  Returns the replacement for n, or the original if no change was made\n",
          "diff": "@@ -1,50 +1,51 @@\n-void tryMinimizeCondition(NodeTraversal t, Node n, Node parent) {\n+Node tryMinimizeCondition(Node n) {\n+    Node parent \u003d n.getParent();\n     switch(n.getType()) {\n         case Token.NOT:\n             Node first \u003d n.getFirstChild();\n             switch(first.getType()) {\n                 case Token.NOT:\n                     {\n                         Node newRoot \u003d first.removeFirstChild();\n                         parent.replaceChild(n, newRoot);\n                         n \u003d newRoot;\n-                        t.getCompiler().reportCodeChange();\n-                        tryMinimizeCondition(t, n, parent);\n-                        return;\n+                        reportCodeChange();\n+                        return tryMinimizeCondition(n);\n                     }\n                 case Token.AND:\n                 case Token.OR:\n                     {\n                         Node leftParent \u003d first.getFirstChild();\n                         Node rightParent \u003d first.getLastChild();\n                         if (leftParent.getType() !\u003d Token.NOT || rightParent.getType() !\u003d Token.NOT) {\n                             break;\n                         }\n                         Node left \u003d leftParent.removeFirstChild();\n                         Node right \u003d rightParent.removeFirstChild();\n                         int newOp \u003d (first.getType() \u003d\u003d Token.AND) ? Token.OR : Token.AND;\n                         Node newRoot \u003d new Node(newOp, left, right);\n                         parent.replaceChild(n, newRoot);\n                         n \u003d newRoot;\n-                        t.getCompiler().reportCodeChange();\n+                        reportCodeChange();\n                     }\n                     break;\n             }\n             break;\n         case Token.OR:\n         case Token.AND:\n             break;\n         default:\n             if (NodeUtil.isLiteralValue(n)) {\n                 boolean result \u003d NodeUtil.getBooleanValue(n);\n                 int equivalentResult \u003d result ? 1 : 0;\n-                maybeReplaceChildWithNumber(t, n, parent, equivalentResult);\n+                return maybeReplaceChildWithNumber(n, parent, equivalentResult);\n             }\n-            return;\n+            return n;\n     }\n     for (Node c \u003d n.getFirstChild(); c !\u003d null; ) {\n         Node next \u003d c.getNext();\n-        tryMinimizeCondition(t, c, n);\n+        tryMinimizeCondition(c);\n         c \u003d next;\n     }\n+    return n;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[t-NodeTraversal, n-Node, parent-Node]",
            "newValue": "[n-Node]"
          }
        }
      ]
    },
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": {
      "type": "Yintroduced",
      "commitMessage": "Initial commit.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/3/09, 3:51 PM",
      "commitName": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "diff": "@@ -0,0 +1,50 @@\n+void tryMinimizeCondition(NodeTraversal t, Node n, Node parent) {\n+    switch(n.getType()) {\n+        case Token.NOT:\n+            Node first \u003d n.getFirstChild();\n+            switch(first.getType()) {\n+                case Token.NOT:\n+                    {\n+                        Node newRoot \u003d first.removeFirstChild();\n+                        parent.replaceChild(n, newRoot);\n+                        n \u003d newRoot;\n+                        t.getCompiler().reportCodeChange();\n+                        tryMinimizeCondition(t, n, parent);\n+                        return;\n+                    }\n+                case Token.AND:\n+                case Token.OR:\n+                    {\n+                        Node leftParent \u003d first.getFirstChild();\n+                        Node rightParent \u003d first.getLastChild();\n+                        if (leftParent.getType() !\u003d Token.NOT || rightParent.getType() !\u003d Token.NOT) {\n+                            break;\n+                        }\n+                        Node left \u003d leftParent.removeFirstChild();\n+                        Node right \u003d rightParent.removeFirstChild();\n+                        int newOp \u003d (first.getType() \u003d\u003d Token.AND) ? Token.OR : Token.AND;\n+                        Node newRoot \u003d new Node(newOp, left, right);\n+                        parent.replaceChild(n, newRoot);\n+                        n \u003d newRoot;\n+                        t.getCompiler().reportCodeChange();\n+                    }\n+                    break;\n+            }\n+            break;\n+        case Token.OR:\n+        case Token.AND:\n+            break;\n+        default:\n+            if (NodeUtil.isLiteralValue(n)) {\n+                boolean result \u003d NodeUtil.getBooleanValue(n);\n+                int equivalentResult \u003d result ? 1 : 0;\n+                maybeReplaceChildWithNumber(t, n, parent, equivalentResult);\n+            }\n+            return;\n+    }\n+    for (Node c \u003d n.getFirstChild(); c !\u003d null; ) {\n+        Node next \u003d c.getNext();\n+        tryMinimizeCondition(t, c, n);\n+        c \u003d next;\n+    }\n+}\n\\ No newline at end of file\n",
      "actualSource": "void tryMinimizeCondition(NodeTraversal t, Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.NOT:\n            Node first \u003d n.getFirstChild();\n            switch(first.getType()) {\n                case Token.NOT:\n                    {\n                        Node newRoot \u003d first.removeFirstChild();\n                        parent.replaceChild(n, newRoot);\n                        n \u003d newRoot;\n                        t.getCompiler().reportCodeChange();\n                        tryMinimizeCondition(t, n, parent);\n                        return;\n                    }\n                case Token.AND:\n                case Token.OR:\n                    {\n                        Node leftParent \u003d first.getFirstChild();\n                        Node rightParent \u003d first.getLastChild();\n                        if (leftParent.getType() !\u003d Token.NOT || rightParent.getType() !\u003d Token.NOT) {\n                            break;\n                        }\n                        Node left \u003d leftParent.removeFirstChild();\n                        Node right \u003d rightParent.removeFirstChild();\n                        int newOp \u003d (first.getType() \u003d\u003d Token.AND) ? Token.OR : Token.AND;\n                        Node newRoot \u003d new Node(newOp, left, right);\n                        parent.replaceChild(n, newRoot);\n                        n \u003d newRoot;\n                        t.getCompiler().reportCodeChange();\n                    }\n                    break;\n            }\n            break;\n        case Token.OR:\n        case Token.AND:\n            break;\n        default:\n            if (NodeUtil.isLiteralValue(n)) {\n                boolean result \u003d NodeUtil.getBooleanValue(n);\n                int equivalentResult \u003d result ? 1 : 0;\n                maybeReplaceChildWithNumber(t, n, parent, equivalentResult);\n            }\n            return;\n    }\n    for (Node c \u003d n.getFirstChild(); c !\u003d null; ) {\n        Node next \u003d c.getNext();\n        tryMinimizeCondition(t, c, n);\n        c \u003d next;\n    }\n}",
      "path": "src/com/google/javascript/jscomp/FoldConstants.java",
      "functionStartLine": 1852,
      "functionName": "tryMinimizeCondition",
      "functionAnnotation": "",
      "functionDoc": "Try to minimize conditions expressions, as there are additional\nassumptions that can be made when it is known that the final result\nis a boolean.\n\nThe following transformations are done recursively:\n  !(x||y) --\u003e !x\u0026\u0026!y\n  !(x\u0026\u0026y) --\u003e !x||!y\n  !!x     --\u003e x\nThus:\n  !(x\u0026\u0026!y) --\u003e !x||!!y --\u003e !x||y\n"
    }
  }
}