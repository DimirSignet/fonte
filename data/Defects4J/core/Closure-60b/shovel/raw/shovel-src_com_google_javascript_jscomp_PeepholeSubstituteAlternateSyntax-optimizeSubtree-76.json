{
  "origin": "codeshovel",
  "repositoryName": "Closure-60b",
  "repositoryPath": "/tmp/Closure-60b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "PeepholeSubstituteAlternateSyntax.java",
  "functionName": "optimizeSubtree",
  "functionId": "optimizeSubtree___node-Node",
  "sourceFilePath": "src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java",
  "functionAnnotation": "@Override,@SuppressWarnings(\"fallthrough\")",
  "functionDoc": "Tries apply our various peephole minimizations on the passed in node.\n",
  "functionStartLine": 76,
  "functionEndLine": 162,
  "numCommitsSeen": 39,
  "timeTaken": 3924,
  "changeHistory": [
    "26dfe37d9ace5bf791ff4ab8cec7bf1e2eb1b3f5",
    "ff625e7cf8c8f31e5428620c34cac38b503e9cd6",
    "d22f487c828d7c230e55548f0dbe0b303d20e304",
    "7e52b85b7a21128c06f5b7bf598ff0306dc99f06",
    "836a93db616b1cde4c4656fe4c0d781f02ca8ff4",
    "b326ab0a322d0ece76e61955852ada034122192b",
    "fc66128defd24dd67a02b1bdd87d1968126f02ea",
    "e7ce7f710e1bf297f1a4258b53f22f550fc1f2e3",
    "8416f4cd68b13a514aa54ed08e12f552c2404441",
    "b7ad2fb211e62adfb260852fd03e4d17ff51226e",
    "48701cc70fde194c05ecd008fc1015b9d82921d1",
    "9de5e9b4671773bb3f2d5932e57c1b4186b9b777",
    "c9e89727dc8063d087d28e42629606f4fd74a6e5",
    "b4801b28ceea8db0f63da7440d6769cb9b7cce8a"
  ],
  "changeHistoryShort": {
    "26dfe37d9ace5bf791ff4ab8cec7bf1e2eb1b3f5": "Ybodychange",
    "ff625e7cf8c8f31e5428620c34cac38b503e9cd6": "Ybodychange",
    "d22f487c828d7c230e55548f0dbe0b303d20e304": "Ybodychange",
    "7e52b85b7a21128c06f5b7bf598ff0306dc99f06": "Ybodychange",
    "836a93db616b1cde4c4656fe4c0d781f02ca8ff4": "Ybodychange",
    "b326ab0a322d0ece76e61955852ada034122192b": "Ybodychange",
    "fc66128defd24dd67a02b1bdd87d1968126f02ea": "Ybodychange",
    "e7ce7f710e1bf297f1a4258b53f22f550fc1f2e3": "Ybodychange",
    "8416f4cd68b13a514aa54ed08e12f552c2404441": "Ybodychange",
    "b7ad2fb211e62adfb260852fd03e4d17ff51226e": "Ybodychange",
    "48701cc70fde194c05ecd008fc1015b9d82921d1": "Ybodychange",
    "9de5e9b4671773bb3f2d5932e57c1b4186b9b777": "Yformatchange",
    "c9e89727dc8063d087d28e42629606f4fd74a6e5": "Ymultichange(Ybodychange,Yannotationchange)",
    "b4801b28ceea8db0f63da7440d6769cb9b7cce8a": "Yintroduced"
  },
  "changeHistoryDetails": {
    "26dfe37d9ace5bf791ff4ab8cec7bf1e2eb1b3f5": {
      "type": "Ybodychange",
      "commitMessage": "\nAutomated g4 rollback.\n\n*** Reason for rollback ***\n\nFix bind/call folding by taking care to maintain the FREE_CALL\nattribute.\n\n*** Original change description ***\n\nAutomated g4 rollback.\n\n*** Reason for rollback ***\nThis breaks gmail\n\n\n... description truncated by g4 rollback ...\n\nR\u003dmoedinger\nDELTA\u003d151  (150 added, 0 deleted, 1 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d2406\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1209 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "6/24/11, 10:58 AM",
      "commitName": "26dfe37d9ace5bf791ff4ab8cec7bf1e2eb1b3f5",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "6/20/11, 9:56 AM",
      "commitNameOld": "b291781ac6325a8a65e328d88589a94ae9031450",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 4.04,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\n@SuppressWarnings(\"fallthrough\")\npublic Node optimizeSubtree(Node node) {\n    switch(node.getType()) {\n        case Token.RETURN:\n            {\n                Node result \u003d tryRemoveRedundantExit(node);\n                if (result !\u003d node) {\n                    return result;\n                }\n                result \u003d tryReplaceExitWithBreak(node);\n                if (result !\u003d node) {\n                    return result;\n                }\n                return tryReduceReturn(node);\n            }\n        case Token.THROW:\n            {\n                Node result \u003d tryRemoveRedundantExit(node);\n                if (result !\u003d node) {\n                    return result;\n                }\n                return tryReplaceExitWithBreak(node);\n            }\n        case Token.NOT:\n            tryMinimizeCondition(node.getFirstChild());\n            return tryMinimizeNot(node);\n        case Token.IF:\n            tryMinimizeCondition(node.getFirstChild());\n            return tryMinimizeIf(node);\n        case Token.EXPR_RESULT:\n            tryMinimizeCondition(node.getFirstChild());\n            return node;\n        case Token.HOOK:\n            tryMinimizeCondition(node.getFirstChild());\n            return node;\n        case Token.WHILE:\n        case Token.DO:\n            tryMinimizeCondition(NodeUtil.getConditionExpression(node));\n            return node;\n        case Token.FOR:\n            if (!NodeUtil.isForIn(node)) {\n                tryMinimizeCondition(NodeUtil.getConditionExpression(node));\n            }\n            return node;\n        case Token.TRUE:\n        case Token.FALSE:\n            return reduceTrueFalse(node);\n        case Token.NEW:\n            node \u003d tryFoldStandardConstructors(node);\n            if (node.getType() !\u003d Token.CALL) {\n                return node;\n            }\n        case Token.CALL:\n            Node result \u003d tryFoldLiteralConstructor(node);\n            if (result \u003d\u003d node) {\n                result \u003d tryFoldImmediateCallToBoundFunction(node);\n            }\n            return result;\n        case Token.COMMA:\n            return tryFoldComma(node);\n        case Token.NAME:\n            return tryReplaceUndefined(node);\n        case Token.BLOCK:\n            return tryReplaceIf(node);\n        case Token.ARRAYLIT:\n            return tryMinimizeArrayLiteral(node);\n        default:\n            return node;\n    }\n}",
      "path": "src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java",
      "functionStartLine": 76,
      "functionName": "optimizeSubtree",
      "functionAnnotation": "@Override,@SuppressWarnings(\"fallthrough\")",
      "functionDoc": "Tries apply our various peephole minimizations on the passed in node.\n",
      "diff": "@@ -1,67 +1,71 @@\n @Override\n @SuppressWarnings(\"fallthrough\")\n public Node optimizeSubtree(Node node) {\n     switch(node.getType()) {\n         case Token.RETURN:\n             {\n                 Node result \u003d tryRemoveRedundantExit(node);\n                 if (result !\u003d node) {\n                     return result;\n                 }\n                 result \u003d tryReplaceExitWithBreak(node);\n                 if (result !\u003d node) {\n                     return result;\n                 }\n                 return tryReduceReturn(node);\n             }\n         case Token.THROW:\n             {\n                 Node result \u003d tryRemoveRedundantExit(node);\n                 if (result !\u003d node) {\n                     return result;\n                 }\n                 return tryReplaceExitWithBreak(node);\n             }\n         case Token.NOT:\n             tryMinimizeCondition(node.getFirstChild());\n             return tryMinimizeNot(node);\n         case Token.IF:\n             tryMinimizeCondition(node.getFirstChild());\n             return tryMinimizeIf(node);\n         case Token.EXPR_RESULT:\n             tryMinimizeCondition(node.getFirstChild());\n             return node;\n         case Token.HOOK:\n             tryMinimizeCondition(node.getFirstChild());\n             return node;\n         case Token.WHILE:\n         case Token.DO:\n             tryMinimizeCondition(NodeUtil.getConditionExpression(node));\n             return node;\n         case Token.FOR:\n             if (!NodeUtil.isForIn(node)) {\n                 tryMinimizeCondition(NodeUtil.getConditionExpression(node));\n             }\n             return node;\n         case Token.TRUE:\n         case Token.FALSE:\n             return reduceTrueFalse(node);\n         case Token.NEW:\n             node \u003d tryFoldStandardConstructors(node);\n             if (node.getType() !\u003d Token.CALL) {\n                 return node;\n             }\n         case Token.CALL:\n-            return tryFoldLiteralConstructor(node);\n+            Node result \u003d tryFoldLiteralConstructor(node);\n+            if (result \u003d\u003d node) {\n+                result \u003d tryFoldImmediateCallToBoundFunction(node);\n+            }\n+            return result;\n         case Token.COMMA:\n             return tryFoldComma(node);\n         case Token.NAME:\n             return tryReplaceUndefined(node);\n         case Token.BLOCK:\n             return tryReplaceIf(node);\n         case Token.ARRAYLIT:\n             return tryMinimizeArrayLiteral(node);\n         default:\n             return node;\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ff625e7cf8c8f31e5428620c34cac38b503e9cd6": {
      "type": "Ybodychange",
      "commitMessage": "\nFold array of string into splits (for re-rolling back JQuery loops)\n\nR\u003dzhuyi\nDELTA\u003d71  (71 added, 0 deleted, 0 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d2283\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1183 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "6/15/11, 3:13 PM",
      "commitName": "ff625e7cf8c8f31e5428620c34cac38b503e9cd6",
      "commitAuthor": "acleung@google.com",
      "commitDateOld": "6/7/11, 12:54 AM",
      "commitNameOld": "d22f487c828d7c230e55548f0dbe0b303d20e304",
      "commitAuthorOld": "moedinger@google.com",
      "daysBetweenCommits": 8.6,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\n@SuppressWarnings(\"fallthrough\")\npublic Node optimizeSubtree(Node node) {\n    switch(node.getType()) {\n        case Token.RETURN:\n            {\n                Node result \u003d tryRemoveRedundantExit(node);\n                if (result !\u003d node) {\n                    return result;\n                }\n                result \u003d tryReplaceExitWithBreak(node);\n                if (result !\u003d node) {\n                    return result;\n                }\n                return tryReduceReturn(node);\n            }\n        case Token.THROW:\n            {\n                Node result \u003d tryRemoveRedundantExit(node);\n                if (result !\u003d node) {\n                    return result;\n                }\n                return tryReplaceExitWithBreak(node);\n            }\n        case Token.NOT:\n            tryMinimizeCondition(node.getFirstChild());\n            return tryMinimizeNot(node);\n        case Token.IF:\n            tryMinimizeCondition(node.getFirstChild());\n            return tryMinimizeIf(node);\n        case Token.EXPR_RESULT:\n            tryMinimizeCondition(node.getFirstChild());\n            return node;\n        case Token.HOOK:\n            tryMinimizeCondition(node.getFirstChild());\n            return node;\n        case Token.WHILE:\n        case Token.DO:\n            tryMinimizeCondition(NodeUtil.getConditionExpression(node));\n            return node;\n        case Token.FOR:\n            if (!NodeUtil.isForIn(node)) {\n                tryMinimizeCondition(NodeUtil.getConditionExpression(node));\n            }\n            return node;\n        case Token.TRUE:\n        case Token.FALSE:\n            return reduceTrueFalse(node);\n        case Token.NEW:\n            node \u003d tryFoldStandardConstructors(node);\n            if (node.getType() !\u003d Token.CALL) {\n                return node;\n            }\n        case Token.CALL:\n            return tryFoldLiteralConstructor(node);\n        case Token.COMMA:\n            return tryFoldComma(node);\n        case Token.NAME:\n            return tryReplaceUndefined(node);\n        case Token.BLOCK:\n            return tryReplaceIf(node);\n        case Token.ARRAYLIT:\n            return tryMinimizeArrayLiteral(node);\n        default:\n            return node;\n    }\n}",
      "path": "src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java",
      "functionStartLine": 68,
      "functionName": "optimizeSubtree",
      "functionAnnotation": "@Override,@SuppressWarnings(\"fallthrough\")",
      "functionDoc": "Tries apply our various peephole minimizations on the passed in node.\n",
      "diff": "@@ -1,65 +1,67 @@\n @Override\n @SuppressWarnings(\"fallthrough\")\n public Node optimizeSubtree(Node node) {\n     switch(node.getType()) {\n         case Token.RETURN:\n             {\n                 Node result \u003d tryRemoveRedundantExit(node);\n                 if (result !\u003d node) {\n                     return result;\n                 }\n                 result \u003d tryReplaceExitWithBreak(node);\n                 if (result !\u003d node) {\n                     return result;\n                 }\n                 return tryReduceReturn(node);\n             }\n         case Token.THROW:\n             {\n                 Node result \u003d tryRemoveRedundantExit(node);\n                 if (result !\u003d node) {\n                     return result;\n                 }\n                 return tryReplaceExitWithBreak(node);\n             }\n         case Token.NOT:\n             tryMinimizeCondition(node.getFirstChild());\n             return tryMinimizeNot(node);\n         case Token.IF:\n             tryMinimizeCondition(node.getFirstChild());\n             return tryMinimizeIf(node);\n         case Token.EXPR_RESULT:\n             tryMinimizeCondition(node.getFirstChild());\n             return node;\n         case Token.HOOK:\n             tryMinimizeCondition(node.getFirstChild());\n             return node;\n         case Token.WHILE:\n         case Token.DO:\n             tryMinimizeCondition(NodeUtil.getConditionExpression(node));\n             return node;\n         case Token.FOR:\n             if (!NodeUtil.isForIn(node)) {\n                 tryMinimizeCondition(NodeUtil.getConditionExpression(node));\n             }\n             return node;\n         case Token.TRUE:\n         case Token.FALSE:\n             return reduceTrueFalse(node);\n         case Token.NEW:\n             node \u003d tryFoldStandardConstructors(node);\n             if (node.getType() !\u003d Token.CALL) {\n                 return node;\n             }\n         case Token.CALL:\n             return tryFoldLiteralConstructor(node);\n         case Token.COMMA:\n             return tryFoldComma(node);\n         case Token.NAME:\n             return tryReplaceUndefined(node);\n         case Token.BLOCK:\n             return tryReplaceIf(node);\n+        case Token.ARRAYLIT:\n+            return tryMinimizeArrayLiteral(node);\n         default:\n             return node;\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d22f487c828d7c230e55548f0dbe0b303d20e304": {
      "type": "Ybodychange",
      "commitMessage": "\nAutomated g4 rollback.\n\n*** Reason for rollback ***\nbreaks gmail\n\n\n*** Original change description ***\n\nRewrite binds immediately followed by calls.\n\nDELTA\u003d154  (0 added, 153 deleted, 1 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d2197\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1162 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "6/7/11, 12:54 AM",
      "commitName": "d22f487c828d7c230e55548f0dbe0b303d20e304",
      "commitAuthor": "moedinger@google.com",
      "commitDateOld": "6/6/11, 3:36 PM",
      "commitNameOld": "7e52b85b7a21128c06f5b7bf598ff0306dc99f06",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 0.39,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\n@SuppressWarnings(\"fallthrough\")\npublic Node optimizeSubtree(Node node) {\n    switch(node.getType()) {\n        case Token.RETURN:\n            {\n                Node result \u003d tryRemoveRedundantExit(node);\n                if (result !\u003d node) {\n                    return result;\n                }\n                result \u003d tryReplaceExitWithBreak(node);\n                if (result !\u003d node) {\n                    return result;\n                }\n                return tryReduceReturn(node);\n            }\n        case Token.THROW:\n            {\n                Node result \u003d tryRemoveRedundantExit(node);\n                if (result !\u003d node) {\n                    return result;\n                }\n                return tryReplaceExitWithBreak(node);\n            }\n        case Token.NOT:\n            tryMinimizeCondition(node.getFirstChild());\n            return tryMinimizeNot(node);\n        case Token.IF:\n            tryMinimizeCondition(node.getFirstChild());\n            return tryMinimizeIf(node);\n        case Token.EXPR_RESULT:\n            tryMinimizeCondition(node.getFirstChild());\n            return node;\n        case Token.HOOK:\n            tryMinimizeCondition(node.getFirstChild());\n            return node;\n        case Token.WHILE:\n        case Token.DO:\n            tryMinimizeCondition(NodeUtil.getConditionExpression(node));\n            return node;\n        case Token.FOR:\n            if (!NodeUtil.isForIn(node)) {\n                tryMinimizeCondition(NodeUtil.getConditionExpression(node));\n            }\n            return node;\n        case Token.TRUE:\n        case Token.FALSE:\n            return reduceTrueFalse(node);\n        case Token.NEW:\n            node \u003d tryFoldStandardConstructors(node);\n            if (node.getType() !\u003d Token.CALL) {\n                return node;\n            }\n        case Token.CALL:\n            return tryFoldLiteralConstructor(node);\n        case Token.COMMA:\n            return tryFoldComma(node);\n        case Token.NAME:\n            return tryReplaceUndefined(node);\n        case Token.BLOCK:\n            return tryReplaceIf(node);\n        default:\n            return node;\n    }\n}",
      "path": "src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java",
      "functionStartLine": 65,
      "functionName": "optimizeSubtree",
      "functionAnnotation": "@Override,@SuppressWarnings(\"fallthrough\")",
      "functionDoc": "Tries apply our various peephole minimizations on the passed in node.\n",
      "diff": "@@ -1,69 +1,65 @@\n @Override\n @SuppressWarnings(\"fallthrough\")\n public Node optimizeSubtree(Node node) {\n     switch(node.getType()) {\n         case Token.RETURN:\n             {\n                 Node result \u003d tryRemoveRedundantExit(node);\n                 if (result !\u003d node) {\n                     return result;\n                 }\n                 result \u003d tryReplaceExitWithBreak(node);\n                 if (result !\u003d node) {\n                     return result;\n                 }\n                 return tryReduceReturn(node);\n             }\n         case Token.THROW:\n             {\n                 Node result \u003d tryRemoveRedundantExit(node);\n                 if (result !\u003d node) {\n                     return result;\n                 }\n                 return tryReplaceExitWithBreak(node);\n             }\n         case Token.NOT:\n             tryMinimizeCondition(node.getFirstChild());\n             return tryMinimizeNot(node);\n         case Token.IF:\n             tryMinimizeCondition(node.getFirstChild());\n             return tryMinimizeIf(node);\n         case Token.EXPR_RESULT:\n             tryMinimizeCondition(node.getFirstChild());\n             return node;\n         case Token.HOOK:\n             tryMinimizeCondition(node.getFirstChild());\n             return node;\n         case Token.WHILE:\n         case Token.DO:\n             tryMinimizeCondition(NodeUtil.getConditionExpression(node));\n             return node;\n         case Token.FOR:\n             if (!NodeUtil.isForIn(node)) {\n                 tryMinimizeCondition(NodeUtil.getConditionExpression(node));\n             }\n             return node;\n         case Token.TRUE:\n         case Token.FALSE:\n             return reduceTrueFalse(node);\n         case Token.NEW:\n             node \u003d tryFoldStandardConstructors(node);\n             if (node.getType() !\u003d Token.CALL) {\n                 return node;\n             }\n         case Token.CALL:\n-            Node result \u003d tryFoldLiteralConstructor(node);\n-            if (result \u003d\u003d node) {\n-                result \u003d tryFoldImmediateCallToBoundFunction(node);\n-            }\n-            return result;\n+            return tryFoldLiteralConstructor(node);\n         case Token.COMMA:\n             return tryFoldComma(node);\n         case Token.NAME:\n             return tryReplaceUndefined(node);\n         case Token.BLOCK:\n             return tryReplaceIf(node);\n         default:\n             return node;\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7e52b85b7a21128c06f5b7bf598ff0306dc99f06": {
      "type": "Ybodychange",
      "commitMessage": "\nRewrite binds immediately followed by calls.\n\nR\u003dacleung\nDELTA\u003d154  (153 added, 0 deleted, 1 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d2196\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1161 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "6/6/11, 3:36 PM",
      "commitName": "7e52b85b7a21128c06f5b7bf598ff0306dc99f06",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "5/16/11, 3:01 PM",
      "commitNameOld": "828828472848b88b6d3b1e847fa8be5dde78e2da",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 21.02,
      "commitsBetweenForRepo": 52,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\n@SuppressWarnings(\"fallthrough\")\npublic Node optimizeSubtree(Node node) {\n    switch(node.getType()) {\n        case Token.RETURN:\n            {\n                Node result \u003d tryRemoveRedundantExit(node);\n                if (result !\u003d node) {\n                    return result;\n                }\n                result \u003d tryReplaceExitWithBreak(node);\n                if (result !\u003d node) {\n                    return result;\n                }\n                return tryReduceReturn(node);\n            }\n        case Token.THROW:\n            {\n                Node result \u003d tryRemoveRedundantExit(node);\n                if (result !\u003d node) {\n                    return result;\n                }\n                return tryReplaceExitWithBreak(node);\n            }\n        case Token.NOT:\n            tryMinimizeCondition(node.getFirstChild());\n            return tryMinimizeNot(node);\n        case Token.IF:\n            tryMinimizeCondition(node.getFirstChild());\n            return tryMinimizeIf(node);\n        case Token.EXPR_RESULT:\n            tryMinimizeCondition(node.getFirstChild());\n            return node;\n        case Token.HOOK:\n            tryMinimizeCondition(node.getFirstChild());\n            return node;\n        case Token.WHILE:\n        case Token.DO:\n            tryMinimizeCondition(NodeUtil.getConditionExpression(node));\n            return node;\n        case Token.FOR:\n            if (!NodeUtil.isForIn(node)) {\n                tryMinimizeCondition(NodeUtil.getConditionExpression(node));\n            }\n            return node;\n        case Token.TRUE:\n        case Token.FALSE:\n            return reduceTrueFalse(node);\n        case Token.NEW:\n            node \u003d tryFoldStandardConstructors(node);\n            if (node.getType() !\u003d Token.CALL) {\n                return node;\n            }\n        case Token.CALL:\n            Node result \u003d tryFoldLiteralConstructor(node);\n            if (result \u003d\u003d node) {\n                result \u003d tryFoldImmediateCallToBoundFunction(node);\n            }\n            return result;\n        case Token.COMMA:\n            return tryFoldComma(node);\n        case Token.NAME:\n            return tryReplaceUndefined(node);\n        case Token.BLOCK:\n            return tryReplaceIf(node);\n        default:\n            return node;\n    }\n}",
      "path": "src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java",
      "functionStartLine": 66,
      "functionName": "optimizeSubtree",
      "functionAnnotation": "@Override,@SuppressWarnings(\"fallthrough\")",
      "functionDoc": "Tries apply our various peephole minimizations on the passed in node.\n",
      "diff": "@@ -1,65 +1,69 @@\n @Override\n @SuppressWarnings(\"fallthrough\")\n public Node optimizeSubtree(Node node) {\n     switch(node.getType()) {\n         case Token.RETURN:\n             {\n                 Node result \u003d tryRemoveRedundantExit(node);\n                 if (result !\u003d node) {\n                     return result;\n                 }\n                 result \u003d tryReplaceExitWithBreak(node);\n                 if (result !\u003d node) {\n                     return result;\n                 }\n                 return tryReduceReturn(node);\n             }\n         case Token.THROW:\n             {\n                 Node result \u003d tryRemoveRedundantExit(node);\n                 if (result !\u003d node) {\n                     return result;\n                 }\n                 return tryReplaceExitWithBreak(node);\n             }\n         case Token.NOT:\n             tryMinimizeCondition(node.getFirstChild());\n             return tryMinimizeNot(node);\n         case Token.IF:\n             tryMinimizeCondition(node.getFirstChild());\n             return tryMinimizeIf(node);\n         case Token.EXPR_RESULT:\n             tryMinimizeCondition(node.getFirstChild());\n             return node;\n         case Token.HOOK:\n             tryMinimizeCondition(node.getFirstChild());\n             return node;\n         case Token.WHILE:\n         case Token.DO:\n             tryMinimizeCondition(NodeUtil.getConditionExpression(node));\n             return node;\n         case Token.FOR:\n             if (!NodeUtil.isForIn(node)) {\n                 tryMinimizeCondition(NodeUtil.getConditionExpression(node));\n             }\n             return node;\n         case Token.TRUE:\n         case Token.FALSE:\n             return reduceTrueFalse(node);\n         case Token.NEW:\n             node \u003d tryFoldStandardConstructors(node);\n             if (node.getType() !\u003d Token.CALL) {\n                 return node;\n             }\n         case Token.CALL:\n-            return tryFoldLiteralConstructor(node);\n+            Node result \u003d tryFoldLiteralConstructor(node);\n+            if (result \u003d\u003d node) {\n+                result \u003d tryFoldImmediateCallToBoundFunction(node);\n+            }\n+            return result;\n         case Token.COMMA:\n             return tryFoldComma(node);\n         case Token.NAME:\n             return tryReplaceUndefined(node);\n         case Token.BLOCK:\n             return tryReplaceIf(node);\n         default:\n             return node;\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "836a93db616b1cde4c4656fe4c0d781f02ca8ff4": {
      "type": "Ybodychange",
      "commitMessage": "\nAdd handling for \"if (cond) return expression1; return expression2;\nFixes issue 436\nIssue: http://code.google.com/p/closure-compiler/issues/detail?id\u003d436\n\nR\u003dacleung\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d1912\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1100 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "5/13/11, 9:09 PM",
      "commitName": "836a93db616b1cde4c4656fe4c0d781f02ca8ff4",
      "commitAuthor": "fmeawad@google.com",
      "commitDateOld": "4/12/11, 12:15 PM",
      "commitNameOld": "f322be0e576d5e2114cb59c0a6537197997b9c59",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 31.37,
      "commitsBetweenForRepo": 97,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\n@SuppressWarnings(\"fallthrough\")\npublic Node optimizeSubtree(Node node) {\n    switch(node.getType()) {\n        case Token.RETURN:\n            {\n                Node result \u003d tryRemoveRedundantExit(node);\n                if (result !\u003d node) {\n                    return result;\n                }\n                result \u003d tryReplaceExitWithBreak(node);\n                if (result !\u003d node) {\n                    return result;\n                }\n                return tryReduceReturn(node);\n            }\n        case Token.THROW:\n            {\n                Node result \u003d tryRemoveRedundantExit(node);\n                if (result !\u003d node) {\n                    return result;\n                }\n                return tryReplaceExitWithBreak(node);\n            }\n        case Token.NOT:\n            tryMinimizeCondition(node.getFirstChild());\n            return tryMinimizeNot(node);\n        case Token.IF:\n            tryMinimizeCondition(node.getFirstChild());\n            return tryMinimizeIf(node);\n        case Token.EXPR_RESULT:\n            tryMinimizeCondition(node.getFirstChild());\n            return node;\n        case Token.HOOK:\n            tryMinimizeCondition(node.getFirstChild());\n            return node;\n        case Token.WHILE:\n        case Token.DO:\n            tryMinimizeCondition(NodeUtil.getConditionExpression(node));\n            return node;\n        case Token.FOR:\n            if (!NodeUtil.isForIn(node)) {\n                tryMinimizeCondition(NodeUtil.getConditionExpression(node));\n            }\n            return node;\n        case Token.TRUE:\n        case Token.FALSE:\n            return reduceTrueFalse(node);\n        case Token.NEW:\n            node \u003d tryFoldStandardConstructors(node);\n            if (node.getType() !\u003d Token.CALL) {\n                return node;\n            }\n        case Token.CALL:\n            return tryFoldLiteralConstructor(node);\n        case Token.COMMA:\n            return tryFoldComma(node);\n        case Token.NAME:\n            return tryReplaceUndefined(node);\n        case Token.BLOCK:\n            return tryReplaceIf(node);\n        default:\n            return node;\n    }\n}",
      "path": "src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java",
      "functionStartLine": 65,
      "functionName": "optimizeSubtree",
      "functionAnnotation": "@Override,@SuppressWarnings(\"fallthrough\")",
      "functionDoc": "Tries apply our various peephole minimizations on the passed in node.\n",
      "diff": "@@ -1,63 +1,65 @@\n @Override\n @SuppressWarnings(\"fallthrough\")\n public Node optimizeSubtree(Node node) {\n     switch(node.getType()) {\n         case Token.RETURN:\n             {\n                 Node result \u003d tryRemoveRedundantExit(node);\n                 if (result !\u003d node) {\n                     return result;\n                 }\n                 result \u003d tryReplaceExitWithBreak(node);\n                 if (result !\u003d node) {\n                     return result;\n                 }\n                 return tryReduceReturn(node);\n             }\n         case Token.THROW:\n             {\n                 Node result \u003d tryRemoveRedundantExit(node);\n                 if (result !\u003d node) {\n                     return result;\n                 }\n                 return tryReplaceExitWithBreak(node);\n             }\n         case Token.NOT:\n             tryMinimizeCondition(node.getFirstChild());\n             return tryMinimizeNot(node);\n         case Token.IF:\n             tryMinimizeCondition(node.getFirstChild());\n             return tryMinimizeIf(node);\n         case Token.EXPR_RESULT:\n             tryMinimizeCondition(node.getFirstChild());\n             return node;\n         case Token.HOOK:\n             tryMinimizeCondition(node.getFirstChild());\n             return node;\n         case Token.WHILE:\n         case Token.DO:\n             tryMinimizeCondition(NodeUtil.getConditionExpression(node));\n             return node;\n         case Token.FOR:\n             if (!NodeUtil.isForIn(node)) {\n                 tryMinimizeCondition(NodeUtil.getConditionExpression(node));\n             }\n             return node;\n         case Token.TRUE:\n         case Token.FALSE:\n             return reduceTrueFalse(node);\n         case Token.NEW:\n             node \u003d tryFoldStandardConstructors(node);\n             if (node.getType() !\u003d Token.CALL) {\n                 return node;\n             }\n         case Token.CALL:\n             return tryFoldLiteralConstructor(node);\n         case Token.COMMA:\n             return tryFoldComma(node);\n         case Token.NAME:\n             return tryReplaceUndefined(node);\n+        case Token.BLOCK:\n+            return tryReplaceIf(node);\n         default:\n             return node;\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b326ab0a322d0ece76e61955852ada034122192b": {
      "type": "Ybodychange",
      "commitMessage": "\nIntroduces a late peephole optimization pass.\n\nR\u003djohnlenz\nDELTA\u003d206  (116 added, 57 deleted, 33 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d783\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@860 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "3/7/11, 4:19 PM",
      "commitName": "b326ab0a322d0ece76e61955852ada034122192b",
      "commitAuthor": "acleung@google.com",
      "commitDateOld": "3/3/11, 5:04 PM",
      "commitNameOld": "e4cf805a6a27301672660756202e8dedee1e012b",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 3.97,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\n@SuppressWarnings(\"fallthrough\")\npublic Node optimizeSubtree(Node node) {\n    switch(node.getType()) {\n        case Token.RETURN:\n            {\n                Node result \u003d tryRemoveRedundantExit(node);\n                if (result !\u003d node) {\n                    return result;\n                }\n                result \u003d tryReplaceExitWithBreak(node);\n                if (result !\u003d node) {\n                    return result;\n                }\n                return tryReduceReturn(node);\n            }\n        case Token.THROW:\n            {\n                Node result \u003d tryRemoveRedundantExit(node);\n                if (result !\u003d node) {\n                    return result;\n                }\n                return tryReplaceExitWithBreak(node);\n            }\n        case Token.NOT:\n            tryMinimizeCondition(node.getFirstChild());\n            return tryMinimizeNot(node);\n        case Token.IF:\n            tryMinimizeCondition(node.getFirstChild());\n            return tryMinimizeIf(node);\n        case Token.EXPR_RESULT:\n            tryMinimizeCondition(node.getFirstChild());\n            return node;\n        case Token.HOOK:\n            tryMinimizeCondition(node.getFirstChild());\n            return node;\n        case Token.WHILE:\n        case Token.DO:\n            tryMinimizeCondition(NodeUtil.getConditionExpression(node));\n            return node;\n        case Token.FOR:\n            if (!NodeUtil.isForIn(node)) {\n                tryMinimizeCondition(NodeUtil.getConditionExpression(node));\n            }\n            return node;\n        case Token.TRUE:\n        case Token.FALSE:\n            return reduceTrueFalse(node);\n        case Token.NEW:\n            node \u003d tryFoldStandardConstructors(node);\n            if (node.getType() !\u003d Token.CALL) {\n                return node;\n            }\n        case Token.CALL:\n            return tryFoldLiteralConstructor(node);\n        case Token.COMMA:\n            return tryFoldComma(node);\n        case Token.NAME:\n            return tryReplaceUndefined(node);\n        default:\n            return node;\n    }\n}",
      "path": "src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java",
      "functionStartLine": 65,
      "functionName": "optimizeSubtree",
      "functionAnnotation": "@Override,@SuppressWarnings(\"fallthrough\")",
      "functionDoc": "Tries apply our various peephole minimizations on the passed in node.\n",
      "diff": "@@ -1,61 +1,63 @@\n @Override\n @SuppressWarnings(\"fallthrough\")\n public Node optimizeSubtree(Node node) {\n     switch(node.getType()) {\n         case Token.RETURN:\n             {\n                 Node result \u003d tryRemoveRedundantExit(node);\n                 if (result !\u003d node) {\n                     return result;\n                 }\n                 result \u003d tryReplaceExitWithBreak(node);\n                 if (result !\u003d node) {\n                     return result;\n                 }\n                 return tryReduceReturn(node);\n             }\n         case Token.THROW:\n             {\n                 Node result \u003d tryRemoveRedundantExit(node);\n                 if (result !\u003d node) {\n                     return result;\n                 }\n                 return tryReplaceExitWithBreak(node);\n             }\n         case Token.NOT:\n             tryMinimizeCondition(node.getFirstChild());\n             return tryMinimizeNot(node);\n         case Token.IF:\n             tryMinimizeCondition(node.getFirstChild());\n             return tryMinimizeIf(node);\n         case Token.EXPR_RESULT:\n             tryMinimizeCondition(node.getFirstChild());\n             return node;\n         case Token.HOOK:\n             tryMinimizeCondition(node.getFirstChild());\n             return node;\n         case Token.WHILE:\n         case Token.DO:\n             tryMinimizeCondition(NodeUtil.getConditionExpression(node));\n             return node;\n         case Token.FOR:\n             if (!NodeUtil.isForIn(node)) {\n                 tryMinimizeCondition(NodeUtil.getConditionExpression(node));\n             }\n             return node;\n         case Token.TRUE:\n         case Token.FALSE:\n             return reduceTrueFalse(node);\n         case Token.NEW:\n             node \u003d tryFoldStandardConstructors(node);\n             if (node.getType() !\u003d Token.CALL) {\n                 return node;\n             }\n         case Token.CALL:\n             return tryFoldLiteralConstructor(node);\n+        case Token.COMMA:\n+            return tryFoldComma(node);\n         case Token.NAME:\n             return tryReplaceUndefined(node);\n         default:\n             return node;\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fc66128defd24dd67a02b1bdd87d1968126f02ea": {
      "type": "Ybodychange",
      "commitMessage": "\nFold \"undefined\" to \"void 0\".\nFold side-effect free \"void ...\" expressions to \"void 0\".\n\nR\u003dacleung\nDELTA\u003d54  (52 added, 0 deleted, 2 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d544\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@791 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "2/16/11, 1:24 PM",
      "commitName": "fc66128defd24dd67a02b1bdd87d1968126f02ea",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "2/15/11, 1:06 PM",
      "commitNameOld": "cf3fcbbc124d5b8948d7bef5215c45d80dbeae8e",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 1.01,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\n@SuppressWarnings(\"fallthrough\")\npublic Node optimizeSubtree(Node node) {\n    switch(node.getType()) {\n        case Token.RETURN:\n            {\n                Node result \u003d tryRemoveRedundantExit(node);\n                if (result !\u003d node) {\n                    return result;\n                }\n                result \u003d tryReplaceExitWithBreak(node);\n                if (result !\u003d node) {\n                    return result;\n                }\n                return tryReduceReturn(node);\n            }\n        case Token.THROW:\n            {\n                Node result \u003d tryRemoveRedundantExit(node);\n                if (result !\u003d node) {\n                    return result;\n                }\n                return tryReplaceExitWithBreak(node);\n            }\n        case Token.NOT:\n            tryMinimizeCondition(node.getFirstChild());\n            return tryMinimizeNot(node);\n        case Token.IF:\n            tryMinimizeCondition(node.getFirstChild());\n            return tryMinimizeIf(node);\n        case Token.EXPR_RESULT:\n            tryMinimizeCondition(node.getFirstChild());\n            return node;\n        case Token.HOOK:\n            tryMinimizeCondition(node.getFirstChild());\n            return node;\n        case Token.WHILE:\n        case Token.DO:\n            tryMinimizeCondition(NodeUtil.getConditionExpression(node));\n            return node;\n        case Token.FOR:\n            if (!NodeUtil.isForIn(node)) {\n                tryMinimizeCondition(NodeUtil.getConditionExpression(node));\n            }\n            return node;\n        case Token.TRUE:\n        case Token.FALSE:\n            return reduceTrueFalse(node);\n        case Token.NEW:\n            node \u003d tryFoldStandardConstructors(node);\n            if (node.getType() !\u003d Token.CALL) {\n                return node;\n            }\n        case Token.CALL:\n            return tryFoldLiteralConstructor(node);\n        case Token.NAME:\n            return tryReplaceUndefined(node);\n        default:\n            return node;\n    }\n}",
      "path": "src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java",
      "functionStartLine": 59,
      "functionName": "optimizeSubtree",
      "functionAnnotation": "@Override,@SuppressWarnings(\"fallthrough\")",
      "functionDoc": "Tries apply our various peephole minimizations on the passed in node.\n",
      "diff": "@@ -1,59 +1,61 @@\n @Override\n @SuppressWarnings(\"fallthrough\")\n public Node optimizeSubtree(Node node) {\n     switch(node.getType()) {\n         case Token.RETURN:\n             {\n                 Node result \u003d tryRemoveRedundantExit(node);\n                 if (result !\u003d node) {\n                     return result;\n                 }\n                 result \u003d tryReplaceExitWithBreak(node);\n                 if (result !\u003d node) {\n                     return result;\n                 }\n                 return tryReduceReturn(node);\n             }\n         case Token.THROW:\n             {\n                 Node result \u003d tryRemoveRedundantExit(node);\n                 if (result !\u003d node) {\n                     return result;\n                 }\n                 return tryReplaceExitWithBreak(node);\n             }\n         case Token.NOT:\n             tryMinimizeCondition(node.getFirstChild());\n             return tryMinimizeNot(node);\n         case Token.IF:\n             tryMinimizeCondition(node.getFirstChild());\n             return tryMinimizeIf(node);\n         case Token.EXPR_RESULT:\n             tryMinimizeCondition(node.getFirstChild());\n             return node;\n         case Token.HOOK:\n             tryMinimizeCondition(node.getFirstChild());\n             return node;\n         case Token.WHILE:\n         case Token.DO:\n             tryMinimizeCondition(NodeUtil.getConditionExpression(node));\n             return node;\n         case Token.FOR:\n             if (!NodeUtil.isForIn(node)) {\n                 tryMinimizeCondition(NodeUtil.getConditionExpression(node));\n             }\n             return node;\n         case Token.TRUE:\n         case Token.FALSE:\n             return reduceTrueFalse(node);\n         case Token.NEW:\n             node \u003d tryFoldStandardConstructors(node);\n             if (node.getType() !\u003d Token.CALL) {\n                 return node;\n             }\n         case Token.CALL:\n             return tryFoldLiteralConstructor(node);\n+        case Token.NAME:\n+            return tryReplaceUndefined(node);\n         default:\n             return node;\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e7ce7f710e1bf297f1a4258b53f22f550fc1f2e3": {
      "type": "Ybodychange",
      "commitMessage": "\nUse !0 and !1 for true and false.\n\nR\u003djohnlenz\nDELTA\u003d97  (81 added, 0 deleted, 16 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d500\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@775 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "2/10/11, 4:32 PM",
      "commitName": "e7ce7f710e1bf297f1a4258b53f22f550fc1f2e3",
      "commitAuthor": "acleung@google.com",
      "commitDateOld": "2/4/11, 2:17 PM",
      "commitNameOld": "4b5575897834707871a359b3b7183c856dd301a8",
      "commitAuthorOld": "acleung@google.com",
      "daysBetweenCommits": 6.09,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\n@SuppressWarnings(\"fallthrough\")\npublic Node optimizeSubtree(Node node) {\n    switch(node.getType()) {\n        case Token.RETURN:\n            {\n                Node result \u003d tryRemoveRedundantExit(node);\n                if (result !\u003d node) {\n                    return result;\n                }\n                result \u003d tryReplaceExitWithBreak(node);\n                if (result !\u003d node) {\n                    return result;\n                }\n                return tryReduceReturn(node);\n            }\n        case Token.THROW:\n            {\n                Node result \u003d tryRemoveRedundantExit(node);\n                if (result !\u003d node) {\n                    return result;\n                }\n                return tryReplaceExitWithBreak(node);\n            }\n        case Token.NOT:\n            tryMinimizeCondition(node.getFirstChild());\n            return tryMinimizeNot(node);\n        case Token.IF:\n            tryMinimizeCondition(node.getFirstChild());\n            return tryMinimizeIf(node);\n        case Token.EXPR_RESULT:\n            tryMinimizeCondition(node.getFirstChild());\n            return node;\n        case Token.HOOK:\n            tryMinimizeCondition(node.getFirstChild());\n            return node;\n        case Token.WHILE:\n        case Token.DO:\n            tryMinimizeCondition(NodeUtil.getConditionExpression(node));\n            return node;\n        case Token.FOR:\n            if (!NodeUtil.isForIn(node)) {\n                tryMinimizeCondition(NodeUtil.getConditionExpression(node));\n            }\n            return node;\n        case Token.TRUE:\n        case Token.FALSE:\n            return reduceTrueFalse(node);\n        case Token.NEW:\n            node \u003d tryFoldStandardConstructors(node);\n            if (node.getType() !\u003d Token.CALL) {\n                return node;\n            }\n        case Token.CALL:\n            return tryFoldLiteralConstructor(node);\n        default:\n            return node;\n    }\n}",
      "path": "src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java",
      "functionStartLine": 58,
      "functionName": "optimizeSubtree",
      "functionAnnotation": "@Override,@SuppressWarnings(\"fallthrough\")",
      "functionDoc": "Tries apply our various peephole minimizations on the passed in node.\n",
      "diff": "@@ -1,56 +1,59 @@\n @Override\n @SuppressWarnings(\"fallthrough\")\n public Node optimizeSubtree(Node node) {\n     switch(node.getType()) {\n         case Token.RETURN:\n             {\n                 Node result \u003d tryRemoveRedundantExit(node);\n                 if (result !\u003d node) {\n                     return result;\n                 }\n                 result \u003d tryReplaceExitWithBreak(node);\n                 if (result !\u003d node) {\n                     return result;\n                 }\n                 return tryReduceReturn(node);\n             }\n         case Token.THROW:\n             {\n                 Node result \u003d tryRemoveRedundantExit(node);\n                 if (result !\u003d node) {\n                     return result;\n                 }\n                 return tryReplaceExitWithBreak(node);\n             }\n         case Token.NOT:\n             tryMinimizeCondition(node.getFirstChild());\n             return tryMinimizeNot(node);\n         case Token.IF:\n             tryMinimizeCondition(node.getFirstChild());\n             return tryMinimizeIf(node);\n         case Token.EXPR_RESULT:\n             tryMinimizeCondition(node.getFirstChild());\n             return node;\n         case Token.HOOK:\n             tryMinimizeCondition(node.getFirstChild());\n             return node;\n         case Token.WHILE:\n         case Token.DO:\n             tryMinimizeCondition(NodeUtil.getConditionExpression(node));\n             return node;\n         case Token.FOR:\n             if (!NodeUtil.isForIn(node)) {\n                 tryMinimizeCondition(NodeUtil.getConditionExpression(node));\n             }\n             return node;\n+        case Token.TRUE:\n+        case Token.FALSE:\n+            return reduceTrueFalse(node);\n         case Token.NEW:\n             node \u003d tryFoldStandardConstructors(node);\n             if (node.getType() !\u003d Token.CALL) {\n                 return node;\n             }\n         case Token.CALL:\n             return tryFoldLiteralConstructor(node);\n         default:\n             return node;\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8416f4cd68b13a514aa54ed08e12f552c2404441": {
      "type": "Ybodychange",
      "commitMessage": "\nGeneral eliminations of redundant returns and throws.\n\nR\u003dnicksantos\nDELTA\u003d416  (314 added, 82 deleted, 20 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d164\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@649 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "12/20/10, 11:35 AM",
      "commitName": "8416f4cd68b13a514aa54ed08e12f552c2404441",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "12/14/10, 3:17 PM",
      "commitNameOld": "f64a3f51bd346547ce6e1edb30601df73dff27d9",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 5.85,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\n@SuppressWarnings(\"fallthrough\")\npublic Node optimizeSubtree(Node node) {\n    switch(node.getType()) {\n        case Token.RETURN:\n            {\n                Node result \u003d tryRemoveRedundantExit(node);\n                if (result !\u003d node) {\n                    return result;\n                }\n                result \u003d tryReplaceExitWithBreak(node);\n                if (result !\u003d node) {\n                    return result;\n                }\n                return tryReduceReturn(node);\n            }\n        case Token.THROW:\n            {\n                Node result \u003d tryRemoveRedundantExit(node);\n                if (result !\u003d node) {\n                    return result;\n                }\n                return tryReplaceExitWithBreak(node);\n            }\n        case Token.NOT:\n            tryMinimizeCondition(node.getFirstChild());\n            return tryMinimizeNot(node);\n        case Token.IF:\n            tryMinimizeCondition(node.getFirstChild());\n            return tryMinimizeIf(node);\n        case Token.EXPR_RESULT:\n            tryMinimizeCondition(node.getFirstChild());\n            return node;\n        case Token.HOOK:\n            tryMinimizeCondition(node.getFirstChild());\n            return node;\n        case Token.WHILE:\n        case Token.DO:\n            tryMinimizeCondition(NodeUtil.getConditionExpression(node));\n            return node;\n        case Token.FOR:\n            if (!NodeUtil.isForIn(node)) {\n                tryMinimizeCondition(NodeUtil.getConditionExpression(node));\n            }\n            return node;\n        case Token.NEW:\n            node \u003d tryFoldStandardConstructors(node);\n            if (node.getType() !\u003d Token.CALL) {\n                return node;\n            }\n        case Token.CALL:\n            return tryFoldLiteralConstructor(node);\n        default:\n            return node;\n    }\n}",
      "path": "src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java",
      "functionStartLine": 58,
      "functionName": "optimizeSubtree",
      "functionAnnotation": "@Override,@SuppressWarnings(\"fallthrough\")",
      "functionDoc": "Tries apply our various peephole minimizations on the passed in node.\n",
      "diff": "@@ -1,38 +1,56 @@\n @Override\n @SuppressWarnings(\"fallthrough\")\n public Node optimizeSubtree(Node node) {\n     switch(node.getType()) {\n         case Token.RETURN:\n-            return tryReduceReturn(node);\n+            {\n+                Node result \u003d tryRemoveRedundantExit(node);\n+                if (result !\u003d node) {\n+                    return result;\n+                }\n+                result \u003d tryReplaceExitWithBreak(node);\n+                if (result !\u003d node) {\n+                    return result;\n+                }\n+                return tryReduceReturn(node);\n+            }\n+        case Token.THROW:\n+            {\n+                Node result \u003d tryRemoveRedundantExit(node);\n+                if (result !\u003d node) {\n+                    return result;\n+                }\n+                return tryReplaceExitWithBreak(node);\n+            }\n         case Token.NOT:\n             tryMinimizeCondition(node.getFirstChild());\n             return tryMinimizeNot(node);\n         case Token.IF:\n             tryMinimizeCondition(node.getFirstChild());\n             return tryMinimizeIf(node);\n         case Token.EXPR_RESULT:\n             tryMinimizeCondition(node.getFirstChild());\n             return node;\n         case Token.HOOK:\n             tryMinimizeCondition(node.getFirstChild());\n             return node;\n         case Token.WHILE:\n         case Token.DO:\n             tryMinimizeCondition(NodeUtil.getConditionExpression(node));\n             return node;\n         case Token.FOR:\n             if (!NodeUtil.isForIn(node)) {\n                 tryMinimizeCondition(NodeUtil.getConditionExpression(node));\n             }\n             return node;\n         case Token.NEW:\n             node \u003d tryFoldStandardConstructors(node);\n             if (node.getType() !\u003d Token.CALL) {\n                 return node;\n             }\n         case Token.CALL:\n             return tryFoldLiteralConstructor(node);\n         default:\n             return node;\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b7ad2fb211e62adfb260852fd03e4d17ff51226e": {
      "type": "Ybodychange",
      "commitMessage": "\nGeneralze folding of the operands of AND, OR, HOOK in conditions.\nFixes issue 244.\n\nR\u003dacleung\nDELTA\u003d195  (118 added, 56 deleted, 21 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d236991\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@448 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "9/21/10, 9:21 AM",
      "commitName": "b7ad2fb211e62adfb260852fd03e4d17ff51226e",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "9/13/10, 11:12 AM",
      "commitNameOld": "4c6e1039b80859f17de5f3cbcfeba61ed8ea0485",
      "commitAuthorOld": "elbaum@google.com",
      "daysBetweenCommits": 7.92,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\n@SuppressWarnings(\"fallthrough\")\npublic Node optimizeSubtree(Node node) {\n    switch(node.getType()) {\n        case Token.RETURN:\n            return tryReduceReturn(node);\n        case Token.NOT:\n            tryMinimizeCondition(node.getFirstChild());\n            return tryMinimizeNot(node);\n        case Token.IF:\n            tryMinimizeCondition(node.getFirstChild());\n            return tryMinimizeIf(node);\n        case Token.EXPR_RESULT:\n            tryMinimizeCondition(node.getFirstChild());\n            return node;\n        case Token.HOOK:\n            tryMinimizeCondition(node.getFirstChild());\n            return node;\n        case Token.WHILE:\n        case Token.DO:\n            tryMinimizeCondition(NodeUtil.getConditionExpression(node));\n            return node;\n        case Token.FOR:\n            if (!NodeUtil.isForIn(node)) {\n                tryMinimizeCondition(NodeUtil.getConditionExpression(node));\n            }\n            return node;\n        case Token.NEW:\n            node \u003d tryFoldStandardConstructors(node);\n            if (node.getType() !\u003d Token.CALL) {\n                return node;\n            }\n        case Token.CALL:\n            return tryFoldLiteralConstructor(node);\n        default:\n            return node;\n    }\n}",
      "path": "src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java",
      "functionStartLine": 58,
      "functionName": "optimizeSubtree",
      "functionAnnotation": "@Override,@SuppressWarnings(\"fallthrough\")",
      "functionDoc": "Tries apply our various peephole minimizations on the passed in node.\n",
      "diff": "@@ -1,37 +1,38 @@\n @Override\n @SuppressWarnings(\"fallthrough\")\n public Node optimizeSubtree(Node node) {\n     switch(node.getType()) {\n         case Token.RETURN:\n             return tryReduceReturn(node);\n         case Token.NOT:\n+            tryMinimizeCondition(node.getFirstChild());\n             return tryMinimizeNot(node);\n         case Token.IF:\n             tryMinimizeCondition(node.getFirstChild());\n             return tryMinimizeIf(node);\n         case Token.EXPR_RESULT:\n             tryMinimizeCondition(node.getFirstChild());\n             return node;\n         case Token.HOOK:\n             tryMinimizeCondition(node.getFirstChild());\n             return node;\n         case Token.WHILE:\n         case Token.DO:\n             tryMinimizeCondition(NodeUtil.getConditionExpression(node));\n             return node;\n         case Token.FOR:\n             if (!NodeUtil.isForIn(node)) {\n                 tryMinimizeCondition(NodeUtil.getConditionExpression(node));\n             }\n             return node;\n         case Token.NEW:\n             node \u003d tryFoldStandardConstructors(node);\n             if (node.getType() !\u003d Token.CALL) {\n                 return node;\n             }\n         case Token.CALL:\n             return tryFoldLiteralConstructor(node);\n         default:\n             return node;\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "48701cc70fde194c05ecd008fc1015b9d82921d1": {
      "type": "Ybodychange",
      "commitMessage": "\n- Generalize unused operation removal and remove a couple of special cases (HOOK, NOT).\n- Add handling for other AST locations that can have unused ops removed (COMMA lhs and FOR increment expressions).\n\nR\u003dacleung\nDELTA\u003d358  (260 added, 80 deleted, 18 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d197245\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@390 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "8/27/10, 3:09 PM",
      "commitName": "48701cc70fde194c05ecd008fc1015b9d82921d1",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "8/12/10, 6:02 PM",
      "commitNameOld": "15acafb00636f99295b394145b9b60a5e624ddfa",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 14.88,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\n@SuppressWarnings(\"fallthrough\")\npublic Node optimizeSubtree(Node node) {\n    switch(node.getType()) {\n        case Token.RETURN:\n            return tryReduceReturn(node);\n        case Token.NOT:\n            return tryMinimizeNot(node);\n        case Token.IF:\n            tryMinimizeCondition(node.getFirstChild());\n            return tryMinimizeIf(node);\n        case Token.EXPR_RESULT:\n            tryMinimizeCondition(node.getFirstChild());\n            return node;\n        case Token.HOOK:\n            tryMinimizeCondition(node.getFirstChild());\n            return node;\n        case Token.WHILE:\n        case Token.DO:\n            tryMinimizeCondition(NodeUtil.getConditionExpression(node));\n            return node;\n        case Token.FOR:\n            if (!NodeUtil.isForIn(node)) {\n                tryMinimizeCondition(NodeUtil.getConditionExpression(node));\n            }\n            return node;\n        case Token.NEW:\n            node \u003d tryFoldStandardConstructors(node);\n            if (node.getType() !\u003d Token.CALL) {\n                return node;\n            }\n        case Token.CALL:\n            return tryFoldLiteralConstructor(node);\n        default:\n            return node;\n    }\n}",
      "path": "src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java",
      "functionStartLine": 60,
      "functionName": "optimizeSubtree",
      "functionAnnotation": "@Override,@SuppressWarnings(\"fallthrough\")",
      "functionDoc": "Tries apply our various peephole minimizations on the passed in node.\n",
      "diff": "@@ -1,35 +1,37 @@\n @Override\n @SuppressWarnings(\"fallthrough\")\n public Node optimizeSubtree(Node node) {\n     switch(node.getType()) {\n         case Token.RETURN:\n             return tryReduceReturn(node);\n         case Token.NOT:\n             return tryMinimizeNot(node);\n         case Token.IF:\n             tryMinimizeCondition(node.getFirstChild());\n             return tryMinimizeIf(node);\n         case Token.EXPR_RESULT:\n             tryMinimizeCondition(node.getFirstChild());\n             return node;\n         case Token.HOOK:\n             tryMinimizeCondition(node.getFirstChild());\n             return node;\n         case Token.WHILE:\n         case Token.DO:\n+            tryMinimizeCondition(NodeUtil.getConditionExpression(node));\n+            return node;\n         case Token.FOR:\n-            if (NodeUtil.getConditionExpression(node) !\u003d null) {\n+            if (!NodeUtil.isForIn(node)) {\n                 tryMinimizeCondition(NodeUtil.getConditionExpression(node));\n             }\n             return node;\n         case Token.NEW:\n             node \u003d tryFoldStandardConstructors(node);\n             if (node.getType() !\u003d Token.CALL) {\n                 return node;\n             }\n         case Token.CALL:\n             return tryFoldLiteralConstructor(node);\n         default:\n             return node;\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9de5e9b4671773bb3f2d5932e57c1b4186b9b777": {
      "type": "Yformatchange",
      "commitMessage": "\nChange on 2010/06/30 15:06:33 by johnlenz\n\n\tAdd a diagnostic group so that projects with weird externs can opt-out of the stricter extern checks.\n\n\tR\u003dnicksantos\n\tDELTA\u003d54  (52 added, 0 deleted, 2 changed)\n\nChange on 2010/06/30 17:56:51 by johnlenz\n\n\tRevert warning levels until after a release is put out to control them.\n\n\tR\u003dnicksantos\n\tDELTA\u003d4  (2 added, 0 deleted, 2 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d47002\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@260 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "7/1/10, 7:38 AM",
      "commitName": "9de5e9b4671773bb3f2d5932e57c1b4186b9b777",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "6/29/10, 2:10 PM",
      "commitNameOld": "541402929a600a95bf099513908b4efd8b0e1c5b",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 1.73,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\n@SuppressWarnings(\"fallthrough\")\npublic Node optimizeSubtree(Node node) {\n    switch(node.getType()) {\n        case Token.RETURN:\n            return tryReduceReturn(node);\n        case Token.NOT:\n            return tryMinimizeNot(node);\n        case Token.IF:\n            tryMinimizeCondition(node.getFirstChild());\n            return tryMinimizeIf(node);\n        case Token.EXPR_RESULT:\n            tryMinimizeCondition(node.getFirstChild());\n            return node;\n        case Token.HOOK:\n            tryMinimizeCondition(node.getFirstChild());\n            return node;\n        case Token.WHILE:\n        case Token.DO:\n        case Token.FOR:\n            if (NodeUtil.getConditionExpression(node) !\u003d null) {\n                tryMinimizeCondition(NodeUtil.getConditionExpression(node));\n            }\n            return node;\n        case Token.NEW:\n            node \u003d tryFoldStandardConstructors(node);\n            if (node.getType() !\u003d Token.CALL) {\n                return node;\n            }\n        case Token.CALL:\n            return tryFoldLiteralConstructor(node);\n        default:\n            return node;\n    }\n}",
      "path": "src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java",
      "functionStartLine": 60,
      "functionName": "optimizeSubtree",
      "functionAnnotation": "@Override,@SuppressWarnings(\"fallthrough\")",
      "functionDoc": "Tries apply our various peephole minimizations on the passed in node.\n",
      "diff": "",
      "extendedDetails": {}
    },
    "c9e89727dc8063d087d28e42629606f4fd74a6e5": {
      "type": "Ymultichange(Ybodychange,Yannotationchange)",
      "commitMessage": "\nChange on 2010/06/22 by nicksantos\n\n\tvariable coalescing better be run AFTER ambiguate properties, and\n\tafter denormalization.\n\n\tR\u003djohnlenz\n\tDELTA\u003d36  (20 added, 16 deleted, 0 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d34005\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@248 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "6/22/10, 4:00 PM",
      "commitName": "c9e89727dc8063d087d28e42629606f4fd74a6e5",
      "commitAuthor": "Nicholas.J.Santos",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "\nChange on 2010/06/22 by nicksantos\n\n\tvariable coalescing better be run AFTER ambiguate properties, and\n\tafter denormalization.\n\n\tR\u003djohnlenz\n\tDELTA\u003d36  (20 added, 16 deleted, 0 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d34005\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@248 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "6/22/10, 4:00 PM",
          "commitName": "c9e89727dc8063d087d28e42629606f4fd74a6e5",
          "commitAuthor": "Nicholas.J.Santos",
          "commitDateOld": "6/16/10, 12:33 PM",
          "commitNameOld": "e33e925eea3a8e4de958864e531e1adc4da62e18",
          "commitAuthorOld": "Nicholas.J.Santos",
          "daysBetweenCommits": 6.14,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\n@SuppressWarnings(\"fallthrough\")\npublic Node optimizeSubtree(Node node) {\n    switch(node.getType()) {\n        case Token.RETURN:\n            return tryReduceReturn(node);\n        case Token.NOT:\n            return tryMinimizeNot(node);\n        case Token.IF:\n            tryMinimizeCondition(node.getFirstChild());\n            return tryMinimizeIf(node);\n        case Token.EXPR_RESULT:\n            tryMinimizeCondition(node.getFirstChild());\n            return node;\n        case Token.HOOK:\n            tryMinimizeCondition(node.getFirstChild());\n            return node;\n        case Token.WHILE:\n        case Token.DO:\n        case Token.FOR:\n            if (NodeUtil.getConditionExpression(node) !\u003d null) {\n                tryMinimizeCondition(NodeUtil.getConditionExpression(node));\n            }\n            return node;\n        case Token.NEW:\n            node \u003d tryFoldStandardConstructors(node);\n            if (node.getType() !\u003d Token.CALL) {\n                return node;\n            }\n        case Token.CALL:\n            return tryFoldLiteralConstructor(node);\n        default:\n            return node;\n    }\n}",
          "path": "src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java",
          "functionStartLine": 60,
          "functionName": "optimizeSubtree",
          "functionAnnotation": "@Override,@SuppressWarnings(\"fallthrough\")",
          "functionDoc": "Tries apply our various peephole minimizations on the passed in node.\n",
          "diff": "@@ -1,41 +1,35 @@\n @Override\n+@SuppressWarnings(\"fallthrough\")\n public Node optimizeSubtree(Node node) {\n     switch(node.getType()) {\n         case Token.RETURN:\n             return tryReduceReturn(node);\n         case Token.NOT:\n             return tryMinimizeNot(node);\n         case Token.IF:\n             tryMinimizeCondition(node.getFirstChild());\n             return tryMinimizeIf(node);\n         case Token.EXPR_RESULT:\n             tryMinimizeCondition(node.getFirstChild());\n             return node;\n         case Token.HOOK:\n             tryMinimizeCondition(node.getFirstChild());\n             return node;\n         case Token.WHILE:\n         case Token.DO:\n         case Token.FOR:\n             if (NodeUtil.getConditionExpression(node) !\u003d null) {\n                 tryMinimizeCondition(NodeUtil.getConditionExpression(node));\n             }\n             return node;\n         case Token.NEW:\n-        case Token.CALL:\n-            {\n-                Node left \u003d node.getFirstChild();\n-                if (left !\u003d null) {\n-                    if (Token.NAME \u003d\u003d left.getType()) {\n-                        String className \u003d left.getString();\n-                        if (\"RegExp\".equals(className)) {\n-                            return tryFoldRegularExpressionConstructor(node);\n-                        }\n-                    }\n-                }\n+            node \u003d tryFoldStandardConstructors(node);\n+            if (node.getType() !\u003d Token.CALL) {\n+                return node;\n             }\n-            return node;\n+        case Token.CALL:\n+            return tryFoldLiteralConstructor(node);\n         default:\n             return node;\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Yannotationchange",
          "commitMessage": "\nChange on 2010/06/22 by nicksantos\n\n\tvariable coalescing better be run AFTER ambiguate properties, and\n\tafter denormalization.\n\n\tR\u003djohnlenz\n\tDELTA\u003d36  (20 added, 16 deleted, 0 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d34005\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@248 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "6/22/10, 4:00 PM",
          "commitName": "c9e89727dc8063d087d28e42629606f4fd74a6e5",
          "commitAuthor": "Nicholas.J.Santos",
          "commitDateOld": "6/16/10, 12:33 PM",
          "commitNameOld": "e33e925eea3a8e4de958864e531e1adc4da62e18",
          "commitAuthorOld": "Nicholas.J.Santos",
          "daysBetweenCommits": 6.14,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\n@SuppressWarnings(\"fallthrough\")\npublic Node optimizeSubtree(Node node) {\n    switch(node.getType()) {\n        case Token.RETURN:\n            return tryReduceReturn(node);\n        case Token.NOT:\n            return tryMinimizeNot(node);\n        case Token.IF:\n            tryMinimizeCondition(node.getFirstChild());\n            return tryMinimizeIf(node);\n        case Token.EXPR_RESULT:\n            tryMinimizeCondition(node.getFirstChild());\n            return node;\n        case Token.HOOK:\n            tryMinimizeCondition(node.getFirstChild());\n            return node;\n        case Token.WHILE:\n        case Token.DO:\n        case Token.FOR:\n            if (NodeUtil.getConditionExpression(node) !\u003d null) {\n                tryMinimizeCondition(NodeUtil.getConditionExpression(node));\n            }\n            return node;\n        case Token.NEW:\n            node \u003d tryFoldStandardConstructors(node);\n            if (node.getType() !\u003d Token.CALL) {\n                return node;\n            }\n        case Token.CALL:\n            return tryFoldLiteralConstructor(node);\n        default:\n            return node;\n    }\n}",
          "path": "src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java",
          "functionStartLine": 60,
          "functionName": "optimizeSubtree",
          "functionAnnotation": "@Override,@SuppressWarnings(\"fallthrough\")",
          "functionDoc": "Tries apply our various peephole minimizations on the passed in node.\n",
          "diff": "@@ -1,41 +1,35 @@\n @Override\n+@SuppressWarnings(\"fallthrough\")\n public Node optimizeSubtree(Node node) {\n     switch(node.getType()) {\n         case Token.RETURN:\n             return tryReduceReturn(node);\n         case Token.NOT:\n             return tryMinimizeNot(node);\n         case Token.IF:\n             tryMinimizeCondition(node.getFirstChild());\n             return tryMinimizeIf(node);\n         case Token.EXPR_RESULT:\n             tryMinimizeCondition(node.getFirstChild());\n             return node;\n         case Token.HOOK:\n             tryMinimizeCondition(node.getFirstChild());\n             return node;\n         case Token.WHILE:\n         case Token.DO:\n         case Token.FOR:\n             if (NodeUtil.getConditionExpression(node) !\u003d null) {\n                 tryMinimizeCondition(NodeUtil.getConditionExpression(node));\n             }\n             return node;\n         case Token.NEW:\n-        case Token.CALL:\n-            {\n-                Node left \u003d node.getFirstChild();\n-                if (left !\u003d null) {\n-                    if (Token.NAME \u003d\u003d left.getType()) {\n-                        String className \u003d left.getString();\n-                        if (\"RegExp\".equals(className)) {\n-                            return tryFoldRegularExpressionConstructor(node);\n-                        }\n-                    }\n-                }\n+            node \u003d tryFoldStandardConstructors(node);\n+            if (node.getType() !\u003d Token.CALL) {\n+                return node;\n             }\n-            return node;\n+        case Token.CALL:\n+            return tryFoldLiteralConstructor(node);\n         default:\n             return node;\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "@Override",
            "newValue": "@Override,@SuppressWarnings(\"fallthrough\")"
          }
        }
      ]
    },
    "b4801b28ceea8db0f63da7440d6769cb9b7cce8a": {
      "type": "Yintroduced",
      "commitMessage": "\nChange on 2010/05/28 by johnlenz\n\n        Inline functions with inner functions into global scope if they don\u0027t\n        declare any names.\n\n        R\u003dacleung\n        DELTA\u003d329  (244 added, 27 deleted, 58 changed)\n\nChange on 2010/05/28 by dcc\n\n        First pass on refactoring FoldConstants into separate peephole optimizations. This changelist adds the notion of an AbstractPeepholeOptimization and adds a PeepholeOptimizationsPass that runs them. In this go around the minimization aspects of FoldConstants have been factored out into PeepholeMinimize. A future change will factor out the other components of FoldConstants into their own PeepholeOptimizations. DefaultPassConfig has also been updated to run the new PeepholeOptimizationPass.\n\n        This change does not move the minimization-related unit tests from FoldConstantsTest to PeepholeMinimizeTest -- a future, separate, change will do so. Hopefully this will make it easier to review.\n\n        R\u003dacleung\n        DELTA\u003d1966  (1271 added, 675 deleted, 20 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d13010\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@235 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "5/29/10, 1:07 PM",
      "commitName": "b4801b28ceea8db0f63da7440d6769cb9b7cce8a",
      "commitAuthor": "Nicholas.J.Santos",
      "diff": "@@ -0,0 +1,41 @@\n+@Override\n+public Node optimizeSubtree(Node node) {\n+    switch(node.getType()) {\n+        case Token.RETURN:\n+            return tryReduceReturn(node);\n+        case Token.NOT:\n+            return tryMinimizeNot(node);\n+        case Token.IF:\n+            tryMinimizeCondition(node.getFirstChild());\n+            return tryMinimizeIf(node);\n+        case Token.EXPR_RESULT:\n+            tryMinimizeCondition(node.getFirstChild());\n+            return node;\n+        case Token.HOOK:\n+            tryMinimizeCondition(node.getFirstChild());\n+            return node;\n+        case Token.WHILE:\n+        case Token.DO:\n+        case Token.FOR:\n+            if (NodeUtil.getConditionExpression(node) !\u003d null) {\n+                tryMinimizeCondition(NodeUtil.getConditionExpression(node));\n+            }\n+            return node;\n+        case Token.NEW:\n+        case Token.CALL:\n+            {\n+                Node left \u003d node.getFirstChild();\n+                if (left !\u003d null) {\n+                    if (Token.NAME \u003d\u003d left.getType()) {\n+                        String className \u003d left.getString();\n+                        if (\"RegExp\".equals(className)) {\n+                            return tryFoldRegularExpressionConstructor(node);\n+                        }\n+                    }\n+                }\n+            }\n+            return node;\n+        default:\n+            return node;\n+    }\n+}\n\\ No newline at end of file\n",
      "actualSource": "@Override\npublic Node optimizeSubtree(Node node) {\n    switch(node.getType()) {\n        case Token.RETURN:\n            return tryReduceReturn(node);\n        case Token.NOT:\n            return tryMinimizeNot(node);\n        case Token.IF:\n            tryMinimizeCondition(node.getFirstChild());\n            return tryMinimizeIf(node);\n        case Token.EXPR_RESULT:\n            tryMinimizeCondition(node.getFirstChild());\n            return node;\n        case Token.HOOK:\n            tryMinimizeCondition(node.getFirstChild());\n            return node;\n        case Token.WHILE:\n        case Token.DO:\n        case Token.FOR:\n            if (NodeUtil.getConditionExpression(node) !\u003d null) {\n                tryMinimizeCondition(NodeUtil.getConditionExpression(node));\n            }\n            return node;\n        case Token.NEW:\n        case Token.CALL:\n            {\n                Node left \u003d node.getFirstChild();\n                if (left !\u003d null) {\n                    if (Token.NAME \u003d\u003d left.getType()) {\n                        String className \u003d left.getString();\n                        if (\"RegExp\".equals(className)) {\n                            return tryFoldRegularExpressionConstructor(node);\n                        }\n                    }\n                }\n            }\n            return node;\n        default:\n            return node;\n    }\n}",
      "path": "src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java",
      "functionStartLine": 57,
      "functionName": "optimizeSubtree",
      "functionAnnotation": "@Override",
      "functionDoc": "Tries apply our various peephole minimizations on the passed in node.\n"
    }
  }
}