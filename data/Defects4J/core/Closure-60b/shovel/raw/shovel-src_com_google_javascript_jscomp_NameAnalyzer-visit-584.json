{
  "origin": "codeshovel",
  "repositoryName": "Closure-60b",
  "repositoryPath": "/tmp/Closure-60b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "NameAnalyzer.java",
  "functionName": "visit",
  "functionId": "$visit___t-NodeTraversal__n-Node__parent-Node",
  "sourceFilePath": "src/com/google/javascript/jscomp/NameAnalyzer.java",
  "functionAnnotation": "",
  "functionDoc": "",
  "functionStartLine": 584,
  "functionEndLine": 630,
  "numCommitsSeen": 28,
  "timeTaken": 2491,
  "changeHistory": [
    "828828472848b88b6d3b1e847fa8be5dde78e2da",
    "f11155426907290f18d4b86854c207cd89419ddc",
    "5f8de0b972f1c3c359ee7a0441729691105a3d62",
    "23705fe72470fa22ba41e86ad0e463263a7cf947",
    "ce1847172d56aedfd334d962445af8d6b82f4c72",
    "ebb59a97610015bc41bda7f458dd1428a3a3e335",
    "bea4e626a55e934ee9a81897069d4a05414c9c57",
    "0d98b3ca84c0b6179b71a9de75b0a2fe42d7343f",
    "45f2bdf91ad3c2f2ac901c72efe9e26148b08d2b",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3"
  ],
  "changeHistoryShort": {
    "828828472848b88b6d3b1e847fa8be5dde78e2da": "Ybodychange",
    "f11155426907290f18d4b86854c207cd89419ddc": "Ybodychange",
    "5f8de0b972f1c3c359ee7a0441729691105a3d62": "Ybodychange",
    "23705fe72470fa22ba41e86ad0e463263a7cf947": "Ybodychange",
    "ce1847172d56aedfd334d962445af8d6b82f4c72": "Ybodychange",
    "ebb59a97610015bc41bda7f458dd1428a3a3e335": "Yformatchange",
    "bea4e626a55e934ee9a81897069d4a05414c9c57": "Ybodychange",
    "0d98b3ca84c0b6179b71a9de75b0a2fe42d7343f": "Ybodychange",
    "45f2bdf91ad3c2f2ac901c72efe9e26148b08d2b": "Ybodychange",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "828828472848b88b6d3b1e847fa8be5dde78e2da": {
      "type": "Ybodychange",
      "commitMessage": "\nMake sure that the compiler doesn\u0027t crash when you have\nfunction f(undefined) {}\nand you left out the default externs.\nI blame this on a poorly-named function\n\nR\u003djohnlenz\nDELTA\u003d70  (53 added, 7 deleted, 10 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d1920\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1108 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "5/16/11, 3:01 PM",
      "commitName": "828828472848b88b6d3b1e847fa8be5dde78e2da",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "5/10/11, 3:01 PM",
      "commitNameOld": "f11155426907290f18d4b86854c207cd89419ddc",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 6.0,
      "commitsBetweenForRepo": 27,
      "commitsBetweenForFile": 1,
      "actualSource": "public void visit(NodeTraversal t, Node n, Node parent) {\n    if (!(NodeUtil.isName(n) || NodeUtil.isGet(n) \u0026\u0026 !NodeUtil.isGetProp(parent))) {\n        return;\n    }\n    NameInformation nameInfo \u003d createNameInformation(t, n, parent);\n    if (nameInfo \u003d\u003d null) {\n        return;\n    }\n    if (nameInfo.onlyAffectsClassDef) {\n        if (nameInfo.superclass !\u003d null) {\n            recordReference(nameInfo.name, nameInfo.superclass, RefType.INHERITANCE);\n        }\n        String nodeName \u003d n.getQualifiedName();\n        if (nodeName !\u003d null) {\n            recordReference(nameInfo.name, nodeName, RefType.REGULAR);\n        }\n        return;\n    }\n    if (parent.getType() \u003d\u003d Token.INSTANCEOF \u0026\u0026 parent.getLastChild() \u003d\u003d n \u0026\u0026 n.isQualifiedName()) {\n        JsName checkedClass \u003d getName(nameInfo.name, true);\n        refNodes.add(new InstanceOfCheckNode(checkedClass, n, parent, parent.getParent()));\n        checkedClass.hasInstanceOfReference \u003d true;\n        return;\n    }\n    NameInformation referring \u003d getDependencyScope(n);\n    String referringName \u003d \"\";\n    if (referring !\u003d null) {\n        referringName \u003d referring.isPrototype ? referring.prototypeClass : referring.name;\n    }\n    String name \u003d nameInfo.name;\n    if (maybeHiddenAlias(name, n)) {\n        recordAlias(name, WINDOW);\n    }\n    if (nameInfo.isExternallyReferenceable) {\n        recordReference(WINDOW, name, RefType.REGULAR);\n        maybeRecordAlias(name, parent, referring, referringName);\n        return;\n    }\n    if (NodeUtil.isVarOrSimpleAssignLhs(n, parent)) {\n        if (referring !\u003d null) {\n            recordReference(referringName, name, RefType.REGULAR);\n        }\n        return;\n    }\n    if (nodesToKeep.contains(n)) {\n        NameInformation functionScope \u003d getEnclosingFunctionDependencyScope(t);\n        if (functionScope !\u003d null) {\n            recordReference(functionScope.name, name, RefType.REGULAR);\n        } else {\n            recordReference(WINDOW, name, RefType.REGULAR);\n        }\n    } else if (referring !\u003d null) {\n        if (!maybeRecordAlias(name, parent, referring, referringName)) {\n            RefType depType \u003d referring.onlyAffectsClassDef ? RefType.INHERITANCE : RefType.REGULAR;\n            recordReference(referringName, name, depType);\n        }\n    } else {\n        for (Node ancestor : n.getAncestors()) {\n            if (NodeUtil.isAssignmentOp(ancestor) || NodeUtil.isFunction(ancestor)) {\n                recordReference(WINDOW, name, RefType.REGULAR);\n                break;\n            }\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/NameAnalyzer.java",
      "functionStartLine": 806,
      "functionName": "visit",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,65 +1,65 @@\n public void visit(NodeTraversal t, Node n, Node parent) {\n     if (!(NodeUtil.isName(n) || NodeUtil.isGet(n) \u0026\u0026 !NodeUtil.isGetProp(parent))) {\n         return;\n     }\n     NameInformation nameInfo \u003d createNameInformation(t, n, parent);\n     if (nameInfo \u003d\u003d null) {\n         return;\n     }\n     if (nameInfo.onlyAffectsClassDef) {\n         if (nameInfo.superclass !\u003d null) {\n             recordReference(nameInfo.name, nameInfo.superclass, RefType.INHERITANCE);\n         }\n         String nodeName \u003d n.getQualifiedName();\n         if (nodeName !\u003d null) {\n             recordReference(nameInfo.name, nodeName, RefType.REGULAR);\n         }\n         return;\n     }\n     if (parent.getType() \u003d\u003d Token.INSTANCEOF \u0026\u0026 parent.getLastChild() \u003d\u003d n \u0026\u0026 n.isQualifiedName()) {\n         JsName checkedClass \u003d getName(nameInfo.name, true);\n         refNodes.add(new InstanceOfCheckNode(checkedClass, n, parent, parent.getParent()));\n         checkedClass.hasInstanceOfReference \u003d true;\n         return;\n     }\n     NameInformation referring \u003d getDependencyScope(n);\n     String referringName \u003d \"\";\n     if (referring !\u003d null) {\n         referringName \u003d referring.isPrototype ? referring.prototypeClass : referring.name;\n     }\n     String name \u003d nameInfo.name;\n     if (maybeHiddenAlias(name, n)) {\n         recordAlias(name, WINDOW);\n     }\n     if (nameInfo.isExternallyReferenceable) {\n         recordReference(WINDOW, name, RefType.REGULAR);\n         maybeRecordAlias(name, parent, referring, referringName);\n         return;\n     }\n-    if (NodeUtil.isLhs(n, parent)) {\n+    if (NodeUtil.isVarOrSimpleAssignLhs(n, parent)) {\n         if (referring !\u003d null) {\n             recordReference(referringName, name, RefType.REGULAR);\n         }\n         return;\n     }\n     if (nodesToKeep.contains(n)) {\n         NameInformation functionScope \u003d getEnclosingFunctionDependencyScope(t);\n         if (functionScope !\u003d null) {\n             recordReference(functionScope.name, name, RefType.REGULAR);\n         } else {\n             recordReference(WINDOW, name, RefType.REGULAR);\n         }\n     } else if (referring !\u003d null) {\n         if (!maybeRecordAlias(name, parent, referring, referringName)) {\n             RefType depType \u003d referring.onlyAffectsClassDef ? RefType.INHERITANCE : RefType.REGULAR;\n             recordReference(referringName, name, depType);\n         }\n     } else {\n         for (Node ancestor : n.getAncestors()) {\n             if (NodeUtil.isAssignmentOp(ancestor) || NodeUtil.isFunction(ancestor)) {\n                 recordReference(WINDOW, name, RefType.REGULAR);\n                 break;\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f11155426907290f18d4b86854c207cd89419ddc": {
      "type": "Ybodychange",
      "commitMessage": "\nHandle aliases used in \"instanceof\" checks.\n\nR\u003dnicksantos\nDELTA\u003d57  (55 added, 0 deleted, 2 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d1814\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1078 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "5/10/11, 3:01 PM",
      "commitName": "f11155426907290f18d4b86854c207cd89419ddc",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "5/10/11, 11:39 AM",
      "commitNameOld": "686a1daa30deb8970d5f3d9aa799d84cff92eac2",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 0.14,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "public void visit(NodeTraversal t, Node n, Node parent) {\n    if (!(NodeUtil.isName(n) || NodeUtil.isGet(n) \u0026\u0026 !NodeUtil.isGetProp(parent))) {\n        return;\n    }\n    NameInformation nameInfo \u003d createNameInformation(t, n, parent);\n    if (nameInfo \u003d\u003d null) {\n        return;\n    }\n    if (nameInfo.onlyAffectsClassDef) {\n        if (nameInfo.superclass !\u003d null) {\n            recordReference(nameInfo.name, nameInfo.superclass, RefType.INHERITANCE);\n        }\n        String nodeName \u003d n.getQualifiedName();\n        if (nodeName !\u003d null) {\n            recordReference(nameInfo.name, nodeName, RefType.REGULAR);\n        }\n        return;\n    }\n    if (parent.getType() \u003d\u003d Token.INSTANCEOF \u0026\u0026 parent.getLastChild() \u003d\u003d n \u0026\u0026 n.isQualifiedName()) {\n        JsName checkedClass \u003d getName(nameInfo.name, true);\n        refNodes.add(new InstanceOfCheckNode(checkedClass, n, parent, parent.getParent()));\n        checkedClass.hasInstanceOfReference \u003d true;\n        return;\n    }\n    NameInformation referring \u003d getDependencyScope(n);\n    String referringName \u003d \"\";\n    if (referring !\u003d null) {\n        referringName \u003d referring.isPrototype ? referring.prototypeClass : referring.name;\n    }\n    String name \u003d nameInfo.name;\n    if (maybeHiddenAlias(name, n)) {\n        recordAlias(name, WINDOW);\n    }\n    if (nameInfo.isExternallyReferenceable) {\n        recordReference(WINDOW, name, RefType.REGULAR);\n        maybeRecordAlias(name, parent, referring, referringName);\n        return;\n    }\n    if (NodeUtil.isLhs(n, parent)) {\n        if (referring !\u003d null) {\n            recordReference(referringName, name, RefType.REGULAR);\n        }\n        return;\n    }\n    if (nodesToKeep.contains(n)) {\n        NameInformation functionScope \u003d getEnclosingFunctionDependencyScope(t);\n        if (functionScope !\u003d null) {\n            recordReference(functionScope.name, name, RefType.REGULAR);\n        } else {\n            recordReference(WINDOW, name, RefType.REGULAR);\n        }\n    } else if (referring !\u003d null) {\n        if (!maybeRecordAlias(name, parent, referring, referringName)) {\n            RefType depType \u003d referring.onlyAffectsClassDef ? RefType.INHERITANCE : RefType.REGULAR;\n            recordReference(referringName, name, depType);\n        }\n    } else {\n        for (Node ancestor : n.getAncestors()) {\n            if (NodeUtil.isAssignmentOp(ancestor) || NodeUtil.isFunction(ancestor)) {\n                recordReference(WINDOW, name, RefType.REGULAR);\n                break;\n            }\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/NameAnalyzer.java",
      "functionStartLine": 806,
      "functionName": "visit",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,64 +1,65 @@\n public void visit(NodeTraversal t, Node n, Node parent) {\n     if (!(NodeUtil.isName(n) || NodeUtil.isGet(n) \u0026\u0026 !NodeUtil.isGetProp(parent))) {\n         return;\n     }\n     NameInformation nameInfo \u003d createNameInformation(t, n, parent);\n     if (nameInfo \u003d\u003d null) {\n         return;\n     }\n     if (nameInfo.onlyAffectsClassDef) {\n         if (nameInfo.superclass !\u003d null) {\n             recordReference(nameInfo.name, nameInfo.superclass, RefType.INHERITANCE);\n         }\n         String nodeName \u003d n.getQualifiedName();\n         if (nodeName !\u003d null) {\n             recordReference(nameInfo.name, nodeName, RefType.REGULAR);\n         }\n         return;\n     }\n     if (parent.getType() \u003d\u003d Token.INSTANCEOF \u0026\u0026 parent.getLastChild() \u003d\u003d n \u0026\u0026 n.isQualifiedName()) {\n         JsName checkedClass \u003d getName(nameInfo.name, true);\n         refNodes.add(new InstanceOfCheckNode(checkedClass, n, parent, parent.getParent()));\n+        checkedClass.hasInstanceOfReference \u003d true;\n         return;\n     }\n     NameInformation referring \u003d getDependencyScope(n);\n     String referringName \u003d \"\";\n     if (referring !\u003d null) {\n         referringName \u003d referring.isPrototype ? referring.prototypeClass : referring.name;\n     }\n     String name \u003d nameInfo.name;\n     if (maybeHiddenAlias(name, n)) {\n         recordAlias(name, WINDOW);\n     }\n     if (nameInfo.isExternallyReferenceable) {\n         recordReference(WINDOW, name, RefType.REGULAR);\n         maybeRecordAlias(name, parent, referring, referringName);\n         return;\n     }\n     if (NodeUtil.isLhs(n, parent)) {\n         if (referring !\u003d null) {\n             recordReference(referringName, name, RefType.REGULAR);\n         }\n         return;\n     }\n     if (nodesToKeep.contains(n)) {\n         NameInformation functionScope \u003d getEnclosingFunctionDependencyScope(t);\n         if (functionScope !\u003d null) {\n             recordReference(functionScope.name, name, RefType.REGULAR);\n         } else {\n             recordReference(WINDOW, name, RefType.REGULAR);\n         }\n     } else if (referring !\u003d null) {\n         if (!maybeRecordAlias(name, parent, referring, referringName)) {\n             RefType depType \u003d referring.onlyAffectsClassDef ? RefType.INHERITANCE : RefType.REGULAR;\n             recordReference(referringName, name, depType);\n         }\n     } else {\n         for (Node ancestor : n.getAncestors()) {\n             if (NodeUtil.isAssignmentOp(ancestor) || NodeUtil.isFunction(ancestor)) {\n                 recordReference(WINDOW, name, RefType.REGULAR);\n                 break;\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5f8de0b972f1c3c359ee7a0441729691105a3d62": {
      "type": "Ybodychange",
      "commitMessage": "\nFix smart name removal to handle aliases formed through function calls.\n\nR\u003dnicksantos\nDELTA\u003d124  (115 added, 1 deleted, 8 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d693\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@830 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "2/28/11, 9:30 AM",
      "commitName": "5f8de0b972f1c3c359ee7a0441729691105a3d62",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "2/24/11, 10:38 PM",
      "commitNameOld": "23705fe72470fa22ba41e86ad0e463263a7cf947",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 3.45,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "actualSource": "public void visit(NodeTraversal t, Node n, Node parent) {\n    if (!(NodeUtil.isName(n) || NodeUtil.isGet(n) \u0026\u0026 !NodeUtil.isGetProp(parent))) {\n        return;\n    }\n    NameInformation nameInfo \u003d createNameInformation(t, n, parent);\n    if (nameInfo \u003d\u003d null) {\n        return;\n    }\n    if (nameInfo.onlyAffectsClassDef) {\n        if (nameInfo.superclass !\u003d null) {\n            recordReference(nameInfo.name, nameInfo.superclass, RefType.INHERITANCE);\n        }\n        String nodeName \u003d n.getQualifiedName();\n        if (nodeName !\u003d null) {\n            recordReference(nameInfo.name, nodeName, RefType.REGULAR);\n        }\n        return;\n    }\n    if (parent.getType() \u003d\u003d Token.INSTANCEOF \u0026\u0026 parent.getLastChild() \u003d\u003d n \u0026\u0026 n.isQualifiedName()) {\n        JsName checkedClass \u003d getName(nameInfo.name, true);\n        refNodes.add(new InstanceOfCheckNode(checkedClass, n, parent, parent.getParent()));\n        return;\n    }\n    NameInformation referring \u003d getDependencyScope(n);\n    String referringName \u003d \"\";\n    if (referring !\u003d null) {\n        referringName \u003d referring.isPrototype ? referring.prototypeClass : referring.name;\n    }\n    String name \u003d nameInfo.name;\n    if (maybeHiddenAlias(name, n)) {\n        recordAlias(name, WINDOW);\n    }\n    if (nameInfo.isExternallyReferenceable) {\n        recordReference(WINDOW, name, RefType.REGULAR);\n        maybeRecordAlias(name, parent, referring, referringName);\n        return;\n    }\n    if (NodeUtil.isLhs(n, parent)) {\n        if (referring !\u003d null) {\n            recordReference(referringName, name, RefType.REGULAR);\n        }\n        return;\n    }\n    if (nodesToKeep.contains(n)) {\n        NameInformation functionScope \u003d getEnclosingFunctionDependencyScope(t);\n        if (functionScope !\u003d null) {\n            recordReference(functionScope.name, name, RefType.REGULAR);\n        } else {\n            recordReference(WINDOW, name, RefType.REGULAR);\n        }\n    } else if (referring !\u003d null) {\n        if (!maybeRecordAlias(name, parent, referring, referringName)) {\n            RefType depType \u003d referring.onlyAffectsClassDef ? RefType.INHERITANCE : RefType.REGULAR;\n            recordReference(referringName, name, depType);\n        }\n    } else {\n        for (Node ancestor : n.getAncestors()) {\n            if (NodeUtil.isAssignmentOp(ancestor) || NodeUtil.isFunction(ancestor)) {\n                recordReference(WINDOW, name, RefType.REGULAR);\n                break;\n            }\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/NameAnalyzer.java",
      "functionStartLine": 790,
      "functionName": "visit",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,61 +1,64 @@\n public void visit(NodeTraversal t, Node n, Node parent) {\n     if (!(NodeUtil.isName(n) || NodeUtil.isGet(n) \u0026\u0026 !NodeUtil.isGetProp(parent))) {\n         return;\n     }\n     NameInformation nameInfo \u003d createNameInformation(t, n, parent);\n     if (nameInfo \u003d\u003d null) {\n         return;\n     }\n     if (nameInfo.onlyAffectsClassDef) {\n         if (nameInfo.superclass !\u003d null) {\n             recordReference(nameInfo.name, nameInfo.superclass, RefType.INHERITANCE);\n         }\n         String nodeName \u003d n.getQualifiedName();\n         if (nodeName !\u003d null) {\n             recordReference(nameInfo.name, nodeName, RefType.REGULAR);\n         }\n         return;\n     }\n     if (parent.getType() \u003d\u003d Token.INSTANCEOF \u0026\u0026 parent.getLastChild() \u003d\u003d n \u0026\u0026 n.isQualifiedName()) {\n         JsName checkedClass \u003d getName(nameInfo.name, true);\n         refNodes.add(new InstanceOfCheckNode(checkedClass, n, parent, parent.getParent()));\n         return;\n     }\n     NameInformation referring \u003d getDependencyScope(n);\n     String referringName \u003d \"\";\n     if (referring !\u003d null) {\n         referringName \u003d referring.isPrototype ? referring.prototypeClass : referring.name;\n     }\n     String name \u003d nameInfo.name;\n+    if (maybeHiddenAlias(name, n)) {\n+        recordAlias(name, WINDOW);\n+    }\n     if (nameInfo.isExternallyReferenceable) {\n         recordReference(WINDOW, name, RefType.REGULAR);\n         maybeRecordAlias(name, parent, referring, referringName);\n         return;\n     }\n     if (NodeUtil.isLhs(n, parent)) {\n         if (referring !\u003d null) {\n             recordReference(referringName, name, RefType.REGULAR);\n         }\n         return;\n     }\n     if (nodesToKeep.contains(n)) {\n         NameInformation functionScope \u003d getEnclosingFunctionDependencyScope(t);\n         if (functionScope !\u003d null) {\n             recordReference(functionScope.name, name, RefType.REGULAR);\n         } else {\n             recordReference(WINDOW, name, RefType.REGULAR);\n         }\n     } else if (referring !\u003d null) {\n         if (!maybeRecordAlias(name, parent, referring, referringName)) {\n             RefType depType \u003d referring.onlyAffectsClassDef ? RefType.INHERITANCE : RefType.REGULAR;\n             recordReference(referringName, name, depType);\n         }\n     } else {\n         for (Node ancestor : n.getAncestors()) {\n             if (NodeUtil.isAssignmentOp(ancestor) || NodeUtil.isFunction(ancestor)) {\n                 recordReference(WINDOW, name, RefType.REGULAR);\n                 break;\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "23705fe72470fa22ba41e86ad0e463263a7cf947": {
      "type": "Ybodychange",
      "commitMessage": "\nFix smart name removal to track aliases to external names.\n\nR\u003dnicksantos\nDELTA\u003d47  (35 added, 4 deleted, 8 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d670\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@819 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "2/24/11, 10:38 PM",
      "commitName": "23705fe72470fa22ba41e86ad0e463263a7cf947",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "1/24/11, 1:17 PM",
      "commitNameOld": "ce1847172d56aedfd334d962445af8d6b82f4c72",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 31.39,
      "commitsBetweenForRepo": 87,
      "commitsBetweenForFile": 1,
      "actualSource": "public void visit(NodeTraversal t, Node n, Node parent) {\n    if (!(NodeUtil.isName(n) || NodeUtil.isGet(n) \u0026\u0026 !NodeUtil.isGetProp(parent))) {\n        return;\n    }\n    NameInformation nameInfo \u003d createNameInformation(t, n, parent);\n    if (nameInfo \u003d\u003d null) {\n        return;\n    }\n    if (nameInfo.onlyAffectsClassDef) {\n        if (nameInfo.superclass !\u003d null) {\n            recordReference(nameInfo.name, nameInfo.superclass, RefType.INHERITANCE);\n        }\n        String nodeName \u003d n.getQualifiedName();\n        if (nodeName !\u003d null) {\n            recordReference(nameInfo.name, nodeName, RefType.REGULAR);\n        }\n        return;\n    }\n    if (parent.getType() \u003d\u003d Token.INSTANCEOF \u0026\u0026 parent.getLastChild() \u003d\u003d n \u0026\u0026 n.isQualifiedName()) {\n        JsName checkedClass \u003d getName(nameInfo.name, true);\n        refNodes.add(new InstanceOfCheckNode(checkedClass, n, parent, parent.getParent()));\n        return;\n    }\n    NameInformation referring \u003d getDependencyScope(n);\n    String referringName \u003d \"\";\n    if (referring !\u003d null) {\n        referringName \u003d referring.isPrototype ? referring.prototypeClass : referring.name;\n    }\n    String name \u003d nameInfo.name;\n    if (nameInfo.isExternallyReferenceable) {\n        recordReference(WINDOW, name, RefType.REGULAR);\n        maybeRecordAlias(name, parent, referring, referringName);\n        return;\n    }\n    if (NodeUtil.isLhs(n, parent)) {\n        if (referring !\u003d null) {\n            recordReference(referringName, name, RefType.REGULAR);\n        }\n        return;\n    }\n    if (nodesToKeep.contains(n)) {\n        NameInformation functionScope \u003d getEnclosingFunctionDependencyScope(t);\n        if (functionScope !\u003d null) {\n            recordReference(functionScope.name, name, RefType.REGULAR);\n        } else {\n            recordReference(WINDOW, name, RefType.REGULAR);\n        }\n    } else if (referring !\u003d null) {\n        if (!maybeRecordAlias(name, parent, referring, referringName)) {\n            RefType depType \u003d referring.onlyAffectsClassDef ? RefType.INHERITANCE : RefType.REGULAR;\n            recordReference(referringName, name, depType);\n        }\n    } else {\n        for (Node ancestor : n.getAncestors()) {\n            if (NodeUtil.isAssignmentOp(ancestor) || NodeUtil.isFunction(ancestor)) {\n                recordReference(WINDOW, name, RefType.REGULAR);\n                break;\n            }\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/NameAnalyzer.java",
      "functionStartLine": 775,
      "functionName": "visit",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,62 +1,61 @@\n public void visit(NodeTraversal t, Node n, Node parent) {\n     if (!(NodeUtil.isName(n) || NodeUtil.isGet(n) \u0026\u0026 !NodeUtil.isGetProp(parent))) {\n         return;\n     }\n     NameInformation nameInfo \u003d createNameInformation(t, n, parent);\n     if (nameInfo \u003d\u003d null) {\n         return;\n     }\n     if (nameInfo.onlyAffectsClassDef) {\n         if (nameInfo.superclass !\u003d null) {\n             recordReference(nameInfo.name, nameInfo.superclass, RefType.INHERITANCE);\n         }\n         String nodeName \u003d n.getQualifiedName();\n         if (nodeName !\u003d null) {\n             recordReference(nameInfo.name, nodeName, RefType.REGULAR);\n         }\n         return;\n     }\n     if (parent.getType() \u003d\u003d Token.INSTANCEOF \u0026\u0026 parent.getLastChild() \u003d\u003d n \u0026\u0026 n.isQualifiedName()) {\n         JsName checkedClass \u003d getName(nameInfo.name, true);\n         refNodes.add(new InstanceOfCheckNode(checkedClass, n, parent, parent.getParent()));\n         return;\n     }\n     NameInformation referring \u003d getDependencyScope(n);\n     String referringName \u003d \"\";\n     if (referring !\u003d null) {\n         referringName \u003d referring.isPrototype ? referring.prototypeClass : referring.name;\n     }\n     String name \u003d nameInfo.name;\n     if (nameInfo.isExternallyReferenceable) {\n         recordReference(WINDOW, name, RefType.REGULAR);\n+        maybeRecordAlias(name, parent, referring, referringName);\n         return;\n     }\n     if (NodeUtil.isLhs(n, parent)) {\n         if (referring !\u003d null) {\n             recordReference(referringName, name, RefType.REGULAR);\n         }\n         return;\n     }\n     if (nodesToKeep.contains(n)) {\n         NameInformation functionScope \u003d getEnclosingFunctionDependencyScope(t);\n         if (functionScope !\u003d null) {\n             recordReference(functionScope.name, name, RefType.REGULAR);\n         } else {\n             recordReference(WINDOW, name, RefType.REGULAR);\n         }\n     } else if (referring !\u003d null) {\n-        if ((parent.getType() \u003d\u003d Token.NAME || parent.getType() \u003d\u003d Token.ASSIGN) \u0026\u0026 scopes.get(parent) \u003d\u003d referring) {\n-            recordAlias(referringName, name);\n-        } else {\n+        if (!maybeRecordAlias(name, parent, referring, referringName)) {\n             RefType depType \u003d referring.onlyAffectsClassDef ? RefType.INHERITANCE : RefType.REGULAR;\n             recordReference(referringName, name, depType);\n         }\n     } else {\n         for (Node ancestor : n.getAncestors()) {\n             if (NodeUtil.isAssignmentOp(ancestor) || NodeUtil.isFunction(ancestor)) {\n                 recordReference(WINDOW, name, RefType.REGULAR);\n                 break;\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ce1847172d56aedfd334d962445af8d6b82f4c72": {
      "type": "Ybodychange",
      "commitMessage": "\nFix compiler crash when doing instanceof on a GETELEM\n\nR\u003dacleung\nDELTA\u003d14  (12 added, 1 deleted, 1 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d343\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@729 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "1/24/11, 1:17 PM",
      "commitName": "ce1847172d56aedfd334d962445af8d6b82f4c72",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "1/13/11, 11:38 AM",
      "commitNameOld": "f70742f8dfc04485dbb2cbaffda0311859265a5a",
      "commitAuthorOld": "agrieve@google.com",
      "daysBetweenCommits": 11.07,
      "commitsBetweenForRepo": 32,
      "commitsBetweenForFile": 1,
      "actualSource": "public void visit(NodeTraversal t, Node n, Node parent) {\n    if (!(NodeUtil.isName(n) || NodeUtil.isGet(n) \u0026\u0026 !NodeUtil.isGetProp(parent))) {\n        return;\n    }\n    NameInformation nameInfo \u003d createNameInformation(t, n, parent);\n    if (nameInfo \u003d\u003d null) {\n        return;\n    }\n    if (nameInfo.onlyAffectsClassDef) {\n        if (nameInfo.superclass !\u003d null) {\n            recordReference(nameInfo.name, nameInfo.superclass, RefType.INHERITANCE);\n        }\n        String nodeName \u003d n.getQualifiedName();\n        if (nodeName !\u003d null) {\n            recordReference(nameInfo.name, nodeName, RefType.REGULAR);\n        }\n        return;\n    }\n    if (parent.getType() \u003d\u003d Token.INSTANCEOF \u0026\u0026 parent.getLastChild() \u003d\u003d n \u0026\u0026 n.isQualifiedName()) {\n        JsName checkedClass \u003d getName(nameInfo.name, true);\n        refNodes.add(new InstanceOfCheckNode(checkedClass, n, parent, parent.getParent()));\n        return;\n    }\n    NameInformation referring \u003d getDependencyScope(n);\n    String referringName \u003d \"\";\n    if (referring !\u003d null) {\n        referringName \u003d referring.isPrototype ? referring.prototypeClass : referring.name;\n    }\n    String name \u003d nameInfo.name;\n    if (nameInfo.isExternallyReferenceable) {\n        recordReference(WINDOW, name, RefType.REGULAR);\n        return;\n    }\n    if (NodeUtil.isLhs(n, parent)) {\n        if (referring !\u003d null) {\n            recordReference(referringName, name, RefType.REGULAR);\n        }\n        return;\n    }\n    if (nodesToKeep.contains(n)) {\n        NameInformation functionScope \u003d getEnclosingFunctionDependencyScope(t);\n        if (functionScope !\u003d null) {\n            recordReference(functionScope.name, name, RefType.REGULAR);\n        } else {\n            recordReference(WINDOW, name, RefType.REGULAR);\n        }\n    } else if (referring !\u003d null) {\n        if ((parent.getType() \u003d\u003d Token.NAME || parent.getType() \u003d\u003d Token.ASSIGN) \u0026\u0026 scopes.get(parent) \u003d\u003d referring) {\n            recordAlias(referringName, name);\n        } else {\n            RefType depType \u003d referring.onlyAffectsClassDef ? RefType.INHERITANCE : RefType.REGULAR;\n            recordReference(referringName, name, depType);\n        }\n    } else {\n        for (Node ancestor : n.getAncestors()) {\n            if (NodeUtil.isAssignmentOp(ancestor) || NodeUtil.isFunction(ancestor)) {\n                recordReference(WINDOW, name, RefType.REGULAR);\n                break;\n            }\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/NameAnalyzer.java",
      "functionStartLine": 775,
      "functionName": "visit",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,62 +1,62 @@\n public void visit(NodeTraversal t, Node n, Node parent) {\n     if (!(NodeUtil.isName(n) || NodeUtil.isGet(n) \u0026\u0026 !NodeUtil.isGetProp(parent))) {\n         return;\n     }\n     NameInformation nameInfo \u003d createNameInformation(t, n, parent);\n     if (nameInfo \u003d\u003d null) {\n         return;\n     }\n     if (nameInfo.onlyAffectsClassDef) {\n         if (nameInfo.superclass !\u003d null) {\n             recordReference(nameInfo.name, nameInfo.superclass, RefType.INHERITANCE);\n         }\n         String nodeName \u003d n.getQualifiedName();\n         if (nodeName !\u003d null) {\n             recordReference(nameInfo.name, nodeName, RefType.REGULAR);\n         }\n         return;\n     }\n-    if (parent.getType() \u003d\u003d Token.INSTANCEOF \u0026\u0026 parent.getLastChild() \u003d\u003d n) {\n+    if (parent.getType() \u003d\u003d Token.INSTANCEOF \u0026\u0026 parent.getLastChild() \u003d\u003d n \u0026\u0026 n.isQualifiedName()) {\n         JsName checkedClass \u003d getName(nameInfo.name, true);\n         refNodes.add(new InstanceOfCheckNode(checkedClass, n, parent, parent.getParent()));\n         return;\n     }\n     NameInformation referring \u003d getDependencyScope(n);\n     String referringName \u003d \"\";\n     if (referring !\u003d null) {\n         referringName \u003d referring.isPrototype ? referring.prototypeClass : referring.name;\n     }\n     String name \u003d nameInfo.name;\n     if (nameInfo.isExternallyReferenceable) {\n         recordReference(WINDOW, name, RefType.REGULAR);\n         return;\n     }\n     if (NodeUtil.isLhs(n, parent)) {\n         if (referring !\u003d null) {\n             recordReference(referringName, name, RefType.REGULAR);\n         }\n         return;\n     }\n     if (nodesToKeep.contains(n)) {\n         NameInformation functionScope \u003d getEnclosingFunctionDependencyScope(t);\n         if (functionScope !\u003d null) {\n             recordReference(functionScope.name, name, RefType.REGULAR);\n         } else {\n             recordReference(WINDOW, name, RefType.REGULAR);\n         }\n     } else if (referring !\u003d null) {\n         if ((parent.getType() \u003d\u003d Token.NAME || parent.getType() \u003d\u003d Token.ASSIGN) \u0026\u0026 scopes.get(parent) \u003d\u003d referring) {\n             recordAlias(referringName, name);\n         } else {\n             RefType depType \u003d referring.onlyAffectsClassDef ? RefType.INHERITANCE : RefType.REGULAR;\n             recordReference(referringName, name, depType);\n         }\n     } else {\n         for (Node ancestor : n.getAncestors()) {\n             if (NodeUtil.isAssignmentOp(ancestor) || NodeUtil.isFunction(ancestor)) {\n                 recordReference(WINDOW, name, RefType.REGULAR);\n                 break;\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ebb59a97610015bc41bda7f458dd1428a3a3e335": {
      "type": "Yformatchange",
      "commitMessage": "\nChange on 2010/04/22 by nick\n\n        fix the extern definition of Window.prototype.stop\n\n        R\u003dsiggy\n        DELTA\u003d1  (0 added, 0 deleted, 1 changed)\n\nChange on 2010/04/22 by john\n\n        \"Anonymous function\" is a confusing term for functions with names.\n        Properly we are usually distinguishing between functions statements\n        (function declarations) and function expressions.\n\n        R\u003dalan\n        DELTA\u003d172  (7 added, 14 deleted, 151 changed)\n\nChange on 2010/04/22 by john\n\n        Standardize the definition of setTimeout/setInterval.\n        Fix for Issue 137\n\n        R\u003dnick\n        DELTA\u003d6  (2 added, 2 deleted, 2 changed)\n\nChange on 2010/04/22 by mark\n\n        Various delegate fixes.\n\n        Give the delegate proxy a name unique from the delegate base so that\n        InstanceObjectType#equals distinguishes them. This is necessary for\n        AmbiguateProperties to work.\n\n        Fix the prototype of the delegate proxy. This makes\n        DisambiguateProperties continue to work.\n\n        Add superclass methods of the delegate base to the delegate proxy.\n\n\n        R\u003dandrew,nada\n        DELTA\u003d526  (383 added, 104 deleted, 39 changed)\n\nChange on 2010/04/23 by john\n\n        Allow variable inlining of function statements. For simplicity  limited to functions defined before first use.\n\n        R\u003dnick\n        DELTA\u003d79  (49 added, 3 deleted, 27 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003dhakjvx\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@197 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/23/10, 11:31 AM",
      "commitName": "ebb59a97610015bc41bda7f458dd1428a3a3e335",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "4/19/10, 4:28 PM",
      "commitNameOld": "5da32cba7b68d69acfc535f57f21d652475d256f",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 3.79,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "public void visit(NodeTraversal t, Node n, Node parent) {\n    if (!(NodeUtil.isName(n) || NodeUtil.isGet(n) \u0026\u0026 !NodeUtil.isGetProp(parent))) {\n        return;\n    }\n    NameInformation nameInfo \u003d createNameInformation(t, n, parent);\n    if (nameInfo \u003d\u003d null) {\n        return;\n    }\n    if (nameInfo.onlyAffectsClassDef) {\n        if (nameInfo.superclass !\u003d null) {\n            recordReference(nameInfo.name, nameInfo.superclass, RefType.INHERITANCE);\n        }\n        String nodeName \u003d n.getQualifiedName();\n        if (nodeName !\u003d null) {\n            recordReference(nameInfo.name, nodeName, RefType.REGULAR);\n        }\n        return;\n    }\n    if (parent.getType() \u003d\u003d Token.INSTANCEOF \u0026\u0026 parent.getLastChild() \u003d\u003d n) {\n        JsName checkedClass \u003d getName(nameInfo.name, true);\n        refNodes.add(new InstanceOfCheckNode(checkedClass, n, parent, parent.getParent()));\n        return;\n    }\n    NameInformation referring \u003d getDependencyScope(n);\n    String referringName \u003d \"\";\n    if (referring !\u003d null) {\n        referringName \u003d referring.isPrototype ? referring.prototypeClass : referring.name;\n    }\n    String name \u003d nameInfo.name;\n    if (nameInfo.isExternallyReferenceable) {\n        recordReference(WINDOW, name, RefType.REGULAR);\n        return;\n    }\n    if (NodeUtil.isLhs(n, parent)) {\n        if (referring !\u003d null) {\n            recordReference(referringName, name, RefType.REGULAR);\n        }\n        return;\n    }\n    if (nodesToKeep.contains(n)) {\n        NameInformation functionScope \u003d getEnclosingFunctionDependencyScope(t);\n        if (functionScope !\u003d null) {\n            recordReference(functionScope.name, name, RefType.REGULAR);\n        } else {\n            recordReference(WINDOW, name, RefType.REGULAR);\n        }\n    } else if (referring !\u003d null) {\n        if ((parent.getType() \u003d\u003d Token.NAME || parent.getType() \u003d\u003d Token.ASSIGN) \u0026\u0026 scopes.get(parent) \u003d\u003d referring) {\n            recordAlias(referringName, name);\n        } else {\n            RefType depType \u003d referring.onlyAffectsClassDef ? RefType.INHERITANCE : RefType.REGULAR;\n            recordReference(referringName, name, depType);\n        }\n    } else {\n        for (Node ancestor : n.getAncestors()) {\n            if (NodeUtil.isAssignmentOp(ancestor) || NodeUtil.isFunction(ancestor)) {\n                recordReference(WINDOW, name, RefType.REGULAR);\n                break;\n            }\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/NameAnalyzer.java",
      "functionStartLine": 777,
      "functionName": "visit",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {}
    },
    "bea4e626a55e934ee9a81897069d4a05414c9c57": {
      "type": "Ybodychange",
      "commitMessage": "\nChange on 2010/04/16 by nick\n\n        Move the topological dependency sort into jscomp/deps\n\n        R\u003dalan\n        DELTA\u003d246  (161 added, 75 deleted, 10 changed)\n\nChange on 2010/04/16 by john\n\n        Enable decompose expressions the open source compiler.\n\n        R\u003dalan\n        DELTA\u003d2  (2 added, 0 deleted, 0 changed)\n\nChange on 2010/04/16 by alan\n\n        Update flow sensitive inlining flow to be tri state. This should not change the behavior\n           of the compiler.\n\n        R\u003djohn,nassar\n        DELTA\u003d11  (1 added, 2 deleted, 8 changed)\n\nChange on 2010/04/16 by nick\n\n        treat goog.addSingletonGetter as a class-defining function.\n\n        R\u003dantonio\n        DELTA\u003d39  (26 added, 5 deleted, 8 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003dolbuid\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@190 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/19/10, 10:45 AM",
      "commitName": "bea4e626a55e934ee9a81897069d4a05414c9c57",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "4/16/10, 10:20 AM",
      "commitNameOld": "6e3eb4f7619179ba6c23db2af7549ef02f588c35",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 3.02,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "public void visit(NodeTraversal t, Node n, Node parent) {\n    if (!(NodeUtil.isName(n) || NodeUtil.isGet(n) \u0026\u0026 !NodeUtil.isGetProp(parent))) {\n        return;\n    }\n    NameInformation nameInfo \u003d createNameInformation(t, n, parent);\n    if (nameInfo \u003d\u003d null) {\n        return;\n    }\n    if (nameInfo.onlyAffectsClassDef) {\n        if (nameInfo.superclass !\u003d null) {\n            recordReference(nameInfo.name, nameInfo.superclass, RefType.INHERITANCE);\n        }\n        String nodeName \u003d n.getQualifiedName();\n        if (nodeName !\u003d null) {\n            recordReference(nameInfo.name, nodeName, RefType.REGULAR);\n        }\n        return;\n    }\n    if (parent.getType() \u003d\u003d Token.INSTANCEOF \u0026\u0026 parent.getLastChild() \u003d\u003d n) {\n        JsName checkedClass \u003d getName(nameInfo.name, true);\n        refNodes.add(new InstanceOfCheckNode(checkedClass, n, parent, parent.getParent()));\n        return;\n    }\n    NameInformation referring \u003d getDependencyScope(n);\n    String referringName \u003d \"\";\n    if (referring !\u003d null) {\n        referringName \u003d referring.isPrototype ? referring.prototypeClass : referring.name;\n    }\n    String name \u003d nameInfo.name;\n    if (nameInfo.isExternallyReferenceable) {\n        recordReference(WINDOW, name, RefType.REGULAR);\n        return;\n    }\n    if (NodeUtil.isLhs(n, parent)) {\n        if (referring !\u003d null) {\n            recordReference(referringName, name, RefType.REGULAR);\n        }\n        return;\n    }\n    if (nodesToKeep.contains(n)) {\n        NameInformation functionScope \u003d getEnclosingFunctionDependencyScope(t);\n        if (functionScope !\u003d null) {\n            recordReference(functionScope.name, name, RefType.REGULAR);\n        } else {\n            recordReference(WINDOW, name, RefType.REGULAR);\n        }\n    } else if (referring !\u003d null) {\n        if ((parent.getType() \u003d\u003d Token.NAME || parent.getType() \u003d\u003d Token.ASSIGN) \u0026\u0026 scopes.get(parent) \u003d\u003d referring) {\n            recordAlias(referringName, name);\n        } else {\n            RefType depType \u003d referring.onlyAffectsClassDef ? RefType.INHERITANCE : RefType.REGULAR;\n            recordReference(referringName, name, depType);\n        }\n    } else {\n        for (Node ancestor : n.getAncestors()) {\n            if (NodeUtil.isAssignmentOp(ancestor) || NodeUtil.isFunction(ancestor)) {\n                recordReference(WINDOW, name, RefType.REGULAR);\n                break;\n            }\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/NameAnalyzer.java",
      "functionStartLine": 777,
      "functionName": "visit",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,60 +1,62 @@\n public void visit(NodeTraversal t, Node n, Node parent) {\n     if (!(NodeUtil.isName(n) || NodeUtil.isGet(n) \u0026\u0026 !NodeUtil.isGetProp(parent))) {\n         return;\n     }\n     NameInformation nameInfo \u003d createNameInformation(t, n, parent);\n     if (nameInfo \u003d\u003d null) {\n         return;\n     }\n     if (nameInfo.onlyAffectsClassDef) {\n-        recordReference(nameInfo.name, nameInfo.superclass, RefType.INHERITANCE);\n+        if (nameInfo.superclass !\u003d null) {\n+            recordReference(nameInfo.name, nameInfo.superclass, RefType.INHERITANCE);\n+        }\n         String nodeName \u003d n.getQualifiedName();\n         if (nodeName !\u003d null) {\n             recordReference(nameInfo.name, nodeName, RefType.REGULAR);\n         }\n         return;\n     }\n     if (parent.getType() \u003d\u003d Token.INSTANCEOF \u0026\u0026 parent.getLastChild() \u003d\u003d n) {\n         JsName checkedClass \u003d getName(nameInfo.name, true);\n         refNodes.add(new InstanceOfCheckNode(checkedClass, n, parent, parent.getParent()));\n         return;\n     }\n     NameInformation referring \u003d getDependencyScope(n);\n     String referringName \u003d \"\";\n     if (referring !\u003d null) {\n         referringName \u003d referring.isPrototype ? referring.prototypeClass : referring.name;\n     }\n     String name \u003d nameInfo.name;\n     if (nameInfo.isExternallyReferenceable) {\n         recordReference(WINDOW, name, RefType.REGULAR);\n         return;\n     }\n     if (NodeUtil.isLhs(n, parent)) {\n         if (referring !\u003d null) {\n             recordReference(referringName, name, RefType.REGULAR);\n         }\n         return;\n     }\n     if (nodesToKeep.contains(n)) {\n         NameInformation functionScope \u003d getEnclosingFunctionDependencyScope(t);\n         if (functionScope !\u003d null) {\n             recordReference(functionScope.name, name, RefType.REGULAR);\n         } else {\n             recordReference(WINDOW, name, RefType.REGULAR);\n         }\n     } else if (referring !\u003d null) {\n         if ((parent.getType() \u003d\u003d Token.NAME || parent.getType() \u003d\u003d Token.ASSIGN) \u0026\u0026 scopes.get(parent) \u003d\u003d referring) {\n             recordAlias(referringName, name);\n         } else {\n             RefType depType \u003d referring.onlyAffectsClassDef ? RefType.INHERITANCE : RefType.REGULAR;\n             recordReference(referringName, name, depType);\n         }\n     } else {\n         for (Node ancestor : n.getAncestors()) {\n             if (NodeUtil.isAssignmentOp(ancestor) || NodeUtil.isFunction(ancestor)) {\n                 recordReference(WINDOW, name, RefType.REGULAR);\n                 break;\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0d98b3ca84c0b6179b71a9de75b0a2fe42d7343f": {
      "type": "Ybodychange",
      "commitMessage": "Make sure that NameAnalyzer does not\nremove property assignments done via aliases. (Nick)\nR\u003dantonio\nDELTA\u003d417  (399 added, 9 deleted, 9 changed)\n\nput the graph tests in the graph package. (Nick)\nR\u003dalan\nDELTA\u003d1422  (753 added, 660 deleted, 9 changed)\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003dqlondb\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@168 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/2/10, 3:08 PM",
      "commitName": "0d98b3ca84c0b6179b71a9de75b0a2fe42d7343f",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "2/11/10, 1:02 PM",
      "commitNameOld": "1771d2005a441cb87df2a488069f265bd71ed9ee",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 50.05,
      "commitsBetweenForRepo": 65,
      "commitsBetweenForFile": 1,
      "actualSource": "public void visit(NodeTraversal t, Node n, Node parent) {\n    if (!(NodeUtil.isName(n) || NodeUtil.isGet(n) \u0026\u0026 !NodeUtil.isGetProp(parent))) {\n        return;\n    }\n    NameInformation nameInfo \u003d createNameInformation(t, n, parent);\n    if (nameInfo \u003d\u003d null) {\n        return;\n    }\n    if (nameInfo.onlyAffectsClassDef) {\n        recordReference(nameInfo.name, nameInfo.superclass, RefType.INHERITANCE);\n        String nodeName \u003d n.getQualifiedName();\n        if (nodeName !\u003d null) {\n            recordReference(nameInfo.name, nodeName, RefType.REGULAR);\n        }\n        return;\n    }\n    if (parent.getType() \u003d\u003d Token.INSTANCEOF \u0026\u0026 parent.getLastChild() \u003d\u003d n) {\n        JsName checkedClass \u003d getName(nameInfo.name, true);\n        refNodes.add(new InstanceOfCheckNode(checkedClass, n, parent, parent.getParent()));\n        return;\n    }\n    NameInformation referring \u003d getDependencyScope(n);\n    String referringName \u003d \"\";\n    if (referring !\u003d null) {\n        referringName \u003d referring.isPrototype ? referring.prototypeClass : referring.name;\n    }\n    String name \u003d nameInfo.name;\n    if (nameInfo.isExternallyReferenceable) {\n        recordReference(WINDOW, name, RefType.REGULAR);\n        return;\n    }\n    if (NodeUtil.isLhs(n, parent)) {\n        if (referring !\u003d null) {\n            recordReference(referringName, name, RefType.REGULAR);\n        }\n        return;\n    }\n    if (nodesToKeep.contains(n)) {\n        NameInformation functionScope \u003d getEnclosingFunctionDependencyScope(t);\n        if (functionScope !\u003d null) {\n            recordReference(functionScope.name, name, RefType.REGULAR);\n        } else {\n            recordReference(WINDOW, name, RefType.REGULAR);\n        }\n    } else if (referring !\u003d null) {\n        if ((parent.getType() \u003d\u003d Token.NAME || parent.getType() \u003d\u003d Token.ASSIGN) \u0026\u0026 scopes.get(parent) \u003d\u003d referring) {\n            recordAlias(referringName, name);\n        } else {\n            RefType depType \u003d referring.onlyAffectsClassDef ? RefType.INHERITANCE : RefType.REGULAR;\n            recordReference(referringName, name, depType);\n        }\n    } else {\n        for (Node ancestor : n.getAncestors()) {\n            if (NodeUtil.isAssignmentOp(ancestor) || NodeUtil.isFunction(ancestor)) {\n                recordReference(WINDOW, name, RefType.REGULAR);\n                break;\n            }\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/NameAnalyzer.java",
      "functionStartLine": 823,
      "functionName": "visit",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,55 +1,60 @@\n public void visit(NodeTraversal t, Node n, Node parent) {\n     if (!(NodeUtil.isName(n) || NodeUtil.isGet(n) \u0026\u0026 !NodeUtil.isGetProp(parent))) {\n         return;\n     }\n     NameInformation nameInfo \u003d createNameInformation(t, n, parent);\n     if (nameInfo \u003d\u003d null) {\n         return;\n     }\n     if (nameInfo.onlyAffectsClassDef) {\n         recordReference(nameInfo.name, nameInfo.superclass, RefType.INHERITANCE);\n         String nodeName \u003d n.getQualifiedName();\n         if (nodeName !\u003d null) {\n             recordReference(nameInfo.name, nodeName, RefType.REGULAR);\n         }\n         return;\n     }\n     if (parent.getType() \u003d\u003d Token.INSTANCEOF \u0026\u0026 parent.getLastChild() \u003d\u003d n) {\n         JsName checkedClass \u003d getName(nameInfo.name, true);\n         refNodes.add(new InstanceOfCheckNode(checkedClass, n, parent, parent.getParent()));\n         return;\n     }\n     NameInformation referring \u003d getDependencyScope(n);\n     String referringName \u003d \"\";\n     if (referring !\u003d null) {\n         referringName \u003d referring.isPrototype ? referring.prototypeClass : referring.name;\n     }\n     String name \u003d nameInfo.name;\n     if (nameInfo.isExternallyReferenceable) {\n         recordReference(WINDOW, name, RefType.REGULAR);\n         return;\n     }\n     if (NodeUtil.isLhs(n, parent)) {\n         if (referring !\u003d null) {\n             recordReference(referringName, name, RefType.REGULAR);\n         }\n         return;\n     }\n     if (nodesToKeep.contains(n)) {\n         NameInformation functionScope \u003d getEnclosingFunctionDependencyScope(t);\n         if (functionScope !\u003d null) {\n             recordReference(functionScope.name, name, RefType.REGULAR);\n         } else {\n             recordReference(WINDOW, name, RefType.REGULAR);\n         }\n     } else if (referring !\u003d null) {\n-        recordReference(referringName, name, RefType.REGULAR);\n+        if ((parent.getType() \u003d\u003d Token.NAME || parent.getType() \u003d\u003d Token.ASSIGN) \u0026\u0026 scopes.get(parent) \u003d\u003d referring) {\n+            recordAlias(referringName, name);\n+        } else {\n+            RefType depType \u003d referring.onlyAffectsClassDef ? RefType.INHERITANCE : RefType.REGULAR;\n+            recordReference(referringName, name, depType);\n+        }\n     } else {\n         for (Node ancestor : n.getAncestors()) {\n             if (NodeUtil.isAssignmentOp(ancestor) || NodeUtil.isFunction(ancestor)) {\n                 recordReference(WINDOW, name, RefType.REGULAR);\n                 break;\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "45f2bdf91ad3c2f2ac901c72efe9e26148b08d2b": {
      "type": "Ybodychange",
      "commitMessage": "Fix a bunch of passes to preserve more type information.\n\nFix goog.provide/goog.require handling to work in the presence of modules.\n\nImprove a bunch of type annotations in gecko_dom.\n\nMake NameAnalyzer use the Graph package.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@95 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "2/8/10, 11:30 AM",
      "commitName": "45f2bdf91ad3c2f2ac901c72efe9e26148b08d2b",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "1/8/10, 1:41 PM",
      "commitNameOld": "6d374c3ee4c9c2651ffb44048924e127fd2bf37c",
      "commitAuthorOld": "nicholas.j.santos@gmail.com",
      "daysBetweenCommits": 30.91,
      "commitsBetweenForRepo": 28,
      "commitsBetweenForFile": 1,
      "actualSource": "public void visit(NodeTraversal t, Node n, Node parent) {\n    if (!(NodeUtil.isName(n) || NodeUtil.isGet(n) \u0026\u0026 !NodeUtil.isGetProp(parent))) {\n        return;\n    }\n    NameInformation nameInfo \u003d createNameInformation(t, n, parent);\n    if (nameInfo \u003d\u003d null) {\n        return;\n    }\n    if (nameInfo.onlyAffectsClassDef) {\n        recordReference(nameInfo.name, nameInfo.superclass, RefType.INHERITANCE);\n        String nodeName \u003d n.getQualifiedName();\n        if (nodeName !\u003d null) {\n            recordReference(nameInfo.name, nodeName, RefType.REGULAR);\n        }\n        return;\n    }\n    if (parent.getType() \u003d\u003d Token.INSTANCEOF \u0026\u0026 parent.getLastChild() \u003d\u003d n) {\n        JsName checkedClass \u003d getName(nameInfo.name, true);\n        refNodes.add(new InstanceOfCheckNode(checkedClass, n, parent, parent.getParent()));\n        return;\n    }\n    NameInformation referring \u003d getDependencyScope(n);\n    String referringName \u003d \"\";\n    if (referring !\u003d null) {\n        referringName \u003d referring.isPrototype ? referring.prototypeClass : referring.name;\n    }\n    String name \u003d nameInfo.name;\n    if (nameInfo.isExternallyReferenceable) {\n        recordReference(WINDOW, name, RefType.REGULAR);\n        return;\n    }\n    if (NodeUtil.isLhs(n, parent)) {\n        if (referring !\u003d null) {\n            recordReference(referringName, name, RefType.REGULAR);\n        }\n        return;\n    }\n    if (nodesToKeep.contains(n)) {\n        NameInformation functionScope \u003d getEnclosingFunctionDependencyScope(t);\n        if (functionScope !\u003d null) {\n            recordReference(functionScope.name, name, RefType.REGULAR);\n        } else {\n            recordReference(WINDOW, name, RefType.REGULAR);\n        }\n    } else if (referring !\u003d null) {\n        recordReference(referringName, name, RefType.REGULAR);\n    } else {\n        for (Node ancestor : n.getAncestors()) {\n            if (NodeUtil.isAssignmentOp(ancestor) || NodeUtil.isFunction(ancestor)) {\n                recordReference(WINDOW, name, RefType.REGULAR);\n                break;\n            }\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/NameAnalyzer.java",
      "functionStartLine": 734,
      "functionName": "visit",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,55 +1,55 @@\n public void visit(NodeTraversal t, Node n, Node parent) {\n     if (!(NodeUtil.isName(n) || NodeUtil.isGet(n) \u0026\u0026 !NodeUtil.isGetProp(parent))) {\n         return;\n     }\n     NameInformation nameInfo \u003d createNameInformation(t, n, parent);\n     if (nameInfo \u003d\u003d null) {\n         return;\n     }\n     if (nameInfo.onlyAffectsClassDef) {\n-        recordReference(nameInfo.name, nameInfo.superclass);\n+        recordReference(nameInfo.name, nameInfo.superclass, RefType.INHERITANCE);\n         String nodeName \u003d n.getQualifiedName();\n         if (nodeName !\u003d null) {\n-            recordReference(nameInfo.name, nodeName);\n+            recordReference(nameInfo.name, nodeName, RefType.REGULAR);\n         }\n         return;\n     }\n     if (parent.getType() \u003d\u003d Token.INSTANCEOF \u0026\u0026 parent.getLastChild() \u003d\u003d n) {\n         JsName checkedClass \u003d getName(nameInfo.name, true);\n         refNodes.add(new InstanceOfCheckNode(checkedClass, n, parent, parent.getParent()));\n         return;\n     }\n     NameInformation referring \u003d getDependencyScope(n);\n     String referringName \u003d \"\";\n     if (referring !\u003d null) {\n         referringName \u003d referring.isPrototype ? referring.prototypeClass : referring.name;\n     }\n     String name \u003d nameInfo.name;\n     if (nameInfo.isExternallyReferenceable) {\n-        recordReference(WINDOW, name);\n+        recordReference(WINDOW, name, RefType.REGULAR);\n         return;\n     }\n     if (NodeUtil.isLhs(n, parent)) {\n         if (referring !\u003d null) {\n-            recordReference(referringName, name);\n+            recordReference(referringName, name, RefType.REGULAR);\n         }\n         return;\n     }\n     if (nodesToKeep.contains(n)) {\n         NameInformation functionScope \u003d getEnclosingFunctionDependencyScope(t);\n         if (functionScope !\u003d null) {\n-            recordReference(functionScope.name, name);\n+            recordReference(functionScope.name, name, RefType.REGULAR);\n         } else {\n-            recordReference(WINDOW, name);\n+            recordReference(WINDOW, name, RefType.REGULAR);\n         }\n     } else if (referring !\u003d null) {\n-        recordReference(referringName, name);\n+        recordReference(referringName, name, RefType.REGULAR);\n     } else {\n         for (Node ancestor : n.getAncestors()) {\n             if (NodeUtil.isAssignmentOp(ancestor) || NodeUtil.isFunction(ancestor)) {\n-                recordReference(WINDOW, name);\n+                recordReference(WINDOW, name, RefType.REGULAR);\n                 break;\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": {
      "type": "Yintroduced",
      "commitMessage": "Initial commit.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/3/09, 3:51 PM",
      "commitName": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "diff": "@@ -0,0 +1,55 @@\n+public void visit(NodeTraversal t, Node n, Node parent) {\n+    if (!(NodeUtil.isName(n) || NodeUtil.isGet(n) \u0026\u0026 !NodeUtil.isGetProp(parent))) {\n+        return;\n+    }\n+    NameInformation nameInfo \u003d createNameInformation(t, n, parent);\n+    if (nameInfo \u003d\u003d null) {\n+        return;\n+    }\n+    if (nameInfo.onlyAffectsClassDef) {\n+        recordReference(nameInfo.name, nameInfo.superclass);\n+        String nodeName \u003d n.getQualifiedName();\n+        if (nodeName !\u003d null) {\n+            recordReference(nameInfo.name, nodeName);\n+        }\n+        return;\n+    }\n+    if (parent.getType() \u003d\u003d Token.INSTANCEOF \u0026\u0026 parent.getLastChild() \u003d\u003d n) {\n+        JsName checkedClass \u003d getName(nameInfo.name, true);\n+        refNodes.add(new InstanceOfCheckNode(checkedClass, n, parent, parent.getParent()));\n+        return;\n+    }\n+    NameInformation referring \u003d getDependencyScope(n);\n+    String referringName \u003d \"\";\n+    if (referring !\u003d null) {\n+        referringName \u003d referring.isPrototype ? referring.prototypeClass : referring.name;\n+    }\n+    String name \u003d nameInfo.name;\n+    if (nameInfo.isExternallyReferenceable) {\n+        recordReference(WINDOW, name);\n+        return;\n+    }\n+    if (NodeUtil.isLhs(n, parent)) {\n+        if (referring !\u003d null) {\n+            recordReference(referringName, name);\n+        }\n+        return;\n+    }\n+    if (nodesToKeep.contains(n)) {\n+        NameInformation functionScope \u003d getEnclosingFunctionDependencyScope(t);\n+        if (functionScope !\u003d null) {\n+            recordReference(functionScope.name, name);\n+        } else {\n+            recordReference(WINDOW, name);\n+        }\n+    } else if (referring !\u003d null) {\n+        recordReference(referringName, name);\n+    } else {\n+        for (Node ancestor : n.getAncestors()) {\n+            if (NodeUtil.isAssignmentOp(ancestor) || NodeUtil.isFunction(ancestor)) {\n+                recordReference(WINDOW, name);\n+                break;\n+            }\n+        }\n+    }\n+}\n\\ No newline at end of file\n",
      "actualSource": "public void visit(NodeTraversal t, Node n, Node parent) {\n    if (!(NodeUtil.isName(n) || NodeUtil.isGet(n) \u0026\u0026 !NodeUtil.isGetProp(parent))) {\n        return;\n    }\n    NameInformation nameInfo \u003d createNameInformation(t, n, parent);\n    if (nameInfo \u003d\u003d null) {\n        return;\n    }\n    if (nameInfo.onlyAffectsClassDef) {\n        recordReference(nameInfo.name, nameInfo.superclass);\n        String nodeName \u003d n.getQualifiedName();\n        if (nodeName !\u003d null) {\n            recordReference(nameInfo.name, nodeName);\n        }\n        return;\n    }\n    if (parent.getType() \u003d\u003d Token.INSTANCEOF \u0026\u0026 parent.getLastChild() \u003d\u003d n) {\n        JsName checkedClass \u003d getName(nameInfo.name, true);\n        refNodes.add(new InstanceOfCheckNode(checkedClass, n, parent, parent.getParent()));\n        return;\n    }\n    NameInformation referring \u003d getDependencyScope(n);\n    String referringName \u003d \"\";\n    if (referring !\u003d null) {\n        referringName \u003d referring.isPrototype ? referring.prototypeClass : referring.name;\n    }\n    String name \u003d nameInfo.name;\n    if (nameInfo.isExternallyReferenceable) {\n        recordReference(WINDOW, name);\n        return;\n    }\n    if (NodeUtil.isLhs(n, parent)) {\n        if (referring !\u003d null) {\n            recordReference(referringName, name);\n        }\n        return;\n    }\n    if (nodesToKeep.contains(n)) {\n        NameInformation functionScope \u003d getEnclosingFunctionDependencyScope(t);\n        if (functionScope !\u003d null) {\n            recordReference(functionScope.name, name);\n        } else {\n            recordReference(WINDOW, name);\n        }\n    } else if (referring !\u003d null) {\n        recordReference(referringName, name);\n    } else {\n        for (Node ancestor : n.getAncestors()) {\n            if (NodeUtil.isAssignmentOp(ancestor) || NodeUtil.isFunction(ancestor)) {\n                recordReference(WINDOW, name);\n                break;\n            }\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/NameAnalyzer.java",
      "functionStartLine": 721,
      "functionName": "visit",
      "functionAnnotation": "",
      "functionDoc": ""
    }
  }
}