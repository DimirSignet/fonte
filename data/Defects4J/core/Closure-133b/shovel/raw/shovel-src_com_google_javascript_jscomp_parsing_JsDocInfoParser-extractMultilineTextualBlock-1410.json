{
  "origin": "codeshovel",
  "repositoryName": "Closure-133b",
  "repositoryPath": "/tmp/Closure-133b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "JsDocInfoParser.java",
  "functionName": "extractMultilineTextualBlock",
  "functionId": "extractMultilineTextualBlock___token-JsDocToken__option-WhitespaceOption",
  "sourceFilePath": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
  "functionAnnotation": "@SuppressWarnings(\"fallthrough\")",
  "functionDoc": "Extracts the text found on the current line and all subsequent\nuntil either an annotation, end of comment or end of file is reached.\nNote that if this method detects an end of line as the first token, it\nwill quit immediately (indicating that there is no text where it was\nexpected).  Note that token \u003d info.token; should be called after this\nmethod is used to update the token properly in the parser.\n\n@param token The start token.\n@param option How to handle whitespace.\n@return The extraction information.\n",
  "functionStartLine": 1410,
  "functionEndLine": 1522,
  "numCommitsSeen": 72,
  "timeTaken": 8075,
  "changeHistory": [
    "70a5626922ea7e8c98747e22b6986638ba38fadc",
    "66c8c695fd8130e3ede6f77c6e5cc1ec96a0e9b3",
    "4fe0dd22b4462cbd3943f3a8d77db8136ff4d9b7",
    "c25df7eca2462861bf42ad8b74215099c3f81ae6",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3"
  ],
  "changeHistoryShort": {
    "70a5626922ea7e8c98747e22b6986638ba38fadc": "Ybodychange",
    "66c8c695fd8130e3ede6f77c6e5cc1ec96a0e9b3": "Ybodychange",
    "4fe0dd22b4462cbd3943f3a8d77db8136ff4d9b7": "Yformatchange",
    "c25df7eca2462861bf42ad8b74215099c3f81ae6": "Ymultichange(Ybodychange,Yannotationchange)",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "70a5626922ea7e8c98747e22b6986638ba38fadc": {
      "type": "Ybodychange",
      "commitMessage": "\nFix various typos, spelling and grammar errors.\nFixes issue 734. \nContributed by Robert Gust Bardon\n\nR\u003dnicksantos\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d4827\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1979 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "5/18/12, 11:09 AM",
      "commitName": "70a5626922ea7e8c98747e22b6986638ba38fadc",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "5/7/12, 2:29 PM",
      "commitNameOld": "c621cfa98e0c217f283c2d41bbf3019662e4fda8",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 10.86,
      "commitsBetweenForRepo": 22,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"fallthrough\")\nprivate ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {\n    if (token \u003d\u003d JsDocToken.EOC || token \u003d\u003d JsDocToken.EOL || token \u003d\u003d JsDocToken.EOF) {\n        return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineno \u003d stream.getLineno();\n    int startCharno \u003d stream.getCharno() + 1;\n    String line \u003d stream.getRemainingJSDocLine();\n    if (option !\u003d WhitespaceOption.PRESERVE) {\n        line \u003d line.trim();\n    }\n    StringBuilder builder \u003d new StringBuilder();\n    builder.append(line);\n    state \u003d State.SEARCHING_ANNOTATION;\n    token \u003d next();\n    boolean ignoreStar \u003d false;\n    int lineStartChar \u003d -1;\n    do {\n        switch(token) {\n            case STAR:\n                if (ignoreStar) {\n                    lineStartChar \u003d stream.getCharno() + 1;\n                } else {\n                    if (builder.length() \u003e 0) {\n                        builder.append(\u0027 \u0027);\n                    }\n                    builder.append(\u0027*\u0027);\n                }\n                token \u003d next();\n                continue;\n            case EOL:\n                if (option !\u003d WhitespaceOption.SINGLE_LINE) {\n                    builder.append(\"\\n\");\n                }\n                ignoreStar \u003d true;\n                lineStartChar \u003d 0;\n                token \u003d next();\n                continue;\n            default:\n                ignoreStar \u003d false;\n                state \u003d State.SEARCHING_ANNOTATION;\n                boolean isEOC \u003d token \u003d\u003d JsDocToken.EOC;\n                if (!isEOC) {\n                    if (lineStartChar !\u003d -1 \u0026\u0026 option \u003d\u003d WhitespaceOption.PRESERVE) {\n                        int numSpaces \u003d stream.getCharno() - lineStartChar;\n                        for (int i \u003d 0; i \u003c numSpaces; i++) {\n                            builder.append(\u0027 \u0027);\n                        }\n                        lineStartChar \u003d -1;\n                    } else if (builder.length() \u003e 0) {\n                        builder.append(\u0027 \u0027);\n                    }\n                }\n                if (token \u003d\u003d JsDocToken.EOC || token \u003d\u003d JsDocToken.EOF || (token \u003d\u003d JsDocToken.ANNOTATION \u0026\u0026 option !\u003d WhitespaceOption.PRESERVE)) {\n                    String multilineText \u003d builder.toString();\n                    if (option !\u003d WhitespaceOption.PRESERVE) {\n                        multilineText \u003d multilineText.trim();\n                    }\n                    int endLineno \u003d stream.getLineno();\n                    int endCharno \u003d stream.getCharno();\n                    if (multilineText.length() \u003e 0) {\n                        jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                    }\n                    return new ExtractionInfo(multilineText, token);\n                }\n                builder.append(toString(token));\n                line \u003d stream.getRemainingJSDocLine();\n                if (option !\u003d WhitespaceOption.PRESERVE) {\n                    line \u003d trimEnd(line);\n                }\n                builder.append(line);\n                token \u003d next();\n        }\n    } while (true);\n}",
      "path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
      "functionStartLine": 1328,
      "functionName": "extractMultilineTextualBlock",
      "functionAnnotation": "@SuppressWarnings(\"fallthrough\")",
      "functionDoc": "Extracts the text found on the current line and all subsequent\nuntil either an annotation, end of comment or end of file is reached.\nNote that if this method detects an end of line as the first token, it\nwill quit immediately (indicating that there is no text where it was\nexpected).  Note that token \u003d info.token; should be called after this\nmethod is used to update the token properly in the parser.\n\n@param token The start token.\n@param option How to handle whitespace.\n@return The extraction information.\n",
      "diff": "",
      "extendedDetails": {}
    },
    "66c8c695fd8130e3ede6f77c6e5cc1ec96a0e9b3": {
      "type": "Ybodychange",
      "commitMessage": "\npreserve whitespace at the beginning of license blocks\nmakes the \u003ccode\u003e in closure docs look a lot better\nfixes issue 701\n\nR\u003djschorr\nDELTA\u003d73  (52 added, 10 deleted, 11 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d4482\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1869 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/5/12, 11:10 AM",
      "commitName": "66c8c695fd8130e3ede6f77c6e5cc1ec96a0e9b3",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "3/9/12, 4:23 PM",
      "commitNameOld": "262e522d93c967c7a80c27c087f166e5e7b903c4",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 26.74,
      "commitsBetweenForRepo": 38,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"fallthrough\")\nprivate ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {\n    if (token \u003d\u003d JsDocToken.EOC || token \u003d\u003d JsDocToken.EOL || token \u003d\u003d JsDocToken.EOF) {\n        return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineno \u003d stream.getLineno();\n    int startCharno \u003d stream.getCharno() + 1;\n    String line \u003d stream.getRemainingJSDocLine();\n    if (option !\u003d WhitespaceOption.PRESERVE) {\n        line \u003d line.trim();\n    }\n    StringBuilder builder \u003d new StringBuilder();\n    builder.append(line);\n    state \u003d State.SEARCHING_ANNOTATION;\n    token \u003d next();\n    boolean ignoreStar \u003d false;\n    int lineStartChar \u003d -1;\n    do {\n        switch(token) {\n            case STAR:\n                if (ignoreStar) {\n                    lineStartChar \u003d stream.getCharno() + 1;\n                } else {\n                    if (builder.length() \u003e 0) {\n                        builder.append(\u0027 \u0027);\n                    }\n                    builder.append(\u0027*\u0027);\n                }\n                token \u003d next();\n                continue;\n            case EOL:\n                if (option !\u003d WhitespaceOption.SINGLE_LINE) {\n                    builder.append(\"\\n\");\n                }\n                ignoreStar \u003d true;\n                lineStartChar \u003d 0;\n                token \u003d next();\n                continue;\n            default:\n                ignoreStar \u003d false;\n                state \u003d State.SEARCHING_ANNOTATION;\n                boolean isEOC \u003d token \u003d\u003d JsDocToken.EOC;\n                if (!isEOC) {\n                    if (lineStartChar !\u003d -1 \u0026\u0026 option \u003d\u003d WhitespaceOption.PRESERVE) {\n                        int numSpaces \u003d stream.getCharno() - lineStartChar;\n                        for (int i \u003d 0; i \u003c numSpaces; i++) {\n                            builder.append(\u0027 \u0027);\n                        }\n                        lineStartChar \u003d -1;\n                    } else if (builder.length() \u003e 0) {\n                        builder.append(\u0027 \u0027);\n                    }\n                }\n                if (token \u003d\u003d JsDocToken.EOC || token \u003d\u003d JsDocToken.EOF || (token \u003d\u003d JsDocToken.ANNOTATION \u0026\u0026 option !\u003d WhitespaceOption.PRESERVE)) {\n                    String multilineText \u003d builder.toString();\n                    if (option !\u003d WhitespaceOption.PRESERVE) {\n                        multilineText \u003d multilineText.trim();\n                    }\n                    int endLineno \u003d stream.getLineno();\n                    int endCharno \u003d stream.getCharno();\n                    if (multilineText.length() \u003e 0) {\n                        jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                    }\n                    return new ExtractionInfo(multilineText, token);\n                }\n                builder.append(toString(token));\n                line \u003d stream.getRemainingJSDocLine();\n                if (option !\u003d WhitespaceOption.PRESERVE) {\n                    line \u003d trimEnd(line);\n                }\n                builder.append(line);\n                token \u003d next();\n        }\n    } while (true);\n}",
      "path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
      "functionStartLine": 1329,
      "functionName": "extractMultilineTextualBlock",
      "functionAnnotation": "@SuppressWarnings(\"fallthrough\")",
      "functionDoc": "Extracts the text found on the current line and all subsequent\nuntil either an annotation, end of comment or end of file is reached.\nNote that if this method detects an end of line as the first token, it\nwill quit immediately (indicating that there is no text where it was\nexpected).  Note that token \u003d info.token; should be called after this\nmethod is used to update the token properly in the parser.\n\n@param token The start token.\n@param option How to handle whitespace.\n@return The extraction information.\n",
      "diff": "@@ -1,66 +1,76 @@\n @SuppressWarnings(\"fallthrough\")\n private ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {\n     if (token \u003d\u003d JsDocToken.EOC || token \u003d\u003d JsDocToken.EOL || token \u003d\u003d JsDocToken.EOF) {\n         return new ExtractionInfo(\"\", token);\n     }\n     stream.update();\n     int startLineno \u003d stream.getLineno();\n     int startCharno \u003d stream.getCharno() + 1;\n     String line \u003d stream.getRemainingJSDocLine();\n     if (option !\u003d WhitespaceOption.PRESERVE) {\n         line \u003d line.trim();\n     }\n     StringBuilder builder \u003d new StringBuilder();\n     builder.append(line);\n     state \u003d State.SEARCHING_ANNOTATION;\n     token \u003d next();\n     boolean ignoreStar \u003d false;\n+    int lineStartChar \u003d -1;\n     do {\n         switch(token) {\n             case STAR:\n-                if (!ignoreStar) {\n+                if (ignoreStar) {\n+                    lineStartChar \u003d stream.getCharno() + 1;\n+                } else {\n                     if (builder.length() \u003e 0) {\n                         builder.append(\u0027 \u0027);\n                     }\n                     builder.append(\u0027*\u0027);\n                 }\n                 token \u003d next();\n                 continue;\n             case EOL:\n                 if (option !\u003d WhitespaceOption.SINGLE_LINE) {\n                     builder.append(\"\\n\");\n                 }\n                 ignoreStar \u003d true;\n+                lineStartChar \u003d 0;\n                 token \u003d next();\n                 continue;\n-            case ANNOTATION:\n-            case EOC:\n-            case EOF:\n-                if (!(option \u003d\u003d WhitespaceOption.PRESERVE \u0026\u0026 token \u003d\u003d JsDocToken.ANNOTATION)) {\n+            default:\n+                ignoreStar \u003d false;\n+                state \u003d State.SEARCHING_ANNOTATION;\n+                boolean isEOC \u003d token \u003d\u003d JsDocToken.EOC;\n+                if (!isEOC) {\n+                    if (lineStartChar !\u003d -1 \u0026\u0026 option \u003d\u003d WhitespaceOption.PRESERVE) {\n+                        int numSpaces \u003d stream.getCharno() - lineStartChar;\n+                        for (int i \u003d 0; i \u003c numSpaces; i++) {\n+                            builder.append(\u0027 \u0027);\n+                        }\n+                        lineStartChar \u003d -1;\n+                    } else if (builder.length() \u003e 0) {\n+                        builder.append(\u0027 \u0027);\n+                    }\n+                }\n+                if (token \u003d\u003d JsDocToken.EOC || token \u003d\u003d JsDocToken.EOF || (token \u003d\u003d JsDocToken.ANNOTATION \u0026\u0026 option !\u003d WhitespaceOption.PRESERVE)) {\n                     String multilineText \u003d builder.toString();\n                     if (option !\u003d WhitespaceOption.PRESERVE) {\n                         multilineText \u003d multilineText.trim();\n                     }\n                     int endLineno \u003d stream.getLineno();\n                     int endCharno \u003d stream.getCharno();\n                     if (multilineText.length() \u003e 0) {\n                         jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                     }\n                     return new ExtractionInfo(multilineText, token);\n                 }\n-            default:\n-                ignoreStar \u003d false;\n-                state \u003d State.SEARCHING_ANNOTATION;\n-                if (builder.length() \u003e 0) {\n-                    builder.append(\u0027 \u0027);\n-                }\n                 builder.append(toString(token));\n                 line \u003d stream.getRemainingJSDocLine();\n                 if (option !\u003d WhitespaceOption.PRESERVE) {\n                     line \u003d trimEnd(line);\n                 }\n                 builder.append(line);\n                 token \u003d next();\n         }\n     } while (true);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4fe0dd22b4462cbd3943f3a8d77db8136ff4d9b7": {
      "type": "Yformatchange",
      "commitMessage": "\nDon\u0027t eat the first token of the @return description.\nThis is kind of a hack because it mixes the character stream up\nwith the token stream, but it\u0027s probably more maintainable\nand has less overhead than trying to manage the description\nin the token stream\n(which is the \"pure-but-lots-of-work\" solution).\n\nR\u003djschorr\nDELTA\u003d58  (48 added, 7 deleted, 3 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d1178\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@954 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "3/30/11, 10:44 AM",
      "commitName": "4fe0dd22b4462cbd3943f3a8d77db8136ff4d9b7",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "3/14/11, 1:14 PM",
      "commitNameOld": "9b04e62d89c89cfa636ae803e210ddbeb007a626",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 15.9,
      "commitsBetweenForRepo": 62,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"fallthrough\")\nprivate ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {\n    if (token \u003d\u003d JsDocToken.EOC || token \u003d\u003d JsDocToken.EOL || token \u003d\u003d JsDocToken.EOF) {\n        return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineno \u003d stream.getLineno();\n    int startCharno \u003d stream.getCharno() + 1;\n    String line \u003d stream.getRemainingJSDocLine();\n    if (option !\u003d WhitespaceOption.PRESERVE) {\n        line \u003d line.trim();\n    }\n    StringBuilder builder \u003d new StringBuilder();\n    builder.append(line);\n    state \u003d State.SEARCHING_ANNOTATION;\n    token \u003d next();\n    boolean ignoreStar \u003d false;\n    do {\n        switch(token) {\n            case STAR:\n                if (!ignoreStar) {\n                    if (builder.length() \u003e 0) {\n                        builder.append(\u0027 \u0027);\n                    }\n                    builder.append(\u0027*\u0027);\n                }\n                token \u003d next();\n                continue;\n            case EOL:\n                if (option !\u003d WhitespaceOption.SINGLE_LINE) {\n                    builder.append(\"\\n\");\n                }\n                ignoreStar \u003d true;\n                token \u003d next();\n                continue;\n            case ANNOTATION:\n            case EOC:\n            case EOF:\n                if (!(option \u003d\u003d WhitespaceOption.PRESERVE \u0026\u0026 token \u003d\u003d JsDocToken.ANNOTATION)) {\n                    String multilineText \u003d builder.toString();\n                    if (option !\u003d WhitespaceOption.PRESERVE) {\n                        multilineText \u003d multilineText.trim();\n                    }\n                    int endLineno \u003d stream.getLineno();\n                    int endCharno \u003d stream.getCharno();\n                    if (multilineText.length() \u003e 0) {\n                        jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                    }\n                    return new ExtractionInfo(multilineText, token);\n                }\n            default:\n                ignoreStar \u003d false;\n                state \u003d State.SEARCHING_ANNOTATION;\n                if (builder.length() \u003e 0) {\n                    builder.append(\u0027 \u0027);\n                }\n                builder.append(toString(token));\n                line \u003d stream.getRemainingJSDocLine();\n                if (option !\u003d WhitespaceOption.PRESERVE) {\n                    line \u003d trimEnd(line);\n                }\n                builder.append(line);\n                token \u003d next();\n        }\n    } while (true);\n}",
      "path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
      "functionStartLine": 1266,
      "functionName": "extractMultilineTextualBlock",
      "functionAnnotation": "@SuppressWarnings(\"fallthrough\")",
      "functionDoc": "Extracts the text found on the current line and all subsequent\nuntil either an annotation, end of comment or end of file is reached.\nNote that if this method detects an end of line as the first token, it\nwill quit immediately (indicating that there is no text where it was\nexpected).  Note that token \u003d info.token; should be called after this\nmethod is used to update the token properly in the parser.\n\n@param token The start token.\n@param option How to handle whitespace.\n@return The extraction information.\n",
      "diff": "",
      "extendedDetails": {}
    },
    "c25df7eca2462861bf42ad8b74215099c3f81ae6": {
      "type": "Ymultichange(Ybodychange,Yannotationchange)",
      "commitMessage": "Make lists the canonical representation of compiler sources.\nThey\u0027re so much easier to sort and mutate, which is going to\nmake a difference once we start sorting sources. (Nick)\nR\u003drobert\nDELTA\u003d97  (58 added, 6 deleted, 33 changed)\n\ninclude everything in the @license tag. (Nick)\nR\u003drobert\nDELTA\u003d78  (32 added, 19 deleted, 27 changed)\n\ntag externs files with the @externs tag. (Nick)\nR\u003dalan\nDELTA\u003d45  (45 added, 0 deleted, 0 changed)\n\nfix for issue 58.\nwork-around a bug in IE where it gets confused if the comparator\npassed to Array.prototype.sort writes to its own parameters. (Nick)\nR\u003dalan\nDELTA\u003d33  (30 added, 0 deleted, 3 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003ddpiluc\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@171 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/5/10, 11:58 PM",
      "commitName": "c25df7eca2462861bf42ad8b74215099c3f81ae6",
      "commitAuthor": "Nicholas.J.Santos",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "Make lists the canonical representation of compiler sources.\nThey\u0027re so much easier to sort and mutate, which is going to\nmake a difference once we start sorting sources. (Nick)\nR\u003drobert\nDELTA\u003d97  (58 added, 6 deleted, 33 changed)\n\ninclude everything in the @license tag. (Nick)\nR\u003drobert\nDELTA\u003d78  (32 added, 19 deleted, 27 changed)\n\ntag externs files with the @externs tag. (Nick)\nR\u003dalan\nDELTA\u003d45  (45 added, 0 deleted, 0 changed)\n\nfix for issue 58.\nwork-around a bug in IE where it gets confused if the comparator\npassed to Array.prototype.sort writes to its own parameters. (Nick)\nR\u003dalan\nDELTA\u003d33  (30 added, 0 deleted, 3 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003ddpiluc\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@171 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "4/5/10, 11:58 PM",
          "commitName": "c25df7eca2462861bf42ad8b74215099c3f81ae6",
          "commitAuthor": "Nicholas.J.Santos",
          "commitDateOld": "3/17/10, 1:06 PM",
          "commitNameOld": "295c978bfbf070d28214b27239cd26aaea58b6d4",
          "commitAuthorOld": "Nicholas.J.Santos",
          "daysBetweenCommits": 19.45,
          "commitsBetweenForRepo": 31,
          "commitsBetweenForFile": 1,
          "actualSource": "@SuppressWarnings(\"fallthrough\")\nprivate ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {\n    if (token \u003d\u003d JsDocToken.EOC || token \u003d\u003d JsDocToken.EOL || token \u003d\u003d JsDocToken.EOF) {\n        return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineno \u003d stream.getLineno();\n    int startCharno \u003d stream.getCharno() + 1;\n    String line \u003d stream.getRemainingJSDocLine();\n    if (option !\u003d WhitespaceOption.PRESERVE) {\n        line \u003d line.trim();\n    }\n    StringBuilder builder \u003d new StringBuilder();\n    builder.append(line);\n    state \u003d State.SEARCHING_ANNOTATION;\n    token \u003d next();\n    boolean ignoreStar \u003d false;\n    do {\n        switch(token) {\n            case STAR:\n                if (!ignoreStar) {\n                    if (builder.length() \u003e 0) {\n                        builder.append(\u0027 \u0027);\n                    }\n                    builder.append(\u0027*\u0027);\n                }\n                token \u003d next();\n                continue;\n            case EOL:\n                if (option !\u003d WhitespaceOption.SINGLE_LINE) {\n                    builder.append(\"\\n\");\n                }\n                ignoreStar \u003d true;\n                token \u003d next();\n                continue;\n            case ANNOTATION:\n            case EOC:\n            case EOF:\n                if (!(option \u003d\u003d WhitespaceOption.PRESERVE \u0026\u0026 token \u003d\u003d JsDocToken.ANNOTATION)) {\n                    String multilineText \u003d builder.toString();\n                    if (option !\u003d WhitespaceOption.PRESERVE) {\n                        multilineText \u003d multilineText.trim();\n                    }\n                    int endLineno \u003d stream.getLineno();\n                    int endCharno \u003d stream.getCharno();\n                    if (multilineText.length() \u003e 0) {\n                        jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                    }\n                    return new ExtractionInfo(multilineText, token);\n                }\n            default:\n                ignoreStar \u003d false;\n                state \u003d State.SEARCHING_ANNOTATION;\n                if (builder.length() \u003e 0) {\n                    builder.append(\u0027 \u0027);\n                }\n                builder.append(toString(token));\n                line \u003d stream.getRemainingJSDocLine();\n                if (option !\u003d WhitespaceOption.PRESERVE) {\n                    line \u003d trimEnd(line);\n                }\n                builder.append(line);\n                token \u003d next();\n        }\n    } while (true);\n}",
          "path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
          "functionStartLine": 1113,
          "functionName": "extractMultilineTextualBlock",
          "functionAnnotation": "@SuppressWarnings(\"fallthrough\")",
          "functionDoc": "Extracts the text found on the current line and all subsequent\nuntil either an annotation, end of comment or end of file is reached.\nNote that if this method detects an end of line as the first token, it\nwill quit immediately (indicating that there is no text where it was\nexpected).  Note that token \u003d info.token; should be called after this\nmethod is used to update the token properly in the parser.\n\n@param token The start token.\n@param option How to handle whitespace.\n@return The extraction information.\n",
          "diff": "@@ -1,63 +1,66 @@\n+@SuppressWarnings(\"fallthrough\")\n private ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {\n     if (token \u003d\u003d JsDocToken.EOC || token \u003d\u003d JsDocToken.EOL || token \u003d\u003d JsDocToken.EOF) {\n         return new ExtractionInfo(\"\", token);\n     }\n     stream.update();\n     int startLineno \u003d stream.getLineno();\n     int startCharno \u003d stream.getCharno() + 1;\n     String line \u003d stream.getRemainingJSDocLine();\n     if (option !\u003d WhitespaceOption.PRESERVE) {\n         line \u003d line.trim();\n     }\n     StringBuilder builder \u003d new StringBuilder();\n     builder.append(line);\n     state \u003d State.SEARCHING_ANNOTATION;\n     token \u003d next();\n     boolean ignoreStar \u003d false;\n     do {\n         switch(token) {\n-            case ANNOTATION:\n-            case EOC:\n-            case EOF:\n-                String multilineText \u003d builder.toString();\n-                if (option !\u003d WhitespaceOption.PRESERVE) {\n-                    multilineText \u003d multilineText.trim();\n-                }\n-                int endLineno \u003d stream.getLineno();\n-                int endCharno \u003d stream.getCharno();\n-                if (multilineText.length() \u003e 0) {\n-                    jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n-                }\n-                return new ExtractionInfo(multilineText, token);\n             case STAR:\n                 if (!ignoreStar) {\n                     if (builder.length() \u003e 0) {\n                         builder.append(\u0027 \u0027);\n                     }\n                     builder.append(\u0027*\u0027);\n                 }\n                 token \u003d next();\n                 continue;\n             case EOL:\n                 if (option !\u003d WhitespaceOption.SINGLE_LINE) {\n                     builder.append(\"\\n\");\n                 }\n                 ignoreStar \u003d true;\n                 token \u003d next();\n                 continue;\n+            case ANNOTATION:\n+            case EOC:\n+            case EOF:\n+                if (!(option \u003d\u003d WhitespaceOption.PRESERVE \u0026\u0026 token \u003d\u003d JsDocToken.ANNOTATION)) {\n+                    String multilineText \u003d builder.toString();\n+                    if (option !\u003d WhitespaceOption.PRESERVE) {\n+                        multilineText \u003d multilineText.trim();\n+                    }\n+                    int endLineno \u003d stream.getLineno();\n+                    int endCharno \u003d stream.getCharno();\n+                    if (multilineText.length() \u003e 0) {\n+                        jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n+                    }\n+                    return new ExtractionInfo(multilineText, token);\n+                }\n             default:\n                 ignoreStar \u003d false;\n                 state \u003d State.SEARCHING_ANNOTATION;\n                 if (builder.length() \u003e 0) {\n                     builder.append(\u0027 \u0027);\n                 }\n                 builder.append(toString(token));\n                 line \u003d stream.getRemainingJSDocLine();\n                 if (option !\u003d WhitespaceOption.PRESERVE) {\n                     line \u003d trimEnd(line);\n                 }\n                 builder.append(line);\n                 token \u003d next();\n         }\n     } while (true);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Yannotationchange",
          "commitMessage": "Make lists the canonical representation of compiler sources.\nThey\u0027re so much easier to sort and mutate, which is going to\nmake a difference once we start sorting sources. (Nick)\nR\u003drobert\nDELTA\u003d97  (58 added, 6 deleted, 33 changed)\n\ninclude everything in the @license tag. (Nick)\nR\u003drobert\nDELTA\u003d78  (32 added, 19 deleted, 27 changed)\n\ntag externs files with the @externs tag. (Nick)\nR\u003dalan\nDELTA\u003d45  (45 added, 0 deleted, 0 changed)\n\nfix for issue 58.\nwork-around a bug in IE where it gets confused if the comparator\npassed to Array.prototype.sort writes to its own parameters. (Nick)\nR\u003dalan\nDELTA\u003d33  (30 added, 0 deleted, 3 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003ddpiluc\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@171 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "4/5/10, 11:58 PM",
          "commitName": "c25df7eca2462861bf42ad8b74215099c3f81ae6",
          "commitAuthor": "Nicholas.J.Santos",
          "commitDateOld": "3/17/10, 1:06 PM",
          "commitNameOld": "295c978bfbf070d28214b27239cd26aaea58b6d4",
          "commitAuthorOld": "Nicholas.J.Santos",
          "daysBetweenCommits": 19.45,
          "commitsBetweenForRepo": 31,
          "commitsBetweenForFile": 1,
          "actualSource": "@SuppressWarnings(\"fallthrough\")\nprivate ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {\n    if (token \u003d\u003d JsDocToken.EOC || token \u003d\u003d JsDocToken.EOL || token \u003d\u003d JsDocToken.EOF) {\n        return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineno \u003d stream.getLineno();\n    int startCharno \u003d stream.getCharno() + 1;\n    String line \u003d stream.getRemainingJSDocLine();\n    if (option !\u003d WhitespaceOption.PRESERVE) {\n        line \u003d line.trim();\n    }\n    StringBuilder builder \u003d new StringBuilder();\n    builder.append(line);\n    state \u003d State.SEARCHING_ANNOTATION;\n    token \u003d next();\n    boolean ignoreStar \u003d false;\n    do {\n        switch(token) {\n            case STAR:\n                if (!ignoreStar) {\n                    if (builder.length() \u003e 0) {\n                        builder.append(\u0027 \u0027);\n                    }\n                    builder.append(\u0027*\u0027);\n                }\n                token \u003d next();\n                continue;\n            case EOL:\n                if (option !\u003d WhitespaceOption.SINGLE_LINE) {\n                    builder.append(\"\\n\");\n                }\n                ignoreStar \u003d true;\n                token \u003d next();\n                continue;\n            case ANNOTATION:\n            case EOC:\n            case EOF:\n                if (!(option \u003d\u003d WhitespaceOption.PRESERVE \u0026\u0026 token \u003d\u003d JsDocToken.ANNOTATION)) {\n                    String multilineText \u003d builder.toString();\n                    if (option !\u003d WhitespaceOption.PRESERVE) {\n                        multilineText \u003d multilineText.trim();\n                    }\n                    int endLineno \u003d stream.getLineno();\n                    int endCharno \u003d stream.getCharno();\n                    if (multilineText.length() \u003e 0) {\n                        jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                    }\n                    return new ExtractionInfo(multilineText, token);\n                }\n            default:\n                ignoreStar \u003d false;\n                state \u003d State.SEARCHING_ANNOTATION;\n                if (builder.length() \u003e 0) {\n                    builder.append(\u0027 \u0027);\n                }\n                builder.append(toString(token));\n                line \u003d stream.getRemainingJSDocLine();\n                if (option !\u003d WhitespaceOption.PRESERVE) {\n                    line \u003d trimEnd(line);\n                }\n                builder.append(line);\n                token \u003d next();\n        }\n    } while (true);\n}",
          "path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
          "functionStartLine": 1113,
          "functionName": "extractMultilineTextualBlock",
          "functionAnnotation": "@SuppressWarnings(\"fallthrough\")",
          "functionDoc": "Extracts the text found on the current line and all subsequent\nuntil either an annotation, end of comment or end of file is reached.\nNote that if this method detects an end of line as the first token, it\nwill quit immediately (indicating that there is no text where it was\nexpected).  Note that token \u003d info.token; should be called after this\nmethod is used to update the token properly in the parser.\n\n@param token The start token.\n@param option How to handle whitespace.\n@return The extraction information.\n",
          "diff": "@@ -1,63 +1,66 @@\n+@SuppressWarnings(\"fallthrough\")\n private ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {\n     if (token \u003d\u003d JsDocToken.EOC || token \u003d\u003d JsDocToken.EOL || token \u003d\u003d JsDocToken.EOF) {\n         return new ExtractionInfo(\"\", token);\n     }\n     stream.update();\n     int startLineno \u003d stream.getLineno();\n     int startCharno \u003d stream.getCharno() + 1;\n     String line \u003d stream.getRemainingJSDocLine();\n     if (option !\u003d WhitespaceOption.PRESERVE) {\n         line \u003d line.trim();\n     }\n     StringBuilder builder \u003d new StringBuilder();\n     builder.append(line);\n     state \u003d State.SEARCHING_ANNOTATION;\n     token \u003d next();\n     boolean ignoreStar \u003d false;\n     do {\n         switch(token) {\n-            case ANNOTATION:\n-            case EOC:\n-            case EOF:\n-                String multilineText \u003d builder.toString();\n-                if (option !\u003d WhitespaceOption.PRESERVE) {\n-                    multilineText \u003d multilineText.trim();\n-                }\n-                int endLineno \u003d stream.getLineno();\n-                int endCharno \u003d stream.getCharno();\n-                if (multilineText.length() \u003e 0) {\n-                    jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n-                }\n-                return new ExtractionInfo(multilineText, token);\n             case STAR:\n                 if (!ignoreStar) {\n                     if (builder.length() \u003e 0) {\n                         builder.append(\u0027 \u0027);\n                     }\n                     builder.append(\u0027*\u0027);\n                 }\n                 token \u003d next();\n                 continue;\n             case EOL:\n                 if (option !\u003d WhitespaceOption.SINGLE_LINE) {\n                     builder.append(\"\\n\");\n                 }\n                 ignoreStar \u003d true;\n                 token \u003d next();\n                 continue;\n+            case ANNOTATION:\n+            case EOC:\n+            case EOF:\n+                if (!(option \u003d\u003d WhitespaceOption.PRESERVE \u0026\u0026 token \u003d\u003d JsDocToken.ANNOTATION)) {\n+                    String multilineText \u003d builder.toString();\n+                    if (option !\u003d WhitespaceOption.PRESERVE) {\n+                        multilineText \u003d multilineText.trim();\n+                    }\n+                    int endLineno \u003d stream.getLineno();\n+                    int endCharno \u003d stream.getCharno();\n+                    if (multilineText.length() \u003e 0) {\n+                        jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n+                    }\n+                    return new ExtractionInfo(multilineText, token);\n+                }\n             default:\n                 ignoreStar \u003d false;\n                 state \u003d State.SEARCHING_ANNOTATION;\n                 if (builder.length() \u003e 0) {\n                     builder.append(\u0027 \u0027);\n                 }\n                 builder.append(toString(token));\n                 line \u003d stream.getRemainingJSDocLine();\n                 if (option !\u003d WhitespaceOption.PRESERVE) {\n                     line \u003d trimEnd(line);\n                 }\n                 builder.append(line);\n                 token \u003d next();\n         }\n     } while (true);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "",
            "newValue": "@SuppressWarnings(\"fallthrough\")"
          }
        }
      ]
    },
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": {
      "type": "Yintroduced",
      "commitMessage": "Initial commit.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/3/09, 3:51 PM",
      "commitName": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "diff": "@@ -0,0 +1,63 @@\n+private ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {\n+    if (token \u003d\u003d JsDocToken.EOC || token \u003d\u003d JsDocToken.EOL || token \u003d\u003d JsDocToken.EOF) {\n+        return new ExtractionInfo(\"\", token);\n+    }\n+    stream.update();\n+    int startLineno \u003d stream.getLineno();\n+    int startCharno \u003d stream.getCharno() + 1;\n+    String line \u003d stream.getRemainingJSDocLine();\n+    if (option !\u003d WhitespaceOption.PRESERVE) {\n+        line \u003d line.trim();\n+    }\n+    StringBuilder builder \u003d new StringBuilder();\n+    builder.append(line);\n+    state \u003d State.SEARCHING_ANNOTATION;\n+    token \u003d next();\n+    boolean ignoreStar \u003d false;\n+    do {\n+        switch(token) {\n+            case ANNOTATION:\n+            case EOC:\n+            case EOF:\n+                String multilineText \u003d builder.toString();\n+                if (option !\u003d WhitespaceOption.PRESERVE) {\n+                    multilineText \u003d multilineText.trim();\n+                }\n+                int endLineno \u003d stream.getLineno();\n+                int endCharno \u003d stream.getCharno();\n+                if (multilineText.length() \u003e 0) {\n+                    jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n+                }\n+                return new ExtractionInfo(multilineText, token);\n+            case STAR:\n+                if (!ignoreStar) {\n+                    if (builder.length() \u003e 0) {\n+                        builder.append(\u0027 \u0027);\n+                    }\n+                    builder.append(\u0027*\u0027);\n+                }\n+                token \u003d next();\n+                continue;\n+            case EOL:\n+                if (option !\u003d WhitespaceOption.SINGLE_LINE) {\n+                    builder.append(\"\\n\");\n+                }\n+                ignoreStar \u003d true;\n+                token \u003d next();\n+                continue;\n+            default:\n+                ignoreStar \u003d false;\n+                state \u003d State.SEARCHING_ANNOTATION;\n+                if (builder.length() \u003e 0) {\n+                    builder.append(\u0027 \u0027);\n+                }\n+                builder.append(toString(token));\n+                line \u003d stream.getRemainingJSDocLine();\n+                if (option !\u003d WhitespaceOption.PRESERVE) {\n+                    line \u003d trimEnd(line);\n+                }\n+                builder.append(line);\n+                token \u003d next();\n+        }\n+    } while (true);\n+}\n\\ No newline at end of file\n",
      "actualSource": "private ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {\n    if (token \u003d\u003d JsDocToken.EOC || token \u003d\u003d JsDocToken.EOL || token \u003d\u003d JsDocToken.EOF) {\n        return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineno \u003d stream.getLineno();\n    int startCharno \u003d stream.getCharno() + 1;\n    String line \u003d stream.getRemainingJSDocLine();\n    if (option !\u003d WhitespaceOption.PRESERVE) {\n        line \u003d line.trim();\n    }\n    StringBuilder builder \u003d new StringBuilder();\n    builder.append(line);\n    state \u003d State.SEARCHING_ANNOTATION;\n    token \u003d next();\n    boolean ignoreStar \u003d false;\n    do {\n        switch(token) {\n            case ANNOTATION:\n            case EOC:\n            case EOF:\n                String multilineText \u003d builder.toString();\n                if (option !\u003d WhitespaceOption.PRESERVE) {\n                    multilineText \u003d multilineText.trim();\n                }\n                int endLineno \u003d stream.getLineno();\n                int endCharno \u003d stream.getCharno();\n                if (multilineText.length() \u003e 0) {\n                    jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                }\n                return new ExtractionInfo(multilineText, token);\n            case STAR:\n                if (!ignoreStar) {\n                    if (builder.length() \u003e 0) {\n                        builder.append(\u0027 \u0027);\n                    }\n                    builder.append(\u0027*\u0027);\n                }\n                token \u003d next();\n                continue;\n            case EOL:\n                if (option !\u003d WhitespaceOption.SINGLE_LINE) {\n                    builder.append(\"\\n\");\n                }\n                ignoreStar \u003d true;\n                token \u003d next();\n                continue;\n            default:\n                ignoreStar \u003d false;\n                state \u003d State.SEARCHING_ANNOTATION;\n                if (builder.length() \u003e 0) {\n                    builder.append(\u0027 \u0027);\n                }\n                builder.append(toString(token));\n                line \u003d stream.getRemainingJSDocLine();\n                if (option !\u003d WhitespaceOption.PRESERVE) {\n                    line \u003d trimEnd(line);\n                }\n                builder.append(line);\n                token \u003d next();\n        }\n    } while (true);\n}",
      "path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
      "functionStartLine": 1164,
      "functionName": "extractMultilineTextualBlock",
      "functionAnnotation": "",
      "functionDoc": "Extracts the text found on the current line and all subsequent\nuntil either an annotation, end of comment or end of file is reached.\nNote that if this method detects an end of line as the first token, it\nwill quit immediately (indicating that there is no text where it was\nexpected).  Note that token \u003d info.token; should be called after this\nmethod is used to update the token properly in the parser.\n\n@param token The start token.\n@param option How to handle whitespace.\n@return The extraction information.\n"
    }
  }
}