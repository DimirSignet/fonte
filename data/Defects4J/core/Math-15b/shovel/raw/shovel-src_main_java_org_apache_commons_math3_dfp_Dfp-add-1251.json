{
  "origin": "codeshovel",
  "repositoryName": "Math-15b",
  "repositoryPath": "/tmp/Math-15b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "Dfp.java",
  "functionName": "add",
  "functionId": "add___x-Dfp(modifiers-final)",
  "sourceFilePath": "src/main/java/org/apache/commons/math3/dfp/Dfp.java",
  "functionAnnotation": "",
  "functionDoc": "Add x to this.\n\n@param x number to add\n@return sum of this and x\n",
  "functionStartLine": 1251,
  "functionEndLine": 1394,
  "numCommitsSeen": 13,
  "timeTaken": 12484,
  "changeHistory": [
    "2d698e4905cb75bd125e2fe1f5223d7e68f0adcd",
    "1eb0c0d7421823470de3a901643ae3be2c9e0a8e"
  ],
  "changeHistoryShort": {
    "2d698e4905cb75bd125e2fe1f5223d7e68f0adcd": "Ymovefromfile",
    "1eb0c0d7421823470de3a901643ae3be2c9e0a8e": "Yintroduced"
  },
  "changeHistoryDetails": {
    "2d698e4905cb75bd125e2fe1f5223d7e68f0adcd": {
      "type": "Ymovefromfile",
      "commitMessage": "MATH-444\nBase package name change: \"o.a.c.math\" -\u003e \"o.a.c.math3\"\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@1244107 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2/14/12, 8:17 AM",
      "commitName": "2d698e4905cb75bd125e2fe1f5223d7e68f0adcd",
      "commitAuthor": "Gilles Sadowski",
      "commitDateOld": "2/14/12, 6:34 AM",
      "commitNameOld": "53257329dd394be1333b38bae787bf0cf19dc900",
      "commitAuthorOld": "Gilles Sadowski",
      "daysBetweenCommits": 0.07,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public Dfp add(final Dfp x) {\n    if (field.getRadixDigits() !\u003d x.field.getRadixDigits()) {\n        field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n        final Dfp result \u003d newInstance(getZero());\n        result.nans \u003d QNAN;\n        return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n    }\n    if (nans !\u003d FINITE || x.nans !\u003d FINITE) {\n        if (isNaN()) {\n            return this;\n        }\n        if (x.isNaN()) {\n            return x;\n        }\n        if (nans \u003d\u003d INFINITE \u0026\u0026 x.nans \u003d\u003d FINITE) {\n            return this;\n        }\n        if (x.nans \u003d\u003d INFINITE \u0026\u0026 nans \u003d\u003d FINITE) {\n            return x;\n        }\n        if (x.nans \u003d\u003d INFINITE \u0026\u0026 nans \u003d\u003d INFINITE \u0026\u0026 sign \u003d\u003d x.sign) {\n            return x;\n        }\n        if (x.nans \u003d\u003d INFINITE \u0026\u0026 nans \u003d\u003d INFINITE \u0026\u0026 sign !\u003d x.sign) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            Dfp result \u003d newInstance(getZero());\n            result.nans \u003d QNAN;\n            result \u003d dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n            return result;\n        }\n    }\n    Dfp a \u003d newInstance(this);\n    Dfp b \u003d newInstance(x);\n    Dfp result \u003d newInstance(getZero());\n    final byte asign \u003d a.sign;\n    final byte bsign \u003d b.sign;\n    a.sign \u003d 1;\n    b.sign \u003d 1;\n    byte rsign \u003d bsign;\n    if (compare(a, b) \u003e 0) {\n        rsign \u003d asign;\n    }\n    if (b.mant[mant.length - 1] \u003d\u003d 0) {\n        b.exp \u003d a.exp;\n    }\n    if (a.mant[mant.length - 1] \u003d\u003d 0) {\n        a.exp \u003d b.exp;\n    }\n    int aextradigit \u003d 0;\n    int bextradigit \u003d 0;\n    if (a.exp \u003c b.exp) {\n        aextradigit \u003d a.align(b.exp);\n    } else {\n        bextradigit \u003d b.align(a.exp);\n    }\n    if (asign !\u003d bsign) {\n        if (asign \u003d\u003d rsign) {\n            bextradigit \u003d b.complement(bextradigit);\n        } else {\n            aextradigit \u003d a.complement(aextradigit);\n        }\n    }\n    int rh \u003d 0;\n    for (int i \u003d 0; i \u003c mant.length; i++) {\n        final int r \u003d a.mant[i] + b.mant[i] + rh;\n        rh \u003d r / RADIX;\n        result.mant[i] \u003d r - rh * RADIX;\n    }\n    result.exp \u003d a.exp;\n    result.sign \u003d rsign;\n    if (rh !\u003d 0 \u0026\u0026 (asign \u003d\u003d bsign)) {\n        final int lostdigit \u003d result.mant[0];\n        result.shiftRight();\n        result.mant[mant.length - 1] \u003d rh;\n        final int excp \u003d result.round(lostdigit);\n        if (excp !\u003d 0) {\n            result \u003d dotrap(excp, ADD_TRAP, x, result);\n        }\n    }\n    for (int i \u003d 0; i \u003c mant.length; i++) {\n        if (result.mant[mant.length - 1] !\u003d 0) {\n            break;\n        }\n        result.shiftLeft();\n        if (i \u003d\u003d 0) {\n            result.mant[0] \u003d aextradigit + bextradigit;\n            aextradigit \u003d 0;\n            bextradigit \u003d 0;\n        }\n    }\n    if (result.mant[mant.length - 1] \u003d\u003d 0) {\n        result.exp \u003d 0;\n        if (asign !\u003d bsign) {\n            result.sign \u003d 1;\n        }\n    }\n    final int excp \u003d result.round(aextradigit + bextradigit);\n    if (excp !\u003d 0) {\n        result \u003d dotrap(excp, ADD_TRAP, x, result);\n    }\n    return result;\n}",
      "path": "src/main/java/org/apache/commons/math3/dfp/Dfp.java",
      "functionStartLine": 1251,
      "functionName": "add",
      "functionAnnotation": "",
      "functionDoc": "Add x to this.\n\n@param x number to add\n@return sum of this and x\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/main/java/org/apache/commons/math/dfp/Dfp.java",
        "newPath": "src/main/java/org/apache/commons/math3/dfp/Dfp.java",
        "oldMethodName": "add",
        "newMethodName": "add"
      }
    },
    "1eb0c0d7421823470de3a901643ae3be2c9e0a8e": {
      "type": "Yintroduced",
      "commitMessage": "added the dfp library\nThe Dfp class represent the high precision numbers, it implements our existing Field interface and hence each instance is associated with a DfpField that provides the constants at the required precision as well as factory methods. This allowed to remove the compile-time constraint in the library. Users can even use at the same time a field for 20 decimals digits precision and another field for 100 digits precision. Dfp instances with different precision CANNOT be mixed in the same computation (doing so creates a NaN). A few utility methods have been added, like constructors from integral types, isInfinite and isNaN methods, equal has been renames to equals and its signature changed to match the general Object method (a hashcode method has been added too).\nJIRA: MATH-412\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@992697 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "9/4/10, 3:59 PM",
      "commitName": "1eb0c0d7421823470de3a901643ae3be2c9e0a8e",
      "commitAuthor": "Luc Maisonobe",
      "diff": "@@ -0,0 +1,102 @@\n+public Dfp add(final Dfp x) {\n+    if (field.getRadixDigits() !\u003d x.field.getRadixDigits()) {\n+        field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n+        final Dfp result \u003d newInstance(getZero());\n+        result.nans \u003d QNAN;\n+        return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n+    }\n+    if (nans !\u003d FINITE || x.nans !\u003d FINITE) {\n+        if (isNaN()) {\n+            return this;\n+        }\n+        if (x.isNaN()) {\n+            return x;\n+        }\n+        if (nans \u003d\u003d INFINITE \u0026\u0026 x.nans \u003d\u003d FINITE) {\n+            return this;\n+        }\n+        if (x.nans \u003d\u003d INFINITE \u0026\u0026 nans \u003d\u003d FINITE) {\n+            return x;\n+        }\n+        if (x.nans \u003d\u003d INFINITE \u0026\u0026 nans \u003d\u003d INFINITE \u0026\u0026 sign \u003d\u003d x.sign) {\n+            return x;\n+        }\n+        if (x.nans \u003d\u003d INFINITE \u0026\u0026 nans \u003d\u003d INFINITE \u0026\u0026 sign !\u003d x.sign) {\n+            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n+            Dfp result \u003d newInstance(getZero());\n+            result.nans \u003d QNAN;\n+            result \u003d dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n+            return result;\n+        }\n+    }\n+    Dfp a \u003d newInstance(this);\n+    Dfp b \u003d newInstance(x);\n+    Dfp result \u003d newInstance(getZero());\n+    final byte asign \u003d a.sign;\n+    final byte bsign \u003d b.sign;\n+    a.sign \u003d 1;\n+    b.sign \u003d 1;\n+    byte rsign \u003d bsign;\n+    if (compare(a, b) \u003e 0) {\n+        rsign \u003d asign;\n+    }\n+    if (b.mant[mant.length - 1] \u003d\u003d 0) {\n+        b.exp \u003d a.exp;\n+    }\n+    if (a.mant[mant.length - 1] \u003d\u003d 0) {\n+        a.exp \u003d b.exp;\n+    }\n+    int aextradigit \u003d 0;\n+    int bextradigit \u003d 0;\n+    if (a.exp \u003c b.exp) {\n+        aextradigit \u003d a.align(b.exp);\n+    } else {\n+        bextradigit \u003d b.align(a.exp);\n+    }\n+    if (asign !\u003d bsign) {\n+        if (asign \u003d\u003d rsign) {\n+            bextradigit \u003d b.complement(bextradigit);\n+        } else {\n+            aextradigit \u003d a.complement(aextradigit);\n+        }\n+    }\n+    int rh \u003d 0;\n+    for (int i \u003d 0; i \u003c mant.length; i++) {\n+        final int r \u003d a.mant[i] + b.mant[i] + rh;\n+        rh \u003d r / RADIX;\n+        result.mant[i] \u003d r - rh * RADIX;\n+    }\n+    result.exp \u003d a.exp;\n+    result.sign \u003d rsign;\n+    if (rh !\u003d 0 \u0026\u0026 (asign \u003d\u003d bsign)) {\n+        final int lostdigit \u003d result.mant[0];\n+        result.shiftRight();\n+        result.mant[mant.length - 1] \u003d rh;\n+        final int excp \u003d result.round(lostdigit);\n+        if (excp !\u003d 0) {\n+            result \u003d dotrap(excp, ADD_TRAP, x, result);\n+        }\n+    }\n+    for (int i \u003d 0; i \u003c mant.length; i++) {\n+        if (result.mant[mant.length - 1] !\u003d 0) {\n+            break;\n+        }\n+        result.shiftLeft();\n+        if (i \u003d\u003d 0) {\n+            result.mant[0] \u003d aextradigit + bextradigit;\n+            aextradigit \u003d 0;\n+            bextradigit \u003d 0;\n+        }\n+    }\n+    if (result.mant[mant.length - 1] \u003d\u003d 0) {\n+        result.exp \u003d 0;\n+        if (asign !\u003d bsign) {\n+            result.sign \u003d 1;\n+        }\n+    }\n+    final int excp \u003d result.round(aextradigit + bextradigit);\n+    if (excp !\u003d 0) {\n+        result \u003d dotrap(excp, ADD_TRAP, x, result);\n+    }\n+    return result;\n+}\n\\ No newline at end of file\n",
      "actualSource": "public Dfp add(final Dfp x) {\n    if (field.getRadixDigits() !\u003d x.field.getRadixDigits()) {\n        field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n        final Dfp result \u003d newInstance(getZero());\n        result.nans \u003d QNAN;\n        return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n    }\n    if (nans !\u003d FINITE || x.nans !\u003d FINITE) {\n        if (isNaN()) {\n            return this;\n        }\n        if (x.isNaN()) {\n            return x;\n        }\n        if (nans \u003d\u003d INFINITE \u0026\u0026 x.nans \u003d\u003d FINITE) {\n            return this;\n        }\n        if (x.nans \u003d\u003d INFINITE \u0026\u0026 nans \u003d\u003d FINITE) {\n            return x;\n        }\n        if (x.nans \u003d\u003d INFINITE \u0026\u0026 nans \u003d\u003d INFINITE \u0026\u0026 sign \u003d\u003d x.sign) {\n            return x;\n        }\n        if (x.nans \u003d\u003d INFINITE \u0026\u0026 nans \u003d\u003d INFINITE \u0026\u0026 sign !\u003d x.sign) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            Dfp result \u003d newInstance(getZero());\n            result.nans \u003d QNAN;\n            result \u003d dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n            return result;\n        }\n    }\n    Dfp a \u003d newInstance(this);\n    Dfp b \u003d newInstance(x);\n    Dfp result \u003d newInstance(getZero());\n    final byte asign \u003d a.sign;\n    final byte bsign \u003d b.sign;\n    a.sign \u003d 1;\n    b.sign \u003d 1;\n    byte rsign \u003d bsign;\n    if (compare(a, b) \u003e 0) {\n        rsign \u003d asign;\n    }\n    if (b.mant[mant.length - 1] \u003d\u003d 0) {\n        b.exp \u003d a.exp;\n    }\n    if (a.mant[mant.length - 1] \u003d\u003d 0) {\n        a.exp \u003d b.exp;\n    }\n    int aextradigit \u003d 0;\n    int bextradigit \u003d 0;\n    if (a.exp \u003c b.exp) {\n        aextradigit \u003d a.align(b.exp);\n    } else {\n        bextradigit \u003d b.align(a.exp);\n    }\n    if (asign !\u003d bsign) {\n        if (asign \u003d\u003d rsign) {\n            bextradigit \u003d b.complement(bextradigit);\n        } else {\n            aextradigit \u003d a.complement(aextradigit);\n        }\n    }\n    int rh \u003d 0;\n    for (int i \u003d 0; i \u003c mant.length; i++) {\n        final int r \u003d a.mant[i] + b.mant[i] + rh;\n        rh \u003d r / RADIX;\n        result.mant[i] \u003d r - rh * RADIX;\n    }\n    result.exp \u003d a.exp;\n    result.sign \u003d rsign;\n    if (rh !\u003d 0 \u0026\u0026 (asign \u003d\u003d bsign)) {\n        final int lostdigit \u003d result.mant[0];\n        result.shiftRight();\n        result.mant[mant.length - 1] \u003d rh;\n        final int excp \u003d result.round(lostdigit);\n        if (excp !\u003d 0) {\n            result \u003d dotrap(excp, ADD_TRAP, x, result);\n        }\n    }\n    for (int i \u003d 0; i \u003c mant.length; i++) {\n        if (result.mant[mant.length - 1] !\u003d 0) {\n            break;\n        }\n        result.shiftLeft();\n        if (i \u003d\u003d 0) {\n            result.mant[0] \u003d aextradigit + bextradigit;\n            aextradigit \u003d 0;\n            bextradigit \u003d 0;\n        }\n    }\n    if (result.mant[mant.length - 1] \u003d\u003d 0) {\n        result.exp \u003d 0;\n        if (asign !\u003d bsign) {\n            result.sign \u003d 1;\n        }\n    }\n    final int excp \u003d result.round(aextradigit + bextradigit);\n    if (excp !\u003d 0) {\n        result \u003d dotrap(excp, ADD_TRAP, x, result);\n    }\n    return result;\n}",
      "path": "src/main/java/org/apache/commons/math/dfp/Dfp.java",
      "functionStartLine": 1164,
      "functionName": "add",
      "functionAnnotation": "",
      "functionDoc": "Add x to this.\n\n@param x number to add\n@return sum of this and x\n"
    }
  }
}