{
  "origin": "codeshovel",
  "repositoryName": "Math-48b",
  "repositoryPath": "/tmp/Math-48b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "BaseSecantSolver.java",
  "functionName": "doSolve",
  "functionId": "doSolve",
  "sourceFilePath": "src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java",
  "functionAnnotation": "",
  "functionDoc": "@inheritDoc}\n",
  "functionStartLine": 128,
  "functionEndLine": 249,
  "numCommitsSeen": 83,
  "timeTaken": 3308,
  "changeHistory": [
    "39cf5e69259d7560d50553caf028f9229b721013",
    "2f066a5b2d2fe8a00a251a3220b0d52446fe392d",
    "0d7fa0fd61810e6c4fba2839c4101f9c5cf62c25",
    "c8bb7cc4bbf53334f9b803cdcd4c3af6390320a1",
    "cfcd4cf992702e25c9b15e5a2ebb7fc8bec010f4",
    "3bd4ebcb79a6bb6df36ba3fcf23ae55d68c45ddf",
    "6a23f66ae368949d1a0764cdcd8aad9668bda0c3",
    "ed5fdf67a31518149a74e05db23371056af10842",
    "74ff198bd249a56d1349b963bd265f8899743b9b",
    "8302dd02498495277ec0db9301edb2158bb0e314",
    "80b1e90b42a34856b61cec628fcea6633d1000cd",
    "1eaea0b549f685bd416cef68faa3a137b9bb3519",
    "26dac5a0e7fc9c6be9571b3e71a15d8502480d96",
    "d6a438e931412713e99624cf9ed74470f1040184",
    "95d2cf0a090068a561701ae57a0e17436ec8c284",
    "1d1436557bcb21887d9b352dd0f5f3d3acb71e11",
    "583dffc0ee383e9b5e1e08c574de10db8270fdb7",
    "d2d4c5fd63f279be0797468277593ef72506c696",
    "4f1e69b5313761cb95909359a408d13e6aa29635",
    "6a978ea29f680a87dfc380c760adf2e17b2e7c9c",
    "5cb403cbbcb292481c680728298cb87c46663914",
    "0a904461932f2c0455611e77ec6a8d8aced2980b"
  ],
  "changeHistoryShort": {
    "39cf5e69259d7560d50553caf028f9229b721013": "Ybodychange",
    "2f066a5b2d2fe8a00a251a3220b0d52446fe392d": "Ybodychange",
    "0d7fa0fd61810e6c4fba2839c4101f9c5cf62c25": "Ybodychange",
    "c8bb7cc4bbf53334f9b803cdcd4c3af6390320a1": "Ymultichange(Ybodychange,Yannotationchange)",
    "cfcd4cf992702e25c9b15e5a2ebb7fc8bec010f4": "Ybodychange",
    "3bd4ebcb79a6bb6df36ba3fcf23ae55d68c45ddf": "Ybodychange",
    "6a23f66ae368949d1a0764cdcd8aad9668bda0c3": "Yfilerename",
    "ed5fdf67a31518149a74e05db23371056af10842": "Ymultichange(Ymovefromfile,Ymodifierchange,Ybodychange)",
    "74ff198bd249a56d1349b963bd265f8899743b9b": "Ymultichange(Yrename,Yparameterchange,Ymodifierchange,Yexceptionschange,Ybodychange,Yannotationchange,Ydocchange)",
    "8302dd02498495277ec0db9301edb2158bb0e314": "Ymultichange(Yexceptionschange,Ydocchange)",
    "80b1e90b42a34856b61cec628fcea6633d1000cd": "Ybodychange",
    "1eaea0b549f685bd416cef68faa3a137b9bb3519": "Ybodychange",
    "26dac5a0e7fc9c6be9571b3e71a15d8502480d96": "Yformatchange",
    "d6a438e931412713e99624cf9ed74470f1040184": "Yfilerename",
    "95d2cf0a090068a561701ae57a0e17436ec8c284": "Ybodychange",
    "1d1436557bcb21887d9b352dd0f5f3d3acb71e11": "Yfilerename",
    "583dffc0ee383e9b5e1e08c574de10db8270fdb7": "Ymultichange(Yparameterchange,Yparametermetachange,Ydocchange)",
    "d2d4c5fd63f279be0797468277593ef72506c696": "Ymultichange(Yexceptionschange,Ybodychange,Ydocchange)",
    "4f1e69b5313761cb95909359a408d13e6aa29635": "Ybodychange",
    "6a978ea29f680a87dfc380c760adf2e17b2e7c9c": "Ymultichange(Yexceptionschange,Ybodychange,Ydocchange)",
    "5cb403cbbcb292481c680728298cb87c46663914": "Ydocchange",
    "0a904461932f2c0455611e77ec6a8d8aced2980b": "Yintroduced"
  },
  "changeHistoryDetails": {
    "39cf5e69259d7560d50553caf028f9229b721013": {
      "type": "Ybodychange",
      "commitMessage": "MATH-631\nReverted to original behaviour.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@1157185 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "8/12/11, 9:48 AM",
      "commitName": "39cf5e69259d7560d50553caf028f9229b721013",
      "commitAuthor": "Gilles Sadowski",
      "commitDateOld": "8/6/11, 3:26 PM",
      "commitNameOld": "2f066a5b2d2fe8a00a251a3220b0d52446fe392d",
      "commitAuthorOld": "Gilles Sadowski",
      "daysBetweenCommits": 5.76,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "actualSource": "protected final double doSolve() {\n    double x0 \u003d getMin();\n    double x1 \u003d getMax();\n    double f0 \u003d computeObjectiveValue(x0);\n    double f1 \u003d computeObjectiveValue(x1);\n    if (f0 \u003d\u003d 0.0) {\n        return x0;\n    }\n    if (f1 \u003d\u003d 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol \u003d getFunctionValueAccuracy();\n    final double atol \u003d getAbsoluteAccuracy();\n    final double rtol \u003d getRelativeAccuracy();\n    boolean inverted \u003d false;\n    while (true) {\n        final double x \u003d x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx \u003d computeObjectiveValue(x);\n        if (fx \u003d\u003d 0.0) {\n            return x;\n        }\n        if (f1 * fx \u003c 0) {\n            x0 \u003d x1;\n            f0 \u003d f1;\n            inverted \u003d !inverted;\n        } else {\n            switch(method) {\n                case ILLINOIS:\n                    f0 *\u003d 0.5;\n                    break;\n                case PEGASUS:\n                    f0 *\u003d f1 / (f1 + fx);\n                    break;\n                case REGULA_FALSI:\n                    break;\n                default:\n                    throw new MathInternalError();\n            }\n        }\n        x1 \u003d x;\n        f1 \u003d fx;\n        if (FastMath.abs(f1) \u003c\u003d ftol) {\n            switch(allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    if (inverted) {\n                        return x1;\n                    }\n                    break;\n                case RIGHT_SIDE:\n                    if (!inverted) {\n                        return x1;\n                    }\n                    break;\n                case BELOW_SIDE:\n                    if (f1 \u003c\u003d 0) {\n                        return x1;\n                    }\n                    break;\n                case ABOVE_SIDE:\n                    if (f1 \u003e\u003d 0) {\n                        return x1;\n                    }\n                    break;\n                default:\n                    throw new MathInternalError();\n            }\n        }\n        if (FastMath.abs(x1 - x0) \u003c FastMath.max(rtol * FastMath.abs(x1), atol)) {\n            switch(allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    return inverted ? x1 : x0;\n                case RIGHT_SIDE:\n                    return inverted ? x0 : x1;\n                case BELOW_SIDE:\n                    return (f1 \u003c\u003d 0) ? x1 : x0;\n                case ABOVE_SIDE:\n                    return (f1 \u003e\u003d 0) ? x1 : x0;\n                default:\n                    throw new MathInternalError();\n            }\n        }\n    }\n}",
      "path": "src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java",
      "functionStartLine": 128,
      "functionName": "doSolve",
      "functionAnnotation": "",
      "functionDoc": "@inheritDoc}\n",
      "diff": "@@ -1,93 +1,88 @@\n protected final double doSolve() {\n     double x0 \u003d getMin();\n     double x1 \u003d getMax();\n     double f0 \u003d computeObjectiveValue(x0);\n     double f1 \u003d computeObjectiveValue(x1);\n     if (f0 \u003d\u003d 0.0) {\n         return x0;\n     }\n     if (f1 \u003d\u003d 0.0) {\n         return x1;\n     }\n     verifyBracketing(x0, x1);\n     final double ftol \u003d getFunctionValueAccuracy();\n     final double atol \u003d getAbsoluteAccuracy();\n     final double rtol \u003d getRelativeAccuracy();\n     boolean inverted \u003d false;\n     while (true) {\n         final double x \u003d x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n         final double fx \u003d computeObjectiveValue(x);\n         if (fx \u003d\u003d 0.0) {\n             return x;\n         }\n         if (f1 * fx \u003c 0) {\n             x0 \u003d x1;\n             f0 \u003d f1;\n             inverted \u003d !inverted;\n         } else {\n             switch(method) {\n                 case ILLINOIS:\n                     f0 *\u003d 0.5;\n                     break;\n                 case PEGASUS:\n                     f0 *\u003d f1 / (f1 + fx);\n                     break;\n                 case REGULA_FALSI:\n-                    if (x \u003d\u003d x1) {\n-                        final double delta \u003d FastMath.max(rtol * FastMath.abs(x1), atol);\n-                        x0 \u003d 0.5 * (x0 + x1 - delta);\n-                        f0 \u003d computeObjectiveValue(x0);\n-                    }\n                     break;\n                 default:\n                     throw new MathInternalError();\n             }\n         }\n         x1 \u003d x;\n         f1 \u003d fx;\n         if (FastMath.abs(f1) \u003c\u003d ftol) {\n             switch(allowed) {\n                 case ANY_SIDE:\n                     return x1;\n                 case LEFT_SIDE:\n                     if (inverted) {\n                         return x1;\n                     }\n                     break;\n                 case RIGHT_SIDE:\n                     if (!inverted) {\n                         return x1;\n                     }\n                     break;\n                 case BELOW_SIDE:\n                     if (f1 \u003c\u003d 0) {\n                         return x1;\n                     }\n                     break;\n                 case ABOVE_SIDE:\n                     if (f1 \u003e\u003d 0) {\n                         return x1;\n                     }\n                     break;\n                 default:\n                     throw new MathInternalError();\n             }\n         }\n         if (FastMath.abs(x1 - x0) \u003c FastMath.max(rtol * FastMath.abs(x1), atol)) {\n             switch(allowed) {\n                 case ANY_SIDE:\n                     return x1;\n                 case LEFT_SIDE:\n                     return inverted ? x1 : x0;\n                 case RIGHT_SIDE:\n                     return inverted ? x0 : x1;\n                 case BELOW_SIDE:\n                     return (f1 \u003c\u003d 0) ? x1 : x0;\n                 case ABOVE_SIDE:\n                     return (f1 \u003e\u003d 0) ? x1 : x0;\n                 default:\n                     throw new MathInternalError();\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2f066a5b2d2fe8a00a251a3220b0d52446fe392d": {
      "type": "Ybodychange",
      "commitMessage": "MATH-631\nWork around infinite loop.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@1154614 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "8/6/11, 3:26 PM",
      "commitName": "2f066a5b2d2fe8a00a251a3220b0d52446fe392d",
      "commitAuthor": "Gilles Sadowski",
      "commitDateOld": "7/31/11, 2:27 PM",
      "commitNameOld": "5a3c5f2f87367f3bf9a2a1e0b8a1926c11f174e0",
      "commitAuthorOld": "Gilles Sadowski",
      "daysBetweenCommits": 6.04,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "actualSource": "protected final double doSolve() {\n    double x0 \u003d getMin();\n    double x1 \u003d getMax();\n    double f0 \u003d computeObjectiveValue(x0);\n    double f1 \u003d computeObjectiveValue(x1);\n    if (f0 \u003d\u003d 0.0) {\n        return x0;\n    }\n    if (f1 \u003d\u003d 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol \u003d getFunctionValueAccuracy();\n    final double atol \u003d getAbsoluteAccuracy();\n    final double rtol \u003d getRelativeAccuracy();\n    boolean inverted \u003d false;\n    while (true) {\n        final double x \u003d x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx \u003d computeObjectiveValue(x);\n        if (fx \u003d\u003d 0.0) {\n            return x;\n        }\n        if (f1 * fx \u003c 0) {\n            x0 \u003d x1;\n            f0 \u003d f1;\n            inverted \u003d !inverted;\n        } else {\n            switch(method) {\n                case ILLINOIS:\n                    f0 *\u003d 0.5;\n                    break;\n                case PEGASUS:\n                    f0 *\u003d f1 / (f1 + fx);\n                    break;\n                case REGULA_FALSI:\n                    if (x \u003d\u003d x1) {\n                        final double delta \u003d FastMath.max(rtol * FastMath.abs(x1), atol);\n                        x0 \u003d 0.5 * (x0 + x1 - delta);\n                        f0 \u003d computeObjectiveValue(x0);\n                    }\n                    break;\n                default:\n                    throw new MathInternalError();\n            }\n        }\n        x1 \u003d x;\n        f1 \u003d fx;\n        if (FastMath.abs(f1) \u003c\u003d ftol) {\n            switch(allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    if (inverted) {\n                        return x1;\n                    }\n                    break;\n                case RIGHT_SIDE:\n                    if (!inverted) {\n                        return x1;\n                    }\n                    break;\n                case BELOW_SIDE:\n                    if (f1 \u003c\u003d 0) {\n                        return x1;\n                    }\n                    break;\n                case ABOVE_SIDE:\n                    if (f1 \u003e\u003d 0) {\n                        return x1;\n                    }\n                    break;\n                default:\n                    throw new MathInternalError();\n            }\n        }\n        if (FastMath.abs(x1 - x0) \u003c FastMath.max(rtol * FastMath.abs(x1), atol)) {\n            switch(allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    return inverted ? x1 : x0;\n                case RIGHT_SIDE:\n                    return inverted ? x0 : x1;\n                case BELOW_SIDE:\n                    return (f1 \u003c\u003d 0) ? x1 : x0;\n                case ABOVE_SIDE:\n                    return (f1 \u003e\u003d 0) ? x1 : x0;\n                default:\n                    throw new MathInternalError();\n            }\n        }\n    }\n}",
      "path": "src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java",
      "functionStartLine": 128,
      "functionName": "doSolve",
      "functionAnnotation": "",
      "functionDoc": "@inheritDoc}\n",
      "diff": "@@ -1,84 +1,93 @@\n protected final double doSolve() {\n     double x0 \u003d getMin();\n     double x1 \u003d getMax();\n     double f0 \u003d computeObjectiveValue(x0);\n     double f1 \u003d computeObjectiveValue(x1);\n     if (f0 \u003d\u003d 0.0) {\n         return x0;\n     }\n     if (f1 \u003d\u003d 0.0) {\n         return x1;\n     }\n     verifyBracketing(x0, x1);\n     final double ftol \u003d getFunctionValueAccuracy();\n     final double atol \u003d getAbsoluteAccuracy();\n     final double rtol \u003d getRelativeAccuracy();\n     boolean inverted \u003d false;\n     while (true) {\n         final double x \u003d x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n         final double fx \u003d computeObjectiveValue(x);\n         if (fx \u003d\u003d 0.0) {\n             return x;\n         }\n         if (f1 * fx \u003c 0) {\n             x0 \u003d x1;\n             f0 \u003d f1;\n-            x1 \u003d x;\n-            f1 \u003d fx;\n             inverted \u003d !inverted;\n         } else {\n-            if (method \u003d\u003d Method.ILLINOIS) {\n-                f0 *\u003d 0.5;\n+            switch(method) {\n+                case ILLINOIS:\n+                    f0 *\u003d 0.5;\n+                    break;\n+                case PEGASUS:\n+                    f0 *\u003d f1 / (f1 + fx);\n+                    break;\n+                case REGULA_FALSI:\n+                    if (x \u003d\u003d x1) {\n+                        final double delta \u003d FastMath.max(rtol * FastMath.abs(x1), atol);\n+                        x0 \u003d 0.5 * (x0 + x1 - delta);\n+                        f0 \u003d computeObjectiveValue(x0);\n+                    }\n+                    break;\n+                default:\n+                    throw new MathInternalError();\n             }\n-            if (method \u003d\u003d Method.PEGASUS) {\n-                f0 *\u003d f1 / (f1 + fx);\n-            }\n-            x1 \u003d x;\n-            f1 \u003d fx;\n         }\n+        x1 \u003d x;\n+        f1 \u003d fx;\n         if (FastMath.abs(f1) \u003c\u003d ftol) {\n             switch(allowed) {\n                 case ANY_SIDE:\n                     return x1;\n                 case LEFT_SIDE:\n                     if (inverted) {\n                         return x1;\n                     }\n                     break;\n                 case RIGHT_SIDE:\n                     if (!inverted) {\n                         return x1;\n                     }\n                     break;\n                 case BELOW_SIDE:\n                     if (f1 \u003c\u003d 0) {\n                         return x1;\n                     }\n                     break;\n                 case ABOVE_SIDE:\n                     if (f1 \u003e\u003d 0) {\n                         return x1;\n                     }\n                     break;\n                 default:\n                     throw new MathInternalError();\n             }\n         }\n         if (FastMath.abs(x1 - x0) \u003c FastMath.max(rtol * FastMath.abs(x1), atol)) {\n             switch(allowed) {\n                 case ANY_SIDE:\n                     return x1;\n                 case LEFT_SIDE:\n                     return inverted ? x1 : x0;\n                 case RIGHT_SIDE:\n                     return inverted ? x0 : x1;\n                 case BELOW_SIDE:\n                     return (f1 \u003c\u003d 0) ? x1 : x0;\n                 case ABOVE_SIDE:\n                     return (f1 \u003e\u003d 0) ? x1 : x0;\n                 default:\n                     throw new MathInternalError();\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0d7fa0fd61810e6c4fba2839c4101f9c5cf62c25": {
      "type": "Ybodychange",
      "commitMessage": "fixed checkstyle warnings\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@1144838 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "7/10/11, 4:28 AM",
      "commitName": "0d7fa0fd61810e6c4fba2839c4101f9c5cf62c25",
      "commitAuthor": "Luc Maisonobe",
      "commitDateOld": "7/10/11, 4:07 AM",
      "commitNameOld": "c8bb7cc4bbf53334f9b803cdcd4c3af6390320a1",
      "commitAuthorOld": "Luc Maisonobe",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "protected final double doSolve() {\n    double x0 \u003d getMin();\n    double x1 \u003d getMax();\n    double f0 \u003d computeObjectiveValue(x0);\n    double f1 \u003d computeObjectiveValue(x1);\n    if (f0 \u003d\u003d 0.0) {\n        return x0;\n    }\n    if (f1 \u003d\u003d 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol \u003d getFunctionValueAccuracy();\n    final double atol \u003d getAbsoluteAccuracy();\n    final double rtol \u003d getRelativeAccuracy();\n    boolean inverted \u003d false;\n    while (true) {\n        final double x \u003d x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx \u003d computeObjectiveValue(x);\n        if (fx \u003d\u003d 0.0) {\n            return x;\n        }\n        if (f1 * fx \u003c 0) {\n            x0 \u003d x1;\n            f0 \u003d f1;\n            x1 \u003d x;\n            f1 \u003d fx;\n            inverted \u003d !inverted;\n        } else {\n            if (method \u003d\u003d Method.ILLINOIS) {\n                f0 *\u003d 0.5;\n            }\n            if (method \u003d\u003d Method.PEGASUS) {\n                f0 *\u003d f1 / (f1 + fx);\n            }\n            x1 \u003d x;\n            f1 \u003d fx;\n        }\n        if (FastMath.abs(f1) \u003c\u003d ftol) {\n            switch(allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    if (inverted) {\n                        return x1;\n                    }\n                    break;\n                case RIGHT_SIDE:\n                    if (!inverted) {\n                        return x1;\n                    }\n                    break;\n                case BELOW_SIDE:\n                    if (f1 \u003c\u003d 0) {\n                        return x1;\n                    }\n                    break;\n                case ABOVE_SIDE:\n                    if (f1 \u003e\u003d 0) {\n                        return x1;\n                    }\n                    break;\n                default:\n                    throw new MathInternalError();\n            }\n        }\n        if (FastMath.abs(x1 - x0) \u003c FastMath.max(rtol * FastMath.abs(x1), atol)) {\n            switch(allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    return inverted ? x1 : x0;\n                case RIGHT_SIDE:\n                    return inverted ? x0 : x1;\n                case BELOW_SIDE:\n                    return (f1 \u003c\u003d 0) ? x1 : x0;\n                case ABOVE_SIDE:\n                    return (f1 \u003e\u003d 0) ? x1 : x0;\n                default:\n                    throw new MathInternalError();\n            }\n        }\n    }\n}",
      "path": "src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java",
      "functionStartLine": 111,
      "functionName": "doSolve",
      "functionAnnotation": "",
      "functionDoc": "@inheritDoc}\n",
      "diff": "@@ -1,84 +1,84 @@\n protected final double doSolve() {\n     double x0 \u003d getMin();\n     double x1 \u003d getMax();\n     double f0 \u003d computeObjectiveValue(x0);\n     double f1 \u003d computeObjectiveValue(x1);\n     if (f0 \u003d\u003d 0.0) {\n         return x0;\n     }\n     if (f1 \u003d\u003d 0.0) {\n         return x1;\n     }\n     verifyBracketing(x0, x1);\n     final double ftol \u003d getFunctionValueAccuracy();\n     final double atol \u003d getAbsoluteAccuracy();\n     final double rtol \u003d getRelativeAccuracy();\n     boolean inverted \u003d false;\n     while (true) {\n         final double x \u003d x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n         final double fx \u003d computeObjectiveValue(x);\n         if (fx \u003d\u003d 0.0) {\n             return x;\n         }\n         if (f1 * fx \u003c 0) {\n             x0 \u003d x1;\n             f0 \u003d f1;\n             x1 \u003d x;\n             f1 \u003d fx;\n             inverted \u003d !inverted;\n         } else {\n             if (method \u003d\u003d Method.ILLINOIS) {\n                 f0 *\u003d 0.5;\n             }\n             if (method \u003d\u003d Method.PEGASUS) {\n                 f0 *\u003d f1 / (f1 + fx);\n             }\n             x1 \u003d x;\n             f1 \u003d fx;\n         }\n         if (FastMath.abs(f1) \u003c\u003d ftol) {\n-            switch(allowedSolutions) {\n+            switch(allowed) {\n                 case ANY_SIDE:\n                     return x1;\n                 case LEFT_SIDE:\n                     if (inverted) {\n                         return x1;\n                     }\n                     break;\n                 case RIGHT_SIDE:\n                     if (!inverted) {\n                         return x1;\n                     }\n                     break;\n                 case BELOW_SIDE:\n                     if (f1 \u003c\u003d 0) {\n                         return x1;\n                     }\n                     break;\n                 case ABOVE_SIDE:\n                     if (f1 \u003e\u003d 0) {\n                         return x1;\n                     }\n                     break;\n                 default:\n                     throw new MathInternalError();\n             }\n         }\n         if (FastMath.abs(x1 - x0) \u003c FastMath.max(rtol * FastMath.abs(x1), atol)) {\n-            switch(allowedSolutions) {\n+            switch(allowed) {\n                 case ANY_SIDE:\n                     return x1;\n                 case LEFT_SIDE:\n                     return inverted ? x1 : x0;\n                 case RIGHT_SIDE:\n                     return inverted ? x0 : x1;\n                 case BELOW_SIDE:\n                     return (f1 \u003c\u003d 0) ? x1 : x0;\n                 case ABOVE_SIDE:\n                     return (f1 \u003e\u003d 0) ? x1 : x0;\n                 default:\n                     throw new MathInternalError();\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c8bb7cc4bbf53334f9b803cdcd4c3af6390320a1": {
      "type": "Ymultichange(Ybodychange,Yannotationchange)",
      "commitMessage": "Separate implementation of secant solver from bracketing solvers.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@1144828 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "7/10/11, 4:07 AM",
      "commitName": "c8bb7cc4bbf53334f9b803cdcd4c3af6390320a1",
      "commitAuthor": "Luc Maisonobe",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "Separate implementation of secant solver from bracketing solvers.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@1144828 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "7/10/11, 4:07 AM",
          "commitName": "c8bb7cc4bbf53334f9b803cdcd4c3af6390320a1",
          "commitAuthor": "Luc Maisonobe",
          "commitDateOld": "7/2/11, 9:27 AM",
          "commitNameOld": "cfcd4cf992702e25c9b15e5a2ebb7fc8bec010f4",
          "commitAuthorOld": "Luc Maisonobe",
          "daysBetweenCommits": 7.78,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "actualSource": "protected final double doSolve() {\n    double x0 \u003d getMin();\n    double x1 \u003d getMax();\n    double f0 \u003d computeObjectiveValue(x0);\n    double f1 \u003d computeObjectiveValue(x1);\n    if (f0 \u003d\u003d 0.0) {\n        return x0;\n    }\n    if (f1 \u003d\u003d 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol \u003d getFunctionValueAccuracy();\n    final double atol \u003d getAbsoluteAccuracy();\n    final double rtol \u003d getRelativeAccuracy();\n    boolean inverted \u003d false;\n    while (true) {\n        final double x \u003d x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx \u003d computeObjectiveValue(x);\n        if (fx \u003d\u003d 0.0) {\n            return x;\n        }\n        if (f1 * fx \u003c 0) {\n            x0 \u003d x1;\n            f0 \u003d f1;\n            x1 \u003d x;\n            f1 \u003d fx;\n            inverted \u003d !inverted;\n        } else {\n            if (method \u003d\u003d Method.ILLINOIS) {\n                f0 *\u003d 0.5;\n            }\n            if (method \u003d\u003d Method.PEGASUS) {\n                f0 *\u003d f1 / (f1 + fx);\n            }\n            x1 \u003d x;\n            f1 \u003d fx;\n        }\n        if (FastMath.abs(f1) \u003c\u003d ftol) {\n            switch(allowedSolutions) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    if (inverted) {\n                        return x1;\n                    }\n                    break;\n                case RIGHT_SIDE:\n                    if (!inverted) {\n                        return x1;\n                    }\n                    break;\n                case BELOW_SIDE:\n                    if (f1 \u003c\u003d 0) {\n                        return x1;\n                    }\n                    break;\n                case ABOVE_SIDE:\n                    if (f1 \u003e\u003d 0) {\n                        return x1;\n                    }\n                    break;\n                default:\n                    throw new MathInternalError();\n            }\n        }\n        if (FastMath.abs(x1 - x0) \u003c FastMath.max(rtol * FastMath.abs(x1), atol)) {\n            switch(allowedSolutions) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    return inverted ? x1 : x0;\n                case RIGHT_SIDE:\n                    return inverted ? x0 : x1;\n                case BELOW_SIDE:\n                    return (f1 \u003c\u003d 0) ? x1 : x0;\n                case ABOVE_SIDE:\n                    return (f1 \u003e\u003d 0) ? x1 : x0;\n                default:\n                    throw new MathInternalError();\n            }\n        }\n    }\n}",
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java",
          "functionStartLine": 111,
          "functionName": "doSolve",
          "functionAnnotation": "",
          "functionDoc": "@inheritDoc}\n",
          "diff": "@@ -1,90 +1,84 @@\n-@Override\n protected final double doSolve() {\n     double x0 \u003d getMin();\n     double x1 \u003d getMax();\n     double f0 \u003d computeObjectiveValue(x0);\n     double f1 \u003d computeObjectiveValue(x1);\n     if (f0 \u003d\u003d 0.0) {\n         return x0;\n     }\n     if (f1 \u003d\u003d 0.0) {\n         return x1;\n     }\n     verifyBracketing(x0, x1);\n     final double ftol \u003d getFunctionValueAccuracy();\n     final double atol \u003d getAbsoluteAccuracy();\n     final double rtol \u003d getRelativeAccuracy();\n     boolean inverted \u003d false;\n     while (true) {\n         final double x \u003d x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n         final double fx \u003d computeObjectiveValue(x);\n         if (fx \u003d\u003d 0.0) {\n             return x;\n         }\n-        if (method \u003d\u003d Method.SECANT) {\n-            x0 \u003d x1;\n-            f0 \u003d f1;\n-            x1 \u003d x;\n-            f1 \u003d fx;\n-        } else if (f1 * fx \u003c 0) {\n+        if (f1 * fx \u003c 0) {\n             x0 \u003d x1;\n             f0 \u003d f1;\n             x1 \u003d x;\n             f1 \u003d fx;\n             inverted \u003d !inverted;\n         } else {\n             if (method \u003d\u003d Method.ILLINOIS) {\n                 f0 *\u003d 0.5;\n             }\n             if (method \u003d\u003d Method.PEGASUS) {\n                 f0 *\u003d f1 / (f1 + fx);\n             }\n             x1 \u003d x;\n             f1 \u003d fx;\n         }\n         if (FastMath.abs(f1) \u003c\u003d ftol) {\n             switch(allowedSolutions) {\n-                case EITHER_SIDE:\n+                case ANY_SIDE:\n                     return x1;\n                 case LEFT_SIDE:\n                     if (inverted) {\n                         return x1;\n                     }\n                     break;\n                 case RIGHT_SIDE:\n                     if (!inverted) {\n                         return x1;\n                     }\n                     break;\n                 case BELOW_SIDE:\n                     if (f1 \u003c\u003d 0) {\n                         return x1;\n                     }\n                     break;\n                 case ABOVE_SIDE:\n                     if (f1 \u003e\u003d 0) {\n                         return x1;\n                     }\n                     break;\n                 default:\n                     throw new MathInternalError();\n             }\n         }\n         if (FastMath.abs(x1 - x0) \u003c FastMath.max(rtol * FastMath.abs(x1), atol)) {\n             switch(allowedSolutions) {\n-                case EITHER_SIDE:\n+                case ANY_SIDE:\n                     return x1;\n                 case LEFT_SIDE:\n                     return inverted ? x1 : x0;\n                 case RIGHT_SIDE:\n                     return inverted ? x0 : x1;\n                 case BELOW_SIDE:\n                     return (f1 \u003c\u003d 0) ? x1 : x0;\n                 case ABOVE_SIDE:\n                     return (f1 \u003e\u003d 0) ? x1 : x0;\n                 default:\n                     throw new MathInternalError();\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Yannotationchange",
          "commitMessage": "Separate implementation of secant solver from bracketing solvers.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@1144828 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "7/10/11, 4:07 AM",
          "commitName": "c8bb7cc4bbf53334f9b803cdcd4c3af6390320a1",
          "commitAuthor": "Luc Maisonobe",
          "commitDateOld": "7/2/11, 9:27 AM",
          "commitNameOld": "cfcd4cf992702e25c9b15e5a2ebb7fc8bec010f4",
          "commitAuthorOld": "Luc Maisonobe",
          "daysBetweenCommits": 7.78,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "actualSource": "protected final double doSolve() {\n    double x0 \u003d getMin();\n    double x1 \u003d getMax();\n    double f0 \u003d computeObjectiveValue(x0);\n    double f1 \u003d computeObjectiveValue(x1);\n    if (f0 \u003d\u003d 0.0) {\n        return x0;\n    }\n    if (f1 \u003d\u003d 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol \u003d getFunctionValueAccuracy();\n    final double atol \u003d getAbsoluteAccuracy();\n    final double rtol \u003d getRelativeAccuracy();\n    boolean inverted \u003d false;\n    while (true) {\n        final double x \u003d x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx \u003d computeObjectiveValue(x);\n        if (fx \u003d\u003d 0.0) {\n            return x;\n        }\n        if (f1 * fx \u003c 0) {\n            x0 \u003d x1;\n            f0 \u003d f1;\n            x1 \u003d x;\n            f1 \u003d fx;\n            inverted \u003d !inverted;\n        } else {\n            if (method \u003d\u003d Method.ILLINOIS) {\n                f0 *\u003d 0.5;\n            }\n            if (method \u003d\u003d Method.PEGASUS) {\n                f0 *\u003d f1 / (f1 + fx);\n            }\n            x1 \u003d x;\n            f1 \u003d fx;\n        }\n        if (FastMath.abs(f1) \u003c\u003d ftol) {\n            switch(allowedSolutions) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    if (inverted) {\n                        return x1;\n                    }\n                    break;\n                case RIGHT_SIDE:\n                    if (!inverted) {\n                        return x1;\n                    }\n                    break;\n                case BELOW_SIDE:\n                    if (f1 \u003c\u003d 0) {\n                        return x1;\n                    }\n                    break;\n                case ABOVE_SIDE:\n                    if (f1 \u003e\u003d 0) {\n                        return x1;\n                    }\n                    break;\n                default:\n                    throw new MathInternalError();\n            }\n        }\n        if (FastMath.abs(x1 - x0) \u003c FastMath.max(rtol * FastMath.abs(x1), atol)) {\n            switch(allowedSolutions) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    return inverted ? x1 : x0;\n                case RIGHT_SIDE:\n                    return inverted ? x0 : x1;\n                case BELOW_SIDE:\n                    return (f1 \u003c\u003d 0) ? x1 : x0;\n                case ABOVE_SIDE:\n                    return (f1 \u003e\u003d 0) ? x1 : x0;\n                default:\n                    throw new MathInternalError();\n            }\n        }\n    }\n}",
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java",
          "functionStartLine": 111,
          "functionName": "doSolve",
          "functionAnnotation": "",
          "functionDoc": "@inheritDoc}\n",
          "diff": "@@ -1,90 +1,84 @@\n-@Override\n protected final double doSolve() {\n     double x0 \u003d getMin();\n     double x1 \u003d getMax();\n     double f0 \u003d computeObjectiveValue(x0);\n     double f1 \u003d computeObjectiveValue(x1);\n     if (f0 \u003d\u003d 0.0) {\n         return x0;\n     }\n     if (f1 \u003d\u003d 0.0) {\n         return x1;\n     }\n     verifyBracketing(x0, x1);\n     final double ftol \u003d getFunctionValueAccuracy();\n     final double atol \u003d getAbsoluteAccuracy();\n     final double rtol \u003d getRelativeAccuracy();\n     boolean inverted \u003d false;\n     while (true) {\n         final double x \u003d x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n         final double fx \u003d computeObjectiveValue(x);\n         if (fx \u003d\u003d 0.0) {\n             return x;\n         }\n-        if (method \u003d\u003d Method.SECANT) {\n-            x0 \u003d x1;\n-            f0 \u003d f1;\n-            x1 \u003d x;\n-            f1 \u003d fx;\n-        } else if (f1 * fx \u003c 0) {\n+        if (f1 * fx \u003c 0) {\n             x0 \u003d x1;\n             f0 \u003d f1;\n             x1 \u003d x;\n             f1 \u003d fx;\n             inverted \u003d !inverted;\n         } else {\n             if (method \u003d\u003d Method.ILLINOIS) {\n                 f0 *\u003d 0.5;\n             }\n             if (method \u003d\u003d Method.PEGASUS) {\n                 f0 *\u003d f1 / (f1 + fx);\n             }\n             x1 \u003d x;\n             f1 \u003d fx;\n         }\n         if (FastMath.abs(f1) \u003c\u003d ftol) {\n             switch(allowedSolutions) {\n-                case EITHER_SIDE:\n+                case ANY_SIDE:\n                     return x1;\n                 case LEFT_SIDE:\n                     if (inverted) {\n                         return x1;\n                     }\n                     break;\n                 case RIGHT_SIDE:\n                     if (!inverted) {\n                         return x1;\n                     }\n                     break;\n                 case BELOW_SIDE:\n                     if (f1 \u003c\u003d 0) {\n                         return x1;\n                     }\n                     break;\n                 case ABOVE_SIDE:\n                     if (f1 \u003e\u003d 0) {\n                         return x1;\n                     }\n                     break;\n                 default:\n                     throw new MathInternalError();\n             }\n         }\n         if (FastMath.abs(x1 - x0) \u003c FastMath.max(rtol * FastMath.abs(x1), atol)) {\n             switch(allowedSolutions) {\n-                case EITHER_SIDE:\n+                case ANY_SIDE:\n                     return x1;\n                 case LEFT_SIDE:\n                     return inverted ? x1 : x0;\n                 case RIGHT_SIDE:\n                     return inverted ? x0 : x1;\n                 case BELOW_SIDE:\n                     return (f1 \u003c\u003d 0) ? x1 : x0;\n                 case ABOVE_SIDE:\n                     return (f1 \u003e\u003d 0) ? x1 : x0;\n                 default:\n                     throw new MathInternalError();\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "@Override",
            "newValue": ""
          }
        }
      ]
    },
    "cfcd4cf992702e25c9b15e5a2ebb7fc8bec010f4": {
      "type": "Ybodychange",
      "commitMessage": "Added BELOW_SIDE and ABOVE_SIDE in the possible allowed solutions for bracketing solvers.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@1142244 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "7/2/11, 9:27 AM",
      "commitName": "cfcd4cf992702e25c9b15e5a2ebb7fc8bec010f4",
      "commitAuthor": "Luc Maisonobe",
      "commitDateOld": "6/24/11, 4:13 PM",
      "commitNameOld": "3bd4ebcb79a6bb6df36ba3fcf23ae55d68c45ddf",
      "commitAuthorOld": "Gilles Sadowski",
      "daysBetweenCommits": 7.72,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected final double doSolve() {\n    double x0 \u003d getMin();\n    double x1 \u003d getMax();\n    double f0 \u003d computeObjectiveValue(x0);\n    double f1 \u003d computeObjectiveValue(x1);\n    if (f0 \u003d\u003d 0.0) {\n        return x0;\n    }\n    if (f1 \u003d\u003d 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol \u003d getFunctionValueAccuracy();\n    final double atol \u003d getAbsoluteAccuracy();\n    final double rtol \u003d getRelativeAccuracy();\n    boolean inverted \u003d false;\n    while (true) {\n        final double x \u003d x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx \u003d computeObjectiveValue(x);\n        if (fx \u003d\u003d 0.0) {\n            return x;\n        }\n        if (method \u003d\u003d Method.SECANT) {\n            x0 \u003d x1;\n            f0 \u003d f1;\n            x1 \u003d x;\n            f1 \u003d fx;\n        } else if (f1 * fx \u003c 0) {\n            x0 \u003d x1;\n            f0 \u003d f1;\n            x1 \u003d x;\n            f1 \u003d fx;\n            inverted \u003d !inverted;\n        } else {\n            if (method \u003d\u003d Method.ILLINOIS) {\n                f0 *\u003d 0.5;\n            }\n            if (method \u003d\u003d Method.PEGASUS) {\n                f0 *\u003d f1 / (f1 + fx);\n            }\n            x1 \u003d x;\n            f1 \u003d fx;\n        }\n        if (FastMath.abs(f1) \u003c\u003d ftol) {\n            switch(allowedSolutions) {\n                case EITHER_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    if (inverted) {\n                        return x1;\n                    }\n                    break;\n                case RIGHT_SIDE:\n                    if (!inverted) {\n                        return x1;\n                    }\n                    break;\n                case BELOW_SIDE:\n                    if (f1 \u003c\u003d 0) {\n                        return x1;\n                    }\n                    break;\n                case ABOVE_SIDE:\n                    if (f1 \u003e\u003d 0) {\n                        return x1;\n                    }\n                    break;\n                default:\n                    throw new MathInternalError();\n            }\n        }\n        if (FastMath.abs(x1 - x0) \u003c FastMath.max(rtol * FastMath.abs(x1), atol)) {\n            switch(allowedSolutions) {\n                case EITHER_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    return inverted ? x1 : x0;\n                case RIGHT_SIDE:\n                    return inverted ? x0 : x1;\n                case BELOW_SIDE:\n                    return (f1 \u003c\u003d 0) ? x1 : x0;\n                case ABOVE_SIDE:\n                    return (f1 \u003e\u003d 0) ? x1 : x0;\n                default:\n                    throw new MathInternalError();\n            }\n        }\n    }\n}",
      "path": "src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java",
      "functionStartLine": 79,
      "functionName": "doSolve",
      "functionAnnotation": "@Override",
      "functionDoc": "@inheritDoc}\n",
      "diff": "@@ -1,78 +1,90 @@\n @Override\n protected final double doSolve() {\n     double x0 \u003d getMin();\n     double x1 \u003d getMax();\n     double f0 \u003d computeObjectiveValue(x0);\n     double f1 \u003d computeObjectiveValue(x1);\n     if (f0 \u003d\u003d 0.0) {\n         return x0;\n     }\n     if (f1 \u003d\u003d 0.0) {\n         return x1;\n     }\n     verifyBracketing(x0, x1);\n     final double ftol \u003d getFunctionValueAccuracy();\n     final double atol \u003d getAbsoluteAccuracy();\n     final double rtol \u003d getRelativeAccuracy();\n-    double x;\n-    double fx;\n     boolean inverted \u003d false;\n     while (true) {\n-        x \u003d x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n-        fx \u003d computeObjectiveValue(x);\n+        final double x \u003d x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n+        final double fx \u003d computeObjectiveValue(x);\n         if (fx \u003d\u003d 0.0) {\n             return x;\n         }\n         if (method \u003d\u003d Method.SECANT) {\n             x0 \u003d x1;\n             f0 \u003d f1;\n             x1 \u003d x;\n             f1 \u003d fx;\n         } else if (f1 * fx \u003c 0) {\n             x0 \u003d x1;\n             f0 \u003d f1;\n             x1 \u003d x;\n             f1 \u003d fx;\n             inverted \u003d !inverted;\n         } else {\n             if (method \u003d\u003d Method.ILLINOIS) {\n                 f0 *\u003d 0.5;\n             }\n             if (method \u003d\u003d Method.PEGASUS) {\n                 f0 *\u003d f1 / (f1 + fx);\n             }\n             x1 \u003d x;\n             f1 \u003d fx;\n         }\n         if (FastMath.abs(f1) \u003c\u003d ftol) {\n             switch(allowedSolutions) {\n                 case EITHER_SIDE:\n                     return x1;\n                 case LEFT_SIDE:\n                     if (inverted) {\n                         return x1;\n                     }\n                     break;\n                 case RIGHT_SIDE:\n                     if (!inverted) {\n                         return x1;\n                     }\n                     break;\n+                case BELOW_SIDE:\n+                    if (f1 \u003c\u003d 0) {\n+                        return x1;\n+                    }\n+                    break;\n+                case ABOVE_SIDE:\n+                    if (f1 \u003e\u003d 0) {\n+                        return x1;\n+                    }\n+                    break;\n                 default:\n                     throw new MathInternalError();\n             }\n         }\n         if (FastMath.abs(x1 - x0) \u003c FastMath.max(rtol * FastMath.abs(x1), atol)) {\n             switch(allowedSolutions) {\n                 case EITHER_SIDE:\n                     return x1;\n                 case LEFT_SIDE:\n                     return inverted ? x1 : x0;\n                 case RIGHT_SIDE:\n                     return inverted ? x0 : x1;\n+                case BELOW_SIDE:\n+                    return (f1 \u003c\u003d 0) ? x1 : x0;\n+                case ABOVE_SIDE:\n+                    return (f1 \u003e\u003d 0) ? x1 : x0;\n                 default:\n                     throw new MathInternalError();\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3bd4ebcb79a6bb6df36ba3fcf23ae55d68c45ddf": {
      "type": "Ybodychange",
      "commitMessage": "MATH-599\nAdded brackets around single-statement conditional branches.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@1139460 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "6/24/11, 4:13 PM",
      "commitName": "3bd4ebcb79a6bb6df36ba3fcf23ae55d68c45ddf",
      "commitAuthor": "Gilles Sadowski",
      "commitDateOld": "6/24/11, 3:36 PM",
      "commitNameOld": "6a23f66ae368949d1a0764cdcd8aad9668bda0c3",
      "commitAuthorOld": "Gilles Sadowski",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected final double doSolve() {\n    double x0 \u003d getMin();\n    double x1 \u003d getMax();\n    double f0 \u003d computeObjectiveValue(x0);\n    double f1 \u003d computeObjectiveValue(x1);\n    if (f0 \u003d\u003d 0.0) {\n        return x0;\n    }\n    if (f1 \u003d\u003d 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol \u003d getFunctionValueAccuracy();\n    final double atol \u003d getAbsoluteAccuracy();\n    final double rtol \u003d getRelativeAccuracy();\n    double x;\n    double fx;\n    boolean inverted \u003d false;\n    while (true) {\n        x \u003d x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        fx \u003d computeObjectiveValue(x);\n        if (fx \u003d\u003d 0.0) {\n            return x;\n        }\n        if (method \u003d\u003d Method.SECANT) {\n            x0 \u003d x1;\n            f0 \u003d f1;\n            x1 \u003d x;\n            f1 \u003d fx;\n        } else if (f1 * fx \u003c 0) {\n            x0 \u003d x1;\n            f0 \u003d f1;\n            x1 \u003d x;\n            f1 \u003d fx;\n            inverted \u003d !inverted;\n        } else {\n            if (method \u003d\u003d Method.ILLINOIS) {\n                f0 *\u003d 0.5;\n            }\n            if (method \u003d\u003d Method.PEGASUS) {\n                f0 *\u003d f1 / (f1 + fx);\n            }\n            x1 \u003d x;\n            f1 \u003d fx;\n        }\n        if (FastMath.abs(f1) \u003c\u003d ftol) {\n            switch(allowedSolutions) {\n                case EITHER_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    if (inverted) {\n                        return x1;\n                    }\n                    break;\n                case RIGHT_SIDE:\n                    if (!inverted) {\n                        return x1;\n                    }\n                    break;\n                default:\n                    throw new MathInternalError();\n            }\n        }\n        if (FastMath.abs(x1 - x0) \u003c FastMath.max(rtol * FastMath.abs(x1), atol)) {\n            switch(allowedSolutions) {\n                case EITHER_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    return inverted ? x1 : x0;\n                case RIGHT_SIDE:\n                    return inverted ? x0 : x1;\n                default:\n                    throw new MathInternalError();\n            }\n        }\n    }\n}",
      "path": "src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java",
      "functionStartLine": 79,
      "functionName": "doSolve",
      "functionAnnotation": "@Override",
      "functionDoc": "@inheritDoc}\n",
      "diff": "@@ -1,73 +1,78 @@\n @Override\n protected final double doSolve() {\n     double x0 \u003d getMin();\n     double x1 \u003d getMax();\n     double f0 \u003d computeObjectiveValue(x0);\n     double f1 \u003d computeObjectiveValue(x1);\n-    if (f0 \u003d\u003d 0.0)\n+    if (f0 \u003d\u003d 0.0) {\n         return x0;\n-    if (f1 \u003d\u003d 0.0)\n+    }\n+    if (f1 \u003d\u003d 0.0) {\n         return x1;\n+    }\n     verifyBracketing(x0, x1);\n     final double ftol \u003d getFunctionValueAccuracy();\n     final double atol \u003d getAbsoluteAccuracy();\n     final double rtol \u003d getRelativeAccuracy();\n     double x;\n     double fx;\n     boolean inverted \u003d false;\n     while (true) {\n         x \u003d x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n         fx \u003d computeObjectiveValue(x);\n-        if (fx \u003d\u003d 0.0)\n+        if (fx \u003d\u003d 0.0) {\n             return x;\n+        }\n         if (method \u003d\u003d Method.SECANT) {\n             x0 \u003d x1;\n             f0 \u003d f1;\n             x1 \u003d x;\n             f1 \u003d fx;\n         } else if (f1 * fx \u003c 0) {\n             x0 \u003d x1;\n             f0 \u003d f1;\n             x1 \u003d x;\n             f1 \u003d fx;\n             inverted \u003d !inverted;\n         } else {\n-            if (method \u003d\u003d Method.ILLINOIS)\n+            if (method \u003d\u003d Method.ILLINOIS) {\n                 f0 *\u003d 0.5;\n-            if (method \u003d\u003d Method.PEGASUS)\n+            }\n+            if (method \u003d\u003d Method.PEGASUS) {\n                 f0 *\u003d f1 / (f1 + fx);\n+            }\n             x1 \u003d x;\n             f1 \u003d fx;\n         }\n         if (FastMath.abs(f1) \u003c\u003d ftol) {\n             switch(allowedSolutions) {\n                 case EITHER_SIDE:\n                     return x1;\n                 case LEFT_SIDE:\n                     if (inverted) {\n                         return x1;\n                     }\n                     break;\n                 case RIGHT_SIDE:\n                     if (!inverted) {\n                         return x1;\n                     }\n                     break;\n                 default:\n                     throw new MathInternalError();\n             }\n         }\n         if (FastMath.abs(x1 - x0) \u003c FastMath.max(rtol * FastMath.abs(x1), atol)) {\n             switch(allowedSolutions) {\n                 case EITHER_SIDE:\n                     return x1;\n                 case LEFT_SIDE:\n                     return inverted ? x1 : x0;\n                 case RIGHT_SIDE:\n                     return inverted ? x0 : x1;\n                 default:\n                     throw new MathInternalError();\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6a23f66ae368949d1a0764cdcd8aad9668bda0c3": {
      "type": "Yfilerename",
      "commitMessage": "MATH-599\nInserted \"BaseBracketedSecantSolver\" into the secant-based solvers hierarchy.\nRenamed \"SecantBase\" to \"BaseSecantSolver\".\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@1139455 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "6/24/11, 3:36 PM",
      "commitName": "6a23f66ae368949d1a0764cdcd8aad9668bda0c3",
      "commitAuthor": "Gilles Sadowski",
      "commitDateOld": "6/24/11, 5:29 AM",
      "commitNameOld": "4d95c18a15bdbc2048953924d7a8dd735202a5ff",
      "commitAuthorOld": "Gilles Sadowski",
      "daysBetweenCommits": 0.42,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected final double doSolve() {\n    double x0 \u003d getMin();\n    double x1 \u003d getMax();\n    double f0 \u003d computeObjectiveValue(x0);\n    double f1 \u003d computeObjectiveValue(x1);\n    if (f0 \u003d\u003d 0.0)\n        return x0;\n    if (f1 \u003d\u003d 0.0)\n        return x1;\n    verifyBracketing(x0, x1);\n    final double ftol \u003d getFunctionValueAccuracy();\n    final double atol \u003d getAbsoluteAccuracy();\n    final double rtol \u003d getRelativeAccuracy();\n    double x;\n    double fx;\n    boolean inverted \u003d false;\n    while (true) {\n        x \u003d x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        fx \u003d computeObjectiveValue(x);\n        if (fx \u003d\u003d 0.0)\n            return x;\n        if (method \u003d\u003d Method.SECANT) {\n            x0 \u003d x1;\n            f0 \u003d f1;\n            x1 \u003d x;\n            f1 \u003d fx;\n        } else if (f1 * fx \u003c 0) {\n            x0 \u003d x1;\n            f0 \u003d f1;\n            x1 \u003d x;\n            f1 \u003d fx;\n            inverted \u003d !inverted;\n        } else {\n            if (method \u003d\u003d Method.ILLINOIS)\n                f0 *\u003d 0.5;\n            if (method \u003d\u003d Method.PEGASUS)\n                f0 *\u003d f1 / (f1 + fx);\n            x1 \u003d x;\n            f1 \u003d fx;\n        }\n        if (FastMath.abs(f1) \u003c\u003d ftol) {\n            switch(allowedSolutions) {\n                case EITHER_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    if (inverted) {\n                        return x1;\n                    }\n                    break;\n                case RIGHT_SIDE:\n                    if (!inverted) {\n                        return x1;\n                    }\n                    break;\n                default:\n                    throw new MathInternalError();\n            }\n        }\n        if (FastMath.abs(x1 - x0) \u003c FastMath.max(rtol * FastMath.abs(x1), atol)) {\n            switch(allowedSolutions) {\n                case EITHER_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    return inverted ? x1 : x0;\n                case RIGHT_SIDE:\n                    return inverted ? x0 : x1;\n                default:\n                    throw new MathInternalError();\n            }\n        }\n    }\n}",
      "path": "src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java",
      "functionStartLine": 79,
      "functionName": "doSolve",
      "functionAnnotation": "@Override",
      "functionDoc": "@inheritDoc}\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/main/java/org/apache/commons/math/analysis/solvers/SecantBase.java",
        "newPath": "src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java"
      }
    },
    "ed5fdf67a31518149a74e05db23371056af10842": {
      "type": "Ymultichange(Ymovefromfile,Ymodifierchange,Ybodychange)",
      "commitMessage": "MATH-599\n\"SecantSolver\" modified to correspond to the original algorithm. Added several\nsecant-based solvers. Patch provided by Dennis Hendriks.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@1139126 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "6/23/11, 5:12 PM",
      "commitName": "ed5fdf67a31518149a74e05db23371056af10842",
      "commitAuthor": "Gilles Sadowski",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "MATH-599\n\"SecantSolver\" modified to correspond to the original algorithm. Added several\nsecant-based solvers. Patch provided by Dennis Hendriks.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@1139126 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "6/23/11, 5:12 PM",
          "commitName": "ed5fdf67a31518149a74e05db23371056af10842",
          "commitAuthor": "Gilles Sadowski",
          "commitDateOld": "6/22/11, 6:42 AM",
          "commitNameOld": "c377b9c6bc631f057b190ca331114ac7f8e67769",
          "commitAuthorOld": "Gilles Sadowski",
          "daysBetweenCommits": 1.44,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\nprotected final double doSolve() {\n    double x0 \u003d getMin();\n    double x1 \u003d getMax();\n    double f0 \u003d computeObjectiveValue(x0);\n    double f1 \u003d computeObjectiveValue(x1);\n    if (f0 \u003d\u003d 0.0)\n        return x0;\n    if (f1 \u003d\u003d 0.0)\n        return x1;\n    verifyBracketing(x0, x1);\n    final double ftol \u003d getFunctionValueAccuracy();\n    final double atol \u003d getAbsoluteAccuracy();\n    final double rtol \u003d getRelativeAccuracy();\n    double x;\n    double fx;\n    boolean inverted \u003d false;\n    while (true) {\n        x \u003d x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        fx \u003d computeObjectiveValue(x);\n        if (fx \u003d\u003d 0.0)\n            return x;\n        if (method \u003d\u003d Method.SECANT) {\n            x0 \u003d x1;\n            f0 \u003d f1;\n            x1 \u003d x;\n            f1 \u003d fx;\n        } else if (f1 * fx \u003c 0) {\n            x0 \u003d x1;\n            f0 \u003d f1;\n            x1 \u003d x;\n            f1 \u003d fx;\n            inverted \u003d !inverted;\n        } else {\n            if (method \u003d\u003d Method.ILLINOIS)\n                f0 *\u003d 0.5;\n            if (method \u003d\u003d Method.PEGASUS)\n                f0 *\u003d f1 / (f1 + fx);\n            x1 \u003d x;\n            f1 \u003d fx;\n        }\n        if (FastMath.abs(f1) \u003c\u003d ftol) {\n            switch(allowedSolutions) {\n                case EITHER_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    if (inverted) {\n                        return x1;\n                    }\n                    break;\n                case RIGHT_SIDE:\n                    if (!inverted) {\n                        return x1;\n                    }\n                    break;\n                default:\n                    throw new MathInternalError();\n            }\n        }\n        if (FastMath.abs(x1 - x0) \u003c FastMath.max(rtol * FastMath.abs(x1), atol)) {\n            switch(allowedSolutions) {\n                case EITHER_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    return inverted ? x1 : x0;\n                case RIGHT_SIDE:\n                    return inverted ? x0 : x1;\n                default:\n                    throw new MathInternalError();\n            }\n        }\n    }\n}",
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/SecantBase.java",
          "functionStartLine": 79,
          "functionName": "doSolve",
          "functionAnnotation": "@Override",
          "functionDoc": "@inheritDoc}\n",
          "diff": "@@ -1,59 +1,73 @@\n @Override\n-protected double doSolve() {\n-    double min \u003d getMin();\n-    double max \u003d getMax();\n-    verifyInterval(min, max);\n-    final double functionValueAccuracy \u003d getFunctionValueAccuracy();\n-    double x0 \u003d min;\n-    double x1 \u003d max;\n-    double y0 \u003d computeObjectiveValue(x0);\n-    if (FastMath.abs(y0) \u003c\u003d functionValueAccuracy) {\n+protected final double doSolve() {\n+    double x0 \u003d getMin();\n+    double x1 \u003d getMax();\n+    double f0 \u003d computeObjectiveValue(x0);\n+    double f1 \u003d computeObjectiveValue(x1);\n+    if (f0 \u003d\u003d 0.0)\n         return x0;\n-    }\n-    double y1 \u003d computeObjectiveValue(x1);\n-    if (FastMath.abs(y1) \u003c\u003d functionValueAccuracy) {\n+    if (f1 \u003d\u003d 0.0)\n         return x1;\n-    }\n-    if (y0 * y1 \u003e\u003d 0) {\n-        throw new NoBracketingException(min, max, y0, y1);\n-    }\n-    final double absoluteAccuracy \u003d getAbsoluteAccuracy();\n-    final double relativeAccuracy \u003d getRelativeAccuracy();\n-    double x2 \u003d x0;\n-    double y2 \u003d y0;\n-    double oldDelta \u003d x2 - x1;\n+    verifyBracketing(x0, x1);\n+    final double ftol \u003d getFunctionValueAccuracy();\n+    final double atol \u003d getAbsoluteAccuracy();\n+    final double rtol \u003d getRelativeAccuracy();\n+    double x;\n+    double fx;\n+    boolean inverted \u003d false;\n     while (true) {\n-        if (FastMath.abs(y2) \u003c FastMath.abs(y1)) {\n+        x \u003d x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n+        fx \u003d computeObjectiveValue(x);\n+        if (fx \u003d\u003d 0.0)\n+            return x;\n+        if (method \u003d\u003d Method.SECANT) {\n             x0 \u003d x1;\n-            x1 \u003d x2;\n-            x2 \u003d x0;\n-            y0 \u003d y1;\n-            y1 \u003d y2;\n-            y2 \u003d y0;\n-        }\n-        if (FastMath.abs(y1) \u003c\u003d functionValueAccuracy) {\n-            return x1;\n-        }\n-        if (FastMath.abs(oldDelta) \u003c FastMath.max(relativeAccuracy * FastMath.abs(x1), absoluteAccuracy)) {\n-            return x1;\n-        }\n-        double delta;\n-        if (FastMath.abs(y1) \u003e FastMath.abs(y0)) {\n-            delta \u003d 0.5 * oldDelta;\n+            f0 \u003d f1;\n+            x1 \u003d x;\n+            f1 \u003d fx;\n+        } else if (f1 * fx \u003c 0) {\n+            x0 \u003d x1;\n+            f0 \u003d f1;\n+            x1 \u003d x;\n+            f1 \u003d fx;\n+            inverted \u003d !inverted;\n         } else {\n-            delta \u003d (x0 - x1) / (1 - y0 / y1);\n-            if (delta / oldDelta \u003e 1) {\n-                delta \u003d 0.5 * oldDelta;\n+            if (method \u003d\u003d Method.ILLINOIS)\n+                f0 *\u003d 0.5;\n+            if (method \u003d\u003d Method.PEGASUS)\n+                f0 *\u003d f1 / (f1 + fx);\n+            x1 \u003d x;\n+            f1 \u003d fx;\n+        }\n+        if (FastMath.abs(f1) \u003c\u003d ftol) {\n+            switch(allowedSolutions) {\n+                case EITHER_SIDE:\n+                    return x1;\n+                case LEFT_SIDE:\n+                    if (inverted) {\n+                        return x1;\n+                    }\n+                    break;\n+                case RIGHT_SIDE:\n+                    if (!inverted) {\n+                        return x1;\n+                    }\n+                    break;\n+                default:\n+                    throw new MathInternalError();\n             }\n         }\n-        x0 \u003d x1;\n-        y0 \u003d y1;\n-        x1 \u003d x1 + delta;\n-        y1 \u003d computeObjectiveValue(x1);\n-        if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n-            x2 \u003d x0;\n-            y2 \u003d y0;\n+        if (FastMath.abs(x1 - x0) \u003c FastMath.max(rtol * FastMath.abs(x1), atol)) {\n+            switch(allowedSolutions) {\n+                case EITHER_SIDE:\n+                    return x1;\n+                case LEFT_SIDE:\n+                    return inverted ? x1 : x0;\n+                case RIGHT_SIDE:\n+                    return inverted ? x0 : x1;\n+                default:\n+                    throw new MathInternalError();\n+            }\n         }\n-        oldDelta \u003d x2 - x1;\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldPath": "src/main/java/org/apache/commons/math/analysis/solvers/SecantSolver.java",
            "newPath": "src/main/java/org/apache/commons/math/analysis/solvers/SecantBase.java",
            "oldMethodName": "doSolve",
            "newMethodName": "doSolve"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "MATH-599\n\"SecantSolver\" modified to correspond to the original algorithm. Added several\nsecant-based solvers. Patch provided by Dennis Hendriks.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@1139126 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "6/23/11, 5:12 PM",
          "commitName": "ed5fdf67a31518149a74e05db23371056af10842",
          "commitAuthor": "Gilles Sadowski",
          "commitDateOld": "6/22/11, 6:42 AM",
          "commitNameOld": "c377b9c6bc631f057b190ca331114ac7f8e67769",
          "commitAuthorOld": "Gilles Sadowski",
          "daysBetweenCommits": 1.44,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\nprotected final double doSolve() {\n    double x0 \u003d getMin();\n    double x1 \u003d getMax();\n    double f0 \u003d computeObjectiveValue(x0);\n    double f1 \u003d computeObjectiveValue(x1);\n    if (f0 \u003d\u003d 0.0)\n        return x0;\n    if (f1 \u003d\u003d 0.0)\n        return x1;\n    verifyBracketing(x0, x1);\n    final double ftol \u003d getFunctionValueAccuracy();\n    final double atol \u003d getAbsoluteAccuracy();\n    final double rtol \u003d getRelativeAccuracy();\n    double x;\n    double fx;\n    boolean inverted \u003d false;\n    while (true) {\n        x \u003d x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        fx \u003d computeObjectiveValue(x);\n        if (fx \u003d\u003d 0.0)\n            return x;\n        if (method \u003d\u003d Method.SECANT) {\n            x0 \u003d x1;\n            f0 \u003d f1;\n            x1 \u003d x;\n            f1 \u003d fx;\n        } else if (f1 * fx \u003c 0) {\n            x0 \u003d x1;\n            f0 \u003d f1;\n            x1 \u003d x;\n            f1 \u003d fx;\n            inverted \u003d !inverted;\n        } else {\n            if (method \u003d\u003d Method.ILLINOIS)\n                f0 *\u003d 0.5;\n            if (method \u003d\u003d Method.PEGASUS)\n                f0 *\u003d f1 / (f1 + fx);\n            x1 \u003d x;\n            f1 \u003d fx;\n        }\n        if (FastMath.abs(f1) \u003c\u003d ftol) {\n            switch(allowedSolutions) {\n                case EITHER_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    if (inverted) {\n                        return x1;\n                    }\n                    break;\n                case RIGHT_SIDE:\n                    if (!inverted) {\n                        return x1;\n                    }\n                    break;\n                default:\n                    throw new MathInternalError();\n            }\n        }\n        if (FastMath.abs(x1 - x0) \u003c FastMath.max(rtol * FastMath.abs(x1), atol)) {\n            switch(allowedSolutions) {\n                case EITHER_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    return inverted ? x1 : x0;\n                case RIGHT_SIDE:\n                    return inverted ? x0 : x1;\n                default:\n                    throw new MathInternalError();\n            }\n        }\n    }\n}",
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/SecantBase.java",
          "functionStartLine": 79,
          "functionName": "doSolve",
          "functionAnnotation": "@Override",
          "functionDoc": "@inheritDoc}\n",
          "diff": "@@ -1,59 +1,73 @@\n @Override\n-protected double doSolve() {\n-    double min \u003d getMin();\n-    double max \u003d getMax();\n-    verifyInterval(min, max);\n-    final double functionValueAccuracy \u003d getFunctionValueAccuracy();\n-    double x0 \u003d min;\n-    double x1 \u003d max;\n-    double y0 \u003d computeObjectiveValue(x0);\n-    if (FastMath.abs(y0) \u003c\u003d functionValueAccuracy) {\n+protected final double doSolve() {\n+    double x0 \u003d getMin();\n+    double x1 \u003d getMax();\n+    double f0 \u003d computeObjectiveValue(x0);\n+    double f1 \u003d computeObjectiveValue(x1);\n+    if (f0 \u003d\u003d 0.0)\n         return x0;\n-    }\n-    double y1 \u003d computeObjectiveValue(x1);\n-    if (FastMath.abs(y1) \u003c\u003d functionValueAccuracy) {\n+    if (f1 \u003d\u003d 0.0)\n         return x1;\n-    }\n-    if (y0 * y1 \u003e\u003d 0) {\n-        throw new NoBracketingException(min, max, y0, y1);\n-    }\n-    final double absoluteAccuracy \u003d getAbsoluteAccuracy();\n-    final double relativeAccuracy \u003d getRelativeAccuracy();\n-    double x2 \u003d x0;\n-    double y2 \u003d y0;\n-    double oldDelta \u003d x2 - x1;\n+    verifyBracketing(x0, x1);\n+    final double ftol \u003d getFunctionValueAccuracy();\n+    final double atol \u003d getAbsoluteAccuracy();\n+    final double rtol \u003d getRelativeAccuracy();\n+    double x;\n+    double fx;\n+    boolean inverted \u003d false;\n     while (true) {\n-        if (FastMath.abs(y2) \u003c FastMath.abs(y1)) {\n+        x \u003d x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n+        fx \u003d computeObjectiveValue(x);\n+        if (fx \u003d\u003d 0.0)\n+            return x;\n+        if (method \u003d\u003d Method.SECANT) {\n             x0 \u003d x1;\n-            x1 \u003d x2;\n-            x2 \u003d x0;\n-            y0 \u003d y1;\n-            y1 \u003d y2;\n-            y2 \u003d y0;\n-        }\n-        if (FastMath.abs(y1) \u003c\u003d functionValueAccuracy) {\n-            return x1;\n-        }\n-        if (FastMath.abs(oldDelta) \u003c FastMath.max(relativeAccuracy * FastMath.abs(x1), absoluteAccuracy)) {\n-            return x1;\n-        }\n-        double delta;\n-        if (FastMath.abs(y1) \u003e FastMath.abs(y0)) {\n-            delta \u003d 0.5 * oldDelta;\n+            f0 \u003d f1;\n+            x1 \u003d x;\n+            f1 \u003d fx;\n+        } else if (f1 * fx \u003c 0) {\n+            x0 \u003d x1;\n+            f0 \u003d f1;\n+            x1 \u003d x;\n+            f1 \u003d fx;\n+            inverted \u003d !inverted;\n         } else {\n-            delta \u003d (x0 - x1) / (1 - y0 / y1);\n-            if (delta / oldDelta \u003e 1) {\n-                delta \u003d 0.5 * oldDelta;\n+            if (method \u003d\u003d Method.ILLINOIS)\n+                f0 *\u003d 0.5;\n+            if (method \u003d\u003d Method.PEGASUS)\n+                f0 *\u003d f1 / (f1 + fx);\n+            x1 \u003d x;\n+            f1 \u003d fx;\n+        }\n+        if (FastMath.abs(f1) \u003c\u003d ftol) {\n+            switch(allowedSolutions) {\n+                case EITHER_SIDE:\n+                    return x1;\n+                case LEFT_SIDE:\n+                    if (inverted) {\n+                        return x1;\n+                    }\n+                    break;\n+                case RIGHT_SIDE:\n+                    if (!inverted) {\n+                        return x1;\n+                    }\n+                    break;\n+                default:\n+                    throw new MathInternalError();\n             }\n         }\n-        x0 \u003d x1;\n-        y0 \u003d y1;\n-        x1 \u003d x1 + delta;\n-        y1 \u003d computeObjectiveValue(x1);\n-        if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n-            x2 \u003d x0;\n-            y2 \u003d y0;\n+        if (FastMath.abs(x1 - x0) \u003c FastMath.max(rtol * FastMath.abs(x1), atol)) {\n+            switch(allowedSolutions) {\n+                case EITHER_SIDE:\n+                    return x1;\n+                case LEFT_SIDE:\n+                    return inverted ? x1 : x0;\n+                case RIGHT_SIDE:\n+                    return inverted ? x0 : x1;\n+                default:\n+                    throw new MathInternalError();\n+            }\n         }\n-        oldDelta \u003d x2 - x1;\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[protected]",
            "newValue": "[protected, final]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "MATH-599\n\"SecantSolver\" modified to correspond to the original algorithm. Added several\nsecant-based solvers. Patch provided by Dennis Hendriks.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@1139126 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "6/23/11, 5:12 PM",
          "commitName": "ed5fdf67a31518149a74e05db23371056af10842",
          "commitAuthor": "Gilles Sadowski",
          "commitDateOld": "6/22/11, 6:42 AM",
          "commitNameOld": "c377b9c6bc631f057b190ca331114ac7f8e67769",
          "commitAuthorOld": "Gilles Sadowski",
          "daysBetweenCommits": 1.44,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\nprotected final double doSolve() {\n    double x0 \u003d getMin();\n    double x1 \u003d getMax();\n    double f0 \u003d computeObjectiveValue(x0);\n    double f1 \u003d computeObjectiveValue(x1);\n    if (f0 \u003d\u003d 0.0)\n        return x0;\n    if (f1 \u003d\u003d 0.0)\n        return x1;\n    verifyBracketing(x0, x1);\n    final double ftol \u003d getFunctionValueAccuracy();\n    final double atol \u003d getAbsoluteAccuracy();\n    final double rtol \u003d getRelativeAccuracy();\n    double x;\n    double fx;\n    boolean inverted \u003d false;\n    while (true) {\n        x \u003d x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        fx \u003d computeObjectiveValue(x);\n        if (fx \u003d\u003d 0.0)\n            return x;\n        if (method \u003d\u003d Method.SECANT) {\n            x0 \u003d x1;\n            f0 \u003d f1;\n            x1 \u003d x;\n            f1 \u003d fx;\n        } else if (f1 * fx \u003c 0) {\n            x0 \u003d x1;\n            f0 \u003d f1;\n            x1 \u003d x;\n            f1 \u003d fx;\n            inverted \u003d !inverted;\n        } else {\n            if (method \u003d\u003d Method.ILLINOIS)\n                f0 *\u003d 0.5;\n            if (method \u003d\u003d Method.PEGASUS)\n                f0 *\u003d f1 / (f1 + fx);\n            x1 \u003d x;\n            f1 \u003d fx;\n        }\n        if (FastMath.abs(f1) \u003c\u003d ftol) {\n            switch(allowedSolutions) {\n                case EITHER_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    if (inverted) {\n                        return x1;\n                    }\n                    break;\n                case RIGHT_SIDE:\n                    if (!inverted) {\n                        return x1;\n                    }\n                    break;\n                default:\n                    throw new MathInternalError();\n            }\n        }\n        if (FastMath.abs(x1 - x0) \u003c FastMath.max(rtol * FastMath.abs(x1), atol)) {\n            switch(allowedSolutions) {\n                case EITHER_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    return inverted ? x1 : x0;\n                case RIGHT_SIDE:\n                    return inverted ? x0 : x1;\n                default:\n                    throw new MathInternalError();\n            }\n        }\n    }\n}",
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/SecantBase.java",
          "functionStartLine": 79,
          "functionName": "doSolve",
          "functionAnnotation": "@Override",
          "functionDoc": "@inheritDoc}\n",
          "diff": "@@ -1,59 +1,73 @@\n @Override\n-protected double doSolve() {\n-    double min \u003d getMin();\n-    double max \u003d getMax();\n-    verifyInterval(min, max);\n-    final double functionValueAccuracy \u003d getFunctionValueAccuracy();\n-    double x0 \u003d min;\n-    double x1 \u003d max;\n-    double y0 \u003d computeObjectiveValue(x0);\n-    if (FastMath.abs(y0) \u003c\u003d functionValueAccuracy) {\n+protected final double doSolve() {\n+    double x0 \u003d getMin();\n+    double x1 \u003d getMax();\n+    double f0 \u003d computeObjectiveValue(x0);\n+    double f1 \u003d computeObjectiveValue(x1);\n+    if (f0 \u003d\u003d 0.0)\n         return x0;\n-    }\n-    double y1 \u003d computeObjectiveValue(x1);\n-    if (FastMath.abs(y1) \u003c\u003d functionValueAccuracy) {\n+    if (f1 \u003d\u003d 0.0)\n         return x1;\n-    }\n-    if (y0 * y1 \u003e\u003d 0) {\n-        throw new NoBracketingException(min, max, y0, y1);\n-    }\n-    final double absoluteAccuracy \u003d getAbsoluteAccuracy();\n-    final double relativeAccuracy \u003d getRelativeAccuracy();\n-    double x2 \u003d x0;\n-    double y2 \u003d y0;\n-    double oldDelta \u003d x2 - x1;\n+    verifyBracketing(x0, x1);\n+    final double ftol \u003d getFunctionValueAccuracy();\n+    final double atol \u003d getAbsoluteAccuracy();\n+    final double rtol \u003d getRelativeAccuracy();\n+    double x;\n+    double fx;\n+    boolean inverted \u003d false;\n     while (true) {\n-        if (FastMath.abs(y2) \u003c FastMath.abs(y1)) {\n+        x \u003d x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n+        fx \u003d computeObjectiveValue(x);\n+        if (fx \u003d\u003d 0.0)\n+            return x;\n+        if (method \u003d\u003d Method.SECANT) {\n             x0 \u003d x1;\n-            x1 \u003d x2;\n-            x2 \u003d x0;\n-            y0 \u003d y1;\n-            y1 \u003d y2;\n-            y2 \u003d y0;\n-        }\n-        if (FastMath.abs(y1) \u003c\u003d functionValueAccuracy) {\n-            return x1;\n-        }\n-        if (FastMath.abs(oldDelta) \u003c FastMath.max(relativeAccuracy * FastMath.abs(x1), absoluteAccuracy)) {\n-            return x1;\n-        }\n-        double delta;\n-        if (FastMath.abs(y1) \u003e FastMath.abs(y0)) {\n-            delta \u003d 0.5 * oldDelta;\n+            f0 \u003d f1;\n+            x1 \u003d x;\n+            f1 \u003d fx;\n+        } else if (f1 * fx \u003c 0) {\n+            x0 \u003d x1;\n+            f0 \u003d f1;\n+            x1 \u003d x;\n+            f1 \u003d fx;\n+            inverted \u003d !inverted;\n         } else {\n-            delta \u003d (x0 - x1) / (1 - y0 / y1);\n-            if (delta / oldDelta \u003e 1) {\n-                delta \u003d 0.5 * oldDelta;\n+            if (method \u003d\u003d Method.ILLINOIS)\n+                f0 *\u003d 0.5;\n+            if (method \u003d\u003d Method.PEGASUS)\n+                f0 *\u003d f1 / (f1 + fx);\n+            x1 \u003d x;\n+            f1 \u003d fx;\n+        }\n+        if (FastMath.abs(f1) \u003c\u003d ftol) {\n+            switch(allowedSolutions) {\n+                case EITHER_SIDE:\n+                    return x1;\n+                case LEFT_SIDE:\n+                    if (inverted) {\n+                        return x1;\n+                    }\n+                    break;\n+                case RIGHT_SIDE:\n+                    if (!inverted) {\n+                        return x1;\n+                    }\n+                    break;\n+                default:\n+                    throw new MathInternalError();\n             }\n         }\n-        x0 \u003d x1;\n-        y0 \u003d y1;\n-        x1 \u003d x1 + delta;\n-        y1 \u003d computeObjectiveValue(x1);\n-        if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n-            x2 \u003d x0;\n-            y2 \u003d y0;\n+        if (FastMath.abs(x1 - x0) \u003c FastMath.max(rtol * FastMath.abs(x1), atol)) {\n+            switch(allowedSolutions) {\n+                case EITHER_SIDE:\n+                    return x1;\n+                case LEFT_SIDE:\n+                    return inverted ? x1 : x0;\n+                case RIGHT_SIDE:\n+                    return inverted ? x0 : x1;\n+                default:\n+                    throw new MathInternalError();\n+            }\n         }\n-        oldDelta \u003d x2 - x1;\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "74ff198bd249a56d1349b963bd265f8899743b9b": {
      "type": "Ymultichange(Yrename,Yparameterchange,Ymodifierchange,Yexceptionschange,Ybodychange,Yannotationchange,Ydocchange)",
      "commitMessage": "MATH-439\nRefactored the \"solvers\" package. Implementations refer to number of\nevaluation of the objective function (instead of the number of iterations).\nNew interfaces and base classes.\n\"NewtonSolver\" fits in the design without resorting to a cast.\nCreated class \"MullerSolver2\" to contain the code of the method named \"solve2\"\nin class \"MullerSolver\".\nRemoved \"UnivariateRealSolverFactory\" and \"UnivariateRealSolverFactoryImpl\".\nDefault solver in \"UnivariateRealSolverUtils\" is explicitely instantiated.\n\"AbstractContinuousDistribution\": Type of exception thrown changed in\n\"UnivariateRealSolverUtils\".\nFactored out duplicate code (in \"GaussNewtonOptimizerTest\" and\n\"LevenbergMarquardtOptimizerTest\"): class \"Circle\" is now called\n\"CircleVectorial\". Also factored out the \"Circle\" class from\n\"NonLinearConjugateGradientOptimizerTest\": class is named \"CircleScalar\".\nCreated \"SecantSolverTest\", moving there all the tests for the class\n\"SecantSolver\" that were located in class \"BrentSolverTest\".\nCreated new interface and base class for polynomial functions solvers\n(\"LaguerreSolver\") so that the function type is now checked at compile time.\nRemoved deprecated exceptions (MATH-441).\nJavadoc clean-up.\nLowered tolerance values in some unit tests.\nTests upgraded to Junit 4 (MATH-423).\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@1039083 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/25/10, 8:22 AM",
      "commitName": "74ff198bd249a56d1349b963bd265f8899743b9b",
      "commitAuthor": "Gilles Sadowski",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "MATH-439\nRefactored the \"solvers\" package. Implementations refer to number of\nevaluation of the objective function (instead of the number of iterations).\nNew interfaces and base classes.\n\"NewtonSolver\" fits in the design without resorting to a cast.\nCreated class \"MullerSolver2\" to contain the code of the method named \"solve2\"\nin class \"MullerSolver\".\nRemoved \"UnivariateRealSolverFactory\" and \"UnivariateRealSolverFactoryImpl\".\nDefault solver in \"UnivariateRealSolverUtils\" is explicitely instantiated.\n\"AbstractContinuousDistribution\": Type of exception thrown changed in\n\"UnivariateRealSolverUtils\".\nFactored out duplicate code (in \"GaussNewtonOptimizerTest\" and\n\"LevenbergMarquardtOptimizerTest\"): class \"Circle\" is now called\n\"CircleVectorial\". Also factored out the \"Circle\" class from\n\"NonLinearConjugateGradientOptimizerTest\": class is named \"CircleScalar\".\nCreated \"SecantSolverTest\", moving there all the tests for the class\n\"SecantSolver\" that were located in class \"BrentSolverTest\".\nCreated new interface and base class for polynomial functions solvers\n(\"LaguerreSolver\") so that the function type is now checked at compile time.\nRemoved deprecated exceptions (MATH-441).\nJavadoc clean-up.\nLowered tolerance values in some unit tests.\nTests upgraded to Junit 4 (MATH-423).\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@1039083 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "11/25/10, 8:22 AM",
          "commitName": "74ff198bd249a56d1349b963bd265f8899743b9b",
          "commitAuthor": "Gilles Sadowski",
          "commitDateOld": "11/20/10, 1:01 PM",
          "commitNameOld": "8302dd02498495277ec0db9301edb2158bb0e314",
          "commitAuthorOld": "Luc Maisonobe",
          "daysBetweenCommits": 4.81,
          "commitsBetweenForRepo": 8,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\nprotected double doSolve() {\n    double min \u003d getMin();\n    double max \u003d getMax();\n    verifyInterval(min, max);\n    final double functionValueAccuracy \u003d getFunctionValueAccuracy();\n    double x0 \u003d min;\n    double x1 \u003d max;\n    double y0 \u003d computeObjectiveValue(x0);\n    if (FastMath.abs(y0) \u003c\u003d functionValueAccuracy) {\n        return x0;\n    }\n    double y1 \u003d computeObjectiveValue(x1);\n    if (FastMath.abs(y1) \u003c\u003d functionValueAccuracy) {\n        return x1;\n    }\n    if (y0 * y1 \u003e\u003d 0) {\n        throw new NoBracketingException(min, max, y0, y1);\n    }\n    final double absoluteAccuracy \u003d getAbsoluteAccuracy();\n    final double relativeAccuracy \u003d getRelativeAccuracy();\n    double x2 \u003d x0;\n    double y2 \u003d y0;\n    double oldDelta \u003d x2 - x1;\n    while (true) {\n        if (FastMath.abs(y2) \u003c FastMath.abs(y1)) {\n            x0 \u003d x1;\n            x1 \u003d x2;\n            x2 \u003d x0;\n            y0 \u003d y1;\n            y1 \u003d y2;\n            y2 \u003d y0;\n        }\n        if (FastMath.abs(y1) \u003c\u003d functionValueAccuracy) {\n            return x1;\n        }\n        if (FastMath.abs(oldDelta) \u003c FastMath.max(relativeAccuracy * FastMath.abs(x1), absoluteAccuracy)) {\n            return x1;\n        }\n        double delta;\n        if (FastMath.abs(y1) \u003e FastMath.abs(y0)) {\n            delta \u003d 0.5 * oldDelta;\n        } else {\n            delta \u003d (x0 - x1) / (1 - y0 / y1);\n            if (delta / oldDelta \u003e 1) {\n                delta \u003d 0.5 * oldDelta;\n            }\n        }\n        x0 \u003d x1;\n        y0 \u003d y1;\n        x1 \u003d x1 + delta;\n        y1 \u003d computeObjectiveValue(x1);\n        if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n            x2 \u003d x0;\n            y2 \u003d y0;\n        }\n        oldDelta \u003d x2 - x1;\n    }\n}",
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/SecantSolver.java",
          "functionStartLine": 72,
          "functionName": "doSolve",
          "functionAnnotation": "@Override",
          "functionDoc": "@inheritDoc}\n",
          "diff": "@@ -1,53 +1,59 @@\n-public double solve(final UnivariateRealFunction f, final double min, final double max) throws MaxIterationsExceededException, MathUserException {\n-    clearResult();\n+@Override\n+protected double doSolve() {\n+    double min \u003d getMin();\n+    double max \u003d getMax();\n     verifyInterval(min, max);\n+    final double functionValueAccuracy \u003d getFunctionValueAccuracy();\n     double x0 \u003d min;\n     double x1 \u003d max;\n-    double y0 \u003d f.value(x0);\n-    double y1 \u003d f.value(x1);\n-    if (y0 * y1 \u003e\u003d 0) {\n-        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.SAME_SIGN_AT_ENDPOINTS, min, max, y0, y1);\n+    double y0 \u003d computeObjectiveValue(x0);\n+    if (FastMath.abs(y0) \u003c\u003d functionValueAccuracy) {\n+        return x0;\n     }\n+    double y1 \u003d computeObjectiveValue(x1);\n+    if (FastMath.abs(y1) \u003c\u003d functionValueAccuracy) {\n+        return x1;\n+    }\n+    if (y0 * y1 \u003e\u003d 0) {\n+        throw new NoBracketingException(min, max, y0, y1);\n+    }\n+    final double absoluteAccuracy \u003d getAbsoluteAccuracy();\n+    final double relativeAccuracy \u003d getRelativeAccuracy();\n     double x2 \u003d x0;\n     double y2 \u003d y0;\n     double oldDelta \u003d x2 - x1;\n-    int i \u003d 0;\n-    while (i \u003c maximalIterationCount) {\n+    while (true) {\n         if (FastMath.abs(y2) \u003c FastMath.abs(y1)) {\n             x0 \u003d x1;\n             x1 \u003d x2;\n             x2 \u003d x0;\n             y0 \u003d y1;\n             y1 \u003d y2;\n             y2 \u003d y0;\n         }\n         if (FastMath.abs(y1) \u003c\u003d functionValueAccuracy) {\n-            setResult(x1, i);\n-            return result;\n+            return x1;\n         }\n         if (FastMath.abs(oldDelta) \u003c FastMath.max(relativeAccuracy * FastMath.abs(x1), absoluteAccuracy)) {\n-            setResult(x1, i);\n-            return result;\n+            return x1;\n         }\n         double delta;\n         if (FastMath.abs(y1) \u003e FastMath.abs(y0)) {\n             delta \u003d 0.5 * oldDelta;\n         } else {\n             delta \u003d (x0 - x1) / (1 - y0 / y1);\n             if (delta / oldDelta \u003e 1) {\n                 delta \u003d 0.5 * oldDelta;\n             }\n         }\n         x0 \u003d x1;\n         y0 \u003d y1;\n         x1 \u003d x1 + delta;\n-        y1 \u003d f.value(x1);\n+        y1 \u003d computeObjectiveValue(x1);\n         if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n             x2 \u003d x0;\n             y2 \u003d y0;\n         }\n         oldDelta \u003d x2 - x1;\n-        i++;\n     }\n-    throw new MaxIterationsExceededException(maximalIterationCount);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "solve",
            "newValue": "doSolve"
          }
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "MATH-439\nRefactored the \"solvers\" package. Implementations refer to number of\nevaluation of the objective function (instead of the number of iterations).\nNew interfaces and base classes.\n\"NewtonSolver\" fits in the design without resorting to a cast.\nCreated class \"MullerSolver2\" to contain the code of the method named \"solve2\"\nin class \"MullerSolver\".\nRemoved \"UnivariateRealSolverFactory\" and \"UnivariateRealSolverFactoryImpl\".\nDefault solver in \"UnivariateRealSolverUtils\" is explicitely instantiated.\n\"AbstractContinuousDistribution\": Type of exception thrown changed in\n\"UnivariateRealSolverUtils\".\nFactored out duplicate code (in \"GaussNewtonOptimizerTest\" and\n\"LevenbergMarquardtOptimizerTest\"): class \"Circle\" is now called\n\"CircleVectorial\". Also factored out the \"Circle\" class from\n\"NonLinearConjugateGradientOptimizerTest\": class is named \"CircleScalar\".\nCreated \"SecantSolverTest\", moving there all the tests for the class\n\"SecantSolver\" that were located in class \"BrentSolverTest\".\nCreated new interface and base class for polynomial functions solvers\n(\"LaguerreSolver\") so that the function type is now checked at compile time.\nRemoved deprecated exceptions (MATH-441).\nJavadoc clean-up.\nLowered tolerance values in some unit tests.\nTests upgraded to Junit 4 (MATH-423).\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@1039083 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "11/25/10, 8:22 AM",
          "commitName": "74ff198bd249a56d1349b963bd265f8899743b9b",
          "commitAuthor": "Gilles Sadowski",
          "commitDateOld": "11/20/10, 1:01 PM",
          "commitNameOld": "8302dd02498495277ec0db9301edb2158bb0e314",
          "commitAuthorOld": "Luc Maisonobe",
          "daysBetweenCommits": 4.81,
          "commitsBetweenForRepo": 8,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\nprotected double doSolve() {\n    double min \u003d getMin();\n    double max \u003d getMax();\n    verifyInterval(min, max);\n    final double functionValueAccuracy \u003d getFunctionValueAccuracy();\n    double x0 \u003d min;\n    double x1 \u003d max;\n    double y0 \u003d computeObjectiveValue(x0);\n    if (FastMath.abs(y0) \u003c\u003d functionValueAccuracy) {\n        return x0;\n    }\n    double y1 \u003d computeObjectiveValue(x1);\n    if (FastMath.abs(y1) \u003c\u003d functionValueAccuracy) {\n        return x1;\n    }\n    if (y0 * y1 \u003e\u003d 0) {\n        throw new NoBracketingException(min, max, y0, y1);\n    }\n    final double absoluteAccuracy \u003d getAbsoluteAccuracy();\n    final double relativeAccuracy \u003d getRelativeAccuracy();\n    double x2 \u003d x0;\n    double y2 \u003d y0;\n    double oldDelta \u003d x2 - x1;\n    while (true) {\n        if (FastMath.abs(y2) \u003c FastMath.abs(y1)) {\n            x0 \u003d x1;\n            x1 \u003d x2;\n            x2 \u003d x0;\n            y0 \u003d y1;\n            y1 \u003d y2;\n            y2 \u003d y0;\n        }\n        if (FastMath.abs(y1) \u003c\u003d functionValueAccuracy) {\n            return x1;\n        }\n        if (FastMath.abs(oldDelta) \u003c FastMath.max(relativeAccuracy * FastMath.abs(x1), absoluteAccuracy)) {\n            return x1;\n        }\n        double delta;\n        if (FastMath.abs(y1) \u003e FastMath.abs(y0)) {\n            delta \u003d 0.5 * oldDelta;\n        } else {\n            delta \u003d (x0 - x1) / (1 - y0 / y1);\n            if (delta / oldDelta \u003e 1) {\n                delta \u003d 0.5 * oldDelta;\n            }\n        }\n        x0 \u003d x1;\n        y0 \u003d y1;\n        x1 \u003d x1 + delta;\n        y1 \u003d computeObjectiveValue(x1);\n        if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n            x2 \u003d x0;\n            y2 \u003d y0;\n        }\n        oldDelta \u003d x2 - x1;\n    }\n}",
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/SecantSolver.java",
          "functionStartLine": 72,
          "functionName": "doSolve",
          "functionAnnotation": "@Override",
          "functionDoc": "@inheritDoc}\n",
          "diff": "@@ -1,53 +1,59 @@\n-public double solve(final UnivariateRealFunction f, final double min, final double max) throws MaxIterationsExceededException, MathUserException {\n-    clearResult();\n+@Override\n+protected double doSolve() {\n+    double min \u003d getMin();\n+    double max \u003d getMax();\n     verifyInterval(min, max);\n+    final double functionValueAccuracy \u003d getFunctionValueAccuracy();\n     double x0 \u003d min;\n     double x1 \u003d max;\n-    double y0 \u003d f.value(x0);\n-    double y1 \u003d f.value(x1);\n-    if (y0 * y1 \u003e\u003d 0) {\n-        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.SAME_SIGN_AT_ENDPOINTS, min, max, y0, y1);\n+    double y0 \u003d computeObjectiveValue(x0);\n+    if (FastMath.abs(y0) \u003c\u003d functionValueAccuracy) {\n+        return x0;\n     }\n+    double y1 \u003d computeObjectiveValue(x1);\n+    if (FastMath.abs(y1) \u003c\u003d functionValueAccuracy) {\n+        return x1;\n+    }\n+    if (y0 * y1 \u003e\u003d 0) {\n+        throw new NoBracketingException(min, max, y0, y1);\n+    }\n+    final double absoluteAccuracy \u003d getAbsoluteAccuracy();\n+    final double relativeAccuracy \u003d getRelativeAccuracy();\n     double x2 \u003d x0;\n     double y2 \u003d y0;\n     double oldDelta \u003d x2 - x1;\n-    int i \u003d 0;\n-    while (i \u003c maximalIterationCount) {\n+    while (true) {\n         if (FastMath.abs(y2) \u003c FastMath.abs(y1)) {\n             x0 \u003d x1;\n             x1 \u003d x2;\n             x2 \u003d x0;\n             y0 \u003d y1;\n             y1 \u003d y2;\n             y2 \u003d y0;\n         }\n         if (FastMath.abs(y1) \u003c\u003d functionValueAccuracy) {\n-            setResult(x1, i);\n-            return result;\n+            return x1;\n         }\n         if (FastMath.abs(oldDelta) \u003c FastMath.max(relativeAccuracy * FastMath.abs(x1), absoluteAccuracy)) {\n-            setResult(x1, i);\n-            return result;\n+            return x1;\n         }\n         double delta;\n         if (FastMath.abs(y1) \u003e FastMath.abs(y0)) {\n             delta \u003d 0.5 * oldDelta;\n         } else {\n             delta \u003d (x0 - x1) / (1 - y0 / y1);\n             if (delta / oldDelta \u003e 1) {\n                 delta \u003d 0.5 * oldDelta;\n             }\n         }\n         x0 \u003d x1;\n         y0 \u003d y1;\n         x1 \u003d x1 + delta;\n-        y1 \u003d f.value(x1);\n+        y1 \u003d computeObjectiveValue(x1);\n         if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n             x2 \u003d x0;\n             y2 \u003d y0;\n         }\n         oldDelta \u003d x2 - x1;\n-        i++;\n     }\n-    throw new MaxIterationsExceededException(maximalIterationCount);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[f-UnivariateRealFunction(modifiers-final), min-double(modifiers-final), max-double(modifiers-final)]",
            "newValue": "[]"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "MATH-439\nRefactored the \"solvers\" package. Implementations refer to number of\nevaluation of the objective function (instead of the number of iterations).\nNew interfaces and base classes.\n\"NewtonSolver\" fits in the design without resorting to a cast.\nCreated class \"MullerSolver2\" to contain the code of the method named \"solve2\"\nin class \"MullerSolver\".\nRemoved \"UnivariateRealSolverFactory\" and \"UnivariateRealSolverFactoryImpl\".\nDefault solver in \"UnivariateRealSolverUtils\" is explicitely instantiated.\n\"AbstractContinuousDistribution\": Type of exception thrown changed in\n\"UnivariateRealSolverUtils\".\nFactored out duplicate code (in \"GaussNewtonOptimizerTest\" and\n\"LevenbergMarquardtOptimizerTest\"): class \"Circle\" is now called\n\"CircleVectorial\". Also factored out the \"Circle\" class from\n\"NonLinearConjugateGradientOptimizerTest\": class is named \"CircleScalar\".\nCreated \"SecantSolverTest\", moving there all the tests for the class\n\"SecantSolver\" that were located in class \"BrentSolverTest\".\nCreated new interface and base class for polynomial functions solvers\n(\"LaguerreSolver\") so that the function type is now checked at compile time.\nRemoved deprecated exceptions (MATH-441).\nJavadoc clean-up.\nLowered tolerance values in some unit tests.\nTests upgraded to Junit 4 (MATH-423).\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@1039083 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "11/25/10, 8:22 AM",
          "commitName": "74ff198bd249a56d1349b963bd265f8899743b9b",
          "commitAuthor": "Gilles Sadowski",
          "commitDateOld": "11/20/10, 1:01 PM",
          "commitNameOld": "8302dd02498495277ec0db9301edb2158bb0e314",
          "commitAuthorOld": "Luc Maisonobe",
          "daysBetweenCommits": 4.81,
          "commitsBetweenForRepo": 8,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\nprotected double doSolve() {\n    double min \u003d getMin();\n    double max \u003d getMax();\n    verifyInterval(min, max);\n    final double functionValueAccuracy \u003d getFunctionValueAccuracy();\n    double x0 \u003d min;\n    double x1 \u003d max;\n    double y0 \u003d computeObjectiveValue(x0);\n    if (FastMath.abs(y0) \u003c\u003d functionValueAccuracy) {\n        return x0;\n    }\n    double y1 \u003d computeObjectiveValue(x1);\n    if (FastMath.abs(y1) \u003c\u003d functionValueAccuracy) {\n        return x1;\n    }\n    if (y0 * y1 \u003e\u003d 0) {\n        throw new NoBracketingException(min, max, y0, y1);\n    }\n    final double absoluteAccuracy \u003d getAbsoluteAccuracy();\n    final double relativeAccuracy \u003d getRelativeAccuracy();\n    double x2 \u003d x0;\n    double y2 \u003d y0;\n    double oldDelta \u003d x2 - x1;\n    while (true) {\n        if (FastMath.abs(y2) \u003c FastMath.abs(y1)) {\n            x0 \u003d x1;\n            x1 \u003d x2;\n            x2 \u003d x0;\n            y0 \u003d y1;\n            y1 \u003d y2;\n            y2 \u003d y0;\n        }\n        if (FastMath.abs(y1) \u003c\u003d functionValueAccuracy) {\n            return x1;\n        }\n        if (FastMath.abs(oldDelta) \u003c FastMath.max(relativeAccuracy * FastMath.abs(x1), absoluteAccuracy)) {\n            return x1;\n        }\n        double delta;\n        if (FastMath.abs(y1) \u003e FastMath.abs(y0)) {\n            delta \u003d 0.5 * oldDelta;\n        } else {\n            delta \u003d (x0 - x1) / (1 - y0 / y1);\n            if (delta / oldDelta \u003e 1) {\n                delta \u003d 0.5 * oldDelta;\n            }\n        }\n        x0 \u003d x1;\n        y0 \u003d y1;\n        x1 \u003d x1 + delta;\n        y1 \u003d computeObjectiveValue(x1);\n        if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n            x2 \u003d x0;\n            y2 \u003d y0;\n        }\n        oldDelta \u003d x2 - x1;\n    }\n}",
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/SecantSolver.java",
          "functionStartLine": 72,
          "functionName": "doSolve",
          "functionAnnotation": "@Override",
          "functionDoc": "@inheritDoc}\n",
          "diff": "@@ -1,53 +1,59 @@\n-public double solve(final UnivariateRealFunction f, final double min, final double max) throws MaxIterationsExceededException, MathUserException {\n-    clearResult();\n+@Override\n+protected double doSolve() {\n+    double min \u003d getMin();\n+    double max \u003d getMax();\n     verifyInterval(min, max);\n+    final double functionValueAccuracy \u003d getFunctionValueAccuracy();\n     double x0 \u003d min;\n     double x1 \u003d max;\n-    double y0 \u003d f.value(x0);\n-    double y1 \u003d f.value(x1);\n-    if (y0 * y1 \u003e\u003d 0) {\n-        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.SAME_SIGN_AT_ENDPOINTS, min, max, y0, y1);\n+    double y0 \u003d computeObjectiveValue(x0);\n+    if (FastMath.abs(y0) \u003c\u003d functionValueAccuracy) {\n+        return x0;\n     }\n+    double y1 \u003d computeObjectiveValue(x1);\n+    if (FastMath.abs(y1) \u003c\u003d functionValueAccuracy) {\n+        return x1;\n+    }\n+    if (y0 * y1 \u003e\u003d 0) {\n+        throw new NoBracketingException(min, max, y0, y1);\n+    }\n+    final double absoluteAccuracy \u003d getAbsoluteAccuracy();\n+    final double relativeAccuracy \u003d getRelativeAccuracy();\n     double x2 \u003d x0;\n     double y2 \u003d y0;\n     double oldDelta \u003d x2 - x1;\n-    int i \u003d 0;\n-    while (i \u003c maximalIterationCount) {\n+    while (true) {\n         if (FastMath.abs(y2) \u003c FastMath.abs(y1)) {\n             x0 \u003d x1;\n             x1 \u003d x2;\n             x2 \u003d x0;\n             y0 \u003d y1;\n             y1 \u003d y2;\n             y2 \u003d y0;\n         }\n         if (FastMath.abs(y1) \u003c\u003d functionValueAccuracy) {\n-            setResult(x1, i);\n-            return result;\n+            return x1;\n         }\n         if (FastMath.abs(oldDelta) \u003c FastMath.max(relativeAccuracy * FastMath.abs(x1), absoluteAccuracy)) {\n-            setResult(x1, i);\n-            return result;\n+            return x1;\n         }\n         double delta;\n         if (FastMath.abs(y1) \u003e FastMath.abs(y0)) {\n             delta \u003d 0.5 * oldDelta;\n         } else {\n             delta \u003d (x0 - x1) / (1 - y0 / y1);\n             if (delta / oldDelta \u003e 1) {\n                 delta \u003d 0.5 * oldDelta;\n             }\n         }\n         x0 \u003d x1;\n         y0 \u003d y1;\n         x1 \u003d x1 + delta;\n-        y1 \u003d f.value(x1);\n+        y1 \u003d computeObjectiveValue(x1);\n         if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n             x2 \u003d x0;\n             y2 \u003d y0;\n         }\n         oldDelta \u003d x2 - x1;\n-        i++;\n     }\n-    throw new MaxIterationsExceededException(maximalIterationCount);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[public]",
            "newValue": "[protected]"
          }
        },
        {
          "type": "Yexceptionschange",
          "commitMessage": "MATH-439\nRefactored the \"solvers\" package. Implementations refer to number of\nevaluation of the objective function (instead of the number of iterations).\nNew interfaces and base classes.\n\"NewtonSolver\" fits in the design without resorting to a cast.\nCreated class \"MullerSolver2\" to contain the code of the method named \"solve2\"\nin class \"MullerSolver\".\nRemoved \"UnivariateRealSolverFactory\" and \"UnivariateRealSolverFactoryImpl\".\nDefault solver in \"UnivariateRealSolverUtils\" is explicitely instantiated.\n\"AbstractContinuousDistribution\": Type of exception thrown changed in\n\"UnivariateRealSolverUtils\".\nFactored out duplicate code (in \"GaussNewtonOptimizerTest\" and\n\"LevenbergMarquardtOptimizerTest\"): class \"Circle\" is now called\n\"CircleVectorial\". Also factored out the \"Circle\" class from\n\"NonLinearConjugateGradientOptimizerTest\": class is named \"CircleScalar\".\nCreated \"SecantSolverTest\", moving there all the tests for the class\n\"SecantSolver\" that were located in class \"BrentSolverTest\".\nCreated new interface and base class for polynomial functions solvers\n(\"LaguerreSolver\") so that the function type is now checked at compile time.\nRemoved deprecated exceptions (MATH-441).\nJavadoc clean-up.\nLowered tolerance values in some unit tests.\nTests upgraded to Junit 4 (MATH-423).\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@1039083 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "11/25/10, 8:22 AM",
          "commitName": "74ff198bd249a56d1349b963bd265f8899743b9b",
          "commitAuthor": "Gilles Sadowski",
          "commitDateOld": "11/20/10, 1:01 PM",
          "commitNameOld": "8302dd02498495277ec0db9301edb2158bb0e314",
          "commitAuthorOld": "Luc Maisonobe",
          "daysBetweenCommits": 4.81,
          "commitsBetweenForRepo": 8,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\nprotected double doSolve() {\n    double min \u003d getMin();\n    double max \u003d getMax();\n    verifyInterval(min, max);\n    final double functionValueAccuracy \u003d getFunctionValueAccuracy();\n    double x0 \u003d min;\n    double x1 \u003d max;\n    double y0 \u003d computeObjectiveValue(x0);\n    if (FastMath.abs(y0) \u003c\u003d functionValueAccuracy) {\n        return x0;\n    }\n    double y1 \u003d computeObjectiveValue(x1);\n    if (FastMath.abs(y1) \u003c\u003d functionValueAccuracy) {\n        return x1;\n    }\n    if (y0 * y1 \u003e\u003d 0) {\n        throw new NoBracketingException(min, max, y0, y1);\n    }\n    final double absoluteAccuracy \u003d getAbsoluteAccuracy();\n    final double relativeAccuracy \u003d getRelativeAccuracy();\n    double x2 \u003d x0;\n    double y2 \u003d y0;\n    double oldDelta \u003d x2 - x1;\n    while (true) {\n        if (FastMath.abs(y2) \u003c FastMath.abs(y1)) {\n            x0 \u003d x1;\n            x1 \u003d x2;\n            x2 \u003d x0;\n            y0 \u003d y1;\n            y1 \u003d y2;\n            y2 \u003d y0;\n        }\n        if (FastMath.abs(y1) \u003c\u003d functionValueAccuracy) {\n            return x1;\n        }\n        if (FastMath.abs(oldDelta) \u003c FastMath.max(relativeAccuracy * FastMath.abs(x1), absoluteAccuracy)) {\n            return x1;\n        }\n        double delta;\n        if (FastMath.abs(y1) \u003e FastMath.abs(y0)) {\n            delta \u003d 0.5 * oldDelta;\n        } else {\n            delta \u003d (x0 - x1) / (1 - y0 / y1);\n            if (delta / oldDelta \u003e 1) {\n                delta \u003d 0.5 * oldDelta;\n            }\n        }\n        x0 \u003d x1;\n        y0 \u003d y1;\n        x1 \u003d x1 + delta;\n        y1 \u003d computeObjectiveValue(x1);\n        if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n            x2 \u003d x0;\n            y2 \u003d y0;\n        }\n        oldDelta \u003d x2 - x1;\n    }\n}",
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/SecantSolver.java",
          "functionStartLine": 72,
          "functionName": "doSolve",
          "functionAnnotation": "@Override",
          "functionDoc": "@inheritDoc}\n",
          "diff": "@@ -1,53 +1,59 @@\n-public double solve(final UnivariateRealFunction f, final double min, final double max) throws MaxIterationsExceededException, MathUserException {\n-    clearResult();\n+@Override\n+protected double doSolve() {\n+    double min \u003d getMin();\n+    double max \u003d getMax();\n     verifyInterval(min, max);\n+    final double functionValueAccuracy \u003d getFunctionValueAccuracy();\n     double x0 \u003d min;\n     double x1 \u003d max;\n-    double y0 \u003d f.value(x0);\n-    double y1 \u003d f.value(x1);\n-    if (y0 * y1 \u003e\u003d 0) {\n-        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.SAME_SIGN_AT_ENDPOINTS, min, max, y0, y1);\n+    double y0 \u003d computeObjectiveValue(x0);\n+    if (FastMath.abs(y0) \u003c\u003d functionValueAccuracy) {\n+        return x0;\n     }\n+    double y1 \u003d computeObjectiveValue(x1);\n+    if (FastMath.abs(y1) \u003c\u003d functionValueAccuracy) {\n+        return x1;\n+    }\n+    if (y0 * y1 \u003e\u003d 0) {\n+        throw new NoBracketingException(min, max, y0, y1);\n+    }\n+    final double absoluteAccuracy \u003d getAbsoluteAccuracy();\n+    final double relativeAccuracy \u003d getRelativeAccuracy();\n     double x2 \u003d x0;\n     double y2 \u003d y0;\n     double oldDelta \u003d x2 - x1;\n-    int i \u003d 0;\n-    while (i \u003c maximalIterationCount) {\n+    while (true) {\n         if (FastMath.abs(y2) \u003c FastMath.abs(y1)) {\n             x0 \u003d x1;\n             x1 \u003d x2;\n             x2 \u003d x0;\n             y0 \u003d y1;\n             y1 \u003d y2;\n             y2 \u003d y0;\n         }\n         if (FastMath.abs(y1) \u003c\u003d functionValueAccuracy) {\n-            setResult(x1, i);\n-            return result;\n+            return x1;\n         }\n         if (FastMath.abs(oldDelta) \u003c FastMath.max(relativeAccuracy * FastMath.abs(x1), absoluteAccuracy)) {\n-            setResult(x1, i);\n-            return result;\n+            return x1;\n         }\n         double delta;\n         if (FastMath.abs(y1) \u003e FastMath.abs(y0)) {\n             delta \u003d 0.5 * oldDelta;\n         } else {\n             delta \u003d (x0 - x1) / (1 - y0 / y1);\n             if (delta / oldDelta \u003e 1) {\n                 delta \u003d 0.5 * oldDelta;\n             }\n         }\n         x0 \u003d x1;\n         y0 \u003d y1;\n         x1 \u003d x1 + delta;\n-        y1 \u003d f.value(x1);\n+        y1 \u003d computeObjectiveValue(x1);\n         if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n             x2 \u003d x0;\n             y2 \u003d y0;\n         }\n         oldDelta \u003d x2 - x1;\n-        i++;\n     }\n-    throw new MaxIterationsExceededException(maximalIterationCount);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[MaxIterationsExceededException, MathUserException]",
            "newValue": "[]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "MATH-439\nRefactored the \"solvers\" package. Implementations refer to number of\nevaluation of the objective function (instead of the number of iterations).\nNew interfaces and base classes.\n\"NewtonSolver\" fits in the design without resorting to a cast.\nCreated class \"MullerSolver2\" to contain the code of the method named \"solve2\"\nin class \"MullerSolver\".\nRemoved \"UnivariateRealSolverFactory\" and \"UnivariateRealSolverFactoryImpl\".\nDefault solver in \"UnivariateRealSolverUtils\" is explicitely instantiated.\n\"AbstractContinuousDistribution\": Type of exception thrown changed in\n\"UnivariateRealSolverUtils\".\nFactored out duplicate code (in \"GaussNewtonOptimizerTest\" and\n\"LevenbergMarquardtOptimizerTest\"): class \"Circle\" is now called\n\"CircleVectorial\". Also factored out the \"Circle\" class from\n\"NonLinearConjugateGradientOptimizerTest\": class is named \"CircleScalar\".\nCreated \"SecantSolverTest\", moving there all the tests for the class\n\"SecantSolver\" that were located in class \"BrentSolverTest\".\nCreated new interface and base class for polynomial functions solvers\n(\"LaguerreSolver\") so that the function type is now checked at compile time.\nRemoved deprecated exceptions (MATH-441).\nJavadoc clean-up.\nLowered tolerance values in some unit tests.\nTests upgraded to Junit 4 (MATH-423).\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@1039083 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "11/25/10, 8:22 AM",
          "commitName": "74ff198bd249a56d1349b963bd265f8899743b9b",
          "commitAuthor": "Gilles Sadowski",
          "commitDateOld": "11/20/10, 1:01 PM",
          "commitNameOld": "8302dd02498495277ec0db9301edb2158bb0e314",
          "commitAuthorOld": "Luc Maisonobe",
          "daysBetweenCommits": 4.81,
          "commitsBetweenForRepo": 8,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\nprotected double doSolve() {\n    double min \u003d getMin();\n    double max \u003d getMax();\n    verifyInterval(min, max);\n    final double functionValueAccuracy \u003d getFunctionValueAccuracy();\n    double x0 \u003d min;\n    double x1 \u003d max;\n    double y0 \u003d computeObjectiveValue(x0);\n    if (FastMath.abs(y0) \u003c\u003d functionValueAccuracy) {\n        return x0;\n    }\n    double y1 \u003d computeObjectiveValue(x1);\n    if (FastMath.abs(y1) \u003c\u003d functionValueAccuracy) {\n        return x1;\n    }\n    if (y0 * y1 \u003e\u003d 0) {\n        throw new NoBracketingException(min, max, y0, y1);\n    }\n    final double absoluteAccuracy \u003d getAbsoluteAccuracy();\n    final double relativeAccuracy \u003d getRelativeAccuracy();\n    double x2 \u003d x0;\n    double y2 \u003d y0;\n    double oldDelta \u003d x2 - x1;\n    while (true) {\n        if (FastMath.abs(y2) \u003c FastMath.abs(y1)) {\n            x0 \u003d x1;\n            x1 \u003d x2;\n            x2 \u003d x0;\n            y0 \u003d y1;\n            y1 \u003d y2;\n            y2 \u003d y0;\n        }\n        if (FastMath.abs(y1) \u003c\u003d functionValueAccuracy) {\n            return x1;\n        }\n        if (FastMath.abs(oldDelta) \u003c FastMath.max(relativeAccuracy * FastMath.abs(x1), absoluteAccuracy)) {\n            return x1;\n        }\n        double delta;\n        if (FastMath.abs(y1) \u003e FastMath.abs(y0)) {\n            delta \u003d 0.5 * oldDelta;\n        } else {\n            delta \u003d (x0 - x1) / (1 - y0 / y1);\n            if (delta / oldDelta \u003e 1) {\n                delta \u003d 0.5 * oldDelta;\n            }\n        }\n        x0 \u003d x1;\n        y0 \u003d y1;\n        x1 \u003d x1 + delta;\n        y1 \u003d computeObjectiveValue(x1);\n        if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n            x2 \u003d x0;\n            y2 \u003d y0;\n        }\n        oldDelta \u003d x2 - x1;\n    }\n}",
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/SecantSolver.java",
          "functionStartLine": 72,
          "functionName": "doSolve",
          "functionAnnotation": "@Override",
          "functionDoc": "@inheritDoc}\n",
          "diff": "@@ -1,53 +1,59 @@\n-public double solve(final UnivariateRealFunction f, final double min, final double max) throws MaxIterationsExceededException, MathUserException {\n-    clearResult();\n+@Override\n+protected double doSolve() {\n+    double min \u003d getMin();\n+    double max \u003d getMax();\n     verifyInterval(min, max);\n+    final double functionValueAccuracy \u003d getFunctionValueAccuracy();\n     double x0 \u003d min;\n     double x1 \u003d max;\n-    double y0 \u003d f.value(x0);\n-    double y1 \u003d f.value(x1);\n-    if (y0 * y1 \u003e\u003d 0) {\n-        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.SAME_SIGN_AT_ENDPOINTS, min, max, y0, y1);\n+    double y0 \u003d computeObjectiveValue(x0);\n+    if (FastMath.abs(y0) \u003c\u003d functionValueAccuracy) {\n+        return x0;\n     }\n+    double y1 \u003d computeObjectiveValue(x1);\n+    if (FastMath.abs(y1) \u003c\u003d functionValueAccuracy) {\n+        return x1;\n+    }\n+    if (y0 * y1 \u003e\u003d 0) {\n+        throw new NoBracketingException(min, max, y0, y1);\n+    }\n+    final double absoluteAccuracy \u003d getAbsoluteAccuracy();\n+    final double relativeAccuracy \u003d getRelativeAccuracy();\n     double x2 \u003d x0;\n     double y2 \u003d y0;\n     double oldDelta \u003d x2 - x1;\n-    int i \u003d 0;\n-    while (i \u003c maximalIterationCount) {\n+    while (true) {\n         if (FastMath.abs(y2) \u003c FastMath.abs(y1)) {\n             x0 \u003d x1;\n             x1 \u003d x2;\n             x2 \u003d x0;\n             y0 \u003d y1;\n             y1 \u003d y2;\n             y2 \u003d y0;\n         }\n         if (FastMath.abs(y1) \u003c\u003d functionValueAccuracy) {\n-            setResult(x1, i);\n-            return result;\n+            return x1;\n         }\n         if (FastMath.abs(oldDelta) \u003c FastMath.max(relativeAccuracy * FastMath.abs(x1), absoluteAccuracy)) {\n-            setResult(x1, i);\n-            return result;\n+            return x1;\n         }\n         double delta;\n         if (FastMath.abs(y1) \u003e FastMath.abs(y0)) {\n             delta \u003d 0.5 * oldDelta;\n         } else {\n             delta \u003d (x0 - x1) / (1 - y0 / y1);\n             if (delta / oldDelta \u003e 1) {\n                 delta \u003d 0.5 * oldDelta;\n             }\n         }\n         x0 \u003d x1;\n         y0 \u003d y1;\n         x1 \u003d x1 + delta;\n-        y1 \u003d f.value(x1);\n+        y1 \u003d computeObjectiveValue(x1);\n         if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n             x2 \u003d x0;\n             y2 \u003d y0;\n         }\n         oldDelta \u003d x2 - x1;\n-        i++;\n     }\n-    throw new MaxIterationsExceededException(maximalIterationCount);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Yannotationchange",
          "commitMessage": "MATH-439\nRefactored the \"solvers\" package. Implementations refer to number of\nevaluation of the objective function (instead of the number of iterations).\nNew interfaces and base classes.\n\"NewtonSolver\" fits in the design without resorting to a cast.\nCreated class \"MullerSolver2\" to contain the code of the method named \"solve2\"\nin class \"MullerSolver\".\nRemoved \"UnivariateRealSolverFactory\" and \"UnivariateRealSolverFactoryImpl\".\nDefault solver in \"UnivariateRealSolverUtils\" is explicitely instantiated.\n\"AbstractContinuousDistribution\": Type of exception thrown changed in\n\"UnivariateRealSolverUtils\".\nFactored out duplicate code (in \"GaussNewtonOptimizerTest\" and\n\"LevenbergMarquardtOptimizerTest\"): class \"Circle\" is now called\n\"CircleVectorial\". Also factored out the \"Circle\" class from\n\"NonLinearConjugateGradientOptimizerTest\": class is named \"CircleScalar\".\nCreated \"SecantSolverTest\", moving there all the tests for the class\n\"SecantSolver\" that were located in class \"BrentSolverTest\".\nCreated new interface and base class for polynomial functions solvers\n(\"LaguerreSolver\") so that the function type is now checked at compile time.\nRemoved deprecated exceptions (MATH-441).\nJavadoc clean-up.\nLowered tolerance values in some unit tests.\nTests upgraded to Junit 4 (MATH-423).\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@1039083 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "11/25/10, 8:22 AM",
          "commitName": "74ff198bd249a56d1349b963bd265f8899743b9b",
          "commitAuthor": "Gilles Sadowski",
          "commitDateOld": "11/20/10, 1:01 PM",
          "commitNameOld": "8302dd02498495277ec0db9301edb2158bb0e314",
          "commitAuthorOld": "Luc Maisonobe",
          "daysBetweenCommits": 4.81,
          "commitsBetweenForRepo": 8,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\nprotected double doSolve() {\n    double min \u003d getMin();\n    double max \u003d getMax();\n    verifyInterval(min, max);\n    final double functionValueAccuracy \u003d getFunctionValueAccuracy();\n    double x0 \u003d min;\n    double x1 \u003d max;\n    double y0 \u003d computeObjectiveValue(x0);\n    if (FastMath.abs(y0) \u003c\u003d functionValueAccuracy) {\n        return x0;\n    }\n    double y1 \u003d computeObjectiveValue(x1);\n    if (FastMath.abs(y1) \u003c\u003d functionValueAccuracy) {\n        return x1;\n    }\n    if (y0 * y1 \u003e\u003d 0) {\n        throw new NoBracketingException(min, max, y0, y1);\n    }\n    final double absoluteAccuracy \u003d getAbsoluteAccuracy();\n    final double relativeAccuracy \u003d getRelativeAccuracy();\n    double x2 \u003d x0;\n    double y2 \u003d y0;\n    double oldDelta \u003d x2 - x1;\n    while (true) {\n        if (FastMath.abs(y2) \u003c FastMath.abs(y1)) {\n            x0 \u003d x1;\n            x1 \u003d x2;\n            x2 \u003d x0;\n            y0 \u003d y1;\n            y1 \u003d y2;\n            y2 \u003d y0;\n        }\n        if (FastMath.abs(y1) \u003c\u003d functionValueAccuracy) {\n            return x1;\n        }\n        if (FastMath.abs(oldDelta) \u003c FastMath.max(relativeAccuracy * FastMath.abs(x1), absoluteAccuracy)) {\n            return x1;\n        }\n        double delta;\n        if (FastMath.abs(y1) \u003e FastMath.abs(y0)) {\n            delta \u003d 0.5 * oldDelta;\n        } else {\n            delta \u003d (x0 - x1) / (1 - y0 / y1);\n            if (delta / oldDelta \u003e 1) {\n                delta \u003d 0.5 * oldDelta;\n            }\n        }\n        x0 \u003d x1;\n        y0 \u003d y1;\n        x1 \u003d x1 + delta;\n        y1 \u003d computeObjectiveValue(x1);\n        if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n            x2 \u003d x0;\n            y2 \u003d y0;\n        }\n        oldDelta \u003d x2 - x1;\n    }\n}",
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/SecantSolver.java",
          "functionStartLine": 72,
          "functionName": "doSolve",
          "functionAnnotation": "@Override",
          "functionDoc": "@inheritDoc}\n",
          "diff": "@@ -1,53 +1,59 @@\n-public double solve(final UnivariateRealFunction f, final double min, final double max) throws MaxIterationsExceededException, MathUserException {\n-    clearResult();\n+@Override\n+protected double doSolve() {\n+    double min \u003d getMin();\n+    double max \u003d getMax();\n     verifyInterval(min, max);\n+    final double functionValueAccuracy \u003d getFunctionValueAccuracy();\n     double x0 \u003d min;\n     double x1 \u003d max;\n-    double y0 \u003d f.value(x0);\n-    double y1 \u003d f.value(x1);\n-    if (y0 * y1 \u003e\u003d 0) {\n-        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.SAME_SIGN_AT_ENDPOINTS, min, max, y0, y1);\n+    double y0 \u003d computeObjectiveValue(x0);\n+    if (FastMath.abs(y0) \u003c\u003d functionValueAccuracy) {\n+        return x0;\n     }\n+    double y1 \u003d computeObjectiveValue(x1);\n+    if (FastMath.abs(y1) \u003c\u003d functionValueAccuracy) {\n+        return x1;\n+    }\n+    if (y0 * y1 \u003e\u003d 0) {\n+        throw new NoBracketingException(min, max, y0, y1);\n+    }\n+    final double absoluteAccuracy \u003d getAbsoluteAccuracy();\n+    final double relativeAccuracy \u003d getRelativeAccuracy();\n     double x2 \u003d x0;\n     double y2 \u003d y0;\n     double oldDelta \u003d x2 - x1;\n-    int i \u003d 0;\n-    while (i \u003c maximalIterationCount) {\n+    while (true) {\n         if (FastMath.abs(y2) \u003c FastMath.abs(y1)) {\n             x0 \u003d x1;\n             x1 \u003d x2;\n             x2 \u003d x0;\n             y0 \u003d y1;\n             y1 \u003d y2;\n             y2 \u003d y0;\n         }\n         if (FastMath.abs(y1) \u003c\u003d functionValueAccuracy) {\n-            setResult(x1, i);\n-            return result;\n+            return x1;\n         }\n         if (FastMath.abs(oldDelta) \u003c FastMath.max(relativeAccuracy * FastMath.abs(x1), absoluteAccuracy)) {\n-            setResult(x1, i);\n-            return result;\n+            return x1;\n         }\n         double delta;\n         if (FastMath.abs(y1) \u003e FastMath.abs(y0)) {\n             delta \u003d 0.5 * oldDelta;\n         } else {\n             delta \u003d (x0 - x1) / (1 - y0 / y1);\n             if (delta / oldDelta \u003e 1) {\n                 delta \u003d 0.5 * oldDelta;\n             }\n         }\n         x0 \u003d x1;\n         y0 \u003d y1;\n         x1 \u003d x1 + delta;\n-        y1 \u003d f.value(x1);\n+        y1 \u003d computeObjectiveValue(x1);\n         if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n             x2 \u003d x0;\n             y2 \u003d y0;\n         }\n         oldDelta \u003d x2 - x1;\n-        i++;\n     }\n-    throw new MaxIterationsExceededException(maximalIterationCount);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "",
            "newValue": "@Override"
          }
        },
        {
          "type": "Ydocchange",
          "commitMessage": "MATH-439\nRefactored the \"solvers\" package. Implementations refer to number of\nevaluation of the objective function (instead of the number of iterations).\nNew interfaces and base classes.\n\"NewtonSolver\" fits in the design without resorting to a cast.\nCreated class \"MullerSolver2\" to contain the code of the method named \"solve2\"\nin class \"MullerSolver\".\nRemoved \"UnivariateRealSolverFactory\" and \"UnivariateRealSolverFactoryImpl\".\nDefault solver in \"UnivariateRealSolverUtils\" is explicitely instantiated.\n\"AbstractContinuousDistribution\": Type of exception thrown changed in\n\"UnivariateRealSolverUtils\".\nFactored out duplicate code (in \"GaussNewtonOptimizerTest\" and\n\"LevenbergMarquardtOptimizerTest\"): class \"Circle\" is now called\n\"CircleVectorial\". Also factored out the \"Circle\" class from\n\"NonLinearConjugateGradientOptimizerTest\": class is named \"CircleScalar\".\nCreated \"SecantSolverTest\", moving there all the tests for the class\n\"SecantSolver\" that were located in class \"BrentSolverTest\".\nCreated new interface and base class for polynomial functions solvers\n(\"LaguerreSolver\") so that the function type is now checked at compile time.\nRemoved deprecated exceptions (MATH-441).\nJavadoc clean-up.\nLowered tolerance values in some unit tests.\nTests upgraded to Junit 4 (MATH-423).\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@1039083 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "11/25/10, 8:22 AM",
          "commitName": "74ff198bd249a56d1349b963bd265f8899743b9b",
          "commitAuthor": "Gilles Sadowski",
          "commitDateOld": "11/20/10, 1:01 PM",
          "commitNameOld": "8302dd02498495277ec0db9301edb2158bb0e314",
          "commitAuthorOld": "Luc Maisonobe",
          "daysBetweenCommits": 4.81,
          "commitsBetweenForRepo": 8,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\nprotected double doSolve() {\n    double min \u003d getMin();\n    double max \u003d getMax();\n    verifyInterval(min, max);\n    final double functionValueAccuracy \u003d getFunctionValueAccuracy();\n    double x0 \u003d min;\n    double x1 \u003d max;\n    double y0 \u003d computeObjectiveValue(x0);\n    if (FastMath.abs(y0) \u003c\u003d functionValueAccuracy) {\n        return x0;\n    }\n    double y1 \u003d computeObjectiveValue(x1);\n    if (FastMath.abs(y1) \u003c\u003d functionValueAccuracy) {\n        return x1;\n    }\n    if (y0 * y1 \u003e\u003d 0) {\n        throw new NoBracketingException(min, max, y0, y1);\n    }\n    final double absoluteAccuracy \u003d getAbsoluteAccuracy();\n    final double relativeAccuracy \u003d getRelativeAccuracy();\n    double x2 \u003d x0;\n    double y2 \u003d y0;\n    double oldDelta \u003d x2 - x1;\n    while (true) {\n        if (FastMath.abs(y2) \u003c FastMath.abs(y1)) {\n            x0 \u003d x1;\n            x1 \u003d x2;\n            x2 \u003d x0;\n            y0 \u003d y1;\n            y1 \u003d y2;\n            y2 \u003d y0;\n        }\n        if (FastMath.abs(y1) \u003c\u003d functionValueAccuracy) {\n            return x1;\n        }\n        if (FastMath.abs(oldDelta) \u003c FastMath.max(relativeAccuracy * FastMath.abs(x1), absoluteAccuracy)) {\n            return x1;\n        }\n        double delta;\n        if (FastMath.abs(y1) \u003e FastMath.abs(y0)) {\n            delta \u003d 0.5 * oldDelta;\n        } else {\n            delta \u003d (x0 - x1) / (1 - y0 / y1);\n            if (delta / oldDelta \u003e 1) {\n                delta \u003d 0.5 * oldDelta;\n            }\n        }\n        x0 \u003d x1;\n        y0 \u003d y1;\n        x1 \u003d x1 + delta;\n        y1 \u003d computeObjectiveValue(x1);\n        if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n            x2 \u003d x0;\n            y2 \u003d y0;\n        }\n        oldDelta \u003d x2 - x1;\n    }\n}",
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/SecantSolver.java",
          "functionStartLine": 72,
          "functionName": "doSolve",
          "functionAnnotation": "@Override",
          "functionDoc": "@inheritDoc}\n",
          "diff": "@@ -1,53 +1,59 @@\n-public double solve(final UnivariateRealFunction f, final double min, final double max) throws MaxIterationsExceededException, MathUserException {\n-    clearResult();\n+@Override\n+protected double doSolve() {\n+    double min \u003d getMin();\n+    double max \u003d getMax();\n     verifyInterval(min, max);\n+    final double functionValueAccuracy \u003d getFunctionValueAccuracy();\n     double x0 \u003d min;\n     double x1 \u003d max;\n-    double y0 \u003d f.value(x0);\n-    double y1 \u003d f.value(x1);\n-    if (y0 * y1 \u003e\u003d 0) {\n-        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.SAME_SIGN_AT_ENDPOINTS, min, max, y0, y1);\n+    double y0 \u003d computeObjectiveValue(x0);\n+    if (FastMath.abs(y0) \u003c\u003d functionValueAccuracy) {\n+        return x0;\n     }\n+    double y1 \u003d computeObjectiveValue(x1);\n+    if (FastMath.abs(y1) \u003c\u003d functionValueAccuracy) {\n+        return x1;\n+    }\n+    if (y0 * y1 \u003e\u003d 0) {\n+        throw new NoBracketingException(min, max, y0, y1);\n+    }\n+    final double absoluteAccuracy \u003d getAbsoluteAccuracy();\n+    final double relativeAccuracy \u003d getRelativeAccuracy();\n     double x2 \u003d x0;\n     double y2 \u003d y0;\n     double oldDelta \u003d x2 - x1;\n-    int i \u003d 0;\n-    while (i \u003c maximalIterationCount) {\n+    while (true) {\n         if (FastMath.abs(y2) \u003c FastMath.abs(y1)) {\n             x0 \u003d x1;\n             x1 \u003d x2;\n             x2 \u003d x0;\n             y0 \u003d y1;\n             y1 \u003d y2;\n             y2 \u003d y0;\n         }\n         if (FastMath.abs(y1) \u003c\u003d functionValueAccuracy) {\n-            setResult(x1, i);\n-            return result;\n+            return x1;\n         }\n         if (FastMath.abs(oldDelta) \u003c FastMath.max(relativeAccuracy * FastMath.abs(x1), absoluteAccuracy)) {\n-            setResult(x1, i);\n-            return result;\n+            return x1;\n         }\n         double delta;\n         if (FastMath.abs(y1) \u003e FastMath.abs(y0)) {\n             delta \u003d 0.5 * oldDelta;\n         } else {\n             delta \u003d (x0 - x1) / (1 - y0 / y1);\n             if (delta / oldDelta \u003e 1) {\n                 delta \u003d 0.5 * oldDelta;\n             }\n         }\n         x0 \u003d x1;\n         y0 \u003d y1;\n         x1 \u003d x1 + delta;\n-        y1 \u003d f.value(x1);\n+        y1 \u003d computeObjectiveValue(x1);\n         if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n             x2 \u003d x0;\n             y2 \u003d y0;\n         }\n         oldDelta \u003d x2 - x1;\n-        i++;\n     }\n-    throw new MaxIterationsExceededException(maximalIterationCount);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Find a zero in the given interval.\n\n@param f the function to solve\n@param min the lower bound for the interval.\n@param max the upper bound for the interval.\n@return the value where the function is zero\n@throws MaxIterationsExceededException  if the maximum iteration count is exceeded\n@throws MathUserException if an error occurs evaluating the function\n@throws IllegalArgumentException if min is not less than max or the\nsigns of the values of the function at the endpoints are not opposites\n",
            "newValue": "@inheritDoc}\n"
          }
        }
      ]
    },
    "8302dd02498495277ec0db9301edb2158bb0e314": {
      "type": "Ymultichange(Yexceptionschange,Ydocchange)",
      "commitMessage": "removed FunctionEvaluationException, DerivativeException and MatrixVisitorException\nthese exception were  deprecated in 2.2 and a smooth transition path was set up to help users, now all user functions should use the new unchecked MathUserException\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@1037328 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/20/10, 1:01 PM",
      "commitName": "8302dd02498495277ec0db9301edb2158bb0e314",
      "commitAuthor": "Luc Maisonobe",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "removed FunctionEvaluationException, DerivativeException and MatrixVisitorException\nthese exception were  deprecated in 2.2 and a smooth transition path was set up to help users, now all user functions should use the new unchecked MathUserException\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@1037328 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "11/20/10, 1:01 PM",
          "commitName": "8302dd02498495277ec0db9301edb2158bb0e314",
          "commitAuthor": "Luc Maisonobe",
          "commitDateOld": "11/13/10, 2:27 PM",
          "commitNameOld": "255364ac1f6434c1a429433931980145adc181ce",
          "commitAuthorOld": "Gilles Sadowski",
          "daysBetweenCommits": 6.94,
          "commitsBetweenForRepo": 10,
          "commitsBetweenForFile": 1,
          "actualSource": "public double solve(final UnivariateRealFunction f, final double min, final double max) throws MaxIterationsExceededException, MathUserException {\n    clearResult();\n    verifyInterval(min, max);\n    double x0 \u003d min;\n    double x1 \u003d max;\n    double y0 \u003d f.value(x0);\n    double y1 \u003d f.value(x1);\n    if (y0 * y1 \u003e\u003d 0) {\n        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.SAME_SIGN_AT_ENDPOINTS, min, max, y0, y1);\n    }\n    double x2 \u003d x0;\n    double y2 \u003d y0;\n    double oldDelta \u003d x2 - x1;\n    int i \u003d 0;\n    while (i \u003c maximalIterationCount) {\n        if (FastMath.abs(y2) \u003c FastMath.abs(y1)) {\n            x0 \u003d x1;\n            x1 \u003d x2;\n            x2 \u003d x0;\n            y0 \u003d y1;\n            y1 \u003d y2;\n            y2 \u003d y0;\n        }\n        if (FastMath.abs(y1) \u003c\u003d functionValueAccuracy) {\n            setResult(x1, i);\n            return result;\n        }\n        if (FastMath.abs(oldDelta) \u003c FastMath.max(relativeAccuracy * FastMath.abs(x1), absoluteAccuracy)) {\n            setResult(x1, i);\n            return result;\n        }\n        double delta;\n        if (FastMath.abs(y1) \u003e FastMath.abs(y0)) {\n            delta \u003d 0.5 * oldDelta;\n        } else {\n            delta \u003d (x0 - x1) / (1 - y0 / y1);\n            if (delta / oldDelta \u003e 1) {\n                delta \u003d 0.5 * oldDelta;\n            }\n        }\n        x0 \u003d x1;\n        y0 \u003d y1;\n        x1 \u003d x1 + delta;\n        y1 \u003d f.value(x1);\n        if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n            x2 \u003d x0;\n            y2 \u003d y0;\n        }\n        oldDelta \u003d x2 - x1;\n        i++;\n    }\n    throw new MaxIterationsExceededException(maximalIterationCount);\n}",
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/SecantSolver.java",
          "functionStartLine": 83,
          "functionName": "solve",
          "functionAnnotation": "",
          "functionDoc": "Find a zero in the given interval.\n\n@param f the function to solve\n@param min the lower bound for the interval.\n@param max the upper bound for the interval.\n@return the value where the function is zero\n@throws MaxIterationsExceededException  if the maximum iteration count is exceeded\n@throws MathUserException if an error occurs evaluating the function\n@throws IllegalArgumentException if min is not less than max or the\nsigns of the values of the function at the endpoints are not opposites\n",
          "diff": "@@ -1,53 +1,53 @@\n-public double solve(final UnivariateRealFunction f, final double min, final double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n+public double solve(final UnivariateRealFunction f, final double min, final double max) throws MaxIterationsExceededException, MathUserException {\n     clearResult();\n     verifyInterval(min, max);\n     double x0 \u003d min;\n     double x1 \u003d max;\n     double y0 \u003d f.value(x0);\n     double y1 \u003d f.value(x1);\n     if (y0 * y1 \u003e\u003d 0) {\n         throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.SAME_SIGN_AT_ENDPOINTS, min, max, y0, y1);\n     }\n     double x2 \u003d x0;\n     double y2 \u003d y0;\n     double oldDelta \u003d x2 - x1;\n     int i \u003d 0;\n     while (i \u003c maximalIterationCount) {\n         if (FastMath.abs(y2) \u003c FastMath.abs(y1)) {\n             x0 \u003d x1;\n             x1 \u003d x2;\n             x2 \u003d x0;\n             y0 \u003d y1;\n             y1 \u003d y2;\n             y2 \u003d y0;\n         }\n         if (FastMath.abs(y1) \u003c\u003d functionValueAccuracy) {\n             setResult(x1, i);\n             return result;\n         }\n         if (FastMath.abs(oldDelta) \u003c FastMath.max(relativeAccuracy * FastMath.abs(x1), absoluteAccuracy)) {\n             setResult(x1, i);\n             return result;\n         }\n         double delta;\n         if (FastMath.abs(y1) \u003e FastMath.abs(y0)) {\n             delta \u003d 0.5 * oldDelta;\n         } else {\n             delta \u003d (x0 - x1) / (1 - y0 / y1);\n             if (delta / oldDelta \u003e 1) {\n                 delta \u003d 0.5 * oldDelta;\n             }\n         }\n         x0 \u003d x1;\n         y0 \u003d y1;\n         x1 \u003d x1 + delta;\n         y1 \u003d f.value(x1);\n         if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n             x2 \u003d x0;\n             y2 \u003d y0;\n         }\n         oldDelta \u003d x2 - x1;\n         i++;\n     }\n     throw new MaxIterationsExceededException(maximalIterationCount);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[MaxIterationsExceededException, FunctionEvaluationException]",
            "newValue": "[MaxIterationsExceededException, MathUserException]"
          }
        },
        {
          "type": "Ydocchange",
          "commitMessage": "removed FunctionEvaluationException, DerivativeException and MatrixVisitorException\nthese exception were  deprecated in 2.2 and a smooth transition path was set up to help users, now all user functions should use the new unchecked MathUserException\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@1037328 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "11/20/10, 1:01 PM",
          "commitName": "8302dd02498495277ec0db9301edb2158bb0e314",
          "commitAuthor": "Luc Maisonobe",
          "commitDateOld": "11/13/10, 2:27 PM",
          "commitNameOld": "255364ac1f6434c1a429433931980145adc181ce",
          "commitAuthorOld": "Gilles Sadowski",
          "daysBetweenCommits": 6.94,
          "commitsBetweenForRepo": 10,
          "commitsBetweenForFile": 1,
          "actualSource": "public double solve(final UnivariateRealFunction f, final double min, final double max) throws MaxIterationsExceededException, MathUserException {\n    clearResult();\n    verifyInterval(min, max);\n    double x0 \u003d min;\n    double x1 \u003d max;\n    double y0 \u003d f.value(x0);\n    double y1 \u003d f.value(x1);\n    if (y0 * y1 \u003e\u003d 0) {\n        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.SAME_SIGN_AT_ENDPOINTS, min, max, y0, y1);\n    }\n    double x2 \u003d x0;\n    double y2 \u003d y0;\n    double oldDelta \u003d x2 - x1;\n    int i \u003d 0;\n    while (i \u003c maximalIterationCount) {\n        if (FastMath.abs(y2) \u003c FastMath.abs(y1)) {\n            x0 \u003d x1;\n            x1 \u003d x2;\n            x2 \u003d x0;\n            y0 \u003d y1;\n            y1 \u003d y2;\n            y2 \u003d y0;\n        }\n        if (FastMath.abs(y1) \u003c\u003d functionValueAccuracy) {\n            setResult(x1, i);\n            return result;\n        }\n        if (FastMath.abs(oldDelta) \u003c FastMath.max(relativeAccuracy * FastMath.abs(x1), absoluteAccuracy)) {\n            setResult(x1, i);\n            return result;\n        }\n        double delta;\n        if (FastMath.abs(y1) \u003e FastMath.abs(y0)) {\n            delta \u003d 0.5 * oldDelta;\n        } else {\n            delta \u003d (x0 - x1) / (1 - y0 / y1);\n            if (delta / oldDelta \u003e 1) {\n                delta \u003d 0.5 * oldDelta;\n            }\n        }\n        x0 \u003d x1;\n        y0 \u003d y1;\n        x1 \u003d x1 + delta;\n        y1 \u003d f.value(x1);\n        if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n            x2 \u003d x0;\n            y2 \u003d y0;\n        }\n        oldDelta \u003d x2 - x1;\n        i++;\n    }\n    throw new MaxIterationsExceededException(maximalIterationCount);\n}",
          "path": "src/main/java/org/apache/commons/math/analysis/solvers/SecantSolver.java",
          "functionStartLine": 83,
          "functionName": "solve",
          "functionAnnotation": "",
          "functionDoc": "Find a zero in the given interval.\n\n@param f the function to solve\n@param min the lower bound for the interval.\n@param max the upper bound for the interval.\n@return the value where the function is zero\n@throws MaxIterationsExceededException  if the maximum iteration count is exceeded\n@throws MathUserException if an error occurs evaluating the function\n@throws IllegalArgumentException if min is not less than max or the\nsigns of the values of the function at the endpoints are not opposites\n",
          "diff": "@@ -1,53 +1,53 @@\n-public double solve(final UnivariateRealFunction f, final double min, final double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n+public double solve(final UnivariateRealFunction f, final double min, final double max) throws MaxIterationsExceededException, MathUserException {\n     clearResult();\n     verifyInterval(min, max);\n     double x0 \u003d min;\n     double x1 \u003d max;\n     double y0 \u003d f.value(x0);\n     double y1 \u003d f.value(x1);\n     if (y0 * y1 \u003e\u003d 0) {\n         throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.SAME_SIGN_AT_ENDPOINTS, min, max, y0, y1);\n     }\n     double x2 \u003d x0;\n     double y2 \u003d y0;\n     double oldDelta \u003d x2 - x1;\n     int i \u003d 0;\n     while (i \u003c maximalIterationCount) {\n         if (FastMath.abs(y2) \u003c FastMath.abs(y1)) {\n             x0 \u003d x1;\n             x1 \u003d x2;\n             x2 \u003d x0;\n             y0 \u003d y1;\n             y1 \u003d y2;\n             y2 \u003d y0;\n         }\n         if (FastMath.abs(y1) \u003c\u003d functionValueAccuracy) {\n             setResult(x1, i);\n             return result;\n         }\n         if (FastMath.abs(oldDelta) \u003c FastMath.max(relativeAccuracy * FastMath.abs(x1), absoluteAccuracy)) {\n             setResult(x1, i);\n             return result;\n         }\n         double delta;\n         if (FastMath.abs(y1) \u003e FastMath.abs(y0)) {\n             delta \u003d 0.5 * oldDelta;\n         } else {\n             delta \u003d (x0 - x1) / (1 - y0 / y1);\n             if (delta / oldDelta \u003e 1) {\n                 delta \u003d 0.5 * oldDelta;\n             }\n         }\n         x0 \u003d x1;\n         y0 \u003d y1;\n         x1 \u003d x1 + delta;\n         y1 \u003d f.value(x1);\n         if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n             x2 \u003d x0;\n             y2 \u003d y0;\n         }\n         oldDelta \u003d x2 - x1;\n         i++;\n     }\n     throw new MaxIterationsExceededException(maximalIterationCount);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Find a zero in the given interval.\n\n@param f the function to solve\n@param min the lower bound for the interval.\n@param max the upper bound for the interval.\n@return the value where the function is zero\n@throws MaxIterationsExceededException  if the maximum iteration count is exceeded\n@throws FunctionEvaluationException if an error occurs evaluating the\nfunction\n@throws IllegalArgumentException if min is not less than max or the\nsigns of the values of the function at the endpoints are not opposites\n",
            "newValue": "Find a zero in the given interval.\n\n@param f the function to solve\n@param min the lower bound for the interval.\n@param max the upper bound for the interval.\n@return the value where the function is zero\n@throws MaxIterationsExceededException  if the maximum iteration count is exceeded\n@throws MathUserException if an error occurs evaluating the function\n@throws IllegalArgumentException if min is not less than max or the\nsigns of the values of the function at the endpoints are not opposites\n"
          }
        }
      ]
    },
    "80b1e90b42a34856b61cec628fcea6633d1000cd": {
      "type": "Ybodychange",
      "commitMessage": "added FastMath and used it everywhere in replacement of java.util.Math\nthe unit tests have not been added yet (waiting for dfp library addition)\nJIRA: MATH-375\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@990658 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "8/29/10, 3:04 PM",
      "commitName": "80b1e90b42a34856b61cec628fcea6633d1000cd",
      "commitAuthor": "Luc Maisonobe",
      "commitDateOld": "8/10/10, 3:46 AM",
      "commitNameOld": "986597f52ce9c6c1ff13fb134b91696de6ec2796",
      "commitAuthorOld": "Gilles Sadowski",
      "daysBetweenCommits": 19.47,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "actualSource": "public double solve(final UnivariateRealFunction f, final double min, final double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifyInterval(min, max);\n    double x0 \u003d min;\n    double x1 \u003d max;\n    double y0 \u003d f.value(x0);\n    double y1 \u003d f.value(x1);\n    if (y0 * y1 \u003e\u003d 0) {\n        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.SAME_SIGN_AT_ENDPOINTS, min, max, y0, y1);\n    }\n    double x2 \u003d x0;\n    double y2 \u003d y0;\n    double oldDelta \u003d x2 - x1;\n    int i \u003d 0;\n    while (i \u003c maximalIterationCount) {\n        if (FastMath.abs(y2) \u003c FastMath.abs(y1)) {\n            x0 \u003d x1;\n            x1 \u003d x2;\n            x2 \u003d x0;\n            y0 \u003d y1;\n            y1 \u003d y2;\n            y2 \u003d y0;\n        }\n        if (FastMath.abs(y1) \u003c\u003d functionValueAccuracy) {\n            setResult(x1, i);\n            return result;\n        }\n        if (FastMath.abs(oldDelta) \u003c FastMath.max(relativeAccuracy * FastMath.abs(x1), absoluteAccuracy)) {\n            setResult(x1, i);\n            return result;\n        }\n        double delta;\n        if (FastMath.abs(y1) \u003e FastMath.abs(y0)) {\n            delta \u003d 0.5 * oldDelta;\n        } else {\n            delta \u003d (x0 - x1) / (1 - y0 / y1);\n            if (delta / oldDelta \u003e 1) {\n                delta \u003d 0.5 * oldDelta;\n            }\n        }\n        x0 \u003d x1;\n        y0 \u003d y1;\n        x1 \u003d x1 + delta;\n        y1 \u003d f.value(x1);\n        if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n            x2 \u003d x0;\n            y2 \u003d y0;\n        }\n        oldDelta \u003d x2 - x1;\n        i++;\n    }\n    throw new MaxIterationsExceededException(maximalIterationCount);\n}",
      "path": "src/main/java/org/apache/commons/math/analysis/solvers/SecantSolver.java",
      "functionStartLine": 112,
      "functionName": "solve",
      "functionAnnotation": "",
      "functionDoc": "Find a zero in the given interval.\n\n@param f the function to solve\n@param min the lower bound for the interval.\n@param max the upper bound for the interval.\n@return the value where the function is zero\n@throws MaxIterationsExceededException  if the maximum iteration count is exceeded\n@throws FunctionEvaluationException if an error occurs evaluating the\nfunction\n@throws IllegalArgumentException if min is not less than max or the\nsigns of the values of the function at the endpoints are not opposites\n",
      "diff": "@@ -1,53 +1,53 @@\n public double solve(final UnivariateRealFunction f, final double min, final double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n     clearResult();\n     verifyInterval(min, max);\n     double x0 \u003d min;\n     double x1 \u003d max;\n     double y0 \u003d f.value(x0);\n     double y1 \u003d f.value(x1);\n     if (y0 * y1 \u003e\u003d 0) {\n         throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.SAME_SIGN_AT_ENDPOINTS, min, max, y0, y1);\n     }\n     double x2 \u003d x0;\n     double y2 \u003d y0;\n     double oldDelta \u003d x2 - x1;\n     int i \u003d 0;\n     while (i \u003c maximalIterationCount) {\n-        if (Math.abs(y2) \u003c Math.abs(y1)) {\n+        if (FastMath.abs(y2) \u003c FastMath.abs(y1)) {\n             x0 \u003d x1;\n             x1 \u003d x2;\n             x2 \u003d x0;\n             y0 \u003d y1;\n             y1 \u003d y2;\n             y2 \u003d y0;\n         }\n-        if (Math.abs(y1) \u003c\u003d functionValueAccuracy) {\n+        if (FastMath.abs(y1) \u003c\u003d functionValueAccuracy) {\n             setResult(x1, i);\n             return result;\n         }\n-        if (Math.abs(oldDelta) \u003c Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy)) {\n+        if (FastMath.abs(oldDelta) \u003c FastMath.max(relativeAccuracy * FastMath.abs(x1), absoluteAccuracy)) {\n             setResult(x1, i);\n             return result;\n         }\n         double delta;\n-        if (Math.abs(y1) \u003e Math.abs(y0)) {\n+        if (FastMath.abs(y1) \u003e FastMath.abs(y0)) {\n             delta \u003d 0.5 * oldDelta;\n         } else {\n             delta \u003d (x0 - x1) / (1 - y0 / y1);\n             if (delta / oldDelta \u003e 1) {\n                 delta \u003d 0.5 * oldDelta;\n             }\n         }\n         x0 \u003d x1;\n         y0 \u003d y1;\n         x1 \u003d x1 + delta;\n         y1 \u003d f.value(x1);\n         if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n             x2 \u003d x0;\n             y2 \u003d y0;\n         }\n         oldDelta \u003d x2 - x1;\n         i++;\n     }\n     throw new MaxIterationsExceededException(maximalIterationCount);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1eaea0b549f685bd416cef68faa3a137b9bb3519": {
      "type": "Ybodychange",
      "commitMessage": "changed the localization mechanism for error messages. The new system is based on an enum rather than on duplicated string literals.\nJIRA: MATH-361\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@955423 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "6/16/10, 4:03 PM",
      "commitName": "1eaea0b549f685bd416cef68faa3a137b9bb3519",
      "commitAuthor": "Luc Maisonobe",
      "commitDateOld": "9/5/09, 10:36 AM",
      "commitNameOld": "26dac5a0e7fc9c6be9571b3e71a15d8502480d96",
      "commitAuthorOld": "Phil Steitz",
      "daysBetweenCommits": 284.23,
      "commitsBetweenForRepo": 275,
      "commitsBetweenForFile": 1,
      "actualSource": "public double solve(final UnivariateRealFunction f, final double min, final double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifyInterval(min, max);\n    double x0 \u003d min;\n    double x1 \u003d max;\n    double y0 \u003d f.value(x0);\n    double y1 \u003d f.value(x1);\n    if (y0 * y1 \u003e\u003d 0) {\n        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.SAME_SIGN_AT_ENDPOINTS, min, max, y0, y1);\n    }\n    double x2 \u003d x0;\n    double y2 \u003d y0;\n    double oldDelta \u003d x2 - x1;\n    int i \u003d 0;\n    while (i \u003c maximalIterationCount) {\n        if (Math.abs(y2) \u003c Math.abs(y1)) {\n            x0 \u003d x1;\n            x1 \u003d x2;\n            x2 \u003d x0;\n            y0 \u003d y1;\n            y1 \u003d y2;\n            y2 \u003d y0;\n        }\n        if (Math.abs(y1) \u003c\u003d functionValueAccuracy) {\n            setResult(x1, i);\n            return result;\n        }\n        if (Math.abs(oldDelta) \u003c Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy)) {\n            setResult(x1, i);\n            return result;\n        }\n        double delta;\n        if (Math.abs(y1) \u003e Math.abs(y0)) {\n            delta \u003d 0.5 * oldDelta;\n        } else {\n            delta \u003d (x0 - x1) / (1 - y0 / y1);\n            if (delta / oldDelta \u003e 1) {\n                delta \u003d 0.5 * oldDelta;\n            }\n        }\n        x0 \u003d x1;\n        y0 \u003d y1;\n        x1 \u003d x1 + delta;\n        y1 \u003d f.value(x1);\n        if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n            x2 \u003d x0;\n            y2 \u003d y0;\n        }\n        oldDelta \u003d x2 - x1;\n        i++;\n    }\n    throw new MaxIterationsExceededException(maximalIterationCount);\n}",
      "path": "src/main/java/org/apache/commons/math/analysis/solvers/SecantSolver.java",
      "functionStartLine": 111,
      "functionName": "solve",
      "functionAnnotation": "",
      "functionDoc": "Find a zero in the given interval.\n\n@param f the function to solve\n@param min the lower bound for the interval.\n@param max the upper bound for the interval.\n@return the value where the function is zero\n@throws MaxIterationsExceededException  if the maximum iteration count is exceeded\n@throws FunctionEvaluationException if an error occurs evaluating the\nfunction\n@throws IllegalArgumentException if min is not less than max or the\nsigns of the values of the function at the endpoints are not opposites\n",
      "diff": "@@ -1,53 +1,53 @@\n public double solve(final UnivariateRealFunction f, final double min, final double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n     clearResult();\n     verifyInterval(min, max);\n     double x0 \u003d min;\n     double x1 \u003d max;\n     double y0 \u003d f.value(x0);\n     double y1 \u003d f.value(x1);\n     if (y0 * y1 \u003e\u003d 0) {\n-        throw MathRuntimeException.createIllegalArgumentException(\"function values at endpoints do not have different signs, \" + \"endpoints: [{0}, {1}], values: [{2}, {3}]\", min, max, y0, y1);\n+        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.SAME_SIGN_AT_ENDPOINTS, min, max, y0, y1);\n     }\n     double x2 \u003d x0;\n     double y2 \u003d y0;\n     double oldDelta \u003d x2 - x1;\n     int i \u003d 0;\n     while (i \u003c maximalIterationCount) {\n         if (Math.abs(y2) \u003c Math.abs(y1)) {\n             x0 \u003d x1;\n             x1 \u003d x2;\n             x2 \u003d x0;\n             y0 \u003d y1;\n             y1 \u003d y2;\n             y2 \u003d y0;\n         }\n         if (Math.abs(y1) \u003c\u003d functionValueAccuracy) {\n             setResult(x1, i);\n             return result;\n         }\n         if (Math.abs(oldDelta) \u003c Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy)) {\n             setResult(x1, i);\n             return result;\n         }\n         double delta;\n         if (Math.abs(y1) \u003e Math.abs(y0)) {\n             delta \u003d 0.5 * oldDelta;\n         } else {\n             delta \u003d (x0 - x1) / (1 - y0 / y1);\n             if (delta / oldDelta \u003e 1) {\n                 delta \u003d 0.5 * oldDelta;\n             }\n         }\n         x0 \u003d x1;\n         y0 \u003d y1;\n         x1 \u003d x1 + delta;\n         y1 \u003d f.value(x1);\n         if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n             x2 \u003d x0;\n             y2 \u003d y0;\n         }\n         oldDelta \u003d x2 - x1;\n         i++;\n     }\n     throw new MaxIterationsExceededException(maximalIterationCount);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "26dac5a0e7fc9c6be9571b3e71a15d8502480d96": {
      "type": "Yformatchange",
      "commitMessage": "Removed trailing spaces.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@811685 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "9/5/09, 10:36 AM",
      "commitName": "26dac5a0e7fc9c6be9571b3e71a15d8502480d96",
      "commitAuthor": "Phil Steitz",
      "commitDateOld": "8/1/09, 7:30 AM",
      "commitNameOld": "d6a438e931412713e99624cf9ed74470f1040184",
      "commitAuthorOld": "Luc Maisonobe",
      "daysBetweenCommits": 35.13,
      "commitsBetweenForRepo": 44,
      "commitsBetweenForFile": 1,
      "actualSource": "public double solve(final UnivariateRealFunction f, final double min, final double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifyInterval(min, max);\n    double x0 \u003d min;\n    double x1 \u003d max;\n    double y0 \u003d f.value(x0);\n    double y1 \u003d f.value(x1);\n    if (y0 * y1 \u003e\u003d 0) {\n        throw MathRuntimeException.createIllegalArgumentException(\"function values at endpoints do not have different signs, \" + \"endpoints: [{0}, {1}], values: [{2}, {3}]\", min, max, y0, y1);\n    }\n    double x2 \u003d x0;\n    double y2 \u003d y0;\n    double oldDelta \u003d x2 - x1;\n    int i \u003d 0;\n    while (i \u003c maximalIterationCount) {\n        if (Math.abs(y2) \u003c Math.abs(y1)) {\n            x0 \u003d x1;\n            x1 \u003d x2;\n            x2 \u003d x0;\n            y0 \u003d y1;\n            y1 \u003d y2;\n            y2 \u003d y0;\n        }\n        if (Math.abs(y1) \u003c\u003d functionValueAccuracy) {\n            setResult(x1, i);\n            return result;\n        }\n        if (Math.abs(oldDelta) \u003c Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy)) {\n            setResult(x1, i);\n            return result;\n        }\n        double delta;\n        if (Math.abs(y1) \u003e Math.abs(y0)) {\n            delta \u003d 0.5 * oldDelta;\n        } else {\n            delta \u003d (x0 - x1) / (1 - y0 / y1);\n            if (delta / oldDelta \u003e 1) {\n                delta \u003d 0.5 * oldDelta;\n            }\n        }\n        x0 \u003d x1;\n        y0 \u003d y1;\n        x1 \u003d x1 + delta;\n        y1 \u003d f.value(x1);\n        if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n            x2 \u003d x0;\n            y2 \u003d y0;\n        }\n        oldDelta \u003d x2 - x1;\n        i++;\n    }\n    throw new MaxIterationsExceededException(maximalIterationCount);\n}",
      "path": "src/main/java/org/apache/commons/math/analysis/solvers/SecantSolver.java",
      "functionStartLine": 110,
      "functionName": "solve",
      "functionAnnotation": "",
      "functionDoc": "Find a zero in the given interval.\n\n@param f the function to solve\n@param min the lower bound for the interval.\n@param max the upper bound for the interval.\n@return the value where the function is zero\n@throws MaxIterationsExceededException  if the maximum iteration count is exceeded\n@throws FunctionEvaluationException if an error occurs evaluating the\nfunction\n@throws IllegalArgumentException if min is not less than max or the\nsigns of the values of the function at the endpoints are not opposites\n",
      "diff": "",
      "extendedDetails": {}
    },
    "d6a438e931412713e99624cf9ed74470f1040184": {
      "type": "Yfilerename",
      "commitMessage": "moved main java directory for compliance with maven standard directory layout\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@799870 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "8/1/09, 7:30 AM",
      "commitName": "d6a438e931412713e99624cf9ed74470f1040184",
      "commitAuthor": "Luc Maisonobe",
      "commitDateOld": "8/1/09, 7:23 AM",
      "commitNameOld": "2ad5ef61630be627f46ae1c266cf796f044bd4a8",
      "commitAuthorOld": "Luc Maisonobe",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public double solve(final UnivariateRealFunction f, final double min, final double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifyInterval(min, max);\n    double x0 \u003d min;\n    double x1 \u003d max;\n    double y0 \u003d f.value(x0);\n    double y1 \u003d f.value(x1);\n    if (y0 * y1 \u003e\u003d 0) {\n        throw MathRuntimeException.createIllegalArgumentException(\"function values at endpoints do not have different signs, \" + \"endpoints: [{0}, {1}], values: [{2}, {3}]\", min, max, y0, y1);\n    }\n    double x2 \u003d x0;\n    double y2 \u003d y0;\n    double oldDelta \u003d x2 - x1;\n    int i \u003d 0;\n    while (i \u003c maximalIterationCount) {\n        if (Math.abs(y2) \u003c Math.abs(y1)) {\n            x0 \u003d x1;\n            x1 \u003d x2;\n            x2 \u003d x0;\n            y0 \u003d y1;\n            y1 \u003d y2;\n            y2 \u003d y0;\n        }\n        if (Math.abs(y1) \u003c\u003d functionValueAccuracy) {\n            setResult(x1, i);\n            return result;\n        }\n        if (Math.abs(oldDelta) \u003c Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy)) {\n            setResult(x1, i);\n            return result;\n        }\n        double delta;\n        if (Math.abs(y1) \u003e Math.abs(y0)) {\n            delta \u003d 0.5 * oldDelta;\n        } else {\n            delta \u003d (x0 - x1) / (1 - y0 / y1);\n            if (delta / oldDelta \u003e 1) {\n                delta \u003d 0.5 * oldDelta;\n            }\n        }\n        x0 \u003d x1;\n        y0 \u003d y1;\n        x1 \u003d x1 + delta;\n        y1 \u003d f.value(x1);\n        if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n            x2 \u003d x0;\n            y2 \u003d y0;\n        }\n        oldDelta \u003d x2 - x1;\n        i++;\n    }\n    throw new MaxIterationsExceededException(maximalIterationCount);\n}",
      "path": "src/main/java/org/apache/commons/math/analysis/solvers/SecantSolver.java",
      "functionStartLine": 110,
      "functionName": "solve",
      "functionAnnotation": "",
      "functionDoc": "Find a zero in the given interval.\n\n@param f the function to solve\n@param min the lower bound for the interval.\n@param max the upper bound for the interval.\n@return the value where the function is zero\n@throws MaxIterationsExceededException  if the maximum iteration count is exceeded\n@throws FunctionEvaluationException if an error occurs evaluating the\nfunction\n@throws IllegalArgumentException if min is not less than max or the\nsigns of the values of the function at the endpoints are not opposites\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/commons/math/analysis/solvers/SecantSolver.java",
        "newPath": "src/main/java/org/apache/commons/math/analysis/solvers/SecantSolver.java"
      }
    },
    "95d2cf0a090068a561701ae57a0e17436ec8c284": {
      "type": "Ybodychange",
      "commitMessage": "improved error messages\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@771097 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "5/3/09, 11:24 AM",
      "commitName": "95d2cf0a090068a561701ae57a0e17436ec8c284",
      "commitAuthor": "Luc Maisonobe",
      "commitDateOld": "1/18/09, 11:48 AM",
      "commitNameOld": "a96ae799963961cd4aff7e1e45abad3ecc21bbbb",
      "commitAuthorOld": "Luc Maisonobe",
      "daysBetweenCommits": 104.94,
      "commitsBetweenForRepo": 192,
      "commitsBetweenForFile": 1,
      "actualSource": "public double solve(final UnivariateRealFunction f, final double min, final double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifyInterval(min, max);\n    double x0 \u003d min;\n    double x1 \u003d max;\n    double y0 \u003d f.value(x0);\n    double y1 \u003d f.value(x1);\n    if (y0 * y1 \u003e\u003d 0) {\n        throw MathRuntimeException.createIllegalArgumentException(\"function values at endpoints do not have different signs, \" + \"endpoints: [{0}, {1}], values: [{2}, {3}]\", min, max, y0, y1);\n    }\n    double x2 \u003d x0;\n    double y2 \u003d y0;\n    double oldDelta \u003d x2 - x1;\n    int i \u003d 0;\n    while (i \u003c maximalIterationCount) {\n        if (Math.abs(y2) \u003c Math.abs(y1)) {\n            x0 \u003d x1;\n            x1 \u003d x2;\n            x2 \u003d x0;\n            y0 \u003d y1;\n            y1 \u003d y2;\n            y2 \u003d y0;\n        }\n        if (Math.abs(y1) \u003c\u003d functionValueAccuracy) {\n            setResult(x1, i);\n            return result;\n        }\n        if (Math.abs(oldDelta) \u003c Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy)) {\n            setResult(x1, i);\n            return result;\n        }\n        double delta;\n        if (Math.abs(y1) \u003e Math.abs(y0)) {\n            delta \u003d 0.5 * oldDelta;\n        } else {\n            delta \u003d (x0 - x1) / (1 - y0 / y1);\n            if (delta / oldDelta \u003e 1) {\n                delta \u003d 0.5 * oldDelta;\n            }\n        }\n        x0 \u003d x1;\n        y0 \u003d y1;\n        x1 \u003d x1 + delta;\n        y1 \u003d f.value(x1);\n        if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n            x2 \u003d x0;\n            y2 \u003d y0;\n        }\n        oldDelta \u003d x2 - x1;\n        i++;\n    }\n    throw new MaxIterationsExceededException(maximalIterationCount);\n}",
      "path": "src/java/org/apache/commons/math/analysis/solvers/SecantSolver.java",
      "functionStartLine": 115,
      "functionName": "solve",
      "functionAnnotation": "",
      "functionDoc": "Find a zero in the given interval.\n\n@param f the function to solve\n@param min the lower bound for the interval.\n@param max the upper bound for the interval.\n@return the value where the function is zero\n@throws MaxIterationsExceededException  if the maximum iteration count is exceeded\n@throws FunctionEvaluationException if an error occurs evaluating the\nfunction\n@throws IllegalArgumentException if min is not less than max or the\nsigns of the values of the function at the endpoints are not opposites\n",
      "diff": "@@ -1,53 +1,53 @@\n public double solve(final UnivariateRealFunction f, final double min, final double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n     clearResult();\n     verifyInterval(min, max);\n     double x0 \u003d min;\n     double x1 \u003d max;\n     double y0 \u003d f.value(x0);\n     double y1 \u003d f.value(x1);\n     if (y0 * y1 \u003e\u003d 0) {\n-        throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\" + \"  Endpoints: [\" + min + \",\" + max + \"]\" + \"  Values: [\" + y0 + \",\" + y1 + \"]\");\n+        throw MathRuntimeException.createIllegalArgumentException(\"function values at endpoints do not have different signs, \" + \"endpoints: [{0}, {1}], values: [{2}, {3}]\", min, max, y0, y1);\n     }\n     double x2 \u003d x0;\n     double y2 \u003d y0;\n     double oldDelta \u003d x2 - x1;\n     int i \u003d 0;\n     while (i \u003c maximalIterationCount) {\n         if (Math.abs(y2) \u003c Math.abs(y1)) {\n             x0 \u003d x1;\n             x1 \u003d x2;\n             x2 \u003d x0;\n             y0 \u003d y1;\n             y1 \u003d y2;\n             y2 \u003d y0;\n         }\n         if (Math.abs(y1) \u003c\u003d functionValueAccuracy) {\n             setResult(x1, i);\n             return result;\n         }\n         if (Math.abs(oldDelta) \u003c Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy)) {\n             setResult(x1, i);\n             return result;\n         }\n         double delta;\n         if (Math.abs(y1) \u003e Math.abs(y0)) {\n             delta \u003d 0.5 * oldDelta;\n         } else {\n             delta \u003d (x0 - x1) / (1 - y0 / y1);\n             if (delta / oldDelta \u003e 1) {\n                 delta \u003d 0.5 * oldDelta;\n             }\n         }\n         x0 \u003d x1;\n         y0 \u003d y1;\n         x1 \u003d x1 + delta;\n         y1 \u003d f.value(x1);\n         if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n             x2 \u003d x0;\n             y2 \u003d y0;\n         }\n         oldDelta \u003d x2 - x1;\n         i++;\n     }\n     throw new MaxIterationsExceededException(maximalIterationCount);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1d1436557bcb21887d9b352dd0f5f3d3acb71e11": {
      "type": "Yfilerename",
      "commitMessage": "split the analysis package into several sub-packages\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@735449 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "1/18/09, 5:07 AM",
      "commitName": "1d1436557bcb21887d9b352dd0f5f3d3acb71e11",
      "commitAuthor": "Luc Maisonobe",
      "commitDateOld": "1/17/09, 9:08 AM",
      "commitNameOld": "3a8a9685ec252116dce375ae9ca61f4cd41fa70f",
      "commitAuthorOld": "Phil Steitz",
      "daysBetweenCommits": 0.83,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public double solve(final UnivariateRealFunction f, final double min, final double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifyInterval(min, max);\n    double x0 \u003d min;\n    double x1 \u003d max;\n    double y0 \u003d f.value(x0);\n    double y1 \u003d f.value(x1);\n    if (y0 * y1 \u003e\u003d 0) {\n        throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\" + \"  Endpoints: [\" + min + \",\" + max + \"]\" + \"  Values: [\" + y0 + \",\" + y1 + \"]\");\n    }\n    double x2 \u003d x0;\n    double y2 \u003d y0;\n    double oldDelta \u003d x2 - x1;\n    int i \u003d 0;\n    while (i \u003c maximalIterationCount) {\n        if (Math.abs(y2) \u003c Math.abs(y1)) {\n            x0 \u003d x1;\n            x1 \u003d x2;\n            x2 \u003d x0;\n            y0 \u003d y1;\n            y1 \u003d y2;\n            y2 \u003d y0;\n        }\n        if (Math.abs(y1) \u003c\u003d functionValueAccuracy) {\n            setResult(x1, i);\n            return result;\n        }\n        if (Math.abs(oldDelta) \u003c Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy)) {\n            setResult(x1, i);\n            return result;\n        }\n        double delta;\n        if (Math.abs(y1) \u003e Math.abs(y0)) {\n            delta \u003d 0.5 * oldDelta;\n        } else {\n            delta \u003d (x0 - x1) / (1 - y0 / y1);\n            if (delta / oldDelta \u003e 1) {\n                delta \u003d 0.5 * oldDelta;\n            }\n        }\n        x0 \u003d x1;\n        y0 \u003d y1;\n        x1 \u003d x1 + delta;\n        y1 \u003d f.value(x1);\n        if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n            x2 \u003d x0;\n            y2 \u003d y0;\n        }\n        oldDelta \u003d x2 - x1;\n        i++;\n    }\n    throw new MaxIterationsExceededException(maximalIterationCount);\n}",
      "path": "src/java/org/apache/commons/math/analysis/solvers/SecantSolver.java",
      "functionStartLine": 114,
      "functionName": "solve",
      "functionAnnotation": "",
      "functionDoc": "Find a zero in the given interval.\n\n@param f the function to solve\n@param min the lower bound for the interval.\n@param max the upper bound for the interval.\n@return the value where the function is zero\n@throws MaxIterationsExceededException  if the maximum iteration count is exceeded\n@throws FunctionEvaluationException if an error occurs evaluating the\nfunction\n@throws IllegalArgumentException if min is not less than max or the\nsigns of the values of the function at the endpoints are not opposites\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/commons/math/analysis/SecantSolver.java",
        "newPath": "src/java/org/apache/commons/math/analysis/solvers/SecantSolver.java"
      }
    },
    "583dffc0ee383e9b5e1e08c574de10db8270fdb7": {
      "type": "Ymultichange(Yparameterchange,Yparametermetachange,Ydocchange)",
      "commitMessage": "The root solvers now take the function to solve as a parameter to\nthe solve methods, thus allowing to reuse the same solver for different\nfunctions.\n\nJIRA:MATH-218\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@724191 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/7/08, 12:24 PM",
      "commitName": "583dffc0ee383e9b5e1e08c574de10db8270fdb7",
      "commitAuthor": "Luc Maisonobe",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "The root solvers now take the function to solve as a parameter to\nthe solve methods, thus allowing to reuse the same solver for different\nfunctions.\n\nJIRA:MATH-218\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@724191 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "12/7/08, 12:24 PM",
          "commitName": "583dffc0ee383e9b5e1e08c574de10db8270fdb7",
          "commitAuthor": "Luc Maisonobe",
          "commitDateOld": "1/27/08, 10:10 PM",
          "commitNameOld": "932ebf87acd81162cc7b1751c18b0e0ca760c8bf",
          "commitAuthorOld": "Phil Steitz",
          "daysBetweenCommits": 314.59,
          "commitsBetweenForRepo": 296,
          "commitsBetweenForFile": 1,
          "actualSource": "public double solve(final UnivariateRealFunction f, final double min, final double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifyInterval(min, max);\n    double x0 \u003d min;\n    double x1 \u003d max;\n    double y0 \u003d f.value(x0);\n    double y1 \u003d f.value(x1);\n    if (y0 * y1 \u003e\u003d 0) {\n        throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\" + \"  Endpoints: [\" + min + \",\" + max + \"]\" + \"  Values: [\" + y0 + \",\" + y1 + \"]\");\n    }\n    double x2 \u003d x0;\n    double y2 \u003d y0;\n    double oldDelta \u003d x2 - x1;\n    int i \u003d 0;\n    while (i \u003c maximalIterationCount) {\n        if (Math.abs(y2) \u003c Math.abs(y1)) {\n            x0 \u003d x1;\n            x1 \u003d x2;\n            x2 \u003d x0;\n            y0 \u003d y1;\n            y1 \u003d y2;\n            y2 \u003d y0;\n        }\n        if (Math.abs(y1) \u003c\u003d functionValueAccuracy) {\n            setResult(x1, i);\n            return result;\n        }\n        if (Math.abs(oldDelta) \u003c Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy)) {\n            setResult(x1, i);\n            return result;\n        }\n        double delta;\n        if (Math.abs(y1) \u003e Math.abs(y0)) {\n            delta \u003d 0.5 * oldDelta;\n        } else {\n            delta \u003d (x0 - x1) / (1 - y0 / y1);\n            if (delta / oldDelta \u003e 1) {\n                delta \u003d 0.5 * oldDelta;\n            }\n        }\n        x0 \u003d x1;\n        y0 \u003d y1;\n        x1 \u003d x1 + delta;\n        y1 \u003d f.value(x1);\n        if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n            x2 \u003d x0;\n            y2 \u003d y0;\n        }\n        oldDelta \u003d x2 - x1;\n        i++;\n    }\n    throw new MaxIterationsExceededException(maximalIterationCount);\n}",
          "path": "src/java/org/apache/commons/math/analysis/SecantSolver.java",
          "functionStartLine": 113,
          "functionName": "solve",
          "functionAnnotation": "",
          "functionDoc": "Find a zero in the given interval.\n\n@param f the function to solve\n@param min the lower bound for the interval.\n@param max the upper bound for the interval.\n@return the value where the function is zero\n@throws MaxIterationsExceededException  if the maximum iteration count is exceeded\n@throws FunctionEvaluationException if an error occurs evaluating the\nfunction\n@throws IllegalArgumentException if min is not less than max or the\nsigns of the values of the function at the endpoints are not opposites\n",
          "diff": "@@ -1,53 +1,53 @@\n-public double solve(double min, double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n+public double solve(final UnivariateRealFunction f, final double min, final double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n     clearResult();\n     verifyInterval(min, max);\n     double x0 \u003d min;\n     double x1 \u003d max;\n     double y0 \u003d f.value(x0);\n     double y1 \u003d f.value(x1);\n     if (y0 * y1 \u003e\u003d 0) {\n         throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\" + \"  Endpoints: [\" + min + \",\" + max + \"]\" + \"  Values: [\" + y0 + \",\" + y1 + \"]\");\n     }\n     double x2 \u003d x0;\n     double y2 \u003d y0;\n     double oldDelta \u003d x2 - x1;\n     int i \u003d 0;\n     while (i \u003c maximalIterationCount) {\n         if (Math.abs(y2) \u003c Math.abs(y1)) {\n             x0 \u003d x1;\n             x1 \u003d x2;\n             x2 \u003d x0;\n             y0 \u003d y1;\n             y1 \u003d y2;\n             y2 \u003d y0;\n         }\n         if (Math.abs(y1) \u003c\u003d functionValueAccuracy) {\n             setResult(x1, i);\n             return result;\n         }\n         if (Math.abs(oldDelta) \u003c Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy)) {\n             setResult(x1, i);\n             return result;\n         }\n         double delta;\n         if (Math.abs(y1) \u003e Math.abs(y0)) {\n             delta \u003d 0.5 * oldDelta;\n         } else {\n             delta \u003d (x0 - x1) / (1 - y0 / y1);\n             if (delta / oldDelta \u003e 1) {\n                 delta \u003d 0.5 * oldDelta;\n             }\n         }\n         x0 \u003d x1;\n         y0 \u003d y1;\n         x1 \u003d x1 + delta;\n         y1 \u003d f.value(x1);\n         if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n             x2 \u003d x0;\n             y2 \u003d y0;\n         }\n         oldDelta \u003d x2 - x1;\n         i++;\n     }\n     throw new MaxIterationsExceededException(maximalIterationCount);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[min-double, max-double]",
            "newValue": "[f-UnivariateRealFunction(modifiers-final), min-double(modifiers-final), max-double(modifiers-final)]"
          }
        },
        {
          "type": "Yparametermetachange",
          "commitMessage": "The root solvers now take the function to solve as a parameter to\nthe solve methods, thus allowing to reuse the same solver for different\nfunctions.\n\nJIRA:MATH-218\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@724191 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "12/7/08, 12:24 PM",
          "commitName": "583dffc0ee383e9b5e1e08c574de10db8270fdb7",
          "commitAuthor": "Luc Maisonobe",
          "commitDateOld": "1/27/08, 10:10 PM",
          "commitNameOld": "932ebf87acd81162cc7b1751c18b0e0ca760c8bf",
          "commitAuthorOld": "Phil Steitz",
          "daysBetweenCommits": 314.59,
          "commitsBetweenForRepo": 296,
          "commitsBetweenForFile": 1,
          "actualSource": "public double solve(final UnivariateRealFunction f, final double min, final double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifyInterval(min, max);\n    double x0 \u003d min;\n    double x1 \u003d max;\n    double y0 \u003d f.value(x0);\n    double y1 \u003d f.value(x1);\n    if (y0 * y1 \u003e\u003d 0) {\n        throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\" + \"  Endpoints: [\" + min + \",\" + max + \"]\" + \"  Values: [\" + y0 + \",\" + y1 + \"]\");\n    }\n    double x2 \u003d x0;\n    double y2 \u003d y0;\n    double oldDelta \u003d x2 - x1;\n    int i \u003d 0;\n    while (i \u003c maximalIterationCount) {\n        if (Math.abs(y2) \u003c Math.abs(y1)) {\n            x0 \u003d x1;\n            x1 \u003d x2;\n            x2 \u003d x0;\n            y0 \u003d y1;\n            y1 \u003d y2;\n            y2 \u003d y0;\n        }\n        if (Math.abs(y1) \u003c\u003d functionValueAccuracy) {\n            setResult(x1, i);\n            return result;\n        }\n        if (Math.abs(oldDelta) \u003c Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy)) {\n            setResult(x1, i);\n            return result;\n        }\n        double delta;\n        if (Math.abs(y1) \u003e Math.abs(y0)) {\n            delta \u003d 0.5 * oldDelta;\n        } else {\n            delta \u003d (x0 - x1) / (1 - y0 / y1);\n            if (delta / oldDelta \u003e 1) {\n                delta \u003d 0.5 * oldDelta;\n            }\n        }\n        x0 \u003d x1;\n        y0 \u003d y1;\n        x1 \u003d x1 + delta;\n        y1 \u003d f.value(x1);\n        if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n            x2 \u003d x0;\n            y2 \u003d y0;\n        }\n        oldDelta \u003d x2 - x1;\n        i++;\n    }\n    throw new MaxIterationsExceededException(maximalIterationCount);\n}",
          "path": "src/java/org/apache/commons/math/analysis/SecantSolver.java",
          "functionStartLine": 113,
          "functionName": "solve",
          "functionAnnotation": "",
          "functionDoc": "Find a zero in the given interval.\n\n@param f the function to solve\n@param min the lower bound for the interval.\n@param max the upper bound for the interval.\n@return the value where the function is zero\n@throws MaxIterationsExceededException  if the maximum iteration count is exceeded\n@throws FunctionEvaluationException if an error occurs evaluating the\nfunction\n@throws IllegalArgumentException if min is not less than max or the\nsigns of the values of the function at the endpoints are not opposites\n",
          "diff": "@@ -1,53 +1,53 @@\n-public double solve(double min, double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n+public double solve(final UnivariateRealFunction f, final double min, final double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n     clearResult();\n     verifyInterval(min, max);\n     double x0 \u003d min;\n     double x1 \u003d max;\n     double y0 \u003d f.value(x0);\n     double y1 \u003d f.value(x1);\n     if (y0 * y1 \u003e\u003d 0) {\n         throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\" + \"  Endpoints: [\" + min + \",\" + max + \"]\" + \"  Values: [\" + y0 + \",\" + y1 + \"]\");\n     }\n     double x2 \u003d x0;\n     double y2 \u003d y0;\n     double oldDelta \u003d x2 - x1;\n     int i \u003d 0;\n     while (i \u003c maximalIterationCount) {\n         if (Math.abs(y2) \u003c Math.abs(y1)) {\n             x0 \u003d x1;\n             x1 \u003d x2;\n             x2 \u003d x0;\n             y0 \u003d y1;\n             y1 \u003d y2;\n             y2 \u003d y0;\n         }\n         if (Math.abs(y1) \u003c\u003d functionValueAccuracy) {\n             setResult(x1, i);\n             return result;\n         }\n         if (Math.abs(oldDelta) \u003c Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy)) {\n             setResult(x1, i);\n             return result;\n         }\n         double delta;\n         if (Math.abs(y1) \u003e Math.abs(y0)) {\n             delta \u003d 0.5 * oldDelta;\n         } else {\n             delta \u003d (x0 - x1) / (1 - y0 / y1);\n             if (delta / oldDelta \u003e 1) {\n                 delta \u003d 0.5 * oldDelta;\n             }\n         }\n         x0 \u003d x1;\n         y0 \u003d y1;\n         x1 \u003d x1 + delta;\n         y1 \u003d f.value(x1);\n         if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n             x2 \u003d x0;\n             y2 \u003d y0;\n         }\n         oldDelta \u003d x2 - x1;\n         i++;\n     }\n     throw new MaxIterationsExceededException(maximalIterationCount);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[min-double, max-double]",
            "newValue": "[f-UnivariateRealFunction(modifiers-final), min-double(modifiers-final), max-double(modifiers-final)]"
          }
        },
        {
          "type": "Ydocchange",
          "commitMessage": "The root solvers now take the function to solve as a parameter to\nthe solve methods, thus allowing to reuse the same solver for different\nfunctions.\n\nJIRA:MATH-218\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@724191 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "12/7/08, 12:24 PM",
          "commitName": "583dffc0ee383e9b5e1e08c574de10db8270fdb7",
          "commitAuthor": "Luc Maisonobe",
          "commitDateOld": "1/27/08, 10:10 PM",
          "commitNameOld": "932ebf87acd81162cc7b1751c18b0e0ca760c8bf",
          "commitAuthorOld": "Phil Steitz",
          "daysBetweenCommits": 314.59,
          "commitsBetweenForRepo": 296,
          "commitsBetweenForFile": 1,
          "actualSource": "public double solve(final UnivariateRealFunction f, final double min, final double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifyInterval(min, max);\n    double x0 \u003d min;\n    double x1 \u003d max;\n    double y0 \u003d f.value(x0);\n    double y1 \u003d f.value(x1);\n    if (y0 * y1 \u003e\u003d 0) {\n        throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\" + \"  Endpoints: [\" + min + \",\" + max + \"]\" + \"  Values: [\" + y0 + \",\" + y1 + \"]\");\n    }\n    double x2 \u003d x0;\n    double y2 \u003d y0;\n    double oldDelta \u003d x2 - x1;\n    int i \u003d 0;\n    while (i \u003c maximalIterationCount) {\n        if (Math.abs(y2) \u003c Math.abs(y1)) {\n            x0 \u003d x1;\n            x1 \u003d x2;\n            x2 \u003d x0;\n            y0 \u003d y1;\n            y1 \u003d y2;\n            y2 \u003d y0;\n        }\n        if (Math.abs(y1) \u003c\u003d functionValueAccuracy) {\n            setResult(x1, i);\n            return result;\n        }\n        if (Math.abs(oldDelta) \u003c Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy)) {\n            setResult(x1, i);\n            return result;\n        }\n        double delta;\n        if (Math.abs(y1) \u003e Math.abs(y0)) {\n            delta \u003d 0.5 * oldDelta;\n        } else {\n            delta \u003d (x0 - x1) / (1 - y0 / y1);\n            if (delta / oldDelta \u003e 1) {\n                delta \u003d 0.5 * oldDelta;\n            }\n        }\n        x0 \u003d x1;\n        y0 \u003d y1;\n        x1 \u003d x1 + delta;\n        y1 \u003d f.value(x1);\n        if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n            x2 \u003d x0;\n            y2 \u003d y0;\n        }\n        oldDelta \u003d x2 - x1;\n        i++;\n    }\n    throw new MaxIterationsExceededException(maximalIterationCount);\n}",
          "path": "src/java/org/apache/commons/math/analysis/SecantSolver.java",
          "functionStartLine": 113,
          "functionName": "solve",
          "functionAnnotation": "",
          "functionDoc": "Find a zero in the given interval.\n\n@param f the function to solve\n@param min the lower bound for the interval.\n@param max the upper bound for the interval.\n@return the value where the function is zero\n@throws MaxIterationsExceededException  if the maximum iteration count is exceeded\n@throws FunctionEvaluationException if an error occurs evaluating the\nfunction\n@throws IllegalArgumentException if min is not less than max or the\nsigns of the values of the function at the endpoints are not opposites\n",
          "diff": "@@ -1,53 +1,53 @@\n-public double solve(double min, double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n+public double solve(final UnivariateRealFunction f, final double min, final double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n     clearResult();\n     verifyInterval(min, max);\n     double x0 \u003d min;\n     double x1 \u003d max;\n     double y0 \u003d f.value(x0);\n     double y1 \u003d f.value(x1);\n     if (y0 * y1 \u003e\u003d 0) {\n         throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\" + \"  Endpoints: [\" + min + \",\" + max + \"]\" + \"  Values: [\" + y0 + \",\" + y1 + \"]\");\n     }\n     double x2 \u003d x0;\n     double y2 \u003d y0;\n     double oldDelta \u003d x2 - x1;\n     int i \u003d 0;\n     while (i \u003c maximalIterationCount) {\n         if (Math.abs(y2) \u003c Math.abs(y1)) {\n             x0 \u003d x1;\n             x1 \u003d x2;\n             x2 \u003d x0;\n             y0 \u003d y1;\n             y1 \u003d y2;\n             y2 \u003d y0;\n         }\n         if (Math.abs(y1) \u003c\u003d functionValueAccuracy) {\n             setResult(x1, i);\n             return result;\n         }\n         if (Math.abs(oldDelta) \u003c Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy)) {\n             setResult(x1, i);\n             return result;\n         }\n         double delta;\n         if (Math.abs(y1) \u003e Math.abs(y0)) {\n             delta \u003d 0.5 * oldDelta;\n         } else {\n             delta \u003d (x0 - x1) / (1 - y0 / y1);\n             if (delta / oldDelta \u003e 1) {\n                 delta \u003d 0.5 * oldDelta;\n             }\n         }\n         x0 \u003d x1;\n         y0 \u003d y1;\n         x1 \u003d x1 + delta;\n         y1 \u003d f.value(x1);\n         if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n             x2 \u003d x0;\n             y2 \u003d y0;\n         }\n         oldDelta \u003d x2 - x1;\n         i++;\n     }\n     throw new MaxIterationsExceededException(maximalIterationCount);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Find a zero in the given interval.\n\n@param min the lower bound for the interval.\n@param max the upper bound for the interval.\n@return the value where the function is zero\n@throws MaxIterationsExceededException  if the maximum iteration count is exceeded\n@throws FunctionEvaluationException if an error occurs evaluating the\nfunction\n@throws IllegalArgumentException if min is not less than max or the\nsigns of the values of the function at the endpoints are not opposites\n",
            "newValue": "Find a zero in the given interval.\n\n@param f the function to solve\n@param min the lower bound for the interval.\n@param max the upper bound for the interval.\n@return the value where the function is zero\n@throws MaxIterationsExceededException  if the maximum iteration count is exceeded\n@throws FunctionEvaluationException if an error occurs evaluating the\nfunction\n@throws IllegalArgumentException if min is not less than max or the\nsigns of the values of the function at the endpoints are not opposites\n"
          }
        }
      ]
    },
    "d2d4c5fd63f279be0797468277593ef72506c696": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange,Ydocchange)",
      "commitMessage": "Added and used a specialized convergence exception for exceeded iteration counts\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/math/trunk@506585 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2/12/07, 11:17 AM",
      "commitName": "d2d4c5fd63f279be0797468277593ef72506c696",
      "commitAuthor": "Luc Maisonobe",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "Added and used a specialized convergence exception for exceeded iteration counts\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/math/trunk@506585 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2/12/07, 11:17 AM",
          "commitName": "d2d4c5fd63f279be0797468277593ef72506c696",
          "commitAuthor": "Luc Maisonobe",
          "commitDateOld": "11/28/06, 11:14 PM",
          "commitNameOld": "05f7f6059bd0cbb69b5dd49c061f1f3520e0ee1e",
          "commitAuthorOld": "Henri Yandell",
          "daysBetweenCommits": 75.5,
          "commitsBetweenForRepo": 8,
          "commitsBetweenForFile": 1,
          "actualSource": "public double solve(double min, double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifyInterval(min, max);\n    double x0 \u003d min;\n    double x1 \u003d max;\n    double y0 \u003d f.value(x0);\n    double y1 \u003d f.value(x1);\n    if (y0 * y1 \u003e\u003d 0) {\n        throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\" + \"  Endpoints: [\" + min + \",\" + max + \"]\" + \"  Values: [\" + y0 + \",\" + y1 + \"]\");\n    }\n    double x2 \u003d x0;\n    double y2 \u003d y0;\n    double oldDelta \u003d x2 - x1;\n    int i \u003d 0;\n    while (i \u003c maximalIterationCount) {\n        if (Math.abs(y2) \u003c Math.abs(y1)) {\n            x0 \u003d x1;\n            x1 \u003d x2;\n            x2 \u003d x0;\n            y0 \u003d y1;\n            y1 \u003d y2;\n            y2 \u003d y0;\n        }\n        if (Math.abs(y1) \u003c\u003d functionValueAccuracy) {\n            setResult(x1, i);\n            return result;\n        }\n        if (Math.abs(oldDelta) \u003c Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy)) {\n            setResult(x1, i);\n            return result;\n        }\n        double delta;\n        if (Math.abs(y1) \u003e Math.abs(y0)) {\n            delta \u003d 0.5 * oldDelta;\n        } else {\n            delta \u003d (x0 - x1) / (1 - y0 / y1);\n            if (delta / oldDelta \u003e 1) {\n                delta \u003d 0.5 * oldDelta;\n            }\n        }\n        x0 \u003d x1;\n        y0 \u003d y1;\n        x1 \u003d x1 + delta;\n        y1 \u003d f.value(x1);\n        if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n            x2 \u003d x0;\n            y2 \u003d y0;\n        }\n        oldDelta \u003d x2 - x1;\n        i++;\n    }\n    throw new MaxIterationsExceededException(maximalIterationCount);\n}",
          "path": "src/java/org/apache/commons/math/analysis/SecantSolver.java",
          "functionStartLine": 84,
          "functionName": "solve",
          "functionAnnotation": "",
          "functionDoc": "Find a zero in the given interval.\n\n@param min the lower bound for the interval.\n@param max the upper bound for the interval.\n@return the value where the function is zero\n@throws MaxIterationsExceededException  if the maximum iteration count is exceeded\n@throws FunctionEvaluationException if an error occurs evaluating the\nfunction\n@throws IllegalArgumentException if min is not less than max or the\nsigns of the values of the function at the endpoints are not opposites\n",
          "diff": "@@ -1,53 +1,53 @@\n-public double solve(double min, double max) throws ConvergenceException, FunctionEvaluationException {\n+public double solve(double min, double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n     clearResult();\n     verifyInterval(min, max);\n     double x0 \u003d min;\n     double x1 \u003d max;\n     double y0 \u003d f.value(x0);\n     double y1 \u003d f.value(x1);\n     if (y0 * y1 \u003e\u003d 0) {\n         throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\" + \"  Endpoints: [\" + min + \",\" + max + \"]\" + \"  Values: [\" + y0 + \",\" + y1 + \"]\");\n     }\n     double x2 \u003d x0;\n     double y2 \u003d y0;\n     double oldDelta \u003d x2 - x1;\n     int i \u003d 0;\n     while (i \u003c maximalIterationCount) {\n         if (Math.abs(y2) \u003c Math.abs(y1)) {\n             x0 \u003d x1;\n             x1 \u003d x2;\n             x2 \u003d x0;\n             y0 \u003d y1;\n             y1 \u003d y2;\n             y2 \u003d y0;\n         }\n         if (Math.abs(y1) \u003c\u003d functionValueAccuracy) {\n             setResult(x1, i);\n             return result;\n         }\n         if (Math.abs(oldDelta) \u003c Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy)) {\n             setResult(x1, i);\n             return result;\n         }\n         double delta;\n         if (Math.abs(y1) \u003e Math.abs(y0)) {\n             delta \u003d 0.5 * oldDelta;\n         } else {\n             delta \u003d (x0 - x1) / (1 - y0 / y1);\n             if (delta / oldDelta \u003e 1) {\n                 delta \u003d 0.5 * oldDelta;\n             }\n         }\n         x0 \u003d x1;\n         y0 \u003d y1;\n         x1 \u003d x1 + delta;\n         y1 \u003d f.value(x1);\n         if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n             x2 \u003d x0;\n             y2 \u003d y0;\n         }\n         oldDelta \u003d x2 - x1;\n         i++;\n     }\n-    throw new ConvergenceException(\"Maximal iteration number exceeded\" + i);\n+    throw new MaxIterationsExceededException(maximalIterationCount);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[ConvergenceException, FunctionEvaluationException]",
            "newValue": "[MaxIterationsExceededException, FunctionEvaluationException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Added and used a specialized convergence exception for exceeded iteration counts\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/math/trunk@506585 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2/12/07, 11:17 AM",
          "commitName": "d2d4c5fd63f279be0797468277593ef72506c696",
          "commitAuthor": "Luc Maisonobe",
          "commitDateOld": "11/28/06, 11:14 PM",
          "commitNameOld": "05f7f6059bd0cbb69b5dd49c061f1f3520e0ee1e",
          "commitAuthorOld": "Henri Yandell",
          "daysBetweenCommits": 75.5,
          "commitsBetweenForRepo": 8,
          "commitsBetweenForFile": 1,
          "actualSource": "public double solve(double min, double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifyInterval(min, max);\n    double x0 \u003d min;\n    double x1 \u003d max;\n    double y0 \u003d f.value(x0);\n    double y1 \u003d f.value(x1);\n    if (y0 * y1 \u003e\u003d 0) {\n        throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\" + \"  Endpoints: [\" + min + \",\" + max + \"]\" + \"  Values: [\" + y0 + \",\" + y1 + \"]\");\n    }\n    double x2 \u003d x0;\n    double y2 \u003d y0;\n    double oldDelta \u003d x2 - x1;\n    int i \u003d 0;\n    while (i \u003c maximalIterationCount) {\n        if (Math.abs(y2) \u003c Math.abs(y1)) {\n            x0 \u003d x1;\n            x1 \u003d x2;\n            x2 \u003d x0;\n            y0 \u003d y1;\n            y1 \u003d y2;\n            y2 \u003d y0;\n        }\n        if (Math.abs(y1) \u003c\u003d functionValueAccuracy) {\n            setResult(x1, i);\n            return result;\n        }\n        if (Math.abs(oldDelta) \u003c Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy)) {\n            setResult(x1, i);\n            return result;\n        }\n        double delta;\n        if (Math.abs(y1) \u003e Math.abs(y0)) {\n            delta \u003d 0.5 * oldDelta;\n        } else {\n            delta \u003d (x0 - x1) / (1 - y0 / y1);\n            if (delta / oldDelta \u003e 1) {\n                delta \u003d 0.5 * oldDelta;\n            }\n        }\n        x0 \u003d x1;\n        y0 \u003d y1;\n        x1 \u003d x1 + delta;\n        y1 \u003d f.value(x1);\n        if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n            x2 \u003d x0;\n            y2 \u003d y0;\n        }\n        oldDelta \u003d x2 - x1;\n        i++;\n    }\n    throw new MaxIterationsExceededException(maximalIterationCount);\n}",
          "path": "src/java/org/apache/commons/math/analysis/SecantSolver.java",
          "functionStartLine": 84,
          "functionName": "solve",
          "functionAnnotation": "",
          "functionDoc": "Find a zero in the given interval.\n\n@param min the lower bound for the interval.\n@param max the upper bound for the interval.\n@return the value where the function is zero\n@throws MaxIterationsExceededException  if the maximum iteration count is exceeded\n@throws FunctionEvaluationException if an error occurs evaluating the\nfunction\n@throws IllegalArgumentException if min is not less than max or the\nsigns of the values of the function at the endpoints are not opposites\n",
          "diff": "@@ -1,53 +1,53 @@\n-public double solve(double min, double max) throws ConvergenceException, FunctionEvaluationException {\n+public double solve(double min, double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n     clearResult();\n     verifyInterval(min, max);\n     double x0 \u003d min;\n     double x1 \u003d max;\n     double y0 \u003d f.value(x0);\n     double y1 \u003d f.value(x1);\n     if (y0 * y1 \u003e\u003d 0) {\n         throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\" + \"  Endpoints: [\" + min + \",\" + max + \"]\" + \"  Values: [\" + y0 + \",\" + y1 + \"]\");\n     }\n     double x2 \u003d x0;\n     double y2 \u003d y0;\n     double oldDelta \u003d x2 - x1;\n     int i \u003d 0;\n     while (i \u003c maximalIterationCount) {\n         if (Math.abs(y2) \u003c Math.abs(y1)) {\n             x0 \u003d x1;\n             x1 \u003d x2;\n             x2 \u003d x0;\n             y0 \u003d y1;\n             y1 \u003d y2;\n             y2 \u003d y0;\n         }\n         if (Math.abs(y1) \u003c\u003d functionValueAccuracy) {\n             setResult(x1, i);\n             return result;\n         }\n         if (Math.abs(oldDelta) \u003c Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy)) {\n             setResult(x1, i);\n             return result;\n         }\n         double delta;\n         if (Math.abs(y1) \u003e Math.abs(y0)) {\n             delta \u003d 0.5 * oldDelta;\n         } else {\n             delta \u003d (x0 - x1) / (1 - y0 / y1);\n             if (delta / oldDelta \u003e 1) {\n                 delta \u003d 0.5 * oldDelta;\n             }\n         }\n         x0 \u003d x1;\n         y0 \u003d y1;\n         x1 \u003d x1 + delta;\n         y1 \u003d f.value(x1);\n         if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n             x2 \u003d x0;\n             y2 \u003d y0;\n         }\n         oldDelta \u003d x2 - x1;\n         i++;\n     }\n-    throw new ConvergenceException(\"Maximal iteration number exceeded\" + i);\n+    throw new MaxIterationsExceededException(maximalIterationCount);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Added and used a specialized convergence exception for exceeded iteration counts\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/math/trunk@506585 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2/12/07, 11:17 AM",
          "commitName": "d2d4c5fd63f279be0797468277593ef72506c696",
          "commitAuthor": "Luc Maisonobe",
          "commitDateOld": "11/28/06, 11:14 PM",
          "commitNameOld": "05f7f6059bd0cbb69b5dd49c061f1f3520e0ee1e",
          "commitAuthorOld": "Henri Yandell",
          "daysBetweenCommits": 75.5,
          "commitsBetweenForRepo": 8,
          "commitsBetweenForFile": 1,
          "actualSource": "public double solve(double min, double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifyInterval(min, max);\n    double x0 \u003d min;\n    double x1 \u003d max;\n    double y0 \u003d f.value(x0);\n    double y1 \u003d f.value(x1);\n    if (y0 * y1 \u003e\u003d 0) {\n        throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\" + \"  Endpoints: [\" + min + \",\" + max + \"]\" + \"  Values: [\" + y0 + \",\" + y1 + \"]\");\n    }\n    double x2 \u003d x0;\n    double y2 \u003d y0;\n    double oldDelta \u003d x2 - x1;\n    int i \u003d 0;\n    while (i \u003c maximalIterationCount) {\n        if (Math.abs(y2) \u003c Math.abs(y1)) {\n            x0 \u003d x1;\n            x1 \u003d x2;\n            x2 \u003d x0;\n            y0 \u003d y1;\n            y1 \u003d y2;\n            y2 \u003d y0;\n        }\n        if (Math.abs(y1) \u003c\u003d functionValueAccuracy) {\n            setResult(x1, i);\n            return result;\n        }\n        if (Math.abs(oldDelta) \u003c Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy)) {\n            setResult(x1, i);\n            return result;\n        }\n        double delta;\n        if (Math.abs(y1) \u003e Math.abs(y0)) {\n            delta \u003d 0.5 * oldDelta;\n        } else {\n            delta \u003d (x0 - x1) / (1 - y0 / y1);\n            if (delta / oldDelta \u003e 1) {\n                delta \u003d 0.5 * oldDelta;\n            }\n        }\n        x0 \u003d x1;\n        y0 \u003d y1;\n        x1 \u003d x1 + delta;\n        y1 \u003d f.value(x1);\n        if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n            x2 \u003d x0;\n            y2 \u003d y0;\n        }\n        oldDelta \u003d x2 - x1;\n        i++;\n    }\n    throw new MaxIterationsExceededException(maximalIterationCount);\n}",
          "path": "src/java/org/apache/commons/math/analysis/SecantSolver.java",
          "functionStartLine": 84,
          "functionName": "solve",
          "functionAnnotation": "",
          "functionDoc": "Find a zero in the given interval.\n\n@param min the lower bound for the interval.\n@param max the upper bound for the interval.\n@return the value where the function is zero\n@throws MaxIterationsExceededException  if the maximum iteration count is exceeded\n@throws FunctionEvaluationException if an error occurs evaluating the\nfunction\n@throws IllegalArgumentException if min is not less than max or the\nsigns of the values of the function at the endpoints are not opposites\n",
          "diff": "@@ -1,53 +1,53 @@\n-public double solve(double min, double max) throws ConvergenceException, FunctionEvaluationException {\n+public double solve(double min, double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n     clearResult();\n     verifyInterval(min, max);\n     double x0 \u003d min;\n     double x1 \u003d max;\n     double y0 \u003d f.value(x0);\n     double y1 \u003d f.value(x1);\n     if (y0 * y1 \u003e\u003d 0) {\n         throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\" + \"  Endpoints: [\" + min + \",\" + max + \"]\" + \"  Values: [\" + y0 + \",\" + y1 + \"]\");\n     }\n     double x2 \u003d x0;\n     double y2 \u003d y0;\n     double oldDelta \u003d x2 - x1;\n     int i \u003d 0;\n     while (i \u003c maximalIterationCount) {\n         if (Math.abs(y2) \u003c Math.abs(y1)) {\n             x0 \u003d x1;\n             x1 \u003d x2;\n             x2 \u003d x0;\n             y0 \u003d y1;\n             y1 \u003d y2;\n             y2 \u003d y0;\n         }\n         if (Math.abs(y1) \u003c\u003d functionValueAccuracy) {\n             setResult(x1, i);\n             return result;\n         }\n         if (Math.abs(oldDelta) \u003c Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy)) {\n             setResult(x1, i);\n             return result;\n         }\n         double delta;\n         if (Math.abs(y1) \u003e Math.abs(y0)) {\n             delta \u003d 0.5 * oldDelta;\n         } else {\n             delta \u003d (x0 - x1) / (1 - y0 / y1);\n             if (delta / oldDelta \u003e 1) {\n                 delta \u003d 0.5 * oldDelta;\n             }\n         }\n         x0 \u003d x1;\n         y0 \u003d y1;\n         x1 \u003d x1 + delta;\n         y1 \u003d f.value(x1);\n         if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n             x2 \u003d x0;\n             y2 \u003d y0;\n         }\n         oldDelta \u003d x2 - x1;\n         i++;\n     }\n-    throw new ConvergenceException(\"Maximal iteration number exceeded\" + i);\n+    throw new MaxIterationsExceededException(maximalIterationCount);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Find a zero in the given interval.\n\n@param min the lower bound for the interval.\n@param max the upper bound for the interval.\n@return the value where the function is zero\n@throws ConvergenceException  if the maximum iteration count is exceeded\n@throws FunctionEvaluationException if an error occurs evaluating the\nfunction\n@throws IllegalArgumentException if min is not less than max or the\nsigns of the values of the function at the endpoints are not opposites\n",
            "newValue": "Find a zero in the given interval.\n\n@param min the lower bound for the interval.\n@param max the upper bound for the interval.\n@return the value where the function is zero\n@throws MaxIterationsExceededException  if the maximum iteration count is exceeded\n@throws FunctionEvaluationException if an error occurs evaluating the\nfunction\n@throws IllegalArgumentException if min is not less than max or the\nsigns of the values of the function at the endpoints are not opposites\n"
          }
        }
      ]
    },
    "4f1e69b5313761cb95909359a408d13e6aa29635": {
      "type": "Ybodychange",
      "commitMessage": "Eliminated redundant endpoint function evaluations in BrentSolver, SecantSolver. BZ #35042.\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/math/trunk@179958 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "6/3/05, 10:36 PM",
      "commitName": "4f1e69b5313761cb95909359a408d13e6aa29635",
      "commitAuthor": "Phil Steitz",
      "commitDateOld": "2/26/05, 5:11 AM",
      "commitNameOld": "65b65f88b74de6b3462b04b2cf2a69f064a77557",
      "commitAuthorOld": "Dirk Verbeeck",
      "daysBetweenCommits": 97.68,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "actualSource": "public double solve(double min, double max) throws ConvergenceException, FunctionEvaluationException {\n    clearResult();\n    verifyInterval(min, max);\n    double x0 \u003d min;\n    double x1 \u003d max;\n    double y0 \u003d f.value(x0);\n    double y1 \u003d f.value(x1);\n    if (y0 * y1 \u003e\u003d 0) {\n        throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\" + \"  Endpoints: [\" + min + \",\" + max + \"]\" + \"  Values: [\" + y0 + \",\" + y1 + \"]\");\n    }\n    double x2 \u003d x0;\n    double y2 \u003d y0;\n    double oldDelta \u003d x2 - x1;\n    int i \u003d 0;\n    while (i \u003c maximalIterationCount) {\n        if (Math.abs(y2) \u003c Math.abs(y1)) {\n            x0 \u003d x1;\n            x1 \u003d x2;\n            x2 \u003d x0;\n            y0 \u003d y1;\n            y1 \u003d y2;\n            y2 \u003d y0;\n        }\n        if (Math.abs(y1) \u003c\u003d functionValueAccuracy) {\n            setResult(x1, i);\n            return result;\n        }\n        if (Math.abs(oldDelta) \u003c Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy)) {\n            setResult(x1, i);\n            return result;\n        }\n        double delta;\n        if (Math.abs(y1) \u003e Math.abs(y0)) {\n            delta \u003d 0.5 * oldDelta;\n        } else {\n            delta \u003d (x0 - x1) / (1 - y0 / y1);\n            if (delta / oldDelta \u003e 1) {\n                delta \u003d 0.5 * oldDelta;\n            }\n        }\n        x0 \u003d x1;\n        y0 \u003d y1;\n        x1 \u003d x1 + delta;\n        y1 \u003d f.value(x1);\n        if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n            x2 \u003d x0;\n            y2 \u003d y0;\n        }\n        oldDelta \u003d x2 - x1;\n        i++;\n    }\n    throw new ConvergenceException(\"Maximal iteration number exceeded\" + i);\n}",
      "path": "src/java/org/apache/commons/math/analysis/SecantSolver.java",
      "functionStartLine": 83,
      "functionName": "solve",
      "functionAnnotation": "",
      "functionDoc": "Find a zero in the given interval.\n\n@param min the lower bound for the interval.\n@param max the upper bound for the interval.\n@return the value where the function is zero\n@throws ConvergenceException  if the maximum iteration count is exceeded\n@throws FunctionEvaluationException if an error occurs evaluating the\nfunction\n@throws IllegalArgumentException if min is not less than max or the\nsigns of the values of the function at the endpoints are not opposites\n",
      "diff": "@@ -1,50 +1,53 @@\n public double solve(double min, double max) throws ConvergenceException, FunctionEvaluationException {\n     clearResult();\n-    verifyBracketing(min, max, f);\n+    verifyInterval(min, max);\n     double x0 \u003d min;\n     double x1 \u003d max;\n     double y0 \u003d f.value(x0);\n     double y1 \u003d f.value(x1);\n+    if (y0 * y1 \u003e\u003d 0) {\n+        throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\" + \"  Endpoints: [\" + min + \",\" + max + \"]\" + \"  Values: [\" + y0 + \",\" + y1 + \"]\");\n+    }\n     double x2 \u003d x0;\n     double y2 \u003d y0;\n     double oldDelta \u003d x2 - x1;\n     int i \u003d 0;\n     while (i \u003c maximalIterationCount) {\n         if (Math.abs(y2) \u003c Math.abs(y1)) {\n             x0 \u003d x1;\n             x1 \u003d x2;\n             x2 \u003d x0;\n             y0 \u003d y1;\n             y1 \u003d y2;\n             y2 \u003d y0;\n         }\n         if (Math.abs(y1) \u003c\u003d functionValueAccuracy) {\n             setResult(x1, i);\n             return result;\n         }\n         if (Math.abs(oldDelta) \u003c Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy)) {\n             setResult(x1, i);\n             return result;\n         }\n         double delta;\n         if (Math.abs(y1) \u003e Math.abs(y0)) {\n             delta \u003d 0.5 * oldDelta;\n         } else {\n             delta \u003d (x0 - x1) / (1 - y0 / y1);\n             if (delta / oldDelta \u003e 1) {\n                 delta \u003d 0.5 * oldDelta;\n             }\n         }\n         x0 \u003d x1;\n         y0 \u003d y1;\n         x1 \u003d x1 + delta;\n         y1 \u003d f.value(x1);\n         if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n             x2 \u003d x0;\n             y2 \u003d y0;\n         }\n         oldDelta \u003d x2 - x1;\n         i++;\n     }\n     throw new ConvergenceException(\"Maximal iteration number exceeded\" + i);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6a978ea29f680a87dfc380c760adf2e17b2e7c9c": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange,Ydocchange)",
      "commitMessage": "-Changed UnivariateRealFunction.solve() to throw FunctionEvaluationException.\n-Changed UnivariateRealSolver.solve() to throw more specific exceptions:\n  ConvergenceException if max iterations is exceeded\n  IllegalArgumentException if endpoints do not (appear to) bracket a root\n  FunctionEvaluationException if an error occurs evaluating the function\n-Changed UnivariateRealSolver setters to throw IllegalArgumentException\n instead of MathException when input property values are out of range.\n-Changed AbstractContinuousDistribution.inverseCumulativeProbability to handle\n corner cases where solution equals domain lower or upper bound.\n-Improved javadoc.\n-Improved test coverage.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/math/trunk@141391 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "7/17/04, 2:19 PM",
      "commitName": "6a978ea29f680a87dfc380c760adf2e17b2e7c9c",
      "commitAuthor": "Phil Steitz",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "-Changed UnivariateRealFunction.solve() to throw FunctionEvaluationException.\n-Changed UnivariateRealSolver.solve() to throw more specific exceptions:\n  ConvergenceException if max iterations is exceeded\n  IllegalArgumentException if endpoints do not (appear to) bracket a root\n  FunctionEvaluationException if an error occurs evaluating the function\n-Changed UnivariateRealSolver setters to throw IllegalArgumentException\n instead of MathException when input property values are out of range.\n-Changed AbstractContinuousDistribution.inverseCumulativeProbability to handle\n corner cases where solution equals domain lower or upper bound.\n-Improved javadoc.\n-Improved test coverage.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/math/trunk@141391 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "7/17/04, 2:19 PM",
          "commitName": "6a978ea29f680a87dfc380c760adf2e17b2e7c9c",
          "commitAuthor": "Phil Steitz",
          "commitDateOld": "6/23/04, 9:26 AM",
          "commitNameOld": "7b22aec5529fb3bad1e8098938271398d13c92ba",
          "commitAuthorOld": "Brent Worden",
          "daysBetweenCommits": 24.2,
          "commitsBetweenForRepo": 60,
          "commitsBetweenForFile": 1,
          "actualSource": "public double solve(double min, double max) throws ConvergenceException, FunctionEvaluationException {\n    clearResult();\n    verifyBracketing(min, max, f);\n    double x0 \u003d min;\n    double x1 \u003d max;\n    double y0 \u003d f.value(x0);\n    double y1 \u003d f.value(x1);\n    double x2 \u003d x0;\n    double y2 \u003d y0;\n    double oldDelta \u003d x2 - x1;\n    int i \u003d 0;\n    while (i \u003c maximalIterationCount) {\n        if (Math.abs(y2) \u003c Math.abs(y1)) {\n            x0 \u003d x1;\n            x1 \u003d x2;\n            x2 \u003d x0;\n            y0 \u003d y1;\n            y1 \u003d y2;\n            y2 \u003d y0;\n        }\n        if (Math.abs(y1) \u003c\u003d functionValueAccuracy) {\n            setResult(x1, i);\n            return result;\n        }\n        if (Math.abs(oldDelta) \u003c Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy)) {\n            setResult(x1, i);\n            return result;\n        }\n        double delta;\n        if (Math.abs(y1) \u003e Math.abs(y0)) {\n            delta \u003d 0.5 * oldDelta;\n        } else {\n            delta \u003d (x0 - x1) / (1 - y0 / y1);\n            if (delta / oldDelta \u003e 1) {\n                delta \u003d 0.5 * oldDelta;\n            }\n        }\n        x0 \u003d x1;\n        y0 \u003d y1;\n        x1 \u003d x1 + delta;\n        y1 \u003d f.value(x1);\n        if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n            x2 \u003d x0;\n            y2 \u003d y0;\n        }\n        oldDelta \u003d x2 - x1;\n        i++;\n    }\n    throw new ConvergenceException(\"Maximal iteration number exceeded\" + i);\n}",
          "path": "src/java/org/apache/commons/math/analysis/SecantSolver.java",
          "functionStartLine": 83,
          "functionName": "solve",
          "functionAnnotation": "",
          "functionDoc": "Find a zero in the given interval.\n\n@param min the lower bound for the interval.\n@param max the upper bound for the interval.\n@return the value where the function is zero\n@throws ConvergenceException  if the maximum iteration count is exceeded\n@throws FunctionEvaluationException if an error occurs evaluating the\nfunction\n@throws IllegalArgumentException if min is not less than max or the\nsigns of the values of the function at the endpoints are not opposites\n",
          "diff": "@@ -1,52 +1,50 @@\n-public double solve(double min, double max) throws MathException {\n+public double solve(double min, double max) throws ConvergenceException, FunctionEvaluationException {\n     clearResult();\n+    verifyBracketing(min, max, f);\n     double x0 \u003d min;\n     double x1 \u003d max;\n     double y0 \u003d f.value(x0);\n     double y1 \u003d f.value(x1);\n-    if ((y0 \u003e 0) \u003d\u003d (y1 \u003e 0)) {\n-        throw new MathException(\"Interval doesn\u0027t bracket a zero.\");\n-    }\n     double x2 \u003d x0;\n     double y2 \u003d y0;\n     double oldDelta \u003d x2 - x1;\n     int i \u003d 0;\n     while (i \u003c maximalIterationCount) {\n         if (Math.abs(y2) \u003c Math.abs(y1)) {\n             x0 \u003d x1;\n             x1 \u003d x2;\n             x2 \u003d x0;\n             y0 \u003d y1;\n             y1 \u003d y2;\n             y2 \u003d y0;\n         }\n         if (Math.abs(y1) \u003c\u003d functionValueAccuracy) {\n             setResult(x1, i);\n             return result;\n         }\n         if (Math.abs(oldDelta) \u003c Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy)) {\n             setResult(x1, i);\n             return result;\n         }\n         double delta;\n         if (Math.abs(y1) \u003e Math.abs(y0)) {\n             delta \u003d 0.5 * oldDelta;\n         } else {\n             delta \u003d (x0 - x1) / (1 - y0 / y1);\n             if (delta / oldDelta \u003e 1) {\n                 delta \u003d 0.5 * oldDelta;\n             }\n         }\n         x0 \u003d x1;\n         y0 \u003d y1;\n         x1 \u003d x1 + delta;\n         y1 \u003d f.value(x1);\n         if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n             x2 \u003d x0;\n             y2 \u003d y0;\n         }\n         oldDelta \u003d x2 - x1;\n         i++;\n     }\n-    throw new MathException(\"Maximal iteration number exceeded\");\n+    throw new ConvergenceException(\"Maximal iteration number exceeded\" + i);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[MathException]",
            "newValue": "[ConvergenceException, FunctionEvaluationException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "-Changed UnivariateRealFunction.solve() to throw FunctionEvaluationException.\n-Changed UnivariateRealSolver.solve() to throw more specific exceptions:\n  ConvergenceException if max iterations is exceeded\n  IllegalArgumentException if endpoints do not (appear to) bracket a root\n  FunctionEvaluationException if an error occurs evaluating the function\n-Changed UnivariateRealSolver setters to throw IllegalArgumentException\n instead of MathException when input property values are out of range.\n-Changed AbstractContinuousDistribution.inverseCumulativeProbability to handle\n corner cases where solution equals domain lower or upper bound.\n-Improved javadoc.\n-Improved test coverage.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/math/trunk@141391 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "7/17/04, 2:19 PM",
          "commitName": "6a978ea29f680a87dfc380c760adf2e17b2e7c9c",
          "commitAuthor": "Phil Steitz",
          "commitDateOld": "6/23/04, 9:26 AM",
          "commitNameOld": "7b22aec5529fb3bad1e8098938271398d13c92ba",
          "commitAuthorOld": "Brent Worden",
          "daysBetweenCommits": 24.2,
          "commitsBetweenForRepo": 60,
          "commitsBetweenForFile": 1,
          "actualSource": "public double solve(double min, double max) throws ConvergenceException, FunctionEvaluationException {\n    clearResult();\n    verifyBracketing(min, max, f);\n    double x0 \u003d min;\n    double x1 \u003d max;\n    double y0 \u003d f.value(x0);\n    double y1 \u003d f.value(x1);\n    double x2 \u003d x0;\n    double y2 \u003d y0;\n    double oldDelta \u003d x2 - x1;\n    int i \u003d 0;\n    while (i \u003c maximalIterationCount) {\n        if (Math.abs(y2) \u003c Math.abs(y1)) {\n            x0 \u003d x1;\n            x1 \u003d x2;\n            x2 \u003d x0;\n            y0 \u003d y1;\n            y1 \u003d y2;\n            y2 \u003d y0;\n        }\n        if (Math.abs(y1) \u003c\u003d functionValueAccuracy) {\n            setResult(x1, i);\n            return result;\n        }\n        if (Math.abs(oldDelta) \u003c Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy)) {\n            setResult(x1, i);\n            return result;\n        }\n        double delta;\n        if (Math.abs(y1) \u003e Math.abs(y0)) {\n            delta \u003d 0.5 * oldDelta;\n        } else {\n            delta \u003d (x0 - x1) / (1 - y0 / y1);\n            if (delta / oldDelta \u003e 1) {\n                delta \u003d 0.5 * oldDelta;\n            }\n        }\n        x0 \u003d x1;\n        y0 \u003d y1;\n        x1 \u003d x1 + delta;\n        y1 \u003d f.value(x1);\n        if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n            x2 \u003d x0;\n            y2 \u003d y0;\n        }\n        oldDelta \u003d x2 - x1;\n        i++;\n    }\n    throw new ConvergenceException(\"Maximal iteration number exceeded\" + i);\n}",
          "path": "src/java/org/apache/commons/math/analysis/SecantSolver.java",
          "functionStartLine": 83,
          "functionName": "solve",
          "functionAnnotation": "",
          "functionDoc": "Find a zero in the given interval.\n\n@param min the lower bound for the interval.\n@param max the upper bound for the interval.\n@return the value where the function is zero\n@throws ConvergenceException  if the maximum iteration count is exceeded\n@throws FunctionEvaluationException if an error occurs evaluating the\nfunction\n@throws IllegalArgumentException if min is not less than max or the\nsigns of the values of the function at the endpoints are not opposites\n",
          "diff": "@@ -1,52 +1,50 @@\n-public double solve(double min, double max) throws MathException {\n+public double solve(double min, double max) throws ConvergenceException, FunctionEvaluationException {\n     clearResult();\n+    verifyBracketing(min, max, f);\n     double x0 \u003d min;\n     double x1 \u003d max;\n     double y0 \u003d f.value(x0);\n     double y1 \u003d f.value(x1);\n-    if ((y0 \u003e 0) \u003d\u003d (y1 \u003e 0)) {\n-        throw new MathException(\"Interval doesn\u0027t bracket a zero.\");\n-    }\n     double x2 \u003d x0;\n     double y2 \u003d y0;\n     double oldDelta \u003d x2 - x1;\n     int i \u003d 0;\n     while (i \u003c maximalIterationCount) {\n         if (Math.abs(y2) \u003c Math.abs(y1)) {\n             x0 \u003d x1;\n             x1 \u003d x2;\n             x2 \u003d x0;\n             y0 \u003d y1;\n             y1 \u003d y2;\n             y2 \u003d y0;\n         }\n         if (Math.abs(y1) \u003c\u003d functionValueAccuracy) {\n             setResult(x1, i);\n             return result;\n         }\n         if (Math.abs(oldDelta) \u003c Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy)) {\n             setResult(x1, i);\n             return result;\n         }\n         double delta;\n         if (Math.abs(y1) \u003e Math.abs(y0)) {\n             delta \u003d 0.5 * oldDelta;\n         } else {\n             delta \u003d (x0 - x1) / (1 - y0 / y1);\n             if (delta / oldDelta \u003e 1) {\n                 delta \u003d 0.5 * oldDelta;\n             }\n         }\n         x0 \u003d x1;\n         y0 \u003d y1;\n         x1 \u003d x1 + delta;\n         y1 \u003d f.value(x1);\n         if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n             x2 \u003d x0;\n             y2 \u003d y0;\n         }\n         oldDelta \u003d x2 - x1;\n         i++;\n     }\n-    throw new MathException(\"Maximal iteration number exceeded\");\n+    throw new ConvergenceException(\"Maximal iteration number exceeded\" + i);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "-Changed UnivariateRealFunction.solve() to throw FunctionEvaluationException.\n-Changed UnivariateRealSolver.solve() to throw more specific exceptions:\n  ConvergenceException if max iterations is exceeded\n  IllegalArgumentException if endpoints do not (appear to) bracket a root\n  FunctionEvaluationException if an error occurs evaluating the function\n-Changed UnivariateRealSolver setters to throw IllegalArgumentException\n instead of MathException when input property values are out of range.\n-Changed AbstractContinuousDistribution.inverseCumulativeProbability to handle\n corner cases where solution equals domain lower or upper bound.\n-Improved javadoc.\n-Improved test coverage.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/math/trunk@141391 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "7/17/04, 2:19 PM",
          "commitName": "6a978ea29f680a87dfc380c760adf2e17b2e7c9c",
          "commitAuthor": "Phil Steitz",
          "commitDateOld": "6/23/04, 9:26 AM",
          "commitNameOld": "7b22aec5529fb3bad1e8098938271398d13c92ba",
          "commitAuthorOld": "Brent Worden",
          "daysBetweenCommits": 24.2,
          "commitsBetweenForRepo": 60,
          "commitsBetweenForFile": 1,
          "actualSource": "public double solve(double min, double max) throws ConvergenceException, FunctionEvaluationException {\n    clearResult();\n    verifyBracketing(min, max, f);\n    double x0 \u003d min;\n    double x1 \u003d max;\n    double y0 \u003d f.value(x0);\n    double y1 \u003d f.value(x1);\n    double x2 \u003d x0;\n    double y2 \u003d y0;\n    double oldDelta \u003d x2 - x1;\n    int i \u003d 0;\n    while (i \u003c maximalIterationCount) {\n        if (Math.abs(y2) \u003c Math.abs(y1)) {\n            x0 \u003d x1;\n            x1 \u003d x2;\n            x2 \u003d x0;\n            y0 \u003d y1;\n            y1 \u003d y2;\n            y2 \u003d y0;\n        }\n        if (Math.abs(y1) \u003c\u003d functionValueAccuracy) {\n            setResult(x1, i);\n            return result;\n        }\n        if (Math.abs(oldDelta) \u003c Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy)) {\n            setResult(x1, i);\n            return result;\n        }\n        double delta;\n        if (Math.abs(y1) \u003e Math.abs(y0)) {\n            delta \u003d 0.5 * oldDelta;\n        } else {\n            delta \u003d (x0 - x1) / (1 - y0 / y1);\n            if (delta / oldDelta \u003e 1) {\n                delta \u003d 0.5 * oldDelta;\n            }\n        }\n        x0 \u003d x1;\n        y0 \u003d y1;\n        x1 \u003d x1 + delta;\n        y1 \u003d f.value(x1);\n        if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n            x2 \u003d x0;\n            y2 \u003d y0;\n        }\n        oldDelta \u003d x2 - x1;\n        i++;\n    }\n    throw new ConvergenceException(\"Maximal iteration number exceeded\" + i);\n}",
          "path": "src/java/org/apache/commons/math/analysis/SecantSolver.java",
          "functionStartLine": 83,
          "functionName": "solve",
          "functionAnnotation": "",
          "functionDoc": "Find a zero in the given interval.\n\n@param min the lower bound for the interval.\n@param max the upper bound for the interval.\n@return the value where the function is zero\n@throws ConvergenceException  if the maximum iteration count is exceeded\n@throws FunctionEvaluationException if an error occurs evaluating the\nfunction\n@throws IllegalArgumentException if min is not less than max or the\nsigns of the values of the function at the endpoints are not opposites\n",
          "diff": "@@ -1,52 +1,50 @@\n-public double solve(double min, double max) throws MathException {\n+public double solve(double min, double max) throws ConvergenceException, FunctionEvaluationException {\n     clearResult();\n+    verifyBracketing(min, max, f);\n     double x0 \u003d min;\n     double x1 \u003d max;\n     double y0 \u003d f.value(x0);\n     double y1 \u003d f.value(x1);\n-    if ((y0 \u003e 0) \u003d\u003d (y1 \u003e 0)) {\n-        throw new MathException(\"Interval doesn\u0027t bracket a zero.\");\n-    }\n     double x2 \u003d x0;\n     double y2 \u003d y0;\n     double oldDelta \u003d x2 - x1;\n     int i \u003d 0;\n     while (i \u003c maximalIterationCount) {\n         if (Math.abs(y2) \u003c Math.abs(y1)) {\n             x0 \u003d x1;\n             x1 \u003d x2;\n             x2 \u003d x0;\n             y0 \u003d y1;\n             y1 \u003d y2;\n             y2 \u003d y0;\n         }\n         if (Math.abs(y1) \u003c\u003d functionValueAccuracy) {\n             setResult(x1, i);\n             return result;\n         }\n         if (Math.abs(oldDelta) \u003c Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy)) {\n             setResult(x1, i);\n             return result;\n         }\n         double delta;\n         if (Math.abs(y1) \u003e Math.abs(y0)) {\n             delta \u003d 0.5 * oldDelta;\n         } else {\n             delta \u003d (x0 - x1) / (1 - y0 / y1);\n             if (delta / oldDelta \u003e 1) {\n                 delta \u003d 0.5 * oldDelta;\n             }\n         }\n         x0 \u003d x1;\n         y0 \u003d y1;\n         x1 \u003d x1 + delta;\n         y1 \u003d f.value(x1);\n         if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n             x2 \u003d x0;\n             y2 \u003d y0;\n         }\n         oldDelta \u003d x2 - x1;\n         i++;\n     }\n-    throw new MathException(\"Maximal iteration number exceeded\");\n+    throw new ConvergenceException(\"Maximal iteration number exceeded\" + i);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Find a zero in the given interval.\n\n@param min the lower bound for the interval.\n@param max the upper bound for the interval.\n@return the value where the function is zero\n@throws MathException if the iteration count was exceeded or the\n solver detects convergence problems otherwise.\n",
            "newValue": "Find a zero in the given interval.\n\n@param min the lower bound for the interval.\n@param max the upper bound for the interval.\n@return the value where the function is zero\n@throws ConvergenceException  if the maximum iteration count is exceeded\n@throws FunctionEvaluationException if an error occurs evaluating the\nfunction\n@throws IllegalArgumentException if min is not less than max or the\nsigns of the values of the function at the endpoints are not opposites\n"
          }
        }
      ]
    },
    "5cb403cbbcb292481c680728298cb87c46663914": {
      "type": "Ydocchange",
      "commitMessage": "javadoc.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/math/trunk@141105 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2/22/04, 2:01 PM",
      "commitName": "5cb403cbbcb292481c680728298cb87c46663914",
      "commitAuthor": "Phil Steitz",
      "commitDateOld": "2/17/04, 7:24 PM",
      "commitNameOld": "4dae458d8dd9dd4dfc09302a8d4f6a914420da54",
      "commitAuthorOld": "Phil Steitz",
      "daysBetweenCommits": 4.78,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "public double solve(double min, double max) throws MathException {\n    clearResult();\n    double x0 \u003d min;\n    double x1 \u003d max;\n    double y0 \u003d f.value(x0);\n    double y1 \u003d f.value(x1);\n    if ((y0 \u003e 0) \u003d\u003d (y1 \u003e 0)) {\n        throw new MathException(\"Interval doesn\u0027t bracket a zero.\");\n    }\n    double x2 \u003d x0;\n    double y2 \u003d y0;\n    double oldDelta \u003d x2 - x1;\n    int i \u003d 0;\n    while (i \u003c maximalIterationCount) {\n        if (Math.abs(y2) \u003c Math.abs(y1)) {\n            x0 \u003d x1;\n            x1 \u003d x2;\n            x2 \u003d x0;\n            y0 \u003d y1;\n            y1 \u003d y2;\n            y2 \u003d y0;\n        }\n        if (Math.abs(y1) \u003c\u003d functionValueAccuracy) {\n            setResult(x1, i);\n            return result;\n        }\n        if (Math.abs(oldDelta) \u003c Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy)) {\n            setResult(x1, i);\n            return result;\n        }\n        double delta;\n        if (Math.abs(y1) \u003e Math.abs(y0)) {\n            delta \u003d 0.5 * oldDelta;\n        } else {\n            delta \u003d (x0 - x1) / (1 - y0 / y1);\n            if (delta / oldDelta \u003e 1) {\n                delta \u003d 0.5 * oldDelta;\n            }\n        }\n        x0 \u003d x1;\n        y0 \u003d y1;\n        x1 \u003d x1 + delta;\n        y1 \u003d f.value(x1);\n        if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n            x2 \u003d x0;\n            y2 \u003d y0;\n        }\n        oldDelta \u003d x2 - x1;\n        i++;\n    }\n    throw new MathException(\"Maximal iteration number exceeded\");\n}",
      "path": "src/java/org/apache/commons/math/analysis/SecantSolver.java",
      "functionStartLine": 70,
      "functionName": "solve",
      "functionAnnotation": "",
      "functionDoc": "Find a zero in the given interval.\n\n@param min the lower bound for the interval.\n@param max the upper bound for the interval.\n@return the value where the function is zero\n@throws MathException if the iteration count was exceeded or the\n solver detects convergence problems otherwise.\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "Solve for a zero root in the given interval.\n\n@param min the lower bound for the interval.\n@param max the upper bound for the interval.\n@return the value where the function is zero\n@throws MathException if the iteration count was exceeded or the\n solver detects convergence problems otherwise.\n",
        "newValue": "Find a zero in the given interval.\n\n@param min the lower bound for the interval.\n@param max the upper bound for the interval.\n@return the value where the function is zero\n@throws MathException if the iteration count was exceeded or the\n solver detects convergence problems otherwise.\n"
      }
    },
    "0a904461932f2c0455611e77ec6a8d8aced2980b": {
      "type": "Yintroduced",
      "commitMessage": "Attempting to recover last revision.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/math/trunk@141013 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/14/03, 2:25 PM",
      "commitName": "0a904461932f2c0455611e77ec6a8d8aced2980b",
      "commitAuthor": "Mark R. Diggory",
      "diff": "@@ -0,0 +1,52 @@\n+public double solve(double min, double max) throws MathException {\n+    clearResult();\n+    double x0 \u003d min;\n+    double x1 \u003d max;\n+    double y0 \u003d f.value(x0);\n+    double y1 \u003d f.value(x1);\n+    if ((y0 \u003e 0) \u003d\u003d (y1 \u003e 0)) {\n+        throw new MathException(\"Interval doesn\u0027t bracket a zero.\");\n+    }\n+    double x2 \u003d x0;\n+    double y2 \u003d y0;\n+    double oldDelta \u003d x2 - x1;\n+    int i \u003d 0;\n+    while (i \u003c maximalIterationCount) {\n+        if (Math.abs(y2) \u003c Math.abs(y1)) {\n+            x0 \u003d x1;\n+            x1 \u003d x2;\n+            x2 \u003d x0;\n+            y0 \u003d y1;\n+            y1 \u003d y2;\n+            y2 \u003d y0;\n+        }\n+        if (Math.abs(y1) \u003c\u003d functionValueAccuracy) {\n+            setResult(x1, i);\n+            return result;\n+        }\n+        if (Math.abs(oldDelta) \u003c Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy)) {\n+            setResult(x1, i);\n+            return result;\n+        }\n+        double delta;\n+        if (Math.abs(y1) \u003e Math.abs(y0)) {\n+            delta \u003d 0.5 * oldDelta;\n+        } else {\n+            delta \u003d (x0 - x1) / (1 - y0 / y1);\n+            if (delta / oldDelta \u003e 1) {\n+                delta \u003d 0.5 * oldDelta;\n+            }\n+        }\n+        x0 \u003d x1;\n+        y0 \u003d y1;\n+        x1 \u003d x1 + delta;\n+        y1 \u003d f.value(x1);\n+        if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n+            x2 \u003d x0;\n+            y2 \u003d y0;\n+        }\n+        oldDelta \u003d x2 - x1;\n+        i++;\n+    }\n+    throw new MathException(\"Maximal iteration number exceeded\");\n+}\n\\ No newline at end of file\n",
      "actualSource": "public double solve(double min, double max) throws MathException {\n    clearResult();\n    double x0 \u003d min;\n    double x1 \u003d max;\n    double y0 \u003d f.value(x0);\n    double y1 \u003d f.value(x1);\n    if ((y0 \u003e 0) \u003d\u003d (y1 \u003e 0)) {\n        throw new MathException(\"Interval doesn\u0027t bracket a zero.\");\n    }\n    double x2 \u003d x0;\n    double y2 \u003d y0;\n    double oldDelta \u003d x2 - x1;\n    int i \u003d 0;\n    while (i \u003c maximalIterationCount) {\n        if (Math.abs(y2) \u003c Math.abs(y1)) {\n            x0 \u003d x1;\n            x1 \u003d x2;\n            x2 \u003d x0;\n            y0 \u003d y1;\n            y1 \u003d y2;\n            y2 \u003d y0;\n        }\n        if (Math.abs(y1) \u003c\u003d functionValueAccuracy) {\n            setResult(x1, i);\n            return result;\n        }\n        if (Math.abs(oldDelta) \u003c Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy)) {\n            setResult(x1, i);\n            return result;\n        }\n        double delta;\n        if (Math.abs(y1) \u003e Math.abs(y0)) {\n            delta \u003d 0.5 * oldDelta;\n        } else {\n            delta \u003d (x0 - x1) / (1 - y0 / y1);\n            if (delta / oldDelta \u003e 1) {\n                delta \u003d 0.5 * oldDelta;\n            }\n        }\n        x0 \u003d x1;\n        y0 \u003d y1;\n        x1 \u003d x1 + delta;\n        y1 \u003d f.value(x1);\n        if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n            x2 \u003d x0;\n            y2 \u003d y0;\n        }\n        oldDelta \u003d x2 - x1;\n        i++;\n    }\n    throw new MathException(\"Maximal iteration number exceeded\");\n}",
      "path": "src/java/org/apache/commons/math/analysis/SecantSolver.java",
      "functionStartLine": 100,
      "functionName": "solve",
      "functionAnnotation": "",
      "functionDoc": "Solve for a zero root in the given interval.\n\n@param min the lower bound for the interval.\n@param max the upper bound for the interval.\n@return the value where the function is zero\n@throws MathException if the iteration count was exceeded or the\n solver detects convergence problems otherwise.\n"
    }
  }
}