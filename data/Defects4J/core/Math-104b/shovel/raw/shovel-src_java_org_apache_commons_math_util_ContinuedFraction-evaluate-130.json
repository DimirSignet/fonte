{
  "origin": "codeshovel",
  "repositoryName": "Math-104b",
  "repositoryPath": "/tmp/Math-104b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ContinuedFraction.java",
  "functionName": "evaluate",
  "functionId": "evaluate___x-double__epsilon-double__maxIterations-int",
  "sourceFilePath": "src/java/org/apache/commons/math/util/ContinuedFraction.java",
  "functionAnnotation": "",
  "functionDoc": "\u003cp\u003e\nEvaluates the continued fraction at the value x.\n\u003c/p\u003e\n\n\u003cp\u003e\nThe implementation of this method is based on equations 14-17 of:\n\u003cul\u003e\n\u003cli\u003e\n  Eric W. Weisstein. \"Continued Fraction.\" From MathWorld--A Wolfram Web\n  Resource. \u003ca target\u003d\"_blank\"\n  href\u003d\"http://mathworld.wolfram.com/ContinuedFraction.html\"\u003e\n  http://mathworld.wolfram.com/ContinuedFraction.html\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\nThe recurrence relationship defined in those equations can result in\nvery large intermediate results which can result in numerical overflow.\nAs a means to combat these overflow conditions, the intermediate results\nare scaled whenever they threaten to become numerically unstable.\n\n@param x the evaluation point.\n@param epsilon maximum error allowed.\n@param maxIterations maximum number of convergents\n@return the value of the continued fraction evaluated at x.\n@throws MathException if the algorithm fails to converge.\n",
  "functionStartLine": 130,
  "functionEndLine": 179,
  "numCommitsSeen": 19,
  "timeTaken": 546,
  "changeHistory": [
    "d2d4c5fd63f279be0797468277593ef72506c696",
    "6ef3b2932f4ca9219e41784bb0cd229dcabcdb11",
    "ad6929ea0c89c085422c1e43bb3f763a0e3d25e4",
    "7b22aec5529fb3bad1e8098938271398d13c92ba",
    "0a904461932f2c0455611e77ec6a8d8aced2980b"
  ],
  "changeHistoryShort": {
    "d2d4c5fd63f279be0797468277593ef72506c696": "Ybodychange",
    "6ef3b2932f4ca9219e41784bb0cd229dcabcdb11": "Yformatchange",
    "ad6929ea0c89c085422c1e43bb3f763a0e3d25e4": "Ymultichange(Ybodychange,Ydocchange)",
    "7b22aec5529fb3bad1e8098938271398d13c92ba": "Ydocchange",
    "0a904461932f2c0455611e77ec6a8d8aced2980b": "Yintroduced"
  },
  "changeHistoryDetails": {
    "d2d4c5fd63f279be0797468277593ef72506c696": {
      "type": "Ybodychange",
      "commitMessage": "Added and used a specialized convergence exception for exceeded iteration counts\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/math/trunk@506585 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2/12/07, 11:17 AM",
      "commitName": "d2d4c5fd63f279be0797468277593ef72506c696",
      "commitAuthor": "Luc Maisonobe",
      "commitDateOld": "11/28/06, 11:14 PM",
      "commitNameOld": "05f7f6059bd0cbb69b5dd49c061f1f3520e0ee1e",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 75.5,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "public double evaluate(double x, double epsilon, int maxIterations) throws MathException {\n    double p0 \u003d 1.0;\n    double p1 \u003d getA(0, x);\n    double q0 \u003d 0.0;\n    double q1 \u003d 1.0;\n    double c \u003d p1 / q1;\n    int n \u003d 0;\n    double relativeError \u003d Double.MAX_VALUE;\n    while (n \u003c maxIterations \u0026\u0026 relativeError \u003e epsilon) {\n        ++n;\n        double a \u003d getA(n, x);\n        double b \u003d getB(n, x);\n        double p2 \u003d a * p1 + b * p0;\n        double q2 \u003d a * q1 + b * q0;\n        if (Double.isInfinite(p2) || Double.isInfinite(q2)) {\n            if (a !\u003d 0.0) {\n                p2 \u003d p1 + (b / a * p0);\n                q2 \u003d q1 + (b / a * q0);\n            } else if (b !\u003d 0) {\n                p2 \u003d (a / b * p1) + p0;\n                q2 \u003d (a / b * q1) + q0;\n            } else {\n                throw new ConvergenceException(\"Continued fraction convergents diverged to +/- infinity for value {0}\", new Object[] { new Double(x) });\n            }\n        }\n        double r \u003d p2 / q2;\n        relativeError \u003d Math.abs(r / c - 1.0);\n        c \u003d p2 / q2;\n        p0 \u003d p1;\n        p1 \u003d p2;\n        q0 \u003d q1;\n        q1 \u003d q2;\n    }\n    if (n \u003e\u003d maxIterations) {\n        throw new MaxIterationsExceededException(maxIterations, \"Continued fraction convergents failed to converge for value {0}\", new Object[] { new Double(x) });\n    }\n    return c;\n}",
      "path": "src/java/org/apache/commons/math/util/ContinuedFraction.java",
      "functionStartLine": 130,
      "functionName": "evaluate",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003e\nEvaluates the continued fraction at the value x.\n\u003c/p\u003e\n\n\u003cp\u003e\nThe implementation of this method is based on equations 14-17 of:\n\u003cul\u003e\n\u003cli\u003e\n  Eric W. Weisstein. \"Continued Fraction.\" From MathWorld--A Wolfram Web\n  Resource. \u003ca target\u003d\"_blank\"\n  href\u003d\"http://mathworld.wolfram.com/ContinuedFraction.html\"\u003e\n  http://mathworld.wolfram.com/ContinuedFraction.html\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\nThe recurrence relationship defined in those equations can result in\nvery large intermediate results which can result in numerical overflow.\nAs a means to combat these overflow conditions, the intermediate results\nare scaled whenever they threaten to become numerically unstable.\n\n@param x the evaluation point.\n@param epsilon maximum error allowed.\n@param maxIterations maximum number of convergents\n@return the value of the continued fraction evaluated at x.\n@throws MathException if the algorithm fails to converge.\n",
      "diff": "@@ -1,38 +1,38 @@\n public double evaluate(double x, double epsilon, int maxIterations) throws MathException {\n     double p0 \u003d 1.0;\n     double p1 \u003d getA(0, x);\n     double q0 \u003d 0.0;\n     double q1 \u003d 1.0;\n     double c \u003d p1 / q1;\n     int n \u003d 0;\n     double relativeError \u003d Double.MAX_VALUE;\n     while (n \u003c maxIterations \u0026\u0026 relativeError \u003e epsilon) {\n         ++n;\n         double a \u003d getA(n, x);\n         double b \u003d getB(n, x);\n         double p2 \u003d a * p1 + b * p0;\n         double q2 \u003d a * q1 + b * q0;\n         if (Double.isInfinite(p2) || Double.isInfinite(q2)) {\n             if (a !\u003d 0.0) {\n                 p2 \u003d p1 + (b / a * p0);\n                 q2 \u003d q1 + (b / a * q0);\n             } else if (b !\u003d 0) {\n                 p2 \u003d (a / b * p1) + p0;\n                 q2 \u003d (a / b * q1) + q0;\n             } else {\n-                throw new ConvergenceException(\"Continued fraction convergents diverged to +/- \" + \"infinity.\");\n+                throw new ConvergenceException(\"Continued fraction convergents diverged to +/- infinity for value {0}\", new Object[] { new Double(x) });\n             }\n         }\n         double r \u003d p2 / q2;\n         relativeError \u003d Math.abs(r / c - 1.0);\n         c \u003d p2 / q2;\n         p0 \u003d p1;\n         p1 \u003d p2;\n         q0 \u003d q1;\n         q1 \u003d q2;\n     }\n     if (n \u003e\u003d maxIterations) {\n-        throw new ConvergenceException(\"Continued fraction convergents failed to converge.\");\n+        throw new MaxIterationsExceededException(maxIterations, \"Continued fraction convergents failed to converge for value {0}\", new Object[] { new Double(x) });\n     }\n     return c;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6ef3b2932f4ca9219e41784bb0cd229dcabcdb11": {
      "type": "Yformatchange",
      "commitMessage": "Merged (final) src changes from MATH_1_1 release branch r321516-358399\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/math/trunk@358631 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/22/05, 1:16 PM",
      "commitName": "6ef3b2932f4ca9219e41784bb0cd229dcabcdb11",
      "commitAuthor": "Phil Steitz",
      "commitDateOld": "8/22/05, 7:27 PM",
      "commitNameOld": "ad6929ea0c89c085422c1e43bb3f763a0e3d25e4",
      "commitAuthorOld": "Brent Worden",
      "daysBetweenCommits": 121.78,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "actualSource": "public double evaluate(double x, double epsilon, int maxIterations) throws MathException {\n    double p0 \u003d 1.0;\n    double p1 \u003d getA(0, x);\n    double q0 \u003d 0.0;\n    double q1 \u003d 1.0;\n    double c \u003d p1 / q1;\n    int n \u003d 0;\n    double relativeError \u003d Double.MAX_VALUE;\n    while (n \u003c maxIterations \u0026\u0026 relativeError \u003e epsilon) {\n        ++n;\n        double a \u003d getA(n, x);\n        double b \u003d getB(n, x);\n        double p2 \u003d a * p1 + b * p0;\n        double q2 \u003d a * q1 + b * q0;\n        if (Double.isInfinite(p2) || Double.isInfinite(q2)) {\n            if (a !\u003d 0.0) {\n                p2 \u003d p1 + (b / a * p0);\n                q2 \u003d q1 + (b / a * q0);\n            } else if (b !\u003d 0) {\n                p2 \u003d (a / b * p1) + p0;\n                q2 \u003d (a / b * q1) + q0;\n            } else {\n                throw new ConvergenceException(\"Continued fraction convergents diverged to +/- \" + \"infinity.\");\n            }\n        }\n        double r \u003d p2 / q2;\n        relativeError \u003d Math.abs(r / c - 1.0);\n        c \u003d p2 / q2;\n        p0 \u003d p1;\n        p1 \u003d p2;\n        q0 \u003d q1;\n        q1 \u003d q2;\n    }\n    if (n \u003e\u003d maxIterations) {\n        throw new ConvergenceException(\"Continued fraction convergents failed to converge.\");\n    }\n    return c;\n}",
      "path": "src/java/org/apache/commons/math/util/ContinuedFraction.java",
      "functionStartLine": 128,
      "functionName": "evaluate",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003e\nEvaluates the continued fraction at the value x.\n\u003c/p\u003e\n\n\u003cp\u003e\nThe implementation of this method is based on equations 14-17 of:\n\u003cul\u003e\n\u003cli\u003e\n  Eric W. Weisstein. \"Continued Fraction.\" From MathWorld--A Wolfram Web\n  Resource. \u003ca target\u003d\"_blank\"\n  href\u003d\"http://mathworld.wolfram.com/ContinuedFraction.html\"\u003e\n  http://mathworld.wolfram.com/ContinuedFraction.html\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\nThe recurrence relationship defined in those equations can result in\nvery large intermediate results which can result in numerical overflow.\nAs a means to combat these overflow conditions, the intermediate results\nare scaled whenever they threaten to become numerically unstable.\n\n@param x the evaluation point.\n@param epsilon maximum error allowed.\n@param maxIterations maximum number of convergents\n@return the value of the continued fraction evaluated at x.\n@throws MathException if the algorithm fails to converge.\n",
      "diff": "",
      "extendedDetails": {}
    },
    "ad6929ea0c89c085422c1e43bb3f763a0e3d25e4": {
      "type": "Ymultichange(Ybodychange,Ydocchange)",
      "commitMessage": "Merged changes in MATH_1_1 branch to trunk.  This includes revision 232577 through revision 234481.\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/math/trunk@239294 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "8/22/05, 7:27 PM",
      "commitName": "ad6929ea0c89c085422c1e43bb3f763a0e3d25e4",
      "commitAuthor": "Brent Worden",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "Merged changes in MATH_1_1 branch to trunk.  This includes revision 232577 through revision 234481.\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/math/trunk@239294 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "8/22/05, 7:27 PM",
          "commitName": "ad6929ea0c89c085422c1e43bb3f763a0e3d25e4",
          "commitAuthor": "Brent Worden",
          "commitDateOld": "2/26/05, 5:11 AM",
          "commitNameOld": "65b65f88b74de6b3462b04b2cf2a69f064a77557",
          "commitAuthorOld": "Dirk Verbeeck",
          "daysBetweenCommits": 177.55,
          "commitsBetweenForRepo": 77,
          "commitsBetweenForFile": 1,
          "actualSource": "public double evaluate(double x, double epsilon, int maxIterations) throws MathException {\n    double p0 \u003d 1.0;\n    double p1 \u003d getA(0, x);\n    double q0 \u003d 0.0;\n    double q1 \u003d 1.0;\n    double c \u003d p1 / q1;\n    int n \u003d 0;\n    double relativeError \u003d Double.MAX_VALUE;\n    while (n \u003c maxIterations \u0026\u0026 relativeError \u003e epsilon) {\n        ++n;\n        double a \u003d getA(n, x);\n        double b \u003d getB(n, x);\n        double p2 \u003d a * p1 + b * p0;\n        double q2 \u003d a * q1 + b * q0;\n        if (Double.isInfinite(p2) || Double.isInfinite(q2)) {\n            if (a !\u003d 0.0) {\n                p2 \u003d p1 + (b / a * p0);\n                q2 \u003d q1 + (b / a * q0);\n            } else if (b !\u003d 0) {\n                p2 \u003d (a / b * p1) + p0;\n                q2 \u003d (a / b * q1) + q0;\n            } else {\n                throw new ConvergenceException(\"Continued fraction convergents diverged to +/- \" + \"infinity.\");\n            }\n        }\n        double r \u003d p2 / q2;\n        relativeError \u003d Math.abs(r / c - 1.0);\n        c \u003d p2 / q2;\n        p0 \u003d p1;\n        p1 \u003d p2;\n        q0 \u003d q1;\n        q1 \u003d q2;\n    }\n    if (n \u003e\u003d maxIterations) {\n        throw new ConvergenceException(\"Continued fraction convergents failed to converge.\");\n    }\n    return c;\n}",
          "path": "src/java/org/apache/commons/math/util/ContinuedFraction.java",
          "functionStartLine": 128,
          "functionName": "evaluate",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003e\nEvaluates the continued fraction at the value x.\n\u003c/p\u003e\n\n\u003cp\u003e\nThe implementation of this method is based on equations 14-17 of:\n\u003cul\u003e\n\u003cli\u003e\n  Eric W. Weisstein. \"Continued Fraction.\" From MathWorld--A Wolfram Web\n  Resource. \u003ca target\u003d\"_blank\"\n  href\u003d\"http://mathworld.wolfram.com/ContinuedFraction.html\"\u003e\n  http://mathworld.wolfram.com/ContinuedFraction.html\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\nThe recurrence relationship defined in those equations can result in\nvery large intermediate results which can result in numerical overflow.\nAs a means to combat these overflow conditions, the intermediate results\nare scaled whenever they threaten to become numerically unstable.\n\n@param x the evaluation point.\n@param epsilon maximum error allowed.\n@param maxIterations maximum number of convergents\n@return the value of the continued fraction evaluated at x.\n@throws MathException if the algorithm fails to converge.\n",
          "diff": "@@ -1,10 +1,38 @@\n public double evaluate(double x, double epsilon, int maxIterations) throws MathException {\n-    double[][] f \u003d new double[2][2];\n-    double[][] a \u003d new double[2][2];\n-    double[][] an \u003d new double[2][2];\n-    a[0][0] \u003d getA(0, x);\n-    a[0][1] \u003d 1.0;\n-    a[1][0] \u003d 1.0;\n-    a[1][1] \u003d 0.0;\n-    return evaluate(1, x, a, an, f, epsilon, maxIterations);\n+    double p0 \u003d 1.0;\n+    double p1 \u003d getA(0, x);\n+    double q0 \u003d 0.0;\n+    double q1 \u003d 1.0;\n+    double c \u003d p1 / q1;\n+    int n \u003d 0;\n+    double relativeError \u003d Double.MAX_VALUE;\n+    while (n \u003c maxIterations \u0026\u0026 relativeError \u003e epsilon) {\n+        ++n;\n+        double a \u003d getA(n, x);\n+        double b \u003d getB(n, x);\n+        double p2 \u003d a * p1 + b * p0;\n+        double q2 \u003d a * q1 + b * q0;\n+        if (Double.isInfinite(p2) || Double.isInfinite(q2)) {\n+            if (a !\u003d 0.0) {\n+                p2 \u003d p1 + (b / a * p0);\n+                q2 \u003d q1 + (b / a * q0);\n+            } else if (b !\u003d 0) {\n+                p2 \u003d (a / b * p1) + p0;\n+                q2 \u003d (a / b * q1) + q0;\n+            } else {\n+                throw new ConvergenceException(\"Continued fraction convergents diverged to +/- \" + \"infinity.\");\n+            }\n+        }\n+        double r \u003d p2 / q2;\n+        relativeError \u003d Math.abs(r / c - 1.0);\n+        c \u003d p2 / q2;\n+        p0 \u003d p1;\n+        p1 \u003d p2;\n+        q0 \u003d q1;\n+        q1 \u003d q2;\n+    }\n+    if (n \u003e\u003d maxIterations) {\n+        throw new ConvergenceException(\"Continued fraction convergents failed to converge.\");\n+    }\n+    return c;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Merged changes in MATH_1_1 branch to trunk.  This includes revision 232577 through revision 234481.\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/math/trunk@239294 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "8/22/05, 7:27 PM",
          "commitName": "ad6929ea0c89c085422c1e43bb3f763a0e3d25e4",
          "commitAuthor": "Brent Worden",
          "commitDateOld": "2/26/05, 5:11 AM",
          "commitNameOld": "65b65f88b74de6b3462b04b2cf2a69f064a77557",
          "commitAuthorOld": "Dirk Verbeeck",
          "daysBetweenCommits": 177.55,
          "commitsBetweenForRepo": 77,
          "commitsBetweenForFile": 1,
          "actualSource": "public double evaluate(double x, double epsilon, int maxIterations) throws MathException {\n    double p0 \u003d 1.0;\n    double p1 \u003d getA(0, x);\n    double q0 \u003d 0.0;\n    double q1 \u003d 1.0;\n    double c \u003d p1 / q1;\n    int n \u003d 0;\n    double relativeError \u003d Double.MAX_VALUE;\n    while (n \u003c maxIterations \u0026\u0026 relativeError \u003e epsilon) {\n        ++n;\n        double a \u003d getA(n, x);\n        double b \u003d getB(n, x);\n        double p2 \u003d a * p1 + b * p0;\n        double q2 \u003d a * q1 + b * q0;\n        if (Double.isInfinite(p2) || Double.isInfinite(q2)) {\n            if (a !\u003d 0.0) {\n                p2 \u003d p1 + (b / a * p0);\n                q2 \u003d q1 + (b / a * q0);\n            } else if (b !\u003d 0) {\n                p2 \u003d (a / b * p1) + p0;\n                q2 \u003d (a / b * q1) + q0;\n            } else {\n                throw new ConvergenceException(\"Continued fraction convergents diverged to +/- \" + \"infinity.\");\n            }\n        }\n        double r \u003d p2 / q2;\n        relativeError \u003d Math.abs(r / c - 1.0);\n        c \u003d p2 / q2;\n        p0 \u003d p1;\n        p1 \u003d p2;\n        q0 \u003d q1;\n        q1 \u003d q2;\n    }\n    if (n \u003e\u003d maxIterations) {\n        throw new ConvergenceException(\"Continued fraction convergents failed to converge.\");\n    }\n    return c;\n}",
          "path": "src/java/org/apache/commons/math/util/ContinuedFraction.java",
          "functionStartLine": 128,
          "functionName": "evaluate",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003e\nEvaluates the continued fraction at the value x.\n\u003c/p\u003e\n\n\u003cp\u003e\nThe implementation of this method is based on equations 14-17 of:\n\u003cul\u003e\n\u003cli\u003e\n  Eric W. Weisstein. \"Continued Fraction.\" From MathWorld--A Wolfram Web\n  Resource. \u003ca target\u003d\"_blank\"\n  href\u003d\"http://mathworld.wolfram.com/ContinuedFraction.html\"\u003e\n  http://mathworld.wolfram.com/ContinuedFraction.html\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\nThe recurrence relationship defined in those equations can result in\nvery large intermediate results which can result in numerical overflow.\nAs a means to combat these overflow conditions, the intermediate results\nare scaled whenever they threaten to become numerically unstable.\n\n@param x the evaluation point.\n@param epsilon maximum error allowed.\n@param maxIterations maximum number of convergents\n@return the value of the continued fraction evaluated at x.\n@throws MathException if the algorithm fails to converge.\n",
          "diff": "@@ -1,10 +1,38 @@\n public double evaluate(double x, double epsilon, int maxIterations) throws MathException {\n-    double[][] f \u003d new double[2][2];\n-    double[][] a \u003d new double[2][2];\n-    double[][] an \u003d new double[2][2];\n-    a[0][0] \u003d getA(0, x);\n-    a[0][1] \u003d 1.0;\n-    a[1][0] \u003d 1.0;\n-    a[1][1] \u003d 0.0;\n-    return evaluate(1, x, a, an, f, epsilon, maxIterations);\n+    double p0 \u003d 1.0;\n+    double p1 \u003d getA(0, x);\n+    double q0 \u003d 0.0;\n+    double q1 \u003d 1.0;\n+    double c \u003d p1 / q1;\n+    int n \u003d 0;\n+    double relativeError \u003d Double.MAX_VALUE;\n+    while (n \u003c maxIterations \u0026\u0026 relativeError \u003e epsilon) {\n+        ++n;\n+        double a \u003d getA(n, x);\n+        double b \u003d getB(n, x);\n+        double p2 \u003d a * p1 + b * p0;\n+        double q2 \u003d a * q1 + b * q0;\n+        if (Double.isInfinite(p2) || Double.isInfinite(q2)) {\n+            if (a !\u003d 0.0) {\n+                p2 \u003d p1 + (b / a * p0);\n+                q2 \u003d q1 + (b / a * q0);\n+            } else if (b !\u003d 0) {\n+                p2 \u003d (a / b * p1) + p0;\n+                q2 \u003d (a / b * q1) + q0;\n+            } else {\n+                throw new ConvergenceException(\"Continued fraction convergents diverged to +/- \" + \"infinity.\");\n+            }\n+        }\n+        double r \u003d p2 / q2;\n+        relativeError \u003d Math.abs(r / c - 1.0);\n+        c \u003d p2 / q2;\n+        p0 \u003d p1;\n+        p1 \u003d p2;\n+        q0 \u003d q1;\n+        q1 \u003d q2;\n+    }\n+    if (n \u003e\u003d maxIterations) {\n+        throw new ConvergenceException(\"Continued fraction convergents failed to converge.\");\n+    }\n+    return c;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Evaluates the continued fraction at the value x.\n\nThe implementation of this method is based on:\n\u003cul\u003e\n\u003cli\u003eO. E-gecio-glu, C . K. Koc, J. Rifa i Coma,\n\u003ca href\u003d\"http://citeseer.ist.psu.edu/egecioglu91fast.html\"\u003e\nOn Fast Computation of Continued Fractions\u003c/a\u003e, Computers Math. Applic.,\n21(2--3), 1991, 167--169.\u003c/li\u003e\n\u003c/ul\u003e\n\n@param x the evaluation point.\n@param epsilon maximum error allowed.\n@param maxIterations maximum number of convergents\n@return the value of the continued fraction evaluated at x.\n@throws MathException if the algorithm fails to converge.\n",
            "newValue": "\u003cp\u003e\nEvaluates the continued fraction at the value x.\n\u003c/p\u003e\n\n\u003cp\u003e\nThe implementation of this method is based on equations 14-17 of:\n\u003cul\u003e\n\u003cli\u003e\n  Eric W. Weisstein. \"Continued Fraction.\" From MathWorld--A Wolfram Web\n  Resource. \u003ca target\u003d\"_blank\"\n  href\u003d\"http://mathworld.wolfram.com/ContinuedFraction.html\"\u003e\n  http://mathworld.wolfram.com/ContinuedFraction.html\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\nThe recurrence relationship defined in those equations can result in\nvery large intermediate results which can result in numerical overflow.\nAs a means to combat these overflow conditions, the intermediate results\nare scaled whenever they threaten to become numerically unstable.\n\n@param x the evaluation point.\n@param epsilon maximum error allowed.\n@param maxIterations maximum number of convergents\n@return the value of the continued fraction evaluated at x.\n@throws MathException if the algorithm fails to converge.\n"
          }
        }
      ]
    },
    "7b22aec5529fb3bad1e8098938271398d13c92ba": {
      "type": "Ydocchange",
      "commitMessage": "Fixed javadoc, checkstyle, and link warnings.  Made some corrections and additions to the user guide.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/math/trunk@141331 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "6/23/04, 9:26 AM",
      "commitName": "7b22aec5529fb3bad1e8098938271398d13c92ba",
      "commitAuthor": "Brent Worden",
      "commitDateOld": "6/1/04, 5:15 PM",
      "commitNameOld": "1a46b43aed7d8ee2541e294ed6c11c178de3241e",
      "commitAuthorOld": "Mark R. Diggory",
      "daysBetweenCommits": 21.67,
      "commitsBetweenForRepo": 62,
      "commitsBetweenForFile": 1,
      "actualSource": "public double evaluate(double x, double epsilon, int maxIterations) throws MathException {\n    double[][] f \u003d new double[2][2];\n    double[][] a \u003d new double[2][2];\n    double[][] an \u003d new double[2][2];\n    a[0][0] \u003d getA(0, x);\n    a[0][1] \u003d 1.0;\n    a[1][0] \u003d 1.0;\n    a[1][1] \u003d 0.0;\n    return evaluate(1, x, a, an, f, epsilon, maxIterations);\n}",
      "path": "src/java/org/apache/commons/math/util/ContinuedFraction.java",
      "functionStartLine": 119,
      "functionName": "evaluate",
      "functionAnnotation": "",
      "functionDoc": "Evaluates the continued fraction at the value x.\n\nThe implementation of this method is based on:\n\u003cul\u003e\n\u003cli\u003eO. E-gecio-glu, C . K. Koc, J. Rifa i Coma,\n\u003ca href\u003d\"http://citeseer.ist.psu.edu/egecioglu91fast.html\"\u003e\nOn Fast Computation of Continued Fractions\u003c/a\u003e, Computers Math. Applic.,\n21(2--3), 1991, 167--169.\u003c/li\u003e\n\u003c/ul\u003e\n\n@param x the evaluation point.\n@param epsilon maximum error allowed.\n@param maxIterations maximum number of convergents\n@return the value of the continued fraction evaluated at x.\n@throws MathException if the algorithm fails to converge.\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "Evaluates the continued fraction at the value x.\n\nThe implementation of this method is based on:\n\u003cul\u003e\n\u003cli\u003eO. E-gecio-glu, C . K. Koc, J. Rifa i Coma,\n\u003ca href\u003d\"http://citeseer.nj.nec.com/egecioglu91fast.html\"\u003e\nFast Computation of Continued Fractions\u003c/a\u003e, Computers Math. Applic.,\n21(2--3), 1991, 167--169.\u003c/li\u003e\n\u003c/ul\u003e\n\n@param x the evaluation point.\n@param epsilon maximum error allowed.\n@param maxIterations maximum number of convergents\n@return the value of the continued fraction evaluated at x.\n@throws MathException if the algorithm fails to converge.\n",
        "newValue": "Evaluates the continued fraction at the value x.\n\nThe implementation of this method is based on:\n\u003cul\u003e\n\u003cli\u003eO. E-gecio-glu, C . K. Koc, J. Rifa i Coma,\n\u003ca href\u003d\"http://citeseer.ist.psu.edu/egecioglu91fast.html\"\u003e\nOn Fast Computation of Continued Fractions\u003c/a\u003e, Computers Math. Applic.,\n21(2--3), 1991, 167--169.\u003c/li\u003e\n\u003c/ul\u003e\n\n@param x the evaluation point.\n@param epsilon maximum error allowed.\n@param maxIterations maximum number of convergents\n@return the value of the continued fraction evaluated at x.\n@throws MathException if the algorithm fails to converge.\n"
      }
    },
    "0a904461932f2c0455611e77ec6a8d8aced2980b": {
      "type": "Yintroduced",
      "commitMessage": "Attempting to recover last revision.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/math/trunk@141013 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/14/03, 2:25 PM",
      "commitName": "0a904461932f2c0455611e77ec6a8d8aced2980b",
      "commitAuthor": "Mark R. Diggory",
      "diff": "@@ -0,0 +1,10 @@\n+public double evaluate(double x, double epsilon, int maxIterations) throws MathException {\n+    double[][] f \u003d new double[2][2];\n+    double[][] a \u003d new double[2][2];\n+    double[][] an \u003d new double[2][2];\n+    a[0][0] \u003d getA(0, x);\n+    a[0][1] \u003d 1.0;\n+    a[1][0] \u003d 1.0;\n+    a[1][1] \u003d 0.0;\n+    return evaluate(1, x, a, an, f, epsilon, maxIterations);\n+}\n\\ No newline at end of file\n",
      "actualSource": "public double evaluate(double x, double epsilon, int maxIterations) throws MathException {\n    double[][] f \u003d new double[2][2];\n    double[][] a \u003d new double[2][2];\n    double[][] an \u003d new double[2][2];\n    a[0][0] \u003d getA(0, x);\n    a[0][1] \u003d 1.0;\n    a[1][0] \u003d 1.0;\n    a[1][1] \u003d 0.0;\n    return evaluate(1, x, a, an, f, epsilon, maxIterations);\n}",
      "path": "src/java/org/apache/commons/math/util/ContinuedFraction.java",
      "functionStartLine": 148,
      "functionName": "evaluate",
      "functionAnnotation": "",
      "functionDoc": "Evaluates the continued fraction at the value x.\n\nThe implementation of this method is based on:\n\u003cul\u003e\n\u003cli\u003eO. E-gecio-glu, C . K. Koc, J. Rifa i Coma,\n\u003ca href\u003d\"http://citeseer.nj.nec.com/egecioglu91fast.html\"\u003e\nFast Computation of Continued Fractions\u003c/a\u003e, Computers Math. Applic.,\n21(2--3), 1991, 167--169.\u003c/li\u003e\n\u003c/ul\u003e\n\n@param x the evaluation point.\n@param epsilon maximum error allowed.\n@param maxIterations maximum number of convergents\n@return the value of the continued fraction evaluated at x.\n@throws MathException if the algorithm fails to converge.\n"
    }
  }
}