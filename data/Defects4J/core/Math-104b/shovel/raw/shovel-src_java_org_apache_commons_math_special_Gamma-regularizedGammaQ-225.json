{
  "origin": "codeshovel",
  "repositoryName": "Math-104b",
  "repositoryPath": "/tmp/Math-104b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "Gamma.java",
  "functionName": "regularizedGammaQ",
  "functionId": "regularizedGammaQ___a-double(modifiers-final)__x-double__epsilon-double__maxIterations-int",
  "sourceFilePath": "src/java/org/apache/commons/math/special/Gamma.java",
  "functionAnnotation": "",
  "functionDoc": "Returns the regularized gamma function Q(a, x) \u003d 1 - P(a, x).\n\nThe implementation of this method is based on:\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href\u003d\"http://mathworld.wolfram.com/RegularizedGammaFunction.html\"\u003e\nRegularized Gamma Function\u003c/a\u003e, equation (1).\u003c/li\u003e\n\u003cli\u003e\n\u003ca href\u003d\"    http://functions.wolfram.com/GammaBetaErf/GammaRegularized/10/0003/\"\u003e\nRegularized incomplete gamma function: Continued fraction representations  (formula 06.08.10.0003)\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n@param a the a parameter.\n@param x the value.\n@param epsilon When the absolute value of the nth item in the\n               series is less than epsilon the approximation ceases\n               to calculate further elements in the series.\n@param maxIterations Maximum number of \"iterations\" to complete.\n@return the regularized gamma function P(a, x)\n@throws MathException if the algorithm fails to converge.\n",
  "functionStartLine": 225,
  "functionEndLine": 261,
  "numCommitsSeen": 26,
  "timeTaken": 536,
  "changeHistory": [
    "d2d4c5fd63f279be0797468277593ef72506c696",
    "ad6929ea0c89c085422c1e43bb3f763a0e3d25e4",
    "5e15690d8e079588b3e4beedadbba6417b28d33a",
    "a25f1e4515b215f4510088cd1787725479390b14"
  ],
  "changeHistoryShort": {
    "d2d4c5fd63f279be0797468277593ef72506c696": "Ybodychange",
    "ad6929ea0c89c085422c1e43bb3f763a0e3d25e4": "Ybodychange",
    "5e15690d8e079588b3e4beedadbba6417b28d33a": "Ybodychange",
    "a25f1e4515b215f4510088cd1787725479390b14": "Yintroduced"
  },
  "changeHistoryDetails": {
    "d2d4c5fd63f279be0797468277593ef72506c696": {
      "type": "Ybodychange",
      "commitMessage": "Added and used a specialized convergence exception for exceeded iteration counts\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/math/trunk@506585 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2/12/07, 11:17 AM",
      "commitName": "d2d4c5fd63f279be0797468277593ef72506c696",
      "commitAuthor": "Luc Maisonobe",
      "commitDateOld": "11/28/06, 11:14 PM",
      "commitNameOld": "05f7f6059bd0cbb69b5dd49c061f1f3520e0ee1e",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 75.5,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "public static double regularizedGammaQ(final double a, double x, double epsilon, int maxIterations) throws MathException {\n    double ret;\n    if (Double.isNaN(a) || Double.isNaN(x) || (a \u003c\u003d 0.0) || (x \u003c 0.0)) {\n        ret \u003d Double.NaN;\n    } else if (x \u003d\u003d 0.0) {\n        ret \u003d 1.0;\n    } else if (x \u003c a || a \u003c 1.0) {\n        ret \u003d 1.0 - regularizedGammaP(a, x, epsilon, maxIterations);\n    } else {\n        ContinuedFraction cf \u003d new ContinuedFraction() {\n\n            private static final long serialVersionUID \u003d 5378525034886164398L;\n\n            protected double getA(int n, double x) {\n                return ((2.0 * n) + 1.0) - a + x;\n            }\n\n            protected double getB(int n, double x) {\n                return n * (a - n);\n            }\n        };\n        ret \u003d 1.0 / cf.evaluate(x, epsilon, maxIterations);\n        ret \u003d Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * ret;\n    }\n    return ret;\n}",
      "path": "src/java/org/apache/commons/math/special/Gamma.java",
      "functionStartLine": 225,
      "functionName": "regularizedGammaQ",
      "functionAnnotation": "",
      "functionDoc": "Returns the regularized gamma function Q(a, x) \u003d 1 - P(a, x).\n\nThe implementation of this method is based on:\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href\u003d\"http://mathworld.wolfram.com/RegularizedGammaFunction.html\"\u003e\nRegularized Gamma Function\u003c/a\u003e, equation (1).\u003c/li\u003e\n\u003cli\u003e\n\u003ca href\u003d\"    http://functions.wolfram.com/GammaBetaErf/GammaRegularized/10/0003/\"\u003e\nRegularized incomplete gamma function: Continued fraction representations  (formula 06.08.10.0003)\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n@param a the a parameter.\n@param x the value.\n@param epsilon When the absolute value of the nth item in the\n               series is less than epsilon the approximation ceases\n               to calculate further elements in the series.\n@param maxIterations Maximum number of \"iterations\" to complete.\n@return the regularized gamma function P(a, x)\n@throws MathException if the algorithm fails to converge.\n",
      "diff": "@@ -1,24 +1,26 @@\n public static double regularizedGammaQ(final double a, double x, double epsilon, int maxIterations) throws MathException {\n     double ret;\n     if (Double.isNaN(a) || Double.isNaN(x) || (a \u003c\u003d 0.0) || (x \u003c 0.0)) {\n         ret \u003d Double.NaN;\n     } else if (x \u003d\u003d 0.0) {\n         ret \u003d 1.0;\n     } else if (x \u003c a || a \u003c 1.0) {\n         ret \u003d 1.0 - regularizedGammaP(a, x, epsilon, maxIterations);\n     } else {\n         ContinuedFraction cf \u003d new ContinuedFraction() {\n \n+            private static final long serialVersionUID \u003d 5378525034886164398L;\n+\n             protected double getA(int n, double x) {\n                 return ((2.0 * n) + 1.0) - a + x;\n             }\n \n             protected double getB(int n, double x) {\n                 return n * (a - n);\n             }\n         };\n         ret \u003d 1.0 / cf.evaluate(x, epsilon, maxIterations);\n         ret \u003d Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * ret;\n     }\n     return ret;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ad6929ea0c89c085422c1e43bb3f763a0e3d25e4": {
      "type": "Ybodychange",
      "commitMessage": "Merged changes in MATH_1_1 branch to trunk.  This includes revision 232577 through revision 234481.\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/math/trunk@239294 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "8/22/05, 7:27 PM",
      "commitName": "ad6929ea0c89c085422c1e43bb3f763a0e3d25e4",
      "commitAuthor": "Brent Worden",
      "commitDateOld": "2/26/05, 5:11 AM",
      "commitNameOld": "65b65f88b74de6b3462b04b2cf2a69f064a77557",
      "commitAuthorOld": "Dirk Verbeeck",
      "daysBetweenCommits": 177.55,
      "commitsBetweenForRepo": 77,
      "commitsBetweenForFile": 1,
      "actualSource": "public static double regularizedGammaQ(final double a, double x, double epsilon, int maxIterations) throws MathException {\n    double ret;\n    if (Double.isNaN(a) || Double.isNaN(x) || (a \u003c\u003d 0.0) || (x \u003c 0.0)) {\n        ret \u003d Double.NaN;\n    } else if (x \u003d\u003d 0.0) {\n        ret \u003d 1.0;\n    } else if (x \u003c a || a \u003c 1.0) {\n        ret \u003d 1.0 - regularizedGammaP(a, x, epsilon, maxIterations);\n    } else {\n        ContinuedFraction cf \u003d new ContinuedFraction() {\n\n            protected double getA(int n, double x) {\n                return ((2.0 * n) + 1.0) - a + x;\n            }\n\n            protected double getB(int n, double x) {\n                return n * (a - n);\n            }\n        };\n        ret \u003d 1.0 / cf.evaluate(x, epsilon, maxIterations);\n        ret \u003d Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * ret;\n    }\n    return ret;\n}",
      "path": "src/java/org/apache/commons/math/special/Gamma.java",
      "functionStartLine": 222,
      "functionName": "regularizedGammaQ",
      "functionAnnotation": "",
      "functionDoc": "Returns the regularized gamma function Q(a, x) \u003d 1 - P(a, x).\n\nThe implementation of this method is based on:\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href\u003d\"http://mathworld.wolfram.com/RegularizedGammaFunction.html\"\u003e\nRegularized Gamma Function\u003c/a\u003e, equation (1).\u003c/li\u003e\n\u003cli\u003e\n\u003ca href\u003d\"    http://functions.wolfram.com/GammaBetaErf/GammaRegularized/10/0003/\"\u003e\nRegularized incomplete gamma function: Continued fraction representations  (formula 06.08.10.0003)\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n@param a the a parameter.\n@param x the value.\n@param epsilon When the absolute value of the nth item in the\n               series is less than epsilon the approximation ceases\n               to calculate further elements in the series.\n@param maxIterations Maximum number of \"iterations\" to complete.\n@return the regularized gamma function P(a, x)\n@throws MathException if the algorithm fails to converge.\n",
      "diff": "@@ -1,24 +1,24 @@\n public static double regularizedGammaQ(final double a, double x, double epsilon, int maxIterations) throws MathException {\n     double ret;\n     if (Double.isNaN(a) || Double.isNaN(x) || (a \u003c\u003d 0.0) || (x \u003c 0.0)) {\n         ret \u003d Double.NaN;\n     } else if (x \u003d\u003d 0.0) {\n         ret \u003d 1.0;\n-    } else if (x \u003c a || a \u003c\u003d 1.0) {\n+    } else if (x \u003c a || a \u003c 1.0) {\n         ret \u003d 1.0 - regularizedGammaP(a, x, epsilon, maxIterations);\n     } else {\n         ContinuedFraction cf \u003d new ContinuedFraction() {\n \n             protected double getA(int n, double x) {\n                 return ((2.0 * n) + 1.0) - a + x;\n             }\n \n             protected double getB(int n, double x) {\n                 return n * (a - n);\n             }\n         };\n         ret \u003d 1.0 / cf.evaluate(x, epsilon, maxIterations);\n         ret \u003d Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * ret;\n     }\n     return ret;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5e15690d8e079588b3e4beedadbba6417b28d33a": {
      "type": "Ybodychange",
      "commitMessage": "removed some condition logic by changing the continued fraction representation.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/math/trunk@141290 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "6/10/04, 11:34 AM",
      "commitName": "5e15690d8e079588b3e4beedadbba6417b28d33a",
      "commitAuthor": "Brent Worden",
      "commitDateOld": "6/7/04, 1:30 PM",
      "commitNameOld": "a25f1e4515b215f4510088cd1787725479390b14",
      "commitAuthorOld": "Brent Worden",
      "daysBetweenCommits": 2.92,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "public static double regularizedGammaQ(final double a, double x, double epsilon, int maxIterations) throws MathException {\n    double ret;\n    if (Double.isNaN(a) || Double.isNaN(x) || (a \u003c\u003d 0.0) || (x \u003c 0.0)) {\n        ret \u003d Double.NaN;\n    } else if (x \u003d\u003d 0.0) {\n        ret \u003d 1.0;\n    } else if (x \u003c a || a \u003c\u003d 1.0) {\n        ret \u003d 1.0 - regularizedGammaP(a, x, epsilon, maxIterations);\n    } else {\n        ContinuedFraction cf \u003d new ContinuedFraction() {\n\n            protected double getA(int n, double x) {\n                return ((2.0 * n) + 1.0) - a + x;\n            }\n\n            protected double getB(int n, double x) {\n                return n * (a - n);\n            }\n        };\n        ret \u003d 1.0 / cf.evaluate(x, epsilon, maxIterations);\n        ret \u003d Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * ret;\n    }\n    return ret;\n}",
      "path": "src/java/org/apache/commons/math/special/Gamma.java",
      "functionStartLine": 219,
      "functionName": "regularizedGammaQ",
      "functionAnnotation": "",
      "functionDoc": "Returns the regularized gamma function Q(a, x) \u003d 1 - P(a, x).\n\nThe implementation of this method is based on:\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href\u003d\"http://mathworld.wolfram.com/RegularizedGammaFunction.html\"\u003e\nRegularized Gamma Function\u003c/a\u003e, equation (1).\u003c/li\u003e\n\u003cli\u003e\n\u003ca href\u003d\"    http://functions.wolfram.com/GammaBetaErf/GammaRegularized/10/0003/\"\u003e\nRegularized incomplete gamma function: Continued fraction representations  (formula 06.08.10.0003)\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n@param a the a parameter.\n@param x the value.\n@param epsilon When the absolute value of the nth item in the\n               series is less than epsilon the approximation ceases\n               to calculate further elements in the series.\n@param maxIterations Maximum number of \"iterations\" to complete.\n@return the regularized gamma function P(a, x)\n@throws MathException if the algorithm fails to converge.\n",
      "diff": "@@ -1,44 +1,24 @@\n public static double regularizedGammaQ(final double a, double x, double epsilon, int maxIterations) throws MathException {\n     double ret;\n     if (Double.isNaN(a) || Double.isNaN(x) || (a \u003c\u003d 0.0) || (x \u003c 0.0)) {\n         ret \u003d Double.NaN;\n     } else if (x \u003d\u003d 0.0) {\n         ret \u003d 1.0;\n     } else if (x \u003c a || a \u003c\u003d 1.0) {\n         ret \u003d 1.0 - regularizedGammaP(a, x, epsilon, maxIterations);\n     } else {\n         ContinuedFraction cf \u003d new ContinuedFraction() {\n \n             protected double getA(int n, double x) {\n-                double ret;\n-                switch(n) {\n-                    case 0:\n-                        ret \u003d 0.0;\n-                        break;\n-                    default:\n-                        ret \u003d ((2.0 * n) - 1.0) - a + x;\n-                        break;\n-                }\n-                return ret;\n+                return ((2.0 * n) + 1.0) - a + x;\n             }\n \n             protected double getB(int n, double x) {\n-                double ret;\n-                double t;\n-                switch(n) {\n-                    case 1:\n-                        ret \u003d 1.0;\n-                        break;\n-                    default:\n-                        t \u003d n - 1.0;\n-                        ret \u003d t * (a - t);\n-                        break;\n-                }\n-                return ret;\n+                return n * (a - n);\n             }\n         };\n-        ret \u003d cf.evaluate(x, epsilon, maxIterations);\n+        ret \u003d 1.0 / cf.evaluate(x, epsilon, maxIterations);\n         ret \u003d Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * ret;\n     }\n     return ret;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a25f1e4515b215f4510088cd1787725479390b14": {
      "type": "Yintroduced",
      "commitMessage": "PR: 29419\nAdded an implementation of regularized gamma function, Q(a, x) \u003d 1 - P(a,x), based on a continued fraction.  This converges much faster for the large x case.  I added the example submitted by Scott as a test case and ran all the test cases with everything passing.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/math/trunk@141286 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "6/7/04, 1:30 PM",
      "commitName": "a25f1e4515b215f4510088cd1787725479390b14",
      "commitAuthor": "Brent Worden",
      "diff": "@@ -0,0 +1,44 @@\n+public static double regularizedGammaQ(final double a, double x, double epsilon, int maxIterations) throws MathException {\n+    double ret;\n+    if (Double.isNaN(a) || Double.isNaN(x) || (a \u003c\u003d 0.0) || (x \u003c 0.0)) {\n+        ret \u003d Double.NaN;\n+    } else if (x \u003d\u003d 0.0) {\n+        ret \u003d 1.0;\n+    } else if (x \u003c a || a \u003c\u003d 1.0) {\n+        ret \u003d 1.0 - regularizedGammaP(a, x, epsilon, maxIterations);\n+    } else {\n+        ContinuedFraction cf \u003d new ContinuedFraction() {\n+\n+            protected double getA(int n, double x) {\n+                double ret;\n+                switch(n) {\n+                    case 0:\n+                        ret \u003d 0.0;\n+                        break;\n+                    default:\n+                        ret \u003d ((2.0 * n) - 1.0) - a + x;\n+                        break;\n+                }\n+                return ret;\n+            }\n+\n+            protected double getB(int n, double x) {\n+                double ret;\n+                double t;\n+                switch(n) {\n+                    case 1:\n+                        ret \u003d 1.0;\n+                        break;\n+                    default:\n+                        t \u003d n - 1.0;\n+                        ret \u003d t * (a - t);\n+                        break;\n+                }\n+                return ret;\n+            }\n+        };\n+        ret \u003d cf.evaluate(x, epsilon, maxIterations);\n+        ret \u003d Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * ret;\n+    }\n+    return ret;\n+}\n\\ No newline at end of file\n",
      "actualSource": "public static double regularizedGammaQ(final double a, double x, double epsilon, int maxIterations) throws MathException {\n    double ret;\n    if (Double.isNaN(a) || Double.isNaN(x) || (a \u003c\u003d 0.0) || (x \u003c 0.0)) {\n        ret \u003d Double.NaN;\n    } else if (x \u003d\u003d 0.0) {\n        ret \u003d 1.0;\n    } else if (x \u003c a || a \u003c\u003d 1.0) {\n        ret \u003d 1.0 - regularizedGammaP(a, x, epsilon, maxIterations);\n    } else {\n        ContinuedFraction cf \u003d new ContinuedFraction() {\n\n            protected double getA(int n, double x) {\n                double ret;\n                switch(n) {\n                    case 0:\n                        ret \u003d 0.0;\n                        break;\n                    default:\n                        ret \u003d ((2.0 * n) - 1.0) - a + x;\n                        break;\n                }\n                return ret;\n            }\n\n            protected double getB(int n, double x) {\n                double ret;\n                double t;\n                switch(n) {\n                    case 1:\n                        ret \u003d 1.0;\n                        break;\n                    default:\n                        t \u003d n - 1.0;\n                        ret \u003d t * (a - t);\n                        break;\n                }\n                return ret;\n            }\n        };\n        ret \u003d cf.evaluate(x, epsilon, maxIterations);\n        ret \u003d Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * ret;\n    }\n    return ret;\n}",
      "path": "src/java/org/apache/commons/math/special/Gamma.java",
      "functionStartLine": 219,
      "functionName": "regularizedGammaQ",
      "functionAnnotation": "",
      "functionDoc": "Returns the regularized gamma function Q(a, x) \u003d 1 - P(a, x).\n\nThe implementation of this method is based on:\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href\u003d\"http://mathworld.wolfram.com/RegularizedGammaFunction.html\"\u003e\nRegularized Gamma Function\u003c/a\u003e, equation (1).\u003c/li\u003e\n\u003cli\u003e\n\u003ca href\u003d\"    http://functions.wolfram.com/GammaBetaErf/GammaRegularized/10/0003/\"\u003e\nRegularized incomplete gamma function: Continued fraction representations  (formula 06.08.10.0003)\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n@param a the a parameter.\n@param x the value.\n@param epsilon When the absolute value of the nth item in the\n               series is less than epsilon the approximation ceases\n               to calculate further elements in the series.\n@param maxIterations Maximum number of \"iterations\" to complete.\n@return the regularized gamma function P(a, x)\n@throws MathException if the algorithm fails to converge.\n"
    }
  }
}