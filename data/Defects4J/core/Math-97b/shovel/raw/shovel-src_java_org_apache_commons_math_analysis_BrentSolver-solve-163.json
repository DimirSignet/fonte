{
  "origin": "codeshovel",
  "repositoryName": "Math-97b",
  "repositoryPath": "/tmp/Math-97b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "BrentSolver.java",
  "functionName": "solve",
  "functionId": "solve___x0-double__y0-double__x1-double__y1-double__x2-double__y2-double",
  "sourceFilePath": "src/java/org/apache/commons/math/analysis/BrentSolver.java",
  "functionAnnotation": "",
  "functionDoc": "Find a zero starting search according to the three provided points.\n\n@param x0 old approximation for the root\n@param y0 function value at the approximation for the root\n@param x1 last calculated approximation for the root\n@param y1 function value at the last calculated approximation\nfor the root\n@param x2 bracket point (must be set to x0 if no bracket point is\nknown, this will force starting with linear interpolation)\n@param y2 function value at the bracket point.\n@return the value where the function is zero\n@throws MaxIterationsExceededException if the maximum iteration count\nis exceeded\n@throws FunctionEvaluationException if an error occurs evaluating\nthe function\n",
  "functionStartLine": 163,
  "functionEndLine": 257,
  "numCommitsSeen": 29,
  "timeTaken": 582,
  "changeHistory": [
    "96ef54d716955b6e8f8e232813a0470d982ad1af",
    "fd77bfbe13369c830259d6a5cf8b75f6cdf65321",
    "ff69ef1cc25034ce8fd11838ab4478a7a0b048f1"
  ],
  "changeHistoryShort": {
    "96ef54d716955b6e8f8e232813a0470d982ad1af": "Ybodychange",
    "fd77bfbe13369c830259d6a5cf8b75f6cdf65321": "Ydocchange",
    "ff69ef1cc25034ce8fd11838ab4478a7a0b048f1": "Yintroduced"
  },
  "changeHistoryDetails": {
    "96ef54d716955b6e8f8e232813a0470d982ad1af": {
      "type": "Ybodychange",
      "commitMessage": "added comments in the code to explain use of real number equality tests\nJIRA: MATH-183\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@617826 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2/2/08, 8:39 AM",
      "commitName": "96ef54d716955b6e8f8e232813a0470d982ad1af",
      "commitAuthor": "Luc Maisonobe",
      "commitDateOld": "1/27/08, 10:10 PM",
      "commitNameOld": "932ebf87acd81162cc7b1751c18b0e0ca760c8bf",
      "commitAuthorOld": "Phil Steitz",
      "daysBetweenCommits": 5.44,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "actualSource": "private double solve(double x0, double y0, double x1, double y1, double x2, double y2) throws MaxIterationsExceededException, FunctionEvaluationException {\n    double delta \u003d x1 - x0;\n    double oldDelta \u003d delta;\n    int i \u003d 0;\n    while (i \u003c maximalIterationCount) {\n        if (Math.abs(y2) \u003c Math.abs(y1)) {\n            x0 \u003d x1;\n            x1 \u003d x2;\n            x2 \u003d x0;\n            y0 \u003d y1;\n            y1 \u003d y2;\n            y2 \u003d y0;\n        }\n        if (Math.abs(y1) \u003c\u003d functionValueAccuracy) {\n            setResult(x1, i);\n            return result;\n        }\n        double dx \u003d (x2 - x1);\n        double tolerance \u003d Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy);\n        if (Math.abs(dx) \u003c\u003d tolerance) {\n            setResult(x1, i);\n            return result;\n        }\n        if ((Math.abs(oldDelta) \u003c tolerance) || (Math.abs(y0) \u003c\u003d Math.abs(y1))) {\n            delta \u003d 0.5 * dx;\n            oldDelta \u003d delta;\n        } else {\n            double r3 \u003d y1 / y0;\n            double p;\n            double p1;\n            if (x0 \u003d\u003d x2) {\n                p \u003d dx * r3;\n                p1 \u003d 1.0 - r3;\n            } else {\n                double r1 \u003d y0 / y2;\n                double r2 \u003d y1 / y2;\n                p \u003d r3 * (dx * r1 * (r1 - r2) - (x1 - x0) * (r2 - 1.0));\n                p1 \u003d (r1 - 1.0) * (r2 - 1.0) * (r3 - 1.0);\n            }\n            if (p \u003e 0.0) {\n                p1 \u003d -p1;\n            } else {\n                p \u003d -p;\n            }\n            if (2.0 * p \u003e\u003d 1.5 * dx * p1 - Math.abs(tolerance * p1) || p \u003e\u003d Math.abs(0.5 * oldDelta * p1)) {\n                delta \u003d 0.5 * dx;\n                oldDelta \u003d delta;\n            } else {\n                oldDelta \u003d delta;\n                delta \u003d p / p1;\n            }\n        }\n        x0 \u003d x1;\n        y0 \u003d y1;\n        if (Math.abs(delta) \u003e tolerance) {\n            x1 \u003d x1 + delta;\n        } else if (dx \u003e 0.0) {\n            x1 \u003d x1 + 0.5 * tolerance;\n        } else if (dx \u003c\u003d 0.0) {\n            x1 \u003d x1 - 0.5 * tolerance;\n        }\n        y1 \u003d f.value(x1);\n        if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n            x2 \u003d x0;\n            y2 \u003d y0;\n            delta \u003d x1 - x0;\n            oldDelta \u003d delta;\n        }\n        i++;\n    }\n    throw new MaxIterationsExceededException(maximalIterationCount);\n}",
      "path": "src/java/org/apache/commons/math/analysis/BrentSolver.java",
      "functionStartLine": 163,
      "functionName": "solve",
      "functionAnnotation": "",
      "functionDoc": "Find a zero starting search according to the three provided points.\n\n@param x0 old approximation for the root\n@param y0 function value at the approximation for the root\n@param x1 last calculated approximation for the root\n@param y1 function value at the last calculated approximation\nfor the root\n@param x2 bracket point (must be set to x0 if no bracket point is\nknown, this will force starting with linear interpolation)\n@param y2 function value at the bracket point.\n@return the value where the function is zero\n@throws MaxIterationsExceededException if the maximum iteration count\nis exceeded\n@throws FunctionEvaluationException if an error occurs evaluating\nthe function\n",
      "diff": "",
      "extendedDetails": {}
    },
    "fd77bfbe13369c830259d6a5cf8b75f6cdf65321": {
      "type": "Ydocchange",
      "commitMessage": "fixed a parameter name\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@613605 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "1/20/08, 8:49 AM",
      "commitName": "fd77bfbe13369c830259d6a5cf8b75f6cdf65321",
      "commitAuthor": "Luc Maisonobe",
      "commitDateOld": "1/20/08, 8:35 AM",
      "commitNameOld": "1f89e226f2b7dc9b3b498d63c5a5bd5bc23a46b6",
      "commitAuthorOld": "Luc Maisonobe",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "private double solve(double x0, double y0, double x1, double y1, double x2, double y2) throws MaxIterationsExceededException, FunctionEvaluationException {\n    double delta \u003d x1 - x0;\n    double oldDelta \u003d delta;\n    int i \u003d 0;\n    while (i \u003c maximalIterationCount) {\n        if (Math.abs(y2) \u003c Math.abs(y1)) {\n            x0 \u003d x1;\n            x1 \u003d x2;\n            x2 \u003d x0;\n            y0 \u003d y1;\n            y1 \u003d y2;\n            y2 \u003d y0;\n        }\n        if (Math.abs(y1) \u003c\u003d functionValueAccuracy) {\n            setResult(x1, i);\n            return result;\n        }\n        double dx \u003d (x2 - x1);\n        double tolerance \u003d Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy);\n        if (Math.abs(dx) \u003c\u003d tolerance) {\n            setResult(x1, i);\n            return result;\n        }\n        if ((Math.abs(oldDelta) \u003c tolerance) || (Math.abs(y0) \u003c\u003d Math.abs(y1))) {\n            delta \u003d 0.5 * dx;\n            oldDelta \u003d delta;\n        } else {\n            double r3 \u003d y1 / y0;\n            double p;\n            double p1;\n            if (x0 \u003d\u003d x2) {\n                p \u003d dx * r3;\n                p1 \u003d 1.0 - r3;\n            } else {\n                double r1 \u003d y0 / y2;\n                double r2 \u003d y1 / y2;\n                p \u003d r3 * (dx * r1 * (r1 - r2) - (x1 - x0) * (r2 - 1.0));\n                p1 \u003d (r1 - 1.0) * (r2 - 1.0) * (r3 - 1.0);\n            }\n            if (p \u003e 0.0) {\n                p1 \u003d -p1;\n            } else {\n                p \u003d -p;\n            }\n            if (2.0 * p \u003e\u003d 1.5 * dx * p1 - Math.abs(tolerance * p1) || p \u003e\u003d Math.abs(0.5 * oldDelta * p1)) {\n                delta \u003d 0.5 * dx;\n                oldDelta \u003d delta;\n            } else {\n                oldDelta \u003d delta;\n                delta \u003d p / p1;\n            }\n        }\n        x0 \u003d x1;\n        y0 \u003d y1;\n        if (Math.abs(delta) \u003e tolerance) {\n            x1 \u003d x1 + delta;\n        } else if (dx \u003e 0.0) {\n            x1 \u003d x1 + 0.5 * tolerance;\n        } else if (dx \u003c\u003d 0.0) {\n            x1 \u003d x1 - 0.5 * tolerance;\n        }\n        y1 \u003d f.value(x1);\n        if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n            x2 \u003d x0;\n            y2 \u003d y0;\n            delta \u003d x1 - x0;\n            oldDelta \u003d delta;\n        }\n        i++;\n    }\n    throw new MaxIterationsExceededException(maximalIterationCount);\n}",
      "path": "src/java/org/apache/commons/math/analysis/BrentSolver.java",
      "functionStartLine": 163,
      "functionName": "solve",
      "functionAnnotation": "",
      "functionDoc": "Find a zero starting search according to the three provided points.\n\n@param x0 old approximation for the root\n@param y0 function value at the approximation for the root\n@param x1 last calculated approximation for the root\n@param y1 function value at the last calculated approximation\nfor the root\n@param x2 bracket point (must be set to x0 if no bracket point is\nknown, this will force starting with linear interpolation)\n@param y2 function value at the bracket point.\n@return the value where the function is zero\n@throws MaxIterationsExceededException if the maximum iteration count\nis exceeded\n@throws FunctionEvaluationException if an error occurs evaluating\nthe function\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "Find a zero starting search according to the three provided points.\n\n@param x0 old approximation for the root\n@param y0 function value at the approximation for the root\n@param x1 last calculated approximation for the root\n@param y1 function value at the last calculated approximation\nfor the root\n@param x2 bracket point (must be set to x0 if no bracket point is\nknown, this will force starting with linear interpolation)\n@param y3 function value at the bracket point.\n@return the value where the function is zero\n@throws MaxIterationsExceededException if the maximum iteration count\nis exceeded\n@throws FunctionEvaluationException if an error occurs evaluating\nthe function\n",
        "newValue": "Find a zero starting search according to the three provided points.\n\n@param x0 old approximation for the root\n@param y0 function value at the approximation for the root\n@param x1 last calculated approximation for the root\n@param y1 function value at the last calculated approximation\nfor the root\n@param x2 bracket point (must be set to x0 if no bracket point is\nknown, this will force starting with linear interpolation)\n@param y2 function value at the bracket point.\n@return the value where the function is zero\n@throws MaxIterationsExceededException if the maximum iteration count\nis exceeded\n@throws FunctionEvaluationException if an error occurs evaluating\nthe function\n"
      }
    },
    "ff69ef1cc25034ce8fd11838ab4478a7a0b048f1": {
      "type": "Yintroduced",
      "commitMessage": "[MATH-156] use initial guess provided by the caller to BrentSolver.solve(),\nthus improving speed\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/math/trunk@536283 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "5/8/07, 11:16 AM",
      "commitName": "ff69ef1cc25034ce8fd11838ab4478a7a0b048f1",
      "commitAuthor": "Luc Maisonobe",
      "diff": "@@ -0,0 +1,72 @@\n+private double solve(double x0, double y0, double x1, double y1, double x2, double y2) throws MaxIterationsExceededException, FunctionEvaluationException {\n+    double delta \u003d x1 - x0;\n+    double oldDelta \u003d delta;\n+    int i \u003d 0;\n+    while (i \u003c maximalIterationCount) {\n+        if (Math.abs(y2) \u003c Math.abs(y1)) {\n+            x0 \u003d x1;\n+            x1 \u003d x2;\n+            x2 \u003d x0;\n+            y0 \u003d y1;\n+            y1 \u003d y2;\n+            y2 \u003d y0;\n+        }\n+        if (Math.abs(y1) \u003c\u003d functionValueAccuracy) {\n+            setResult(x1, i);\n+            return result;\n+        }\n+        double dx \u003d (x2 - x1);\n+        double tolerance \u003d Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy);\n+        if (Math.abs(dx) \u003c\u003d tolerance) {\n+            setResult(x1, i);\n+            return result;\n+        }\n+        if ((Math.abs(oldDelta) \u003c tolerance) || (Math.abs(y0) \u003c\u003d Math.abs(y1))) {\n+            delta \u003d 0.5 * dx;\n+            oldDelta \u003d delta;\n+        } else {\n+            double r3 \u003d y1 / y0;\n+            double p;\n+            double p1;\n+            if (x0 \u003d\u003d x2) {\n+                p \u003d dx * r3;\n+                p1 \u003d 1.0 - r3;\n+            } else {\n+                double r1 \u003d y0 / y2;\n+                double r2 \u003d y1 / y2;\n+                p \u003d r3 * (dx * r1 * (r1 - r2) - (x1 - x0) * (r2 - 1.0));\n+                p1 \u003d (r1 - 1.0) * (r2 - 1.0) * (r3 - 1.0);\n+            }\n+            if (p \u003e 0.0) {\n+                p1 \u003d -p1;\n+            } else {\n+                p \u003d -p;\n+            }\n+            if (2.0 * p \u003e\u003d 1.5 * dx * p1 - Math.abs(tolerance * p1) || p \u003e\u003d Math.abs(0.5 * oldDelta * p1)) {\n+                delta \u003d 0.5 * dx;\n+                oldDelta \u003d delta;\n+            } else {\n+                oldDelta \u003d delta;\n+                delta \u003d p / p1;\n+            }\n+        }\n+        x0 \u003d x1;\n+        y0 \u003d y1;\n+        if (Math.abs(delta) \u003e tolerance) {\n+            x1 \u003d x1 + delta;\n+        } else if (dx \u003e 0.0) {\n+            x1 \u003d x1 + 0.5 * tolerance;\n+        } else if (dx \u003c\u003d 0.0) {\n+            x1 \u003d x1 - 0.5 * tolerance;\n+        }\n+        y1 \u003d f.value(x1);\n+        if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n+            x2 \u003d x0;\n+            y2 \u003d y0;\n+            delta \u003d x1 - x0;\n+            oldDelta \u003d delta;\n+        }\n+        i++;\n+    }\n+    throw new MaxIterationsExceededException(maximalIterationCount);\n+}\n\\ No newline at end of file\n",
      "actualSource": "private double solve(double x0, double y0, double x1, double y1, double x2, double y2) throws MaxIterationsExceededException, FunctionEvaluationException {\n    double delta \u003d x1 - x0;\n    double oldDelta \u003d delta;\n    int i \u003d 0;\n    while (i \u003c maximalIterationCount) {\n        if (Math.abs(y2) \u003c Math.abs(y1)) {\n            x0 \u003d x1;\n            x1 \u003d x2;\n            x2 \u003d x0;\n            y0 \u003d y1;\n            y1 \u003d y2;\n            y2 \u003d y0;\n        }\n        if (Math.abs(y1) \u003c\u003d functionValueAccuracy) {\n            setResult(x1, i);\n            return result;\n        }\n        double dx \u003d (x2 - x1);\n        double tolerance \u003d Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy);\n        if (Math.abs(dx) \u003c\u003d tolerance) {\n            setResult(x1, i);\n            return result;\n        }\n        if ((Math.abs(oldDelta) \u003c tolerance) || (Math.abs(y0) \u003c\u003d Math.abs(y1))) {\n            delta \u003d 0.5 * dx;\n            oldDelta \u003d delta;\n        } else {\n            double r3 \u003d y1 / y0;\n            double p;\n            double p1;\n            if (x0 \u003d\u003d x2) {\n                p \u003d dx * r3;\n                p1 \u003d 1.0 - r3;\n            } else {\n                double r1 \u003d y0 / y2;\n                double r2 \u003d y1 / y2;\n                p \u003d r3 * (dx * r1 * (r1 - r2) - (x1 - x0) * (r2 - 1.0));\n                p1 \u003d (r1 - 1.0) * (r2 - 1.0) * (r3 - 1.0);\n            }\n            if (p \u003e 0.0) {\n                p1 \u003d -p1;\n            } else {\n                p \u003d -p;\n            }\n            if (2.0 * p \u003e\u003d 1.5 * dx * p1 - Math.abs(tolerance * p1) || p \u003e\u003d Math.abs(0.5 * oldDelta * p1)) {\n                delta \u003d 0.5 * dx;\n                oldDelta \u003d delta;\n            } else {\n                oldDelta \u003d delta;\n                delta \u003d p / p1;\n            }\n        }\n        x0 \u003d x1;\n        y0 \u003d y1;\n        if (Math.abs(delta) \u003e tolerance) {\n            x1 \u003d x1 + delta;\n        } else if (dx \u003e 0.0) {\n            x1 \u003d x1 + 0.5 * tolerance;\n        } else if (dx \u003c\u003d 0.0) {\n            x1 \u003d x1 - 0.5 * tolerance;\n        }\n        y1 \u003d f.value(x1);\n        if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n            x2 \u003d x0;\n            y2 \u003d y0;\n            delta \u003d x1 - x0;\n            oldDelta \u003d delta;\n        }\n        i++;\n    }\n    throw new MaxIterationsExceededException(maximalIterationCount);\n}",
      "path": "src/java/org/apache/commons/math/analysis/BrentSolver.java",
      "functionStartLine": 163,
      "functionName": "solve",
      "functionAnnotation": "",
      "functionDoc": "Find a zero starting search according to the three provided points.\n\n@param x0 old approximation for the root\n@param y0 function value at the approximation for the root\n@param x1 last calculated approximation for the root\n@param y1 function value at the last calculated approximation\nfor the root\n@param x2 bracket point (must be set to x0 if no bracket point is\nknown, this will force starting with linear interpolation)\n@param y3 function value at the bracket point.\n@return the value where the function is zero\n@throws MaxIterationsExceededException if the maximum iteration count\nis exceeded\n@throws FunctionEvaluationException if an error occurs evaluating\nthe function\n"
    }
  }
}