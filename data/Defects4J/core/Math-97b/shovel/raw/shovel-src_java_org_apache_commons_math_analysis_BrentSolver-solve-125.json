{
  "origin": "codeshovel",
  "repositoryName": "Math-97b",
  "repositoryPath": "/tmp/Math-97b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "BrentSolver.java",
  "functionName": "solve",
  "functionId": "solve___min-double__max-double",
  "sourceFilePath": "src/java/org/apache/commons/math/analysis/BrentSolver.java",
  "functionAnnotation": "",
  "functionDoc": "Find a zero in the given interval.\n\u003cp\u003e\nRequires that the values of the function at the endpoints have opposite\nsigns. An \u003ccode\u003eIllegalArgumentException\u003c/code\u003e is thrown if this is not\nthe case.\u003c/p\u003e\n\n@param min the lower bound for the interval.\n@param max the upper bound for the interval.\n@return the value where the function is zero\n@throws MaxIterationsExceededException if the maximum iteration count is exceeded\n@throws FunctionEvaluationException if an error occurs evaluating the\nfunction\n@throws IllegalArgumentException if min is not less than max or the\nsigns of the values of the function at the endpoints are not opposites\n",
  "functionStartLine": 125,
  "functionEndLine": 145,
  "numCommitsSeen": 29,
  "timeTaken": 900,
  "changeHistory": [
    "932ebf87acd81162cc7b1751c18b0e0ca760c8bf",
    "ff69ef1cc25034ce8fd11838ab4478a7a0b048f1",
    "d2d4c5fd63f279be0797468277593ef72506c696",
    "4f1e69b5313761cb95909359a408d13e6aa29635",
    "6a978ea29f680a87dfc380c760adf2e17b2e7c9c",
    "2d69367fab142b626ce36d418272f99ad8fc3dc1",
    "0a904461932f2c0455611e77ec6a8d8aced2980b"
  ],
  "changeHistoryShort": {
    "932ebf87acd81162cc7b1751c18b0e0ca760c8bf": "Ydocchange",
    "ff69ef1cc25034ce8fd11838ab4478a7a0b048f1": "Ybodychange",
    "d2d4c5fd63f279be0797468277593ef72506c696": "Ymultichange(Yexceptionschange,Ybodychange,Ydocchange)",
    "4f1e69b5313761cb95909359a408d13e6aa29635": "Ybodychange",
    "6a978ea29f680a87dfc380c760adf2e17b2e7c9c": "Ymultichange(Yexceptionschange,Ybodychange,Ydocchange)",
    "2d69367fab142b626ce36d418272f99ad8fc3dc1": "Ymultichange(Ybodychange,Ydocchange)",
    "0a904461932f2c0455611e77ec6a8d8aced2980b": "Yintroduced"
  },
  "changeHistoryDetails": {
    "932ebf87acd81162cc7b1751c18b0e0ca760c8bf": {
      "type": "Ydocchange",
      "commitMessage": "Javadoc only. Added missing \u003c/p\u003e\u0027s\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@615734 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "1/27/08, 10:10 PM",
      "commitName": "932ebf87acd81162cc7b1751c18b0e0ca760c8bf",
      "commitAuthor": "Phil Steitz",
      "commitDateOld": "1/20/08, 8:49 AM",
      "commitNameOld": "fd77bfbe13369c830259d6a5cf8b75f6cdf65321",
      "commitAuthorOld": "Luc Maisonobe",
      "daysBetweenCommits": 7.56,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "actualSource": "public double solve(double min, double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifyInterval(min, max);\n    double yMin \u003d f.value(min);\n    double yMax \u003d f.value(max);\n    if (yMin * yMax \u003e\u003d 0) {\n        throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\" + \"  Endpoints: [\" + min + \",\" + max + \"]\" + \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n    }\n    return solve(min, yMin, max, yMax, min, yMin);\n}",
      "path": "src/java/org/apache/commons/math/analysis/BrentSolver.java",
      "functionStartLine": 125,
      "functionName": "solve",
      "functionAnnotation": "",
      "functionDoc": "Find a zero in the given interval.\n\u003cp\u003e\nRequires that the values of the function at the endpoints have opposite\nsigns. An \u003ccode\u003eIllegalArgumentException\u003c/code\u003e is thrown if this is not\nthe case.\u003c/p\u003e\n\n@param min the lower bound for the interval.\n@param max the upper bound for the interval.\n@return the value where the function is zero\n@throws MaxIterationsExceededException if the maximum iteration count is exceeded\n@throws FunctionEvaluationException if an error occurs evaluating the\nfunction\n@throws IllegalArgumentException if min is not less than max or the\nsigns of the values of the function at the endpoints are not opposites\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "Find a zero in the given interval.\n\u003cp\u003e\nRequires that the values of the function at the endpoints have opposite\nsigns. An \u003ccode\u003eIllegalArgumentException\u003c/code\u003e is thrown if this is not\nthe case.\n\n@param min the lower bound for the interval.\n@param max the upper bound for the interval.\n@return the value where the function is zero\n@throws MaxIterationsExceededException if the maximum iteration count is exceeded\n@throws FunctionEvaluationException if an error occurs evaluating the\nfunction\n@throws IllegalArgumentException if min is not less than max or the\nsigns of the values of the function at the endpoints are not opposites\n",
        "newValue": "Find a zero in the given interval.\n\u003cp\u003e\nRequires that the values of the function at the endpoints have opposite\nsigns. An \u003ccode\u003eIllegalArgumentException\u003c/code\u003e is thrown if this is not\nthe case.\u003c/p\u003e\n\n@param min the lower bound for the interval.\n@param max the upper bound for the interval.\n@return the value where the function is zero\n@throws MaxIterationsExceededException if the maximum iteration count is exceeded\n@throws FunctionEvaluationException if an error occurs evaluating the\nfunction\n@throws IllegalArgumentException if min is not less than max or the\nsigns of the values of the function at the endpoints are not opposites\n"
      }
    },
    "ff69ef1cc25034ce8fd11838ab4478a7a0b048f1": {
      "type": "Ybodychange",
      "commitMessage": "[MATH-156] use initial guess provided by the caller to BrentSolver.solve(),\nthus improving speed\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/math/trunk@536283 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "5/8/07, 11:16 AM",
      "commitName": "ff69ef1cc25034ce8fd11838ab4478a7a0b048f1",
      "commitAuthor": "Luc Maisonobe",
      "commitDateOld": "2/12/07, 11:17 AM",
      "commitNameOld": "d2d4c5fd63f279be0797468277593ef72506c696",
      "commitAuthorOld": "Luc Maisonobe",
      "daysBetweenCommits": 84.96,
      "commitsBetweenForRepo": 44,
      "commitsBetweenForFile": 1,
      "actualSource": "public double solve(double min, double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifyInterval(min, max);\n    double yMin \u003d f.value(min);\n    double yMax \u003d f.value(max);\n    if (yMin * yMax \u003e\u003d 0) {\n        throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\" + \"  Endpoints: [\" + min + \",\" + max + \"]\" + \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n    }\n    return solve(min, yMin, max, yMax, min, yMin);\n}",
      "path": "src/java/org/apache/commons/math/analysis/BrentSolver.java",
      "functionStartLine": 125,
      "functionName": "solve",
      "functionAnnotation": "",
      "functionDoc": "Find a zero in the given interval.\n\u003cp\u003e\nRequires that the values of the function at the endpoints have opposite\nsigns. An \u003ccode\u003eIllegalArgumentException\u003c/code\u003e is thrown if this is not\nthe case.\n\n@param min the lower bound for the interval.\n@param max the upper bound for the interval.\n@return the value where the function is zero\n@throws MaxIterationsExceededException if the maximum iteration count is exceeded\n@throws FunctionEvaluationException if an error occurs evaluating the\nfunction\n@throws IllegalArgumentException if min is not less than max or the\nsigns of the values of the function at the endpoints are not opposites\n",
      "diff": "@@ -1,85 +1,10 @@\n public double solve(double min, double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n     clearResult();\n     verifyInterval(min, max);\n-    double x0 \u003d min;\n-    double x1 \u003d max;\n-    double y0;\n-    double y1;\n-    y0 \u003d f.value(x0);\n-    y1 \u003d f.value(x1);\n-    if (y0 * y1 \u003e\u003d 0) {\n-        throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\" + \"  Endpoints: [\" + min + \",\" + max + \"]\" + \"  Values: [\" + y0 + \",\" + y1 + \"]\");\n+    double yMin \u003d f.value(min);\n+    double yMax \u003d f.value(max);\n+    if (yMin * yMax \u003e\u003d 0) {\n+        throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\" + \"  Endpoints: [\" + min + \",\" + max + \"]\" + \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n     }\n-    double x2 \u003d x0;\n-    double y2 \u003d y0;\n-    double delta \u003d x1 - x0;\n-    double oldDelta \u003d delta;\n-    int i \u003d 0;\n-    while (i \u003c maximalIterationCount) {\n-        if (Math.abs(y2) \u003c Math.abs(y1)) {\n-            x0 \u003d x1;\n-            x1 \u003d x2;\n-            x2 \u003d x0;\n-            y0 \u003d y1;\n-            y1 \u003d y2;\n-            y2 \u003d y0;\n-        }\n-        if (Math.abs(y1) \u003c\u003d functionValueAccuracy) {\n-            setResult(x1, i);\n-            return result;\n-        }\n-        double dx \u003d (x2 - x1);\n-        double tolerance \u003d Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy);\n-        if (Math.abs(dx) \u003c\u003d tolerance) {\n-            setResult(x1, i);\n-            return result;\n-        }\n-        if ((Math.abs(oldDelta) \u003c tolerance) || (Math.abs(y0) \u003c\u003d Math.abs(y1))) {\n-            delta \u003d 0.5 * dx;\n-            oldDelta \u003d delta;\n-        } else {\n-            double r3 \u003d y1 / y0;\n-            double p;\n-            double p1;\n-            if (x0 \u003d\u003d x2) {\n-                p \u003d dx * r3;\n-                p1 \u003d 1.0 - r3;\n-            } else {\n-                double r1 \u003d y0 / y2;\n-                double r2 \u003d y1 / y2;\n-                p \u003d r3 * (dx * r1 * (r1 - r2) - (x1 - x0) * (r2 - 1.0));\n-                p1 \u003d (r1 - 1.0) * (r2 - 1.0) * (r3 - 1.0);\n-            }\n-            if (p \u003e 0.0) {\n-                p1 \u003d -p1;\n-            } else {\n-                p \u003d -p;\n-            }\n-            if (2.0 * p \u003e\u003d 1.5 * dx * p1 - Math.abs(tolerance * p1) || p \u003e\u003d Math.abs(0.5 * oldDelta * p1)) {\n-                delta \u003d 0.5 * dx;\n-                oldDelta \u003d delta;\n-            } else {\n-                oldDelta \u003d delta;\n-                delta \u003d p / p1;\n-            }\n-        }\n-        x0 \u003d x1;\n-        y0 \u003d y1;\n-        if (Math.abs(delta) \u003e tolerance) {\n-            x1 \u003d x1 + delta;\n-        } else if (dx \u003e 0.0) {\n-            x1 \u003d x1 + 0.5 * tolerance;\n-        } else if (dx \u003c\u003d 0.0) {\n-            x1 \u003d x1 - 0.5 * tolerance;\n-        }\n-        y1 \u003d f.value(x1);\n-        if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n-            x2 \u003d x0;\n-            y2 \u003d y0;\n-            delta \u003d x1 - x0;\n-            oldDelta \u003d delta;\n-        }\n-        i++;\n-    }\n-    throw new MaxIterationsExceededException(maximalIterationCount);\n+    return solve(min, yMin, max, yMax, min, yMin);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d2d4c5fd63f279be0797468277593ef72506c696": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange,Ydocchange)",
      "commitMessage": "Added and used a specialized convergence exception for exceeded iteration counts\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/math/trunk@506585 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2/12/07, 11:17 AM",
      "commitName": "d2d4c5fd63f279be0797468277593ef72506c696",
      "commitAuthor": "Luc Maisonobe",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "Added and used a specialized convergence exception for exceeded iteration counts\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/math/trunk@506585 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2/12/07, 11:17 AM",
          "commitName": "d2d4c5fd63f279be0797468277593ef72506c696",
          "commitAuthor": "Luc Maisonobe",
          "commitDateOld": "11/28/06, 11:14 PM",
          "commitNameOld": "05f7f6059bd0cbb69b5dd49c061f1f3520e0ee1e",
          "commitAuthorOld": "Henri Yandell",
          "daysBetweenCommits": 75.5,
          "commitsBetweenForRepo": 8,
          "commitsBetweenForFile": 1,
          "actualSource": "public double solve(double min, double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifyInterval(min, max);\n    double x0 \u003d min;\n    double x1 \u003d max;\n    double y0;\n    double y1;\n    y0 \u003d f.value(x0);\n    y1 \u003d f.value(x1);\n    if (y0 * y1 \u003e\u003d 0) {\n        throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\" + \"  Endpoints: [\" + min + \",\" + max + \"]\" + \"  Values: [\" + y0 + \",\" + y1 + \"]\");\n    }\n    double x2 \u003d x0;\n    double y2 \u003d y0;\n    double delta \u003d x1 - x0;\n    double oldDelta \u003d delta;\n    int i \u003d 0;\n    while (i \u003c maximalIterationCount) {\n        if (Math.abs(y2) \u003c Math.abs(y1)) {\n            x0 \u003d x1;\n            x1 \u003d x2;\n            x2 \u003d x0;\n            y0 \u003d y1;\n            y1 \u003d y2;\n            y2 \u003d y0;\n        }\n        if (Math.abs(y1) \u003c\u003d functionValueAccuracy) {\n            setResult(x1, i);\n            return result;\n        }\n        double dx \u003d (x2 - x1);\n        double tolerance \u003d Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy);\n        if (Math.abs(dx) \u003c\u003d tolerance) {\n            setResult(x1, i);\n            return result;\n        }\n        if ((Math.abs(oldDelta) \u003c tolerance) || (Math.abs(y0) \u003c\u003d Math.abs(y1))) {\n            delta \u003d 0.5 * dx;\n            oldDelta \u003d delta;\n        } else {\n            double r3 \u003d y1 / y0;\n            double p;\n            double p1;\n            if (x0 \u003d\u003d x2) {\n                p \u003d dx * r3;\n                p1 \u003d 1.0 - r3;\n            } else {\n                double r1 \u003d y0 / y2;\n                double r2 \u003d y1 / y2;\n                p \u003d r3 * (dx * r1 * (r1 - r2) - (x1 - x0) * (r2 - 1.0));\n                p1 \u003d (r1 - 1.0) * (r2 - 1.0) * (r3 - 1.0);\n            }\n            if (p \u003e 0.0) {\n                p1 \u003d -p1;\n            } else {\n                p \u003d -p;\n            }\n            if (2.0 * p \u003e\u003d 1.5 * dx * p1 - Math.abs(tolerance * p1) || p \u003e\u003d Math.abs(0.5 * oldDelta * p1)) {\n                delta \u003d 0.5 * dx;\n                oldDelta \u003d delta;\n            } else {\n                oldDelta \u003d delta;\n                delta \u003d p / p1;\n            }\n        }\n        x0 \u003d x1;\n        y0 \u003d y1;\n        if (Math.abs(delta) \u003e tolerance) {\n            x1 \u003d x1 + delta;\n        } else if (dx \u003e 0.0) {\n            x1 \u003d x1 + 0.5 * tolerance;\n        } else if (dx \u003c\u003d 0.0) {\n            x1 \u003d x1 - 0.5 * tolerance;\n        }\n        y1 \u003d f.value(x1);\n        if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n            x2 \u003d x0;\n            y2 \u003d y0;\n            delta \u003d x1 - x0;\n            oldDelta \u003d delta;\n        }\n        i++;\n    }\n    throw new MaxIterationsExceededException(maximalIterationCount);\n}",
          "path": "src/java/org/apache/commons/math/analysis/BrentSolver.java",
          "functionStartLine": 82,
          "functionName": "solve",
          "functionAnnotation": "",
          "functionDoc": "Find a zero in the given interval.\n\u003cp\u003e\nRequires that the values of the function at the endpoints have opposite\nsigns. An \u003ccode\u003eIllegalArgumentException\u003c/code\u003e is thrown if this is not\nthe case.\n\n@param min the lower bound for the interval.\n@param max the upper bound for the interval.\n@return the value where the function is zero\n@throws MaxIterationsExceededException if the maximum iteration count is exceeded\n@throws FunctionEvaluationException if an error occurs evaluating the\nfunction\n@throws IllegalArgumentException if min is not less than max or the\nsigns of the values of the function at the endpoints are not opposites\n",
          "diff": "@@ -1,85 +1,85 @@\n-public double solve(double min, double max) throws ConvergenceException, FunctionEvaluationException {\n+public double solve(double min, double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n     clearResult();\n     verifyInterval(min, max);\n     double x0 \u003d min;\n     double x1 \u003d max;\n     double y0;\n     double y1;\n     y0 \u003d f.value(x0);\n     y1 \u003d f.value(x1);\n     if (y0 * y1 \u003e\u003d 0) {\n         throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\" + \"  Endpoints: [\" + min + \",\" + max + \"]\" + \"  Values: [\" + y0 + \",\" + y1 + \"]\");\n     }\n     double x2 \u003d x0;\n     double y2 \u003d y0;\n     double delta \u003d x1 - x0;\n     double oldDelta \u003d delta;\n     int i \u003d 0;\n     while (i \u003c maximalIterationCount) {\n         if (Math.abs(y2) \u003c Math.abs(y1)) {\n             x0 \u003d x1;\n             x1 \u003d x2;\n             x2 \u003d x0;\n             y0 \u003d y1;\n             y1 \u003d y2;\n             y2 \u003d y0;\n         }\n         if (Math.abs(y1) \u003c\u003d functionValueAccuracy) {\n             setResult(x1, i);\n             return result;\n         }\n         double dx \u003d (x2 - x1);\n         double tolerance \u003d Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy);\n         if (Math.abs(dx) \u003c\u003d tolerance) {\n             setResult(x1, i);\n             return result;\n         }\n         if ((Math.abs(oldDelta) \u003c tolerance) || (Math.abs(y0) \u003c\u003d Math.abs(y1))) {\n             delta \u003d 0.5 * dx;\n             oldDelta \u003d delta;\n         } else {\n             double r3 \u003d y1 / y0;\n             double p;\n             double p1;\n             if (x0 \u003d\u003d x2) {\n                 p \u003d dx * r3;\n                 p1 \u003d 1.0 - r3;\n             } else {\n                 double r1 \u003d y0 / y2;\n                 double r2 \u003d y1 / y2;\n                 p \u003d r3 * (dx * r1 * (r1 - r2) - (x1 - x0) * (r2 - 1.0));\n                 p1 \u003d (r1 - 1.0) * (r2 - 1.0) * (r3 - 1.0);\n             }\n             if (p \u003e 0.0) {\n                 p1 \u003d -p1;\n             } else {\n                 p \u003d -p;\n             }\n             if (2.0 * p \u003e\u003d 1.5 * dx * p1 - Math.abs(tolerance * p1) || p \u003e\u003d Math.abs(0.5 * oldDelta * p1)) {\n                 delta \u003d 0.5 * dx;\n                 oldDelta \u003d delta;\n             } else {\n                 oldDelta \u003d delta;\n                 delta \u003d p / p1;\n             }\n         }\n         x0 \u003d x1;\n         y0 \u003d y1;\n         if (Math.abs(delta) \u003e tolerance) {\n             x1 \u003d x1 + delta;\n         } else if (dx \u003e 0.0) {\n             x1 \u003d x1 + 0.5 * tolerance;\n         } else if (dx \u003c\u003d 0.0) {\n             x1 \u003d x1 - 0.5 * tolerance;\n         }\n         y1 \u003d f.value(x1);\n         if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n             x2 \u003d x0;\n             y2 \u003d y0;\n             delta \u003d x1 - x0;\n             oldDelta \u003d delta;\n         }\n         i++;\n     }\n-    throw new ConvergenceException(\"Maximum number of iterations exceeded.\");\n+    throw new MaxIterationsExceededException(maximalIterationCount);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[ConvergenceException, FunctionEvaluationException]",
            "newValue": "[MaxIterationsExceededException, FunctionEvaluationException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Added and used a specialized convergence exception for exceeded iteration counts\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/math/trunk@506585 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2/12/07, 11:17 AM",
          "commitName": "d2d4c5fd63f279be0797468277593ef72506c696",
          "commitAuthor": "Luc Maisonobe",
          "commitDateOld": "11/28/06, 11:14 PM",
          "commitNameOld": "05f7f6059bd0cbb69b5dd49c061f1f3520e0ee1e",
          "commitAuthorOld": "Henri Yandell",
          "daysBetweenCommits": 75.5,
          "commitsBetweenForRepo": 8,
          "commitsBetweenForFile": 1,
          "actualSource": "public double solve(double min, double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifyInterval(min, max);\n    double x0 \u003d min;\n    double x1 \u003d max;\n    double y0;\n    double y1;\n    y0 \u003d f.value(x0);\n    y1 \u003d f.value(x1);\n    if (y0 * y1 \u003e\u003d 0) {\n        throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\" + \"  Endpoints: [\" + min + \",\" + max + \"]\" + \"  Values: [\" + y0 + \",\" + y1 + \"]\");\n    }\n    double x2 \u003d x0;\n    double y2 \u003d y0;\n    double delta \u003d x1 - x0;\n    double oldDelta \u003d delta;\n    int i \u003d 0;\n    while (i \u003c maximalIterationCount) {\n        if (Math.abs(y2) \u003c Math.abs(y1)) {\n            x0 \u003d x1;\n            x1 \u003d x2;\n            x2 \u003d x0;\n            y0 \u003d y1;\n            y1 \u003d y2;\n            y2 \u003d y0;\n        }\n        if (Math.abs(y1) \u003c\u003d functionValueAccuracy) {\n            setResult(x1, i);\n            return result;\n        }\n        double dx \u003d (x2 - x1);\n        double tolerance \u003d Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy);\n        if (Math.abs(dx) \u003c\u003d tolerance) {\n            setResult(x1, i);\n            return result;\n        }\n        if ((Math.abs(oldDelta) \u003c tolerance) || (Math.abs(y0) \u003c\u003d Math.abs(y1))) {\n            delta \u003d 0.5 * dx;\n            oldDelta \u003d delta;\n        } else {\n            double r3 \u003d y1 / y0;\n            double p;\n            double p1;\n            if (x0 \u003d\u003d x2) {\n                p \u003d dx * r3;\n                p1 \u003d 1.0 - r3;\n            } else {\n                double r1 \u003d y0 / y2;\n                double r2 \u003d y1 / y2;\n                p \u003d r3 * (dx * r1 * (r1 - r2) - (x1 - x0) * (r2 - 1.0));\n                p1 \u003d (r1 - 1.0) * (r2 - 1.0) * (r3 - 1.0);\n            }\n            if (p \u003e 0.0) {\n                p1 \u003d -p1;\n            } else {\n                p \u003d -p;\n            }\n            if (2.0 * p \u003e\u003d 1.5 * dx * p1 - Math.abs(tolerance * p1) || p \u003e\u003d Math.abs(0.5 * oldDelta * p1)) {\n                delta \u003d 0.5 * dx;\n                oldDelta \u003d delta;\n            } else {\n                oldDelta \u003d delta;\n                delta \u003d p / p1;\n            }\n        }\n        x0 \u003d x1;\n        y0 \u003d y1;\n        if (Math.abs(delta) \u003e tolerance) {\n            x1 \u003d x1 + delta;\n        } else if (dx \u003e 0.0) {\n            x1 \u003d x1 + 0.5 * tolerance;\n        } else if (dx \u003c\u003d 0.0) {\n            x1 \u003d x1 - 0.5 * tolerance;\n        }\n        y1 \u003d f.value(x1);\n        if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n            x2 \u003d x0;\n            y2 \u003d y0;\n            delta \u003d x1 - x0;\n            oldDelta \u003d delta;\n        }\n        i++;\n    }\n    throw new MaxIterationsExceededException(maximalIterationCount);\n}",
          "path": "src/java/org/apache/commons/math/analysis/BrentSolver.java",
          "functionStartLine": 82,
          "functionName": "solve",
          "functionAnnotation": "",
          "functionDoc": "Find a zero in the given interval.\n\u003cp\u003e\nRequires that the values of the function at the endpoints have opposite\nsigns. An \u003ccode\u003eIllegalArgumentException\u003c/code\u003e is thrown if this is not\nthe case.\n\n@param min the lower bound for the interval.\n@param max the upper bound for the interval.\n@return the value where the function is zero\n@throws MaxIterationsExceededException if the maximum iteration count is exceeded\n@throws FunctionEvaluationException if an error occurs evaluating the\nfunction\n@throws IllegalArgumentException if min is not less than max or the\nsigns of the values of the function at the endpoints are not opposites\n",
          "diff": "@@ -1,85 +1,85 @@\n-public double solve(double min, double max) throws ConvergenceException, FunctionEvaluationException {\n+public double solve(double min, double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n     clearResult();\n     verifyInterval(min, max);\n     double x0 \u003d min;\n     double x1 \u003d max;\n     double y0;\n     double y1;\n     y0 \u003d f.value(x0);\n     y1 \u003d f.value(x1);\n     if (y0 * y1 \u003e\u003d 0) {\n         throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\" + \"  Endpoints: [\" + min + \",\" + max + \"]\" + \"  Values: [\" + y0 + \",\" + y1 + \"]\");\n     }\n     double x2 \u003d x0;\n     double y2 \u003d y0;\n     double delta \u003d x1 - x0;\n     double oldDelta \u003d delta;\n     int i \u003d 0;\n     while (i \u003c maximalIterationCount) {\n         if (Math.abs(y2) \u003c Math.abs(y1)) {\n             x0 \u003d x1;\n             x1 \u003d x2;\n             x2 \u003d x0;\n             y0 \u003d y1;\n             y1 \u003d y2;\n             y2 \u003d y0;\n         }\n         if (Math.abs(y1) \u003c\u003d functionValueAccuracy) {\n             setResult(x1, i);\n             return result;\n         }\n         double dx \u003d (x2 - x1);\n         double tolerance \u003d Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy);\n         if (Math.abs(dx) \u003c\u003d tolerance) {\n             setResult(x1, i);\n             return result;\n         }\n         if ((Math.abs(oldDelta) \u003c tolerance) || (Math.abs(y0) \u003c\u003d Math.abs(y1))) {\n             delta \u003d 0.5 * dx;\n             oldDelta \u003d delta;\n         } else {\n             double r3 \u003d y1 / y0;\n             double p;\n             double p1;\n             if (x0 \u003d\u003d x2) {\n                 p \u003d dx * r3;\n                 p1 \u003d 1.0 - r3;\n             } else {\n                 double r1 \u003d y0 / y2;\n                 double r2 \u003d y1 / y2;\n                 p \u003d r3 * (dx * r1 * (r1 - r2) - (x1 - x0) * (r2 - 1.0));\n                 p1 \u003d (r1 - 1.0) * (r2 - 1.0) * (r3 - 1.0);\n             }\n             if (p \u003e 0.0) {\n                 p1 \u003d -p1;\n             } else {\n                 p \u003d -p;\n             }\n             if (2.0 * p \u003e\u003d 1.5 * dx * p1 - Math.abs(tolerance * p1) || p \u003e\u003d Math.abs(0.5 * oldDelta * p1)) {\n                 delta \u003d 0.5 * dx;\n                 oldDelta \u003d delta;\n             } else {\n                 oldDelta \u003d delta;\n                 delta \u003d p / p1;\n             }\n         }\n         x0 \u003d x1;\n         y0 \u003d y1;\n         if (Math.abs(delta) \u003e tolerance) {\n             x1 \u003d x1 + delta;\n         } else if (dx \u003e 0.0) {\n             x1 \u003d x1 + 0.5 * tolerance;\n         } else if (dx \u003c\u003d 0.0) {\n             x1 \u003d x1 - 0.5 * tolerance;\n         }\n         y1 \u003d f.value(x1);\n         if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n             x2 \u003d x0;\n             y2 \u003d y0;\n             delta \u003d x1 - x0;\n             oldDelta \u003d delta;\n         }\n         i++;\n     }\n-    throw new ConvergenceException(\"Maximum number of iterations exceeded.\");\n+    throw new MaxIterationsExceededException(maximalIterationCount);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Added and used a specialized convergence exception for exceeded iteration counts\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/math/trunk@506585 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2/12/07, 11:17 AM",
          "commitName": "d2d4c5fd63f279be0797468277593ef72506c696",
          "commitAuthor": "Luc Maisonobe",
          "commitDateOld": "11/28/06, 11:14 PM",
          "commitNameOld": "05f7f6059bd0cbb69b5dd49c061f1f3520e0ee1e",
          "commitAuthorOld": "Henri Yandell",
          "daysBetweenCommits": 75.5,
          "commitsBetweenForRepo": 8,
          "commitsBetweenForFile": 1,
          "actualSource": "public double solve(double min, double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifyInterval(min, max);\n    double x0 \u003d min;\n    double x1 \u003d max;\n    double y0;\n    double y1;\n    y0 \u003d f.value(x0);\n    y1 \u003d f.value(x1);\n    if (y0 * y1 \u003e\u003d 0) {\n        throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\" + \"  Endpoints: [\" + min + \",\" + max + \"]\" + \"  Values: [\" + y0 + \",\" + y1 + \"]\");\n    }\n    double x2 \u003d x0;\n    double y2 \u003d y0;\n    double delta \u003d x1 - x0;\n    double oldDelta \u003d delta;\n    int i \u003d 0;\n    while (i \u003c maximalIterationCount) {\n        if (Math.abs(y2) \u003c Math.abs(y1)) {\n            x0 \u003d x1;\n            x1 \u003d x2;\n            x2 \u003d x0;\n            y0 \u003d y1;\n            y1 \u003d y2;\n            y2 \u003d y0;\n        }\n        if (Math.abs(y1) \u003c\u003d functionValueAccuracy) {\n            setResult(x1, i);\n            return result;\n        }\n        double dx \u003d (x2 - x1);\n        double tolerance \u003d Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy);\n        if (Math.abs(dx) \u003c\u003d tolerance) {\n            setResult(x1, i);\n            return result;\n        }\n        if ((Math.abs(oldDelta) \u003c tolerance) || (Math.abs(y0) \u003c\u003d Math.abs(y1))) {\n            delta \u003d 0.5 * dx;\n            oldDelta \u003d delta;\n        } else {\n            double r3 \u003d y1 / y0;\n            double p;\n            double p1;\n            if (x0 \u003d\u003d x2) {\n                p \u003d dx * r3;\n                p1 \u003d 1.0 - r3;\n            } else {\n                double r1 \u003d y0 / y2;\n                double r2 \u003d y1 / y2;\n                p \u003d r3 * (dx * r1 * (r1 - r2) - (x1 - x0) * (r2 - 1.0));\n                p1 \u003d (r1 - 1.0) * (r2 - 1.0) * (r3 - 1.0);\n            }\n            if (p \u003e 0.0) {\n                p1 \u003d -p1;\n            } else {\n                p \u003d -p;\n            }\n            if (2.0 * p \u003e\u003d 1.5 * dx * p1 - Math.abs(tolerance * p1) || p \u003e\u003d Math.abs(0.5 * oldDelta * p1)) {\n                delta \u003d 0.5 * dx;\n                oldDelta \u003d delta;\n            } else {\n                oldDelta \u003d delta;\n                delta \u003d p / p1;\n            }\n        }\n        x0 \u003d x1;\n        y0 \u003d y1;\n        if (Math.abs(delta) \u003e tolerance) {\n            x1 \u003d x1 + delta;\n        } else if (dx \u003e 0.0) {\n            x1 \u003d x1 + 0.5 * tolerance;\n        } else if (dx \u003c\u003d 0.0) {\n            x1 \u003d x1 - 0.5 * tolerance;\n        }\n        y1 \u003d f.value(x1);\n        if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n            x2 \u003d x0;\n            y2 \u003d y0;\n            delta \u003d x1 - x0;\n            oldDelta \u003d delta;\n        }\n        i++;\n    }\n    throw new MaxIterationsExceededException(maximalIterationCount);\n}",
          "path": "src/java/org/apache/commons/math/analysis/BrentSolver.java",
          "functionStartLine": 82,
          "functionName": "solve",
          "functionAnnotation": "",
          "functionDoc": "Find a zero in the given interval.\n\u003cp\u003e\nRequires that the values of the function at the endpoints have opposite\nsigns. An \u003ccode\u003eIllegalArgumentException\u003c/code\u003e is thrown if this is not\nthe case.\n\n@param min the lower bound for the interval.\n@param max the upper bound for the interval.\n@return the value where the function is zero\n@throws MaxIterationsExceededException if the maximum iteration count is exceeded\n@throws FunctionEvaluationException if an error occurs evaluating the\nfunction\n@throws IllegalArgumentException if min is not less than max or the\nsigns of the values of the function at the endpoints are not opposites\n",
          "diff": "@@ -1,85 +1,85 @@\n-public double solve(double min, double max) throws ConvergenceException, FunctionEvaluationException {\n+public double solve(double min, double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n     clearResult();\n     verifyInterval(min, max);\n     double x0 \u003d min;\n     double x1 \u003d max;\n     double y0;\n     double y1;\n     y0 \u003d f.value(x0);\n     y1 \u003d f.value(x1);\n     if (y0 * y1 \u003e\u003d 0) {\n         throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\" + \"  Endpoints: [\" + min + \",\" + max + \"]\" + \"  Values: [\" + y0 + \",\" + y1 + \"]\");\n     }\n     double x2 \u003d x0;\n     double y2 \u003d y0;\n     double delta \u003d x1 - x0;\n     double oldDelta \u003d delta;\n     int i \u003d 0;\n     while (i \u003c maximalIterationCount) {\n         if (Math.abs(y2) \u003c Math.abs(y1)) {\n             x0 \u003d x1;\n             x1 \u003d x2;\n             x2 \u003d x0;\n             y0 \u003d y1;\n             y1 \u003d y2;\n             y2 \u003d y0;\n         }\n         if (Math.abs(y1) \u003c\u003d functionValueAccuracy) {\n             setResult(x1, i);\n             return result;\n         }\n         double dx \u003d (x2 - x1);\n         double tolerance \u003d Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy);\n         if (Math.abs(dx) \u003c\u003d tolerance) {\n             setResult(x1, i);\n             return result;\n         }\n         if ((Math.abs(oldDelta) \u003c tolerance) || (Math.abs(y0) \u003c\u003d Math.abs(y1))) {\n             delta \u003d 0.5 * dx;\n             oldDelta \u003d delta;\n         } else {\n             double r3 \u003d y1 / y0;\n             double p;\n             double p1;\n             if (x0 \u003d\u003d x2) {\n                 p \u003d dx * r3;\n                 p1 \u003d 1.0 - r3;\n             } else {\n                 double r1 \u003d y0 / y2;\n                 double r2 \u003d y1 / y2;\n                 p \u003d r3 * (dx * r1 * (r1 - r2) - (x1 - x0) * (r2 - 1.0));\n                 p1 \u003d (r1 - 1.0) * (r2 - 1.0) * (r3 - 1.0);\n             }\n             if (p \u003e 0.0) {\n                 p1 \u003d -p1;\n             } else {\n                 p \u003d -p;\n             }\n             if (2.0 * p \u003e\u003d 1.5 * dx * p1 - Math.abs(tolerance * p1) || p \u003e\u003d Math.abs(0.5 * oldDelta * p1)) {\n                 delta \u003d 0.5 * dx;\n                 oldDelta \u003d delta;\n             } else {\n                 oldDelta \u003d delta;\n                 delta \u003d p / p1;\n             }\n         }\n         x0 \u003d x1;\n         y0 \u003d y1;\n         if (Math.abs(delta) \u003e tolerance) {\n             x1 \u003d x1 + delta;\n         } else if (dx \u003e 0.0) {\n             x1 \u003d x1 + 0.5 * tolerance;\n         } else if (dx \u003c\u003d 0.0) {\n             x1 \u003d x1 - 0.5 * tolerance;\n         }\n         y1 \u003d f.value(x1);\n         if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n             x2 \u003d x0;\n             y2 \u003d y0;\n             delta \u003d x1 - x0;\n             oldDelta \u003d delta;\n         }\n         i++;\n     }\n-    throw new ConvergenceException(\"Maximum number of iterations exceeded.\");\n+    throw new MaxIterationsExceededException(maximalIterationCount);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Find a zero in the given interval.\n\u003cp\u003e\nRequires that the values of the function at the endpoints have opposite\nsigns. An \u003ccode\u003eIllegalArgumentException\u003c/code\u003e is thrown if this is not\nthe case.\n\n@param min the lower bound for the interval.\n@param max the upper bound for the interval.\n@return the value where the function is zero\n@throws ConvergenceException if the maximum iteration count is exceeded\n@throws FunctionEvaluationException if an error occurs evaluating the\nfunction\n@throws IllegalArgumentException if min is not less than max or the\nsigns of the values of the function at the endpoints are not opposites\n",
            "newValue": "Find a zero in the given interval.\n\u003cp\u003e\nRequires that the values of the function at the endpoints have opposite\nsigns. An \u003ccode\u003eIllegalArgumentException\u003c/code\u003e is thrown if this is not\nthe case.\n\n@param min the lower bound for the interval.\n@param max the upper bound for the interval.\n@return the value where the function is zero\n@throws MaxIterationsExceededException if the maximum iteration count is exceeded\n@throws FunctionEvaluationException if an error occurs evaluating the\nfunction\n@throws IllegalArgumentException if min is not less than max or the\nsigns of the values of the function at the endpoints are not opposites\n"
          }
        }
      ]
    },
    "4f1e69b5313761cb95909359a408d13e6aa29635": {
      "type": "Ybodychange",
      "commitMessage": "Eliminated redundant endpoint function evaluations in BrentSolver, SecantSolver. BZ #35042.\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/math/trunk@179958 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "6/3/05, 10:36 PM",
      "commitName": "4f1e69b5313761cb95909359a408d13e6aa29635",
      "commitAuthor": "Phil Steitz",
      "commitDateOld": "2/26/05, 5:11 AM",
      "commitNameOld": "65b65f88b74de6b3462b04b2cf2a69f064a77557",
      "commitAuthorOld": "Dirk Verbeeck",
      "daysBetweenCommits": 97.68,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "actualSource": "public double solve(double min, double max) throws ConvergenceException, FunctionEvaluationException {\n    clearResult();\n    verifyInterval(min, max);\n    double x0 \u003d min;\n    double x1 \u003d max;\n    double y0;\n    double y1;\n    y0 \u003d f.value(x0);\n    y1 \u003d f.value(x1);\n    if (y0 * y1 \u003e\u003d 0) {\n        throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\" + \"  Endpoints: [\" + min + \",\" + max + \"]\" + \"  Values: [\" + y0 + \",\" + y1 + \"]\");\n    }\n    double x2 \u003d x0;\n    double y2 \u003d y0;\n    double delta \u003d x1 - x0;\n    double oldDelta \u003d delta;\n    int i \u003d 0;\n    while (i \u003c maximalIterationCount) {\n        if (Math.abs(y2) \u003c Math.abs(y1)) {\n            x0 \u003d x1;\n            x1 \u003d x2;\n            x2 \u003d x0;\n            y0 \u003d y1;\n            y1 \u003d y2;\n            y2 \u003d y0;\n        }\n        if (Math.abs(y1) \u003c\u003d functionValueAccuracy) {\n            setResult(x1, i);\n            return result;\n        }\n        double dx \u003d (x2 - x1);\n        double tolerance \u003d Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy);\n        if (Math.abs(dx) \u003c\u003d tolerance) {\n            setResult(x1, i);\n            return result;\n        }\n        if ((Math.abs(oldDelta) \u003c tolerance) || (Math.abs(y0) \u003c\u003d Math.abs(y1))) {\n            delta \u003d 0.5 * dx;\n            oldDelta \u003d delta;\n        } else {\n            double r3 \u003d y1 / y0;\n            double p;\n            double p1;\n            if (x0 \u003d\u003d x2) {\n                p \u003d dx * r3;\n                p1 \u003d 1.0 - r3;\n            } else {\n                double r1 \u003d y0 / y2;\n                double r2 \u003d y1 / y2;\n                p \u003d r3 * (dx * r1 * (r1 - r2) - (x1 - x0) * (r2 - 1.0));\n                p1 \u003d (r1 - 1.0) * (r2 - 1.0) * (r3 - 1.0);\n            }\n            if (p \u003e 0.0) {\n                p1 \u003d -p1;\n            } else {\n                p \u003d -p;\n            }\n            if (2.0 * p \u003e\u003d 1.5 * dx * p1 - Math.abs(tolerance * p1) || p \u003e\u003d Math.abs(0.5 * oldDelta * p1)) {\n                delta \u003d 0.5 * dx;\n                oldDelta \u003d delta;\n            } else {\n                oldDelta \u003d delta;\n                delta \u003d p / p1;\n            }\n        }\n        x0 \u003d x1;\n        y0 \u003d y1;\n        if (Math.abs(delta) \u003e tolerance) {\n            x1 \u003d x1 + delta;\n        } else if (dx \u003e 0.0) {\n            x1 \u003d x1 + 0.5 * tolerance;\n        } else if (dx \u003c\u003d 0.0) {\n            x1 \u003d x1 - 0.5 * tolerance;\n        }\n        y1 \u003d f.value(x1);\n        if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n            x2 \u003d x0;\n            y2 \u003d y0;\n            delta \u003d x1 - x0;\n            oldDelta \u003d delta;\n        }\n        i++;\n    }\n    throw new ConvergenceException(\"Maximum number of iterations exceeded.\");\n}",
      "path": "src/java/org/apache/commons/math/analysis/BrentSolver.java",
      "functionStartLine": 81,
      "functionName": "solve",
      "functionAnnotation": "",
      "functionDoc": "Find a zero in the given interval.\n\u003cp\u003e\nRequires that the values of the function at the endpoints have opposite\nsigns. An \u003ccode\u003eIllegalArgumentException\u003c/code\u003e is thrown if this is not\nthe case.\n\n@param min the lower bound for the interval.\n@param max the upper bound for the interval.\n@return the value where the function is zero\n@throws ConvergenceException if the maximum iteration count is exceeded\n@throws FunctionEvaluationException if an error occurs evaluating the\nfunction\n@throws IllegalArgumentException if min is not less than max or the\nsigns of the values of the function at the endpoints are not opposites\n",
      "diff": "@@ -1,82 +1,85 @@\n public double solve(double min, double max) throws ConvergenceException, FunctionEvaluationException {\n     clearResult();\n-    verifyBracketing(min, max, f);\n+    verifyInterval(min, max);\n     double x0 \u003d min;\n     double x1 \u003d max;\n     double y0;\n     double y1;\n     y0 \u003d f.value(x0);\n     y1 \u003d f.value(x1);\n+    if (y0 * y1 \u003e\u003d 0) {\n+        throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\" + \"  Endpoints: [\" + min + \",\" + max + \"]\" + \"  Values: [\" + y0 + \",\" + y1 + \"]\");\n+    }\n     double x2 \u003d x0;\n     double y2 \u003d y0;\n     double delta \u003d x1 - x0;\n     double oldDelta \u003d delta;\n     int i \u003d 0;\n     while (i \u003c maximalIterationCount) {\n         if (Math.abs(y2) \u003c Math.abs(y1)) {\n             x0 \u003d x1;\n             x1 \u003d x2;\n             x2 \u003d x0;\n             y0 \u003d y1;\n             y1 \u003d y2;\n             y2 \u003d y0;\n         }\n         if (Math.abs(y1) \u003c\u003d functionValueAccuracy) {\n             setResult(x1, i);\n             return result;\n         }\n         double dx \u003d (x2 - x1);\n         double tolerance \u003d Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy);\n         if (Math.abs(dx) \u003c\u003d tolerance) {\n             setResult(x1, i);\n             return result;\n         }\n         if ((Math.abs(oldDelta) \u003c tolerance) || (Math.abs(y0) \u003c\u003d Math.abs(y1))) {\n             delta \u003d 0.5 * dx;\n             oldDelta \u003d delta;\n         } else {\n             double r3 \u003d y1 / y0;\n             double p;\n             double p1;\n             if (x0 \u003d\u003d x2) {\n                 p \u003d dx * r3;\n                 p1 \u003d 1.0 - r3;\n             } else {\n                 double r1 \u003d y0 / y2;\n                 double r2 \u003d y1 / y2;\n                 p \u003d r3 * (dx * r1 * (r1 - r2) - (x1 - x0) * (r2 - 1.0));\n                 p1 \u003d (r1 - 1.0) * (r2 - 1.0) * (r3 - 1.0);\n             }\n             if (p \u003e 0.0) {\n                 p1 \u003d -p1;\n             } else {\n                 p \u003d -p;\n             }\n             if (2.0 * p \u003e\u003d 1.5 * dx * p1 - Math.abs(tolerance * p1) || p \u003e\u003d Math.abs(0.5 * oldDelta * p1)) {\n                 delta \u003d 0.5 * dx;\n                 oldDelta \u003d delta;\n             } else {\n                 oldDelta \u003d delta;\n                 delta \u003d p / p1;\n             }\n         }\n         x0 \u003d x1;\n         y0 \u003d y1;\n         if (Math.abs(delta) \u003e tolerance) {\n             x1 \u003d x1 + delta;\n         } else if (dx \u003e 0.0) {\n             x1 \u003d x1 + 0.5 * tolerance;\n         } else if (dx \u003c\u003d 0.0) {\n             x1 \u003d x1 - 0.5 * tolerance;\n         }\n         y1 \u003d f.value(x1);\n         if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n             x2 \u003d x0;\n             y2 \u003d y0;\n             delta \u003d x1 - x0;\n             oldDelta \u003d delta;\n         }\n         i++;\n     }\n     throw new ConvergenceException(\"Maximum number of iterations exceeded.\");\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6a978ea29f680a87dfc380c760adf2e17b2e7c9c": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange,Ydocchange)",
      "commitMessage": "-Changed UnivariateRealFunction.solve() to throw FunctionEvaluationException.\n-Changed UnivariateRealSolver.solve() to throw more specific exceptions:\n  ConvergenceException if max iterations is exceeded\n  IllegalArgumentException if endpoints do not (appear to) bracket a root\n  FunctionEvaluationException if an error occurs evaluating the function\n-Changed UnivariateRealSolver setters to throw IllegalArgumentException\n instead of MathException when input property values are out of range.\n-Changed AbstractContinuousDistribution.inverseCumulativeProbability to handle\n corner cases where solution equals domain lower or upper bound.\n-Improved javadoc.\n-Improved test coverage.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/math/trunk@141391 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "7/17/04, 2:19 PM",
      "commitName": "6a978ea29f680a87dfc380c760adf2e17b2e7c9c",
      "commitAuthor": "Phil Steitz",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "-Changed UnivariateRealFunction.solve() to throw FunctionEvaluationException.\n-Changed UnivariateRealSolver.solve() to throw more specific exceptions:\n  ConvergenceException if max iterations is exceeded\n  IllegalArgumentException if endpoints do not (appear to) bracket a root\n  FunctionEvaluationException if an error occurs evaluating the function\n-Changed UnivariateRealSolver setters to throw IllegalArgumentException\n instead of MathException when input property values are out of range.\n-Changed AbstractContinuousDistribution.inverseCumulativeProbability to handle\n corner cases where solution equals domain lower or upper bound.\n-Improved javadoc.\n-Improved test coverage.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/math/trunk@141391 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "7/17/04, 2:19 PM",
          "commitName": "6a978ea29f680a87dfc380c760adf2e17b2e7c9c",
          "commitAuthor": "Phil Steitz",
          "commitDateOld": "6/23/04, 9:26 AM",
          "commitNameOld": "7b22aec5529fb3bad1e8098938271398d13c92ba",
          "commitAuthorOld": "Brent Worden",
          "daysBetweenCommits": 24.2,
          "commitsBetweenForRepo": 60,
          "commitsBetweenForFile": 1,
          "actualSource": "public double solve(double min, double max) throws ConvergenceException, FunctionEvaluationException {\n    clearResult();\n    verifyBracketing(min, max, f);\n    double x0 \u003d min;\n    double x1 \u003d max;\n    double y0;\n    double y1;\n    y0 \u003d f.value(x0);\n    y1 \u003d f.value(x1);\n    double x2 \u003d x0;\n    double y2 \u003d y0;\n    double delta \u003d x1 - x0;\n    double oldDelta \u003d delta;\n    int i \u003d 0;\n    while (i \u003c maximalIterationCount) {\n        if (Math.abs(y2) \u003c Math.abs(y1)) {\n            x0 \u003d x1;\n            x1 \u003d x2;\n            x2 \u003d x0;\n            y0 \u003d y1;\n            y1 \u003d y2;\n            y2 \u003d y0;\n        }\n        if (Math.abs(y1) \u003c\u003d functionValueAccuracy) {\n            setResult(x1, i);\n            return result;\n        }\n        double dx \u003d (x2 - x1);\n        double tolerance \u003d Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy);\n        if (Math.abs(dx) \u003c\u003d tolerance) {\n            setResult(x1, i);\n            return result;\n        }\n        if ((Math.abs(oldDelta) \u003c tolerance) || (Math.abs(y0) \u003c\u003d Math.abs(y1))) {\n            delta \u003d 0.5 * dx;\n            oldDelta \u003d delta;\n        } else {\n            double r3 \u003d y1 / y0;\n            double p;\n            double p1;\n            if (x0 \u003d\u003d x2) {\n                p \u003d dx * r3;\n                p1 \u003d 1.0 - r3;\n            } else {\n                double r1 \u003d y0 / y2;\n                double r2 \u003d y1 / y2;\n                p \u003d r3 * (dx * r1 * (r1 - r2) - (x1 - x0) * (r2 - 1.0));\n                p1 \u003d (r1 - 1.0) * (r2 - 1.0) * (r3 - 1.0);\n            }\n            if (p \u003e 0.0) {\n                p1 \u003d -p1;\n            } else {\n                p \u003d -p;\n            }\n            if (2.0 * p \u003e\u003d 1.5 * dx * p1 - Math.abs(tolerance * p1) || p \u003e\u003d Math.abs(0.5 * oldDelta * p1)) {\n                delta \u003d 0.5 * dx;\n                oldDelta \u003d delta;\n            } else {\n                oldDelta \u003d delta;\n                delta \u003d p / p1;\n            }\n        }\n        x0 \u003d x1;\n        y0 \u003d y1;\n        if (Math.abs(delta) \u003e tolerance) {\n            x1 \u003d x1 + delta;\n        } else if (dx \u003e 0.0) {\n            x1 \u003d x1 + 0.5 * tolerance;\n        } else if (dx \u003c\u003d 0.0) {\n            x1 \u003d x1 - 0.5 * tolerance;\n        }\n        y1 \u003d f.value(x1);\n        if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n            x2 \u003d x0;\n            y2 \u003d y0;\n            delta \u003d x1 - x0;\n            oldDelta \u003d delta;\n        }\n        i++;\n    }\n    throw new ConvergenceException(\"Maximum number of iterations exceeded.\");\n}",
          "path": "src/java/org/apache/commons/math/analysis/BrentSolver.java",
          "functionStartLine": 82,
          "functionName": "solve",
          "functionAnnotation": "",
          "functionDoc": "Find a zero in the given interval.\n\u003cp\u003e\nRequires that the values of the function at the endpoints have opposite\nsigns. An \u003ccode\u003eIllegalArgumentException\u003c/code\u003e is thrown if this is not\nthe case.\n\n@param min the lower bound for the interval.\n@param max the upper bound for the interval.\n@return the value where the function is zero\n@throws ConvergenceException if the maximum iteration count is exceeded\n@throws FunctionEvaluationException if an error occurs evaluating the\nfunction\n@throws IllegalArgumentException if min is not less than max or the\nsigns of the values of the function at the endpoints are not opposites\n",
          "diff": "@@ -1,82 +1,82 @@\n-public double solve(double min, double max) throws MathException {\n+public double solve(double min, double max) throws ConvergenceException, FunctionEvaluationException {\n     clearResult();\n+    verifyBracketing(min, max, f);\n     double x0 \u003d min;\n     double x1 \u003d max;\n-    double y0 \u003d f.value(x0);\n-    double y1 \u003d f.value(x1);\n-    if ((y0 \u003e 0) \u003d\u003d (y1 \u003e 0)) {\n-        throw new MathException(\"Interval doesn\u0027t bracket a zero.\");\n-    }\n+    double y0;\n+    double y1;\n+    y0 \u003d f.value(x0);\n+    y1 \u003d f.value(x1);\n     double x2 \u003d x0;\n     double y2 \u003d y0;\n     double delta \u003d x1 - x0;\n     double oldDelta \u003d delta;\n     int i \u003d 0;\n     while (i \u003c maximalIterationCount) {\n         if (Math.abs(y2) \u003c Math.abs(y1)) {\n             x0 \u003d x1;\n             x1 \u003d x2;\n             x2 \u003d x0;\n             y0 \u003d y1;\n             y1 \u003d y2;\n             y2 \u003d y0;\n         }\n         if (Math.abs(y1) \u003c\u003d functionValueAccuracy) {\n             setResult(x1, i);\n             return result;\n         }\n         double dx \u003d (x2 - x1);\n         double tolerance \u003d Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy);\n         if (Math.abs(dx) \u003c\u003d tolerance) {\n             setResult(x1, i);\n             return result;\n         }\n         if ((Math.abs(oldDelta) \u003c tolerance) || (Math.abs(y0) \u003c\u003d Math.abs(y1))) {\n             delta \u003d 0.5 * dx;\n             oldDelta \u003d delta;\n         } else {\n             double r3 \u003d y1 / y0;\n             double p;\n             double p1;\n             if (x0 \u003d\u003d x2) {\n                 p \u003d dx * r3;\n                 p1 \u003d 1.0 - r3;\n             } else {\n                 double r1 \u003d y0 / y2;\n                 double r2 \u003d y1 / y2;\n                 p \u003d r3 * (dx * r1 * (r1 - r2) - (x1 - x0) * (r2 - 1.0));\n                 p1 \u003d (r1 - 1.0) * (r2 - 1.0) * (r3 - 1.0);\n             }\n             if (p \u003e 0.0) {\n                 p1 \u003d -p1;\n             } else {\n                 p \u003d -p;\n             }\n             if (2.0 * p \u003e\u003d 1.5 * dx * p1 - Math.abs(tolerance * p1) || p \u003e\u003d Math.abs(0.5 * oldDelta * p1)) {\n                 delta \u003d 0.5 * dx;\n                 oldDelta \u003d delta;\n             } else {\n                 oldDelta \u003d delta;\n                 delta \u003d p / p1;\n             }\n         }\n         x0 \u003d x1;\n         y0 \u003d y1;\n         if (Math.abs(delta) \u003e tolerance) {\n             x1 \u003d x1 + delta;\n         } else if (dx \u003e 0.0) {\n             x1 \u003d x1 + 0.5 * tolerance;\n         } else if (dx \u003c\u003d 0.0) {\n             x1 \u003d x1 - 0.5 * tolerance;\n         }\n         y1 \u003d f.value(x1);\n         if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n             x2 \u003d x0;\n             y2 \u003d y0;\n             delta \u003d x1 - x0;\n             oldDelta \u003d delta;\n         }\n         i++;\n     }\n-    throw new MathException(\"Maximum number of iterations exceeded.\");\n+    throw new ConvergenceException(\"Maximum number of iterations exceeded.\");\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[MathException]",
            "newValue": "[ConvergenceException, FunctionEvaluationException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "-Changed UnivariateRealFunction.solve() to throw FunctionEvaluationException.\n-Changed UnivariateRealSolver.solve() to throw more specific exceptions:\n  ConvergenceException if max iterations is exceeded\n  IllegalArgumentException if endpoints do not (appear to) bracket a root\n  FunctionEvaluationException if an error occurs evaluating the function\n-Changed UnivariateRealSolver setters to throw IllegalArgumentException\n instead of MathException when input property values are out of range.\n-Changed AbstractContinuousDistribution.inverseCumulativeProbability to handle\n corner cases where solution equals domain lower or upper bound.\n-Improved javadoc.\n-Improved test coverage.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/math/trunk@141391 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "7/17/04, 2:19 PM",
          "commitName": "6a978ea29f680a87dfc380c760adf2e17b2e7c9c",
          "commitAuthor": "Phil Steitz",
          "commitDateOld": "6/23/04, 9:26 AM",
          "commitNameOld": "7b22aec5529fb3bad1e8098938271398d13c92ba",
          "commitAuthorOld": "Brent Worden",
          "daysBetweenCommits": 24.2,
          "commitsBetweenForRepo": 60,
          "commitsBetweenForFile": 1,
          "actualSource": "public double solve(double min, double max) throws ConvergenceException, FunctionEvaluationException {\n    clearResult();\n    verifyBracketing(min, max, f);\n    double x0 \u003d min;\n    double x1 \u003d max;\n    double y0;\n    double y1;\n    y0 \u003d f.value(x0);\n    y1 \u003d f.value(x1);\n    double x2 \u003d x0;\n    double y2 \u003d y0;\n    double delta \u003d x1 - x0;\n    double oldDelta \u003d delta;\n    int i \u003d 0;\n    while (i \u003c maximalIterationCount) {\n        if (Math.abs(y2) \u003c Math.abs(y1)) {\n            x0 \u003d x1;\n            x1 \u003d x2;\n            x2 \u003d x0;\n            y0 \u003d y1;\n            y1 \u003d y2;\n            y2 \u003d y0;\n        }\n        if (Math.abs(y1) \u003c\u003d functionValueAccuracy) {\n            setResult(x1, i);\n            return result;\n        }\n        double dx \u003d (x2 - x1);\n        double tolerance \u003d Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy);\n        if (Math.abs(dx) \u003c\u003d tolerance) {\n            setResult(x1, i);\n            return result;\n        }\n        if ((Math.abs(oldDelta) \u003c tolerance) || (Math.abs(y0) \u003c\u003d Math.abs(y1))) {\n            delta \u003d 0.5 * dx;\n            oldDelta \u003d delta;\n        } else {\n            double r3 \u003d y1 / y0;\n            double p;\n            double p1;\n            if (x0 \u003d\u003d x2) {\n                p \u003d dx * r3;\n                p1 \u003d 1.0 - r3;\n            } else {\n                double r1 \u003d y0 / y2;\n                double r2 \u003d y1 / y2;\n                p \u003d r3 * (dx * r1 * (r1 - r2) - (x1 - x0) * (r2 - 1.0));\n                p1 \u003d (r1 - 1.0) * (r2 - 1.0) * (r3 - 1.0);\n            }\n            if (p \u003e 0.0) {\n                p1 \u003d -p1;\n            } else {\n                p \u003d -p;\n            }\n            if (2.0 * p \u003e\u003d 1.5 * dx * p1 - Math.abs(tolerance * p1) || p \u003e\u003d Math.abs(0.5 * oldDelta * p1)) {\n                delta \u003d 0.5 * dx;\n                oldDelta \u003d delta;\n            } else {\n                oldDelta \u003d delta;\n                delta \u003d p / p1;\n            }\n        }\n        x0 \u003d x1;\n        y0 \u003d y1;\n        if (Math.abs(delta) \u003e tolerance) {\n            x1 \u003d x1 + delta;\n        } else if (dx \u003e 0.0) {\n            x1 \u003d x1 + 0.5 * tolerance;\n        } else if (dx \u003c\u003d 0.0) {\n            x1 \u003d x1 - 0.5 * tolerance;\n        }\n        y1 \u003d f.value(x1);\n        if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n            x2 \u003d x0;\n            y2 \u003d y0;\n            delta \u003d x1 - x0;\n            oldDelta \u003d delta;\n        }\n        i++;\n    }\n    throw new ConvergenceException(\"Maximum number of iterations exceeded.\");\n}",
          "path": "src/java/org/apache/commons/math/analysis/BrentSolver.java",
          "functionStartLine": 82,
          "functionName": "solve",
          "functionAnnotation": "",
          "functionDoc": "Find a zero in the given interval.\n\u003cp\u003e\nRequires that the values of the function at the endpoints have opposite\nsigns. An \u003ccode\u003eIllegalArgumentException\u003c/code\u003e is thrown if this is not\nthe case.\n\n@param min the lower bound for the interval.\n@param max the upper bound for the interval.\n@return the value where the function is zero\n@throws ConvergenceException if the maximum iteration count is exceeded\n@throws FunctionEvaluationException if an error occurs evaluating the\nfunction\n@throws IllegalArgumentException if min is not less than max or the\nsigns of the values of the function at the endpoints are not opposites\n",
          "diff": "@@ -1,82 +1,82 @@\n-public double solve(double min, double max) throws MathException {\n+public double solve(double min, double max) throws ConvergenceException, FunctionEvaluationException {\n     clearResult();\n+    verifyBracketing(min, max, f);\n     double x0 \u003d min;\n     double x1 \u003d max;\n-    double y0 \u003d f.value(x0);\n-    double y1 \u003d f.value(x1);\n-    if ((y0 \u003e 0) \u003d\u003d (y1 \u003e 0)) {\n-        throw new MathException(\"Interval doesn\u0027t bracket a zero.\");\n-    }\n+    double y0;\n+    double y1;\n+    y0 \u003d f.value(x0);\n+    y1 \u003d f.value(x1);\n     double x2 \u003d x0;\n     double y2 \u003d y0;\n     double delta \u003d x1 - x0;\n     double oldDelta \u003d delta;\n     int i \u003d 0;\n     while (i \u003c maximalIterationCount) {\n         if (Math.abs(y2) \u003c Math.abs(y1)) {\n             x0 \u003d x1;\n             x1 \u003d x2;\n             x2 \u003d x0;\n             y0 \u003d y1;\n             y1 \u003d y2;\n             y2 \u003d y0;\n         }\n         if (Math.abs(y1) \u003c\u003d functionValueAccuracy) {\n             setResult(x1, i);\n             return result;\n         }\n         double dx \u003d (x2 - x1);\n         double tolerance \u003d Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy);\n         if (Math.abs(dx) \u003c\u003d tolerance) {\n             setResult(x1, i);\n             return result;\n         }\n         if ((Math.abs(oldDelta) \u003c tolerance) || (Math.abs(y0) \u003c\u003d Math.abs(y1))) {\n             delta \u003d 0.5 * dx;\n             oldDelta \u003d delta;\n         } else {\n             double r3 \u003d y1 / y0;\n             double p;\n             double p1;\n             if (x0 \u003d\u003d x2) {\n                 p \u003d dx * r3;\n                 p1 \u003d 1.0 - r3;\n             } else {\n                 double r1 \u003d y0 / y2;\n                 double r2 \u003d y1 / y2;\n                 p \u003d r3 * (dx * r1 * (r1 - r2) - (x1 - x0) * (r2 - 1.0));\n                 p1 \u003d (r1 - 1.0) * (r2 - 1.0) * (r3 - 1.0);\n             }\n             if (p \u003e 0.0) {\n                 p1 \u003d -p1;\n             } else {\n                 p \u003d -p;\n             }\n             if (2.0 * p \u003e\u003d 1.5 * dx * p1 - Math.abs(tolerance * p1) || p \u003e\u003d Math.abs(0.5 * oldDelta * p1)) {\n                 delta \u003d 0.5 * dx;\n                 oldDelta \u003d delta;\n             } else {\n                 oldDelta \u003d delta;\n                 delta \u003d p / p1;\n             }\n         }\n         x0 \u003d x1;\n         y0 \u003d y1;\n         if (Math.abs(delta) \u003e tolerance) {\n             x1 \u003d x1 + delta;\n         } else if (dx \u003e 0.0) {\n             x1 \u003d x1 + 0.5 * tolerance;\n         } else if (dx \u003c\u003d 0.0) {\n             x1 \u003d x1 - 0.5 * tolerance;\n         }\n         y1 \u003d f.value(x1);\n         if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n             x2 \u003d x0;\n             y2 \u003d y0;\n             delta \u003d x1 - x0;\n             oldDelta \u003d delta;\n         }\n         i++;\n     }\n-    throw new MathException(\"Maximum number of iterations exceeded.\");\n+    throw new ConvergenceException(\"Maximum number of iterations exceeded.\");\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "-Changed UnivariateRealFunction.solve() to throw FunctionEvaluationException.\n-Changed UnivariateRealSolver.solve() to throw more specific exceptions:\n  ConvergenceException if max iterations is exceeded\n  IllegalArgumentException if endpoints do not (appear to) bracket a root\n  FunctionEvaluationException if an error occurs evaluating the function\n-Changed UnivariateRealSolver setters to throw IllegalArgumentException\n instead of MathException when input property values are out of range.\n-Changed AbstractContinuousDistribution.inverseCumulativeProbability to handle\n corner cases where solution equals domain lower or upper bound.\n-Improved javadoc.\n-Improved test coverage.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/math/trunk@141391 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "7/17/04, 2:19 PM",
          "commitName": "6a978ea29f680a87dfc380c760adf2e17b2e7c9c",
          "commitAuthor": "Phil Steitz",
          "commitDateOld": "6/23/04, 9:26 AM",
          "commitNameOld": "7b22aec5529fb3bad1e8098938271398d13c92ba",
          "commitAuthorOld": "Brent Worden",
          "daysBetweenCommits": 24.2,
          "commitsBetweenForRepo": 60,
          "commitsBetweenForFile": 1,
          "actualSource": "public double solve(double min, double max) throws ConvergenceException, FunctionEvaluationException {\n    clearResult();\n    verifyBracketing(min, max, f);\n    double x0 \u003d min;\n    double x1 \u003d max;\n    double y0;\n    double y1;\n    y0 \u003d f.value(x0);\n    y1 \u003d f.value(x1);\n    double x2 \u003d x0;\n    double y2 \u003d y0;\n    double delta \u003d x1 - x0;\n    double oldDelta \u003d delta;\n    int i \u003d 0;\n    while (i \u003c maximalIterationCount) {\n        if (Math.abs(y2) \u003c Math.abs(y1)) {\n            x0 \u003d x1;\n            x1 \u003d x2;\n            x2 \u003d x0;\n            y0 \u003d y1;\n            y1 \u003d y2;\n            y2 \u003d y0;\n        }\n        if (Math.abs(y1) \u003c\u003d functionValueAccuracy) {\n            setResult(x1, i);\n            return result;\n        }\n        double dx \u003d (x2 - x1);\n        double tolerance \u003d Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy);\n        if (Math.abs(dx) \u003c\u003d tolerance) {\n            setResult(x1, i);\n            return result;\n        }\n        if ((Math.abs(oldDelta) \u003c tolerance) || (Math.abs(y0) \u003c\u003d Math.abs(y1))) {\n            delta \u003d 0.5 * dx;\n            oldDelta \u003d delta;\n        } else {\n            double r3 \u003d y1 / y0;\n            double p;\n            double p1;\n            if (x0 \u003d\u003d x2) {\n                p \u003d dx * r3;\n                p1 \u003d 1.0 - r3;\n            } else {\n                double r1 \u003d y0 / y2;\n                double r2 \u003d y1 / y2;\n                p \u003d r3 * (dx * r1 * (r1 - r2) - (x1 - x0) * (r2 - 1.0));\n                p1 \u003d (r1 - 1.0) * (r2 - 1.0) * (r3 - 1.0);\n            }\n            if (p \u003e 0.0) {\n                p1 \u003d -p1;\n            } else {\n                p \u003d -p;\n            }\n            if (2.0 * p \u003e\u003d 1.5 * dx * p1 - Math.abs(tolerance * p1) || p \u003e\u003d Math.abs(0.5 * oldDelta * p1)) {\n                delta \u003d 0.5 * dx;\n                oldDelta \u003d delta;\n            } else {\n                oldDelta \u003d delta;\n                delta \u003d p / p1;\n            }\n        }\n        x0 \u003d x1;\n        y0 \u003d y1;\n        if (Math.abs(delta) \u003e tolerance) {\n            x1 \u003d x1 + delta;\n        } else if (dx \u003e 0.0) {\n            x1 \u003d x1 + 0.5 * tolerance;\n        } else if (dx \u003c\u003d 0.0) {\n            x1 \u003d x1 - 0.5 * tolerance;\n        }\n        y1 \u003d f.value(x1);\n        if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n            x2 \u003d x0;\n            y2 \u003d y0;\n            delta \u003d x1 - x0;\n            oldDelta \u003d delta;\n        }\n        i++;\n    }\n    throw new ConvergenceException(\"Maximum number of iterations exceeded.\");\n}",
          "path": "src/java/org/apache/commons/math/analysis/BrentSolver.java",
          "functionStartLine": 82,
          "functionName": "solve",
          "functionAnnotation": "",
          "functionDoc": "Find a zero in the given interval.\n\u003cp\u003e\nRequires that the values of the function at the endpoints have opposite\nsigns. An \u003ccode\u003eIllegalArgumentException\u003c/code\u003e is thrown if this is not\nthe case.\n\n@param min the lower bound for the interval.\n@param max the upper bound for the interval.\n@return the value where the function is zero\n@throws ConvergenceException if the maximum iteration count is exceeded\n@throws FunctionEvaluationException if an error occurs evaluating the\nfunction\n@throws IllegalArgumentException if min is not less than max or the\nsigns of the values of the function at the endpoints are not opposites\n",
          "diff": "@@ -1,82 +1,82 @@\n-public double solve(double min, double max) throws MathException {\n+public double solve(double min, double max) throws ConvergenceException, FunctionEvaluationException {\n     clearResult();\n+    verifyBracketing(min, max, f);\n     double x0 \u003d min;\n     double x1 \u003d max;\n-    double y0 \u003d f.value(x0);\n-    double y1 \u003d f.value(x1);\n-    if ((y0 \u003e 0) \u003d\u003d (y1 \u003e 0)) {\n-        throw new MathException(\"Interval doesn\u0027t bracket a zero.\");\n-    }\n+    double y0;\n+    double y1;\n+    y0 \u003d f.value(x0);\n+    y1 \u003d f.value(x1);\n     double x2 \u003d x0;\n     double y2 \u003d y0;\n     double delta \u003d x1 - x0;\n     double oldDelta \u003d delta;\n     int i \u003d 0;\n     while (i \u003c maximalIterationCount) {\n         if (Math.abs(y2) \u003c Math.abs(y1)) {\n             x0 \u003d x1;\n             x1 \u003d x2;\n             x2 \u003d x0;\n             y0 \u003d y1;\n             y1 \u003d y2;\n             y2 \u003d y0;\n         }\n         if (Math.abs(y1) \u003c\u003d functionValueAccuracy) {\n             setResult(x1, i);\n             return result;\n         }\n         double dx \u003d (x2 - x1);\n         double tolerance \u003d Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy);\n         if (Math.abs(dx) \u003c\u003d tolerance) {\n             setResult(x1, i);\n             return result;\n         }\n         if ((Math.abs(oldDelta) \u003c tolerance) || (Math.abs(y0) \u003c\u003d Math.abs(y1))) {\n             delta \u003d 0.5 * dx;\n             oldDelta \u003d delta;\n         } else {\n             double r3 \u003d y1 / y0;\n             double p;\n             double p1;\n             if (x0 \u003d\u003d x2) {\n                 p \u003d dx * r3;\n                 p1 \u003d 1.0 - r3;\n             } else {\n                 double r1 \u003d y0 / y2;\n                 double r2 \u003d y1 / y2;\n                 p \u003d r3 * (dx * r1 * (r1 - r2) - (x1 - x0) * (r2 - 1.0));\n                 p1 \u003d (r1 - 1.0) * (r2 - 1.0) * (r3 - 1.0);\n             }\n             if (p \u003e 0.0) {\n                 p1 \u003d -p1;\n             } else {\n                 p \u003d -p;\n             }\n             if (2.0 * p \u003e\u003d 1.5 * dx * p1 - Math.abs(tolerance * p1) || p \u003e\u003d Math.abs(0.5 * oldDelta * p1)) {\n                 delta \u003d 0.5 * dx;\n                 oldDelta \u003d delta;\n             } else {\n                 oldDelta \u003d delta;\n                 delta \u003d p / p1;\n             }\n         }\n         x0 \u003d x1;\n         y0 \u003d y1;\n         if (Math.abs(delta) \u003e tolerance) {\n             x1 \u003d x1 + delta;\n         } else if (dx \u003e 0.0) {\n             x1 \u003d x1 + 0.5 * tolerance;\n         } else if (dx \u003c\u003d 0.0) {\n             x1 \u003d x1 - 0.5 * tolerance;\n         }\n         y1 \u003d f.value(x1);\n         if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n             x2 \u003d x0;\n             y2 \u003d y0;\n             delta \u003d x1 - x0;\n             oldDelta \u003d delta;\n         }\n         i++;\n     }\n-    throw new MathException(\"Maximum number of iterations exceeded.\");\n+    throw new ConvergenceException(\"Maximum number of iterations exceeded.\");\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Find a zero in the given interval.\n\n@param min the lower bound for the interval.\n@param max the upper bound for the interval.\n@return the value where the function is zero\n@throws MathException if the iteration count was exceeded or the\n solver detects convergence problems otherwise.\n",
            "newValue": "Find a zero in the given interval.\n\u003cp\u003e\nRequires that the values of the function at the endpoints have opposite\nsigns. An \u003ccode\u003eIllegalArgumentException\u003c/code\u003e is thrown if this is not\nthe case.\n\n@param min the lower bound for the interval.\n@param max the upper bound for the interval.\n@return the value where the function is zero\n@throws ConvergenceException if the maximum iteration count is exceeded\n@throws FunctionEvaluationException if an error occurs evaluating the\nfunction\n@throws IllegalArgumentException if min is not less than max or the\nsigns of the values of the function at the endpoints are not opposites\n"
          }
        }
      ]
    },
    "2d69367fab142b626ce36d418272f99ad8fc3dc1": {
      "type": "Ymultichange(Ybodychange,Ydocchange)",
      "commitMessage": "javadoc, error message cleanup.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/math/trunk@141103 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2/19/04, 10:22 PM",
      "commitName": "2d69367fab142b626ce36d418272f99ad8fc3dc1",
      "commitAuthor": "Phil Steitz",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "javadoc, error message cleanup.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/math/trunk@141103 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2/19/04, 10:22 PM",
          "commitName": "2d69367fab142b626ce36d418272f99ad8fc3dc1",
          "commitAuthor": "Phil Steitz",
          "commitDateOld": "2/17/04, 7:24 PM",
          "commitNameOld": "4dae458d8dd9dd4dfc09302a8d4f6a914420da54",
          "commitAuthorOld": "Phil Steitz",
          "daysBetweenCommits": 2.12,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "actualSource": "public double solve(double min, double max) throws MathException {\n    clearResult();\n    double x0 \u003d min;\n    double x1 \u003d max;\n    double y0 \u003d f.value(x0);\n    double y1 \u003d f.value(x1);\n    if ((y0 \u003e 0) \u003d\u003d (y1 \u003e 0)) {\n        throw new MathException(\"Interval doesn\u0027t bracket a zero.\");\n    }\n    double x2 \u003d x0;\n    double y2 \u003d y0;\n    double delta \u003d x1 - x0;\n    double oldDelta \u003d delta;\n    int i \u003d 0;\n    while (i \u003c maximalIterationCount) {\n        if (Math.abs(y2) \u003c Math.abs(y1)) {\n            x0 \u003d x1;\n            x1 \u003d x2;\n            x2 \u003d x0;\n            y0 \u003d y1;\n            y1 \u003d y2;\n            y2 \u003d y0;\n        }\n        if (Math.abs(y1) \u003c\u003d functionValueAccuracy) {\n            setResult(x1, i);\n            return result;\n        }\n        double dx \u003d (x2 - x1);\n        double tolerance \u003d Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy);\n        if (Math.abs(dx) \u003c\u003d tolerance) {\n            setResult(x1, i);\n            return result;\n        }\n        if ((Math.abs(oldDelta) \u003c tolerance) || (Math.abs(y0) \u003c\u003d Math.abs(y1))) {\n            delta \u003d 0.5 * dx;\n            oldDelta \u003d delta;\n        } else {\n            double r3 \u003d y1 / y0;\n            double p;\n            double p1;\n            if (x0 \u003d\u003d x2) {\n                p \u003d dx * r3;\n                p1 \u003d 1.0 - r3;\n            } else {\n                double r1 \u003d y0 / y2;\n                double r2 \u003d y1 / y2;\n                p \u003d r3 * (dx * r1 * (r1 - r2) - (x1 - x0) * (r2 - 1.0));\n                p1 \u003d (r1 - 1.0) * (r2 - 1.0) * (r3 - 1.0);\n            }\n            if (p \u003e 0.0) {\n                p1 \u003d -p1;\n            } else {\n                p \u003d -p;\n            }\n            if (2.0 * p \u003e\u003d 1.5 * dx * p1 - Math.abs(tolerance * p1) || p \u003e\u003d Math.abs(0.5 * oldDelta * p1)) {\n                delta \u003d 0.5 * dx;\n                oldDelta \u003d delta;\n            } else {\n                oldDelta \u003d delta;\n                delta \u003d p / p1;\n            }\n        }\n        x0 \u003d x1;\n        y0 \u003d y1;\n        if (Math.abs(delta) \u003e tolerance) {\n            x1 \u003d x1 + delta;\n        } else if (dx \u003e 0.0) {\n            x1 \u003d x1 + 0.5 * tolerance;\n        } else if (dx \u003c\u003d 0.0) {\n            x1 \u003d x1 - 0.5 * tolerance;\n        }\n        y1 \u003d f.value(x1);\n        if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n            x2 \u003d x0;\n            y2 \u003d y0;\n            delta \u003d x1 - x0;\n            oldDelta \u003d delta;\n        }\n        i++;\n    }\n    throw new MathException(\"Maximum number of iterations exceeded.\");\n}",
          "path": "src/java/org/apache/commons/math/analysis/BrentSolver.java",
          "functionStartLine": 64,
          "functionName": "solve",
          "functionAnnotation": "",
          "functionDoc": "Find a zero in the given interval.\n\n@param min the lower bound for the interval.\n@param max the upper bound for the interval.\n@return the value where the function is zero\n@throws MathException if the iteration count was exceeded or the\n solver detects convergence problems otherwise.\n",
          "diff": "@@ -1,82 +1,82 @@\n public double solve(double min, double max) throws MathException {\n     clearResult();\n     double x0 \u003d min;\n     double x1 \u003d max;\n     double y0 \u003d f.value(x0);\n     double y1 \u003d f.value(x1);\n     if ((y0 \u003e 0) \u003d\u003d (y1 \u003e 0)) {\n         throw new MathException(\"Interval doesn\u0027t bracket a zero.\");\n     }\n     double x2 \u003d x0;\n     double y2 \u003d y0;\n     double delta \u003d x1 - x0;\n     double oldDelta \u003d delta;\n     int i \u003d 0;\n     while (i \u003c maximalIterationCount) {\n         if (Math.abs(y2) \u003c Math.abs(y1)) {\n             x0 \u003d x1;\n             x1 \u003d x2;\n             x2 \u003d x0;\n             y0 \u003d y1;\n             y1 \u003d y2;\n             y2 \u003d y0;\n         }\n         if (Math.abs(y1) \u003c\u003d functionValueAccuracy) {\n             setResult(x1, i);\n             return result;\n         }\n         double dx \u003d (x2 - x1);\n         double tolerance \u003d Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy);\n         if (Math.abs(dx) \u003c\u003d tolerance) {\n             setResult(x1, i);\n             return result;\n         }\n         if ((Math.abs(oldDelta) \u003c tolerance) || (Math.abs(y0) \u003c\u003d Math.abs(y1))) {\n             delta \u003d 0.5 * dx;\n             oldDelta \u003d delta;\n         } else {\n             double r3 \u003d y1 / y0;\n             double p;\n             double p1;\n             if (x0 \u003d\u003d x2) {\n                 p \u003d dx * r3;\n                 p1 \u003d 1.0 - r3;\n             } else {\n                 double r1 \u003d y0 / y2;\n                 double r2 \u003d y1 / y2;\n                 p \u003d r3 * (dx * r1 * (r1 - r2) - (x1 - x0) * (r2 - 1.0));\n                 p1 \u003d (r1 - 1.0) * (r2 - 1.0) * (r3 - 1.0);\n             }\n             if (p \u003e 0.0) {\n                 p1 \u003d -p1;\n             } else {\n                 p \u003d -p;\n             }\n             if (2.0 * p \u003e\u003d 1.5 * dx * p1 - Math.abs(tolerance * p1) || p \u003e\u003d Math.abs(0.5 * oldDelta * p1)) {\n                 delta \u003d 0.5 * dx;\n                 oldDelta \u003d delta;\n             } else {\n                 oldDelta \u003d delta;\n                 delta \u003d p / p1;\n             }\n         }\n         x0 \u003d x1;\n         y0 \u003d y1;\n         if (Math.abs(delta) \u003e tolerance) {\n             x1 \u003d x1 + delta;\n         } else if (dx \u003e 0.0) {\n             x1 \u003d x1 + 0.5 * tolerance;\n         } else if (dx \u003c\u003d 0.0) {\n             x1 \u003d x1 - 0.5 * tolerance;\n         }\n         y1 \u003d f.value(x1);\n         if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n             x2 \u003d x0;\n             y2 \u003d y0;\n             delta \u003d x1 - x0;\n             oldDelta \u003d delta;\n         }\n         i++;\n     }\n-    throw new MathException(\"Maximal iteration number exceeded.\");\n+    throw new MathException(\"Maximum number of iterations exceeded.\");\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "javadoc, error message cleanup.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/math/trunk@141103 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2/19/04, 10:22 PM",
          "commitName": "2d69367fab142b626ce36d418272f99ad8fc3dc1",
          "commitAuthor": "Phil Steitz",
          "commitDateOld": "2/17/04, 7:24 PM",
          "commitNameOld": "4dae458d8dd9dd4dfc09302a8d4f6a914420da54",
          "commitAuthorOld": "Phil Steitz",
          "daysBetweenCommits": 2.12,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "actualSource": "public double solve(double min, double max) throws MathException {\n    clearResult();\n    double x0 \u003d min;\n    double x1 \u003d max;\n    double y0 \u003d f.value(x0);\n    double y1 \u003d f.value(x1);\n    if ((y0 \u003e 0) \u003d\u003d (y1 \u003e 0)) {\n        throw new MathException(\"Interval doesn\u0027t bracket a zero.\");\n    }\n    double x2 \u003d x0;\n    double y2 \u003d y0;\n    double delta \u003d x1 - x0;\n    double oldDelta \u003d delta;\n    int i \u003d 0;\n    while (i \u003c maximalIterationCount) {\n        if (Math.abs(y2) \u003c Math.abs(y1)) {\n            x0 \u003d x1;\n            x1 \u003d x2;\n            x2 \u003d x0;\n            y0 \u003d y1;\n            y1 \u003d y2;\n            y2 \u003d y0;\n        }\n        if (Math.abs(y1) \u003c\u003d functionValueAccuracy) {\n            setResult(x1, i);\n            return result;\n        }\n        double dx \u003d (x2 - x1);\n        double tolerance \u003d Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy);\n        if (Math.abs(dx) \u003c\u003d tolerance) {\n            setResult(x1, i);\n            return result;\n        }\n        if ((Math.abs(oldDelta) \u003c tolerance) || (Math.abs(y0) \u003c\u003d Math.abs(y1))) {\n            delta \u003d 0.5 * dx;\n            oldDelta \u003d delta;\n        } else {\n            double r3 \u003d y1 / y0;\n            double p;\n            double p1;\n            if (x0 \u003d\u003d x2) {\n                p \u003d dx * r3;\n                p1 \u003d 1.0 - r3;\n            } else {\n                double r1 \u003d y0 / y2;\n                double r2 \u003d y1 / y2;\n                p \u003d r3 * (dx * r1 * (r1 - r2) - (x1 - x0) * (r2 - 1.0));\n                p1 \u003d (r1 - 1.0) * (r2 - 1.0) * (r3 - 1.0);\n            }\n            if (p \u003e 0.0) {\n                p1 \u003d -p1;\n            } else {\n                p \u003d -p;\n            }\n            if (2.0 * p \u003e\u003d 1.5 * dx * p1 - Math.abs(tolerance * p1) || p \u003e\u003d Math.abs(0.5 * oldDelta * p1)) {\n                delta \u003d 0.5 * dx;\n                oldDelta \u003d delta;\n            } else {\n                oldDelta \u003d delta;\n                delta \u003d p / p1;\n            }\n        }\n        x0 \u003d x1;\n        y0 \u003d y1;\n        if (Math.abs(delta) \u003e tolerance) {\n            x1 \u003d x1 + delta;\n        } else if (dx \u003e 0.0) {\n            x1 \u003d x1 + 0.5 * tolerance;\n        } else if (dx \u003c\u003d 0.0) {\n            x1 \u003d x1 - 0.5 * tolerance;\n        }\n        y1 \u003d f.value(x1);\n        if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n            x2 \u003d x0;\n            y2 \u003d y0;\n            delta \u003d x1 - x0;\n            oldDelta \u003d delta;\n        }\n        i++;\n    }\n    throw new MathException(\"Maximum number of iterations exceeded.\");\n}",
          "path": "src/java/org/apache/commons/math/analysis/BrentSolver.java",
          "functionStartLine": 64,
          "functionName": "solve",
          "functionAnnotation": "",
          "functionDoc": "Find a zero in the given interval.\n\n@param min the lower bound for the interval.\n@param max the upper bound for the interval.\n@return the value where the function is zero\n@throws MathException if the iteration count was exceeded or the\n solver detects convergence problems otherwise.\n",
          "diff": "@@ -1,82 +1,82 @@\n public double solve(double min, double max) throws MathException {\n     clearResult();\n     double x0 \u003d min;\n     double x1 \u003d max;\n     double y0 \u003d f.value(x0);\n     double y1 \u003d f.value(x1);\n     if ((y0 \u003e 0) \u003d\u003d (y1 \u003e 0)) {\n         throw new MathException(\"Interval doesn\u0027t bracket a zero.\");\n     }\n     double x2 \u003d x0;\n     double y2 \u003d y0;\n     double delta \u003d x1 - x0;\n     double oldDelta \u003d delta;\n     int i \u003d 0;\n     while (i \u003c maximalIterationCount) {\n         if (Math.abs(y2) \u003c Math.abs(y1)) {\n             x0 \u003d x1;\n             x1 \u003d x2;\n             x2 \u003d x0;\n             y0 \u003d y1;\n             y1 \u003d y2;\n             y2 \u003d y0;\n         }\n         if (Math.abs(y1) \u003c\u003d functionValueAccuracy) {\n             setResult(x1, i);\n             return result;\n         }\n         double dx \u003d (x2 - x1);\n         double tolerance \u003d Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy);\n         if (Math.abs(dx) \u003c\u003d tolerance) {\n             setResult(x1, i);\n             return result;\n         }\n         if ((Math.abs(oldDelta) \u003c tolerance) || (Math.abs(y0) \u003c\u003d Math.abs(y1))) {\n             delta \u003d 0.5 * dx;\n             oldDelta \u003d delta;\n         } else {\n             double r3 \u003d y1 / y0;\n             double p;\n             double p1;\n             if (x0 \u003d\u003d x2) {\n                 p \u003d dx * r3;\n                 p1 \u003d 1.0 - r3;\n             } else {\n                 double r1 \u003d y0 / y2;\n                 double r2 \u003d y1 / y2;\n                 p \u003d r3 * (dx * r1 * (r1 - r2) - (x1 - x0) * (r2 - 1.0));\n                 p1 \u003d (r1 - 1.0) * (r2 - 1.0) * (r3 - 1.0);\n             }\n             if (p \u003e 0.0) {\n                 p1 \u003d -p1;\n             } else {\n                 p \u003d -p;\n             }\n             if (2.0 * p \u003e\u003d 1.5 * dx * p1 - Math.abs(tolerance * p1) || p \u003e\u003d Math.abs(0.5 * oldDelta * p1)) {\n                 delta \u003d 0.5 * dx;\n                 oldDelta \u003d delta;\n             } else {\n                 oldDelta \u003d delta;\n                 delta \u003d p / p1;\n             }\n         }\n         x0 \u003d x1;\n         y0 \u003d y1;\n         if (Math.abs(delta) \u003e tolerance) {\n             x1 \u003d x1 + delta;\n         } else if (dx \u003e 0.0) {\n             x1 \u003d x1 + 0.5 * tolerance;\n         } else if (dx \u003c\u003d 0.0) {\n             x1 \u003d x1 - 0.5 * tolerance;\n         }\n         y1 \u003d f.value(x1);\n         if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n             x2 \u003d x0;\n             y2 \u003d y0;\n             delta \u003d x1 - x0;\n             oldDelta \u003d delta;\n         }\n         i++;\n     }\n-    throw new MathException(\"Maximal iteration number exceeded.\");\n+    throw new MathException(\"Maximum number of iterations exceeded.\");\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Solve for a zero root in the given interval.\n\n@param min the lower bound for the interval.\n@param max the upper bound for the interval.\n@return the value where the function is zero\n@throws MathException if the iteration count was exceeded or the\n solver detects convergence problems otherwise.\n",
            "newValue": "Find a zero in the given interval.\n\n@param min the lower bound for the interval.\n@param max the upper bound for the interval.\n@return the value where the function is zero\n@throws MathException if the iteration count was exceeded or the\n solver detects convergence problems otherwise.\n"
          }
        }
      ]
    },
    "0a904461932f2c0455611e77ec6a8d8aced2980b": {
      "type": "Yintroduced",
      "commitMessage": "Attempting to recover last revision.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/math/trunk@141013 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/14/03, 2:25 PM",
      "commitName": "0a904461932f2c0455611e77ec6a8d8aced2980b",
      "commitAuthor": "Mark R. Diggory",
      "diff": "@@ -0,0 +1,82 @@\n+public double solve(double min, double max) throws MathException {\n+    clearResult();\n+    double x0 \u003d min;\n+    double x1 \u003d max;\n+    double y0 \u003d f.value(x0);\n+    double y1 \u003d f.value(x1);\n+    if ((y0 \u003e 0) \u003d\u003d (y1 \u003e 0)) {\n+        throw new MathException(\"Interval doesn\u0027t bracket a zero.\");\n+    }\n+    double x2 \u003d x0;\n+    double y2 \u003d y0;\n+    double delta \u003d x1 - x0;\n+    double oldDelta \u003d delta;\n+    int i \u003d 0;\n+    while (i \u003c maximalIterationCount) {\n+        if (Math.abs(y2) \u003c Math.abs(y1)) {\n+            x0 \u003d x1;\n+            x1 \u003d x2;\n+            x2 \u003d x0;\n+            y0 \u003d y1;\n+            y1 \u003d y2;\n+            y2 \u003d y0;\n+        }\n+        if (Math.abs(y1) \u003c\u003d functionValueAccuracy) {\n+            setResult(x1, i);\n+            return result;\n+        }\n+        double dx \u003d (x2 - x1);\n+        double tolerance \u003d Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy);\n+        if (Math.abs(dx) \u003c\u003d tolerance) {\n+            setResult(x1, i);\n+            return result;\n+        }\n+        if ((Math.abs(oldDelta) \u003c tolerance) || (Math.abs(y0) \u003c\u003d Math.abs(y1))) {\n+            delta \u003d 0.5 * dx;\n+            oldDelta \u003d delta;\n+        } else {\n+            double r3 \u003d y1 / y0;\n+            double p;\n+            double p1;\n+            if (x0 \u003d\u003d x2) {\n+                p \u003d dx * r3;\n+                p1 \u003d 1.0 - r3;\n+            } else {\n+                double r1 \u003d y0 / y2;\n+                double r2 \u003d y1 / y2;\n+                p \u003d r3 * (dx * r1 * (r1 - r2) - (x1 - x0) * (r2 - 1.0));\n+                p1 \u003d (r1 - 1.0) * (r2 - 1.0) * (r3 - 1.0);\n+            }\n+            if (p \u003e 0.0) {\n+                p1 \u003d -p1;\n+            } else {\n+                p \u003d -p;\n+            }\n+            if (2.0 * p \u003e\u003d 1.5 * dx * p1 - Math.abs(tolerance * p1) || p \u003e\u003d Math.abs(0.5 * oldDelta * p1)) {\n+                delta \u003d 0.5 * dx;\n+                oldDelta \u003d delta;\n+            } else {\n+                oldDelta \u003d delta;\n+                delta \u003d p / p1;\n+            }\n+        }\n+        x0 \u003d x1;\n+        y0 \u003d y1;\n+        if (Math.abs(delta) \u003e tolerance) {\n+            x1 \u003d x1 + delta;\n+        } else if (dx \u003e 0.0) {\n+            x1 \u003d x1 + 0.5 * tolerance;\n+        } else if (dx \u003c\u003d 0.0) {\n+            x1 \u003d x1 - 0.5 * tolerance;\n+        }\n+        y1 \u003d f.value(x1);\n+        if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n+            x2 \u003d x0;\n+            y2 \u003d y0;\n+            delta \u003d x1 - x0;\n+            oldDelta \u003d delta;\n+        }\n+        i++;\n+    }\n+    throw new MathException(\"Maximal iteration number exceeded.\");\n+}\n\\ No newline at end of file\n",
      "actualSource": "public double solve(double min, double max) throws MathException {\n    clearResult();\n    double x0 \u003d min;\n    double x1 \u003d max;\n    double y0 \u003d f.value(x0);\n    double y1 \u003d f.value(x1);\n    if ((y0 \u003e 0) \u003d\u003d (y1 \u003e 0)) {\n        throw new MathException(\"Interval doesn\u0027t bracket a zero.\");\n    }\n    double x2 \u003d x0;\n    double y2 \u003d y0;\n    double delta \u003d x1 - x0;\n    double oldDelta \u003d delta;\n    int i \u003d 0;\n    while (i \u003c maximalIterationCount) {\n        if (Math.abs(y2) \u003c Math.abs(y1)) {\n            x0 \u003d x1;\n            x1 \u003d x2;\n            x2 \u003d x0;\n            y0 \u003d y1;\n            y1 \u003d y2;\n            y2 \u003d y0;\n        }\n        if (Math.abs(y1) \u003c\u003d functionValueAccuracy) {\n            setResult(x1, i);\n            return result;\n        }\n        double dx \u003d (x2 - x1);\n        double tolerance \u003d Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy);\n        if (Math.abs(dx) \u003c\u003d tolerance) {\n            setResult(x1, i);\n            return result;\n        }\n        if ((Math.abs(oldDelta) \u003c tolerance) || (Math.abs(y0) \u003c\u003d Math.abs(y1))) {\n            delta \u003d 0.5 * dx;\n            oldDelta \u003d delta;\n        } else {\n            double r3 \u003d y1 / y0;\n            double p;\n            double p1;\n            if (x0 \u003d\u003d x2) {\n                p \u003d dx * r3;\n                p1 \u003d 1.0 - r3;\n            } else {\n                double r1 \u003d y0 / y2;\n                double r2 \u003d y1 / y2;\n                p \u003d r3 * (dx * r1 * (r1 - r2) - (x1 - x0) * (r2 - 1.0));\n                p1 \u003d (r1 - 1.0) * (r2 - 1.0) * (r3 - 1.0);\n            }\n            if (p \u003e 0.0) {\n                p1 \u003d -p1;\n            } else {\n                p \u003d -p;\n            }\n            if (2.0 * p \u003e\u003d 1.5 * dx * p1 - Math.abs(tolerance * p1) || p \u003e\u003d Math.abs(0.5 * oldDelta * p1)) {\n                delta \u003d 0.5 * dx;\n                oldDelta \u003d delta;\n            } else {\n                oldDelta \u003d delta;\n                delta \u003d p / p1;\n            }\n        }\n        x0 \u003d x1;\n        y0 \u003d y1;\n        if (Math.abs(delta) \u003e tolerance) {\n            x1 \u003d x1 + delta;\n        } else if (dx \u003e 0.0) {\n            x1 \u003d x1 + 0.5 * tolerance;\n        } else if (dx \u003c\u003d 0.0) {\n            x1 \u003d x1 - 0.5 * tolerance;\n        }\n        y1 \u003d f.value(x1);\n        if ((y1 \u003e 0) \u003d\u003d (y2 \u003e 0)) {\n            x2 \u003d x0;\n            y2 \u003d y0;\n            delta \u003d x1 - x0;\n            oldDelta \u003d delta;\n        }\n        i++;\n    }\n    throw new MathException(\"Maximal iteration number exceeded.\");\n}",
      "path": "src/java/org/apache/commons/math/analysis/BrentSolver.java",
      "functionStartLine": 98,
      "functionName": "solve",
      "functionAnnotation": "",
      "functionDoc": "Solve for a zero root in the given interval.\n\n@param min the lower bound for the interval.\n@param max the upper bound for the interval.\n@return the value where the function is zero\n@throws MathException if the iteration count was exceeded or the\n solver detects convergence problems otherwise.\n"
    }
  }
}