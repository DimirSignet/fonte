{
  "origin": "codeshovel",
  "repositoryName": "Closure-61b",
  "repositoryPath": "/tmp/Closure-61b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "NodeUtil.java",
  "functionName": "checkForStateChangeHelper",
  "functionId": "checkForStateChangeHelper___n-Node__checkForNewObjects-boolean__compiler-AbstractCompiler",
  "sourceFilePath": "src/com/google/javascript/jscomp/NodeUtil.java",
  "functionAnnotation": "",
  "functionDoc": "Returns true if some node in n\u0027s subtree changes application state.\nIf {@code checkForNewObjects} is true, we assume that newly created\nmutable objects (like object literals) change state. Otherwise, we assume\nthat they have no side effects.\n",
  "functionStartLine": 723,
  "functionEndLine": 866,
  "numCommitsSeen": 109,
  "timeTaken": 7499,
  "changeHistory": [
    "34fd5f8275ae69fc772c2283a3c5fd13b93a7c42",
    "6a2378d43d1f06344f6418388d45c66fe3466a07",
    "f0362b1ab1ae1339e017b1d04f016980e3fa6cb6",
    "9b4ae3ac4b39ed3267d23e12d99e1fd6d86400c5",
    "ebb59a97610015bc41bda7f458dd1428a3a3e335",
    "80fe41fd0173c3eaa56f4abb783031966ea89cef",
    "d964d232de65db2370c06ce04de9865a3b2c8c9f",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3"
  ],
  "changeHistoryShort": {
    "34fd5f8275ae69fc772c2283a3c5fd13b93a7c42": "Ybodychange",
    "6a2378d43d1f06344f6418388d45c66fe3466a07": "Ybodychange",
    "f0362b1ab1ae1339e017b1d04f016980e3fa6cb6": "Ybodychange",
    "9b4ae3ac4b39ed3267d23e12d99e1fd6d86400c5": "Ybodychange",
    "ebb59a97610015bc41bda7f458dd1428a3a3e335": "Ybodychange",
    "80fe41fd0173c3eaa56f4abb783031966ea89cef": "Ymultichange(Yparameterchange,Ybodychange)",
    "d964d232de65db2370c06ce04de9865a3b2c8c9f": "Ybodychange",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "34fd5f8275ae69fc772c2283a3c5fd13b93a7c42": {
      "type": "Ybodychange",
      "commitMessage": "\nChange the OBJECTLIT AST structure from:\n\nOBJECTLIT\n  KEY1\n  VALUE1\n\nto\n\nOBJECTLIT\n  KEY1\n    VALUE1\n\nFixes issue 241\n\nR\u003dacleung,johnlenz,stevey\nDELTA\u003d268  (101 added, 51 deleted, 116 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d356416\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@494 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "10/18/10, 2:55 PM",
      "commitName": "34fd5f8275ae69fc772c2283a3c5fd13b93a7c42",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "10/1/10, 4:37 PM",
      "commitNameOld": "7cc748592670105f9d783b1b85f0f27e938db4ff",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 16.93,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "actualSource": "private static boolean checkForStateChangeHelper(Node n, boolean checkForNewObjects, AbstractCompiler compiler) {\n    switch(n.getType()) {\n        case Token.AND:\n        case Token.BLOCK:\n        case Token.EXPR_RESULT:\n        case Token.HOOK:\n        case Token.IF:\n        case Token.IN:\n        case Token.LP:\n        case Token.NUMBER:\n        case Token.OR:\n        case Token.THIS:\n        case Token.TRUE:\n        case Token.FALSE:\n        case Token.NULL:\n        case Token.STRING:\n        case Token.SWITCH:\n        case Token.TRY:\n        case Token.EMPTY:\n            break;\n        case Token.THROW:\n            return true;\n        case Token.OBJECTLIT:\n            if (checkForNewObjects) {\n                return true;\n            }\n            for (Node c \u003d n.getFirstChild(); c !\u003d null; c \u003d c.getNext()) {\n                if (checkForStateChangeHelper(c.getFirstChild(), checkForNewObjects, compiler)) {\n                    return true;\n                }\n            }\n            return false;\n        case Token.ARRAYLIT:\n        case Token.REGEXP:\n            if (checkForNewObjects) {\n                return true;\n            }\n            break;\n        case Token.VAR:\n        case Token.NAME:\n            if (n.getFirstChild() !\u003d null) {\n                return true;\n            }\n            break;\n        case Token.FUNCTION:\n            return checkForNewObjects || !isFunctionExpression(n);\n        case Token.NEW:\n            if (checkForNewObjects) {\n                return true;\n            }\n            if (!constructorCallHasSideEffects(n)) {\n                break;\n            }\n            return true;\n        case Token.CALL:\n            if (!functionCallHasSideEffects(n, compiler)) {\n                break;\n            }\n            return true;\n        default:\n            if (isSimpleOperatorType(n.getType())) {\n                break;\n            }\n            if (isAssignmentOp(n)) {\n                Node assignTarget \u003d n.getFirstChild();\n                if (isName(assignTarget)) {\n                    return true;\n                }\n                if (checkForStateChangeHelper(n.getFirstChild(), checkForNewObjects, compiler) || checkForStateChangeHelper(n.getLastChild(), checkForNewObjects, compiler)) {\n                    return true;\n                }\n                if (isGet(assignTarget)) {\n                    Node current \u003d assignTarget.getFirstChild();\n                    if (evaluatesToLocalValue(current)) {\n                        return false;\n                    }\n                    while (isGet(current)) {\n                        current \u003d current.getFirstChild();\n                    }\n                    return !isLiteralValue(current, true);\n                } else {\n                    return !isLiteralValue(assignTarget, true);\n                }\n            }\n            return true;\n    }\n    for (Node c \u003d n.getFirstChild(); c !\u003d null; c \u003d c.getNext()) {\n        if (checkForStateChangeHelper(c, checkForNewObjects, compiler)) {\n            return true;\n        }\n    }\n    return false;\n}",
      "path": "src/com/google/javascript/jscomp/NodeUtil.java",
      "functionStartLine": 485,
      "functionName": "checkForStateChangeHelper",
      "functionAnnotation": "",
      "functionDoc": "Returns true if some node in n\u0027s subtree changes application state.\nIf {@code checkForNewObjects} is true, we assume that newly created\nmutable objects (like object literals) change state. Otherwise, we assume\nthat they have no side effects.\n",
      "diff": "@@ -1,84 +1,93 @@\n private static boolean checkForStateChangeHelper(Node n, boolean checkForNewObjects, AbstractCompiler compiler) {\n     switch(n.getType()) {\n         case Token.AND:\n         case Token.BLOCK:\n         case Token.EXPR_RESULT:\n         case Token.HOOK:\n         case Token.IF:\n         case Token.IN:\n         case Token.LP:\n         case Token.NUMBER:\n         case Token.OR:\n         case Token.THIS:\n         case Token.TRUE:\n         case Token.FALSE:\n         case Token.NULL:\n         case Token.STRING:\n         case Token.SWITCH:\n         case Token.TRY:\n         case Token.EMPTY:\n             break;\n         case Token.THROW:\n             return true;\n         case Token.OBJECTLIT:\n+            if (checkForNewObjects) {\n+                return true;\n+            }\n+            for (Node c \u003d n.getFirstChild(); c !\u003d null; c \u003d c.getNext()) {\n+                if (checkForStateChangeHelper(c.getFirstChild(), checkForNewObjects, compiler)) {\n+                    return true;\n+                }\n+            }\n+            return false;\n         case Token.ARRAYLIT:\n         case Token.REGEXP:\n             if (checkForNewObjects) {\n                 return true;\n             }\n             break;\n         case Token.VAR:\n         case Token.NAME:\n             if (n.getFirstChild() !\u003d null) {\n                 return true;\n             }\n             break;\n         case Token.FUNCTION:\n             return checkForNewObjects || !isFunctionExpression(n);\n         case Token.NEW:\n             if (checkForNewObjects) {\n                 return true;\n             }\n             if (!constructorCallHasSideEffects(n)) {\n                 break;\n             }\n             return true;\n         case Token.CALL:\n             if (!functionCallHasSideEffects(n, compiler)) {\n                 break;\n             }\n             return true;\n         default:\n             if (isSimpleOperatorType(n.getType())) {\n                 break;\n             }\n             if (isAssignmentOp(n)) {\n                 Node assignTarget \u003d n.getFirstChild();\n                 if (isName(assignTarget)) {\n                     return true;\n                 }\n                 if (checkForStateChangeHelper(n.getFirstChild(), checkForNewObjects, compiler) || checkForStateChangeHelper(n.getLastChild(), checkForNewObjects, compiler)) {\n                     return true;\n                 }\n                 if (isGet(assignTarget)) {\n                     Node current \u003d assignTarget.getFirstChild();\n                     if (evaluatesToLocalValue(current)) {\n                         return false;\n                     }\n                     while (isGet(current)) {\n                         current \u003d current.getFirstChild();\n                     }\n                     return !isLiteralValue(current, true);\n                 } else {\n                     return !isLiteralValue(assignTarget, true);\n                 }\n             }\n             return true;\n     }\n     for (Node c \u003d n.getFirstChild(); c !\u003d null; c \u003d c.getNext()) {\n         if (checkForStateChangeHelper(c, checkForNewObjects, compiler)) {\n             return true;\n         }\n     }\n     return false;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6a2378d43d1f06344f6418388d45c66fe3466a07": {
      "type": "Ybodychange",
      "commitMessage": "\nTake advantage of the finer grain side-effect information when\ndetermining side-effects.\nThe bulk of the changes here are the move of the \"isKnownLocalValue\"\nfunction and its tests from to NodeUtil/NodeUtilTest.\n\nR\u003dnicksantos\nDELTA\u003d664  (419 added, 201 deleted, 44 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d260873\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@466 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "9/27/10, 4:16 PM",
      "commitName": "6a2378d43d1f06344f6418388d45c66fe3466a07",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "9/24/10, 6:20 PM",
      "commitNameOld": "2e526cbea28c991cd34d3f73a77891fa2ffbf6ee",
      "commitAuthorOld": "jschorr@google.com",
      "daysBetweenCommits": 2.91,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "private static boolean checkForStateChangeHelper(Node n, boolean checkForNewObjects, AbstractCompiler compiler) {\n    switch(n.getType()) {\n        case Token.AND:\n        case Token.BLOCK:\n        case Token.EXPR_RESULT:\n        case Token.HOOK:\n        case Token.IF:\n        case Token.IN:\n        case Token.LP:\n        case Token.NUMBER:\n        case Token.OR:\n        case Token.THIS:\n        case Token.TRUE:\n        case Token.FALSE:\n        case Token.NULL:\n        case Token.STRING:\n        case Token.SWITCH:\n        case Token.TRY:\n        case Token.EMPTY:\n            break;\n        case Token.THROW:\n            return true;\n        case Token.OBJECTLIT:\n        case Token.ARRAYLIT:\n        case Token.REGEXP:\n            if (checkForNewObjects) {\n                return true;\n            }\n            break;\n        case Token.VAR:\n        case Token.NAME:\n            if (n.getFirstChild() !\u003d null) {\n                return true;\n            }\n            break;\n        case Token.FUNCTION:\n            return checkForNewObjects || !isFunctionExpression(n);\n        case Token.NEW:\n            if (checkForNewObjects) {\n                return true;\n            }\n            if (!constructorCallHasSideEffects(n)) {\n                break;\n            }\n            return true;\n        case Token.CALL:\n            if (!functionCallHasSideEffects(n, compiler)) {\n                break;\n            }\n            return true;\n        default:\n            if (isSimpleOperatorType(n.getType())) {\n                break;\n            }\n            if (isAssignmentOp(n)) {\n                Node assignTarget \u003d n.getFirstChild();\n                if (isName(assignTarget)) {\n                    return true;\n                }\n                if (checkForStateChangeHelper(n.getFirstChild(), checkForNewObjects, compiler) || checkForStateChangeHelper(n.getLastChild(), checkForNewObjects, compiler)) {\n                    return true;\n                }\n                if (isGet(assignTarget)) {\n                    Node current \u003d assignTarget.getFirstChild();\n                    if (evaluatesToLocalValue(current)) {\n                        return false;\n                    }\n                    while (isGet(current)) {\n                        current \u003d current.getFirstChild();\n                    }\n                    return !isLiteralValue(current, true);\n                } else {\n                    return !isLiteralValue(assignTarget, true);\n                }\n            }\n            return true;\n    }\n    for (Node c \u003d n.getFirstChild(); c !\u003d null; c \u003d c.getNext()) {\n        if (checkForStateChangeHelper(c, checkForNewObjects, compiler)) {\n            return true;\n        }\n    }\n    return false;\n}",
      "path": "src/com/google/javascript/jscomp/NodeUtil.java",
      "functionStartLine": 455,
      "functionName": "checkForStateChangeHelper",
      "functionAnnotation": "",
      "functionDoc": "Returns true if some node in n\u0027s subtree changes application state.\nIf {@code checkForNewObjects} is true, we assume that newly created\nmutable objects (like object literals) change state. Otherwise, we assume\nthat they have no side effects.\n",
      "diff": "@@ -1,72 +1,84 @@\n private static boolean checkForStateChangeHelper(Node n, boolean checkForNewObjects, AbstractCompiler compiler) {\n     switch(n.getType()) {\n         case Token.AND:\n         case Token.BLOCK:\n         case Token.EXPR_RESULT:\n         case Token.HOOK:\n         case Token.IF:\n         case Token.IN:\n         case Token.LP:\n         case Token.NUMBER:\n         case Token.OR:\n         case Token.THIS:\n         case Token.TRUE:\n         case Token.FALSE:\n         case Token.NULL:\n         case Token.STRING:\n         case Token.SWITCH:\n         case Token.TRY:\n         case Token.EMPTY:\n             break;\n         case Token.THROW:\n             return true;\n         case Token.OBJECTLIT:\n         case Token.ARRAYLIT:\n         case Token.REGEXP:\n             if (checkForNewObjects) {\n                 return true;\n             }\n             break;\n         case Token.VAR:\n         case Token.NAME:\n             if (n.getFirstChild() !\u003d null) {\n                 return true;\n             }\n             break;\n         case Token.FUNCTION:\n             return checkForNewObjects || !isFunctionExpression(n);\n         case Token.NEW:\n             if (checkForNewObjects) {\n                 return true;\n             }\n             if (!constructorCallHasSideEffects(n)) {\n                 break;\n             }\n             return true;\n         case Token.CALL:\n             if (!functionCallHasSideEffects(n, compiler)) {\n                 break;\n             }\n             return true;\n         default:\n             if (isSimpleOperatorType(n.getType())) {\n                 break;\n             }\n             if (isAssignmentOp(n)) {\n+                Node assignTarget \u003d n.getFirstChild();\n+                if (isName(assignTarget)) {\n+                    return true;\n+                }\n                 if (checkForStateChangeHelper(n.getFirstChild(), checkForNewObjects, compiler) || checkForStateChangeHelper(n.getLastChild(), checkForNewObjects, compiler)) {\n                     return true;\n                 }\n-                Node current \u003d n.getFirstChild();\n-                for (; current.getType() \u003d\u003d Token.GETPROP || current.getType() \u003d\u003d Token.GETELEM; current \u003d current.getFirstChild()) {\n+                if (isGet(assignTarget)) {\n+                    Node current \u003d assignTarget.getFirstChild();\n+                    if (evaluatesToLocalValue(current)) {\n+                        return false;\n+                    }\n+                    while (isGet(current)) {\n+                        current \u003d current.getFirstChild();\n+                    }\n+                    return !isLiteralValue(current, true);\n+                } else {\n+                    return !isLiteralValue(assignTarget, true);\n                 }\n-                return !isLiteralValue(current, true);\n             }\n             return true;\n     }\n     for (Node c \u003d n.getFirstChild(); c !\u003d null; c \u003d c.getNext()) {\n         if (checkForStateChangeHelper(c, checkForNewObjects, compiler)) {\n             return true;\n         }\n     }\n     return false;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f0362b1ab1ae1339e017b1d04f016980e3fa6cb6": {
      "type": "Ybodychange",
      "commitMessage": "\nfix a bug where NodeUtil was reporting function literals\nas immutable. functions are mutable.\nMake isLiteralValue a bit more flexible, so that it can\nidentify function literals.\ndo some additional folding on function literals.\n\nR\u003dacleung\nDELTA\u003d68  (35 added, 1 deleted, 32 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d64001\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@308 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "7/23/10, 2:49 PM",
      "commitName": "f0362b1ab1ae1339e017b1d04f016980e3fa6cb6",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "7/20/10, 11:11 AM",
      "commitNameOld": "9b4ae3ac4b39ed3267d23e12d99e1fd6d86400c5",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 3.15,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "actualSource": "private static boolean checkForStateChangeHelper(Node n, boolean checkForNewObjects, AbstractCompiler compiler) {\n    switch(n.getType()) {\n        case Token.AND:\n        case Token.BLOCK:\n        case Token.EXPR_RESULT:\n        case Token.HOOK:\n        case Token.IF:\n        case Token.IN:\n        case Token.LP:\n        case Token.NUMBER:\n        case Token.OR:\n        case Token.THIS:\n        case Token.TRUE:\n        case Token.FALSE:\n        case Token.NULL:\n        case Token.STRING:\n        case Token.SWITCH:\n        case Token.TRY:\n        case Token.EMPTY:\n            break;\n        case Token.THROW:\n            return true;\n        case Token.OBJECTLIT:\n        case Token.ARRAYLIT:\n        case Token.REGEXP:\n            if (checkForNewObjects) {\n                return true;\n            }\n            break;\n        case Token.VAR:\n        case Token.NAME:\n            if (n.getFirstChild() !\u003d null) {\n                return true;\n            }\n            break;\n        case Token.FUNCTION:\n            return checkForNewObjects || !isFunctionExpression(n);\n        case Token.NEW:\n            if (checkForNewObjects) {\n                return true;\n            }\n            if (!constructorCallHasSideEffects(n)) {\n                break;\n            }\n            return true;\n        case Token.CALL:\n            if (!functionCallHasSideEffects(n, compiler)) {\n                break;\n            }\n            return true;\n        default:\n            if (isSimpleOperatorType(n.getType())) {\n                break;\n            }\n            if (isAssignmentOp(n)) {\n                if (checkForStateChangeHelper(n.getFirstChild(), checkForNewObjects, compiler) || checkForStateChangeHelper(n.getLastChild(), checkForNewObjects, compiler)) {\n                    return true;\n                }\n                Node current \u003d n.getFirstChild();\n                for (; current.getType() \u003d\u003d Token.GETPROP || current.getType() \u003d\u003d Token.GETELEM; current \u003d current.getFirstChild()) {\n                }\n                return !isLiteralValue(current, true);\n            }\n            return true;\n    }\n    for (Node c \u003d n.getFirstChild(); c !\u003d null; c \u003d c.getNext()) {\n        if (checkForStateChangeHelper(c, checkForNewObjects, compiler)) {\n            return true;\n        }\n    }\n    return false;\n}",
      "path": "src/com/google/javascript/jscomp/NodeUtil.java",
      "functionStartLine": 382,
      "functionName": "checkForStateChangeHelper",
      "functionAnnotation": "",
      "functionDoc": "Returns true if some node in n\u0027s subtree changes application state.\nIf {@code checkForNewObjects} is true, we assume that newly created\nmutable objects (like object literals) change state. Otherwise, we assume\nthat they have no side effects.\n",
      "diff": "@@ -1,72 +1,72 @@\n private static boolean checkForStateChangeHelper(Node n, boolean checkForNewObjects, AbstractCompiler compiler) {\n     switch(n.getType()) {\n         case Token.AND:\n         case Token.BLOCK:\n         case Token.EXPR_RESULT:\n         case Token.HOOK:\n         case Token.IF:\n         case Token.IN:\n         case Token.LP:\n         case Token.NUMBER:\n         case Token.OR:\n         case Token.THIS:\n         case Token.TRUE:\n         case Token.FALSE:\n         case Token.NULL:\n         case Token.STRING:\n         case Token.SWITCH:\n         case Token.TRY:\n         case Token.EMPTY:\n             break;\n         case Token.THROW:\n             return true;\n         case Token.OBJECTLIT:\n         case Token.ARRAYLIT:\n         case Token.REGEXP:\n             if (checkForNewObjects) {\n                 return true;\n             }\n             break;\n         case Token.VAR:\n         case Token.NAME:\n             if (n.getFirstChild() !\u003d null) {\n                 return true;\n             }\n             break;\n         case Token.FUNCTION:\n-            return !isFunctionExpression(n);\n+            return checkForNewObjects || !isFunctionExpression(n);\n         case Token.NEW:\n             if (checkForNewObjects) {\n                 return true;\n             }\n             if (!constructorCallHasSideEffects(n)) {\n                 break;\n             }\n             return true;\n         case Token.CALL:\n             if (!functionCallHasSideEffects(n, compiler)) {\n                 break;\n             }\n             return true;\n         default:\n             if (isSimpleOperatorType(n.getType())) {\n                 break;\n             }\n             if (isAssignmentOp(n)) {\n                 if (checkForStateChangeHelper(n.getFirstChild(), checkForNewObjects, compiler) || checkForStateChangeHelper(n.getLastChild(), checkForNewObjects, compiler)) {\n                     return true;\n                 }\n                 Node current \u003d n.getFirstChild();\n                 for (; current.getType() \u003d\u003d Token.GETPROP || current.getType() \u003d\u003d Token.GETELEM; current \u003d current.getFirstChild()) {\n                 }\n-                return !(isLiteralValue(current) || current.getType() \u003d\u003d Token.FUNCTION);\n+                return !isLiteralValue(current, true);\n             }\n             return true;\n     }\n     for (Node c \u003d n.getFirstChild(); c !\u003d null; c \u003d c.getNext()) {\n         if (checkForStateChangeHelper(c, checkForNewObjects, compiler)) {\n             return true;\n         }\n     }\n     return false;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9b4ae3ac4b39ed3267d23e12d99e1fd6d86400c5": {
      "type": "Ybodychange",
      "commitMessage": "\nCorrect \"void\" operator side-effect detection.\n\nR\u003dbowdidge\nDELTA\u003d17  (13 added, 1 deleted, 3 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d54013\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@298 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "7/20/10, 11:11 AM",
      "commitName": "9b4ae3ac4b39ed3267d23e12d99e1fd6d86400c5",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "7/16/10, 2:56 AM",
      "commitNameOld": "192a60673cfd308fbcb735664fbab98e3cb3a21a",
      "commitAuthorOld": "nadaa@google.com",
      "daysBetweenCommits": 4.34,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "actualSource": "private static boolean checkForStateChangeHelper(Node n, boolean checkForNewObjects, AbstractCompiler compiler) {\n    switch(n.getType()) {\n        case Token.AND:\n        case Token.BLOCK:\n        case Token.EXPR_RESULT:\n        case Token.HOOK:\n        case Token.IF:\n        case Token.IN:\n        case Token.LP:\n        case Token.NUMBER:\n        case Token.OR:\n        case Token.THIS:\n        case Token.TRUE:\n        case Token.FALSE:\n        case Token.NULL:\n        case Token.STRING:\n        case Token.SWITCH:\n        case Token.TRY:\n        case Token.EMPTY:\n            break;\n        case Token.THROW:\n            return true;\n        case Token.OBJECTLIT:\n        case Token.ARRAYLIT:\n        case Token.REGEXP:\n            if (checkForNewObjects) {\n                return true;\n            }\n            break;\n        case Token.VAR:\n        case Token.NAME:\n            if (n.getFirstChild() !\u003d null) {\n                return true;\n            }\n            break;\n        case Token.FUNCTION:\n            return !isFunctionExpression(n);\n        case Token.NEW:\n            if (checkForNewObjects) {\n                return true;\n            }\n            if (!constructorCallHasSideEffects(n)) {\n                break;\n            }\n            return true;\n        case Token.CALL:\n            if (!functionCallHasSideEffects(n, compiler)) {\n                break;\n            }\n            return true;\n        default:\n            if (isSimpleOperatorType(n.getType())) {\n                break;\n            }\n            if (isAssignmentOp(n)) {\n                if (checkForStateChangeHelper(n.getFirstChild(), checkForNewObjects, compiler) || checkForStateChangeHelper(n.getLastChild(), checkForNewObjects, compiler)) {\n                    return true;\n                }\n                Node current \u003d n.getFirstChild();\n                for (; current.getType() \u003d\u003d Token.GETPROP || current.getType() \u003d\u003d Token.GETELEM; current \u003d current.getFirstChild()) {\n                }\n                return !(isLiteralValue(current) || current.getType() \u003d\u003d Token.FUNCTION);\n            }\n            return true;\n    }\n    for (Node c \u003d n.getFirstChild(); c !\u003d null; c \u003d c.getNext()) {\n        if (checkForStateChangeHelper(c, checkForNewObjects, compiler)) {\n            return true;\n        }\n    }\n    return false;\n}",
      "path": "src/com/google/javascript/jscomp/NodeUtil.java",
      "functionStartLine": 364,
      "functionName": "checkForStateChangeHelper",
      "functionAnnotation": "",
      "functionDoc": "Returns true if some node in n\u0027s subtree changes application state.\nIf {@code checkForNewObjects} is true, we assume that newly created\nmutable objects (like object literals) change state. Otherwise, we assume\nthat they have no side effects.\n",
      "diff": "@@ -1,70 +1,72 @@\n private static boolean checkForStateChangeHelper(Node n, boolean checkForNewObjects, AbstractCompiler compiler) {\n     switch(n.getType()) {\n         case Token.AND:\n         case Token.BLOCK:\n         case Token.EXPR_RESULT:\n         case Token.HOOK:\n         case Token.IF:\n         case Token.IN:\n         case Token.LP:\n         case Token.NUMBER:\n         case Token.OR:\n         case Token.THIS:\n         case Token.TRUE:\n         case Token.FALSE:\n         case Token.NULL:\n         case Token.STRING:\n         case Token.SWITCH:\n         case Token.TRY:\n         case Token.EMPTY:\n             break;\n         case Token.THROW:\n             return true;\n         case Token.OBJECTLIT:\n         case Token.ARRAYLIT:\n         case Token.REGEXP:\n             if (checkForNewObjects) {\n                 return true;\n             }\n             break;\n         case Token.VAR:\n         case Token.NAME:\n-            if (n.getFirstChild() !\u003d null)\n+            if (n.getFirstChild() !\u003d null) {\n                 return true;\n+            }\n             break;\n         case Token.FUNCTION:\n             return !isFunctionExpression(n);\n         case Token.NEW:\n             if (checkForNewObjects) {\n                 return true;\n             }\n             if (!constructorCallHasSideEffects(n)) {\n                 break;\n             }\n             return true;\n         case Token.CALL:\n             if (!functionCallHasSideEffects(n, compiler)) {\n                 break;\n             }\n             return true;\n         default:\n-            if (isSimpleOperatorType(n.getType()))\n+            if (isSimpleOperatorType(n.getType())) {\n                 break;\n+            }\n             if (isAssignmentOp(n)) {\n                 if (checkForStateChangeHelper(n.getFirstChild(), checkForNewObjects, compiler) || checkForStateChangeHelper(n.getLastChild(), checkForNewObjects, compiler)) {\n                     return true;\n                 }\n                 Node current \u003d n.getFirstChild();\n                 for (; current.getType() \u003d\u003d Token.GETPROP || current.getType() \u003d\u003d Token.GETELEM; current \u003d current.getFirstChild()) {\n                 }\n                 return !(isLiteralValue(current) || current.getType() \u003d\u003d Token.FUNCTION);\n             }\n             return true;\n     }\n     for (Node c \u003d n.getFirstChild(); c !\u003d null; c \u003d c.getNext()) {\n         if (checkForStateChangeHelper(c, checkForNewObjects, compiler)) {\n             return true;\n         }\n     }\n     return false;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ebb59a97610015bc41bda7f458dd1428a3a3e335": {
      "type": "Ybodychange",
      "commitMessage": "\nChange on 2010/04/22 by nick\n\n        fix the extern definition of Window.prototype.stop\n\n        R\u003dsiggy\n        DELTA\u003d1  (0 added, 0 deleted, 1 changed)\n\nChange on 2010/04/22 by john\n\n        \"Anonymous function\" is a confusing term for functions with names.\n        Properly we are usually distinguishing between functions statements\n        (function declarations) and function expressions.\n\n        R\u003dalan\n        DELTA\u003d172  (7 added, 14 deleted, 151 changed)\n\nChange on 2010/04/22 by john\n\n        Standardize the definition of setTimeout/setInterval.\n        Fix for Issue 137\n\n        R\u003dnick\n        DELTA\u003d6  (2 added, 2 deleted, 2 changed)\n\nChange on 2010/04/22 by mark\n\n        Various delegate fixes.\n\n        Give the delegate proxy a name unique from the delegate base so that\n        InstanceObjectType#equals distinguishes them. This is necessary for\n        AmbiguateProperties to work.\n\n        Fix the prototype of the delegate proxy. This makes\n        DisambiguateProperties continue to work.\n\n        Add superclass methods of the delegate base to the delegate proxy.\n\n\n        R\u003dandrew,nada\n        DELTA\u003d526  (383 added, 104 deleted, 39 changed)\n\nChange on 2010/04/23 by john\n\n        Allow variable inlining of function statements. For simplicity  limited to functions defined before first use.\n\n        R\u003dnick\n        DELTA\u003d79  (49 added, 3 deleted, 27 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003dhakjvx\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@197 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/23/10, 11:31 AM",
      "commitName": "ebb59a97610015bc41bda7f458dd1428a3a3e335",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "4/16/10, 10:20 AM",
      "commitNameOld": "6e3eb4f7619179ba6c23db2af7549ef02f588c35",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 7.05,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "actualSource": "private static boolean checkForStateChangeHelper(Node n, boolean checkForNewObjects, AbstractCompiler compiler) {\n    switch(n.getType()) {\n        case Token.AND:\n        case Token.BLOCK:\n        case Token.EXPR_RESULT:\n        case Token.HOOK:\n        case Token.IF:\n        case Token.IN:\n        case Token.LP:\n        case Token.NUMBER:\n        case Token.OR:\n        case Token.THIS:\n        case Token.TRUE:\n        case Token.FALSE:\n        case Token.NULL:\n        case Token.STRING:\n        case Token.SWITCH:\n        case Token.TRY:\n        case Token.EMPTY:\n            break;\n        case Token.THROW:\n            return true;\n        case Token.OBJECTLIT:\n        case Token.ARRAYLIT:\n        case Token.REGEXP:\n            if (checkForNewObjects) {\n                return true;\n            }\n            break;\n        case Token.VAR:\n        case Token.NAME:\n            if (n.getFirstChild() !\u003d null)\n                return true;\n            break;\n        case Token.FUNCTION:\n            return !isFunctionExpression(n);\n        case Token.NEW:\n            if (checkForNewObjects) {\n                return true;\n            }\n            if (!constructorCallHasSideEffects(n)) {\n                break;\n            }\n            return true;\n        case Token.CALL:\n            if (!functionCallHasSideEffects(n, compiler)) {\n                break;\n            }\n            return true;\n        default:\n            if (isSimpleOperatorType(n.getType()))\n                break;\n            if (isAssignmentOp(n)) {\n                if (checkForStateChangeHelper(n.getFirstChild(), checkForNewObjects, compiler) || checkForStateChangeHelper(n.getLastChild(), checkForNewObjects, compiler)) {\n                    return true;\n                }\n                Node current \u003d n.getFirstChild();\n                for (; current.getType() \u003d\u003d Token.GETPROP || current.getType() \u003d\u003d Token.GETELEM; current \u003d current.getFirstChild()) {\n                }\n                return !(isLiteralValue(current) || current.getType() \u003d\u003d Token.FUNCTION);\n            }\n            return true;\n    }\n    for (Node c \u003d n.getFirstChild(); c !\u003d null; c \u003d c.getNext()) {\n        if (checkForStateChangeHelper(c, checkForNewObjects, compiler)) {\n            return true;\n        }\n    }\n    return false;\n}",
      "path": "src/com/google/javascript/jscomp/NodeUtil.java",
      "functionStartLine": 362,
      "functionName": "checkForStateChangeHelper",
      "functionAnnotation": "",
      "functionDoc": "Returns true if some node in n\u0027s subtree changes application state.\nIf {@code checkForNewObjects} is true, we assume that newly created\nmutable objects (like object literals) change state. Otherwise, we assume\nthat they have no side effects.\n",
      "diff": "@@ -1,70 +1,70 @@\n private static boolean checkForStateChangeHelper(Node n, boolean checkForNewObjects, AbstractCompiler compiler) {\n     switch(n.getType()) {\n         case Token.AND:\n         case Token.BLOCK:\n         case Token.EXPR_RESULT:\n         case Token.HOOK:\n         case Token.IF:\n         case Token.IN:\n         case Token.LP:\n         case Token.NUMBER:\n         case Token.OR:\n         case Token.THIS:\n         case Token.TRUE:\n         case Token.FALSE:\n         case Token.NULL:\n         case Token.STRING:\n         case Token.SWITCH:\n         case Token.TRY:\n         case Token.EMPTY:\n             break;\n         case Token.THROW:\n             return true;\n         case Token.OBJECTLIT:\n         case Token.ARRAYLIT:\n         case Token.REGEXP:\n             if (checkForNewObjects) {\n                 return true;\n             }\n             break;\n         case Token.VAR:\n         case Token.NAME:\n             if (n.getFirstChild() !\u003d null)\n                 return true;\n             break;\n         case Token.FUNCTION:\n-            return !isFunctionAnonymous(n);\n+            return !isFunctionExpression(n);\n         case Token.NEW:\n             if (checkForNewObjects) {\n                 return true;\n             }\n             if (!constructorCallHasSideEffects(n)) {\n                 break;\n             }\n             return true;\n         case Token.CALL:\n             if (!functionCallHasSideEffects(n, compiler)) {\n                 break;\n             }\n             return true;\n         default:\n             if (isSimpleOperatorType(n.getType()))\n                 break;\n             if (isAssignmentOp(n)) {\n                 if (checkForStateChangeHelper(n.getFirstChild(), checkForNewObjects, compiler) || checkForStateChangeHelper(n.getLastChild(), checkForNewObjects, compiler)) {\n                     return true;\n                 }\n                 Node current \u003d n.getFirstChild();\n                 for (; current.getType() \u003d\u003d Token.GETPROP || current.getType() \u003d\u003d Token.GETELEM; current \u003d current.getFirstChild()) {\n                 }\n                 return !(isLiteralValue(current) || current.getType() \u003d\u003d Token.FUNCTION);\n             }\n             return true;\n     }\n     for (Node c \u003d n.getFirstChild(); c !\u003d null; c \u003d c.getNext()) {\n         if (checkForStateChangeHelper(c, checkForNewObjects, compiler)) {\n             return true;\n         }\n     }\n     return false;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "80fe41fd0173c3eaa56f4abb783031966ea89cef": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "\nChange on 2010/04/09 by john\n\n        Part II: Use global RegExp reference information to optimize references when possible.\n\n        R\u003dalan\n        DELTA\u003d231  (173 added, 17 deleted, 41 changed)\n\nChange on 2010/04/09 by nicksantos\n\n        Make JsFileLineParser much more efficient for large files\n        (we were running into problems with it running out of memory.)\n\n        R\u003dandrew\n        DELTA\u003d192  (157 added, 1 deleted, 34 changed)\n\nChange on 2010/04/09 by alan\n\n        Fix typed code gen crash when generating typed code.\n\n        R\u003dnicksantos\n        DELTA\u003d35  (24 added, 2 deleted, 9 changed)\n\nChange on 2010/04/09 by alan\n\n        Disable method motion on functions that reads closure variables.\n\n        R\u003dnicksantos\n        DELTA\u003d171  (162 added, 1 deleted, 8 changed)\n\nChange on 2010/04/12 by nada\n\n        In AmbiguateProperties, invert the related type relationship, by\n        considering subclasses and implementors (down) instead of superclasses\n        and implemented interfaces (up). This has two advantages:\n\n        - The \u0027independent of\u0027 relationship is simplified, because we only\n          need to consider whether the related types intersect.\n\n        - We can account for \u0027multiple inheritance\u0027, which is a practical\n          issue because of interfaces.\n\n        Note that the \u0027up\u0027 relationship allows us to easily find common\n        ancestors while the \u0027down\u0027 relationship allows us to easily find\n        common descendants -- and this is what we care about for ambiguation.\n\n\n        R\u003dmoedinger\n        DELTA\u003d173  (124 added, 15 deleted, 34 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003dmwgnge\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@180 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/12/10, 7:59 AM",
      "commitName": "80fe41fd0173c3eaa56f4abb783031966ea89cef",
      "commitAuthor": "Nicholas.J.Santos",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "\nChange on 2010/04/09 by john\n\n        Part II: Use global RegExp reference information to optimize references when possible.\n\n        R\u003dalan\n        DELTA\u003d231  (173 added, 17 deleted, 41 changed)\n\nChange on 2010/04/09 by nicksantos\n\n        Make JsFileLineParser much more efficient for large files\n        (we were running into problems with it running out of memory.)\n\n        R\u003dandrew\n        DELTA\u003d192  (157 added, 1 deleted, 34 changed)\n\nChange on 2010/04/09 by alan\n\n        Fix typed code gen crash when generating typed code.\n\n        R\u003dnicksantos\n        DELTA\u003d35  (24 added, 2 deleted, 9 changed)\n\nChange on 2010/04/09 by alan\n\n        Disable method motion on functions that reads closure variables.\n\n        R\u003dnicksantos\n        DELTA\u003d171  (162 added, 1 deleted, 8 changed)\n\nChange on 2010/04/12 by nada\n\n        In AmbiguateProperties, invert the related type relationship, by\n        considering subclasses and implementors (down) instead of superclasses\n        and implemented interfaces (up). This has two advantages:\n\n        - The \u0027independent of\u0027 relationship is simplified, because we only\n          need to consider whether the related types intersect.\n\n        - We can account for \u0027multiple inheritance\u0027, which is a practical\n          issue because of interfaces.\n\n        Note that the \u0027up\u0027 relationship allows us to easily find common\n        ancestors while the \u0027down\u0027 relationship allows us to easily find\n        common descendants -- and this is what we care about for ambiguation.\n\n\n        R\u003dmoedinger\n        DELTA\u003d173  (124 added, 15 deleted, 34 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003dmwgnge\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@180 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "4/12/10, 7:59 AM",
          "commitName": "80fe41fd0173c3eaa56f4abb783031966ea89cef",
          "commitAuthor": "Nicholas.J.Santos",
          "commitDateOld": "4/7/10, 11:34 AM",
          "commitNameOld": "7eaa0d8eca2549742649af34671eaf3da83b5c08",
          "commitAuthorOld": "Nicholas.J.Santos",
          "daysBetweenCommits": 4.85,
          "commitsBetweenForRepo": 5,
          "commitsBetweenForFile": 1,
          "actualSource": "private static boolean checkForStateChangeHelper(Node n, boolean checkForNewObjects, AbstractCompiler compiler) {\n    switch(n.getType()) {\n        case Token.AND:\n        case Token.BLOCK:\n        case Token.EXPR_RESULT:\n        case Token.HOOK:\n        case Token.IF:\n        case Token.IN:\n        case Token.LP:\n        case Token.NUMBER:\n        case Token.OR:\n        case Token.THIS:\n        case Token.TRUE:\n        case Token.FALSE:\n        case Token.NULL:\n        case Token.STRING:\n        case Token.SWITCH:\n        case Token.TRY:\n        case Token.EMPTY:\n            break;\n        case Token.THROW:\n            return true;\n        case Token.OBJECTLIT:\n        case Token.ARRAYLIT:\n        case Token.REGEXP:\n            if (checkForNewObjects) {\n                return true;\n            }\n            break;\n        case Token.VAR:\n        case Token.NAME:\n            if (n.getFirstChild() !\u003d null)\n                return true;\n            break;\n        case Token.FUNCTION:\n            return !isFunctionAnonymous(n);\n        case Token.NEW:\n            if (checkForNewObjects) {\n                return true;\n            }\n            if (!constructorCallHasSideEffects(n)) {\n                break;\n            }\n            return true;\n        case Token.CALL:\n            if (!functionCallHasSideEffects(n, compiler)) {\n                break;\n            }\n            return true;\n        default:\n            if (isSimpleOperatorType(n.getType()))\n                break;\n            if (isAssignmentOp(n)) {\n                if (checkForStateChangeHelper(n.getFirstChild(), checkForNewObjects, compiler) || checkForStateChangeHelper(n.getLastChild(), checkForNewObjects, compiler)) {\n                    return true;\n                }\n                Node current \u003d n.getFirstChild();\n                for (; current.getType() \u003d\u003d Token.GETPROP || current.getType() \u003d\u003d Token.GETELEM; current \u003d current.getFirstChild()) {\n                }\n                return !(isLiteralValue(current) || current.getType() \u003d\u003d Token.FUNCTION);\n            }\n            return true;\n    }\n    for (Node c \u003d n.getFirstChild(); c !\u003d null; c \u003d c.getNext()) {\n        if (checkForStateChangeHelper(c, checkForNewObjects, compiler)) {\n            return true;\n        }\n    }\n    return false;\n}",
          "path": "src/com/google/javascript/jscomp/NodeUtil.java",
          "functionStartLine": 363,
          "functionName": "checkForStateChangeHelper",
          "functionAnnotation": "",
          "functionDoc": "Returns true if some node in n\u0027s subtree changes application state.\nIf {@code checkForNewObjects} is true, we assume that newly created\nmutable objects (like object literals) change state. Otherwise, we assume\nthat they have no side effects.\n",
          "diff": "@@ -1,80 +1,70 @@\n-private static boolean checkForStateChangeHelper(Node n, boolean checkForNewObjects) {\n+private static boolean checkForStateChangeHelper(Node n, boolean checkForNewObjects, AbstractCompiler compiler) {\n     switch(n.getType()) {\n         case Token.AND:\n         case Token.BLOCK:\n         case Token.EXPR_RESULT:\n         case Token.HOOK:\n         case Token.IF:\n         case Token.IN:\n         case Token.LP:\n         case Token.NUMBER:\n         case Token.OR:\n         case Token.THIS:\n         case Token.TRUE:\n         case Token.FALSE:\n         case Token.NULL:\n         case Token.STRING:\n         case Token.SWITCH:\n         case Token.TRY:\n         case Token.EMPTY:\n             break;\n         case Token.THROW:\n             return true;\n         case Token.OBJECTLIT:\n         case Token.ARRAYLIT:\n         case Token.REGEXP:\n             if (checkForNewObjects) {\n                 return true;\n             }\n             break;\n         case Token.VAR:\n         case Token.NAME:\n             if (n.getFirstChild() !\u003d null)\n                 return true;\n             break;\n         case Token.FUNCTION:\n             return !isFunctionAnonymous(n);\n         case Token.NEW:\n-            {\n-                if (checkForNewObjects) {\n-                    return true;\n-                }\n-                if (n.isNoSideEffectsCall()) {\n-                    break;\n-                }\n-                Node constructor \u003d n.getFirstChild();\n-                if (Token.NAME \u003d\u003d constructor.getType()) {\n-                    String className \u003d constructor.getString();\n-                    if (CONSTRUCTORS_WITHOUT_SIDE_EFFECTS.contains(className)) {\n-                        break;\n-                    }\n-                } else {\n-                }\n+            if (checkForNewObjects) {\n+                return true;\n+            }\n+            if (!constructorCallHasSideEffects(n)) {\n+                break;\n             }\n             return true;\n         case Token.CALL:\n-            if (n.isNoSideEffectsCall()) {\n+            if (!functionCallHasSideEffects(n, compiler)) {\n                 break;\n             }\n             return true;\n         default:\n             if (isSimpleOperatorType(n.getType()))\n                 break;\n             if (isAssignmentOp(n)) {\n-                if (checkForStateChangeHelper(n.getFirstChild(), checkForNewObjects) || checkForStateChangeHelper(n.getLastChild(), checkForNewObjects)) {\n+                if (checkForStateChangeHelper(n.getFirstChild(), checkForNewObjects, compiler) || checkForStateChangeHelper(n.getLastChild(), checkForNewObjects, compiler)) {\n                     return true;\n                 }\n                 Node current \u003d n.getFirstChild();\n                 for (; current.getType() \u003d\u003d Token.GETPROP || current.getType() \u003d\u003d Token.GETELEM; current \u003d current.getFirstChild()) {\n                 }\n                 return !(isLiteralValue(current) || current.getType() \u003d\u003d Token.FUNCTION);\n             }\n             return true;\n     }\n     for (Node c \u003d n.getFirstChild(); c !\u003d null; c \u003d c.getNext()) {\n-        if (checkForStateChangeHelper(c, checkForNewObjects)) {\n+        if (checkForStateChangeHelper(c, checkForNewObjects, compiler)) {\n             return true;\n         }\n     }\n     return false;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[n-Node, checkForNewObjects-boolean]",
            "newValue": "[n-Node, checkForNewObjects-boolean, compiler-AbstractCompiler]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "\nChange on 2010/04/09 by john\n\n        Part II: Use global RegExp reference information to optimize references when possible.\n\n        R\u003dalan\n        DELTA\u003d231  (173 added, 17 deleted, 41 changed)\n\nChange on 2010/04/09 by nicksantos\n\n        Make JsFileLineParser much more efficient for large files\n        (we were running into problems with it running out of memory.)\n\n        R\u003dandrew\n        DELTA\u003d192  (157 added, 1 deleted, 34 changed)\n\nChange on 2010/04/09 by alan\n\n        Fix typed code gen crash when generating typed code.\n\n        R\u003dnicksantos\n        DELTA\u003d35  (24 added, 2 deleted, 9 changed)\n\nChange on 2010/04/09 by alan\n\n        Disable method motion on functions that reads closure variables.\n\n        R\u003dnicksantos\n        DELTA\u003d171  (162 added, 1 deleted, 8 changed)\n\nChange on 2010/04/12 by nada\n\n        In AmbiguateProperties, invert the related type relationship, by\n        considering subclasses and implementors (down) instead of superclasses\n        and implemented interfaces (up). This has two advantages:\n\n        - The \u0027independent of\u0027 relationship is simplified, because we only\n          need to consider whether the related types intersect.\n\n        - We can account for \u0027multiple inheritance\u0027, which is a practical\n          issue because of interfaces.\n\n        Note that the \u0027up\u0027 relationship allows us to easily find common\n        ancestors while the \u0027down\u0027 relationship allows us to easily find\n        common descendants -- and this is what we care about for ambiguation.\n\n\n        R\u003dmoedinger\n        DELTA\u003d173  (124 added, 15 deleted, 34 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003dmwgnge\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@180 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "4/12/10, 7:59 AM",
          "commitName": "80fe41fd0173c3eaa56f4abb783031966ea89cef",
          "commitAuthor": "Nicholas.J.Santos",
          "commitDateOld": "4/7/10, 11:34 AM",
          "commitNameOld": "7eaa0d8eca2549742649af34671eaf3da83b5c08",
          "commitAuthorOld": "Nicholas.J.Santos",
          "daysBetweenCommits": 4.85,
          "commitsBetweenForRepo": 5,
          "commitsBetweenForFile": 1,
          "actualSource": "private static boolean checkForStateChangeHelper(Node n, boolean checkForNewObjects, AbstractCompiler compiler) {\n    switch(n.getType()) {\n        case Token.AND:\n        case Token.BLOCK:\n        case Token.EXPR_RESULT:\n        case Token.HOOK:\n        case Token.IF:\n        case Token.IN:\n        case Token.LP:\n        case Token.NUMBER:\n        case Token.OR:\n        case Token.THIS:\n        case Token.TRUE:\n        case Token.FALSE:\n        case Token.NULL:\n        case Token.STRING:\n        case Token.SWITCH:\n        case Token.TRY:\n        case Token.EMPTY:\n            break;\n        case Token.THROW:\n            return true;\n        case Token.OBJECTLIT:\n        case Token.ARRAYLIT:\n        case Token.REGEXP:\n            if (checkForNewObjects) {\n                return true;\n            }\n            break;\n        case Token.VAR:\n        case Token.NAME:\n            if (n.getFirstChild() !\u003d null)\n                return true;\n            break;\n        case Token.FUNCTION:\n            return !isFunctionAnonymous(n);\n        case Token.NEW:\n            if (checkForNewObjects) {\n                return true;\n            }\n            if (!constructorCallHasSideEffects(n)) {\n                break;\n            }\n            return true;\n        case Token.CALL:\n            if (!functionCallHasSideEffects(n, compiler)) {\n                break;\n            }\n            return true;\n        default:\n            if (isSimpleOperatorType(n.getType()))\n                break;\n            if (isAssignmentOp(n)) {\n                if (checkForStateChangeHelper(n.getFirstChild(), checkForNewObjects, compiler) || checkForStateChangeHelper(n.getLastChild(), checkForNewObjects, compiler)) {\n                    return true;\n                }\n                Node current \u003d n.getFirstChild();\n                for (; current.getType() \u003d\u003d Token.GETPROP || current.getType() \u003d\u003d Token.GETELEM; current \u003d current.getFirstChild()) {\n                }\n                return !(isLiteralValue(current) || current.getType() \u003d\u003d Token.FUNCTION);\n            }\n            return true;\n    }\n    for (Node c \u003d n.getFirstChild(); c !\u003d null; c \u003d c.getNext()) {\n        if (checkForStateChangeHelper(c, checkForNewObjects, compiler)) {\n            return true;\n        }\n    }\n    return false;\n}",
          "path": "src/com/google/javascript/jscomp/NodeUtil.java",
          "functionStartLine": 363,
          "functionName": "checkForStateChangeHelper",
          "functionAnnotation": "",
          "functionDoc": "Returns true if some node in n\u0027s subtree changes application state.\nIf {@code checkForNewObjects} is true, we assume that newly created\nmutable objects (like object literals) change state. Otherwise, we assume\nthat they have no side effects.\n",
          "diff": "@@ -1,80 +1,70 @@\n-private static boolean checkForStateChangeHelper(Node n, boolean checkForNewObjects) {\n+private static boolean checkForStateChangeHelper(Node n, boolean checkForNewObjects, AbstractCompiler compiler) {\n     switch(n.getType()) {\n         case Token.AND:\n         case Token.BLOCK:\n         case Token.EXPR_RESULT:\n         case Token.HOOK:\n         case Token.IF:\n         case Token.IN:\n         case Token.LP:\n         case Token.NUMBER:\n         case Token.OR:\n         case Token.THIS:\n         case Token.TRUE:\n         case Token.FALSE:\n         case Token.NULL:\n         case Token.STRING:\n         case Token.SWITCH:\n         case Token.TRY:\n         case Token.EMPTY:\n             break;\n         case Token.THROW:\n             return true;\n         case Token.OBJECTLIT:\n         case Token.ARRAYLIT:\n         case Token.REGEXP:\n             if (checkForNewObjects) {\n                 return true;\n             }\n             break;\n         case Token.VAR:\n         case Token.NAME:\n             if (n.getFirstChild() !\u003d null)\n                 return true;\n             break;\n         case Token.FUNCTION:\n             return !isFunctionAnonymous(n);\n         case Token.NEW:\n-            {\n-                if (checkForNewObjects) {\n-                    return true;\n-                }\n-                if (n.isNoSideEffectsCall()) {\n-                    break;\n-                }\n-                Node constructor \u003d n.getFirstChild();\n-                if (Token.NAME \u003d\u003d constructor.getType()) {\n-                    String className \u003d constructor.getString();\n-                    if (CONSTRUCTORS_WITHOUT_SIDE_EFFECTS.contains(className)) {\n-                        break;\n-                    }\n-                } else {\n-                }\n+            if (checkForNewObjects) {\n+                return true;\n+            }\n+            if (!constructorCallHasSideEffects(n)) {\n+                break;\n             }\n             return true;\n         case Token.CALL:\n-            if (n.isNoSideEffectsCall()) {\n+            if (!functionCallHasSideEffects(n, compiler)) {\n                 break;\n             }\n             return true;\n         default:\n             if (isSimpleOperatorType(n.getType()))\n                 break;\n             if (isAssignmentOp(n)) {\n-                if (checkForStateChangeHelper(n.getFirstChild(), checkForNewObjects) || checkForStateChangeHelper(n.getLastChild(), checkForNewObjects)) {\n+                if (checkForStateChangeHelper(n.getFirstChild(), checkForNewObjects, compiler) || checkForStateChangeHelper(n.getLastChild(), checkForNewObjects, compiler)) {\n                     return true;\n                 }\n                 Node current \u003d n.getFirstChild();\n                 for (; current.getType() \u003d\u003d Token.GETPROP || current.getType() \u003d\u003d Token.GETELEM; current \u003d current.getFirstChild()) {\n                 }\n                 return !(isLiteralValue(current) || current.getType() \u003d\u003d Token.FUNCTION);\n             }\n             return true;\n     }\n     for (Node c \u003d n.getFirstChild(); c !\u003d null; c \u003d c.getNext()) {\n-        if (checkForStateChangeHelper(c, checkForNewObjects)) {\n+        if (checkForStateChangeHelper(c, checkForNewObjects, compiler)) {\n             return true;\n         }\n     }\n     return false;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "d964d232de65db2370c06ce04de9865a3b2c8c9f": {
      "type": "Ybodychange",
      "commitMessage": "Minor code removal improvement \"({}).prop \u003d 3;\" has no side effects.\n\nImprovements to test infrastructure.\n\nFix an edge case compiler crash in TypeValidator.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@43 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "12/21/09, 10:13 AM",
      "commitName": "d964d232de65db2370c06ce04de9865a3b2c8c9f",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "commitDateOld": "12/17/09, 4:20 PM",
      "commitNameOld": "14ddcfdc0b8d1cece3c79221b1870b84f055d419",
      "commitAuthorOld": "nicholas.j.santos@gmail.com",
      "daysBetweenCommits": 3.75,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "private static boolean checkForStateChangeHelper(Node n, boolean checkForNewObjects) {\n    switch(n.getType()) {\n        case Token.AND:\n        case Token.BLOCK:\n        case Token.EXPR_RESULT:\n        case Token.HOOK:\n        case Token.IF:\n        case Token.IN:\n        case Token.LP:\n        case Token.NUMBER:\n        case Token.OR:\n        case Token.THIS:\n        case Token.TRUE:\n        case Token.FALSE:\n        case Token.NULL:\n        case Token.STRING:\n        case Token.SWITCH:\n        case Token.TRY:\n        case Token.EMPTY:\n            break;\n        case Token.THROW:\n            return true;\n        case Token.OBJECTLIT:\n        case Token.ARRAYLIT:\n        case Token.REGEXP:\n            if (checkForNewObjects) {\n                return true;\n            }\n            break;\n        case Token.VAR:\n        case Token.NAME:\n            if (n.getFirstChild() !\u003d null)\n                return true;\n            break;\n        case Token.FUNCTION:\n            return !isFunctionAnonymous(n);\n        case Token.NEW:\n            {\n                if (checkForNewObjects) {\n                    return true;\n                }\n                if (n.isNoSideEffectsCall()) {\n                    break;\n                }\n                Node constructor \u003d n.getFirstChild();\n                if (Token.NAME \u003d\u003d constructor.getType()) {\n                    String className \u003d constructor.getString();\n                    if (CONSTRUCTORS_WITHOUT_SIDE_EFFECTS.contains(className)) {\n                        break;\n                    }\n                } else {\n                }\n            }\n            return true;\n        case Token.CALL:\n            if (n.isNoSideEffectsCall()) {\n                break;\n            }\n            return true;\n        default:\n            if (isSimpleOperatorType(n.getType()))\n                break;\n            if (isAssignmentOp(n)) {\n                if (checkForStateChangeHelper(n.getFirstChild(), checkForNewObjects) || checkForStateChangeHelper(n.getLastChild(), checkForNewObjects)) {\n                    return true;\n                }\n                Node current \u003d n.getFirstChild();\n                for (; current.getType() \u003d\u003d Token.GETPROP || current.getType() \u003d\u003d Token.GETELEM; current \u003d current.getFirstChild()) {\n                }\n                return !(isLiteralValue(current) || current.getType() \u003d\u003d Token.FUNCTION);\n            }\n            return true;\n    }\n    for (Node c \u003d n.getFirstChild(); c !\u003d null; c \u003d c.getNext()) {\n        if (checkForStateChangeHelper(c, checkForNewObjects)) {\n            return true;\n        }\n    }\n    return false;\n}",
      "path": "src/com/google/javascript/jscomp/NodeUtil.java",
      "functionStartLine": 352,
      "functionName": "checkForStateChangeHelper",
      "functionAnnotation": "",
      "functionDoc": "Returns true if some node in n\u0027s subtree changes application state.\nIf {@code checkForNewObjects} is true, we assume that newly created\nmutable objects (like object literals) change state. Otherwise, we assume\nthat they have no side effects.\n",
      "diff": "@@ -1,71 +1,80 @@\n private static boolean checkForStateChangeHelper(Node n, boolean checkForNewObjects) {\n     switch(n.getType()) {\n         case Token.AND:\n         case Token.BLOCK:\n         case Token.EXPR_RESULT:\n         case Token.HOOK:\n         case Token.IF:\n         case Token.IN:\n         case Token.LP:\n         case Token.NUMBER:\n         case Token.OR:\n         case Token.THIS:\n         case Token.TRUE:\n         case Token.FALSE:\n         case Token.NULL:\n         case Token.STRING:\n         case Token.SWITCH:\n         case Token.TRY:\n         case Token.EMPTY:\n             break;\n         case Token.THROW:\n             return true;\n         case Token.OBJECTLIT:\n         case Token.ARRAYLIT:\n         case Token.REGEXP:\n             if (checkForNewObjects) {\n                 return true;\n             }\n             break;\n         case Token.VAR:\n         case Token.NAME:\n             if (n.getFirstChild() !\u003d null)\n                 return true;\n             break;\n         case Token.FUNCTION:\n             return !isFunctionAnonymous(n);\n         case Token.NEW:\n             {\n                 if (checkForNewObjects) {\n                     return true;\n                 }\n                 if (n.isNoSideEffectsCall()) {\n                     break;\n                 }\n                 Node constructor \u003d n.getFirstChild();\n                 if (Token.NAME \u003d\u003d constructor.getType()) {\n                     String className \u003d constructor.getString();\n                     if (CONSTRUCTORS_WITHOUT_SIDE_EFFECTS.contains(className)) {\n                         break;\n                     }\n                 } else {\n                 }\n             }\n             return true;\n         case Token.CALL:\n             if (n.isNoSideEffectsCall()) {\n                 break;\n             }\n             return true;\n         default:\n             if (isSimpleOperatorType(n.getType()))\n                 break;\n+            if (isAssignmentOp(n)) {\n+                if (checkForStateChangeHelper(n.getFirstChild(), checkForNewObjects) || checkForStateChangeHelper(n.getLastChild(), checkForNewObjects)) {\n+                    return true;\n+                }\n+                Node current \u003d n.getFirstChild();\n+                for (; current.getType() \u003d\u003d Token.GETPROP || current.getType() \u003d\u003d Token.GETELEM; current \u003d current.getFirstChild()) {\n+                }\n+                return !(isLiteralValue(current) || current.getType() \u003d\u003d Token.FUNCTION);\n+            }\n             return true;\n     }\n     for (Node c \u003d n.getFirstChild(); c !\u003d null; c \u003d c.getNext()) {\n         if (checkForStateChangeHelper(c, checkForNewObjects)) {\n             return true;\n         }\n     }\n     return false;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": {
      "type": "Yintroduced",
      "commitMessage": "Initial commit.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/3/09, 3:51 PM",
      "commitName": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "diff": "@@ -0,0 +1,71 @@\n+private static boolean checkForStateChangeHelper(Node n, boolean checkForNewObjects) {\n+    switch(n.getType()) {\n+        case Token.AND:\n+        case Token.BLOCK:\n+        case Token.EXPR_RESULT:\n+        case Token.HOOK:\n+        case Token.IF:\n+        case Token.IN:\n+        case Token.LP:\n+        case Token.NUMBER:\n+        case Token.OR:\n+        case Token.THIS:\n+        case Token.TRUE:\n+        case Token.FALSE:\n+        case Token.NULL:\n+        case Token.STRING:\n+        case Token.SWITCH:\n+        case Token.TRY:\n+        case Token.EMPTY:\n+            break;\n+        case Token.THROW:\n+            return true;\n+        case Token.OBJECTLIT:\n+        case Token.ARRAYLIT:\n+        case Token.REGEXP:\n+            if (checkForNewObjects) {\n+                return true;\n+            }\n+            break;\n+        case Token.VAR:\n+        case Token.NAME:\n+            if (n.getFirstChild() !\u003d null)\n+                return true;\n+            break;\n+        case Token.FUNCTION:\n+            return !isFunctionAnonymous(n);\n+        case Token.NEW:\n+            {\n+                if (checkForNewObjects) {\n+                    return true;\n+                }\n+                if (n.isNoSideEffectsCall()) {\n+                    break;\n+                }\n+                Node constructor \u003d n.getFirstChild();\n+                if (Token.NAME \u003d\u003d constructor.getType()) {\n+                    String className \u003d constructor.getString();\n+                    if (CONSTRUCTORS_WITHOUT_SIDE_EFFECTS.contains(className)) {\n+                        break;\n+                    }\n+                } else {\n+                }\n+            }\n+            return true;\n+        case Token.CALL:\n+            if (n.isNoSideEffectsCall()) {\n+                break;\n+            }\n+            return true;\n+        default:\n+            if (isSimpleOperatorType(n.getType()))\n+                break;\n+            return true;\n+    }\n+    for (Node c \u003d n.getFirstChild(); c !\u003d null; c \u003d c.getNext()) {\n+        if (checkForStateChangeHelper(c, checkForNewObjects)) {\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n\\ No newline at end of file\n",
      "actualSource": "private static boolean checkForStateChangeHelper(Node n, boolean checkForNewObjects) {\n    switch(n.getType()) {\n        case Token.AND:\n        case Token.BLOCK:\n        case Token.EXPR_RESULT:\n        case Token.HOOK:\n        case Token.IF:\n        case Token.IN:\n        case Token.LP:\n        case Token.NUMBER:\n        case Token.OR:\n        case Token.THIS:\n        case Token.TRUE:\n        case Token.FALSE:\n        case Token.NULL:\n        case Token.STRING:\n        case Token.SWITCH:\n        case Token.TRY:\n        case Token.EMPTY:\n            break;\n        case Token.THROW:\n            return true;\n        case Token.OBJECTLIT:\n        case Token.ARRAYLIT:\n        case Token.REGEXP:\n            if (checkForNewObjects) {\n                return true;\n            }\n            break;\n        case Token.VAR:\n        case Token.NAME:\n            if (n.getFirstChild() !\u003d null)\n                return true;\n            break;\n        case Token.FUNCTION:\n            return !isFunctionAnonymous(n);\n        case Token.NEW:\n            {\n                if (checkForNewObjects) {\n                    return true;\n                }\n                if (n.isNoSideEffectsCall()) {\n                    break;\n                }\n                Node constructor \u003d n.getFirstChild();\n                if (Token.NAME \u003d\u003d constructor.getType()) {\n                    String className \u003d constructor.getString();\n                    if (CONSTRUCTORS_WITHOUT_SIDE_EFFECTS.contains(className)) {\n                        break;\n                    }\n                } else {\n                }\n            }\n            return true;\n        case Token.CALL:\n            if (n.isNoSideEffectsCall()) {\n                break;\n            }\n            return true;\n        default:\n            if (isSimpleOperatorType(n.getType()))\n                break;\n            return true;\n    }\n    for (Node c \u003d n.getFirstChild(); c !\u003d null; c \u003d c.getNext()) {\n        if (checkForStateChangeHelper(c, checkForNewObjects)) {\n            return true;\n        }\n    }\n    return false;\n}",
      "path": "src/com/google/javascript/jscomp/NodeUtil.java",
      "functionStartLine": 351,
      "functionName": "checkForStateChangeHelper",
      "functionAnnotation": "",
      "functionDoc": "Returns true if some node in n\u0027s subtree changes application state.\nIf {@code checkForNewObjects} is true, we assume that newly created\nmutable objects (like object literals) change state. Otherwise, we assume\nthat they have no side effects.\n"
    }
  }
}