{
  "origin": "codeshovel",
  "repositoryName": "Time-7b",
  "repositoryPath": "/tmp/Time-7b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "DateTimeFormatter.java",
  "functionName": "parseInto",
  "functionId": "parseInto___instant-ReadWritableInstant__text-String__position-int",
  "sourceFilePath": "src/main/java/org/joda/time/format/DateTimeFormatter.java",
  "functionAnnotation": "",
  "functionDoc": "Parses a datetime from the given text, at the given position, saving the\nresult into the fields of the given ReadWritableInstant. If the parse\nsucceeds, the return value is the new text position. Note that the parse\nmay succeed without fully reading the text and in this case those fields\nthat were read will be set.\n\u003cp\u003e\nOnly those fields present in the string will be changed in the specified\ninstant. All other fields will remain unaltered. Thus if the string only\ncontains a year and a month, then the day and time will be retained from\nthe input instant. If this is not the behaviour you want, then reset the\nfields before calling this method, or use {@link #parseDateTime(String)}\nor {@link #parseMutableDateTime(String)}.\n\u003cp\u003e\nIf it fails, the return value is negative, but the instant may still be\nmodified. To determine the position where the parse failed, apply the\none\u0027s complement operator (~) on the return value.\n\u003cp\u003e\nThis parse method ignores the {@link #getDefaultYear() default year} and\nparses using the year from the supplied instant as the default.\n\u003cp\u003e\nThe parse will use the chronology of the instant.\n\n@param instant an instant that will be modified, not null\n@param text the text to parse\n@param position position to start parsing from\n@return new position, negative value means parse failed -\n apply complement operator (~) to get position of failure\n@throws UnsupportedOperationException if parsing is not supported\n@throws IllegalArgumentException if the instant is null\n@throws IllegalArgumentException if any field is out of range\n",
  "functionStartLine": 698,
  "functionEndLine": 725,
  "numCommitsSeen": 54,
  "timeTaken": 4092,
  "changeHistory": [
    "706513d59425e7a9dc6bdb972f25b03b02e48558",
    "1ec3c2f0962d41db0d83e01ac5df26d7b954aa34",
    "53eadfbd0ec9d6b4a02dae38730b77b14000c1f3",
    "df4a82f4fb46cc2248280c462e18f08d55a3d112",
    "843d7b8f07f4899ad153ffabc25e09a6c0e897c7",
    "53feb3fa56af7260e607844524b7e5a9be49ecc1",
    "26dc14b0c91afee273ccfb885d6cd3431e2b2bb3",
    "83df500ae8c247c268e4505054aad99ed7df8999",
    "e97bb78797a379a6d0dcdacd37dd87f07677f738",
    "5082337a4152e04ebd8077fd0b7fa28113a4d79e",
    "1707517294d44202e104305e7b0c6fb12dd1a6dd",
    "c6a69cc40dcb388b5ddc3e616064f130ef3608e2",
    "6cad802018b6b82ea4df53aaf91a0bbc98b2f9a3",
    "a26563f0cd1fbdd5587a0f9d3c0c77864553d737",
    "0e07ac6b2cff63550d7df336355ca63cc05aa40b",
    "7fe68f297f7c372b515fde7f0bc8d721ec257ceb"
  ],
  "changeHistoryShort": {
    "706513d59425e7a9dc6bdb972f25b03b02e48558": "Ymultichange(Ybodychange,Ydocchange)",
    "1ec3c2f0962d41db0d83e01ac5df26d7b954aa34": "Ybodychange",
    "53eadfbd0ec9d6b4a02dae38730b77b14000c1f3": "Ybodychange",
    "df4a82f4fb46cc2248280c462e18f08d55a3d112": "Yfilerename",
    "843d7b8f07f4899ad153ffabc25e09a6c0e897c7": "Ybodychange",
    "53feb3fa56af7260e607844524b7e5a9be49ecc1": "Yfilerename",
    "26dc14b0c91afee273ccfb885d6cd3431e2b2bb3": "Ybodychange",
    "83df500ae8c247c268e4505054aad99ed7df8999": "Ybodychange",
    "e97bb78797a379a6d0dcdacd37dd87f07677f738": "Ybodychange",
    "5082337a4152e04ebd8077fd0b7fa28113a4d79e": "Ymultichange(Ymovefromfile,Ybodychange,Ydocchange)",
    "1707517294d44202e104305e7b0c6fb12dd1a6dd": "Ybodychange",
    "c6a69cc40dcb388b5ddc3e616064f130ef3608e2": "Ybodychange",
    "6cad802018b6b82ea4df53aaf91a0bbc98b2f9a3": "Ymultichange(Ymovefromfile,Ybodychange,Yparametermetachange)",
    "a26563f0cd1fbdd5587a0f9d3c0c77864553d737": "Ybodychange",
    "0e07ac6b2cff63550d7df336355ca63cc05aa40b": "Ymultichange(Ybodychange,Yparametermetachange)",
    "7fe68f297f7c372b515fde7f0bc8d721ec257ceb": "Yintroduced"
  },
  "changeHistoryDetails": {
    "706513d59425e7a9dc6bdb972f25b03b02e48558": {
      "type": "Ymultichange(Ybodychange,Ydocchange)",
      "commitMessage": "Fix DateTimeFormatter.parseInto() [3522138]\n\nRevert behaviour back to v1.x when parseInto month/day only\n",
      "commitDate": "4/30/12, 4:14 AM",
      "commitName": "706513d59425e7a9dc6bdb972f25b03b02e48558",
      "commitAuthor": "Stephen Colebourne",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "Fix DateTimeFormatter.parseInto() [3522138]\n\nRevert behaviour back to v1.x when parseInto month/day only\n",
          "commitDate": "4/30/12, 4:14 AM",
          "commitName": "706513d59425e7a9dc6bdb972f25b03b02e48558",
          "commitAuthor": "Stephen Colebourne",
          "commitDateOld": "7/31/11, 3:11 AM",
          "commitNameOld": "1ec3c2f0962d41db0d83e01ac5df26d7b954aa34",
          "commitAuthorOld": "Stephen Colebourne",
          "daysBetweenCommits": 274.04,
          "commitsBetweenForRepo": 40,
          "commitsBetweenForFile": 1,
          "actualSource": "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    DateTimeParser parser \u003d requireParser();\n    if (instant \u003d\u003d null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    long instantMillis \u003d instant.getMillis();\n    Chronology chrono \u003d instant.getChronology();\n    long instantLocal \u003d instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono \u003d selectChronology(chrono);\n    DateTimeParserBucket bucket \u003d new DateTimeParserBucket(instantLocal, chrono, iLocale, iPivotYear, chrono.year().get(instantLocal));\n    int newPos \u003d parser.parseInto(bucket, text, position);\n    instant.setMillis(bucket.computeMillis(false, text));\n    if (iOffsetParsed \u0026\u0026 bucket.getOffsetInteger() !\u003d null) {\n        int parsedOffset \u003d bucket.getOffsetInteger();\n        DateTimeZone parsedZone \u003d DateTimeZone.forOffsetMillis(parsedOffset);\n        chrono \u003d chrono.withZone(parsedZone);\n    } else if (bucket.getZone() !\u003d null) {\n        chrono \u003d chrono.withZone(bucket.getZone());\n    }\n    instant.setChronology(chrono);\n    if (iZone !\u003d null) {\n        instant.setZone(iZone);\n    }\n    return newPos;\n}",
          "path": "src/main/java/org/joda/time/format/DateTimeFormatter.java",
          "functionStartLine": 697,
          "functionName": "parseInto",
          "functionAnnotation": "",
          "functionDoc": "Parses a datetime from the given text, at the given position, saving the\nresult into the fields of the given ReadWritableInstant. If the parse\nsucceeds, the return value is the new text position. Note that the parse\nmay succeed without fully reading the text and in this case those fields\nthat were read will be set.\n\u003cp\u003e\nOnly those fields present in the string will be changed in the specified\ninstant. All other fields will remain unaltered. Thus if the string only\ncontains a year and a month, then the day and time will be retained from\nthe input instant. If this is not the behaviour you want, then reset the\nfields before calling this method, or use {@link #parseDateTime(String)}\nor {@link #parseMutableDateTime(String)}.\n\u003cp\u003e\nIf it fails, the return value is negative, but the instant may still be\nmodified. To determine the position where the parse failed, apply the\none\u0027s complement operator (~) on the return value.\n\u003cp\u003e\nThis parse method ignores the {@link #getDefaultYear() default year} and\nparses using the year from the supplied instant as the default.\n\u003cp\u003e\nThe parse will use the chronology of the instant.\n\n@param instant an instant that will be modified, not null\n@param text the text to parse\n@param position position to start parsing from\n@return new position, negative value means parse failed -\n apply complement operator (~) to get position of failure\n@throws UnsupportedOperationException if parsing is not supported\n@throws IllegalArgumentException if the instant is null\n@throws IllegalArgumentException if any field is out of range\n",
          "diff": "@@ -1,25 +1,25 @@\n public int parseInto(ReadWritableInstant instant, String text, int position) {\n     DateTimeParser parser \u003d requireParser();\n     if (instant \u003d\u003d null) {\n         throw new IllegalArgumentException(\"Instant must not be null\");\n     }\n     long instantMillis \u003d instant.getMillis();\n     Chronology chrono \u003d instant.getChronology();\n     long instantLocal \u003d instantMillis + chrono.getZone().getOffset(instantMillis);\n     chrono \u003d selectChronology(chrono);\n-    DateTimeParserBucket bucket \u003d new DateTimeParserBucket(instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n+    DateTimeParserBucket bucket \u003d new DateTimeParserBucket(instantLocal, chrono, iLocale, iPivotYear, chrono.year().get(instantLocal));\n     int newPos \u003d parser.parseInto(bucket, text, position);\n     instant.setMillis(bucket.computeMillis(false, text));\n     if (iOffsetParsed \u0026\u0026 bucket.getOffsetInteger() !\u003d null) {\n         int parsedOffset \u003d bucket.getOffsetInteger();\n         DateTimeZone parsedZone \u003d DateTimeZone.forOffsetMillis(parsedOffset);\n         chrono \u003d chrono.withZone(parsedZone);\n     } else if (bucket.getZone() !\u003d null) {\n         chrono \u003d chrono.withZone(bucket.getZone());\n     }\n     instant.setChronology(chrono);\n     if (iZone !\u003d null) {\n         instant.setZone(iZone);\n     }\n     return newPos;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Fix DateTimeFormatter.parseInto() [3522138]\n\nRevert behaviour back to v1.x when parseInto month/day only\n",
          "commitDate": "4/30/12, 4:14 AM",
          "commitName": "706513d59425e7a9dc6bdb972f25b03b02e48558",
          "commitAuthor": "Stephen Colebourne",
          "commitDateOld": "7/31/11, 3:11 AM",
          "commitNameOld": "1ec3c2f0962d41db0d83e01ac5df26d7b954aa34",
          "commitAuthorOld": "Stephen Colebourne",
          "daysBetweenCommits": 274.04,
          "commitsBetweenForRepo": 40,
          "commitsBetweenForFile": 1,
          "actualSource": "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    DateTimeParser parser \u003d requireParser();\n    if (instant \u003d\u003d null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    long instantMillis \u003d instant.getMillis();\n    Chronology chrono \u003d instant.getChronology();\n    long instantLocal \u003d instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono \u003d selectChronology(chrono);\n    DateTimeParserBucket bucket \u003d new DateTimeParserBucket(instantLocal, chrono, iLocale, iPivotYear, chrono.year().get(instantLocal));\n    int newPos \u003d parser.parseInto(bucket, text, position);\n    instant.setMillis(bucket.computeMillis(false, text));\n    if (iOffsetParsed \u0026\u0026 bucket.getOffsetInteger() !\u003d null) {\n        int parsedOffset \u003d bucket.getOffsetInteger();\n        DateTimeZone parsedZone \u003d DateTimeZone.forOffsetMillis(parsedOffset);\n        chrono \u003d chrono.withZone(parsedZone);\n    } else if (bucket.getZone() !\u003d null) {\n        chrono \u003d chrono.withZone(bucket.getZone());\n    }\n    instant.setChronology(chrono);\n    if (iZone !\u003d null) {\n        instant.setZone(iZone);\n    }\n    return newPos;\n}",
          "path": "src/main/java/org/joda/time/format/DateTimeFormatter.java",
          "functionStartLine": 697,
          "functionName": "parseInto",
          "functionAnnotation": "",
          "functionDoc": "Parses a datetime from the given text, at the given position, saving the\nresult into the fields of the given ReadWritableInstant. If the parse\nsucceeds, the return value is the new text position. Note that the parse\nmay succeed without fully reading the text and in this case those fields\nthat were read will be set.\n\u003cp\u003e\nOnly those fields present in the string will be changed in the specified\ninstant. All other fields will remain unaltered. Thus if the string only\ncontains a year and a month, then the day and time will be retained from\nthe input instant. If this is not the behaviour you want, then reset the\nfields before calling this method, or use {@link #parseDateTime(String)}\nor {@link #parseMutableDateTime(String)}.\n\u003cp\u003e\nIf it fails, the return value is negative, but the instant may still be\nmodified. To determine the position where the parse failed, apply the\none\u0027s complement operator (~) on the return value.\n\u003cp\u003e\nThis parse method ignores the {@link #getDefaultYear() default year} and\nparses using the year from the supplied instant as the default.\n\u003cp\u003e\nThe parse will use the chronology of the instant.\n\n@param instant an instant that will be modified, not null\n@param text the text to parse\n@param position position to start parsing from\n@return new position, negative value means parse failed -\n apply complement operator (~) to get position of failure\n@throws UnsupportedOperationException if parsing is not supported\n@throws IllegalArgumentException if the instant is null\n@throws IllegalArgumentException if any field is out of range\n",
          "diff": "@@ -1,25 +1,25 @@\n public int parseInto(ReadWritableInstant instant, String text, int position) {\n     DateTimeParser parser \u003d requireParser();\n     if (instant \u003d\u003d null) {\n         throw new IllegalArgumentException(\"Instant must not be null\");\n     }\n     long instantMillis \u003d instant.getMillis();\n     Chronology chrono \u003d instant.getChronology();\n     long instantLocal \u003d instantMillis + chrono.getZone().getOffset(instantMillis);\n     chrono \u003d selectChronology(chrono);\n-    DateTimeParserBucket bucket \u003d new DateTimeParserBucket(instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n+    DateTimeParserBucket bucket \u003d new DateTimeParserBucket(instantLocal, chrono, iLocale, iPivotYear, chrono.year().get(instantLocal));\n     int newPos \u003d parser.parseInto(bucket, text, position);\n     instant.setMillis(bucket.computeMillis(false, text));\n     if (iOffsetParsed \u0026\u0026 bucket.getOffsetInteger() !\u003d null) {\n         int parsedOffset \u003d bucket.getOffsetInteger();\n         DateTimeZone parsedZone \u003d DateTimeZone.forOffsetMillis(parsedOffset);\n         chrono \u003d chrono.withZone(parsedZone);\n     } else if (bucket.getZone() !\u003d null) {\n         chrono \u003d chrono.withZone(bucket.getZone());\n     }\n     instant.setChronology(chrono);\n     if (iZone !\u003d null) {\n         instant.setZone(iZone);\n     }\n     return newPos;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Parses a datetime from the given text, at the given position, saving the\nresult into the fields of the given ReadWritableInstant. If the parse\nsucceeds, the return value is the new text position. Note that the parse\nmay succeed without fully reading the text and in this case those fields\nthat were read will be set.\n\u003cp\u003e\nOnly those fields present in the string will be changed in the specified\ninstant. All other fields will remain unaltered. Thus if the string only\ncontains a year and a month, then the day and time will be retained from\nthe input instant. If this is not the behaviour you want, then reset the\nfields before calling this method, or use {@link #parseDateTime(String)}\nor {@link #parseMutableDateTime(String)}.\n\u003cp\u003e\nIf it fails, the return value is negative, but the instant may still be\nmodified. To determine the position where the parse failed, apply the\none\u0027s complement operator (~) on the return value.\n\u003cp\u003e\nThe parse will use the chronology of the instant.\n\n@param instant an instant that will be modified, not null\n@param text the text to parse\n@param position position to start parsing from\n@return new position, negative value means parse failed -\n apply complement operator (~) to get position of failure\n@throws UnsupportedOperationException if parsing is not supported\n@throws IllegalArgumentException if the instant is null\n@throws IllegalArgumentException if any field is out of range\n",
            "newValue": "Parses a datetime from the given text, at the given position, saving the\nresult into the fields of the given ReadWritableInstant. If the parse\nsucceeds, the return value is the new text position. Note that the parse\nmay succeed without fully reading the text and in this case those fields\nthat were read will be set.\n\u003cp\u003e\nOnly those fields present in the string will be changed in the specified\ninstant. All other fields will remain unaltered. Thus if the string only\ncontains a year and a month, then the day and time will be retained from\nthe input instant. If this is not the behaviour you want, then reset the\nfields before calling this method, or use {@link #parseDateTime(String)}\nor {@link #parseMutableDateTime(String)}.\n\u003cp\u003e\nIf it fails, the return value is negative, but the instant may still be\nmodified. To determine the position where the parse failed, apply the\none\u0027s complement operator (~) on the return value.\n\u003cp\u003e\nThis parse method ignores the {@link #getDefaultYear() default year} and\nparses using the year from the supplied instant as the default.\n\u003cp\u003e\nThe parse will use the chronology of the instant.\n\n@param instant an instant that will be modified, not null\n@param text the text to parse\n@param position position to start parsing from\n@return new position, negative value means parse failed -\n apply complement operator (~) to get position of failure\n@throws UnsupportedOperationException if parsing is not supported\n@throws IllegalArgumentException if the instant is null\n@throws IllegalArgumentException if any field is out of range\n"
          }
        }
      ]
    },
    "1ec3c2f0962d41db0d83e01ac5df26d7b954aa34": {
      "type": "Ybodychange",
      "commitMessage": "Support parsing of date-time zone names like BST or British Summer Time\n\nFix code to avoid source and binary incompatibility\n",
      "commitDate": "7/31/11, 3:11 AM",
      "commitName": "1ec3c2f0962d41db0d83e01ac5df26d7b954aa34",
      "commitAuthor": "Stephen Colebourne",
      "commitDateOld": "7/31/11, 3:03 AM",
      "commitNameOld": "3ea62678a6497af61932df9b8e1b5c06d90df116",
      "commitAuthorOld": "Stephen Colebourne",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    DateTimeParser parser \u003d requireParser();\n    if (instant \u003d\u003d null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    long instantMillis \u003d instant.getMillis();\n    Chronology chrono \u003d instant.getChronology();\n    long instantLocal \u003d instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono \u003d selectChronology(chrono);\n    DateTimeParserBucket bucket \u003d new DateTimeParserBucket(instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos \u003d parser.parseInto(bucket, text, position);\n    instant.setMillis(bucket.computeMillis(false, text));\n    if (iOffsetParsed \u0026\u0026 bucket.getOffsetInteger() !\u003d null) {\n        int parsedOffset \u003d bucket.getOffsetInteger();\n        DateTimeZone parsedZone \u003d DateTimeZone.forOffsetMillis(parsedOffset);\n        chrono \u003d chrono.withZone(parsedZone);\n    } else if (bucket.getZone() !\u003d null) {\n        chrono \u003d chrono.withZone(bucket.getZone());\n    }\n    instant.setChronology(chrono);\n    if (iZone !\u003d null) {\n        instant.setZone(iZone);\n    }\n    return newPos;\n}",
      "path": "src/main/java/org/joda/time/format/DateTimeFormatter.java",
      "functionStartLine": 693,
      "functionName": "parseInto",
      "functionAnnotation": "",
      "functionDoc": "Parses a datetime from the given text, at the given position, saving the\nresult into the fields of the given ReadWritableInstant. If the parse\nsucceeds, the return value is the new text position. Note that the parse\nmay succeed without fully reading the text and in this case those fields\nthat were read will be set.\n\u003cp\u003e\nOnly those fields present in the string will be changed in the specified\ninstant. All other fields will remain unaltered. Thus if the string only\ncontains a year and a month, then the day and time will be retained from\nthe input instant. If this is not the behaviour you want, then reset the\nfields before calling this method, or use {@link #parseDateTime(String)}\nor {@link #parseMutableDateTime(String)}.\n\u003cp\u003e\nIf it fails, the return value is negative, but the instant may still be\nmodified. To determine the position where the parse failed, apply the\none\u0027s complement operator (~) on the return value.\n\u003cp\u003e\nThe parse will use the chronology of the instant.\n\n@param instant an instant that will be modified, not null\n@param text the text to parse\n@param position position to start parsing from\n@return new position, negative value means parse failed -\n apply complement operator (~) to get position of failure\n@throws UnsupportedOperationException if parsing is not supported\n@throws IllegalArgumentException if the instant is null\n@throws IllegalArgumentException if any field is out of range\n",
      "diff": "@@ -1,25 +1,25 @@\n public int parseInto(ReadWritableInstant instant, String text, int position) {\n     DateTimeParser parser \u003d requireParser();\n     if (instant \u003d\u003d null) {\n         throw new IllegalArgumentException(\"Instant must not be null\");\n     }\n     long instantMillis \u003d instant.getMillis();\n     Chronology chrono \u003d instant.getChronology();\n     long instantLocal \u003d instantMillis + chrono.getZone().getOffset(instantMillis);\n     chrono \u003d selectChronology(chrono);\n     DateTimeParserBucket bucket \u003d new DateTimeParserBucket(instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n     int newPos \u003d parser.parseInto(bucket, text, position);\n     instant.setMillis(bucket.computeMillis(false, text));\n-    if (iOffsetParsed \u0026\u0026 bucket.getOffset() !\u003d null) {\n-        int parsedOffset \u003d bucket.getOffset();\n+    if (iOffsetParsed \u0026\u0026 bucket.getOffsetInteger() !\u003d null) {\n+        int parsedOffset \u003d bucket.getOffsetInteger();\n         DateTimeZone parsedZone \u003d DateTimeZone.forOffsetMillis(parsedOffset);\n         chrono \u003d chrono.withZone(parsedZone);\n     } else if (bucket.getZone() !\u003d null) {\n         chrono \u003d chrono.withZone(bucket.getZone());\n     }\n     instant.setChronology(chrono);\n     if (iZone !\u003d null) {\n         instant.setZone(iZone);\n     }\n     return newPos;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "53eadfbd0ec9d6b4a02dae38730b77b14000c1f3": {
      "type": "Ybodychange",
      "commitMessage": "Support parsing of date-time zone IDs like Europe/London\n",
      "commitDate": "7/30/11, 4:48 AM",
      "commitName": "53eadfbd0ec9d6b4a02dae38730b77b14000c1f3",
      "commitAuthor": "Stephen Colebourne",
      "commitDateOld": "5/16/11, 10:02 AM",
      "commitNameOld": "df4a82f4fb46cc2248280c462e18f08d55a3d112",
      "commitAuthorOld": "Stephen Colebourne",
      "daysBetweenCommits": 74.78,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "actualSource": "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    DateTimeParser parser \u003d requireParser();\n    if (instant \u003d\u003d null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    long instantMillis \u003d instant.getMillis();\n    Chronology chrono \u003d instant.getChronology();\n    long instantLocal \u003d instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono \u003d selectChronology(chrono);\n    DateTimeParserBucket bucket \u003d new DateTimeParserBucket(instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos \u003d parser.parseInto(bucket, text, position);\n    instant.setMillis(bucket.computeMillis(false, text));\n    if (iOffsetParsed \u0026\u0026 bucket.getOffset() !\u003d null) {\n        int parsedOffset \u003d bucket.getOffset();\n        DateTimeZone parsedZone \u003d DateTimeZone.forOffsetMillis(parsedOffset);\n        chrono \u003d chrono.withZone(parsedZone);\n    } else if (bucket.getZone() !\u003d null) {\n        chrono \u003d chrono.withZone(bucket.getZone());\n    }\n    instant.setChronology(chrono);\n    if (iZone !\u003d null) {\n        instant.setZone(iZone);\n    }\n    return newPos;\n}",
      "path": "src/main/java/org/joda/time/format/DateTimeFormatter.java",
      "functionStartLine": 692,
      "functionName": "parseInto",
      "functionAnnotation": "",
      "functionDoc": "Parses a datetime from the given text, at the given position, saving the\nresult into the fields of the given ReadWritableInstant. If the parse\nsucceeds, the return value is the new text position. Note that the parse\nmay succeed without fully reading the text and in this case those fields\nthat were read will be set.\n\u003cp\u003e\nOnly those fields present in the string will be changed in the specified\ninstant. All other fields will remain unaltered. Thus if the string only\ncontains a year and a month, then the day and time will be retained from\nthe input instant. If this is not the behaviour you want, then reset the\nfields before calling this method, or use {@link #parseDateTime(String)}\nor {@link #parseMutableDateTime(String)}.\n\u003cp\u003e\nIf it fails, the return value is negative, but the instant may still be\nmodified. To determine the position where the parse failed, apply the\none\u0027s complement operator (~) on the return value.\n\u003cp\u003e\nThe parse will use the chronology of the instant.\n\n@param instant an instant that will be modified, not null\n@param text the text to parse\n@param position position to start parsing from\n@return new position, negative value means parse failed -\n apply complement operator (~) to get position of failure\n@throws UnsupportedOperationException if parsing is not supported\n@throws IllegalArgumentException if the instant is null\n@throws IllegalArgumentException if any field is out of range\n",
      "diff": "@@ -1,20 +1,25 @@\n public int parseInto(ReadWritableInstant instant, String text, int position) {\n     DateTimeParser parser \u003d requireParser();\n     if (instant \u003d\u003d null) {\n         throw new IllegalArgumentException(\"Instant must not be null\");\n     }\n     long instantMillis \u003d instant.getMillis();\n     Chronology chrono \u003d instant.getChronology();\n     long instantLocal \u003d instantMillis + chrono.getZone().getOffset(instantMillis);\n     chrono \u003d selectChronology(chrono);\n     DateTimeParserBucket bucket \u003d new DateTimeParserBucket(instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n     int newPos \u003d parser.parseInto(bucket, text, position);\n     instant.setMillis(bucket.computeMillis(false, text));\n-    if (iOffsetParsed \u0026\u0026 bucket.getZone() \u003d\u003d null) {\n+    if (iOffsetParsed \u0026\u0026 bucket.getOffset() !\u003d null) {\n         int parsedOffset \u003d bucket.getOffset();\n         DateTimeZone parsedZone \u003d DateTimeZone.forOffsetMillis(parsedOffset);\n         chrono \u003d chrono.withZone(parsedZone);\n+    } else if (bucket.getZone() !\u003d null) {\n+        chrono \u003d chrono.withZone(bucket.getZone());\n     }\n     instant.setChronology(chrono);\n+    if (iZone !\u003d null) {\n+        instant.setZone(iZone);\n+    }\n     return newPos;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "df4a82f4fb46cc2248280c462e18f08d55a3d112": {
      "type": "Yfilerename",
      "commitMessage": "Remove JodaTime folder moving files to top level\n",
      "commitDate": "5/16/11, 10:02 AM",
      "commitName": "df4a82f4fb46cc2248280c462e18f08d55a3d112",
      "commitAuthor": "Stephen Colebourne",
      "commitDateOld": "5/16/11, 9:58 AM",
      "commitNameOld": "72b22654962284bac59c2777131b42a2d1f53228",
      "commitAuthorOld": "Stephen Colebourne",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    DateTimeParser parser \u003d requireParser();\n    if (instant \u003d\u003d null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    long instantMillis \u003d instant.getMillis();\n    Chronology chrono \u003d instant.getChronology();\n    long instantLocal \u003d instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono \u003d selectChronology(chrono);\n    DateTimeParserBucket bucket \u003d new DateTimeParserBucket(instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos \u003d parser.parseInto(bucket, text, position);\n    instant.setMillis(bucket.computeMillis(false, text));\n    if (iOffsetParsed \u0026\u0026 bucket.getZone() \u003d\u003d null) {\n        int parsedOffset \u003d bucket.getOffset();\n        DateTimeZone parsedZone \u003d DateTimeZone.forOffsetMillis(parsedOffset);\n        chrono \u003d chrono.withZone(parsedZone);\n    }\n    instant.setChronology(chrono);\n    return newPos;\n}",
      "path": "src/main/java/org/joda/time/format/DateTimeFormatter.java",
      "functionStartLine": 692,
      "functionName": "parseInto",
      "functionAnnotation": "",
      "functionDoc": "Parses a datetime from the given text, at the given position, saving the\nresult into the fields of the given ReadWritableInstant. If the parse\nsucceeds, the return value is the new text position. Note that the parse\nmay succeed without fully reading the text and in this case those fields\nthat were read will be set.\n\u003cp\u003e\nOnly those fields present in the string will be changed in the specified\ninstant. All other fields will remain unaltered. Thus if the string only\ncontains a year and a month, then the day and time will be retained from\nthe input instant. If this is not the behaviour you want, then reset the\nfields before calling this method, or use {@link #parseDateTime(String)}\nor {@link #parseMutableDateTime(String)}.\n\u003cp\u003e\nIf it fails, the return value is negative, but the instant may still be\nmodified. To determine the position where the parse failed, apply the\none\u0027s complement operator (~) on the return value.\n\u003cp\u003e\nThe parse will use the chronology of the instant.\n\n@param instant an instant that will be modified, not null\n@param text the text to parse\n@param position position to start parsing from\n@return new position, negative value means parse failed -\n apply complement operator (~) to get position of failure\n@throws UnsupportedOperationException if parsing is not supported\n@throws IllegalArgumentException if the instant is null\n@throws IllegalArgumentException if any field is out of range\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "JodaTime/src/main/java/org/joda/time/format/DateTimeFormatter.java",
        "newPath": "src/main/java/org/joda/time/format/DateTimeFormatter.java"
      }
    },
    "843d7b8f07f4899ad153ffabc25e09a6c0e897c7": {
      "type": "Ybodychange",
      "commitMessage": "Parse month-day in year 2000 instead of 1970 to parse Feb 29\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@1591 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1\n",
      "commitDate": "11/18/10, 11:26 AM",
      "commitName": "843d7b8f07f4899ad153ffabc25e09a6c0e897c7",
      "commitAuthor": "Stephen Colebourne",
      "commitDateOld": "11/13/10, 3:33 AM",
      "commitNameOld": "73cf859dd13b3fc550569e2dff75da8cca8ddbfa",
      "commitAuthorOld": "Stephen Colebourne",
      "daysBetweenCommits": 5.33,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    DateTimeParser parser \u003d requireParser();\n    if (instant \u003d\u003d null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    long instantMillis \u003d instant.getMillis();\n    Chronology chrono \u003d instant.getChronology();\n    long instantLocal \u003d instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono \u003d selectChronology(chrono);\n    DateTimeParserBucket bucket \u003d new DateTimeParserBucket(instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos \u003d parser.parseInto(bucket, text, position);\n    instant.setMillis(bucket.computeMillis(false, text));\n    if (iOffsetParsed \u0026\u0026 bucket.getZone() \u003d\u003d null) {\n        int parsedOffset \u003d bucket.getOffset();\n        DateTimeZone parsedZone \u003d DateTimeZone.forOffsetMillis(parsedOffset);\n        chrono \u003d chrono.withZone(parsedZone);\n    }\n    instant.setChronology(chrono);\n    return newPos;\n}",
      "path": "JodaTime/src/main/java/org/joda/time/format/DateTimeFormatter.java",
      "functionStartLine": 692,
      "functionName": "parseInto",
      "functionAnnotation": "",
      "functionDoc": "Parses a datetime from the given text, at the given position, saving the\nresult into the fields of the given ReadWritableInstant. If the parse\nsucceeds, the return value is the new text position. Note that the parse\nmay succeed without fully reading the text and in this case those fields\nthat were read will be set.\n\u003cp\u003e\nOnly those fields present in the string will be changed in the specified\ninstant. All other fields will remain unaltered. Thus if the string only\ncontains a year and a month, then the day and time will be retained from\nthe input instant. If this is not the behaviour you want, then reset the\nfields before calling this method, or use {@link #parseDateTime(String)}\nor {@link #parseMutableDateTime(String)}.\n\u003cp\u003e\nIf it fails, the return value is negative, but the instant may still be\nmodified. To determine the position where the parse failed, apply the\none\u0027s complement operator (~) on the return value.\n\u003cp\u003e\nThe parse will use the chronology of the instant.\n\n@param instant an instant that will be modified, not null\n@param text the text to parse\n@param position position to start parsing from\n@return new position, negative value means parse failed -\n apply complement operator (~) to get position of failure\n@throws UnsupportedOperationException if parsing is not supported\n@throws IllegalArgumentException if the instant is null\n@throws IllegalArgumentException if any field is out of range\n",
      "diff": "@@ -1,20 +1,20 @@\n public int parseInto(ReadWritableInstant instant, String text, int position) {\n     DateTimeParser parser \u003d requireParser();\n     if (instant \u003d\u003d null) {\n         throw new IllegalArgumentException(\"Instant must not be null\");\n     }\n     long instantMillis \u003d instant.getMillis();\n     Chronology chrono \u003d instant.getChronology();\n     long instantLocal \u003d instantMillis + chrono.getZone().getOffset(instantMillis);\n     chrono \u003d selectChronology(chrono);\n-    DateTimeParserBucket bucket \u003d new DateTimeParserBucket(instantLocal, chrono, iLocale, iPivotYear);\n+    DateTimeParserBucket bucket \u003d new DateTimeParserBucket(instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n     int newPos \u003d parser.parseInto(bucket, text, position);\n     instant.setMillis(bucket.computeMillis(false, text));\n     if (iOffsetParsed \u0026\u0026 bucket.getZone() \u003d\u003d null) {\n         int parsedOffset \u003d bucket.getOffset();\n         DateTimeZone parsedZone \u003d DateTimeZone.forOffsetMillis(parsedOffset);\n         chrono \u003d chrono.withZone(parsedZone);\n     }\n     instant.setChronology(chrono);\n     return newPos;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "53feb3fa56af7260e607844524b7e5a9be49ecc1": {
      "type": "Yfilerename",
      "commitMessage": "Convert to maven 2\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@1540 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1\n",
      "commitDate": "8/8/10, 5:17 PM",
      "commitName": "53feb3fa56af7260e607844524b7e5a9be49ecc1",
      "commitAuthor": "Stephen Colebourne",
      "commitDateOld": "8/8/10, 5:02 PM",
      "commitNameOld": "7fa2ceaf5d95d050095432aa646ea803aa35e122",
      "commitAuthorOld": "Stephen Colebourne",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    DateTimeParser parser \u003d requireParser();\n    if (instant \u003d\u003d null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    long instantMillis \u003d instant.getMillis();\n    Chronology chrono \u003d instant.getChronology();\n    long instantLocal \u003d instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono \u003d selectChronology(chrono);\n    DateTimeParserBucket bucket \u003d new DateTimeParserBucket(instantLocal, chrono, iLocale, iPivotYear);\n    int newPos \u003d parser.parseInto(bucket, text, position);\n    instant.setMillis(bucket.computeMillis(false, text));\n    if (iOffsetParsed \u0026\u0026 bucket.getZone() \u003d\u003d null) {\n        int parsedOffset \u003d bucket.getOffset();\n        DateTimeZone parsedZone \u003d DateTimeZone.forOffsetMillis(parsedOffset);\n        chrono \u003d chrono.withZone(parsedZone);\n    }\n    instant.setChronology(chrono);\n    return newPos;\n}",
      "path": "JodaTime/src/main/java/org/joda/time/format/DateTimeFormatter.java",
      "functionStartLine": 654,
      "functionName": "parseInto",
      "functionAnnotation": "",
      "functionDoc": "Parses a datetime from the given text, at the given position, saving the\nresult into the fields of the given ReadWritableInstant. If the parse\nsucceeds, the return value is the new text position. Note that the parse\nmay succeed without fully reading the text and in this case those fields\nthat were read will be set.\n\u003cp\u003e\nOnly those fields present in the string will be changed in the specified\ninstant. All other fields will remain unaltered. Thus if the string only\ncontains a year and a month, then the day and time will be retained from\nthe input instant. If this is not the behaviour you want, then reset the\nfields before calling this method, or use {@link #parseDateTime(String)}\nor {@link #parseMutableDateTime(String)}.\n\u003cp\u003e\nIf it fails, the return value is negative, but the instant may still be\nmodified. To determine the position where the parse failed, apply the\none\u0027s complement operator (~) on the return value.\n\u003cp\u003e\nThe parse will use the chronology of the instant.\n\n@param instant an instant that will be modified, not null\n@param text the text to parse\n@param position position to start parsing from\n@return new position, negative value means parse failed -\n apply complement operator (~) to get position of failure\n@throws UnsupportedOperationException if parsing is not supported\n@throws IllegalArgumentException if the instant is null\n@throws IllegalArgumentException if any field is out of range\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "JodaTime/src/java/org/joda/time/format/DateTimeFormatter.java",
        "newPath": "JodaTime/src/main/java/org/joda/time/format/DateTimeFormatter.java"
      }
    },
    "26dc14b0c91afee273ccfb885d6cd3431e2b2bb3": {
      "type": "Ybodychange",
      "commitMessage": "Eliminate redundant checks.\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@1249 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1\n",
      "commitDate": "9/9/07, 10:49 AM",
      "commitName": "26dc14b0c91afee273ccfb885d6cd3431e2b2bb3",
      "commitAuthor": "Brian S O\u0027Neill",
      "commitDateOld": "3/26/06, 3:41 PM",
      "commitNameOld": "83df500ae8c247c268e4505054aad99ed7df8999",
      "commitAuthorOld": "Brian S O\u0027Neill",
      "daysBetweenCommits": 531.76,
      "commitsBetweenForRepo": 193,
      "commitsBetweenForFile": 1,
      "actualSource": "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    DateTimeParser parser \u003d requireParser();\n    if (instant \u003d\u003d null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    long instantMillis \u003d instant.getMillis();\n    Chronology chrono \u003d instant.getChronology();\n    long instantLocal \u003d instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono \u003d selectChronology(chrono);\n    DateTimeParserBucket bucket \u003d new DateTimeParserBucket(instantLocal, chrono, iLocale, iPivotYear);\n    int newPos \u003d parser.parseInto(bucket, text, position);\n    instant.setMillis(bucket.computeMillis(false, text));\n    if (iOffsetParsed \u0026\u0026 bucket.getZone() \u003d\u003d null) {\n        int parsedOffset \u003d bucket.getOffset();\n        DateTimeZone parsedZone \u003d DateTimeZone.forOffsetMillis(parsedOffset);\n        chrono \u003d chrono.withZone(parsedZone);\n    }\n    instant.setChronology(chrono);\n    return newPos;\n}",
      "path": "JodaTime/src/java/org/joda/time/format/DateTimeFormatter.java",
      "functionStartLine": 585,
      "functionName": "parseInto",
      "functionAnnotation": "",
      "functionDoc": "Parses a datetime from the given text, at the given position, saving the\nresult into the fields of the given ReadWritableInstant. If the parse\nsucceeds, the return value is the new text position. Note that the parse\nmay succeed without fully reading the text and in this case those fields\nthat were read will be set.\n\u003cp\u003e\nOnly those fields present in the string will be changed in the specified\ninstant. All other fields will remain unaltered. Thus if the string only\ncontains a year and a month, then the day and time will be retained from\nthe input instant. If this is not the behaviour you want, then reset the\nfields before calling this method, or use {@link #parseDateTime(String)}\nor {@link #parseMutableDateTime(String)}.\n\u003cp\u003e\nIf it fails, the return value is negative, but the instant may still be\nmodified. To determine the position where the parse failed, apply the\none\u0027s complement operator (~) on the return value.\n\u003cp\u003e\nThe parse will use the chronology of the instant.\n\n@param instant an instant that will be modified, not null\n@param text the text to parse\n@param position position to start parsing from\n@return new position, negative value means parse failed -\n apply complement operator (~) to get position of failure\n@throws UnsupportedOperationException if parsing is not supported\n@throws IllegalArgumentException if the instant is null\n@throws IllegalArgumentException if any field is out of range\n",
      "diff": "@@ -1,20 +1,20 @@\n public int parseInto(ReadWritableInstant instant, String text, int position) {\n-    checkParser();\n+    DateTimeParser parser \u003d requireParser();\n     if (instant \u003d\u003d null) {\n         throw new IllegalArgumentException(\"Instant must not be null\");\n     }\n     long instantMillis \u003d instant.getMillis();\n     Chronology chrono \u003d instant.getChronology();\n     long instantLocal \u003d instantMillis + chrono.getZone().getOffset(instantMillis);\n     chrono \u003d selectChronology(chrono);\n     DateTimeParserBucket bucket \u003d new DateTimeParserBucket(instantLocal, chrono, iLocale, iPivotYear);\n-    int newPos \u003d iParser.parseInto(bucket, text, position);\n+    int newPos \u003d parser.parseInto(bucket, text, position);\n     instant.setMillis(bucket.computeMillis(false, text));\n     if (iOffsetParsed \u0026\u0026 bucket.getZone() \u003d\u003d null) {\n         int parsedOffset \u003d bucket.getOffset();\n         DateTimeZone parsedZone \u003d DateTimeZone.forOffsetMillis(parsedOffset);\n         chrono \u003d chrono.withZone(parsedZone);\n     }\n     instant.setChronology(chrono);\n     return newPos;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "83df500ae8c247c268e4505054aad99ed7df8999": {
      "type": "Ybodychange",
      "commitMessage": "If a parsed datetime is illegal due to field range or time zone offset transition, thrown exception includes text of datetime being parsed.\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@1052 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1\n",
      "commitDate": "3/26/06, 3:41 PM",
      "commitName": "83df500ae8c247c268e4505054aad99ed7df8999",
      "commitAuthor": "Brian S O\u0027Neill",
      "commitDateOld": "9/7/05, 11:54 AM",
      "commitNameOld": "37ea1f66a344bd315e101a31d55ccf0d64b37f6a",
      "commitAuthorOld": "Brian S O\u0027Neill",
      "daysBetweenCommits": 200.2,
      "commitsBetweenForRepo": 145,
      "commitsBetweenForFile": 1,
      "actualSource": "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    checkParser();\n    if (instant \u003d\u003d null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    long instantMillis \u003d instant.getMillis();\n    Chronology chrono \u003d instant.getChronology();\n    long instantLocal \u003d instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono \u003d selectChronology(chrono);\n    DateTimeParserBucket bucket \u003d new DateTimeParserBucket(instantLocal, chrono, iLocale, iPivotYear);\n    int newPos \u003d iParser.parseInto(bucket, text, position);\n    instant.setMillis(bucket.computeMillis(false, text));\n    if (iOffsetParsed \u0026\u0026 bucket.getZone() \u003d\u003d null) {\n        int parsedOffset \u003d bucket.getOffset();\n        DateTimeZone parsedZone \u003d DateTimeZone.forOffsetMillis(parsedOffset);\n        chrono \u003d chrono.withZone(parsedZone);\n    }\n    instant.setChronology(chrono);\n    return newPos;\n}",
      "path": "JodaTime/src/java/org/joda/time/format/DateTimeFormatter.java",
      "functionStartLine": 595,
      "functionName": "parseInto",
      "functionAnnotation": "",
      "functionDoc": "Parses a datetime from the given text, at the given position, saving the\nresult into the fields of the given ReadWritableInstant. If the parse\nsucceeds, the return value is the new text position. Note that the parse\nmay succeed without fully reading the text and in this case those fields\nthat were read will be set.\n\u003cp\u003e\nOnly those fields present in the string will be changed in the specified\ninstant. All other fields will remain unaltered. Thus if the string only\ncontains a year and a month, then the day and time will be retained from\nthe input instant. If this is not the behaviour you want, then reset the\nfields before calling this method, or use {@link #parseDateTime(String)}\nor {@link #parseMutableDateTime(String)}.\n\u003cp\u003e\nIf it fails, the return value is negative, but the instant may still be\nmodified. To determine the position where the parse failed, apply the\none\u0027s complement operator (~) on the return value.\n\u003cp\u003e\nThe parse will use the chronology of the instant.\n\n@param instant an instant that will be modified, not null\n@param text the text to parse\n@param position position to start parsing from\n@return new position, negative value means parse failed -\n apply complement operator (~) to get position of failure\n@throws UnsupportedOperationException if parsing is not supported\n@throws IllegalArgumentException if the instant is null\n@throws IllegalArgumentException if any field is out of range\n",
      "diff": "@@ -1,20 +1,20 @@\n public int parseInto(ReadWritableInstant instant, String text, int position) {\n     checkParser();\n     if (instant \u003d\u003d null) {\n         throw new IllegalArgumentException(\"Instant must not be null\");\n     }\n     long instantMillis \u003d instant.getMillis();\n     Chronology chrono \u003d instant.getChronology();\n     long instantLocal \u003d instantMillis + chrono.getZone().getOffset(instantMillis);\n     chrono \u003d selectChronology(chrono);\n     DateTimeParserBucket bucket \u003d new DateTimeParserBucket(instantLocal, chrono, iLocale, iPivotYear);\n     int newPos \u003d iParser.parseInto(bucket, text, position);\n-    instant.setMillis(bucket.computeMillis());\n+    instant.setMillis(bucket.computeMillis(false, text));\n     if (iOffsetParsed \u0026\u0026 bucket.getZone() \u003d\u003d null) {\n         int parsedOffset \u003d bucket.getOffset();\n         DateTimeZone parsedZone \u003d DateTimeZone.forOffsetMillis(parsedOffset);\n         chrono \u003d chrono.withZone(parsedZone);\n     }\n     instant.setChronology(chrono);\n     return newPos;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e97bb78797a379a6d0dcdacd37dd87f07677f738": {
      "type": "Ybodychange",
      "commitMessage": "Add DateTimeFormatter.withPivotYear to handle pattern pivot control\nfrom Fredrik Borgh\n\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@737 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1\n",
      "commitDate": "3/5/05, 10:27 AM",
      "commitName": "e97bb78797a379a6d0dcdacd37dd87f07677f738",
      "commitAuthor": "Stephen Colebourne",
      "commitDateOld": "2/17/05, 4:08 PM",
      "commitNameOld": "ad1be7578f5822b29a3b14149f462298d6b5553d",
      "commitAuthorOld": "Stephen Colebourne",
      "daysBetweenCommits": 15.76,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "actualSource": "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    checkParser();\n    if (instant \u003d\u003d null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    long instantMillis \u003d instant.getMillis();\n    Chronology chrono \u003d instant.getChronology();\n    long instantLocal \u003d instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono \u003d selectChronology(chrono);\n    DateTimeParserBucket bucket \u003d new DateTimeParserBucket(instantLocal, chrono, iLocale, iPivotYear);\n    int newPos \u003d iParser.parseInto(bucket, text, position);\n    instant.setMillis(bucket.computeMillis());\n    if (iOffsetParsed \u0026\u0026 bucket.getZone() \u003d\u003d null) {\n        int parsedOffset \u003d bucket.getOffset();\n        DateTimeZone parsedZone \u003d DateTimeZone.forOffsetMillis(parsedOffset);\n        chrono \u003d chrono.withZone(parsedZone);\n    }\n    instant.setChronology(chrono);\n    return newPos;\n}",
      "path": "JodaTime/src/java/org/joda/time/format/DateTimeFormatter.java",
      "functionStartLine": 548,
      "functionName": "parseInto",
      "functionAnnotation": "",
      "functionDoc": "Parses a datetime from the given text, at the given position, saving the\nresult into the fields of the given ReadWritableInstant. If the parse\nsucceeds, the return value is the new text position. Note that the parse\nmay succeed without fully reading the text and in this case those fields\nthat were read will be set.\n\u003cp\u003e\nOnly those fields present in the string will be changed in the specified\ninstant. All other fields will remain unaltered. Thus if the string only\ncontains a year and a month, then the day and time will be retained from\nthe input instant. If this is not the behaviour you want, then reset the\nfields before calling this method, or use {@link #parseDateTime(String)}\nor {@link #parseMutableDateTime(String)}.\n\u003cp\u003e\nIf it fails, the return value is negative, but the instant may still be\nmodified. To determine the position where the parse failed, apply the\none\u0027s complement operator (~) on the return value.\n\u003cp\u003e\nThe parse will use the chronology of the instant.\n\n@param instant an instant that will be modified, not null\n@param text the text to parse\n@param position position to start parsing from\n@return new position, negative value means parse failed -\n apply complement operator (~) to get position of failure\n@throws UnsupportedOperationException if parsing is not supported\n@throws IllegalArgumentException if the instant is null\n@throws IllegalArgumentException if any field is out of range\n",
      "diff": "@@ -1,20 +1,20 @@\n public int parseInto(ReadWritableInstant instant, String text, int position) {\n     checkParser();\n     if (instant \u003d\u003d null) {\n         throw new IllegalArgumentException(\"Instant must not be null\");\n     }\n     long instantMillis \u003d instant.getMillis();\n     Chronology chrono \u003d instant.getChronology();\n     long instantLocal \u003d instantMillis + chrono.getZone().getOffset(instantMillis);\n     chrono \u003d selectChronology(chrono);\n-    DateTimeParserBucket bucket \u003d new DateTimeParserBucket(instantLocal, chrono, iLocale);\n+    DateTimeParserBucket bucket \u003d new DateTimeParserBucket(instantLocal, chrono, iLocale, iPivotYear);\n     int newPos \u003d iParser.parseInto(bucket, text, position);\n     instant.setMillis(bucket.computeMillis());\n     if (iOffsetParsed \u0026\u0026 bucket.getZone() \u003d\u003d null) {\n         int parsedOffset \u003d bucket.getOffset();\n         DateTimeZone parsedZone \u003d DateTimeZone.forOffsetMillis(parsedOffset);\n         chrono \u003d chrono.withZone(parsedZone);\n     }\n     instant.setChronology(chrono);\n     return newPos;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5082337a4152e04ebd8077fd0b7fa28113a4d79e": {
      "type": "Ymultichange(Ymovefromfile,Ybodychange,Ydocchange)",
      "commitMessage": "Refactor DateTime formatting to use decoration pattern\n\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@687 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1\n",
      "commitDate": "2/12/05, 6:39 PM",
      "commitName": "5082337a4152e04ebd8077fd0b7fa28113a4d79e",
      "commitAuthor": "Stephen Colebourne",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "Refactor DateTime formatting to use decoration pattern\n\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@687 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1\n",
          "commitDate": "2/12/05, 6:39 PM",
          "commitName": "5082337a4152e04ebd8077fd0b7fa28113a4d79e",
          "commitAuthor": "Stephen Colebourne",
          "commitDateOld": "2/12/05, 4:47 PM",
          "commitNameOld": "c012c27530466440b3c067fc60c6c9edb9ae784b",
          "commitAuthorOld": "Stephen Colebourne",
          "daysBetweenCommits": 0.08,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    checkParser();\n    if (instant \u003d\u003d null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    long instantMillis \u003d instant.getMillis();\n    Chronology chrono \u003d instant.getChronology();\n    long instantLocal \u003d instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono \u003d selectChronology(chrono);\n    DateTimeParserBucket bucket \u003d new DateTimeParserBucket(instantLocal, chrono, iLocale);\n    int newPos \u003d iParser.parseInto(bucket, text, position);\n    instant.setMillis(bucket.computeMillis());\n    if (iOffsetParsed \u0026\u0026 bucket.getZone() \u003d\u003d null) {\n        int parsedOffset \u003d bucket.getOffset();\n        DateTimeZone parsedZone \u003d DateTimeZone.forOffsetMillis(parsedOffset);\n        chrono \u003d chrono.withZone(parsedZone);\n    }\n    instant.setChronology(chrono);\n    return newPos;\n}",
          "path": "JodaTime/src/java/org/joda/time/format/DateTimeFormatter.java",
          "functionStartLine": 492,
          "functionName": "parseInto",
          "functionAnnotation": "",
          "functionDoc": "Parses a datetime from the given text, at the given position, saving the\nresult into the fields of the given ReadWritableInstant. If the parse\nsucceeds, the return value is the new text position. Note that the parse\nmay succeed without fully reading the text and in this case those fields\nthat were read will be set.\n\u003cp\u003e\nOnly those fields present in the string will be changed in the specified\ninstant. All other fields will remain unaltered. Thus if the string only\ncontains a year and a month, then the day and time will be retained from\nthe input instant. If this is not the behaviour you want, then reset the\nfields before calling this method, or use {@link #parseDateTime(String)}\nor {@link #parseMutableDateTime(String)}.\n\u003cp\u003e\nIf it fails, the return value is negative, but the instant may still be\nmodified. To determine the position where the parse failed, apply the\none\u0027s complement operator (~) on the return value.\n\u003cp\u003e\nThe parse will use the chronology of the instant.\n\n@param instant an instant that will be modified, not null\n@param text the text to parse\n@param position position to start parsing from\n@return new position, negative value means parse failed -\n apply complement operator (~) to get position of failure\n@throws UnsupportedOperationException if parsing is not supported\n@throws IllegalArgumentException if the instant is null\n@throws IllegalArgumentException if any field is out of range\n",
          "diff": "@@ -1,12 +1,20 @@\n public int parseInto(ReadWritableInstant instant, String text, int position) {\n+    checkParser();\n     if (instant \u003d\u003d null) {\n         throw new IllegalArgumentException(\"Instant must not be null\");\n     }\n-    long millis \u003d instant.getMillis();\n+    long instantMillis \u003d instant.getMillis();\n     Chronology chrono \u003d instant.getChronology();\n-    long instantLocal \u003d millis + chrono.getZone().getOffset(millis);\n-    DateTimeParserBucket bucket \u003d new DateTimeParserBucket(instantLocal, chrono);\n-    int resultPos \u003d ((DateTimeParser) this).parseInto(bucket, text, position);\n+    long instantLocal \u003d instantMillis + chrono.getZone().getOffset(instantMillis);\n+    chrono \u003d selectChronology(chrono);\n+    DateTimeParserBucket bucket \u003d new DateTimeParserBucket(instantLocal, chrono, iLocale);\n+    int newPos \u003d iParser.parseInto(bucket, text, position);\n     instant.setMillis(bucket.computeMillis());\n-    return resultPos;\n+    if (iOffsetParsed \u0026\u0026 bucket.getZone() \u003d\u003d null) {\n+        int parsedOffset \u003d bucket.getOffset();\n+        DateTimeZone parsedZone \u003d DateTimeZone.forOffsetMillis(parsedOffset);\n+        chrono \u003d chrono.withZone(parsedZone);\n+    }\n+    instant.setChronology(chrono);\n+    return newPos;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldPath": "JodaTime/src/java/org/joda/time/format/BaseDateTimeFormatter.java",
            "newPath": "JodaTime/src/java/org/joda/time/format/DateTimeFormatter.java",
            "oldMethodName": "parseInto",
            "newMethodName": "parseInto"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Refactor DateTime formatting to use decoration pattern\n\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@687 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1\n",
          "commitDate": "2/12/05, 6:39 PM",
          "commitName": "5082337a4152e04ebd8077fd0b7fa28113a4d79e",
          "commitAuthor": "Stephen Colebourne",
          "commitDateOld": "2/12/05, 4:47 PM",
          "commitNameOld": "c012c27530466440b3c067fc60c6c9edb9ae784b",
          "commitAuthorOld": "Stephen Colebourne",
          "daysBetweenCommits": 0.08,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    checkParser();\n    if (instant \u003d\u003d null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    long instantMillis \u003d instant.getMillis();\n    Chronology chrono \u003d instant.getChronology();\n    long instantLocal \u003d instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono \u003d selectChronology(chrono);\n    DateTimeParserBucket bucket \u003d new DateTimeParserBucket(instantLocal, chrono, iLocale);\n    int newPos \u003d iParser.parseInto(bucket, text, position);\n    instant.setMillis(bucket.computeMillis());\n    if (iOffsetParsed \u0026\u0026 bucket.getZone() \u003d\u003d null) {\n        int parsedOffset \u003d bucket.getOffset();\n        DateTimeZone parsedZone \u003d DateTimeZone.forOffsetMillis(parsedOffset);\n        chrono \u003d chrono.withZone(parsedZone);\n    }\n    instant.setChronology(chrono);\n    return newPos;\n}",
          "path": "JodaTime/src/java/org/joda/time/format/DateTimeFormatter.java",
          "functionStartLine": 492,
          "functionName": "parseInto",
          "functionAnnotation": "",
          "functionDoc": "Parses a datetime from the given text, at the given position, saving the\nresult into the fields of the given ReadWritableInstant. If the parse\nsucceeds, the return value is the new text position. Note that the parse\nmay succeed without fully reading the text and in this case those fields\nthat were read will be set.\n\u003cp\u003e\nOnly those fields present in the string will be changed in the specified\ninstant. All other fields will remain unaltered. Thus if the string only\ncontains a year and a month, then the day and time will be retained from\nthe input instant. If this is not the behaviour you want, then reset the\nfields before calling this method, or use {@link #parseDateTime(String)}\nor {@link #parseMutableDateTime(String)}.\n\u003cp\u003e\nIf it fails, the return value is negative, but the instant may still be\nmodified. To determine the position where the parse failed, apply the\none\u0027s complement operator (~) on the return value.\n\u003cp\u003e\nThe parse will use the chronology of the instant.\n\n@param instant an instant that will be modified, not null\n@param text the text to parse\n@param position position to start parsing from\n@return new position, negative value means parse failed -\n apply complement operator (~) to get position of failure\n@throws UnsupportedOperationException if parsing is not supported\n@throws IllegalArgumentException if the instant is null\n@throws IllegalArgumentException if any field is out of range\n",
          "diff": "@@ -1,12 +1,20 @@\n public int parseInto(ReadWritableInstant instant, String text, int position) {\n+    checkParser();\n     if (instant \u003d\u003d null) {\n         throw new IllegalArgumentException(\"Instant must not be null\");\n     }\n-    long millis \u003d instant.getMillis();\n+    long instantMillis \u003d instant.getMillis();\n     Chronology chrono \u003d instant.getChronology();\n-    long instantLocal \u003d millis + chrono.getZone().getOffset(millis);\n-    DateTimeParserBucket bucket \u003d new DateTimeParserBucket(instantLocal, chrono);\n-    int resultPos \u003d ((DateTimeParser) this).parseInto(bucket, text, position);\n+    long instantLocal \u003d instantMillis + chrono.getZone().getOffset(instantMillis);\n+    chrono \u003d selectChronology(chrono);\n+    DateTimeParserBucket bucket \u003d new DateTimeParserBucket(instantLocal, chrono, iLocale);\n+    int newPos \u003d iParser.parseInto(bucket, text, position);\n     instant.setMillis(bucket.computeMillis());\n-    return resultPos;\n+    if (iOffsetParsed \u0026\u0026 bucket.getZone() \u003d\u003d null) {\n+        int parsedOffset \u003d bucket.getOffset();\n+        DateTimeZone parsedZone \u003d DateTimeZone.forOffsetMillis(parsedOffset);\n+        chrono \u003d chrono.withZone(parsedZone);\n+    }\n+    instant.setChronology(chrono);\n+    return newPos;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Refactor DateTime formatting to use decoration pattern\n\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@687 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1\n",
          "commitDate": "2/12/05, 6:39 PM",
          "commitName": "5082337a4152e04ebd8077fd0b7fa28113a4d79e",
          "commitAuthor": "Stephen Colebourne",
          "commitDateOld": "2/12/05, 4:47 PM",
          "commitNameOld": "c012c27530466440b3c067fc60c6c9edb9ae784b",
          "commitAuthorOld": "Stephen Colebourne",
          "daysBetweenCommits": 0.08,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    checkParser();\n    if (instant \u003d\u003d null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    long instantMillis \u003d instant.getMillis();\n    Chronology chrono \u003d instant.getChronology();\n    long instantLocal \u003d instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono \u003d selectChronology(chrono);\n    DateTimeParserBucket bucket \u003d new DateTimeParserBucket(instantLocal, chrono, iLocale);\n    int newPos \u003d iParser.parseInto(bucket, text, position);\n    instant.setMillis(bucket.computeMillis());\n    if (iOffsetParsed \u0026\u0026 bucket.getZone() \u003d\u003d null) {\n        int parsedOffset \u003d bucket.getOffset();\n        DateTimeZone parsedZone \u003d DateTimeZone.forOffsetMillis(parsedOffset);\n        chrono \u003d chrono.withZone(parsedZone);\n    }\n    instant.setChronology(chrono);\n    return newPos;\n}",
          "path": "JodaTime/src/java/org/joda/time/format/DateTimeFormatter.java",
          "functionStartLine": 492,
          "functionName": "parseInto",
          "functionAnnotation": "",
          "functionDoc": "Parses a datetime from the given text, at the given position, saving the\nresult into the fields of the given ReadWritableInstant. If the parse\nsucceeds, the return value is the new text position. Note that the parse\nmay succeed without fully reading the text and in this case those fields\nthat were read will be set.\n\u003cp\u003e\nOnly those fields present in the string will be changed in the specified\ninstant. All other fields will remain unaltered. Thus if the string only\ncontains a year and a month, then the day and time will be retained from\nthe input instant. If this is not the behaviour you want, then reset the\nfields before calling this method, or use {@link #parseDateTime(String)}\nor {@link #parseMutableDateTime(String)}.\n\u003cp\u003e\nIf it fails, the return value is negative, but the instant may still be\nmodified. To determine the position where the parse failed, apply the\none\u0027s complement operator (~) on the return value.\n\u003cp\u003e\nThe parse will use the chronology of the instant.\n\n@param instant an instant that will be modified, not null\n@param text the text to parse\n@param position position to start parsing from\n@return new position, negative value means parse failed -\n apply complement operator (~) to get position of failure\n@throws UnsupportedOperationException if parsing is not supported\n@throws IllegalArgumentException if the instant is null\n@throws IllegalArgumentException if any field is out of range\n",
          "diff": "@@ -1,12 +1,20 @@\n public int parseInto(ReadWritableInstant instant, String text, int position) {\n+    checkParser();\n     if (instant \u003d\u003d null) {\n         throw new IllegalArgumentException(\"Instant must not be null\");\n     }\n-    long millis \u003d instant.getMillis();\n+    long instantMillis \u003d instant.getMillis();\n     Chronology chrono \u003d instant.getChronology();\n-    long instantLocal \u003d millis + chrono.getZone().getOffset(millis);\n-    DateTimeParserBucket bucket \u003d new DateTimeParserBucket(instantLocal, chrono);\n-    int resultPos \u003d ((DateTimeParser) this).parseInto(bucket, text, position);\n+    long instantLocal \u003d instantMillis + chrono.getZone().getOffset(instantMillis);\n+    chrono \u003d selectChronology(chrono);\n+    DateTimeParserBucket bucket \u003d new DateTimeParserBucket(instantLocal, chrono, iLocale);\n+    int newPos \u003d iParser.parseInto(bucket, text, position);\n     instant.setMillis(bucket.computeMillis());\n-    return resultPos;\n+    if (iOffsetParsed \u0026\u0026 bucket.getZone() \u003d\u003d null) {\n+        int parsedOffset \u003d bucket.getOffset();\n+        DateTimeZone parsedZone \u003d DateTimeZone.forOffsetMillis(parsedOffset);\n+        chrono \u003d chrono.withZone(parsedZone);\n+    }\n+    instant.setChronology(chrono);\n+    return newPos;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "",
            "newValue": "Parses a datetime from the given text, at the given position, saving the\nresult into the fields of the given ReadWritableInstant. If the parse\nsucceeds, the return value is the new text position. Note that the parse\nmay succeed without fully reading the text and in this case those fields\nthat were read will be set.\n\u003cp\u003e\nOnly those fields present in the string will be changed in the specified\ninstant. All other fields will remain unaltered. Thus if the string only\ncontains a year and a month, then the day and time will be retained from\nthe input instant. If this is not the behaviour you want, then reset the\nfields before calling this method, or use {@link #parseDateTime(String)}\nor {@link #parseMutableDateTime(String)}.\n\u003cp\u003e\nIf it fails, the return value is negative, but the instant may still be\nmodified. To determine the position where the parse failed, apply the\none\u0027s complement operator (~) on the return value.\n\u003cp\u003e\nThe parse will use the chronology of the instant.\n\n@param instant an instant that will be modified, not null\n@param text the text to parse\n@param position position to start parsing from\n@return new position, negative value means parse failed -\n apply complement operator (~) to get position of failure\n@throws UnsupportedOperationException if parsing is not supported\n@throws IllegalArgumentException if the instant is null\n@throws IllegalArgumentException if any field is out of range\n"
          }
        }
      ]
    },
    "1707517294d44202e104305e7b0c6fb12dd1a6dd": {
      "type": "Ybodychange",
      "commitMessage": "Restored formatting interfaces to provide same functionality as v0.95.\n\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@604 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1\n",
      "commitDate": "12/12/04, 8:21 PM",
      "commitName": "1707517294d44202e104305e7b0c6fb12dd1a6dd",
      "commitAuthor": "Brian S O\u0027Neill",
      "commitDateOld": "11/4/04, 3:53 PM",
      "commitNameOld": "ccddaff1a7295a4cb39f77589d781e760fd3b382",
      "commitAuthorOld": "Stephen Colebourne",
      "daysBetweenCommits": 38.19,
      "commitsBetweenForRepo": 45,
      "commitsBetweenForFile": 1,
      "actualSource": "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    if (instant \u003d\u003d null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    long millis \u003d instant.getMillis();\n    Chronology chrono \u003d instant.getChronology();\n    long instantLocal \u003d millis + chrono.getZone().getOffset(millis);\n    DateTimeParserBucket bucket \u003d new DateTimeParserBucket(instantLocal, chrono);\n    int resultPos \u003d ((DateTimeParser) this).parseInto(bucket, text, position);\n    instant.setMillis(bucket.computeMillis());\n    return resultPos;\n}",
      "path": "JodaTime/src/java/org/joda/time/format/BaseDateTimeFormatter.java",
      "functionStartLine": 185,
      "functionName": "parseInto",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,12 +1,12 @@\n public int parseInto(ReadWritableInstant instant, String text, int position) {\n     if (instant \u003d\u003d null) {\n         throw new IllegalArgumentException(\"Instant must not be null\");\n     }\n     long millis \u003d instant.getMillis();\n     Chronology chrono \u003d instant.getChronology();\n     long instantLocal \u003d millis + chrono.getZone().getOffset(millis);\n-    ParseBucket bucket \u003d new ParseBucket(instantLocal, chrono);\n-    int resultPos \u003d parseInto(bucket, text, position);\n+    DateTimeParserBucket bucket \u003d new DateTimeParserBucket(instantLocal, chrono);\n+    int resultPos \u003d ((DateTimeParser) this).parseInto(bucket, text, position);\n     instant.setMillis(bucket.computeMillis());\n     return resultPos;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c6a69cc40dcb388b5ddc3e616064f130ef3608e2": {
      "type": "Ybodychange",
      "commitMessage": "Refactor DateTimeParserBucket to inner class to aid package comprehension\n\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@544 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1\n",
      "commitDate": "10/28/04, 4:19 PM",
      "commitName": "c6a69cc40dcb388b5ddc3e616064f130ef3608e2",
      "commitAuthor": "Stephen Colebourne",
      "commitDateOld": "10/28/04, 3:56 PM",
      "commitNameOld": "6cad802018b6b82ea4df53aaf91a0bbc98b2f9a3",
      "commitAuthorOld": "Stephen Colebourne",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    if (instant \u003d\u003d null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    long millis \u003d instant.getMillis();\n    Chronology chrono \u003d instant.getChronology();\n    long instantLocal \u003d millis + chrono.getZone().getOffset(millis);\n    ParseBucket bucket \u003d new ParseBucket(instantLocal, chrono);\n    int resultPos \u003d parseInto(bucket, text, position);\n    instant.setMillis(bucket.computeMillis());\n    return resultPos;\n}",
      "path": "JodaTime/src/java/org/joda/time/format/BaseDateTimeFormatter.java",
      "functionStartLine": 205,
      "functionName": "parseInto",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,12 +1,12 @@\n public int parseInto(ReadWritableInstant instant, String text, int position) {\n     if (instant \u003d\u003d null) {\n         throw new IllegalArgumentException(\"Instant must not be null\");\n     }\n     long millis \u003d instant.getMillis();\n     Chronology chrono \u003d instant.getChronology();\n     long instantLocal \u003d millis + chrono.getZone().getOffset(millis);\n-    DateTimeParserBucket bucket \u003d new DateTimeParserBucket(instantLocal, chrono);\n+    ParseBucket bucket \u003d new ParseBucket(instantLocal, chrono);\n     int resultPos \u003d parseInto(bucket, text, position);\n     instant.setMillis(bucket.computeMillis());\n     return resultPos;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6cad802018b6b82ea4df53aaf91a0bbc98b2f9a3": {
      "type": "Ymultichange(Ymovefromfile,Ybodychange,Yparametermetachange)",
      "commitMessage": "Refactor format package to use late binding of chronology\n\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@543 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1\n",
      "commitDate": "10/28/04, 3:56 PM",
      "commitName": "6cad802018b6b82ea4df53aaf91a0bbc98b2f9a3",
      "commitAuthor": "Stephen Colebourne",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "Refactor format package to use late binding of chronology\n\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@543 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1\n",
          "commitDate": "10/28/04, 3:56 PM",
          "commitName": "6cad802018b6b82ea4df53aaf91a0bbc98b2f9a3",
          "commitAuthor": "Stephen Colebourne",
          "commitDateOld": "10/27/04, 7:35 PM",
          "commitNameOld": "369388fcda06e845e28911926d82cb8f634b4bba",
          "commitAuthorOld": "Brian S O\u0027Neill",
          "daysBetweenCommits": 0.85,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    if (instant \u003d\u003d null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    long millis \u003d instant.getMillis();\n    Chronology chrono \u003d instant.getChronology();\n    long instantLocal \u003d millis + chrono.getZone().getOffset(millis);\n    DateTimeParserBucket bucket \u003d new DateTimeParserBucket(instantLocal, chrono);\n    int resultPos \u003d parseInto(bucket, text, position);\n    instant.setMillis(bucket.computeMillis());\n    return resultPos;\n}",
          "path": "JodaTime/src/java/org/joda/time/format/BaseDateTimeFormatter.java",
          "functionStartLine": 201,
          "functionName": "parseInto",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,15 +1,12 @@\n-public int parseInto(final ReadWritableInstant instant, final String text, final int position) {\n-    DateTimeParser p \u003d (DateTimeParser) this;\n+public int parseInto(ReadWritableInstant instant, String text, int position) {\n+    if (instant \u003d\u003d null) {\n+        throw new IllegalArgumentException(\"Instant must not be null\");\n+    }\n     long millis \u003d instant.getMillis();\n     Chronology chrono \u003d instant.getChronology();\n-    if (chrono !\u003d null) {\n-        DateTimeZone zone \u003d chrono.getZone();\n-        if (zone !\u003d null) {\n-            millis +\u003d zone.getOffset(millis);\n-        }\n-    }\n-    DateTimeParserBucket bucket \u003d createBucket(millis);\n-    int resultPos \u003d p.parseInto(bucket, text, position);\n+    long instantLocal \u003d millis + chrono.getZone().getOffset(millis);\n+    DateTimeParserBucket bucket \u003d new DateTimeParserBucket(instantLocal, chrono);\n+    int resultPos \u003d parseInto(bucket, text, position);\n     instant.setMillis(bucket.computeMillis());\n     return resultPos;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldPath": "JodaTime/src/java/org/joda/time/format/AbstractDateTimeFormatter.java",
            "newPath": "JodaTime/src/java/org/joda/time/format/BaseDateTimeFormatter.java",
            "oldMethodName": "parseInto",
            "newMethodName": "parseInto"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Refactor format package to use late binding of chronology\n\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@543 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1\n",
          "commitDate": "10/28/04, 3:56 PM",
          "commitName": "6cad802018b6b82ea4df53aaf91a0bbc98b2f9a3",
          "commitAuthor": "Stephen Colebourne",
          "commitDateOld": "10/27/04, 7:35 PM",
          "commitNameOld": "369388fcda06e845e28911926d82cb8f634b4bba",
          "commitAuthorOld": "Brian S O\u0027Neill",
          "daysBetweenCommits": 0.85,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    if (instant \u003d\u003d null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    long millis \u003d instant.getMillis();\n    Chronology chrono \u003d instant.getChronology();\n    long instantLocal \u003d millis + chrono.getZone().getOffset(millis);\n    DateTimeParserBucket bucket \u003d new DateTimeParserBucket(instantLocal, chrono);\n    int resultPos \u003d parseInto(bucket, text, position);\n    instant.setMillis(bucket.computeMillis());\n    return resultPos;\n}",
          "path": "JodaTime/src/java/org/joda/time/format/BaseDateTimeFormatter.java",
          "functionStartLine": 201,
          "functionName": "parseInto",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,15 +1,12 @@\n-public int parseInto(final ReadWritableInstant instant, final String text, final int position) {\n-    DateTimeParser p \u003d (DateTimeParser) this;\n+public int parseInto(ReadWritableInstant instant, String text, int position) {\n+    if (instant \u003d\u003d null) {\n+        throw new IllegalArgumentException(\"Instant must not be null\");\n+    }\n     long millis \u003d instant.getMillis();\n     Chronology chrono \u003d instant.getChronology();\n-    if (chrono !\u003d null) {\n-        DateTimeZone zone \u003d chrono.getZone();\n-        if (zone !\u003d null) {\n-            millis +\u003d zone.getOffset(millis);\n-        }\n-    }\n-    DateTimeParserBucket bucket \u003d createBucket(millis);\n-    int resultPos \u003d p.parseInto(bucket, text, position);\n+    long instantLocal \u003d millis + chrono.getZone().getOffset(millis);\n+    DateTimeParserBucket bucket \u003d new DateTimeParserBucket(instantLocal, chrono);\n+    int resultPos \u003d parseInto(bucket, text, position);\n     instant.setMillis(bucket.computeMillis());\n     return resultPos;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Yparametermetachange",
          "commitMessage": "Refactor format package to use late binding of chronology\n\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@543 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1\n",
          "commitDate": "10/28/04, 3:56 PM",
          "commitName": "6cad802018b6b82ea4df53aaf91a0bbc98b2f9a3",
          "commitAuthor": "Stephen Colebourne",
          "commitDateOld": "10/27/04, 7:35 PM",
          "commitNameOld": "369388fcda06e845e28911926d82cb8f634b4bba",
          "commitAuthorOld": "Brian S O\u0027Neill",
          "daysBetweenCommits": 0.85,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    if (instant \u003d\u003d null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    long millis \u003d instant.getMillis();\n    Chronology chrono \u003d instant.getChronology();\n    long instantLocal \u003d millis + chrono.getZone().getOffset(millis);\n    DateTimeParserBucket bucket \u003d new DateTimeParserBucket(instantLocal, chrono);\n    int resultPos \u003d parseInto(bucket, text, position);\n    instant.setMillis(bucket.computeMillis());\n    return resultPos;\n}",
          "path": "JodaTime/src/java/org/joda/time/format/BaseDateTimeFormatter.java",
          "functionStartLine": 201,
          "functionName": "parseInto",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,15 +1,12 @@\n-public int parseInto(final ReadWritableInstant instant, final String text, final int position) {\n-    DateTimeParser p \u003d (DateTimeParser) this;\n+public int parseInto(ReadWritableInstant instant, String text, int position) {\n+    if (instant \u003d\u003d null) {\n+        throw new IllegalArgumentException(\"Instant must not be null\");\n+    }\n     long millis \u003d instant.getMillis();\n     Chronology chrono \u003d instant.getChronology();\n-    if (chrono !\u003d null) {\n-        DateTimeZone zone \u003d chrono.getZone();\n-        if (zone !\u003d null) {\n-            millis +\u003d zone.getOffset(millis);\n-        }\n-    }\n-    DateTimeParserBucket bucket \u003d createBucket(millis);\n-    int resultPos \u003d p.parseInto(bucket, text, position);\n+    long instantLocal \u003d millis + chrono.getZone().getOffset(millis);\n+    DateTimeParserBucket bucket \u003d new DateTimeParserBucket(instantLocal, chrono);\n+    int resultPos \u003d parseInto(bucket, text, position);\n     instant.setMillis(bucket.computeMillis());\n     return resultPos;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[instant-ReadWritableInstant(modifiers-final), text-String(modifiers-final), position-int(modifiers-final)]",
            "newValue": "[instant-ReadWritableInstant, text-String, position-int]"
          }
        }
      ]
    },
    "a26563f0cd1fbdd5587a0f9d3c0c77864553d737": {
      "type": "Ybodychange",
      "commitMessage": "Rename getDateTimeZone methods to getZone etc\n\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@177 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1\n",
      "commitDate": "4/14/04, 4:43 PM",
      "commitName": "a26563f0cd1fbdd5587a0f9d3c0c77864553d737",
      "commitAuthor": "Stephen Colebourne",
      "commitDateOld": "1/3/04, 4:24 AM",
      "commitNameOld": "35aca9c2020c7c426b67fbe19e57ddcb9f1b389d",
      "commitAuthorOld": "Stephen Colebourne",
      "daysBetweenCommits": 102.47,
      "commitsBetweenForRepo": 85,
      "commitsBetweenForFile": 1,
      "actualSource": "public int parseInto(final ReadWritableInstant instant, final String text, final int position) {\n    DateTimeParser p \u003d (DateTimeParser) this;\n    long millis \u003d instant.getMillis();\n    Chronology chrono \u003d instant.getChronology();\n    if (chrono !\u003d null) {\n        DateTimeZone zone \u003d chrono.getZone();\n        if (zone !\u003d null) {\n            millis +\u003d zone.getOffset(millis);\n        }\n    }\n    DateTimeParserBucket bucket \u003d createBucket(millis);\n    int resultPos \u003d p.parseInto(bucket, text, position);\n    instant.setMillis(bucket.computeMillis());\n    return resultPos;\n}",
      "path": "JodaTime/src/java/org/joda/time/format/AbstractDateTimeFormatter.java",
      "functionStartLine": 199,
      "functionName": "parseInto",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,15 +1,15 @@\n public int parseInto(final ReadWritableInstant instant, final String text, final int position) {\n     DateTimeParser p \u003d (DateTimeParser) this;\n     long millis \u003d instant.getMillis();\n     Chronology chrono \u003d instant.getChronology();\n     if (chrono !\u003d null) {\n-        DateTimeZone zone \u003d chrono.getDateTimeZone();\n+        DateTimeZone zone \u003d chrono.getZone();\n         if (zone !\u003d null) {\n             millis +\u003d zone.getOffset(millis);\n         }\n     }\n     DateTimeParserBucket bucket \u003d createBucket(millis);\n     int resultPos \u003d p.parseInto(bucket, text, position);\n     instant.setMillis(bucket.computeMillis());\n     return resultPos;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0e07ac6b2cff63550d7df336355ca63cc05aa40b": {
      "type": "Ymultichange(Ybodychange,Yparametermetachange)",
      "commitMessage": "Move from Joda CVS\n\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@10 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1\n",
      "commitDate": "12/18/03, 6:07 PM",
      "commitName": "0e07ac6b2cff63550d7df336355ca63cc05aa40b",
      "commitAuthor": "Stephen Colebourne",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "Move from Joda CVS\n\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@10 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1\n",
          "commitDate": "12/18/03, 6:07 PM",
          "commitName": "0e07ac6b2cff63550d7df336355ca63cc05aa40b",
          "commitAuthor": "Stephen Colebourne",
          "commitDateOld": "12/16/03, 1:39 PM",
          "commitNameOld": "7fe68f297f7c372b515fde7f0bc8d721ec257ceb",
          "commitAuthorOld": "Stephen Colebourne",
          "daysBetweenCommits": 2.19,
          "commitsBetweenForRepo": 6,
          "commitsBetweenForFile": 1,
          "actualSource": "public int parseInto(final ReadWritableInstant instant, final String text, final int position) {\n    DateTimeParser p \u003d (DateTimeParser) this;\n    long millis \u003d instant.getMillis();\n    Chronology chrono \u003d instant.getChronology();\n    if (chrono !\u003d null) {\n        DateTimeZone zone \u003d chrono.getDateTimeZone();\n        if (zone !\u003d null) {\n            millis +\u003d zone.getOffset(millis);\n        }\n    }\n    DateTimeParserBucket bucket \u003d createBucket(millis);\n    int resultPos \u003d p.parseInto(bucket, text, position);\n    instant.setMillis(bucket.computeMillis());\n    return resultPos;\n}",
          "path": "JodaTime/src/java/org/joda/time/format/AbstractDateTimeFormatter.java",
          "functionStartLine": 199,
          "functionName": "parseInto",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,15 +1,15 @@\n-public int parseInto(ReadWritableInstant instant, String text, int position) {\n+public int parseInto(final ReadWritableInstant instant, final String text, final int position) {\n     DateTimeParser p \u003d (DateTimeParser) this;\n     long millis \u003d instant.getMillis();\n     Chronology chrono \u003d instant.getChronology();\n     if (chrono !\u003d null) {\n         DateTimeZone zone \u003d chrono.getDateTimeZone();\n         if (zone !\u003d null) {\n             millis +\u003d zone.getOffset(millis);\n         }\n     }\n     DateTimeParserBucket bucket \u003d createBucket(millis);\n-    position \u003d p.parseInto(bucket, text, position);\n+    int resultPos \u003d p.parseInto(bucket, text, position);\n     instant.setMillis(bucket.computeMillis());\n-    return position;\n+    return resultPos;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Yparametermetachange",
          "commitMessage": "Move from Joda CVS\n\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@10 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1\n",
          "commitDate": "12/18/03, 6:07 PM",
          "commitName": "0e07ac6b2cff63550d7df336355ca63cc05aa40b",
          "commitAuthor": "Stephen Colebourne",
          "commitDateOld": "12/16/03, 1:39 PM",
          "commitNameOld": "7fe68f297f7c372b515fde7f0bc8d721ec257ceb",
          "commitAuthorOld": "Stephen Colebourne",
          "daysBetweenCommits": 2.19,
          "commitsBetweenForRepo": 6,
          "commitsBetweenForFile": 1,
          "actualSource": "public int parseInto(final ReadWritableInstant instant, final String text, final int position) {\n    DateTimeParser p \u003d (DateTimeParser) this;\n    long millis \u003d instant.getMillis();\n    Chronology chrono \u003d instant.getChronology();\n    if (chrono !\u003d null) {\n        DateTimeZone zone \u003d chrono.getDateTimeZone();\n        if (zone !\u003d null) {\n            millis +\u003d zone.getOffset(millis);\n        }\n    }\n    DateTimeParserBucket bucket \u003d createBucket(millis);\n    int resultPos \u003d p.parseInto(bucket, text, position);\n    instant.setMillis(bucket.computeMillis());\n    return resultPos;\n}",
          "path": "JodaTime/src/java/org/joda/time/format/AbstractDateTimeFormatter.java",
          "functionStartLine": 199,
          "functionName": "parseInto",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,15 +1,15 @@\n-public int parseInto(ReadWritableInstant instant, String text, int position) {\n+public int parseInto(final ReadWritableInstant instant, final String text, final int position) {\n     DateTimeParser p \u003d (DateTimeParser) this;\n     long millis \u003d instant.getMillis();\n     Chronology chrono \u003d instant.getChronology();\n     if (chrono !\u003d null) {\n         DateTimeZone zone \u003d chrono.getDateTimeZone();\n         if (zone !\u003d null) {\n             millis +\u003d zone.getOffset(millis);\n         }\n     }\n     DateTimeParserBucket bucket \u003d createBucket(millis);\n-    position \u003d p.parseInto(bucket, text, position);\n+    int resultPos \u003d p.parseInto(bucket, text, position);\n     instant.setMillis(bucket.computeMillis());\n-    return position;\n+    return resultPos;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[instant-ReadWritableInstant, text-String, position-int]",
            "newValue": "[instant-ReadWritableInstant(modifiers-final), text-String(modifiers-final), position-int(modifiers-final)]"
          }
        }
      ]
    },
    "7fe68f297f7c372b515fde7f0bc8d721ec257ceb": {
      "type": "Yintroduced",
      "commitMessage": "Move version 0.9 to joda-time repository\n\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@4 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1\n",
      "commitDate": "12/16/03, 1:39 PM",
      "commitName": "7fe68f297f7c372b515fde7f0bc8d721ec257ceb",
      "commitAuthor": "Stephen Colebourne",
      "diff": "@@ -0,0 +1,15 @@\n+public int parseInto(ReadWritableInstant instant, String text, int position) {\n+    DateTimeParser p \u003d (DateTimeParser) this;\n+    long millis \u003d instant.getMillis();\n+    Chronology chrono \u003d instant.getChronology();\n+    if (chrono !\u003d null) {\n+        DateTimeZone zone \u003d chrono.getDateTimeZone();\n+        if (zone !\u003d null) {\n+            millis +\u003d zone.getOffset(millis);\n+        }\n+    }\n+    DateTimeParserBucket bucket \u003d createBucket(millis);\n+    position \u003d p.parseInto(bucket, text, position);\n+    instant.setMillis(bucket.computeMillis());\n+    return position;\n+}\n\\ No newline at end of file\n",
      "actualSource": "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    DateTimeParser p \u003d (DateTimeParser) this;\n    long millis \u003d instant.getMillis();\n    Chronology chrono \u003d instant.getChronology();\n    if (chrono !\u003d null) {\n        DateTimeZone zone \u003d chrono.getDateTimeZone();\n        if (zone !\u003d null) {\n            millis +\u003d zone.getOffset(millis);\n        }\n    }\n    DateTimeParserBucket bucket \u003d createBucket(millis);\n    position \u003d p.parseInto(bucket, text, position);\n    instant.setMillis(bucket.computeMillis());\n    return position;\n}",
      "path": "JodaTime/src/java/org/joda/time/format/AbstractDateTimeFormatter.java",
      "functionStartLine": 216,
      "functionName": "parseInto",
      "functionAnnotation": "",
      "functionDoc": ""
    }
  }
}