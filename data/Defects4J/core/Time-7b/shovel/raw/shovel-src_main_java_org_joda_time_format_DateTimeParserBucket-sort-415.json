{
  "origin": "codeshovel",
  "repositoryName": "Time-7b",
  "repositoryPath": "/tmp/Time-7b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "DateTimeParserBucket.java",
  "functionName": "sort",
  "functionId": "sort___array-SavedField[]__high-int",
  "sourceFilePath": "src/main/java/org/joda/time/format/DateTimeParserBucket.java",
  "functionAnnotation": "",
  "functionDoc": "Sorts elements [0,high). Calling java.util.Arrays isn\u0027t always the right\nchoice since it always creates an internal copy of the array, even if it\ndoesn\u0027t need to. If the array slice is small enough, an insertion sort\nis chosen instead, but it doesn\u0027t need a copy!\n\u003cp\u003e\nThis method has a modified version of that insertion sort, except it\ndoesn\u0027t create an unnecessary array copy. If high is over 10, then\njava.util.Arrays is called, which will perform a merge sort, which is\nfaster than insertion sort on large lists.\n\u003cp\u003e\nThe end result is much greater performance when computeMillis is called.\nSince the amount of saved fields is small, the insertion sort is a\nbetter choice. Additional performance is gained since there is no extra\narray allocation and copying. Also, the insertion sort here does not\nperform any casting operations. The version in java.util.Arrays performs\ncasts within the insertion sort loop.\n",
  "functionStartLine": 415,
  "functionEndLine": 427,
  "numCommitsSeen": 59,
  "timeTaken": 1977,
  "changeHistory": [
    "df4a82f4fb46cc2248280c462e18f08d55a3d112",
    "53feb3fa56af7260e607844524b7e5a9be49ecc1",
    "3f1e047c898c9c925e1faac33bb07e1cb05d88cb",
    "1707517294d44202e104305e7b0c6fb12dd1a6dd",
    "c6a69cc40dcb388b5ddc3e616064f130ef3608e2",
    "4d08164b8dcd0fd8cd02e6c6a64cfedf56636aee"
  ],
  "changeHistoryShort": {
    "df4a82f4fb46cc2248280c462e18f08d55a3d112": "Yfilerename",
    "53feb3fa56af7260e607844524b7e5a9be49ecc1": "Yfilerename",
    "3f1e047c898c9c925e1faac33bb07e1cb05d88cb": "Ymultichange(Yparameterchange,Ybodychange,Ydocchange)",
    "1707517294d44202e104305e7b0c6fb12dd1a6dd": "Ymultichange(Ymovefromfile,Yformatchange)",
    "c6a69cc40dcb388b5ddc3e616064f130ef3608e2": "Ymultichange(Ymovefromfile,Yformatchange)",
    "4d08164b8dcd0fd8cd02e6c6a64cfedf56636aee": "Yintroduced"
  },
  "changeHistoryDetails": {
    "df4a82f4fb46cc2248280c462e18f08d55a3d112": {
      "type": "Yfilerename",
      "commitMessage": "Remove JodaTime folder moving files to top level\n",
      "commitDate": "5/16/11, 10:02 AM",
      "commitName": "df4a82f4fb46cc2248280c462e18f08d55a3d112",
      "commitAuthor": "Stephen Colebourne",
      "commitDateOld": "5/16/11, 9:58 AM",
      "commitNameOld": "72b22654962284bac59c2777131b42a2d1f53228",
      "commitAuthorOld": "Stephen Colebourne",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private static void sort(SavedField[] array, int high) {\n    if (high \u003e 10) {\n        Arrays.sort(array, 0, high);\n    } else {\n        for (int i \u003d 0; i \u003c high; i++) {\n            for (int j \u003d i; j \u003e 0 \u0026\u0026 (array[j - 1]).compareTo(array[j]) \u003e 0; j--) {\n                SavedField t \u003d array[j];\n                array[j] \u003d array[j - 1];\n                array[j - 1] \u003d t;\n            }\n        }\n    }\n}",
      "path": "src/main/java/org/joda/time/format/DateTimeParserBucket.java",
      "functionStartLine": 403,
      "functionName": "sort",
      "functionAnnotation": "",
      "functionDoc": "Sorts elements [0,high). Calling java.util.Arrays isn\u0027t always the right\nchoice since it always creates an internal copy of the array, even if it\ndoesn\u0027t need to. If the array slice is small enough, an insertion sort\nis chosen instead, but it doesn\u0027t need a copy!\n\u003cp\u003e\nThis method has a modified version of that insertion sort, except it\ndoesn\u0027t create an unnecessary array copy. If high is over 10, then\njava.util.Arrays is called, which will perform a merge sort, which is\nfaster than insertion sort on large lists.\n\u003cp\u003e\nThe end result is much greater performance when computeMillis is called.\nSince the amount of saved fields is small, the insertion sort is a\nbetter choice. Additional performance is gained since there is no extra\narray allocation and copying. Also, the insertion sort here does not\nperform any casting operations. The version in java.util.Arrays performs\ncasts within the insertion sort loop.\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "JodaTime/src/main/java/org/joda/time/format/DateTimeParserBucket.java",
        "newPath": "src/main/java/org/joda/time/format/DateTimeParserBucket.java"
      }
    },
    "53feb3fa56af7260e607844524b7e5a9be49ecc1": {
      "type": "Yfilerename",
      "commitMessage": "Convert to maven 2\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@1540 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1\n",
      "commitDate": "8/8/10, 5:17 PM",
      "commitName": "53feb3fa56af7260e607844524b7e5a9be49ecc1",
      "commitAuthor": "Stephen Colebourne",
      "commitDateOld": "8/8/10, 5:02 PM",
      "commitNameOld": "7fa2ceaf5d95d050095432aa646ea803aa35e122",
      "commitAuthorOld": "Stephen Colebourne",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private static void sort(SavedField[] array, int high) {\n    if (high \u003e 10) {\n        Arrays.sort(array, 0, high);\n    } else {\n        for (int i \u003d 0; i \u003c high; i++) {\n            for (int j \u003d i; j \u003e 0 \u0026\u0026 (array[j - 1]).compareTo(array[j]) \u003e 0; j--) {\n                SavedField t \u003d array[j];\n                array[j] \u003d array[j - 1];\n                array[j - 1] \u003d t;\n            }\n        }\n    }\n}",
      "path": "JodaTime/src/main/java/org/joda/time/format/DateTimeParserBucket.java",
      "functionStartLine": 361,
      "functionName": "sort",
      "functionAnnotation": "",
      "functionDoc": "Sorts elements [0,high). Calling java.util.Arrays isn\u0027t always the right\nchoice since it always creates an internal copy of the array, even if it\ndoesn\u0027t need to. If the array slice is small enough, an insertion sort\nis chosen instead, but it doesn\u0027t need a copy!\n\u003cp\u003e\nThis method has a modified version of that insertion sort, except it\ndoesn\u0027t create an unnecessary array copy. If high is over 10, then\njava.util.Arrays is called, which will perform a merge sort, which is\nfaster than insertion sort on large lists.\n\u003cp\u003e\nThe end result is much greater performance when computeMillis is called.\nSince the amount of saved fields is small, the insertion sort is a\nbetter choice. Additional performance is gained since there is no extra\narray allocation and copying. Also, the insertion sort here does not\nperform any casting operations. The version in java.util.Arrays performs\ncasts within the insertion sort loop.\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java",
        "newPath": "JodaTime/src/main/java/org/joda/time/format/DateTimeParserBucket.java"
      }
    },
    "3f1e047c898c9c925e1faac33bb07e1cb05d88cb": {
      "type": "Ymultichange(Yparameterchange,Ybodychange,Ydocchange)",
      "commitMessage": "Move to Java 5 with generics\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@1406 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1\n",
      "commitDate": "11/4/09, 3:55 PM",
      "commitName": "3f1e047c898c9c925e1faac33bb07e1cb05d88cb",
      "commitAuthor": "Stephen Colebourne",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Move to Java 5 with generics\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@1406 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1\n",
          "commitDate": "11/4/09, 3:55 PM",
          "commitName": "3f1e047c898c9c925e1faac33bb07e1cb05d88cb",
          "commitAuthor": "Stephen Colebourne",
          "commitDateOld": "7/31/06, 3:10 PM",
          "commitNameOld": "ce6991c2cfb3b666b53c5ad8b5b1f18d0eca9b21",
          "commitAuthorOld": "Stephen Colebourne",
          "daysBetweenCommits": 1192.07,
          "commitsBetweenForRepo": 267,
          "commitsBetweenForFile": 1,
          "actualSource": "private static void sort(SavedField[] array, int high) {\n    if (high \u003e 10) {\n        Arrays.sort(array, 0, high);\n    } else {\n        for (int i \u003d 0; i \u003c high; i++) {\n            for (int j \u003d i; j \u003e 0 \u0026\u0026 (array[j - 1]).compareTo(array[j]) \u003e 0; j--) {\n                SavedField t \u003d array[j];\n                array[j] \u003d array[j - 1];\n                array[j - 1] \u003d t;\n            }\n        }\n    }\n}",
          "path": "JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java",
          "functionStartLine": 361,
          "functionName": "sort",
          "functionAnnotation": "",
          "functionDoc": "Sorts elements [0,high). Calling java.util.Arrays isn\u0027t always the right\nchoice since it always creates an internal copy of the array, even if it\ndoesn\u0027t need to. If the array slice is small enough, an insertion sort\nis chosen instead, but it doesn\u0027t need a copy!\n\u003cp\u003e\nThis method has a modified version of that insertion sort, except it\ndoesn\u0027t create an unnecessary array copy. If high is over 10, then\njava.util.Arrays is called, which will perform a merge sort, which is\nfaster than insertion sort on large lists.\n\u003cp\u003e\nThe end result is much greater performance when computeMillis is called.\nSince the amount of saved fields is small, the insertion sort is a\nbetter choice. Additional performance is gained since there is no extra\narray allocation and copying. Also, the insertion sort here does not\nperform any casting operations. The version in java.util.Arrays performs\ncasts within the insertion sort loop.\n",
          "diff": "@@ -1,13 +1,13 @@\n-private static void sort(Comparable[] array, int high) {\n+private static void sort(SavedField[] array, int high) {\n     if (high \u003e 10) {\n         Arrays.sort(array, 0, high);\n     } else {\n         for (int i \u003d 0; i \u003c high; i++) {\n             for (int j \u003d i; j \u003e 0 \u0026\u0026 (array[j - 1]).compareTo(array[j]) \u003e 0; j--) {\n-                Comparable t \u003d array[j];\n+                SavedField t \u003d array[j];\n                 array[j] \u003d array[j - 1];\n                 array[j - 1] \u003d t;\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[array-Comparable[], high-int]",
            "newValue": "[array-SavedField[], high-int]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Move to Java 5 with generics\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@1406 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1\n",
          "commitDate": "11/4/09, 3:55 PM",
          "commitName": "3f1e047c898c9c925e1faac33bb07e1cb05d88cb",
          "commitAuthor": "Stephen Colebourne",
          "commitDateOld": "7/31/06, 3:10 PM",
          "commitNameOld": "ce6991c2cfb3b666b53c5ad8b5b1f18d0eca9b21",
          "commitAuthorOld": "Stephen Colebourne",
          "daysBetweenCommits": 1192.07,
          "commitsBetweenForRepo": 267,
          "commitsBetweenForFile": 1,
          "actualSource": "private static void sort(SavedField[] array, int high) {\n    if (high \u003e 10) {\n        Arrays.sort(array, 0, high);\n    } else {\n        for (int i \u003d 0; i \u003c high; i++) {\n            for (int j \u003d i; j \u003e 0 \u0026\u0026 (array[j - 1]).compareTo(array[j]) \u003e 0; j--) {\n                SavedField t \u003d array[j];\n                array[j] \u003d array[j - 1];\n                array[j - 1] \u003d t;\n            }\n        }\n    }\n}",
          "path": "JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java",
          "functionStartLine": 361,
          "functionName": "sort",
          "functionAnnotation": "",
          "functionDoc": "Sorts elements [0,high). Calling java.util.Arrays isn\u0027t always the right\nchoice since it always creates an internal copy of the array, even if it\ndoesn\u0027t need to. If the array slice is small enough, an insertion sort\nis chosen instead, but it doesn\u0027t need a copy!\n\u003cp\u003e\nThis method has a modified version of that insertion sort, except it\ndoesn\u0027t create an unnecessary array copy. If high is over 10, then\njava.util.Arrays is called, which will perform a merge sort, which is\nfaster than insertion sort on large lists.\n\u003cp\u003e\nThe end result is much greater performance when computeMillis is called.\nSince the amount of saved fields is small, the insertion sort is a\nbetter choice. Additional performance is gained since there is no extra\narray allocation and copying. Also, the insertion sort here does not\nperform any casting operations. The version in java.util.Arrays performs\ncasts within the insertion sort loop.\n",
          "diff": "@@ -1,13 +1,13 @@\n-private static void sort(Comparable[] array, int high) {\n+private static void sort(SavedField[] array, int high) {\n     if (high \u003e 10) {\n         Arrays.sort(array, 0, high);\n     } else {\n         for (int i \u003d 0; i \u003c high; i++) {\n             for (int j \u003d i; j \u003e 0 \u0026\u0026 (array[j - 1]).compareTo(array[j]) \u003e 0; j--) {\n-                Comparable t \u003d array[j];\n+                SavedField t \u003d array[j];\n                 array[j] \u003d array[j - 1];\n                 array[j - 1] \u003d t;\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Move to Java 5 with generics\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@1406 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1\n",
          "commitDate": "11/4/09, 3:55 PM",
          "commitName": "3f1e047c898c9c925e1faac33bb07e1cb05d88cb",
          "commitAuthor": "Stephen Colebourne",
          "commitDateOld": "7/31/06, 3:10 PM",
          "commitNameOld": "ce6991c2cfb3b666b53c5ad8b5b1f18d0eca9b21",
          "commitAuthorOld": "Stephen Colebourne",
          "daysBetweenCommits": 1192.07,
          "commitsBetweenForRepo": 267,
          "commitsBetweenForFile": 1,
          "actualSource": "private static void sort(SavedField[] array, int high) {\n    if (high \u003e 10) {\n        Arrays.sort(array, 0, high);\n    } else {\n        for (int i \u003d 0; i \u003c high; i++) {\n            for (int j \u003d i; j \u003e 0 \u0026\u0026 (array[j - 1]).compareTo(array[j]) \u003e 0; j--) {\n                SavedField t \u003d array[j];\n                array[j] \u003d array[j - 1];\n                array[j - 1] \u003d t;\n            }\n        }\n    }\n}",
          "path": "JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java",
          "functionStartLine": 361,
          "functionName": "sort",
          "functionAnnotation": "",
          "functionDoc": "Sorts elements [0,high). Calling java.util.Arrays isn\u0027t always the right\nchoice since it always creates an internal copy of the array, even if it\ndoesn\u0027t need to. If the array slice is small enough, an insertion sort\nis chosen instead, but it doesn\u0027t need a copy!\n\u003cp\u003e\nThis method has a modified version of that insertion sort, except it\ndoesn\u0027t create an unnecessary array copy. If high is over 10, then\njava.util.Arrays is called, which will perform a merge sort, which is\nfaster than insertion sort on large lists.\n\u003cp\u003e\nThe end result is much greater performance when computeMillis is called.\nSince the amount of saved fields is small, the insertion sort is a\nbetter choice. Additional performance is gained since there is no extra\narray allocation and copying. Also, the insertion sort here does not\nperform any casting operations. The version in java.util.Arrays performs\ncasts within the insertion sort loop.\n",
          "diff": "@@ -1,13 +1,13 @@\n-private static void sort(Comparable[] array, int high) {\n+private static void sort(SavedField[] array, int high) {\n     if (high \u003e 10) {\n         Arrays.sort(array, 0, high);\n     } else {\n         for (int i \u003d 0; i \u003c high; i++) {\n             for (int j \u003d i; j \u003e 0 \u0026\u0026 (array[j - 1]).compareTo(array[j]) \u003e 0; j--) {\n-                Comparable t \u003d array[j];\n+                SavedField t \u003d array[j];\n                 array[j] \u003d array[j - 1];\n                 array[j - 1] \u003d t;\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Sorts elements [0,high). Calling java.util.Arrays isn\u0027t always the right\nchoice since it always creates an internal copy of the array, even if it\ndoesn\u0027t need to. If the array slice is small enough, an insertion sort\nis chosen instead, but it doesn\u0027t need a copy!\n\u003cp\u003e\nThis method has a modified version of that insertion sort, except it\ndoesn\u0027t create an unnecessary array copy. If high is over 10, then\njava.util.Arrays is called, which will perform a merge sort, which is\nfaster than insertion sort on large lists.\n\u003cp\u003e\nThe end result is much greater performace when computeMillis is called.\nSince the amount of saved fields is small, the insertion sort is a\nbetter choice. Additional performance is gained since there is no extra\narray allocation and copying. Also, the insertion sort here does not\nperform any casting operations. The version in java.util.Arrays performs\ncasts within the insertion sort loop.\n",
            "newValue": "Sorts elements [0,high). Calling java.util.Arrays isn\u0027t always the right\nchoice since it always creates an internal copy of the array, even if it\ndoesn\u0027t need to. If the array slice is small enough, an insertion sort\nis chosen instead, but it doesn\u0027t need a copy!\n\u003cp\u003e\nThis method has a modified version of that insertion sort, except it\ndoesn\u0027t create an unnecessary array copy. If high is over 10, then\njava.util.Arrays is called, which will perform a merge sort, which is\nfaster than insertion sort on large lists.\n\u003cp\u003e\nThe end result is much greater performance when computeMillis is called.\nSince the amount of saved fields is small, the insertion sort is a\nbetter choice. Additional performance is gained since there is no extra\narray allocation and copying. Also, the insertion sort here does not\nperform any casting operations. The version in java.util.Arrays performs\ncasts within the insertion sort loop.\n"
          }
        }
      ]
    },
    "1707517294d44202e104305e7b0c6fb12dd1a6dd": {
      "type": "Ymultichange(Ymovefromfile,Yformatchange)",
      "commitMessage": "Restored formatting interfaces to provide same functionality as v0.95.\n\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@604 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1\n",
      "commitDate": "12/12/04, 8:21 PM",
      "commitName": "1707517294d44202e104305e7b0c6fb12dd1a6dd",
      "commitAuthor": "Brian S O\u0027Neill",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "Restored formatting interfaces to provide same functionality as v0.95.\n\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@604 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1\n",
          "commitDate": "12/12/04, 8:21 PM",
          "commitName": "1707517294d44202e104305e7b0c6fb12dd1a6dd",
          "commitAuthor": "Brian S O\u0027Neill",
          "commitDateOld": "12/12/04, 12:59 PM",
          "commitNameOld": "d1284b53b2a0d06a81cdd9e0ea1205d0e5c20631",
          "commitAuthorOld": "Brian S O\u0027Neill",
          "daysBetweenCommits": 0.31,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "private static void sort(Comparable[] array, int high) {\n    if (high \u003e 10) {\n        Arrays.sort(array, 0, high);\n    } else {\n        for (int i \u003d 0; i \u003c high; i++) {\n            for (int j \u003d i; j \u003e 0 \u0026\u0026 (array[j - 1]).compareTo(array[j]) \u003e 0; j--) {\n                Comparable t \u003d array[j];\n                array[j] \u003d array[j - 1];\n                array[j - 1] \u003d t;\n            }\n        }\n    }\n}",
          "path": "JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java",
          "functionStartLine": 313,
          "functionName": "sort",
          "functionAnnotation": "",
          "functionDoc": "Sorts elements [0,high). Calling java.util.Arrays isn\u0027t always the right\nchoice since it always creates an internal copy of the array, even if it\ndoesn\u0027t need to. If the array slice is small enough, an insertion sort\nis chosen instead, but it doesn\u0027t need a copy!\n\u003cp\u003e\nThis method has a modified version of that insertion sort, except it\ndoesn\u0027t create an unnecessary array copy. If high is over 10, then\njava.util.Arrays is called, which will perform a merge sort, which is\nfaster than insertion sort on large lists.\n\u003cp\u003e\nThe end result is much greater performace when computeMillis is called.\nSince the amount of saved fields is small, the insertion sort is a\nbetter choice. Additional performance is gained since there is no extra\narray allocation and copying. Also, the insertion sort here does not\nperform any casting operations. The version in java.util.Arrays performs\ncasts within the insertion sort loop.\n",
          "diff": "",
          "extendedDetails": {
            "oldPath": "JodaTime/src/java/org/joda/time/format/BaseDateTimeFormatter.java",
            "newPath": "JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java",
            "oldMethodName": "sort",
            "newMethodName": "sort"
          }
        },
        {
          "type": "Yformatchange",
          "commitMessage": "Restored formatting interfaces to provide same functionality as v0.95.\n\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@604 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1\n",
          "commitDate": "12/12/04, 8:21 PM",
          "commitName": "1707517294d44202e104305e7b0c6fb12dd1a6dd",
          "commitAuthor": "Brian S O\u0027Neill",
          "commitDateOld": "12/12/04, 12:59 PM",
          "commitNameOld": "d1284b53b2a0d06a81cdd9e0ea1205d0e5c20631",
          "commitAuthorOld": "Brian S O\u0027Neill",
          "daysBetweenCommits": 0.31,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "private static void sort(Comparable[] array, int high) {\n    if (high \u003e 10) {\n        Arrays.sort(array, 0, high);\n    } else {\n        for (int i \u003d 0; i \u003c high; i++) {\n            for (int j \u003d i; j \u003e 0 \u0026\u0026 (array[j - 1]).compareTo(array[j]) \u003e 0; j--) {\n                Comparable t \u003d array[j];\n                array[j] \u003d array[j - 1];\n                array[j - 1] \u003d t;\n            }\n        }\n    }\n}",
          "path": "JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java",
          "functionStartLine": 313,
          "functionName": "sort",
          "functionAnnotation": "",
          "functionDoc": "Sorts elements [0,high). Calling java.util.Arrays isn\u0027t always the right\nchoice since it always creates an internal copy of the array, even if it\ndoesn\u0027t need to. If the array slice is small enough, an insertion sort\nis chosen instead, but it doesn\u0027t need a copy!\n\u003cp\u003e\nThis method has a modified version of that insertion sort, except it\ndoesn\u0027t create an unnecessary array copy. If high is over 10, then\njava.util.Arrays is called, which will perform a merge sort, which is\nfaster than insertion sort on large lists.\n\u003cp\u003e\nThe end result is much greater performace when computeMillis is called.\nSince the amount of saved fields is small, the insertion sort is a\nbetter choice. Additional performance is gained since there is no extra\narray allocation and copying. Also, the insertion sort here does not\nperform any casting operations. The version in java.util.Arrays performs\ncasts within the insertion sort loop.\n",
          "diff": "",
          "extendedDetails": {}
        }
      ]
    },
    "c6a69cc40dcb388b5ddc3e616064f130ef3608e2": {
      "type": "Ymultichange(Ymovefromfile,Yformatchange)",
      "commitMessage": "Refactor DateTimeParserBucket to inner class to aid package comprehension\n\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@544 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1\n",
      "commitDate": "10/28/04, 4:19 PM",
      "commitName": "c6a69cc40dcb388b5ddc3e616064f130ef3608e2",
      "commitAuthor": "Stephen Colebourne",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "Refactor DateTimeParserBucket to inner class to aid package comprehension\n\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@544 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1\n",
          "commitDate": "10/28/04, 4:19 PM",
          "commitName": "c6a69cc40dcb388b5ddc3e616064f130ef3608e2",
          "commitAuthor": "Stephen Colebourne",
          "commitDateOld": "10/28/04, 3:56 PM",
          "commitNameOld": "6cad802018b6b82ea4df53aaf91a0bbc98b2f9a3",
          "commitAuthorOld": "Stephen Colebourne",
          "daysBetweenCommits": 0.02,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "private static void sort(Comparable[] array, int high) {\n    if (high \u003e 10) {\n        Arrays.sort(array, 0, high);\n    } else {\n        for (int i \u003d 0; i \u003c high; i++) {\n            for (int j \u003d i; j \u003e 0 \u0026\u0026 (array[j - 1]).compareTo(array[j]) \u003e 0; j--) {\n                Comparable t \u003d array[j];\n                array[j] \u003d array[j - 1];\n                array[j - 1] \u003d t;\n            }\n        }\n    }\n}",
          "path": "JodaTime/src/java/org/joda/time/format/BaseDateTimeFormatter.java",
          "functionStartLine": 544,
          "functionName": "sort",
          "functionAnnotation": "",
          "functionDoc": "Sorts elements [0,high). Calling java.util.Arrays isn\u0027t always the right\nchoice since it always creates an internal copy of the array, even if it\ndoesn\u0027t need to. If the array slice is small enough, an insertion sort\nis chosen instead, but it doesn\u0027t need a copy!\n\u003cp\u003e\nThis method has a modified version of that insertion sort, except it\ndoesn\u0027t create an unnecessary array copy. If high is over 10, then\njava.util.Arrays is called, which will perform a merge sort, which is\nfaster than insertion sort on large lists.\n\u003cp\u003e\nThe end result is much greater performace when computeMillis is called.\nSince the amount of saved fields is small, the insertion sort is a\nbetter choice. Additional performance is gained since there is no extra\narray allocation and copying. Also, the insertion sort here does not\nperform any casting operations. The version in java.util.Arrays performs\ncasts within the insertion sort loop.\n",
          "diff": "",
          "extendedDetails": {
            "oldPath": "JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java",
            "newPath": "JodaTime/src/java/org/joda/time/format/BaseDateTimeFormatter.java",
            "oldMethodName": "sort",
            "newMethodName": "sort"
          }
        },
        {
          "type": "Yformatchange",
          "commitMessage": "Refactor DateTimeParserBucket to inner class to aid package comprehension\n\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@544 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1\n",
          "commitDate": "10/28/04, 4:19 PM",
          "commitName": "c6a69cc40dcb388b5ddc3e616064f130ef3608e2",
          "commitAuthor": "Stephen Colebourne",
          "commitDateOld": "10/28/04, 3:56 PM",
          "commitNameOld": "6cad802018b6b82ea4df53aaf91a0bbc98b2f9a3",
          "commitAuthorOld": "Stephen Colebourne",
          "daysBetweenCommits": 0.02,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "private static void sort(Comparable[] array, int high) {\n    if (high \u003e 10) {\n        Arrays.sort(array, 0, high);\n    } else {\n        for (int i \u003d 0; i \u003c high; i++) {\n            for (int j \u003d i; j \u003e 0 \u0026\u0026 (array[j - 1]).compareTo(array[j]) \u003e 0; j--) {\n                Comparable t \u003d array[j];\n                array[j] \u003d array[j - 1];\n                array[j - 1] \u003d t;\n            }\n        }\n    }\n}",
          "path": "JodaTime/src/java/org/joda/time/format/BaseDateTimeFormatter.java",
          "functionStartLine": 544,
          "functionName": "sort",
          "functionAnnotation": "",
          "functionDoc": "Sorts elements [0,high). Calling java.util.Arrays isn\u0027t always the right\nchoice since it always creates an internal copy of the array, even if it\ndoesn\u0027t need to. If the array slice is small enough, an insertion sort\nis chosen instead, but it doesn\u0027t need a copy!\n\u003cp\u003e\nThis method has a modified version of that insertion sort, except it\ndoesn\u0027t create an unnecessary array copy. If high is over 10, then\njava.util.Arrays is called, which will perform a merge sort, which is\nfaster than insertion sort on large lists.\n\u003cp\u003e\nThe end result is much greater performace when computeMillis is called.\nSince the amount of saved fields is small, the insertion sort is a\nbetter choice. Additional performance is gained since there is no extra\narray allocation and copying. Also, the insertion sort here does not\nperform any casting operations. The version in java.util.Arrays performs\ncasts within the insertion sort loop.\n",
          "diff": "",
          "extendedDetails": {}
        }
      ]
    },
    "4d08164b8dcd0fd8cd02e6c6a64cfedf56636aee": {
      "type": "Yintroduced",
      "commitMessage": "More performance improvements due to less object allocation.\n\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@106 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1\n",
      "commitDate": "1/4/04, 10:51 PM",
      "commitName": "4d08164b8dcd0fd8cd02e6c6a64cfedf56636aee",
      "commitAuthor": "Brian S O\u0027Neill",
      "diff": "@@ -0,0 +1,13 @@\n+private static void sort(Comparable[] array, int high) {\n+    if (high \u003e 10) {\n+        Arrays.sort(array, 0, high);\n+    } else {\n+        for (int i \u003d 0; i \u003c high; i++) {\n+            for (int j \u003d i; j \u003e 0 \u0026\u0026 (array[j - 1]).compareTo(array[j]) \u003e 0; j--) {\n+                Comparable t \u003d array[j];\n+                array[j] \u003d array[j - 1];\n+                array[j - 1] \u003d t;\n+            }\n+        }\n+    }\n+}\n\\ No newline at end of file\n",
      "actualSource": "private static void sort(Comparable[] array, int high) {\n    if (high \u003e 10) {\n        Arrays.sort(array, 0, high);\n    } else {\n        for (int i \u003d 0; i \u003c high; i++) {\n            for (int j \u003d i; j \u003e 0 \u0026\u0026 (array[j - 1]).compareTo(array[j]) \u003e 0; j--) {\n                Comparable t \u003d array[j];\n                array[j] \u003d array[j - 1];\n                array[j - 1] \u003d t;\n            }\n        }\n    }\n}",
      "path": "JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java",
      "functionStartLine": 245,
      "functionName": "sort",
      "functionAnnotation": "",
      "functionDoc": "Sorts elements [0,high). Calling java.util.Arrays isn\u0027t always the right\nchoice since it always creates an internal copy of the array, even if it\ndoesn\u0027t need to. If the array slice is small enough, an insertion sort\nis chosen instead, but it doesn\u0027t need a copy!\n\u003cp\u003e\nThis method has a modified version of that insertion sort, except it\ndoesn\u0027t create an unnecessary array copy. If high is over 10, then\njava.util.Arrays is called, which will perform a merge sort, which is\nfaster than insertion sort on large lists.\n\u003cp\u003e\nThe end result is much greater performace when computeMillis is called.\nSince the amount of saved fields is small, the insertion sort is a\nbetter choice. Additional performance is gained since there is no extra\narray allocation and copying. Also, the insertion sort here does not\nperform any casting operations. The version in java.util.Arrays performs\ncasts within the insertion sort loop.\n"
    }
  }
}