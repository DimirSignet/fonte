{
  "origin": "codeshovel",
  "repositoryName": "Lang-39b",
  "repositoryPath": "/tmp/Lang-39b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "StringUtils.java",
  "functionName": "replaceEach",
  "functionId": "replaceEach___text-String__searchList-String[]__replacementList-String[]__repeat-boolean__timeToLive-int",
  "sourceFilePath": "src/java/org/apache/commons/lang3/StringUtils.java",
  "functionAnnotation": "",
  "functionDoc": "\u003cp\u003e\nReplaces all occurrences of Strings within another String.\n\u003c/p\u003e\n\n\u003cp\u003e\nA \u003ccode\u003enull\u003c/code\u003e reference passed to this method is a no-op, or if\nany \"search string\" or \"string to replace\" is null, that replace will be\nignored. \n\u003c/p\u003e\n\n\u003cpre\u003e\n StringUtils.replaceEach(null, *, *, *) \u003d null\n StringUtils.replaceEach(\"\", *, *, *) \u003d \"\"\n StringUtils.replaceEach(\"aba\", null, null, *) \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", new String[0], null, *) \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", null, new String[0], *) \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, null, *) \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, new String[]{\"\"}, *) \u003d \"b\"\n StringUtils.replaceEach(\"aba\", new String[]{null}, new String[]{\"a\"}, *) \u003d \"aba\"\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"w\", \"t\"}, *) \u003d \"wcte\"\n (example of how it repeats)\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, false) \u003d \"dcte\"\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, true) \u003d \"tcte\"\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"ab\"}, *) \u003d IllegalArgumentException\n\u003c/pre\u003e\n\n@param text text to search and replace in, no-op if null\n@param searchList the Strings to search for, no-op if null\n@param replacementList the Strings to replace them with, no-op if null\n@param repeat if true, then replace repeatedly \n      until there are no more possible replacements or timeToLive \u003c 0\n@param timeToLive if less than 0 then there is a circular reference and endless\n           loop\n@return the text with any replacements processed, \u003ccode\u003enull\u003c/code\u003e if\n        null String input\n@throws IllegalArgumentException\n            if the search is repeating and there is an endless loop due\n            to outputs of one being inputs to another\n@throws IndexOutOfBoundsException\n            if the lengths of the arrays are not the same (null is ok,\n            and/or size 0)\n@since 2.4\n",
  "functionStartLine": 3605,
  "functionEndLine": 3731,
  "numCommitsSeen": 395,
  "timeTaken": 5500,
  "changeHistory": [
    "586080851f6bca4d7aa84a7d307203ad8222407e",
    "7b43ec58a7e0d12a33af862888ef254bbed6056c",
    "bf1476fafba6a50d40db1765859f47954dd5428c",
    "5310e78952ca17521b7d5e83bfcefafa227187a5",
    "19f33e4e0d824e732d07f06a08567c27b3c808f3",
    "4aefe9f0b1d8e5f9649eceaf0e232eff71b3d034",
    "2a6b4afd3463243e17ff0af1d423b8dad0c46e69",
    "e8600d357d98cbf727b573732052aba0fd7a1f69"
  ],
  "changeHistoryShort": {
    "586080851f6bca4d7aa84a7d307203ad8222407e": "Yfilerename",
    "7b43ec58a7e0d12a33af862888ef254bbed6056c": "Ybodychange",
    "bf1476fafba6a50d40db1765859f47954dd5428c": "Ymultichange(Ydocchange,Yformatchange)",
    "5310e78952ca17521b7d5e83bfcefafa227187a5": "Ymultichange(Yparameterchange,Ybodychange,Ydocchange)",
    "19f33e4e0d824e732d07f06a08567c27b3c808f3": "Ydocchange",
    "4aefe9f0b1d8e5f9649eceaf0e232eff71b3d034": "Yformatchange",
    "2a6b4afd3463243e17ff0af1d423b8dad0c46e69": "Ydocchange",
    "e8600d357d98cbf727b573732052aba0fd7a1f69": "Yintroduced"
  },
  "changeHistoryDetails": {
    "586080851f6bca4d7aa84a7d307203ad8222407e": {
      "type": "Yfilerename",
      "commitMessage": "Changing directory name from lang to lang3. Build will fail (probably) until Java code is changed in subsequent commit. LANG-563\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@889202 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/10/09, 3:33 AM",
      "commitName": "586080851f6bca4d7aa84a7d307203ad8222407e",
      "commitAuthor": "Henri Yandell",
      "commitDateOld": "12/10/09, 3:31 AM",
      "commitNameOld": "da479d635f66c1f82a1f858591cfb1b9941457ae",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) {\n    if (text \u003d\u003d null || text.length() \u003d\u003d 0 || searchList \u003d\u003d null || searchList.length \u003d\u003d 0 || replacementList \u003d\u003d null || replacementList.length \u003d\u003d 0) {\n        return text;\n    }\n    if (timeToLive \u003c 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n    int searchLength \u003d searchList.length;\n    int replacementLength \u003d replacementList.length;\n    if (searchLength !\u003d replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don\u0027t match: \" + searchLength + \" vs \" + replacementLength);\n    }\n    boolean[] noMoreMatchesForReplIndex \u003d new boolean[searchLength];\n    int textIndex \u003d -1;\n    int replaceIndex \u003d -1;\n    int tempIndex \u003d -1;\n    for (int i \u003d 0; i \u003c searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] \u003d\u003d null || searchList[i].length() \u003d\u003d 0 || replacementList[i] \u003d\u003d null) {\n            continue;\n        }\n        tempIndex \u003d text.indexOf(searchList[i]);\n        if (tempIndex \u003d\u003d -1) {\n            noMoreMatchesForReplIndex[i] \u003d true;\n        } else {\n            if (textIndex \u003d\u003d -1 || tempIndex \u003c textIndex) {\n                textIndex \u003d tempIndex;\n                replaceIndex \u003d i;\n            }\n        }\n    }\n    if (textIndex \u003d\u003d -1) {\n        return text;\n    }\n    int start \u003d 0;\n    int increase \u003d 0;\n    for (int i \u003d 0; i \u003c searchList.length; i++) {\n        int greater \u003d replacementList[i].length() - searchList[i].length();\n        if (greater \u003e 0) {\n            increase +\u003d 3 * greater;\n        }\n    }\n    increase \u003d Math.min(increase, text.length() / 5);\n    StringBuilder buf \u003d new StringBuilder(text.length() + increase);\n    while (textIndex !\u003d -1) {\n        for (int i \u003d start; i \u003c textIndex; i++) {\n            buf.append(text.charAt(i));\n        }\n        buf.append(replacementList[replaceIndex]);\n        start \u003d textIndex + searchList[replaceIndex].length();\n        textIndex \u003d -1;\n        replaceIndex \u003d -1;\n        tempIndex \u003d -1;\n        for (int i \u003d 0; i \u003c searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] \u003d\u003d null || searchList[i].length() \u003d\u003d 0 || replacementList[i] \u003d\u003d null) {\n                continue;\n            }\n            tempIndex \u003d text.indexOf(searchList[i], start);\n            if (tempIndex \u003d\u003d -1) {\n                noMoreMatchesForReplIndex[i] \u003d true;\n            } else {\n                if (textIndex \u003d\u003d -1 || tempIndex \u003c textIndex) {\n                    textIndex \u003d tempIndex;\n                    replaceIndex \u003d i;\n                }\n            }\n        }\n    }\n    int textLength \u003d text.length();\n    for (int i \u003d start; i \u003c textLength; i++) {\n        buf.append(text.charAt(i));\n    }\n    String result \u003d buf.toString();\n    if (!repeat) {\n        return result;\n    }\n    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n}",
      "path": "src/java/org/apache/commons/lang3/StringUtils.java",
      "functionStartLine": 3541,
      "functionName": "replaceEach",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003e\nReplaces all occurrences of Strings within another String.\n\u003c/p\u003e\n\n\u003cp\u003e\nA \u003ccode\u003enull\u003c/code\u003e reference passed to this method is a no-op, or if\nany \"search string\" or \"string to replace\" is null, that replace will be\nignored. \n\u003c/p\u003e\n\n\u003cpre\u003e\n StringUtils.replaceEach(null, *, *, *) \u003d null\n StringUtils.replaceEach(\"\", *, *, *) \u003d \"\"\n StringUtils.replaceEach(\"aba\", null, null, *) \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", new String[0], null, *) \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", null, new String[0], *) \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, null, *) \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, new String[]{\"\"}, *) \u003d \"b\"\n StringUtils.replaceEach(\"aba\", new String[]{null}, new String[]{\"a\"}, *) \u003d \"aba\"\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"w\", \"t\"}, *) \u003d \"wcte\"\n (example of how it repeats)\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, false) \u003d \"dcte\"\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, true) \u003d \"tcte\"\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"ab\"}, *) \u003d IllegalArgumentException\n\u003c/pre\u003e\n\n@param text text to search and replace in, no-op if null\n@param searchList the Strings to search for, no-op if null\n@param replacementList the Strings to replace them with, no-op if null\n@param repeat if true, then replace repeatedly \n      until there are no more possible replacements or timeToLive \u003c 0\n@param timeToLive if less than 0 then there is a circular reference and endless\n           loop\n@return the text with any replacements processed, \u003ccode\u003enull\u003c/code\u003e if\n        null String input\n@throws IllegalArgumentException\n            if the search is repeating and there is an endless loop due\n            to outputs of one being inputs to another\n@throws IndexOutOfBoundsException\n            if the lengths of the arrays are not the same (null is ok,\n            and/or size 0)\n@since 2.4\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/commons/lang/StringUtils.java",
        "newPath": "src/java/org/apache/commons/lang3/StringUtils.java"
      }
    },
    "7b43ec58a7e0d12a33af862888ef254bbed6056c": {
      "type": "Ybodychange",
      "commitMessage": "Switched StringBuffer to StringBuilder whenever a local usage (and not subsequently used in an API) as per LANG-541\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@826958 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/19/09, 10:35 PM",
      "commitName": "7b43ec58a7e0d12a33af862888ef254bbed6056c",
      "commitAuthor": "Henri Yandell",
      "commitDateOld": "10/19/09, 10:18 PM",
      "commitNameOld": "d46523cf9c6371475f375c6c0b9df8d59fe26013",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) {\n    if (text \u003d\u003d null || text.length() \u003d\u003d 0 || searchList \u003d\u003d null || searchList.length \u003d\u003d 0 || replacementList \u003d\u003d null || replacementList.length \u003d\u003d 0) {\n        return text;\n    }\n    if (timeToLive \u003c 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n    int searchLength \u003d searchList.length;\n    int replacementLength \u003d replacementList.length;\n    if (searchLength !\u003d replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don\u0027t match: \" + searchLength + \" vs \" + replacementLength);\n    }\n    boolean[] noMoreMatchesForReplIndex \u003d new boolean[searchLength];\n    int textIndex \u003d -1;\n    int replaceIndex \u003d -1;\n    int tempIndex \u003d -1;\n    for (int i \u003d 0; i \u003c searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] \u003d\u003d null || searchList[i].length() \u003d\u003d 0 || replacementList[i] \u003d\u003d null) {\n            continue;\n        }\n        tempIndex \u003d text.indexOf(searchList[i]);\n        if (tempIndex \u003d\u003d -1) {\n            noMoreMatchesForReplIndex[i] \u003d true;\n        } else {\n            if (textIndex \u003d\u003d -1 || tempIndex \u003c textIndex) {\n                textIndex \u003d tempIndex;\n                replaceIndex \u003d i;\n            }\n        }\n    }\n    if (textIndex \u003d\u003d -1) {\n        return text;\n    }\n    int start \u003d 0;\n    int increase \u003d 0;\n    for (int i \u003d 0; i \u003c searchList.length; i++) {\n        int greater \u003d replacementList[i].length() - searchList[i].length();\n        if (greater \u003e 0) {\n            increase +\u003d 3 * greater;\n        }\n    }\n    increase \u003d Math.min(increase, text.length() / 5);\n    StringBuilder buf \u003d new StringBuilder(text.length() + increase);\n    while (textIndex !\u003d -1) {\n        for (int i \u003d start; i \u003c textIndex; i++) {\n            buf.append(text.charAt(i));\n        }\n        buf.append(replacementList[replaceIndex]);\n        start \u003d textIndex + searchList[replaceIndex].length();\n        textIndex \u003d -1;\n        replaceIndex \u003d -1;\n        tempIndex \u003d -1;\n        for (int i \u003d 0; i \u003c searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] \u003d\u003d null || searchList[i].length() \u003d\u003d 0 || replacementList[i] \u003d\u003d null) {\n                continue;\n            }\n            tempIndex \u003d text.indexOf(searchList[i], start);\n            if (tempIndex \u003d\u003d -1) {\n                noMoreMatchesForReplIndex[i] \u003d true;\n            } else {\n                if (textIndex \u003d\u003d -1 || tempIndex \u003c textIndex) {\n                    textIndex \u003d tempIndex;\n                    replaceIndex \u003d i;\n                }\n            }\n        }\n    }\n    int textLength \u003d text.length();\n    for (int i \u003d start; i \u003c textLength; i++) {\n        buf.append(text.charAt(i));\n    }\n    String result \u003d buf.toString();\n    if (!repeat) {\n        return result;\n    }\n    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n}",
      "path": "src/java/org/apache/commons/lang/StringUtils.java",
      "functionStartLine": 3535,
      "functionName": "replaceEach",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003e\nReplaces all occurrences of Strings within another String.\n\u003c/p\u003e\n\n\u003cp\u003e\nA \u003ccode\u003enull\u003c/code\u003e reference passed to this method is a no-op, or if\nany \"search string\" or \"string to replace\" is null, that replace will be\nignored. \n\u003c/p\u003e\n\n\u003cpre\u003e\n StringUtils.replaceEach(null, *, *, *) \u003d null\n StringUtils.replaceEach(\"\", *, *, *) \u003d \"\"\n StringUtils.replaceEach(\"aba\", null, null, *) \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", new String[0], null, *) \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", null, new String[0], *) \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, null, *) \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, new String[]{\"\"}, *) \u003d \"b\"\n StringUtils.replaceEach(\"aba\", new String[]{null}, new String[]{\"a\"}, *) \u003d \"aba\"\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"w\", \"t\"}, *) \u003d \"wcte\"\n (example of how it repeats)\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, false) \u003d \"dcte\"\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, true) \u003d \"tcte\"\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"ab\"}, *) \u003d IllegalArgumentException\n\u003c/pre\u003e\n\n@param text text to search and replace in, no-op if null\n@param searchList the Strings to search for, no-op if null\n@param replacementList the Strings to replace them with, no-op if null\n@param repeat if true, then replace repeatedly \n      until there are no more possible replacements or timeToLive \u003c 0\n@param timeToLive if less than 0 then there is a circular reference and endless\n           loop\n@return the text with any replacements processed, \u003ccode\u003enull\u003c/code\u003e if\n        null String input\n@throws IllegalArgumentException\n            if the search is repeating and there is an endless loop due\n            to outputs of one being inputs to another\n@throws IndexOutOfBoundsException\n            if the lengths of the arrays are not the same (null is ok,\n            and/or size 0)\n@since 2.4\n",
      "diff": "@@ -1,77 +1,77 @@\n private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) {\n     if (text \u003d\u003d null || text.length() \u003d\u003d 0 || searchList \u003d\u003d null || searchList.length \u003d\u003d 0 || replacementList \u003d\u003d null || replacementList.length \u003d\u003d 0) {\n         return text;\n     }\n     if (timeToLive \u003c 0) {\n         throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n     }\n     int searchLength \u003d searchList.length;\n     int replacementLength \u003d replacementList.length;\n     if (searchLength !\u003d replacementLength) {\n         throw new IllegalArgumentException(\"Search and Replace array lengths don\u0027t match: \" + searchLength + \" vs \" + replacementLength);\n     }\n     boolean[] noMoreMatchesForReplIndex \u003d new boolean[searchLength];\n     int textIndex \u003d -1;\n     int replaceIndex \u003d -1;\n     int tempIndex \u003d -1;\n     for (int i \u003d 0; i \u003c searchLength; i++) {\n         if (noMoreMatchesForReplIndex[i] || searchList[i] \u003d\u003d null || searchList[i].length() \u003d\u003d 0 || replacementList[i] \u003d\u003d null) {\n             continue;\n         }\n         tempIndex \u003d text.indexOf(searchList[i]);\n         if (tempIndex \u003d\u003d -1) {\n             noMoreMatchesForReplIndex[i] \u003d true;\n         } else {\n             if (textIndex \u003d\u003d -1 || tempIndex \u003c textIndex) {\n                 textIndex \u003d tempIndex;\n                 replaceIndex \u003d i;\n             }\n         }\n     }\n     if (textIndex \u003d\u003d -1) {\n         return text;\n     }\n     int start \u003d 0;\n     int increase \u003d 0;\n     for (int i \u003d 0; i \u003c searchList.length; i++) {\n         int greater \u003d replacementList[i].length() - searchList[i].length();\n         if (greater \u003e 0) {\n             increase +\u003d 3 * greater;\n         }\n     }\n     increase \u003d Math.min(increase, text.length() / 5);\n-    StringBuffer buf \u003d new StringBuffer(text.length() + increase);\n+    StringBuilder buf \u003d new StringBuilder(text.length() + increase);\n     while (textIndex !\u003d -1) {\n         for (int i \u003d start; i \u003c textIndex; i++) {\n             buf.append(text.charAt(i));\n         }\n         buf.append(replacementList[replaceIndex]);\n         start \u003d textIndex + searchList[replaceIndex].length();\n         textIndex \u003d -1;\n         replaceIndex \u003d -1;\n         tempIndex \u003d -1;\n         for (int i \u003d 0; i \u003c searchLength; i++) {\n             if (noMoreMatchesForReplIndex[i] || searchList[i] \u003d\u003d null || searchList[i].length() \u003d\u003d 0 || replacementList[i] \u003d\u003d null) {\n                 continue;\n             }\n             tempIndex \u003d text.indexOf(searchList[i], start);\n             if (tempIndex \u003d\u003d -1) {\n                 noMoreMatchesForReplIndex[i] \u003d true;\n             } else {\n                 if (textIndex \u003d\u003d -1 || tempIndex \u003c textIndex) {\n                     textIndex \u003d tempIndex;\n                     replaceIndex \u003d i;\n                 }\n             }\n         }\n     }\n     int textLength \u003d text.length();\n     for (int i \u003d start; i \u003c textLength; i++) {\n         buf.append(text.charAt(i));\n     }\n     String result \u003d buf.toString();\n     if (!repeat) {\n         return result;\n     }\n     return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "bf1476fafba6a50d40db1765859f47954dd5428c": {
      "type": "Ymultichange(Ydocchange,Yformatchange)",
      "commitMessage": "Dealing with some of the \u003e120 length lines as per checkstyle. A few still need reducing. \n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@635447 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "3/9/08, 11:27 PM",
      "commitName": "bf1476fafba6a50d40db1765859f47954dd5428c",
      "commitAuthor": "Henri Yandell",
      "subchanges": [
        {
          "type": "Ydocchange",
          "commitMessage": "Dealing with some of the \u003e120 length lines as per checkstyle. A few still need reducing. \n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@635447 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "3/9/08, 11:27 PM",
          "commitName": "bf1476fafba6a50d40db1765859f47954dd5428c",
          "commitAuthor": "Henri Yandell",
          "commitDateOld": "2/28/08, 9:15 AM",
          "commitNameOld": "ce73c048f336f01ecb052c5daa50066faf2c3d07",
          "commitAuthorOld": "Matthew Jason Benson",
          "daysBetweenCommits": 10.55,
          "commitsBetweenForRepo": 15,
          "commitsBetweenForFile": 1,
          "actualSource": "private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) {\n    if (text \u003d\u003d null || text.length() \u003d\u003d 0 || searchList \u003d\u003d null || searchList.length \u003d\u003d 0 || replacementList \u003d\u003d null || replacementList.length \u003d\u003d 0) {\n        return text;\n    }\n    if (timeToLive \u003c 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n    int searchLength \u003d searchList.length;\n    int replacementLength \u003d replacementList.length;\n    if (searchLength !\u003d replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don\u0027t match: \" + searchLength + \" vs \" + replacementLength);\n    }\n    boolean[] noMoreMatchesForReplIndex \u003d new boolean[searchLength];\n    int textIndex \u003d -1;\n    int replaceIndex \u003d -1;\n    int tempIndex \u003d -1;\n    for (int i \u003d 0; i \u003c searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] \u003d\u003d null || searchList[i].length() \u003d\u003d 0 || replacementList[i] \u003d\u003d null) {\n            continue;\n        }\n        tempIndex \u003d text.indexOf(searchList[i]);\n        if (tempIndex \u003d\u003d -1) {\n            noMoreMatchesForReplIndex[i] \u003d true;\n        } else {\n            if (textIndex \u003d\u003d -1 || tempIndex \u003c textIndex) {\n                textIndex \u003d tempIndex;\n                replaceIndex \u003d i;\n            }\n        }\n    }\n    if (textIndex \u003d\u003d -1) {\n        return text;\n    }\n    int start \u003d 0;\n    int increase \u003d 0;\n    for (int i \u003d 0; i \u003c searchList.length; i++) {\n        int greater \u003d replacementList[i].length() - searchList[i].length();\n        if (greater \u003e 0) {\n            increase +\u003d 3 * greater;\n        }\n    }\n    increase \u003d Math.min(increase, text.length() / 5);\n    StringBuffer buf \u003d new StringBuffer(text.length() + increase);\n    while (textIndex !\u003d -1) {\n        for (int i \u003d start; i \u003c textIndex; i++) {\n            buf.append(text.charAt(i));\n        }\n        buf.append(replacementList[replaceIndex]);\n        start \u003d textIndex + searchList[replaceIndex].length();\n        textIndex \u003d -1;\n        replaceIndex \u003d -1;\n        tempIndex \u003d -1;\n        for (int i \u003d 0; i \u003c searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] \u003d\u003d null || searchList[i].length() \u003d\u003d 0 || replacementList[i] \u003d\u003d null) {\n                continue;\n            }\n            tempIndex \u003d text.indexOf(searchList[i], start);\n            if (tempIndex \u003d\u003d -1) {\n                noMoreMatchesForReplIndex[i] \u003d true;\n            } else {\n                if (textIndex \u003d\u003d -1 || tempIndex \u003c textIndex) {\n                    textIndex \u003d tempIndex;\n                    replaceIndex \u003d i;\n                }\n            }\n        }\n    }\n    int textLength \u003d text.length();\n    for (int i \u003d start; i \u003c textLength; i++) {\n        buf.append(text.charAt(i));\n    }\n    String result \u003d buf.toString();\n    if (!repeat) {\n        return result;\n    }\n    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n}",
          "path": "src/java/org/apache/commons/lang/StringUtils.java",
          "functionStartLine": 3658,
          "functionName": "replaceEach",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003e\nReplaces all occurrences of Strings within another String.\n\u003c/p\u003e\n\n\u003cp\u003e\nA \u003ccode\u003enull\u003c/code\u003e reference passed to this method is a no-op, or if\nany \"search string\" or \"string to replace\" is null, that replace will be\nignored. \n\u003c/p\u003e\n\n\u003cpre\u003e\n StringUtils.replaceEach(null, *, *, *) \u003d null\n StringUtils.replaceEach(\"\", *, *, *) \u003d \"\"\n StringUtils.replaceEach(\"aba\", null, null, *) \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", new String[0], null, *) \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", null, new String[0], *) \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, null, *) \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, new String[]{\"\"}, *) \u003d \"b\"\n StringUtils.replaceEach(\"aba\", new String[]{null}, new String[]{\"a\"}, *) \u003d \"aba\"\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"w\", \"t\"}, *) \u003d \"wcte\"\n (example of how it repeats)\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, false) \u003d \"dcte\"\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, true) \u003d \"tcte\"\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"ab\"}, *) \u003d IllegalArgumentException\n\u003c/pre\u003e\n\n@param text text to search and replace in, no-op if null\n@param searchList the Strings to search for, no-op if null\n@param replacementList the Strings to replace them with, no-op if null\n@param repeat if true, then replace repeatedly \n      until there are no more possible replacements or timeToLive \u003c 0\n@param timeToLive if less than 0 then there is a circular reference and endless\n           loop\n@return the text with any replacements processed, \u003ccode\u003enull\u003c/code\u003e if\n        null String input\n@throws IllegalArgumentException\n            if the search is repeating and there is an endless loop due\n            to outputs of one being inputs to another\n@throws IndexOutOfBoundsException\n            if the lengths of the arrays are not the same (null is ok,\n            and/or size 0)\n@since 2.4\n",
          "diff": "",
          "extendedDetails": {
            "oldValue": "\u003cp\u003e\nReplaces all occurrences of Strings within another String.\n\u003c/p\u003e\n\n\u003cp\u003e\nA \u003ccode\u003enull\u003c/code\u003e reference passed to this method is a no-op, or if\nany \"search string\" or \"string to replace\" is null, that replace will be\nignored. \n\u003c/p\u003e\n\n\u003cpre\u003e\n StringUtils.replaceEach(null, *, *, *)        \u003d null\n StringUtils.replaceEach(\"\", *, *, *)          \u003d \"\"\n StringUtils.replaceEach(\"aba\", null, null, *) \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", new String[0], null, *) \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", null, new String[0], *) \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, null, *)  \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, new String[]{\"\"}, *)  \u003d \"b\"\n StringUtils.replaceEach(\"aba\", new String[]{null}, new String[]{\"a\"}, *)  \u003d \"aba\"\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"w\", \"t\"}, *)  \u003d \"wcte\"\n (example of how it repeats)\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, false)  \u003d \"dcte\"\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, true)  \u003d \"tcte\"\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"ab\"}, *)  \u003d IllegalArgumentException\n\u003c/pre\u003e\n\n@param text text to search and replace in, no-op if null\n@param searchList the Strings to search for, no-op if null\n@param replacementList the Strings to replace them with, no-op if null\n@param repeat if true, then replace repeatedly \n      until there are no more possible replacements or timeToLive \u003c 0\n@param timeToLive if less than 0 then there is a circular reference and endless\n           loop\n@return the text with any replacements processed, \u003ccode\u003enull\u003c/code\u003e if\n        null String input\n@throws IllegalArgumentException\n            if the search is repeating and there is an endless loop due\n            to outputs of one being inputs to another\n@throws IndexOutOfBoundsException\n            if the lengths of the arrays are not the same (null is ok,\n            and/or size 0)\n@since 2.4\n",
            "newValue": "\u003cp\u003e\nReplaces all occurrences of Strings within another String.\n\u003c/p\u003e\n\n\u003cp\u003e\nA \u003ccode\u003enull\u003c/code\u003e reference passed to this method is a no-op, or if\nany \"search string\" or \"string to replace\" is null, that replace will be\nignored. \n\u003c/p\u003e\n\n\u003cpre\u003e\n StringUtils.replaceEach(null, *, *, *) \u003d null\n StringUtils.replaceEach(\"\", *, *, *) \u003d \"\"\n StringUtils.replaceEach(\"aba\", null, null, *) \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", new String[0], null, *) \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", null, new String[0], *) \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, null, *) \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, new String[]{\"\"}, *) \u003d \"b\"\n StringUtils.replaceEach(\"aba\", new String[]{null}, new String[]{\"a\"}, *) \u003d \"aba\"\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"w\", \"t\"}, *) \u003d \"wcte\"\n (example of how it repeats)\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, false) \u003d \"dcte\"\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, true) \u003d \"tcte\"\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"ab\"}, *) \u003d IllegalArgumentException\n\u003c/pre\u003e\n\n@param text text to search and replace in, no-op if null\n@param searchList the Strings to search for, no-op if null\n@param replacementList the Strings to replace them with, no-op if null\n@param repeat if true, then replace repeatedly \n      until there are no more possible replacements or timeToLive \u003c 0\n@param timeToLive if less than 0 then there is a circular reference and endless\n           loop\n@return the text with any replacements processed, \u003ccode\u003enull\u003c/code\u003e if\n        null String input\n@throws IllegalArgumentException\n            if the search is repeating and there is an endless loop due\n            to outputs of one being inputs to another\n@throws IndexOutOfBoundsException\n            if the lengths of the arrays are not the same (null is ok,\n            and/or size 0)\n@since 2.4\n"
          }
        },
        {
          "type": "Yformatchange",
          "commitMessage": "Dealing with some of the \u003e120 length lines as per checkstyle. A few still need reducing. \n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@635447 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "3/9/08, 11:27 PM",
          "commitName": "bf1476fafba6a50d40db1765859f47954dd5428c",
          "commitAuthor": "Henri Yandell",
          "commitDateOld": "2/28/08, 9:15 AM",
          "commitNameOld": "ce73c048f336f01ecb052c5daa50066faf2c3d07",
          "commitAuthorOld": "Matthew Jason Benson",
          "daysBetweenCommits": 10.55,
          "commitsBetweenForRepo": 15,
          "commitsBetweenForFile": 1,
          "actualSource": "private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) {\n    if (text \u003d\u003d null || text.length() \u003d\u003d 0 || searchList \u003d\u003d null || searchList.length \u003d\u003d 0 || replacementList \u003d\u003d null || replacementList.length \u003d\u003d 0) {\n        return text;\n    }\n    if (timeToLive \u003c 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n    int searchLength \u003d searchList.length;\n    int replacementLength \u003d replacementList.length;\n    if (searchLength !\u003d replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don\u0027t match: \" + searchLength + \" vs \" + replacementLength);\n    }\n    boolean[] noMoreMatchesForReplIndex \u003d new boolean[searchLength];\n    int textIndex \u003d -1;\n    int replaceIndex \u003d -1;\n    int tempIndex \u003d -1;\n    for (int i \u003d 0; i \u003c searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] \u003d\u003d null || searchList[i].length() \u003d\u003d 0 || replacementList[i] \u003d\u003d null) {\n            continue;\n        }\n        tempIndex \u003d text.indexOf(searchList[i]);\n        if (tempIndex \u003d\u003d -1) {\n            noMoreMatchesForReplIndex[i] \u003d true;\n        } else {\n            if (textIndex \u003d\u003d -1 || tempIndex \u003c textIndex) {\n                textIndex \u003d tempIndex;\n                replaceIndex \u003d i;\n            }\n        }\n    }\n    if (textIndex \u003d\u003d -1) {\n        return text;\n    }\n    int start \u003d 0;\n    int increase \u003d 0;\n    for (int i \u003d 0; i \u003c searchList.length; i++) {\n        int greater \u003d replacementList[i].length() - searchList[i].length();\n        if (greater \u003e 0) {\n            increase +\u003d 3 * greater;\n        }\n    }\n    increase \u003d Math.min(increase, text.length() / 5);\n    StringBuffer buf \u003d new StringBuffer(text.length() + increase);\n    while (textIndex !\u003d -1) {\n        for (int i \u003d start; i \u003c textIndex; i++) {\n            buf.append(text.charAt(i));\n        }\n        buf.append(replacementList[replaceIndex]);\n        start \u003d textIndex + searchList[replaceIndex].length();\n        textIndex \u003d -1;\n        replaceIndex \u003d -1;\n        tempIndex \u003d -1;\n        for (int i \u003d 0; i \u003c searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] \u003d\u003d null || searchList[i].length() \u003d\u003d 0 || replacementList[i] \u003d\u003d null) {\n                continue;\n            }\n            tempIndex \u003d text.indexOf(searchList[i], start);\n            if (tempIndex \u003d\u003d -1) {\n                noMoreMatchesForReplIndex[i] \u003d true;\n            } else {\n                if (textIndex \u003d\u003d -1 || tempIndex \u003c textIndex) {\n                    textIndex \u003d tempIndex;\n                    replaceIndex \u003d i;\n                }\n            }\n        }\n    }\n    int textLength \u003d text.length();\n    for (int i \u003d start; i \u003c textLength; i++) {\n        buf.append(text.charAt(i));\n    }\n    String result \u003d buf.toString();\n    if (!repeat) {\n        return result;\n    }\n    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n}",
          "path": "src/java/org/apache/commons/lang/StringUtils.java",
          "functionStartLine": 3658,
          "functionName": "replaceEach",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003e\nReplaces all occurrences of Strings within another String.\n\u003c/p\u003e\n\n\u003cp\u003e\nA \u003ccode\u003enull\u003c/code\u003e reference passed to this method is a no-op, or if\nany \"search string\" or \"string to replace\" is null, that replace will be\nignored. \n\u003c/p\u003e\n\n\u003cpre\u003e\n StringUtils.replaceEach(null, *, *, *) \u003d null\n StringUtils.replaceEach(\"\", *, *, *) \u003d \"\"\n StringUtils.replaceEach(\"aba\", null, null, *) \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", new String[0], null, *) \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", null, new String[0], *) \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, null, *) \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, new String[]{\"\"}, *) \u003d \"b\"\n StringUtils.replaceEach(\"aba\", new String[]{null}, new String[]{\"a\"}, *) \u003d \"aba\"\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"w\", \"t\"}, *) \u003d \"wcte\"\n (example of how it repeats)\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, false) \u003d \"dcte\"\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, true) \u003d \"tcte\"\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"ab\"}, *) \u003d IllegalArgumentException\n\u003c/pre\u003e\n\n@param text text to search and replace in, no-op if null\n@param searchList the Strings to search for, no-op if null\n@param replacementList the Strings to replace them with, no-op if null\n@param repeat if true, then replace repeatedly \n      until there are no more possible replacements or timeToLive \u003c 0\n@param timeToLive if less than 0 then there is a circular reference and endless\n           loop\n@return the text with any replacements processed, \u003ccode\u003enull\u003c/code\u003e if\n        null String input\n@throws IllegalArgumentException\n            if the search is repeating and there is an endless loop due\n            to outputs of one being inputs to another\n@throws IndexOutOfBoundsException\n            if the lengths of the arrays are not the same (null is ok,\n            and/or size 0)\n@since 2.4\n",
          "diff": "",
          "extendedDetails": {}
        }
      ]
    },
    "5310e78952ca17521b7d5e83bfcefafa227187a5": {
      "type": "Ymultichange(Yparameterchange,Ybodychange,Ydocchange)",
      "commitMessage": "LANG-410 - Ambiguous / confusing names in StringUtils replace* methods\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@627588 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2/13/08, 12:41 PM",
      "commitName": "5310e78952ca17521b7d5e83bfcefafa227187a5",
      "commitAuthor": "Sebastian Bazley",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "LANG-410 - Ambiguous / confusing names in StringUtils replace* methods\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@627588 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2/13/08, 12:41 PM",
          "commitName": "5310e78952ca17521b7d5e83bfcefafa227187a5",
          "commitAuthor": "Sebastian Bazley",
          "commitDateOld": "2/6/08, 1:24 PM",
          "commitNameOld": "19f33e4e0d824e732d07f06a08567c27b3c808f3",
          "commitAuthorOld": "Matthew Jason Benson",
          "daysBetweenCommits": 6.97,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) {\n    if (text \u003d\u003d null || text.length() \u003d\u003d 0 || searchList \u003d\u003d null || searchList.length \u003d\u003d 0 || replacementList \u003d\u003d null || replacementList.length \u003d\u003d 0) {\n        return text;\n    }\n    if (timeToLive \u003c 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n    int searchLength \u003d searchList.length;\n    int replacementLength \u003d replacementList.length;\n    if (searchLength !\u003d replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don\u0027t match: \" + searchLength + \" vs \" + replacementLength);\n    }\n    boolean[] noMoreMatchesForReplIndex \u003d new boolean[searchLength];\n    int textIndex \u003d -1;\n    int replaceIndex \u003d -1;\n    int tempIndex \u003d -1;\n    for (int i \u003d 0; i \u003c searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] \u003d\u003d null || searchList[i].length() \u003d\u003d 0 || replacementList[i] \u003d\u003d null) {\n            continue;\n        }\n        tempIndex \u003d text.indexOf(searchList[i]);\n        if (tempIndex \u003d\u003d -1) {\n            noMoreMatchesForReplIndex[i] \u003d true;\n        } else {\n            if (textIndex \u003d\u003d -1 || tempIndex \u003c textIndex) {\n                textIndex \u003d tempIndex;\n                replaceIndex \u003d i;\n            }\n        }\n    }\n    if (textIndex \u003d\u003d -1) {\n        return text;\n    }\n    int start \u003d 0;\n    int increase \u003d 0;\n    for (int i \u003d 0; i \u003c searchList.length; i++) {\n        int greater \u003d replacementList[i].length() - searchList[i].length();\n        if (greater \u003e 0) {\n            increase +\u003d 3 * greater;\n        }\n    }\n    increase \u003d Math.min(increase, text.length() / 5);\n    StringBuffer buf \u003d new StringBuffer(text.length() + increase);\n    while (textIndex !\u003d -1) {\n        for (int i \u003d start; i \u003c textIndex; i++) {\n            buf.append(text.charAt(i));\n        }\n        buf.append(replacementList[replaceIndex]);\n        start \u003d textIndex + searchList[replaceIndex].length();\n        textIndex \u003d -1;\n        replaceIndex \u003d -1;\n        tempIndex \u003d -1;\n        for (int i \u003d 0; i \u003c searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] \u003d\u003d null || searchList[i].length() \u003d\u003d 0 || replacementList[i] \u003d\u003d null) {\n                continue;\n            }\n            tempIndex \u003d text.indexOf(searchList[i], start);\n            if (tempIndex \u003d\u003d -1) {\n                noMoreMatchesForReplIndex[i] \u003d true;\n            } else {\n                if (textIndex \u003d\u003d -1 || tempIndex \u003c textIndex) {\n                    textIndex \u003d tempIndex;\n                    replaceIndex \u003d i;\n                }\n            }\n        }\n    }\n    int textLength \u003d text.length();\n    for (int i \u003d start; i \u003c textLength; i++) {\n        buf.append(text.charAt(i));\n    }\n    String result \u003d buf.toString();\n    if (!repeat) {\n        return result;\n    }\n    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n}",
          "path": "src/java/org/apache/commons/lang/StringUtils.java",
          "functionStartLine": 3658,
          "functionName": "replaceEach",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003e\nReplaces all occurrences of Strings within another String.\n\u003c/p\u003e\n\n\u003cp\u003e\nA \u003ccode\u003enull\u003c/code\u003e reference passed to this method is a no-op, or if\nany \"search string\" or \"string to replace\" is null, that replace will be\nignored. \n\u003c/p\u003e\n\n\u003cpre\u003e\n StringUtils.replaceEach(null, *, *, *)        \u003d null\n StringUtils.replaceEach(\"\", *, *, *)          \u003d \"\"\n StringUtils.replaceEach(\"aba\", null, null, *) \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", new String[0], null, *) \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", null, new String[0], *) \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, null, *)  \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, new String[]{\"\"}, *)  \u003d \"b\"\n StringUtils.replaceEach(\"aba\", new String[]{null}, new String[]{\"a\"}, *)  \u003d \"aba\"\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"w\", \"t\"}, *)  \u003d \"wcte\"\n (example of how it repeats)\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, false)  \u003d \"dcte\"\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, true)  \u003d \"tcte\"\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"ab\"}, *)  \u003d IllegalArgumentException\n\u003c/pre\u003e\n\n@param text text to search and replace in, no-op if null\n@param searchList the Strings to search for, no-op if null\n@param replacementList the Strings to replace them with, no-op if null\n@param repeat if true, then replace repeatedly \n      until there are no more possible replacements or timeToLive \u003c 0\n@param timeToLive if less than 0 then there is a circular reference and endless\n           loop\n@return the text with any replacements processed, \u003ccode\u003enull\u003c/code\u003e if\n        null String input\n@throws IllegalArgumentException\n            if the search is repeating and there is an endless loop due\n            to outputs of one being inputs to another\n@throws IndexOutOfBoundsException\n            if the lengths of the arrays are not the same (null is ok,\n            and/or size 0)\n@since 2.4\n",
          "diff": "@@ -1,77 +1,77 @@\n-private static String replaceEach(String text, String[] repl, String[] with, boolean repeat, int timeToLive) {\n-    if (text \u003d\u003d null || text.length() \u003d\u003d 0 || repl \u003d\u003d null || repl.length \u003d\u003d 0 || with \u003d\u003d null || with.length \u003d\u003d 0) {\n+private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) {\n+    if (text \u003d\u003d null || text.length() \u003d\u003d 0 || searchList \u003d\u003d null || searchList.length \u003d\u003d 0 || replacementList \u003d\u003d null || replacementList.length \u003d\u003d 0) {\n         return text;\n     }\n     if (timeToLive \u003c 0) {\n         throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n     }\n-    int replLength \u003d repl.length;\n-    int withLength \u003d with.length;\n-    if (replLength !\u003d withLength) {\n-        throw new IllegalArgumentException(\"Search and Replace array lengths don\u0027t match: \" + replLength + \" vs \" + withLength);\n+    int searchLength \u003d searchList.length;\n+    int replacementLength \u003d replacementList.length;\n+    if (searchLength !\u003d replacementLength) {\n+        throw new IllegalArgumentException(\"Search and Replace array lengths don\u0027t match: \" + searchLength + \" vs \" + replacementLength);\n     }\n-    boolean[] noMoreMatchesForReplIndex \u003d new boolean[replLength];\n+    boolean[] noMoreMatchesForReplIndex \u003d new boolean[searchLength];\n     int textIndex \u003d -1;\n     int replaceIndex \u003d -1;\n     int tempIndex \u003d -1;\n-    for (int i \u003d 0; i \u003c replLength; i++) {\n-        if (noMoreMatchesForReplIndex[i] || repl[i] \u003d\u003d null || repl[i].length() \u003d\u003d 0 || with[i] \u003d\u003d null) {\n+    for (int i \u003d 0; i \u003c searchLength; i++) {\n+        if (noMoreMatchesForReplIndex[i] || searchList[i] \u003d\u003d null || searchList[i].length() \u003d\u003d 0 || replacementList[i] \u003d\u003d null) {\n             continue;\n         }\n-        tempIndex \u003d text.indexOf(repl[i]);\n+        tempIndex \u003d text.indexOf(searchList[i]);\n         if (tempIndex \u003d\u003d -1) {\n             noMoreMatchesForReplIndex[i] \u003d true;\n         } else {\n             if (textIndex \u003d\u003d -1 || tempIndex \u003c textIndex) {\n                 textIndex \u003d tempIndex;\n                 replaceIndex \u003d i;\n             }\n         }\n     }\n     if (textIndex \u003d\u003d -1) {\n         return text;\n     }\n     int start \u003d 0;\n     int increase \u003d 0;\n-    for (int i \u003d 0; i \u003c repl.length; i++) {\n-        int greater \u003d with[i].length() - repl[i].length();\n+    for (int i \u003d 0; i \u003c searchList.length; i++) {\n+        int greater \u003d replacementList[i].length() - searchList[i].length();\n         if (greater \u003e 0) {\n             increase +\u003d 3 * greater;\n         }\n     }\n     increase \u003d Math.min(increase, text.length() / 5);\n     StringBuffer buf \u003d new StringBuffer(text.length() + increase);\n     while (textIndex !\u003d -1) {\n         for (int i \u003d start; i \u003c textIndex; i++) {\n             buf.append(text.charAt(i));\n         }\n-        buf.append(with[replaceIndex]);\n-        start \u003d textIndex + repl[replaceIndex].length();\n+        buf.append(replacementList[replaceIndex]);\n+        start \u003d textIndex + searchList[replaceIndex].length();\n         textIndex \u003d -1;\n         replaceIndex \u003d -1;\n         tempIndex \u003d -1;\n-        for (int i \u003d 0; i \u003c replLength; i++) {\n-            if (noMoreMatchesForReplIndex[i] || repl[i] \u003d\u003d null || repl[i].length() \u003d\u003d 0 || with[i] \u003d\u003d null) {\n+        for (int i \u003d 0; i \u003c searchLength; i++) {\n+            if (noMoreMatchesForReplIndex[i] || searchList[i] \u003d\u003d null || searchList[i].length() \u003d\u003d 0 || replacementList[i] \u003d\u003d null) {\n                 continue;\n             }\n-            tempIndex \u003d text.indexOf(repl[i], start);\n+            tempIndex \u003d text.indexOf(searchList[i], start);\n             if (tempIndex \u003d\u003d -1) {\n                 noMoreMatchesForReplIndex[i] \u003d true;\n             } else {\n                 if (textIndex \u003d\u003d -1 || tempIndex \u003c textIndex) {\n                     textIndex \u003d tempIndex;\n                     replaceIndex \u003d i;\n                 }\n             }\n         }\n     }\n     int textLength \u003d text.length();\n     for (int i \u003d start; i \u003c textLength; i++) {\n         buf.append(text.charAt(i));\n     }\n     String result \u003d buf.toString();\n     if (!repeat) {\n         return result;\n     }\n-    return replaceEach(result, repl, with, repeat, timeToLive - 1);\n+    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[text-String, repl-String[], with-String[], repeat-boolean, timeToLive-int]",
            "newValue": "[text-String, searchList-String[], replacementList-String[], repeat-boolean, timeToLive-int]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "LANG-410 - Ambiguous / confusing names in StringUtils replace* methods\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@627588 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2/13/08, 12:41 PM",
          "commitName": "5310e78952ca17521b7d5e83bfcefafa227187a5",
          "commitAuthor": "Sebastian Bazley",
          "commitDateOld": "2/6/08, 1:24 PM",
          "commitNameOld": "19f33e4e0d824e732d07f06a08567c27b3c808f3",
          "commitAuthorOld": "Matthew Jason Benson",
          "daysBetweenCommits": 6.97,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) {\n    if (text \u003d\u003d null || text.length() \u003d\u003d 0 || searchList \u003d\u003d null || searchList.length \u003d\u003d 0 || replacementList \u003d\u003d null || replacementList.length \u003d\u003d 0) {\n        return text;\n    }\n    if (timeToLive \u003c 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n    int searchLength \u003d searchList.length;\n    int replacementLength \u003d replacementList.length;\n    if (searchLength !\u003d replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don\u0027t match: \" + searchLength + \" vs \" + replacementLength);\n    }\n    boolean[] noMoreMatchesForReplIndex \u003d new boolean[searchLength];\n    int textIndex \u003d -1;\n    int replaceIndex \u003d -1;\n    int tempIndex \u003d -1;\n    for (int i \u003d 0; i \u003c searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] \u003d\u003d null || searchList[i].length() \u003d\u003d 0 || replacementList[i] \u003d\u003d null) {\n            continue;\n        }\n        tempIndex \u003d text.indexOf(searchList[i]);\n        if (tempIndex \u003d\u003d -1) {\n            noMoreMatchesForReplIndex[i] \u003d true;\n        } else {\n            if (textIndex \u003d\u003d -1 || tempIndex \u003c textIndex) {\n                textIndex \u003d tempIndex;\n                replaceIndex \u003d i;\n            }\n        }\n    }\n    if (textIndex \u003d\u003d -1) {\n        return text;\n    }\n    int start \u003d 0;\n    int increase \u003d 0;\n    for (int i \u003d 0; i \u003c searchList.length; i++) {\n        int greater \u003d replacementList[i].length() - searchList[i].length();\n        if (greater \u003e 0) {\n            increase +\u003d 3 * greater;\n        }\n    }\n    increase \u003d Math.min(increase, text.length() / 5);\n    StringBuffer buf \u003d new StringBuffer(text.length() + increase);\n    while (textIndex !\u003d -1) {\n        for (int i \u003d start; i \u003c textIndex; i++) {\n            buf.append(text.charAt(i));\n        }\n        buf.append(replacementList[replaceIndex]);\n        start \u003d textIndex + searchList[replaceIndex].length();\n        textIndex \u003d -1;\n        replaceIndex \u003d -1;\n        tempIndex \u003d -1;\n        for (int i \u003d 0; i \u003c searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] \u003d\u003d null || searchList[i].length() \u003d\u003d 0 || replacementList[i] \u003d\u003d null) {\n                continue;\n            }\n            tempIndex \u003d text.indexOf(searchList[i], start);\n            if (tempIndex \u003d\u003d -1) {\n                noMoreMatchesForReplIndex[i] \u003d true;\n            } else {\n                if (textIndex \u003d\u003d -1 || tempIndex \u003c textIndex) {\n                    textIndex \u003d tempIndex;\n                    replaceIndex \u003d i;\n                }\n            }\n        }\n    }\n    int textLength \u003d text.length();\n    for (int i \u003d start; i \u003c textLength; i++) {\n        buf.append(text.charAt(i));\n    }\n    String result \u003d buf.toString();\n    if (!repeat) {\n        return result;\n    }\n    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n}",
          "path": "src/java/org/apache/commons/lang/StringUtils.java",
          "functionStartLine": 3658,
          "functionName": "replaceEach",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003e\nReplaces all occurrences of Strings within another String.\n\u003c/p\u003e\n\n\u003cp\u003e\nA \u003ccode\u003enull\u003c/code\u003e reference passed to this method is a no-op, or if\nany \"search string\" or \"string to replace\" is null, that replace will be\nignored. \n\u003c/p\u003e\n\n\u003cpre\u003e\n StringUtils.replaceEach(null, *, *, *)        \u003d null\n StringUtils.replaceEach(\"\", *, *, *)          \u003d \"\"\n StringUtils.replaceEach(\"aba\", null, null, *) \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", new String[0], null, *) \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", null, new String[0], *) \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, null, *)  \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, new String[]{\"\"}, *)  \u003d \"b\"\n StringUtils.replaceEach(\"aba\", new String[]{null}, new String[]{\"a\"}, *)  \u003d \"aba\"\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"w\", \"t\"}, *)  \u003d \"wcte\"\n (example of how it repeats)\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, false)  \u003d \"dcte\"\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, true)  \u003d \"tcte\"\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"ab\"}, *)  \u003d IllegalArgumentException\n\u003c/pre\u003e\n\n@param text text to search and replace in, no-op if null\n@param searchList the Strings to search for, no-op if null\n@param replacementList the Strings to replace them with, no-op if null\n@param repeat if true, then replace repeatedly \n      until there are no more possible replacements or timeToLive \u003c 0\n@param timeToLive if less than 0 then there is a circular reference and endless\n           loop\n@return the text with any replacements processed, \u003ccode\u003enull\u003c/code\u003e if\n        null String input\n@throws IllegalArgumentException\n            if the search is repeating and there is an endless loop due\n            to outputs of one being inputs to another\n@throws IndexOutOfBoundsException\n            if the lengths of the arrays are not the same (null is ok,\n            and/or size 0)\n@since 2.4\n",
          "diff": "@@ -1,77 +1,77 @@\n-private static String replaceEach(String text, String[] repl, String[] with, boolean repeat, int timeToLive) {\n-    if (text \u003d\u003d null || text.length() \u003d\u003d 0 || repl \u003d\u003d null || repl.length \u003d\u003d 0 || with \u003d\u003d null || with.length \u003d\u003d 0) {\n+private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) {\n+    if (text \u003d\u003d null || text.length() \u003d\u003d 0 || searchList \u003d\u003d null || searchList.length \u003d\u003d 0 || replacementList \u003d\u003d null || replacementList.length \u003d\u003d 0) {\n         return text;\n     }\n     if (timeToLive \u003c 0) {\n         throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n     }\n-    int replLength \u003d repl.length;\n-    int withLength \u003d with.length;\n-    if (replLength !\u003d withLength) {\n-        throw new IllegalArgumentException(\"Search and Replace array lengths don\u0027t match: \" + replLength + \" vs \" + withLength);\n+    int searchLength \u003d searchList.length;\n+    int replacementLength \u003d replacementList.length;\n+    if (searchLength !\u003d replacementLength) {\n+        throw new IllegalArgumentException(\"Search and Replace array lengths don\u0027t match: \" + searchLength + \" vs \" + replacementLength);\n     }\n-    boolean[] noMoreMatchesForReplIndex \u003d new boolean[replLength];\n+    boolean[] noMoreMatchesForReplIndex \u003d new boolean[searchLength];\n     int textIndex \u003d -1;\n     int replaceIndex \u003d -1;\n     int tempIndex \u003d -1;\n-    for (int i \u003d 0; i \u003c replLength; i++) {\n-        if (noMoreMatchesForReplIndex[i] || repl[i] \u003d\u003d null || repl[i].length() \u003d\u003d 0 || with[i] \u003d\u003d null) {\n+    for (int i \u003d 0; i \u003c searchLength; i++) {\n+        if (noMoreMatchesForReplIndex[i] || searchList[i] \u003d\u003d null || searchList[i].length() \u003d\u003d 0 || replacementList[i] \u003d\u003d null) {\n             continue;\n         }\n-        tempIndex \u003d text.indexOf(repl[i]);\n+        tempIndex \u003d text.indexOf(searchList[i]);\n         if (tempIndex \u003d\u003d -1) {\n             noMoreMatchesForReplIndex[i] \u003d true;\n         } else {\n             if (textIndex \u003d\u003d -1 || tempIndex \u003c textIndex) {\n                 textIndex \u003d tempIndex;\n                 replaceIndex \u003d i;\n             }\n         }\n     }\n     if (textIndex \u003d\u003d -1) {\n         return text;\n     }\n     int start \u003d 0;\n     int increase \u003d 0;\n-    for (int i \u003d 0; i \u003c repl.length; i++) {\n-        int greater \u003d with[i].length() - repl[i].length();\n+    for (int i \u003d 0; i \u003c searchList.length; i++) {\n+        int greater \u003d replacementList[i].length() - searchList[i].length();\n         if (greater \u003e 0) {\n             increase +\u003d 3 * greater;\n         }\n     }\n     increase \u003d Math.min(increase, text.length() / 5);\n     StringBuffer buf \u003d new StringBuffer(text.length() + increase);\n     while (textIndex !\u003d -1) {\n         for (int i \u003d start; i \u003c textIndex; i++) {\n             buf.append(text.charAt(i));\n         }\n-        buf.append(with[replaceIndex]);\n-        start \u003d textIndex + repl[replaceIndex].length();\n+        buf.append(replacementList[replaceIndex]);\n+        start \u003d textIndex + searchList[replaceIndex].length();\n         textIndex \u003d -1;\n         replaceIndex \u003d -1;\n         tempIndex \u003d -1;\n-        for (int i \u003d 0; i \u003c replLength; i++) {\n-            if (noMoreMatchesForReplIndex[i] || repl[i] \u003d\u003d null || repl[i].length() \u003d\u003d 0 || with[i] \u003d\u003d null) {\n+        for (int i \u003d 0; i \u003c searchLength; i++) {\n+            if (noMoreMatchesForReplIndex[i] || searchList[i] \u003d\u003d null || searchList[i].length() \u003d\u003d 0 || replacementList[i] \u003d\u003d null) {\n                 continue;\n             }\n-            tempIndex \u003d text.indexOf(repl[i], start);\n+            tempIndex \u003d text.indexOf(searchList[i], start);\n             if (tempIndex \u003d\u003d -1) {\n                 noMoreMatchesForReplIndex[i] \u003d true;\n             } else {\n                 if (textIndex \u003d\u003d -1 || tempIndex \u003c textIndex) {\n                     textIndex \u003d tempIndex;\n                     replaceIndex \u003d i;\n                 }\n             }\n         }\n     }\n     int textLength \u003d text.length();\n     for (int i \u003d start; i \u003c textLength; i++) {\n         buf.append(text.charAt(i));\n     }\n     String result \u003d buf.toString();\n     if (!repeat) {\n         return result;\n     }\n-    return replaceEach(result, repl, with, repeat, timeToLive - 1);\n+    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "LANG-410 - Ambiguous / confusing names in StringUtils replace* methods\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@627588 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2/13/08, 12:41 PM",
          "commitName": "5310e78952ca17521b7d5e83bfcefafa227187a5",
          "commitAuthor": "Sebastian Bazley",
          "commitDateOld": "2/6/08, 1:24 PM",
          "commitNameOld": "19f33e4e0d824e732d07f06a08567c27b3c808f3",
          "commitAuthorOld": "Matthew Jason Benson",
          "daysBetweenCommits": 6.97,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) {\n    if (text \u003d\u003d null || text.length() \u003d\u003d 0 || searchList \u003d\u003d null || searchList.length \u003d\u003d 0 || replacementList \u003d\u003d null || replacementList.length \u003d\u003d 0) {\n        return text;\n    }\n    if (timeToLive \u003c 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n    int searchLength \u003d searchList.length;\n    int replacementLength \u003d replacementList.length;\n    if (searchLength !\u003d replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don\u0027t match: \" + searchLength + \" vs \" + replacementLength);\n    }\n    boolean[] noMoreMatchesForReplIndex \u003d new boolean[searchLength];\n    int textIndex \u003d -1;\n    int replaceIndex \u003d -1;\n    int tempIndex \u003d -1;\n    for (int i \u003d 0; i \u003c searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] \u003d\u003d null || searchList[i].length() \u003d\u003d 0 || replacementList[i] \u003d\u003d null) {\n            continue;\n        }\n        tempIndex \u003d text.indexOf(searchList[i]);\n        if (tempIndex \u003d\u003d -1) {\n            noMoreMatchesForReplIndex[i] \u003d true;\n        } else {\n            if (textIndex \u003d\u003d -1 || tempIndex \u003c textIndex) {\n                textIndex \u003d tempIndex;\n                replaceIndex \u003d i;\n            }\n        }\n    }\n    if (textIndex \u003d\u003d -1) {\n        return text;\n    }\n    int start \u003d 0;\n    int increase \u003d 0;\n    for (int i \u003d 0; i \u003c searchList.length; i++) {\n        int greater \u003d replacementList[i].length() - searchList[i].length();\n        if (greater \u003e 0) {\n            increase +\u003d 3 * greater;\n        }\n    }\n    increase \u003d Math.min(increase, text.length() / 5);\n    StringBuffer buf \u003d new StringBuffer(text.length() + increase);\n    while (textIndex !\u003d -1) {\n        for (int i \u003d start; i \u003c textIndex; i++) {\n            buf.append(text.charAt(i));\n        }\n        buf.append(replacementList[replaceIndex]);\n        start \u003d textIndex + searchList[replaceIndex].length();\n        textIndex \u003d -1;\n        replaceIndex \u003d -1;\n        tempIndex \u003d -1;\n        for (int i \u003d 0; i \u003c searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] \u003d\u003d null || searchList[i].length() \u003d\u003d 0 || replacementList[i] \u003d\u003d null) {\n                continue;\n            }\n            tempIndex \u003d text.indexOf(searchList[i], start);\n            if (tempIndex \u003d\u003d -1) {\n                noMoreMatchesForReplIndex[i] \u003d true;\n            } else {\n                if (textIndex \u003d\u003d -1 || tempIndex \u003c textIndex) {\n                    textIndex \u003d tempIndex;\n                    replaceIndex \u003d i;\n                }\n            }\n        }\n    }\n    int textLength \u003d text.length();\n    for (int i \u003d start; i \u003c textLength; i++) {\n        buf.append(text.charAt(i));\n    }\n    String result \u003d buf.toString();\n    if (!repeat) {\n        return result;\n    }\n    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n}",
          "path": "src/java/org/apache/commons/lang/StringUtils.java",
          "functionStartLine": 3658,
          "functionName": "replaceEach",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003e\nReplaces all occurrences of Strings within another String.\n\u003c/p\u003e\n\n\u003cp\u003e\nA \u003ccode\u003enull\u003c/code\u003e reference passed to this method is a no-op, or if\nany \"search string\" or \"string to replace\" is null, that replace will be\nignored. \n\u003c/p\u003e\n\n\u003cpre\u003e\n StringUtils.replaceEach(null, *, *, *)        \u003d null\n StringUtils.replaceEach(\"\", *, *, *)          \u003d \"\"\n StringUtils.replaceEach(\"aba\", null, null, *) \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", new String[0], null, *) \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", null, new String[0], *) \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, null, *)  \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, new String[]{\"\"}, *)  \u003d \"b\"\n StringUtils.replaceEach(\"aba\", new String[]{null}, new String[]{\"a\"}, *)  \u003d \"aba\"\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"w\", \"t\"}, *)  \u003d \"wcte\"\n (example of how it repeats)\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, false)  \u003d \"dcte\"\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, true)  \u003d \"tcte\"\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"ab\"}, *)  \u003d IllegalArgumentException\n\u003c/pre\u003e\n\n@param text text to search and replace in, no-op if null\n@param searchList the Strings to search for, no-op if null\n@param replacementList the Strings to replace them with, no-op if null\n@param repeat if true, then replace repeatedly \n      until there are no more possible replacements or timeToLive \u003c 0\n@param timeToLive if less than 0 then there is a circular reference and endless\n           loop\n@return the text with any replacements processed, \u003ccode\u003enull\u003c/code\u003e if\n        null String input\n@throws IllegalArgumentException\n            if the search is repeating and there is an endless loop due\n            to outputs of one being inputs to another\n@throws IndexOutOfBoundsException\n            if the lengths of the arrays are not the same (null is ok,\n            and/or size 0)\n@since 2.4\n",
          "diff": "@@ -1,77 +1,77 @@\n-private static String replaceEach(String text, String[] repl, String[] with, boolean repeat, int timeToLive) {\n-    if (text \u003d\u003d null || text.length() \u003d\u003d 0 || repl \u003d\u003d null || repl.length \u003d\u003d 0 || with \u003d\u003d null || with.length \u003d\u003d 0) {\n+private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) {\n+    if (text \u003d\u003d null || text.length() \u003d\u003d 0 || searchList \u003d\u003d null || searchList.length \u003d\u003d 0 || replacementList \u003d\u003d null || replacementList.length \u003d\u003d 0) {\n         return text;\n     }\n     if (timeToLive \u003c 0) {\n         throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n     }\n-    int replLength \u003d repl.length;\n-    int withLength \u003d with.length;\n-    if (replLength !\u003d withLength) {\n-        throw new IllegalArgumentException(\"Search and Replace array lengths don\u0027t match: \" + replLength + \" vs \" + withLength);\n+    int searchLength \u003d searchList.length;\n+    int replacementLength \u003d replacementList.length;\n+    if (searchLength !\u003d replacementLength) {\n+        throw new IllegalArgumentException(\"Search and Replace array lengths don\u0027t match: \" + searchLength + \" vs \" + replacementLength);\n     }\n-    boolean[] noMoreMatchesForReplIndex \u003d new boolean[replLength];\n+    boolean[] noMoreMatchesForReplIndex \u003d new boolean[searchLength];\n     int textIndex \u003d -1;\n     int replaceIndex \u003d -1;\n     int tempIndex \u003d -1;\n-    for (int i \u003d 0; i \u003c replLength; i++) {\n-        if (noMoreMatchesForReplIndex[i] || repl[i] \u003d\u003d null || repl[i].length() \u003d\u003d 0 || with[i] \u003d\u003d null) {\n+    for (int i \u003d 0; i \u003c searchLength; i++) {\n+        if (noMoreMatchesForReplIndex[i] || searchList[i] \u003d\u003d null || searchList[i].length() \u003d\u003d 0 || replacementList[i] \u003d\u003d null) {\n             continue;\n         }\n-        tempIndex \u003d text.indexOf(repl[i]);\n+        tempIndex \u003d text.indexOf(searchList[i]);\n         if (tempIndex \u003d\u003d -1) {\n             noMoreMatchesForReplIndex[i] \u003d true;\n         } else {\n             if (textIndex \u003d\u003d -1 || tempIndex \u003c textIndex) {\n                 textIndex \u003d tempIndex;\n                 replaceIndex \u003d i;\n             }\n         }\n     }\n     if (textIndex \u003d\u003d -1) {\n         return text;\n     }\n     int start \u003d 0;\n     int increase \u003d 0;\n-    for (int i \u003d 0; i \u003c repl.length; i++) {\n-        int greater \u003d with[i].length() - repl[i].length();\n+    for (int i \u003d 0; i \u003c searchList.length; i++) {\n+        int greater \u003d replacementList[i].length() - searchList[i].length();\n         if (greater \u003e 0) {\n             increase +\u003d 3 * greater;\n         }\n     }\n     increase \u003d Math.min(increase, text.length() / 5);\n     StringBuffer buf \u003d new StringBuffer(text.length() + increase);\n     while (textIndex !\u003d -1) {\n         for (int i \u003d start; i \u003c textIndex; i++) {\n             buf.append(text.charAt(i));\n         }\n-        buf.append(with[replaceIndex]);\n-        start \u003d textIndex + repl[replaceIndex].length();\n+        buf.append(replacementList[replaceIndex]);\n+        start \u003d textIndex + searchList[replaceIndex].length();\n         textIndex \u003d -1;\n         replaceIndex \u003d -1;\n         tempIndex \u003d -1;\n-        for (int i \u003d 0; i \u003c replLength; i++) {\n-            if (noMoreMatchesForReplIndex[i] || repl[i] \u003d\u003d null || repl[i].length() \u003d\u003d 0 || with[i] \u003d\u003d null) {\n+        for (int i \u003d 0; i \u003c searchLength; i++) {\n+            if (noMoreMatchesForReplIndex[i] || searchList[i] \u003d\u003d null || searchList[i].length() \u003d\u003d 0 || replacementList[i] \u003d\u003d null) {\n                 continue;\n             }\n-            tempIndex \u003d text.indexOf(repl[i], start);\n+            tempIndex \u003d text.indexOf(searchList[i], start);\n             if (tempIndex \u003d\u003d -1) {\n                 noMoreMatchesForReplIndex[i] \u003d true;\n             } else {\n                 if (textIndex \u003d\u003d -1 || tempIndex \u003c textIndex) {\n                     textIndex \u003d tempIndex;\n                     replaceIndex \u003d i;\n                 }\n             }\n         }\n     }\n     int textLength \u003d text.length();\n     for (int i \u003d start; i \u003c textLength; i++) {\n         buf.append(text.charAt(i));\n     }\n     String result \u003d buf.toString();\n     if (!repeat) {\n         return result;\n     }\n-    return replaceEach(result, repl, with, repeat, timeToLive - 1);\n+    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "\u003cp\u003e\nReplaces all occurrences of Strings within another String.\n\u003c/p\u003e\n\n\u003cp\u003e\nA \u003ccode\u003enull\u003c/code\u003e reference passed to this method is a no-op, or if\nany \"search string\" or \"string to replace\" is null, that replace will be\nignored. \n\u003c/p\u003e\n\n\u003cpre\u003e\n StringUtils.replaceEach(null, *, *, *)        \u003d null\n StringUtils.replaceEach(\"\", *, *, *)          \u003d \"\"\n StringUtils.replaceEach(\"aba\", null, null, *) \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", new String[0], null, *) \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", null, new String[0], *) \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, null, *)  \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, new String[]{\"\"}, *)  \u003d \"b\"\n StringUtils.replaceEach(\"aba\", new String[]{null}, new String[]{\"a\"}, *)  \u003d \"aba\"\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"w\", \"t\"}, *)  \u003d \"wcte\"\n (example of how it repeats)\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, false)  \u003d \"dcte\"\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, true)  \u003d \"tcte\"\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"ab\"}, *)  \u003d IllegalArgumentException\n\u003c/pre\u003e\n\n@param text text to search and replace in, no-op if null\n@param repl the Strings to search for, no-op if null\n@param with the Strings to replace with, no-op if null\n@param timeToLive if less than 0 then there is a circular reference and endless\n           loop\n@return the text with any replacements processed, \u003ccode\u003enull\u003c/code\u003e if\n        null String input\n@throws IllegalArgumentException\n            if the search is repeating and there is an endless loop due\n            to outputs of one being inputs to another\n@throws IndexOutOfBoundsException\n            if the lengths of the arrays are not the same (null is ok,\n            and/or size 0)\n@since 2.4\n",
            "newValue": "\u003cp\u003e\nReplaces all occurrences of Strings within another String.\n\u003c/p\u003e\n\n\u003cp\u003e\nA \u003ccode\u003enull\u003c/code\u003e reference passed to this method is a no-op, or if\nany \"search string\" or \"string to replace\" is null, that replace will be\nignored. \n\u003c/p\u003e\n\n\u003cpre\u003e\n StringUtils.replaceEach(null, *, *, *)        \u003d null\n StringUtils.replaceEach(\"\", *, *, *)          \u003d \"\"\n StringUtils.replaceEach(\"aba\", null, null, *) \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", new String[0], null, *) \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", null, new String[0], *) \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, null, *)  \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, new String[]{\"\"}, *)  \u003d \"b\"\n StringUtils.replaceEach(\"aba\", new String[]{null}, new String[]{\"a\"}, *)  \u003d \"aba\"\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"w\", \"t\"}, *)  \u003d \"wcte\"\n (example of how it repeats)\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, false)  \u003d \"dcte\"\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, true)  \u003d \"tcte\"\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"ab\"}, *)  \u003d IllegalArgumentException\n\u003c/pre\u003e\n\n@param text text to search and replace in, no-op if null\n@param searchList the Strings to search for, no-op if null\n@param replacementList the Strings to replace them with, no-op if null\n@param repeat if true, then replace repeatedly \n      until there are no more possible replacements or timeToLive \u003c 0\n@param timeToLive if less than 0 then there is a circular reference and endless\n           loop\n@return the text with any replacements processed, \u003ccode\u003enull\u003c/code\u003e if\n        null String input\n@throws IllegalArgumentException\n            if the search is repeating and there is an endless loop due\n            to outputs of one being inputs to another\n@throws IndexOutOfBoundsException\n            if the lengths of the arrays are not the same (null is ok,\n            and/or size 0)\n@since 2.4\n"
          }
        }
      ]
    },
    "19f33e4e0d824e732d07f06a08567c27b3c808f3": {
      "type": "Ydocchange",
      "commitMessage": "sp again\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@619157 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2/6/08, 1:24 PM",
      "commitName": "19f33e4e0d824e732d07f06a08567c27b3c808f3",
      "commitAuthor": "Matthew Jason Benson",
      "commitDateOld": "2/6/08, 12:21 PM",
      "commitNameOld": "4aefe9f0b1d8e5f9649eceaf0e232eff71b3d034",
      "commitAuthorOld": "Gary D. Gregory",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private static String replaceEach(String text, String[] repl, String[] with, boolean repeat, int timeToLive) {\n    if (text \u003d\u003d null || text.length() \u003d\u003d 0 || repl \u003d\u003d null || repl.length \u003d\u003d 0 || with \u003d\u003d null || with.length \u003d\u003d 0) {\n        return text;\n    }\n    if (timeToLive \u003c 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n    int replLength \u003d repl.length;\n    int withLength \u003d with.length;\n    if (replLength !\u003d withLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don\u0027t match: \" + replLength + \" vs \" + withLength);\n    }\n    boolean[] noMoreMatchesForReplIndex \u003d new boolean[replLength];\n    int textIndex \u003d -1;\n    int replaceIndex \u003d -1;\n    int tempIndex \u003d -1;\n    for (int i \u003d 0; i \u003c replLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || repl[i] \u003d\u003d null || repl[i].length() \u003d\u003d 0 || with[i] \u003d\u003d null) {\n            continue;\n        }\n        tempIndex \u003d text.indexOf(repl[i]);\n        if (tempIndex \u003d\u003d -1) {\n            noMoreMatchesForReplIndex[i] \u003d true;\n        } else {\n            if (textIndex \u003d\u003d -1 || tempIndex \u003c textIndex) {\n                textIndex \u003d tempIndex;\n                replaceIndex \u003d i;\n            }\n        }\n    }\n    if (textIndex \u003d\u003d -1) {\n        return text;\n    }\n    int start \u003d 0;\n    int increase \u003d 0;\n    for (int i \u003d 0; i \u003c repl.length; i++) {\n        int greater \u003d with[i].length() - repl[i].length();\n        if (greater \u003e 0) {\n            increase +\u003d 3 * greater;\n        }\n    }\n    increase \u003d Math.min(increase, text.length() / 5);\n    StringBuffer buf \u003d new StringBuffer(text.length() + increase);\n    while (textIndex !\u003d -1) {\n        for (int i \u003d start; i \u003c textIndex; i++) {\n            buf.append(text.charAt(i));\n        }\n        buf.append(with[replaceIndex]);\n        start \u003d textIndex + repl[replaceIndex].length();\n        textIndex \u003d -1;\n        replaceIndex \u003d -1;\n        tempIndex \u003d -1;\n        for (int i \u003d 0; i \u003c replLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || repl[i] \u003d\u003d null || repl[i].length() \u003d\u003d 0 || with[i] \u003d\u003d null) {\n                continue;\n            }\n            tempIndex \u003d text.indexOf(repl[i], start);\n            if (tempIndex \u003d\u003d -1) {\n                noMoreMatchesForReplIndex[i] \u003d true;\n            } else {\n                if (textIndex \u003d\u003d -1 || tempIndex \u003c textIndex) {\n                    textIndex \u003d tempIndex;\n                    replaceIndex \u003d i;\n                }\n            }\n        }\n    }\n    int textLength \u003d text.length();\n    for (int i \u003d start; i \u003c textLength; i++) {\n        buf.append(text.charAt(i));\n    }\n    String result \u003d buf.toString();\n    if (!repeat) {\n        return result;\n    }\n    return replaceEach(result, repl, with, repeat, timeToLive - 1);\n}",
      "path": "src/java/org/apache/commons/lang/StringUtils.java",
      "functionStartLine": 3656,
      "functionName": "replaceEach",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003e\nReplaces all occurrences of Strings within another String.\n\u003c/p\u003e\n\n\u003cp\u003e\nA \u003ccode\u003enull\u003c/code\u003e reference passed to this method is a no-op, or if\nany \"search string\" or \"string to replace\" is null, that replace will be\nignored. \n\u003c/p\u003e\n\n\u003cpre\u003e\n StringUtils.replaceEach(null, *, *, *)        \u003d null\n StringUtils.replaceEach(\"\", *, *, *)          \u003d \"\"\n StringUtils.replaceEach(\"aba\", null, null, *) \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", new String[0], null, *) \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", null, new String[0], *) \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, null, *)  \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, new String[]{\"\"}, *)  \u003d \"b\"\n StringUtils.replaceEach(\"aba\", new String[]{null}, new String[]{\"a\"}, *)  \u003d \"aba\"\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"w\", \"t\"}, *)  \u003d \"wcte\"\n (example of how it repeats)\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, false)  \u003d \"dcte\"\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, true)  \u003d \"tcte\"\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"ab\"}, *)  \u003d IllegalArgumentException\n\u003c/pre\u003e\n\n@param text text to search and replace in, no-op if null\n@param repl the Strings to search for, no-op if null\n@param with the Strings to replace with, no-op if null\n@param timeToLive if less than 0 then there is a circular reference and endless\n           loop\n@return the text with any replacements processed, \u003ccode\u003enull\u003c/code\u003e if\n        null String input\n@throws IllegalArgumentException\n            if the search is repeating and there is an endless loop due\n            to outputs of one being inputs to another\n@throws IndexOutOfBoundsException\n            if the lengths of the arrays are not the same (null is ok,\n            and/or size 0)\n@since 2.4\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "\u003cp\u003e\nReplaces all occurences of Strings within another String.\n\u003c/p\u003e\n\n\u003cp\u003e\nA \u003ccode\u003enull\u003c/code\u003e reference passed to this method is a no-op, or if\nany \"search string\" or \"string to replace\" is null, that replace will be\nignored. \n\u003c/p\u003e\n\n\u003cpre\u003e\n StringUtils.replaceEach(null, *, *, *)        \u003d null\n StringUtils.replaceEach(\"\", *, *, *)          \u003d \"\"\n StringUtils.replaceEach(\"aba\", null, null, *) \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", new String[0], null, *) \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", null, new String[0], *) \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, null, *)  \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, new String[]{\"\"}, *)  \u003d \"b\"\n StringUtils.replaceEach(\"aba\", new String[]{null}, new String[]{\"a\"}, *)  \u003d \"aba\"\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"w\", \"t\"}, *)  \u003d \"wcte\"\n (example of how it repeats)\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, false)  \u003d \"dcte\"\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, true)  \u003d \"tcte\"\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"ab\"}, *)  \u003d IllegalArgumentException\n\u003c/pre\u003e\n\n@param text text to search and replace in, no-op if null\n@param repl the Strings to search for, no-op if null\n@param with the Strings to replace with, no-op if null\n@param timeToLive if less than 0 then there is a circular reference and endless\n           loop\n@return the text with any replacements processed, \u003ccode\u003enull\u003c/code\u003e if\n        null String input\n@throws IllegalArgumentException\n            if the search is repeating and there is an endless loop due\n            to outputs of one being inputs to another\n@throws IndexOutOfBoundsException\n            if the lengths of the arrays are not the same (null is ok,\n            and/or size 0)\n@since 2.4\n",
        "newValue": "\u003cp\u003e\nReplaces all occurrences of Strings within another String.\n\u003c/p\u003e\n\n\u003cp\u003e\nA \u003ccode\u003enull\u003c/code\u003e reference passed to this method is a no-op, or if\nany \"search string\" or \"string to replace\" is null, that replace will be\nignored. \n\u003c/p\u003e\n\n\u003cpre\u003e\n StringUtils.replaceEach(null, *, *, *)        \u003d null\n StringUtils.replaceEach(\"\", *, *, *)          \u003d \"\"\n StringUtils.replaceEach(\"aba\", null, null, *) \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", new String[0], null, *) \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", null, new String[0], *) \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, null, *)  \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, new String[]{\"\"}, *)  \u003d \"b\"\n StringUtils.replaceEach(\"aba\", new String[]{null}, new String[]{\"a\"}, *)  \u003d \"aba\"\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"w\", \"t\"}, *)  \u003d \"wcte\"\n (example of how it repeats)\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, false)  \u003d \"dcte\"\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, true)  \u003d \"tcte\"\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"ab\"}, *)  \u003d IllegalArgumentException\n\u003c/pre\u003e\n\n@param text text to search and replace in, no-op if null\n@param repl the Strings to search for, no-op if null\n@param with the Strings to replace with, no-op if null\n@param timeToLive if less than 0 then there is a circular reference and endless\n           loop\n@return the text with any replacements processed, \u003ccode\u003enull\u003c/code\u003e if\n        null String input\n@throws IllegalArgumentException\n            if the search is repeating and there is an endless loop due\n            to outputs of one being inputs to another\n@throws IndexOutOfBoundsException\n            if the lengths of the arrays are not the same (null is ok,\n            and/or size 0)\n@since 2.4\n"
      }
    },
    "4aefe9f0b1d8e5f9649eceaf0e232eff71b3d034": {
      "type": "Yformatchange",
      "commitMessage": "Format @since 2.4 methods to match the rest of the file. For example, expressions use no spaces around parens.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@619143 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2/6/08, 12:21 PM",
      "commitName": "4aefe9f0b1d8e5f9649eceaf0e232eff71b3d034",
      "commitAuthor": "Gary D. Gregory",
      "commitDateOld": "2/6/08, 12:10 PM",
      "commitNameOld": "2a088e07629f1d3f3cf3205ef04754067a2aad21",
      "commitAuthorOld": "Gary D. Gregory",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private static String replaceEach(String text, String[] repl, String[] with, boolean repeat, int timeToLive) {\n    if (text \u003d\u003d null || text.length() \u003d\u003d 0 || repl \u003d\u003d null || repl.length \u003d\u003d 0 || with \u003d\u003d null || with.length \u003d\u003d 0) {\n        return text;\n    }\n    if (timeToLive \u003c 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n    int replLength \u003d repl.length;\n    int withLength \u003d with.length;\n    if (replLength !\u003d withLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don\u0027t match: \" + replLength + \" vs \" + withLength);\n    }\n    boolean[] noMoreMatchesForReplIndex \u003d new boolean[replLength];\n    int textIndex \u003d -1;\n    int replaceIndex \u003d -1;\n    int tempIndex \u003d -1;\n    for (int i \u003d 0; i \u003c replLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || repl[i] \u003d\u003d null || repl[i].length() \u003d\u003d 0 || with[i] \u003d\u003d null) {\n            continue;\n        }\n        tempIndex \u003d text.indexOf(repl[i]);\n        if (tempIndex \u003d\u003d -1) {\n            noMoreMatchesForReplIndex[i] \u003d true;\n        } else {\n            if (textIndex \u003d\u003d -1 || tempIndex \u003c textIndex) {\n                textIndex \u003d tempIndex;\n                replaceIndex \u003d i;\n            }\n        }\n    }\n    if (textIndex \u003d\u003d -1) {\n        return text;\n    }\n    int start \u003d 0;\n    int increase \u003d 0;\n    for (int i \u003d 0; i \u003c repl.length; i++) {\n        int greater \u003d with[i].length() - repl[i].length();\n        if (greater \u003e 0) {\n            increase +\u003d 3 * greater;\n        }\n    }\n    increase \u003d Math.min(increase, text.length() / 5);\n    StringBuffer buf \u003d new StringBuffer(text.length() + increase);\n    while (textIndex !\u003d -1) {\n        for (int i \u003d start; i \u003c textIndex; i++) {\n            buf.append(text.charAt(i));\n        }\n        buf.append(with[replaceIndex]);\n        start \u003d textIndex + repl[replaceIndex].length();\n        textIndex \u003d -1;\n        replaceIndex \u003d -1;\n        tempIndex \u003d -1;\n        for (int i \u003d 0; i \u003c replLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || repl[i] \u003d\u003d null || repl[i].length() \u003d\u003d 0 || with[i] \u003d\u003d null) {\n                continue;\n            }\n            tempIndex \u003d text.indexOf(repl[i], start);\n            if (tempIndex \u003d\u003d -1) {\n                noMoreMatchesForReplIndex[i] \u003d true;\n            } else {\n                if (textIndex \u003d\u003d -1 || tempIndex \u003c textIndex) {\n                    textIndex \u003d tempIndex;\n                    replaceIndex \u003d i;\n                }\n            }\n        }\n    }\n    int textLength \u003d text.length();\n    for (int i \u003d start; i \u003c textLength; i++) {\n        buf.append(text.charAt(i));\n    }\n    String result \u003d buf.toString();\n    if (!repeat) {\n        return result;\n    }\n    return replaceEach(result, repl, with, repeat, timeToLive - 1);\n}",
      "path": "src/java/org/apache/commons/lang/StringUtils.java",
      "functionStartLine": 3656,
      "functionName": "replaceEach",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003e\nReplaces all occurences of Strings within another String.\n\u003c/p\u003e\n\n\u003cp\u003e\nA \u003ccode\u003enull\u003c/code\u003e reference passed to this method is a no-op, or if\nany \"search string\" or \"string to replace\" is null, that replace will be\nignored. \n\u003c/p\u003e\n\n\u003cpre\u003e\n StringUtils.replaceEach(null, *, *, *)        \u003d null\n StringUtils.replaceEach(\"\", *, *, *)          \u003d \"\"\n StringUtils.replaceEach(\"aba\", null, null, *) \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", new String[0], null, *) \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", null, new String[0], *) \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, null, *)  \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, new String[]{\"\"}, *)  \u003d \"b\"\n StringUtils.replaceEach(\"aba\", new String[]{null}, new String[]{\"a\"}, *)  \u003d \"aba\"\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"w\", \"t\"}, *)  \u003d \"wcte\"\n (example of how it repeats)\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, false)  \u003d \"dcte\"\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, true)  \u003d \"tcte\"\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"ab\"}, *)  \u003d IllegalArgumentException\n\u003c/pre\u003e\n\n@param text text to search and replace in, no-op if null\n@param repl the Strings to search for, no-op if null\n@param with the Strings to replace with, no-op if null\n@param timeToLive if less than 0 then there is a circular reference and endless\n           loop\n@return the text with any replacements processed, \u003ccode\u003enull\u003c/code\u003e if\n        null String input\n@throws IllegalArgumentException\n            if the search is repeating and there is an endless loop due\n            to outputs of one being inputs to another\n@throws IndexOutOfBoundsException\n            if the lengths of the arrays are not the same (null is ok,\n            and/or size 0)\n@since 2.4\n",
      "diff": "",
      "extendedDetails": {}
    },
    "2a6b4afd3463243e17ff0af1d423b8dad0c46e69": {
      "type": "Ydocchange",
      "commitMessage": "Correct spelling and punctuation in Javadoc. \n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@619091 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2/6/08, 10:24 AM",
      "commitName": "2a6b4afd3463243e17ff0af1d423b8dad0c46e69",
      "commitAuthor": "Sebastian Bazley",
      "commitDateOld": "2/5/08, 8:32 PM",
      "commitNameOld": "56d9bb88e5dc419921fe2ae84e11288f05d1e26a",
      "commitAuthorOld": "Gary D. Gregory",
      "daysBetweenCommits": 0.58,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "private static String replaceEach(String text, String[] repl, String[] with, boolean repeat, int timeToLive) {\n    if (text \u003d\u003d null || text.length() \u003d\u003d 0 || repl \u003d\u003d null || repl.length \u003d\u003d 0 || with \u003d\u003d null || with.length \u003d\u003d 0) {\n        return text;\n    }\n    if (timeToLive \u003c 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n    int replLength \u003d repl.length;\n    int withLength \u003d with.length;\n    if (replLength !\u003d withLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don\u0027t match: \" + replLength + \" vs \" + withLength);\n    }\n    boolean[] noMoreMatchesForReplIndex \u003d new boolean[replLength];\n    int textIndex \u003d -1;\n    int replaceIndex \u003d -1;\n    int tempIndex \u003d -1;\n    for (int i \u003d 0; i \u003c replLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || repl[i] \u003d\u003d null || repl[i].length() \u003d\u003d 0 || with[i] \u003d\u003d null) {\n            continue;\n        }\n        tempIndex \u003d text.indexOf(repl[i]);\n        if (tempIndex \u003d\u003d -1) {\n            noMoreMatchesForReplIndex[i] \u003d true;\n        } else {\n            if (textIndex \u003d\u003d -1 || tempIndex \u003c textIndex) {\n                textIndex \u003d tempIndex;\n                replaceIndex \u003d i;\n            }\n        }\n    }\n    if (textIndex \u003d\u003d -1) {\n        return text;\n    }\n    int start \u003d 0;\n    int increase \u003d 0;\n    for (int i \u003d 0; i \u003c repl.length; i++) {\n        int greater \u003d with[i].length() - repl[i].length();\n        if (greater \u003e 0) {\n            increase +\u003d 3 * greater;\n        }\n    }\n    increase \u003d Math.min(increase, text.length() / 5);\n    StringBuffer buf \u003d new StringBuffer(text.length() + increase);\n    while (textIndex !\u003d -1) {\n        for (int i \u003d start; i \u003c textIndex; i++) {\n            buf.append(text.charAt(i));\n        }\n        buf.append(with[replaceIndex]);\n        start \u003d textIndex + repl[replaceIndex].length();\n        textIndex \u003d -1;\n        replaceIndex \u003d -1;\n        tempIndex \u003d -1;\n        for (int i \u003d 0; i \u003c replLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || repl[i] \u003d\u003d null || repl[i].length() \u003d\u003d 0 || with[i] \u003d\u003d null) {\n                continue;\n            }\n            tempIndex \u003d text.indexOf(repl[i], start);\n            if (tempIndex \u003d\u003d -1) {\n                noMoreMatchesForReplIndex[i] \u003d true;\n            } else {\n                if (textIndex \u003d\u003d -1 || tempIndex \u003c textIndex) {\n                    textIndex \u003d tempIndex;\n                    replaceIndex \u003d i;\n                }\n            }\n        }\n    }\n    int textLength \u003d text.length();\n    for (int i \u003d start; i \u003c textLength; i++) {\n        buf.append(text.charAt(i));\n    }\n    String result \u003d buf.toString();\n    if (!repeat) {\n        return result;\n    }\n    return replaceEach(result, repl, with, repeat, timeToLive - 1);\n}",
      "path": "src/java/org/apache/commons/lang/StringUtils.java",
      "functionStartLine": 3668,
      "functionName": "replaceEach",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003e\nReplaces all occurences of Strings within another String.\n\u003c/p\u003e\n\n\u003cp\u003e\nA \u003ccode\u003enull\u003c/code\u003e reference passed to this method is a no-op, or if\nany \"search string\" or \"string to replace\" is null, that replace will be\nignored. \n\u003c/p\u003e\n\n\u003cpre\u003e\n StringUtils.replaceEach(null, *, *, *)        \u003d null\n StringUtils.replaceEach(\"\", *, *, *)          \u003d \"\"\n StringUtils.replaceEach(\"aba\", null, null, *) \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", new String[0], null, *) \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", null, new String[0], *) \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, null, *)  \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, new String[]{\"\"}, *)  \u003d \"b\"\n StringUtils.replaceEach(\"aba\", new String[]{null}, new String[]{\"a\"}, *)  \u003d \"aba\"\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"w\", \"t\"}, *)  \u003d \"wcte\"\n (example of how it repeats)\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, false)  \u003d \"dcte\"\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, true)  \u003d \"tcte\"\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"ab\"}, *)  \u003d IllegalArgumentException\n\u003c/pre\u003e\n\n@param text text to search and replace in, no-op if null\n@param repl the Strings to search for, no-op if null\n@param with the Strings to replace with, no-op if null\n@param timeToLive if less than 0 then there is a circular reference and endless\n           loop\n@return the text with any replacements processed, \u003ccode\u003enull\u003c/code\u003e if\n        null String input\n@throws IllegalArgumentException\n            if the search is repeating and there is an endless loop due\n            to outputs of one being inputs to another\n@throws IndexOutOfBoundsException\n            if the lengths of the arrays are not the same (null is ok,\n            and/or size 0)\n@since 2.4\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "\u003cp\u003e\nReplaces all occurances of Strings within another String.\n\u003c/p\u003e\n\n\u003cp\u003e\nA \u003ccode\u003enull\u003c/code\u003e reference passed to this method is a no-op, or if\nany \"search string\" or \"string to replace\" is null, that replace will be\nignored. \n\u003c/p\u003e\n\n\u003cpre\u003e\n StringUtils.replaceEach(null, *, *, *)        \u003d null\n StringUtils.replaceEach(\"\", *, *, *)          \u003d \"\"\n StringUtils.replaceEach(\"aba\", null, null, *) \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", new String[0], null, *) \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", null, new String[0], *) \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, null, *)  \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, new String[]{\"\"}, *)  \u003d \"b\"\n StringUtils.replaceEach(\"aba\", new String[]{null}, new String[]{\"a\"}, *)  \u003d \"aba\"\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"w\", \"t\"}, *)  \u003d \"wcte\"\n (example of how it repeats)\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, false)  \u003d \"dcte\"\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, true)  \u003d \"tcte\"\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"ab\"}, *)  \u003d IllegalArgumentException\n\u003c/pre\u003e\n\n@param text text to search and replace in, no-op if null\n@param repl the Strings to search for, no-op if null\n@param with the Strings to replace with, no-op if null\n@param timeToLive if less than 0 then there is a circular reference and endless\n           loop\n@return the text with any replacements processed, \u003ccode\u003enull\u003c/code\u003e if\n        null String input\n@throws IllegalArgumentException\n            if the search is repeating and there is an endless loop due\n            to outputs of one being inputs to another\n@throws IndexOutOfBoundsException\n            if the lengths of the arrays are not the same (null is ok,\n            and/or size 0)\n@since 2.4\n",
        "newValue": "\u003cp\u003e\nReplaces all occurences of Strings within another String.\n\u003c/p\u003e\n\n\u003cp\u003e\nA \u003ccode\u003enull\u003c/code\u003e reference passed to this method is a no-op, or if\nany \"search string\" or \"string to replace\" is null, that replace will be\nignored. \n\u003c/p\u003e\n\n\u003cpre\u003e\n StringUtils.replaceEach(null, *, *, *)        \u003d null\n StringUtils.replaceEach(\"\", *, *, *)          \u003d \"\"\n StringUtils.replaceEach(\"aba\", null, null, *) \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", new String[0], null, *) \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", null, new String[0], *) \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, null, *)  \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, new String[]{\"\"}, *)  \u003d \"b\"\n StringUtils.replaceEach(\"aba\", new String[]{null}, new String[]{\"a\"}, *)  \u003d \"aba\"\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"w\", \"t\"}, *)  \u003d \"wcte\"\n (example of how it repeats)\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, false)  \u003d \"dcte\"\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, true)  \u003d \"tcte\"\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"ab\"}, *)  \u003d IllegalArgumentException\n\u003c/pre\u003e\n\n@param text text to search and replace in, no-op if null\n@param repl the Strings to search for, no-op if null\n@param with the Strings to replace with, no-op if null\n@param timeToLive if less than 0 then there is a circular reference and endless\n           loop\n@return the text with any replacements processed, \u003ccode\u003enull\u003c/code\u003e if\n        null String input\n@throws IllegalArgumentException\n            if the search is repeating and there is an endless loop due\n            to outputs of one being inputs to another\n@throws IndexOutOfBoundsException\n            if the lengths of the arrays are not the same (null is ok,\n            and/or size 0)\n@since 2.4\n"
      }
    },
    "e8600d357d98cbf727b573732052aba0fd7a1f69": {
      "type": "Yintroduced",
      "commitMessage": "Applying my modified version of Chris Hyzer\u0027s patch from LANG-180 - adding a replaceEach(String, String[], String[]) and replaceRepeatedly(String, String[], String[]) pair of methods. The internal code to the private replaceEach method has not been fully reviewed yet - I wanted to get more eyes focused on the algorithm\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@616170 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "1/28/08, 9:33 PM",
      "commitName": "e8600d357d98cbf727b573732052aba0fd7a1f69",
      "commitAuthor": "Henri Yandell",
      "diff": "@@ -0,0 +1,77 @@\n+private static String replaceEach(String text, String[] repl, String[] with, boolean repeat, int timeToLive) {\n+    if (text \u003d\u003d null || text.length() \u003d\u003d 0 || repl \u003d\u003d null || repl.length \u003d\u003d 0 || with \u003d\u003d null || with.length \u003d\u003d 0) {\n+        return text;\n+    }\n+    if (timeToLive \u003c 0) {\n+        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n+    }\n+    int replLength \u003d repl.length;\n+    int withLength \u003d with.length;\n+    if (replLength !\u003d withLength) {\n+        throw new IllegalArgumentException(\"Search and Replace array lengths don\u0027t match: \" + replLength + \" vs \" + withLength);\n+    }\n+    boolean[] noMoreMatchesForReplIndex \u003d new boolean[replLength];\n+    int textIndex \u003d -1;\n+    int replaceIndex \u003d -1;\n+    int tempIndex \u003d -1;\n+    for (int i \u003d 0; i \u003c replLength; i++) {\n+        if (noMoreMatchesForReplIndex[i] || repl[i] \u003d\u003d null || repl[i].length() \u003d\u003d 0 || with[i] \u003d\u003d null) {\n+            continue;\n+        }\n+        tempIndex \u003d text.indexOf(repl[i]);\n+        if (tempIndex \u003d\u003d -1) {\n+            noMoreMatchesForReplIndex[i] \u003d true;\n+        } else {\n+            if (textIndex \u003d\u003d -1 || tempIndex \u003c textIndex) {\n+                textIndex \u003d tempIndex;\n+                replaceIndex \u003d i;\n+            }\n+        }\n+    }\n+    if (textIndex \u003d\u003d -1) {\n+        return text;\n+    }\n+    int start \u003d 0;\n+    int increase \u003d 0;\n+    for (int i \u003d 0; i \u003c repl.length; i++) {\n+        int greater \u003d with[i].length() - repl[i].length();\n+        if (greater \u003e 0) {\n+            increase +\u003d 3 * greater;\n+        }\n+    }\n+    increase \u003d Math.min(increase, text.length() / 5);\n+    StringBuffer buf \u003d new StringBuffer(text.length() + increase);\n+    while (textIndex !\u003d -1) {\n+        for (int i \u003d start; i \u003c textIndex; i++) {\n+            buf.append(text.charAt(i));\n+        }\n+        buf.append(with[replaceIndex]);\n+        start \u003d textIndex + repl[replaceIndex].length();\n+        textIndex \u003d -1;\n+        replaceIndex \u003d -1;\n+        tempIndex \u003d -1;\n+        for (int i \u003d 0; i \u003c replLength; i++) {\n+            if (noMoreMatchesForReplIndex[i] || repl[i] \u003d\u003d null || repl[i].length() \u003d\u003d 0 || with[i] \u003d\u003d null) {\n+                continue;\n+            }\n+            tempIndex \u003d text.indexOf(repl[i], start);\n+            if (tempIndex \u003d\u003d -1) {\n+                noMoreMatchesForReplIndex[i] \u003d true;\n+            } else {\n+                if (textIndex \u003d\u003d -1 || tempIndex \u003c textIndex) {\n+                    textIndex \u003d tempIndex;\n+                    replaceIndex \u003d i;\n+                }\n+            }\n+        }\n+    }\n+    int textLength \u003d text.length();\n+    for (int i \u003d start; i \u003c textLength; i++) {\n+        buf.append(text.charAt(i));\n+    }\n+    String result \u003d buf.toString();\n+    if (!repeat) {\n+        return result;\n+    }\n+    return replaceEach(result, repl, with, repeat, timeToLive - 1);\n+}\n\\ No newline at end of file\n",
      "actualSource": "private static String replaceEach(String text, String[] repl, String[] with, boolean repeat, int timeToLive) {\n    if (text \u003d\u003d null || text.length() \u003d\u003d 0 || repl \u003d\u003d null || repl.length \u003d\u003d 0 || with \u003d\u003d null || with.length \u003d\u003d 0) {\n        return text;\n    }\n    if (timeToLive \u003c 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n    int replLength \u003d repl.length;\n    int withLength \u003d with.length;\n    if (replLength !\u003d withLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don\u0027t match: \" + replLength + \" vs \" + withLength);\n    }\n    boolean[] noMoreMatchesForReplIndex \u003d new boolean[replLength];\n    int textIndex \u003d -1;\n    int replaceIndex \u003d -1;\n    int tempIndex \u003d -1;\n    for (int i \u003d 0; i \u003c replLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || repl[i] \u003d\u003d null || repl[i].length() \u003d\u003d 0 || with[i] \u003d\u003d null) {\n            continue;\n        }\n        tempIndex \u003d text.indexOf(repl[i]);\n        if (tempIndex \u003d\u003d -1) {\n            noMoreMatchesForReplIndex[i] \u003d true;\n        } else {\n            if (textIndex \u003d\u003d -1 || tempIndex \u003c textIndex) {\n                textIndex \u003d tempIndex;\n                replaceIndex \u003d i;\n            }\n        }\n    }\n    if (textIndex \u003d\u003d -1) {\n        return text;\n    }\n    int start \u003d 0;\n    int increase \u003d 0;\n    for (int i \u003d 0; i \u003c repl.length; i++) {\n        int greater \u003d with[i].length() - repl[i].length();\n        if (greater \u003e 0) {\n            increase +\u003d 3 * greater;\n        }\n    }\n    increase \u003d Math.min(increase, text.length() / 5);\n    StringBuffer buf \u003d new StringBuffer(text.length() + increase);\n    while (textIndex !\u003d -1) {\n        for (int i \u003d start; i \u003c textIndex; i++) {\n            buf.append(text.charAt(i));\n        }\n        buf.append(with[replaceIndex]);\n        start \u003d textIndex + repl[replaceIndex].length();\n        textIndex \u003d -1;\n        replaceIndex \u003d -1;\n        tempIndex \u003d -1;\n        for (int i \u003d 0; i \u003c replLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || repl[i] \u003d\u003d null || repl[i].length() \u003d\u003d 0 || with[i] \u003d\u003d null) {\n                continue;\n            }\n            tempIndex \u003d text.indexOf(repl[i], start);\n            if (tempIndex \u003d\u003d -1) {\n                noMoreMatchesForReplIndex[i] \u003d true;\n            } else {\n                if (textIndex \u003d\u003d -1 || tempIndex \u003c textIndex) {\n                    textIndex \u003d tempIndex;\n                    replaceIndex \u003d i;\n                }\n            }\n        }\n    }\n    int textLength \u003d text.length();\n    for (int i \u003d start; i \u003c textLength; i++) {\n        buf.append(text.charAt(i));\n    }\n    String result \u003d buf.toString();\n    if (!repeat) {\n        return result;\n    }\n    return replaceEach(result, repl, with, repeat, timeToLive - 1);\n}",
      "path": "src/java/org/apache/commons/lang/StringUtils.java",
      "functionStartLine": 3668,
      "functionName": "replaceEach",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003e\nReplaces all occurances of Strings within another String.\n\u003c/p\u003e\n\n\u003cp\u003e\nA \u003ccode\u003enull\u003c/code\u003e reference passed to this method is a no-op, or if\nany \"search string\" or \"string to replace\" is null, that replace will be\nignored. \n\u003c/p\u003e\n\n\u003cpre\u003e\n StringUtils.replaceEach(null, *, *, *)        \u003d null\n StringUtils.replaceEach(\"\", *, *, *)          \u003d \"\"\n StringUtils.replaceEach(\"aba\", null, null, *) \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", new String[0], null, *) \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", null, new String[0], *) \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, null, *)  \u003d \"aba\"\n StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, new String[]{\"\"}, *)  \u003d \"b\"\n StringUtils.replaceEach(\"aba\", new String[]{null}, new String[]{\"a\"}, *)  \u003d \"aba\"\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"w\", \"t\"}, *)  \u003d \"wcte\"\n (example of how it repeats)\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, false)  \u003d \"dcte\"\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, true)  \u003d \"tcte\"\n StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"ab\"}, *)  \u003d IllegalArgumentException\n\u003c/pre\u003e\n\n@param text text to search and replace in, no-op if null\n@param repl the Strings to search for, no-op if null\n@param with the Strings to replace with, no-op if null\n@param timeToLive if less than 0 then there is a circular reference and endless\n           loop\n@return the text with any replacements processed, \u003ccode\u003enull\u003c/code\u003e if\n        null String input\n@throws IllegalArgumentException\n            if the search is repeating and there is an endless loop due\n            to outputs of one being inputs to another\n@throws IndexOutOfBoundsException\n            if the lengths of the arrays are not the same (null is ok,\n            and/or size 0)\n@since 2.4\n"
    }
  }
}