{
  "origin": "codeshovel",
  "repositoryName": "Math-23b",
  "repositoryPath": "/tmp/Math-23b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "BrentOptimizer.java",
  "functionName": "doOptimize",
  "functionId": "doOptimize",
  "sourceFilePath": "src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java",
  "functionAnnotation": "@Override",
  "functionDoc": "@inheritDoc}\n",
  "functionStartLine": 109,
  "functionEndLine": 271,
  "numCommitsSeen": 27,
  "timeTaken": 17086,
  "changeHistory": [
    "d5ff460ba69e4261f066d7856e2f90b886924513",
    "36d811b2d4cfe1b867823bd60ccca25abbc80b46",
    "216ac0065f5f75e72601b459c7b9415f81be17a8",
    "2d698e4905cb75bd125e2fe1f5223d7e68f0adcd",
    "5a8be77a303c9e2f8c19d029e8628d7697fb581d",
    "b59e97464fc8d910c06b90c06598d7176ce1924a",
    "74c289e6cc999fec27551b7e16fb6245b1352a37",
    "8302dd02498495277ec0db9301edb2158bb0e314",
    "7285331645183d45a7110d03b45e74acf46f8be3",
    "16727ebdc33f38d0a37aee0e87700500cc272a8b",
    "9707f8dd5e57662832967082a1a49518cb033d1e",
    "d4a0b9eb3d09bb697afe8a4c2b3340a46b97a53b",
    "43ed5002e1483019207c5130459ef469c24dab31",
    "9102bea5d82c6f97bf3cfb1d8525c13e58a9d418",
    "ee555fecaf3a86dc55468b27c28cc28c2983e87b",
    "76fcbc838c0f27d9b029c1f283390cb4f47f8895",
    "7bbad398dd4da51c933414be9a17b07179dee5e4"
  ],
  "changeHistoryShort": {
    "d5ff460ba69e4261f066d7856e2f90b886924513": "Ybodychange",
    "36d811b2d4cfe1b867823bd60ccca25abbc80b46": "Ybodychange",
    "216ac0065f5f75e72601b459c7b9415f81be17a8": "Ybodychange",
    "2d698e4905cb75bd125e2fe1f5223d7e68f0adcd": "Ymovefromfile",
    "5a8be77a303c9e2f8c19d029e8628d7697fb581d": "Ymultichange(Yreturntypechange,Ybodychange)",
    "b59e97464fc8d910c06b90c06598d7176ce1924a": "Ybodychange",
    "74c289e6cc999fec27551b7e16fb6245b1352a37": "Yexceptionschange",
    "8302dd02498495277ec0db9301edb2158bb0e314": "Yexceptionschange",
    "7285331645183d45a7110d03b45e74acf46f8be3": "Yexceptionschange",
    "16727ebdc33f38d0a37aee0e87700500cc272a8b": "Yannotationchange",
    "9707f8dd5e57662832967082a1a49518cb033d1e": "Ybodychange",
    "d4a0b9eb3d09bb697afe8a4c2b3340a46b97a53b": "Ybodychange",
    "43ed5002e1483019207c5130459ef469c24dab31": "Ybodychange",
    "9102bea5d82c6f97bf3cfb1d8525c13e58a9d418": "Ymultichange(Yreturntypechange,Yexceptionschange,Ybodychange)",
    "ee555fecaf3a86dc55468b27c28cc28c2983e87b": "Ydocchange",
    "76fcbc838c0f27d9b029c1f283390cb4f47f8895": "Ymultichange(Yexceptionschange,Ybodychange,Ydocchange)",
    "7bbad398dd4da51c933414be9a17b07179dee5e4": "Yintroduced"
  },
  "changeHistoryDetails": {
    "d5ff460ba69e4261f066d7856e2f90b886924513": {
      "type": "Ybodychange",
      "commitMessage": "MATH-855\nThe best point is sometimes not the last one evaluated.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@1381195 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "9/5/12, 7:22 AM",
      "commitName": "d5ff460ba69e4261f066d7856e2f90b886924513",
      "commitAuthor": "Gilles Sadowski",
      "commitDateOld": "4/27/12, 4:30 PM",
      "commitNameOld": "36d811b2d4cfe1b867823bd60ccca25abbc80b46",
      "commitAuthorOld": "Gilles Sadowski",
      "daysBetweenCommits": 130.62,
      "commitsBetweenForRepo": 343,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected UnivariatePointValuePair doOptimize() {\n    final boolean isMinim \u003d getGoalType() \u003d\u003d GoalType.MINIMIZE;\n    final double lo \u003d getMin();\n    final double mid \u003d getStartValue();\n    final double hi \u003d getMax();\n    final ConvergenceChecker\u003cUnivariatePointValuePair\u003e checker \u003d getConvergenceChecker();\n    double a;\n    double b;\n    if (lo \u003c hi) {\n        a \u003d lo;\n        b \u003d hi;\n    } else {\n        a \u003d hi;\n        b \u003d lo;\n    }\n    double x \u003d mid;\n    double v \u003d x;\n    double w \u003d x;\n    double d \u003d 0;\n    double e \u003d 0;\n    double fx \u003d computeObjectiveValue(x);\n    if (!isMinim) {\n        fx \u003d -fx;\n    }\n    double fv \u003d fx;\n    double fw \u003d fx;\n    UnivariatePointValuePair previous \u003d null;\n    UnivariatePointValuePair current \u003d new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n    int iter \u003d 0;\n    while (true) {\n        final double m \u003d 0.5 * (a + b);\n        final double tol1 \u003d relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n        final double tol2 \u003d 2 * tol1;\n        final boolean stop \u003d FastMath.abs(x - m) \u003c\u003d tol2 - 0.5 * (b - a);\n        if (!stop) {\n            double p \u003d 0;\n            double q \u003d 0;\n            double r \u003d 0;\n            double u \u003d 0;\n            if (FastMath.abs(e) \u003e tol1) {\n                r \u003d (x - w) * (fx - fv);\n                q \u003d (x - v) * (fx - fw);\n                p \u003d (x - v) * q - (x - w) * r;\n                q \u003d 2 * (q - r);\n                if (q \u003e 0) {\n                    p \u003d -p;\n                } else {\n                    q \u003d -q;\n                }\n                r \u003d e;\n                e \u003d d;\n                if (p \u003e q * (a - x) \u0026\u0026 p \u003c q * (b - x) \u0026\u0026 FastMath.abs(p) \u003c FastMath.abs(0.5 * q * r)) {\n                    d \u003d p / q;\n                    u \u003d x + d;\n                    if (u - a \u003c tol2 || b - u \u003c tol2) {\n                        if (x \u003c\u003d m) {\n                            d \u003d tol1;\n                        } else {\n                            d \u003d -tol1;\n                        }\n                    }\n                } else {\n                    if (x \u003c m) {\n                        e \u003d b - x;\n                    } else {\n                        e \u003d a - x;\n                    }\n                    d \u003d GOLDEN_SECTION * e;\n                }\n            } else {\n                if (x \u003c m) {\n                    e \u003d b - x;\n                } else {\n                    e \u003d a - x;\n                }\n                d \u003d GOLDEN_SECTION * e;\n            }\n            if (FastMath.abs(d) \u003c tol1) {\n                if (d \u003e\u003d 0) {\n                    u \u003d x + tol1;\n                } else {\n                    u \u003d x - tol1;\n                }\n            } else {\n                u \u003d x + d;\n            }\n            double fu \u003d computeObjectiveValue(u);\n            if (!isMinim) {\n                fu \u003d -fu;\n            }\n            previous \u003d current;\n            current \u003d new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n            if (checker !\u003d null) {\n                if (checker.converged(iter, previous, current)) {\n                    return best(current, previous, isMinim);\n                }\n            }\n            if (fu \u003c\u003d fx) {\n                if (u \u003c x) {\n                    b \u003d x;\n                } else {\n                    a \u003d x;\n                }\n                v \u003d w;\n                fv \u003d fw;\n                w \u003d x;\n                fw \u003d fx;\n                x \u003d u;\n                fx \u003d fu;\n            } else {\n                if (u \u003c x) {\n                    a \u003d u;\n                } else {\n                    b \u003d u;\n                }\n                if (fu \u003c\u003d fw || Precision.equals(w, x)) {\n                    v \u003d w;\n                    fv \u003d fw;\n                    w \u003d u;\n                    fw \u003d fu;\n                } else if (fu \u003c\u003d fv || Precision.equals(v, x) || Precision.equals(v, w)) {\n                    v \u003d u;\n                    fv \u003d fu;\n                }\n            }\n        } else {\n            return best(current, previous, isMinim);\n        }\n        ++iter;\n    }\n}",
      "path": "src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java",
      "functionStartLine": 109,
      "functionName": "doOptimize",
      "functionAnnotation": "@Override",
      "functionDoc": "@inheritDoc}\n",
      "diff": "@@ -1,132 +1,132 @@\n @Override\n protected UnivariatePointValuePair doOptimize() {\n     final boolean isMinim \u003d getGoalType() \u003d\u003d GoalType.MINIMIZE;\n     final double lo \u003d getMin();\n     final double mid \u003d getStartValue();\n     final double hi \u003d getMax();\n     final ConvergenceChecker\u003cUnivariatePointValuePair\u003e checker \u003d getConvergenceChecker();\n     double a;\n     double b;\n     if (lo \u003c hi) {\n         a \u003d lo;\n         b \u003d hi;\n     } else {\n         a \u003d hi;\n         b \u003d lo;\n     }\n     double x \u003d mid;\n     double v \u003d x;\n     double w \u003d x;\n     double d \u003d 0;\n     double e \u003d 0;\n     double fx \u003d computeObjectiveValue(x);\n     if (!isMinim) {\n         fx \u003d -fx;\n     }\n     double fv \u003d fx;\n     double fw \u003d fx;\n     UnivariatePointValuePair previous \u003d null;\n     UnivariatePointValuePair current \u003d new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n     int iter \u003d 0;\n     while (true) {\n         final double m \u003d 0.5 * (a + b);\n         final double tol1 \u003d relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n         final double tol2 \u003d 2 * tol1;\n         final boolean stop \u003d FastMath.abs(x - m) \u003c\u003d tol2 - 0.5 * (b - a);\n         if (!stop) {\n             double p \u003d 0;\n             double q \u003d 0;\n             double r \u003d 0;\n             double u \u003d 0;\n             if (FastMath.abs(e) \u003e tol1) {\n                 r \u003d (x - w) * (fx - fv);\n                 q \u003d (x - v) * (fx - fw);\n                 p \u003d (x - v) * q - (x - w) * r;\n                 q \u003d 2 * (q - r);\n                 if (q \u003e 0) {\n                     p \u003d -p;\n                 } else {\n                     q \u003d -q;\n                 }\n                 r \u003d e;\n                 e \u003d d;\n                 if (p \u003e q * (a - x) \u0026\u0026 p \u003c q * (b - x) \u0026\u0026 FastMath.abs(p) \u003c FastMath.abs(0.5 * q * r)) {\n                     d \u003d p / q;\n                     u \u003d x + d;\n                     if (u - a \u003c tol2 || b - u \u003c tol2) {\n                         if (x \u003c\u003d m) {\n                             d \u003d tol1;\n                         } else {\n                             d \u003d -tol1;\n                         }\n                     }\n                 } else {\n                     if (x \u003c m) {\n                         e \u003d b - x;\n                     } else {\n                         e \u003d a - x;\n                     }\n                     d \u003d GOLDEN_SECTION * e;\n                 }\n             } else {\n                 if (x \u003c m) {\n                     e \u003d b - x;\n                 } else {\n                     e \u003d a - x;\n                 }\n                 d \u003d GOLDEN_SECTION * e;\n             }\n             if (FastMath.abs(d) \u003c tol1) {\n                 if (d \u003e\u003d 0) {\n                     u \u003d x + tol1;\n                 } else {\n                     u \u003d x - tol1;\n                 }\n             } else {\n                 u \u003d x + d;\n             }\n             double fu \u003d computeObjectiveValue(u);\n             if (!isMinim) {\n                 fu \u003d -fu;\n             }\n             previous \u003d current;\n             current \u003d new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n             if (checker !\u003d null) {\n                 if (checker.converged(iter, previous, current)) {\n-                    return current;\n+                    return best(current, previous, isMinim);\n                 }\n             }\n             if (fu \u003c\u003d fx) {\n                 if (u \u003c x) {\n                     b \u003d x;\n                 } else {\n                     a \u003d x;\n                 }\n                 v \u003d w;\n                 fv \u003d fw;\n                 w \u003d x;\n                 fw \u003d fx;\n                 x \u003d u;\n                 fx \u003d fu;\n             } else {\n                 if (u \u003c x) {\n                     a \u003d u;\n                 } else {\n                     b \u003d u;\n                 }\n                 if (fu \u003c\u003d fw || Precision.equals(w, x)) {\n                     v \u003d w;\n                     fv \u003d fw;\n                     w \u003d u;\n                     fw \u003d fu;\n                 } else if (fu \u003c\u003d fv || Precision.equals(v, x) || Precision.equals(v, w)) {\n                     v \u003d u;\n                     fv \u003d fu;\n                 }\n             }\n         } else {\n-            return current;\n+            return best(current, previous, isMinim);\n         }\n         ++iter;\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "36d811b2d4cfe1b867823bd60ccca25abbc80b46": {
      "type": "Ybodychange",
      "commitMessage": "MATH-782\nLocation of user-defined convergence check.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@1331635 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "4/27/12, 4:30 PM",
      "commitName": "36d811b2d4cfe1b867823bd60ccca25abbc80b46",
      "commitAuthor": "Gilles Sadowski",
      "commitDateOld": "4/25/12, 7:49 AM",
      "commitNameOld": "216ac0065f5f75e72601b459c7b9415f81be17a8",
      "commitAuthorOld": "Gilles Sadowski",
      "daysBetweenCommits": 2.36,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected UnivariatePointValuePair doOptimize() {\n    final boolean isMinim \u003d getGoalType() \u003d\u003d GoalType.MINIMIZE;\n    final double lo \u003d getMin();\n    final double mid \u003d getStartValue();\n    final double hi \u003d getMax();\n    final ConvergenceChecker\u003cUnivariatePointValuePair\u003e checker \u003d getConvergenceChecker();\n    double a;\n    double b;\n    if (lo \u003c hi) {\n        a \u003d lo;\n        b \u003d hi;\n    } else {\n        a \u003d hi;\n        b \u003d lo;\n    }\n    double x \u003d mid;\n    double v \u003d x;\n    double w \u003d x;\n    double d \u003d 0;\n    double e \u003d 0;\n    double fx \u003d computeObjectiveValue(x);\n    if (!isMinim) {\n        fx \u003d -fx;\n    }\n    double fv \u003d fx;\n    double fw \u003d fx;\n    UnivariatePointValuePair previous \u003d null;\n    UnivariatePointValuePair current \u003d new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n    int iter \u003d 0;\n    while (true) {\n        final double m \u003d 0.5 * (a + b);\n        final double tol1 \u003d relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n        final double tol2 \u003d 2 * tol1;\n        final boolean stop \u003d FastMath.abs(x - m) \u003c\u003d tol2 - 0.5 * (b - a);\n        if (!stop) {\n            double p \u003d 0;\n            double q \u003d 0;\n            double r \u003d 0;\n            double u \u003d 0;\n            if (FastMath.abs(e) \u003e tol1) {\n                r \u003d (x - w) * (fx - fv);\n                q \u003d (x - v) * (fx - fw);\n                p \u003d (x - v) * q - (x - w) * r;\n                q \u003d 2 * (q - r);\n                if (q \u003e 0) {\n                    p \u003d -p;\n                } else {\n                    q \u003d -q;\n                }\n                r \u003d e;\n                e \u003d d;\n                if (p \u003e q * (a - x) \u0026\u0026 p \u003c q * (b - x) \u0026\u0026 FastMath.abs(p) \u003c FastMath.abs(0.5 * q * r)) {\n                    d \u003d p / q;\n                    u \u003d x + d;\n                    if (u - a \u003c tol2 || b - u \u003c tol2) {\n                        if (x \u003c\u003d m) {\n                            d \u003d tol1;\n                        } else {\n                            d \u003d -tol1;\n                        }\n                    }\n                } else {\n                    if (x \u003c m) {\n                        e \u003d b - x;\n                    } else {\n                        e \u003d a - x;\n                    }\n                    d \u003d GOLDEN_SECTION * e;\n                }\n            } else {\n                if (x \u003c m) {\n                    e \u003d b - x;\n                } else {\n                    e \u003d a - x;\n                }\n                d \u003d GOLDEN_SECTION * e;\n            }\n            if (FastMath.abs(d) \u003c tol1) {\n                if (d \u003e\u003d 0) {\n                    u \u003d x + tol1;\n                } else {\n                    u \u003d x - tol1;\n                }\n            } else {\n                u \u003d x + d;\n            }\n            double fu \u003d computeObjectiveValue(u);\n            if (!isMinim) {\n                fu \u003d -fu;\n            }\n            previous \u003d current;\n            current \u003d new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n            if (checker !\u003d null) {\n                if (checker.converged(iter, previous, current)) {\n                    return current;\n                }\n            }\n            if (fu \u003c\u003d fx) {\n                if (u \u003c x) {\n                    b \u003d x;\n                } else {\n                    a \u003d x;\n                }\n                v \u003d w;\n                fv \u003d fw;\n                w \u003d x;\n                fw \u003d fx;\n                x \u003d u;\n                fx \u003d fu;\n            } else {\n                if (u \u003c x) {\n                    a \u003d u;\n                } else {\n                    b \u003d u;\n                }\n                if (fu \u003c\u003d fw || Precision.equals(w, x)) {\n                    v \u003d w;\n                    fv \u003d fw;\n                    w \u003d u;\n                    fw \u003d fu;\n                } else if (fu \u003c\u003d fv || Precision.equals(v, x) || Precision.equals(v, w)) {\n                    v \u003d u;\n                    fv \u003d fu;\n                }\n            }\n        } else {\n            return current;\n        }\n        ++iter;\n    }\n}",
      "path": "src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java",
      "functionStartLine": 108,
      "functionName": "doOptimize",
      "functionAnnotation": "@Override",
      "functionDoc": "@inheritDoc}\n",
      "diff": "@@ -1,132 +1,132 @@\n @Override\n protected UnivariatePointValuePair doOptimize() {\n     final boolean isMinim \u003d getGoalType() \u003d\u003d GoalType.MINIMIZE;\n     final double lo \u003d getMin();\n     final double mid \u003d getStartValue();\n     final double hi \u003d getMax();\n     final ConvergenceChecker\u003cUnivariatePointValuePair\u003e checker \u003d getConvergenceChecker();\n     double a;\n     double b;\n     if (lo \u003c hi) {\n         a \u003d lo;\n         b \u003d hi;\n     } else {\n         a \u003d hi;\n         b \u003d lo;\n     }\n     double x \u003d mid;\n     double v \u003d x;\n     double w \u003d x;\n     double d \u003d 0;\n     double e \u003d 0;\n     double fx \u003d computeObjectiveValue(x);\n     if (!isMinim) {\n         fx \u003d -fx;\n     }\n     double fv \u003d fx;\n     double fw \u003d fx;\n     UnivariatePointValuePair previous \u003d null;\n     UnivariatePointValuePair current \u003d new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n     int iter \u003d 0;\n     while (true) {\n         final double m \u003d 0.5 * (a + b);\n         final double tol1 \u003d relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n         final double tol2 \u003d 2 * tol1;\n         final boolean stop \u003d FastMath.abs(x - m) \u003c\u003d tol2 - 0.5 * (b - a);\n         if (!stop) {\n             double p \u003d 0;\n             double q \u003d 0;\n             double r \u003d 0;\n             double u \u003d 0;\n             if (FastMath.abs(e) \u003e tol1) {\n                 r \u003d (x - w) * (fx - fv);\n                 q \u003d (x - v) * (fx - fw);\n                 p \u003d (x - v) * q - (x - w) * r;\n                 q \u003d 2 * (q - r);\n                 if (q \u003e 0) {\n                     p \u003d -p;\n                 } else {\n                     q \u003d -q;\n                 }\n                 r \u003d e;\n                 e \u003d d;\n                 if (p \u003e q * (a - x) \u0026\u0026 p \u003c q * (b - x) \u0026\u0026 FastMath.abs(p) \u003c FastMath.abs(0.5 * q * r)) {\n                     d \u003d p / q;\n                     u \u003d x + d;\n                     if (u - a \u003c tol2 || b - u \u003c tol2) {\n                         if (x \u003c\u003d m) {\n                             d \u003d tol1;\n                         } else {\n                             d \u003d -tol1;\n                         }\n                     }\n                 } else {\n                     if (x \u003c m) {\n                         e \u003d b - x;\n                     } else {\n                         e \u003d a - x;\n                     }\n                     d \u003d GOLDEN_SECTION * e;\n                 }\n             } else {\n                 if (x \u003c m) {\n                     e \u003d b - x;\n                 } else {\n                     e \u003d a - x;\n                 }\n                 d \u003d GOLDEN_SECTION * e;\n             }\n             if (FastMath.abs(d) \u003c tol1) {\n                 if (d \u003e\u003d 0) {\n                     u \u003d x + tol1;\n                 } else {\n                     u \u003d x - tol1;\n                 }\n             } else {\n                 u \u003d x + d;\n             }\n             double fu \u003d computeObjectiveValue(u);\n             if (!isMinim) {\n                 fu \u003d -fu;\n             }\n+            previous \u003d current;\n+            current \u003d new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n+            if (checker !\u003d null) {\n+                if (checker.converged(iter, previous, current)) {\n+                    return current;\n+                }\n+            }\n             if (fu \u003c\u003d fx) {\n                 if (u \u003c x) {\n                     b \u003d x;\n                 } else {\n                     a \u003d x;\n                 }\n                 v \u003d w;\n                 fv \u003d fw;\n                 w \u003d x;\n                 fw \u003d fx;\n                 x \u003d u;\n                 fx \u003d fu;\n-                previous \u003d current;\n-                current \u003d new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n-                if (checker !\u003d null) {\n-                    if (checker.converged(iter, previous, current)) {\n-                        return current;\n-                    }\n-                }\n             } else {\n                 if (u \u003c x) {\n                     a \u003d u;\n                 } else {\n                     b \u003d u;\n                 }\n                 if (fu \u003c\u003d fw || Precision.equals(w, x)) {\n                     v \u003d w;\n                     fv \u003d fw;\n                     w \u003d u;\n                     fw \u003d fu;\n                 } else if (fu \u003c\u003d fv || Precision.equals(v, x) || Precision.equals(v, w)) {\n                     v \u003d u;\n                     fv \u003d fu;\n                 }\n             }\n         } else {\n             return current;\n         }\n         ++iter;\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "216ac0065f5f75e72601b459c7b9415f81be17a8": {
      "type": "Ybodychange",
      "commitMessage": "MATH-782\nMoved incorrectly placed block of code (user-defined stopping criterion).\nAdded unit test.\nNew utility class for simple stopping criterion based on (univariate)\nfunction values.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@1330321 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "4/25/12, 7:49 AM",
      "commitName": "216ac0065f5f75e72601b459c7b9415f81be17a8",
      "commitAuthor": "Gilles Sadowski",
      "commitDateOld": "2/14/12, 8:17 AM",
      "commitNameOld": "2d698e4905cb75bd125e2fe1f5223d7e68f0adcd",
      "commitAuthorOld": "Gilles Sadowski",
      "daysBetweenCommits": 70.94,
      "commitsBetweenForRepo": 148,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected UnivariatePointValuePair doOptimize() {\n    final boolean isMinim \u003d getGoalType() \u003d\u003d GoalType.MINIMIZE;\n    final double lo \u003d getMin();\n    final double mid \u003d getStartValue();\n    final double hi \u003d getMax();\n    final ConvergenceChecker\u003cUnivariatePointValuePair\u003e checker \u003d getConvergenceChecker();\n    double a;\n    double b;\n    if (lo \u003c hi) {\n        a \u003d lo;\n        b \u003d hi;\n    } else {\n        a \u003d hi;\n        b \u003d lo;\n    }\n    double x \u003d mid;\n    double v \u003d x;\n    double w \u003d x;\n    double d \u003d 0;\n    double e \u003d 0;\n    double fx \u003d computeObjectiveValue(x);\n    if (!isMinim) {\n        fx \u003d -fx;\n    }\n    double fv \u003d fx;\n    double fw \u003d fx;\n    UnivariatePointValuePair previous \u003d null;\n    UnivariatePointValuePair current \u003d new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n    int iter \u003d 0;\n    while (true) {\n        final double m \u003d 0.5 * (a + b);\n        final double tol1 \u003d relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n        final double tol2 \u003d 2 * tol1;\n        final boolean stop \u003d FastMath.abs(x - m) \u003c\u003d tol2 - 0.5 * (b - a);\n        if (!stop) {\n            double p \u003d 0;\n            double q \u003d 0;\n            double r \u003d 0;\n            double u \u003d 0;\n            if (FastMath.abs(e) \u003e tol1) {\n                r \u003d (x - w) * (fx - fv);\n                q \u003d (x - v) * (fx - fw);\n                p \u003d (x - v) * q - (x - w) * r;\n                q \u003d 2 * (q - r);\n                if (q \u003e 0) {\n                    p \u003d -p;\n                } else {\n                    q \u003d -q;\n                }\n                r \u003d e;\n                e \u003d d;\n                if (p \u003e q * (a - x) \u0026\u0026 p \u003c q * (b - x) \u0026\u0026 FastMath.abs(p) \u003c FastMath.abs(0.5 * q * r)) {\n                    d \u003d p / q;\n                    u \u003d x + d;\n                    if (u - a \u003c tol2 || b - u \u003c tol2) {\n                        if (x \u003c\u003d m) {\n                            d \u003d tol1;\n                        } else {\n                            d \u003d -tol1;\n                        }\n                    }\n                } else {\n                    if (x \u003c m) {\n                        e \u003d b - x;\n                    } else {\n                        e \u003d a - x;\n                    }\n                    d \u003d GOLDEN_SECTION * e;\n                }\n            } else {\n                if (x \u003c m) {\n                    e \u003d b - x;\n                } else {\n                    e \u003d a - x;\n                }\n                d \u003d GOLDEN_SECTION * e;\n            }\n            if (FastMath.abs(d) \u003c tol1) {\n                if (d \u003e\u003d 0) {\n                    u \u003d x + tol1;\n                } else {\n                    u \u003d x - tol1;\n                }\n            } else {\n                u \u003d x + d;\n            }\n            double fu \u003d computeObjectiveValue(u);\n            if (!isMinim) {\n                fu \u003d -fu;\n            }\n            if (fu \u003c\u003d fx) {\n                if (u \u003c x) {\n                    b \u003d x;\n                } else {\n                    a \u003d x;\n                }\n                v \u003d w;\n                fv \u003d fw;\n                w \u003d x;\n                fw \u003d fx;\n                x \u003d u;\n                fx \u003d fu;\n                previous \u003d current;\n                current \u003d new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n                if (checker !\u003d null) {\n                    if (checker.converged(iter, previous, current)) {\n                        return current;\n                    }\n                }\n            } else {\n                if (u \u003c x) {\n                    a \u003d u;\n                } else {\n                    b \u003d u;\n                }\n                if (fu \u003c\u003d fw || Precision.equals(w, x)) {\n                    v \u003d w;\n                    fv \u003d fw;\n                    w \u003d u;\n                    fw \u003d fu;\n                } else if (fu \u003c\u003d fv || Precision.equals(v, x) || Precision.equals(v, w)) {\n                    v \u003d u;\n                    fv \u003d fu;\n                }\n            }\n        } else {\n            return current;\n        }\n        ++iter;\n    }\n}",
      "path": "src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java",
      "functionStartLine": 108,
      "functionName": "doOptimize",
      "functionAnnotation": "@Override",
      "functionDoc": "@inheritDoc}\n",
      "diff": "@@ -1,132 +1,132 @@\n @Override\n protected UnivariatePointValuePair doOptimize() {\n     final boolean isMinim \u003d getGoalType() \u003d\u003d GoalType.MINIMIZE;\n     final double lo \u003d getMin();\n     final double mid \u003d getStartValue();\n     final double hi \u003d getMax();\n     final ConvergenceChecker\u003cUnivariatePointValuePair\u003e checker \u003d getConvergenceChecker();\n     double a;\n     double b;\n     if (lo \u003c hi) {\n         a \u003d lo;\n         b \u003d hi;\n     } else {\n         a \u003d hi;\n         b \u003d lo;\n     }\n     double x \u003d mid;\n     double v \u003d x;\n     double w \u003d x;\n     double d \u003d 0;\n     double e \u003d 0;\n     double fx \u003d computeObjectiveValue(x);\n     if (!isMinim) {\n         fx \u003d -fx;\n     }\n     double fv \u003d fx;\n     double fw \u003d fx;\n     UnivariatePointValuePair previous \u003d null;\n     UnivariatePointValuePair current \u003d new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n     int iter \u003d 0;\n     while (true) {\n         final double m \u003d 0.5 * (a + b);\n         final double tol1 \u003d relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n         final double tol2 \u003d 2 * tol1;\n         final boolean stop \u003d FastMath.abs(x - m) \u003c\u003d tol2 - 0.5 * (b - a);\n         if (!stop) {\n             double p \u003d 0;\n             double q \u003d 0;\n             double r \u003d 0;\n             double u \u003d 0;\n             if (FastMath.abs(e) \u003e tol1) {\n                 r \u003d (x - w) * (fx - fv);\n                 q \u003d (x - v) * (fx - fw);\n                 p \u003d (x - v) * q - (x - w) * r;\n                 q \u003d 2 * (q - r);\n                 if (q \u003e 0) {\n                     p \u003d -p;\n                 } else {\n                     q \u003d -q;\n                 }\n                 r \u003d e;\n                 e \u003d d;\n                 if (p \u003e q * (a - x) \u0026\u0026 p \u003c q * (b - x) \u0026\u0026 FastMath.abs(p) \u003c FastMath.abs(0.5 * q * r)) {\n                     d \u003d p / q;\n                     u \u003d x + d;\n                     if (u - a \u003c tol2 || b - u \u003c tol2) {\n                         if (x \u003c\u003d m) {\n                             d \u003d tol1;\n                         } else {\n                             d \u003d -tol1;\n                         }\n                     }\n                 } else {\n                     if (x \u003c m) {\n                         e \u003d b - x;\n                     } else {\n                         e \u003d a - x;\n                     }\n                     d \u003d GOLDEN_SECTION * e;\n                 }\n             } else {\n                 if (x \u003c m) {\n                     e \u003d b - x;\n                 } else {\n                     e \u003d a - x;\n                 }\n                 d \u003d GOLDEN_SECTION * e;\n             }\n             if (FastMath.abs(d) \u003c tol1) {\n                 if (d \u003e\u003d 0) {\n                     u \u003d x + tol1;\n                 } else {\n                     u \u003d x - tol1;\n                 }\n             } else {\n                 u \u003d x + d;\n             }\n             double fu \u003d computeObjectiveValue(u);\n             if (!isMinim) {\n                 fu \u003d -fu;\n             }\n             if (fu \u003c\u003d fx) {\n                 if (u \u003c x) {\n                     b \u003d x;\n                 } else {\n                     a \u003d x;\n                 }\n                 v \u003d w;\n                 fv \u003d fw;\n                 w \u003d x;\n                 fw \u003d fx;\n                 x \u003d u;\n                 fx \u003d fu;\n+                previous \u003d current;\n+                current \u003d new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n+                if (checker !\u003d null) {\n+                    if (checker.converged(iter, previous, current)) {\n+                        return current;\n+                    }\n+                }\n             } else {\n                 if (u \u003c x) {\n                     a \u003d u;\n                 } else {\n                     b \u003d u;\n                 }\n                 if (fu \u003c\u003d fw || Precision.equals(w, x)) {\n                     v \u003d w;\n                     fv \u003d fw;\n                     w \u003d u;\n                     fw \u003d fu;\n                 } else if (fu \u003c\u003d fv || Precision.equals(v, x) || Precision.equals(v, w)) {\n                     v \u003d u;\n                     fv \u003d fu;\n                 }\n             }\n-            previous \u003d current;\n-            current \u003d new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n-            if (checker !\u003d null) {\n-                if (checker.converged(iter, previous, current)) {\n-                    return current;\n-                }\n-            }\n         } else {\n             return current;\n         }\n         ++iter;\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2d698e4905cb75bd125e2fe1f5223d7e68f0adcd": {
      "type": "Ymovefromfile",
      "commitMessage": "MATH-444\nBase package name change: \"o.a.c.math\" -\u003e \"o.a.c.math3\"\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@1244107 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2/14/12, 8:17 AM",
      "commitName": "2d698e4905cb75bd125e2fe1f5223d7e68f0adcd",
      "commitAuthor": "Gilles Sadowski",
      "commitDateOld": "2/14/12, 6:34 AM",
      "commitNameOld": "53257329dd394be1333b38bae787bf0cf19dc900",
      "commitAuthorOld": "Gilles Sadowski",
      "daysBetweenCommits": 0.07,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected UnivariatePointValuePair doOptimize() {\n    final boolean isMinim \u003d getGoalType() \u003d\u003d GoalType.MINIMIZE;\n    final double lo \u003d getMin();\n    final double mid \u003d getStartValue();\n    final double hi \u003d getMax();\n    final ConvergenceChecker\u003cUnivariatePointValuePair\u003e checker \u003d getConvergenceChecker();\n    double a;\n    double b;\n    if (lo \u003c hi) {\n        a \u003d lo;\n        b \u003d hi;\n    } else {\n        a \u003d hi;\n        b \u003d lo;\n    }\n    double x \u003d mid;\n    double v \u003d x;\n    double w \u003d x;\n    double d \u003d 0;\n    double e \u003d 0;\n    double fx \u003d computeObjectiveValue(x);\n    if (!isMinim) {\n        fx \u003d -fx;\n    }\n    double fv \u003d fx;\n    double fw \u003d fx;\n    UnivariatePointValuePair previous \u003d null;\n    UnivariatePointValuePair current \u003d new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n    int iter \u003d 0;\n    while (true) {\n        final double m \u003d 0.5 * (a + b);\n        final double tol1 \u003d relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n        final double tol2 \u003d 2 * tol1;\n        final boolean stop \u003d FastMath.abs(x - m) \u003c\u003d tol2 - 0.5 * (b - a);\n        if (!stop) {\n            double p \u003d 0;\n            double q \u003d 0;\n            double r \u003d 0;\n            double u \u003d 0;\n            if (FastMath.abs(e) \u003e tol1) {\n                r \u003d (x - w) * (fx - fv);\n                q \u003d (x - v) * (fx - fw);\n                p \u003d (x - v) * q - (x - w) * r;\n                q \u003d 2 * (q - r);\n                if (q \u003e 0) {\n                    p \u003d -p;\n                } else {\n                    q \u003d -q;\n                }\n                r \u003d e;\n                e \u003d d;\n                if (p \u003e q * (a - x) \u0026\u0026 p \u003c q * (b - x) \u0026\u0026 FastMath.abs(p) \u003c FastMath.abs(0.5 * q * r)) {\n                    d \u003d p / q;\n                    u \u003d x + d;\n                    if (u - a \u003c tol2 || b - u \u003c tol2) {\n                        if (x \u003c\u003d m) {\n                            d \u003d tol1;\n                        } else {\n                            d \u003d -tol1;\n                        }\n                    }\n                } else {\n                    if (x \u003c m) {\n                        e \u003d b - x;\n                    } else {\n                        e \u003d a - x;\n                    }\n                    d \u003d GOLDEN_SECTION * e;\n                }\n            } else {\n                if (x \u003c m) {\n                    e \u003d b - x;\n                } else {\n                    e \u003d a - x;\n                }\n                d \u003d GOLDEN_SECTION * e;\n            }\n            if (FastMath.abs(d) \u003c tol1) {\n                if (d \u003e\u003d 0) {\n                    u \u003d x + tol1;\n                } else {\n                    u \u003d x - tol1;\n                }\n            } else {\n                u \u003d x + d;\n            }\n            double fu \u003d computeObjectiveValue(u);\n            if (!isMinim) {\n                fu \u003d -fu;\n            }\n            if (fu \u003c\u003d fx) {\n                if (u \u003c x) {\n                    b \u003d x;\n                } else {\n                    a \u003d x;\n                }\n                v \u003d w;\n                fv \u003d fw;\n                w \u003d x;\n                fw \u003d fx;\n                x \u003d u;\n                fx \u003d fu;\n            } else {\n                if (u \u003c x) {\n                    a \u003d u;\n                } else {\n                    b \u003d u;\n                }\n                if (fu \u003c\u003d fw || Precision.equals(w, x)) {\n                    v \u003d w;\n                    fv \u003d fw;\n                    w \u003d u;\n                    fw \u003d fu;\n                } else if (fu \u003c\u003d fv || Precision.equals(v, x) || Precision.equals(v, w)) {\n                    v \u003d u;\n                    fv \u003d fu;\n                }\n            }\n            previous \u003d current;\n            current \u003d new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n            if (checker !\u003d null) {\n                if (checker.converged(iter, previous, current)) {\n                    return current;\n                }\n            }\n        } else {\n            return current;\n        }\n        ++iter;\n    }\n}",
      "path": "src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java",
      "functionStartLine": 108,
      "functionName": "doOptimize",
      "functionAnnotation": "@Override",
      "functionDoc": "@inheritDoc}\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java",
        "newPath": "src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java",
        "oldMethodName": "doOptimize",
        "newMethodName": "doOptimize"
      }
    },
    "5a8be77a303c9e2f8c19d029e8628d7697fb581d": {
      "type": "Ymultichange(Yreturntypechange,Ybodychange)",
      "commitMessage": "MATH-707\nRenamed \"RealPointValuePair\" to \"PointValuePair\" and made it a subclass\nof \"Pair\u003cdouble[], Double\u003e\".\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@1243186 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2/11/12, 4:37 PM",
      "commitName": "5a8be77a303c9e2f8c19d029e8628d7697fb581d",
      "commitAuthor": "Gilles Sadowski",
      "subchanges": [
        {
          "type": "Yreturntypechange",
          "commitMessage": "MATH-707\nRenamed \"RealPointValuePair\" to \"PointValuePair\" and made it a subclass\nof \"Pair\u003cdouble[], Double\u003e\".\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@1243186 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2/11/12, 4:37 PM",
          "commitName": "5a8be77a303c9e2f8c19d029e8628d7697fb581d",
          "commitAuthor": "Gilles Sadowski",
          "commitDateOld": "12/9/11, 5:00 AM",
          "commitNameOld": "660821d1758a0bc7eabfd80b6e5528a579a01949",
          "commitAuthorOld": "Gilles Sadowski",
          "daysBetweenCommits": 64.48,
          "commitsBetweenForRepo": 125,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\nprotected UnivariatePointValuePair doOptimize() {\n    final boolean isMinim \u003d getGoalType() \u003d\u003d GoalType.MINIMIZE;\n    final double lo \u003d getMin();\n    final double mid \u003d getStartValue();\n    final double hi \u003d getMax();\n    final ConvergenceChecker\u003cUnivariatePointValuePair\u003e checker \u003d getConvergenceChecker();\n    double a;\n    double b;\n    if (lo \u003c hi) {\n        a \u003d lo;\n        b \u003d hi;\n    } else {\n        a \u003d hi;\n        b \u003d lo;\n    }\n    double x \u003d mid;\n    double v \u003d x;\n    double w \u003d x;\n    double d \u003d 0;\n    double e \u003d 0;\n    double fx \u003d computeObjectiveValue(x);\n    if (!isMinim) {\n        fx \u003d -fx;\n    }\n    double fv \u003d fx;\n    double fw \u003d fx;\n    UnivariatePointValuePair previous \u003d null;\n    UnivariatePointValuePair current \u003d new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n    int iter \u003d 0;\n    while (true) {\n        final double m \u003d 0.5 * (a + b);\n        final double tol1 \u003d relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n        final double tol2 \u003d 2 * tol1;\n        final boolean stop \u003d FastMath.abs(x - m) \u003c\u003d tol2 - 0.5 * (b - a);\n        if (!stop) {\n            double p \u003d 0;\n            double q \u003d 0;\n            double r \u003d 0;\n            double u \u003d 0;\n            if (FastMath.abs(e) \u003e tol1) {\n                r \u003d (x - w) * (fx - fv);\n                q \u003d (x - v) * (fx - fw);\n                p \u003d (x - v) * q - (x - w) * r;\n                q \u003d 2 * (q - r);\n                if (q \u003e 0) {\n                    p \u003d -p;\n                } else {\n                    q \u003d -q;\n                }\n                r \u003d e;\n                e \u003d d;\n                if (p \u003e q * (a - x) \u0026\u0026 p \u003c q * (b - x) \u0026\u0026 FastMath.abs(p) \u003c FastMath.abs(0.5 * q * r)) {\n                    d \u003d p / q;\n                    u \u003d x + d;\n                    if (u - a \u003c tol2 || b - u \u003c tol2) {\n                        if (x \u003c\u003d m) {\n                            d \u003d tol1;\n                        } else {\n                            d \u003d -tol1;\n                        }\n                    }\n                } else {\n                    if (x \u003c m) {\n                        e \u003d b - x;\n                    } else {\n                        e \u003d a - x;\n                    }\n                    d \u003d GOLDEN_SECTION * e;\n                }\n            } else {\n                if (x \u003c m) {\n                    e \u003d b - x;\n                } else {\n                    e \u003d a - x;\n                }\n                d \u003d GOLDEN_SECTION * e;\n            }\n            if (FastMath.abs(d) \u003c tol1) {\n                if (d \u003e\u003d 0) {\n                    u \u003d x + tol1;\n                } else {\n                    u \u003d x - tol1;\n                }\n            } else {\n                u \u003d x + d;\n            }\n            double fu \u003d computeObjectiveValue(u);\n            if (!isMinim) {\n                fu \u003d -fu;\n            }\n            if (fu \u003c\u003d fx) {\n                if (u \u003c x) {\n                    b \u003d x;\n                } else {\n                    a \u003d x;\n                }\n                v \u003d w;\n                fv \u003d fw;\n                w \u003d x;\n                fw \u003d fx;\n                x \u003d u;\n                fx \u003d fu;\n            } else {\n                if (u \u003c x) {\n                    a \u003d u;\n                } else {\n                    b \u003d u;\n                }\n                if (fu \u003c\u003d fw || Precision.equals(w, x)) {\n                    v \u003d w;\n                    fv \u003d fw;\n                    w \u003d u;\n                    fw \u003d fu;\n                } else if (fu \u003c\u003d fv || Precision.equals(v, x) || Precision.equals(v, w)) {\n                    v \u003d u;\n                    fv \u003d fu;\n                }\n            }\n            previous \u003d current;\n            current \u003d new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n            if (checker !\u003d null) {\n                if (checker.converged(iter, previous, current)) {\n                    return current;\n                }\n            }\n        } else {\n            return current;\n        }\n        ++iter;\n    }\n}",
          "path": "src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java",
          "functionStartLine": 108,
          "functionName": "doOptimize",
          "functionAnnotation": "@Override",
          "functionDoc": "@inheritDoc}\n",
          "diff": "@@ -1,132 +1,132 @@\n @Override\n-protected UnivariateRealPointValuePair doOptimize() {\n+protected UnivariatePointValuePair doOptimize() {\n     final boolean isMinim \u003d getGoalType() \u003d\u003d GoalType.MINIMIZE;\n     final double lo \u003d getMin();\n     final double mid \u003d getStartValue();\n     final double hi \u003d getMax();\n-    final ConvergenceChecker\u003cUnivariateRealPointValuePair\u003e checker \u003d getConvergenceChecker();\n+    final ConvergenceChecker\u003cUnivariatePointValuePair\u003e checker \u003d getConvergenceChecker();\n     double a;\n     double b;\n     if (lo \u003c hi) {\n         a \u003d lo;\n         b \u003d hi;\n     } else {\n         a \u003d hi;\n         b \u003d lo;\n     }\n     double x \u003d mid;\n     double v \u003d x;\n     double w \u003d x;\n     double d \u003d 0;\n     double e \u003d 0;\n     double fx \u003d computeObjectiveValue(x);\n     if (!isMinim) {\n         fx \u003d -fx;\n     }\n     double fv \u003d fx;\n     double fw \u003d fx;\n-    UnivariateRealPointValuePair previous \u003d null;\n-    UnivariateRealPointValuePair current \u003d new UnivariateRealPointValuePair(x, isMinim ? fx : -fx);\n+    UnivariatePointValuePair previous \u003d null;\n+    UnivariatePointValuePair current \u003d new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n     int iter \u003d 0;\n     while (true) {\n         final double m \u003d 0.5 * (a + b);\n         final double tol1 \u003d relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n         final double tol2 \u003d 2 * tol1;\n         final boolean stop \u003d FastMath.abs(x - m) \u003c\u003d tol2 - 0.5 * (b - a);\n         if (!stop) {\n             double p \u003d 0;\n             double q \u003d 0;\n             double r \u003d 0;\n             double u \u003d 0;\n             if (FastMath.abs(e) \u003e tol1) {\n                 r \u003d (x - w) * (fx - fv);\n                 q \u003d (x - v) * (fx - fw);\n                 p \u003d (x - v) * q - (x - w) * r;\n                 q \u003d 2 * (q - r);\n                 if (q \u003e 0) {\n                     p \u003d -p;\n                 } else {\n                     q \u003d -q;\n                 }\n                 r \u003d e;\n                 e \u003d d;\n                 if (p \u003e q * (a - x) \u0026\u0026 p \u003c q * (b - x) \u0026\u0026 FastMath.abs(p) \u003c FastMath.abs(0.5 * q * r)) {\n                     d \u003d p / q;\n                     u \u003d x + d;\n                     if (u - a \u003c tol2 || b - u \u003c tol2) {\n                         if (x \u003c\u003d m) {\n                             d \u003d tol1;\n                         } else {\n                             d \u003d -tol1;\n                         }\n                     }\n                 } else {\n                     if (x \u003c m) {\n                         e \u003d b - x;\n                     } else {\n                         e \u003d a - x;\n                     }\n                     d \u003d GOLDEN_SECTION * e;\n                 }\n             } else {\n                 if (x \u003c m) {\n                     e \u003d b - x;\n                 } else {\n                     e \u003d a - x;\n                 }\n                 d \u003d GOLDEN_SECTION * e;\n             }\n             if (FastMath.abs(d) \u003c tol1) {\n                 if (d \u003e\u003d 0) {\n                     u \u003d x + tol1;\n                 } else {\n                     u \u003d x - tol1;\n                 }\n             } else {\n                 u \u003d x + d;\n             }\n             double fu \u003d computeObjectiveValue(u);\n             if (!isMinim) {\n                 fu \u003d -fu;\n             }\n             if (fu \u003c\u003d fx) {\n                 if (u \u003c x) {\n                     b \u003d x;\n                 } else {\n                     a \u003d x;\n                 }\n                 v \u003d w;\n                 fv \u003d fw;\n                 w \u003d x;\n                 fw \u003d fx;\n                 x \u003d u;\n                 fx \u003d fu;\n             } else {\n                 if (u \u003c x) {\n                     a \u003d u;\n                 } else {\n                     b \u003d u;\n                 }\n                 if (fu \u003c\u003d fw || Precision.equals(w, x)) {\n                     v \u003d w;\n                     fv \u003d fw;\n                     w \u003d u;\n                     fw \u003d fu;\n                 } else if (fu \u003c\u003d fv || Precision.equals(v, x) || Precision.equals(v, w)) {\n                     v \u003d u;\n                     fv \u003d fu;\n                 }\n             }\n             previous \u003d current;\n-            current \u003d new UnivariateRealPointValuePair(x, isMinim ? fx : -fx);\n+            current \u003d new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n             if (checker !\u003d null) {\n                 if (checker.converged(iter, previous, current)) {\n                     return current;\n                 }\n             }\n         } else {\n             return current;\n         }\n         ++iter;\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "UnivariateRealPointValuePair",
            "newValue": "UnivariatePointValuePair"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "MATH-707\nRenamed \"RealPointValuePair\" to \"PointValuePair\" and made it a subclass\nof \"Pair\u003cdouble[], Double\u003e\".\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@1243186 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2/11/12, 4:37 PM",
          "commitName": "5a8be77a303c9e2f8c19d029e8628d7697fb581d",
          "commitAuthor": "Gilles Sadowski",
          "commitDateOld": "12/9/11, 5:00 AM",
          "commitNameOld": "660821d1758a0bc7eabfd80b6e5528a579a01949",
          "commitAuthorOld": "Gilles Sadowski",
          "daysBetweenCommits": 64.48,
          "commitsBetweenForRepo": 125,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\nprotected UnivariatePointValuePair doOptimize() {\n    final boolean isMinim \u003d getGoalType() \u003d\u003d GoalType.MINIMIZE;\n    final double lo \u003d getMin();\n    final double mid \u003d getStartValue();\n    final double hi \u003d getMax();\n    final ConvergenceChecker\u003cUnivariatePointValuePair\u003e checker \u003d getConvergenceChecker();\n    double a;\n    double b;\n    if (lo \u003c hi) {\n        a \u003d lo;\n        b \u003d hi;\n    } else {\n        a \u003d hi;\n        b \u003d lo;\n    }\n    double x \u003d mid;\n    double v \u003d x;\n    double w \u003d x;\n    double d \u003d 0;\n    double e \u003d 0;\n    double fx \u003d computeObjectiveValue(x);\n    if (!isMinim) {\n        fx \u003d -fx;\n    }\n    double fv \u003d fx;\n    double fw \u003d fx;\n    UnivariatePointValuePair previous \u003d null;\n    UnivariatePointValuePair current \u003d new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n    int iter \u003d 0;\n    while (true) {\n        final double m \u003d 0.5 * (a + b);\n        final double tol1 \u003d relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n        final double tol2 \u003d 2 * tol1;\n        final boolean stop \u003d FastMath.abs(x - m) \u003c\u003d tol2 - 0.5 * (b - a);\n        if (!stop) {\n            double p \u003d 0;\n            double q \u003d 0;\n            double r \u003d 0;\n            double u \u003d 0;\n            if (FastMath.abs(e) \u003e tol1) {\n                r \u003d (x - w) * (fx - fv);\n                q \u003d (x - v) * (fx - fw);\n                p \u003d (x - v) * q - (x - w) * r;\n                q \u003d 2 * (q - r);\n                if (q \u003e 0) {\n                    p \u003d -p;\n                } else {\n                    q \u003d -q;\n                }\n                r \u003d e;\n                e \u003d d;\n                if (p \u003e q * (a - x) \u0026\u0026 p \u003c q * (b - x) \u0026\u0026 FastMath.abs(p) \u003c FastMath.abs(0.5 * q * r)) {\n                    d \u003d p / q;\n                    u \u003d x + d;\n                    if (u - a \u003c tol2 || b - u \u003c tol2) {\n                        if (x \u003c\u003d m) {\n                            d \u003d tol1;\n                        } else {\n                            d \u003d -tol1;\n                        }\n                    }\n                } else {\n                    if (x \u003c m) {\n                        e \u003d b - x;\n                    } else {\n                        e \u003d a - x;\n                    }\n                    d \u003d GOLDEN_SECTION * e;\n                }\n            } else {\n                if (x \u003c m) {\n                    e \u003d b - x;\n                } else {\n                    e \u003d a - x;\n                }\n                d \u003d GOLDEN_SECTION * e;\n            }\n            if (FastMath.abs(d) \u003c tol1) {\n                if (d \u003e\u003d 0) {\n                    u \u003d x + tol1;\n                } else {\n                    u \u003d x - tol1;\n                }\n            } else {\n                u \u003d x + d;\n            }\n            double fu \u003d computeObjectiveValue(u);\n            if (!isMinim) {\n                fu \u003d -fu;\n            }\n            if (fu \u003c\u003d fx) {\n                if (u \u003c x) {\n                    b \u003d x;\n                } else {\n                    a \u003d x;\n                }\n                v \u003d w;\n                fv \u003d fw;\n                w \u003d x;\n                fw \u003d fx;\n                x \u003d u;\n                fx \u003d fu;\n            } else {\n                if (u \u003c x) {\n                    a \u003d u;\n                } else {\n                    b \u003d u;\n                }\n                if (fu \u003c\u003d fw || Precision.equals(w, x)) {\n                    v \u003d w;\n                    fv \u003d fw;\n                    w \u003d u;\n                    fw \u003d fu;\n                } else if (fu \u003c\u003d fv || Precision.equals(v, x) || Precision.equals(v, w)) {\n                    v \u003d u;\n                    fv \u003d fu;\n                }\n            }\n            previous \u003d current;\n            current \u003d new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n            if (checker !\u003d null) {\n                if (checker.converged(iter, previous, current)) {\n                    return current;\n                }\n            }\n        } else {\n            return current;\n        }\n        ++iter;\n    }\n}",
          "path": "src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java",
          "functionStartLine": 108,
          "functionName": "doOptimize",
          "functionAnnotation": "@Override",
          "functionDoc": "@inheritDoc}\n",
          "diff": "@@ -1,132 +1,132 @@\n @Override\n-protected UnivariateRealPointValuePair doOptimize() {\n+protected UnivariatePointValuePair doOptimize() {\n     final boolean isMinim \u003d getGoalType() \u003d\u003d GoalType.MINIMIZE;\n     final double lo \u003d getMin();\n     final double mid \u003d getStartValue();\n     final double hi \u003d getMax();\n-    final ConvergenceChecker\u003cUnivariateRealPointValuePair\u003e checker \u003d getConvergenceChecker();\n+    final ConvergenceChecker\u003cUnivariatePointValuePair\u003e checker \u003d getConvergenceChecker();\n     double a;\n     double b;\n     if (lo \u003c hi) {\n         a \u003d lo;\n         b \u003d hi;\n     } else {\n         a \u003d hi;\n         b \u003d lo;\n     }\n     double x \u003d mid;\n     double v \u003d x;\n     double w \u003d x;\n     double d \u003d 0;\n     double e \u003d 0;\n     double fx \u003d computeObjectiveValue(x);\n     if (!isMinim) {\n         fx \u003d -fx;\n     }\n     double fv \u003d fx;\n     double fw \u003d fx;\n-    UnivariateRealPointValuePair previous \u003d null;\n-    UnivariateRealPointValuePair current \u003d new UnivariateRealPointValuePair(x, isMinim ? fx : -fx);\n+    UnivariatePointValuePair previous \u003d null;\n+    UnivariatePointValuePair current \u003d new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n     int iter \u003d 0;\n     while (true) {\n         final double m \u003d 0.5 * (a + b);\n         final double tol1 \u003d relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n         final double tol2 \u003d 2 * tol1;\n         final boolean stop \u003d FastMath.abs(x - m) \u003c\u003d tol2 - 0.5 * (b - a);\n         if (!stop) {\n             double p \u003d 0;\n             double q \u003d 0;\n             double r \u003d 0;\n             double u \u003d 0;\n             if (FastMath.abs(e) \u003e tol1) {\n                 r \u003d (x - w) * (fx - fv);\n                 q \u003d (x - v) * (fx - fw);\n                 p \u003d (x - v) * q - (x - w) * r;\n                 q \u003d 2 * (q - r);\n                 if (q \u003e 0) {\n                     p \u003d -p;\n                 } else {\n                     q \u003d -q;\n                 }\n                 r \u003d e;\n                 e \u003d d;\n                 if (p \u003e q * (a - x) \u0026\u0026 p \u003c q * (b - x) \u0026\u0026 FastMath.abs(p) \u003c FastMath.abs(0.5 * q * r)) {\n                     d \u003d p / q;\n                     u \u003d x + d;\n                     if (u - a \u003c tol2 || b - u \u003c tol2) {\n                         if (x \u003c\u003d m) {\n                             d \u003d tol1;\n                         } else {\n                             d \u003d -tol1;\n                         }\n                     }\n                 } else {\n                     if (x \u003c m) {\n                         e \u003d b - x;\n                     } else {\n                         e \u003d a - x;\n                     }\n                     d \u003d GOLDEN_SECTION * e;\n                 }\n             } else {\n                 if (x \u003c m) {\n                     e \u003d b - x;\n                 } else {\n                     e \u003d a - x;\n                 }\n                 d \u003d GOLDEN_SECTION * e;\n             }\n             if (FastMath.abs(d) \u003c tol1) {\n                 if (d \u003e\u003d 0) {\n                     u \u003d x + tol1;\n                 } else {\n                     u \u003d x - tol1;\n                 }\n             } else {\n                 u \u003d x + d;\n             }\n             double fu \u003d computeObjectiveValue(u);\n             if (!isMinim) {\n                 fu \u003d -fu;\n             }\n             if (fu \u003c\u003d fx) {\n                 if (u \u003c x) {\n                     b \u003d x;\n                 } else {\n                     a \u003d x;\n                 }\n                 v \u003d w;\n                 fv \u003d fw;\n                 w \u003d x;\n                 fw \u003d fx;\n                 x \u003d u;\n                 fx \u003d fu;\n             } else {\n                 if (u \u003c x) {\n                     a \u003d u;\n                 } else {\n                     b \u003d u;\n                 }\n                 if (fu \u003c\u003d fw || Precision.equals(w, x)) {\n                     v \u003d w;\n                     fv \u003d fw;\n                     w \u003d u;\n                     fw \u003d fu;\n                 } else if (fu \u003c\u003d fv || Precision.equals(v, x) || Precision.equals(v, w)) {\n                     v \u003d u;\n                     fv \u003d fu;\n                 }\n             }\n             previous \u003d current;\n-            current \u003d new UnivariateRealPointValuePair(x, isMinim ? fx : -fx);\n+            current \u003d new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n             if (checker !\u003d null) {\n                 if (checker.converged(iter, previous, current)) {\n                     return current;\n                 }\n             }\n         } else {\n             return current;\n         }\n         ++iter;\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "b59e97464fc8d910c06b90c06598d7176ce1924a": {
      "type": "Ybodychange",
      "commitMessage": "MATH-689\nMoved \"equals...\" and \"compareTo\" methods from \"MathUtils\" over to a new\n\"Precision\" class.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@1181282 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/10/11, 3:35 PM",
      "commitName": "b59e97464fc8d910c06b90c06598d7176ce1924a",
      "commitAuthor": "Gilles Sadowski",
      "commitDateOld": "9/7/11, 11:48 AM",
      "commitNameOld": "74c289e6cc999fec27551b7e16fb6245b1352a37",
      "commitAuthorOld": "Luc Maisonobe",
      "daysBetweenCommits": 33.16,
      "commitsBetweenForRepo": 166,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected UnivariateRealPointValuePair doOptimize() {\n    final boolean isMinim \u003d getGoalType() \u003d\u003d GoalType.MINIMIZE;\n    final double lo \u003d getMin();\n    final double mid \u003d getStartValue();\n    final double hi \u003d getMax();\n    final ConvergenceChecker\u003cUnivariateRealPointValuePair\u003e checker \u003d getConvergenceChecker();\n    double a;\n    double b;\n    if (lo \u003c hi) {\n        a \u003d lo;\n        b \u003d hi;\n    } else {\n        a \u003d hi;\n        b \u003d lo;\n    }\n    double x \u003d mid;\n    double v \u003d x;\n    double w \u003d x;\n    double d \u003d 0;\n    double e \u003d 0;\n    double fx \u003d computeObjectiveValue(x);\n    if (!isMinim) {\n        fx \u003d -fx;\n    }\n    double fv \u003d fx;\n    double fw \u003d fx;\n    UnivariateRealPointValuePair previous \u003d null;\n    UnivariateRealPointValuePair current \u003d new UnivariateRealPointValuePair(x, isMinim ? fx : -fx);\n    int iter \u003d 0;\n    while (true) {\n        final double m \u003d 0.5 * (a + b);\n        final double tol1 \u003d relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n        final double tol2 \u003d 2 * tol1;\n        final boolean stop \u003d FastMath.abs(x - m) \u003c\u003d tol2 - 0.5 * (b - a);\n        if (!stop) {\n            double p \u003d 0;\n            double q \u003d 0;\n            double r \u003d 0;\n            double u \u003d 0;\n            if (FastMath.abs(e) \u003e tol1) {\n                r \u003d (x - w) * (fx - fv);\n                q \u003d (x - v) * (fx - fw);\n                p \u003d (x - v) * q - (x - w) * r;\n                q \u003d 2 * (q - r);\n                if (q \u003e 0) {\n                    p \u003d -p;\n                } else {\n                    q \u003d -q;\n                }\n                r \u003d e;\n                e \u003d d;\n                if (p \u003e q * (a - x) \u0026\u0026 p \u003c q * (b - x) \u0026\u0026 FastMath.abs(p) \u003c FastMath.abs(0.5 * q * r)) {\n                    d \u003d p / q;\n                    u \u003d x + d;\n                    if (u - a \u003c tol2 || b - u \u003c tol2) {\n                        if (x \u003c\u003d m) {\n                            d \u003d tol1;\n                        } else {\n                            d \u003d -tol1;\n                        }\n                    }\n                } else {\n                    if (x \u003c m) {\n                        e \u003d b - x;\n                    } else {\n                        e \u003d a - x;\n                    }\n                    d \u003d GOLDEN_SECTION * e;\n                }\n            } else {\n                if (x \u003c m) {\n                    e \u003d b - x;\n                } else {\n                    e \u003d a - x;\n                }\n                d \u003d GOLDEN_SECTION * e;\n            }\n            if (FastMath.abs(d) \u003c tol1) {\n                if (d \u003e\u003d 0) {\n                    u \u003d x + tol1;\n                } else {\n                    u \u003d x - tol1;\n                }\n            } else {\n                u \u003d x + d;\n            }\n            double fu \u003d computeObjectiveValue(u);\n            if (!isMinim) {\n                fu \u003d -fu;\n            }\n            if (fu \u003c\u003d fx) {\n                if (u \u003c x) {\n                    b \u003d x;\n                } else {\n                    a \u003d x;\n                }\n                v \u003d w;\n                fv \u003d fw;\n                w \u003d x;\n                fw \u003d fx;\n                x \u003d u;\n                fx \u003d fu;\n            } else {\n                if (u \u003c x) {\n                    a \u003d u;\n                } else {\n                    b \u003d u;\n                }\n                if (fu \u003c\u003d fw || Precision.equals(w, x)) {\n                    v \u003d w;\n                    fv \u003d fw;\n                    w \u003d u;\n                    fw \u003d fu;\n                } else if (fu \u003c\u003d fv || Precision.equals(v, x) || Precision.equals(v, w)) {\n                    v \u003d u;\n                    fv \u003d fu;\n                }\n            }\n            previous \u003d current;\n            current \u003d new UnivariateRealPointValuePair(x, isMinim ? fx : -fx);\n            if (checker !\u003d null) {\n                if (checker.converged(iter, previous, current)) {\n                    return current;\n                }\n            }\n        } else {\n            return current;\n        }\n        ++iter;\n    }\n}",
      "path": "src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java",
      "functionStartLine": 88,
      "functionName": "doOptimize",
      "functionAnnotation": "@Override",
      "functionDoc": "@inheritDoc}\n",
      "diff": "@@ -1,132 +1,132 @@\n @Override\n protected UnivariateRealPointValuePair doOptimize() {\n     final boolean isMinim \u003d getGoalType() \u003d\u003d GoalType.MINIMIZE;\n     final double lo \u003d getMin();\n     final double mid \u003d getStartValue();\n     final double hi \u003d getMax();\n     final ConvergenceChecker\u003cUnivariateRealPointValuePair\u003e checker \u003d getConvergenceChecker();\n     double a;\n     double b;\n     if (lo \u003c hi) {\n         a \u003d lo;\n         b \u003d hi;\n     } else {\n         a \u003d hi;\n         b \u003d lo;\n     }\n     double x \u003d mid;\n     double v \u003d x;\n     double w \u003d x;\n     double d \u003d 0;\n     double e \u003d 0;\n     double fx \u003d computeObjectiveValue(x);\n     if (!isMinim) {\n         fx \u003d -fx;\n     }\n     double fv \u003d fx;\n     double fw \u003d fx;\n     UnivariateRealPointValuePair previous \u003d null;\n     UnivariateRealPointValuePair current \u003d new UnivariateRealPointValuePair(x, isMinim ? fx : -fx);\n     int iter \u003d 0;\n     while (true) {\n         final double m \u003d 0.5 * (a + b);\n         final double tol1 \u003d relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n         final double tol2 \u003d 2 * tol1;\n         final boolean stop \u003d FastMath.abs(x - m) \u003c\u003d tol2 - 0.5 * (b - a);\n         if (!stop) {\n             double p \u003d 0;\n             double q \u003d 0;\n             double r \u003d 0;\n             double u \u003d 0;\n             if (FastMath.abs(e) \u003e tol1) {\n                 r \u003d (x - w) * (fx - fv);\n                 q \u003d (x - v) * (fx - fw);\n                 p \u003d (x - v) * q - (x - w) * r;\n                 q \u003d 2 * (q - r);\n                 if (q \u003e 0) {\n                     p \u003d -p;\n                 } else {\n                     q \u003d -q;\n                 }\n                 r \u003d e;\n                 e \u003d d;\n                 if (p \u003e q * (a - x) \u0026\u0026 p \u003c q * (b - x) \u0026\u0026 FastMath.abs(p) \u003c FastMath.abs(0.5 * q * r)) {\n                     d \u003d p / q;\n                     u \u003d x + d;\n                     if (u - a \u003c tol2 || b - u \u003c tol2) {\n                         if (x \u003c\u003d m) {\n                             d \u003d tol1;\n                         } else {\n                             d \u003d -tol1;\n                         }\n                     }\n                 } else {\n                     if (x \u003c m) {\n                         e \u003d b - x;\n                     } else {\n                         e \u003d a - x;\n                     }\n                     d \u003d GOLDEN_SECTION * e;\n                 }\n             } else {\n                 if (x \u003c m) {\n                     e \u003d b - x;\n                 } else {\n                     e \u003d a - x;\n                 }\n                 d \u003d GOLDEN_SECTION * e;\n             }\n             if (FastMath.abs(d) \u003c tol1) {\n                 if (d \u003e\u003d 0) {\n                     u \u003d x + tol1;\n                 } else {\n                     u \u003d x - tol1;\n                 }\n             } else {\n                 u \u003d x + d;\n             }\n             double fu \u003d computeObjectiveValue(u);\n             if (!isMinim) {\n                 fu \u003d -fu;\n             }\n             if (fu \u003c\u003d fx) {\n                 if (u \u003c x) {\n                     b \u003d x;\n                 } else {\n                     a \u003d x;\n                 }\n                 v \u003d w;\n                 fv \u003d fw;\n                 w \u003d x;\n                 fw \u003d fx;\n                 x \u003d u;\n                 fx \u003d fu;\n             } else {\n                 if (u \u003c x) {\n                     a \u003d u;\n                 } else {\n                     b \u003d u;\n                 }\n-                if (fu \u003c\u003d fw || MathUtils.equals(w, x)) {\n+                if (fu \u003c\u003d fw || Precision.equals(w, x)) {\n                     v \u003d w;\n                     fv \u003d fw;\n                     w \u003d u;\n                     fw \u003d fu;\n-                } else if (fu \u003c\u003d fv || MathUtils.equals(v, x) || MathUtils.equals(v, w)) {\n+                } else if (fu \u003c\u003d fv || Precision.equals(v, x) || Precision.equals(v, w)) {\n                     v \u003d u;\n                     fv \u003d fu;\n                 }\n             }\n             previous \u003d current;\n             current \u003d new UnivariateRealPointValuePair(x, isMinim ? fx : -fx);\n             if (checker !\u003d null) {\n                 if (checker.converged(iter, previous, current)) {\n                     return current;\n                 }\n             }\n         } else {\n             return current;\n         }\n         ++iter;\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "74c289e6cc999fec27551b7e16fb6245b1352a37": {
      "type": "Yexceptionschange",
      "commitMessage": "Removed completely MathUserException.\n\nJIRA: MATH-195\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@1166311 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "9/7/11, 11:48 AM",
      "commitName": "74c289e6cc999fec27551b7e16fb6245b1352a37",
      "commitAuthor": "Luc Maisonobe",
      "commitDateOld": "6/3/11, 1:49 PM",
      "commitNameOld": "98e22d778b3a886be253638b9a6b7ec075c3d62d",
      "commitAuthorOld": "Luc Maisonobe",
      "daysBetweenCommits": 95.92,
      "commitsBetweenForRepo": 273,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected UnivariateRealPointValuePair doOptimize() {\n    final boolean isMinim \u003d getGoalType() \u003d\u003d GoalType.MINIMIZE;\n    final double lo \u003d getMin();\n    final double mid \u003d getStartValue();\n    final double hi \u003d getMax();\n    final ConvergenceChecker\u003cUnivariateRealPointValuePair\u003e checker \u003d getConvergenceChecker();\n    double a;\n    double b;\n    if (lo \u003c hi) {\n        a \u003d lo;\n        b \u003d hi;\n    } else {\n        a \u003d hi;\n        b \u003d lo;\n    }\n    double x \u003d mid;\n    double v \u003d x;\n    double w \u003d x;\n    double d \u003d 0;\n    double e \u003d 0;\n    double fx \u003d computeObjectiveValue(x);\n    if (!isMinim) {\n        fx \u003d -fx;\n    }\n    double fv \u003d fx;\n    double fw \u003d fx;\n    UnivariateRealPointValuePair previous \u003d null;\n    UnivariateRealPointValuePair current \u003d new UnivariateRealPointValuePair(x, isMinim ? fx : -fx);\n    int iter \u003d 0;\n    while (true) {\n        final double m \u003d 0.5 * (a + b);\n        final double tol1 \u003d relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n        final double tol2 \u003d 2 * tol1;\n        final boolean stop \u003d FastMath.abs(x - m) \u003c\u003d tol2 - 0.5 * (b - a);\n        if (!stop) {\n            double p \u003d 0;\n            double q \u003d 0;\n            double r \u003d 0;\n            double u \u003d 0;\n            if (FastMath.abs(e) \u003e tol1) {\n                r \u003d (x - w) * (fx - fv);\n                q \u003d (x - v) * (fx - fw);\n                p \u003d (x - v) * q - (x - w) * r;\n                q \u003d 2 * (q - r);\n                if (q \u003e 0) {\n                    p \u003d -p;\n                } else {\n                    q \u003d -q;\n                }\n                r \u003d e;\n                e \u003d d;\n                if (p \u003e q * (a - x) \u0026\u0026 p \u003c q * (b - x) \u0026\u0026 FastMath.abs(p) \u003c FastMath.abs(0.5 * q * r)) {\n                    d \u003d p / q;\n                    u \u003d x + d;\n                    if (u - a \u003c tol2 || b - u \u003c tol2) {\n                        if (x \u003c\u003d m) {\n                            d \u003d tol1;\n                        } else {\n                            d \u003d -tol1;\n                        }\n                    }\n                } else {\n                    if (x \u003c m) {\n                        e \u003d b - x;\n                    } else {\n                        e \u003d a - x;\n                    }\n                    d \u003d GOLDEN_SECTION * e;\n                }\n            } else {\n                if (x \u003c m) {\n                    e \u003d b - x;\n                } else {\n                    e \u003d a - x;\n                }\n                d \u003d GOLDEN_SECTION * e;\n            }\n            if (FastMath.abs(d) \u003c tol1) {\n                if (d \u003e\u003d 0) {\n                    u \u003d x + tol1;\n                } else {\n                    u \u003d x - tol1;\n                }\n            } else {\n                u \u003d x + d;\n            }\n            double fu \u003d computeObjectiveValue(u);\n            if (!isMinim) {\n                fu \u003d -fu;\n            }\n            if (fu \u003c\u003d fx) {\n                if (u \u003c x) {\n                    b \u003d x;\n                } else {\n                    a \u003d x;\n                }\n                v \u003d w;\n                fv \u003d fw;\n                w \u003d x;\n                fw \u003d fx;\n                x \u003d u;\n                fx \u003d fu;\n            } else {\n                if (u \u003c x) {\n                    a \u003d u;\n                } else {\n                    b \u003d u;\n                }\n                if (fu \u003c\u003d fw || MathUtils.equals(w, x)) {\n                    v \u003d w;\n                    fv \u003d fw;\n                    w \u003d u;\n                    fw \u003d fu;\n                } else if (fu \u003c\u003d fv || MathUtils.equals(v, x) || MathUtils.equals(v, w)) {\n                    v \u003d u;\n                    fv \u003d fu;\n                }\n            }\n            previous \u003d current;\n            current \u003d new UnivariateRealPointValuePair(x, isMinim ? fx : -fx);\n            if (checker !\u003d null) {\n                if (checker.converged(iter, previous, current)) {\n                    return current;\n                }\n            }\n        } else {\n            return current;\n        }\n        ++iter;\n    }\n}",
      "path": "src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java",
      "functionStartLine": 88,
      "functionName": "doOptimize",
      "functionAnnotation": "@Override",
      "functionDoc": "@inheritDoc}\n",
      "diff": "@@ -1,132 +1,132 @@\n @Override\n-protected UnivariateRealPointValuePair doOptimize() throws MathUserException {\n+protected UnivariateRealPointValuePair doOptimize() {\n     final boolean isMinim \u003d getGoalType() \u003d\u003d GoalType.MINIMIZE;\n     final double lo \u003d getMin();\n     final double mid \u003d getStartValue();\n     final double hi \u003d getMax();\n     final ConvergenceChecker\u003cUnivariateRealPointValuePair\u003e checker \u003d getConvergenceChecker();\n     double a;\n     double b;\n     if (lo \u003c hi) {\n         a \u003d lo;\n         b \u003d hi;\n     } else {\n         a \u003d hi;\n         b \u003d lo;\n     }\n     double x \u003d mid;\n     double v \u003d x;\n     double w \u003d x;\n     double d \u003d 0;\n     double e \u003d 0;\n     double fx \u003d computeObjectiveValue(x);\n     if (!isMinim) {\n         fx \u003d -fx;\n     }\n     double fv \u003d fx;\n     double fw \u003d fx;\n     UnivariateRealPointValuePair previous \u003d null;\n     UnivariateRealPointValuePair current \u003d new UnivariateRealPointValuePair(x, isMinim ? fx : -fx);\n     int iter \u003d 0;\n     while (true) {\n         final double m \u003d 0.5 * (a + b);\n         final double tol1 \u003d relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n         final double tol2 \u003d 2 * tol1;\n         final boolean stop \u003d FastMath.abs(x - m) \u003c\u003d tol2 - 0.5 * (b - a);\n         if (!stop) {\n             double p \u003d 0;\n             double q \u003d 0;\n             double r \u003d 0;\n             double u \u003d 0;\n             if (FastMath.abs(e) \u003e tol1) {\n                 r \u003d (x - w) * (fx - fv);\n                 q \u003d (x - v) * (fx - fw);\n                 p \u003d (x - v) * q - (x - w) * r;\n                 q \u003d 2 * (q - r);\n                 if (q \u003e 0) {\n                     p \u003d -p;\n                 } else {\n                     q \u003d -q;\n                 }\n                 r \u003d e;\n                 e \u003d d;\n                 if (p \u003e q * (a - x) \u0026\u0026 p \u003c q * (b - x) \u0026\u0026 FastMath.abs(p) \u003c FastMath.abs(0.5 * q * r)) {\n                     d \u003d p / q;\n                     u \u003d x + d;\n                     if (u - a \u003c tol2 || b - u \u003c tol2) {\n                         if (x \u003c\u003d m) {\n                             d \u003d tol1;\n                         } else {\n                             d \u003d -tol1;\n                         }\n                     }\n                 } else {\n                     if (x \u003c m) {\n                         e \u003d b - x;\n                     } else {\n                         e \u003d a - x;\n                     }\n                     d \u003d GOLDEN_SECTION * e;\n                 }\n             } else {\n                 if (x \u003c m) {\n                     e \u003d b - x;\n                 } else {\n                     e \u003d a - x;\n                 }\n                 d \u003d GOLDEN_SECTION * e;\n             }\n             if (FastMath.abs(d) \u003c tol1) {\n                 if (d \u003e\u003d 0) {\n                     u \u003d x + tol1;\n                 } else {\n                     u \u003d x - tol1;\n                 }\n             } else {\n                 u \u003d x + d;\n             }\n             double fu \u003d computeObjectiveValue(u);\n             if (!isMinim) {\n                 fu \u003d -fu;\n             }\n             if (fu \u003c\u003d fx) {\n                 if (u \u003c x) {\n                     b \u003d x;\n                 } else {\n                     a \u003d x;\n                 }\n                 v \u003d w;\n                 fv \u003d fw;\n                 w \u003d x;\n                 fw \u003d fx;\n                 x \u003d u;\n                 fx \u003d fu;\n             } else {\n                 if (u \u003c x) {\n                     a \u003d u;\n                 } else {\n                     b \u003d u;\n                 }\n                 if (fu \u003c\u003d fw || MathUtils.equals(w, x)) {\n                     v \u003d w;\n                     fv \u003d fw;\n                     w \u003d u;\n                     fw \u003d fu;\n                 } else if (fu \u003c\u003d fv || MathUtils.equals(v, x) || MathUtils.equals(v, w)) {\n                     v \u003d u;\n                     fv \u003d fu;\n                 }\n             }\n             previous \u003d current;\n             current \u003d new UnivariateRealPointValuePair(x, isMinim ? fx : -fx);\n             if (checker !\u003d null) {\n                 if (checker.converged(iter, previous, current)) {\n                     return current;\n                 }\n             }\n         } else {\n             return current;\n         }\n         ++iter;\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[MathUserException]",
        "newValue": "[]"
      }
    },
    "8302dd02498495277ec0db9301edb2158bb0e314": {
      "type": "Yexceptionschange",
      "commitMessage": "removed FunctionEvaluationException, DerivativeException and MatrixVisitorException\nthese exception were  deprecated in 2.2 and a smooth transition path was set up to help users, now all user functions should use the new unchecked MathUserException\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@1037328 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/20/10, 1:01 PM",
      "commitName": "8302dd02498495277ec0db9301edb2158bb0e314",
      "commitAuthor": "Luc Maisonobe",
      "commitDateOld": "11/14/10, 5:41 AM",
      "commitNameOld": "7285331645183d45a7110d03b45e74acf46f8be3",
      "commitAuthorOld": "Gilles Sadowski",
      "daysBetweenCommits": 6.31,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected UnivariateRealPointValuePair doOptimize() throws MathUserException {\n    final boolean isMinim \u003d getGoalType() \u003d\u003d GoalType.MINIMIZE;\n    final double lo \u003d getMin();\n    final double mid \u003d getStartValue();\n    final double hi \u003d getMax();\n    final ConvergenceChecker\u003cUnivariateRealPointValuePair\u003e checker \u003d getConvergenceChecker();\n    double a;\n    double b;\n    if (lo \u003c hi) {\n        a \u003d lo;\n        b \u003d hi;\n    } else {\n        a \u003d hi;\n        b \u003d lo;\n    }\n    double x \u003d mid;\n    double v \u003d x;\n    double w \u003d x;\n    double d \u003d 0;\n    double e \u003d 0;\n    double fx \u003d computeObjectiveValue(x);\n    if (!isMinim) {\n        fx \u003d -fx;\n    }\n    double fv \u003d fx;\n    double fw \u003d fx;\n    UnivariateRealPointValuePair previous \u003d null;\n    UnivariateRealPointValuePair current \u003d new UnivariateRealPointValuePair(x, isMinim ? fx : -fx);\n    int iter \u003d 0;\n    while (true) {\n        final double m \u003d 0.5 * (a + b);\n        final double tol1 \u003d relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n        final double tol2 \u003d 2 * tol1;\n        final boolean stop \u003d FastMath.abs(x - m) \u003c\u003d tol2 - 0.5 * (b - a);\n        if (!stop) {\n            double p \u003d 0;\n            double q \u003d 0;\n            double r \u003d 0;\n            double u \u003d 0;\n            if (FastMath.abs(e) \u003e tol1) {\n                r \u003d (x - w) * (fx - fv);\n                q \u003d (x - v) * (fx - fw);\n                p \u003d (x - v) * q - (x - w) * r;\n                q \u003d 2 * (q - r);\n                if (q \u003e 0) {\n                    p \u003d -p;\n                } else {\n                    q \u003d -q;\n                }\n                r \u003d e;\n                e \u003d d;\n                if (p \u003e q * (a - x) \u0026\u0026 p \u003c q * (b - x) \u0026\u0026 FastMath.abs(p) \u003c FastMath.abs(0.5 * q * r)) {\n                    d \u003d p / q;\n                    u \u003d x + d;\n                    if (u - a \u003c tol2 || b - u \u003c tol2) {\n                        if (x \u003c\u003d m) {\n                            d \u003d tol1;\n                        } else {\n                            d \u003d -tol1;\n                        }\n                    }\n                } else {\n                    if (x \u003c m) {\n                        e \u003d b - x;\n                    } else {\n                        e \u003d a - x;\n                    }\n                    d \u003d GOLDEN_SECTION * e;\n                }\n            } else {\n                if (x \u003c m) {\n                    e \u003d b - x;\n                } else {\n                    e \u003d a - x;\n                }\n                d \u003d GOLDEN_SECTION * e;\n            }\n            if (FastMath.abs(d) \u003c tol1) {\n                if (d \u003e\u003d 0) {\n                    u \u003d x + tol1;\n                } else {\n                    u \u003d x - tol1;\n                }\n            } else {\n                u \u003d x + d;\n            }\n            double fu \u003d computeObjectiveValue(u);\n            if (!isMinim) {\n                fu \u003d -fu;\n            }\n            if (fu \u003c\u003d fx) {\n                if (u \u003c x) {\n                    b \u003d x;\n                } else {\n                    a \u003d x;\n                }\n                v \u003d w;\n                fv \u003d fw;\n                w \u003d x;\n                fw \u003d fx;\n                x \u003d u;\n                fx \u003d fu;\n            } else {\n                if (u \u003c x) {\n                    a \u003d u;\n                } else {\n                    b \u003d u;\n                }\n                if (fu \u003c\u003d fw || MathUtils.equals(w, x)) {\n                    v \u003d w;\n                    fv \u003d fw;\n                    w \u003d u;\n                    fw \u003d fu;\n                } else if (fu \u003c\u003d fv || MathUtils.equals(v, x) || MathUtils.equals(v, w)) {\n                    v \u003d u;\n                    fv \u003d fu;\n                }\n            }\n            previous \u003d current;\n            current \u003d new UnivariateRealPointValuePair(x, isMinim ? fx : -fx);\n            if (checker !\u003d null) {\n                if (checker.converged(iter, previous, current)) {\n                    return current;\n                }\n            }\n        } else {\n            return current;\n        }\n        ++iter;\n    }\n}",
      "path": "src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java",
      "functionStartLine": 89,
      "functionName": "doOptimize",
      "functionAnnotation": "@Override",
      "functionDoc": "@inheritDoc}\n",
      "diff": "@@ -1,132 +1,132 @@\n @Override\n-protected UnivariateRealPointValuePair doOptimize() {\n+protected UnivariateRealPointValuePair doOptimize() throws MathUserException {\n     final boolean isMinim \u003d getGoalType() \u003d\u003d GoalType.MINIMIZE;\n     final double lo \u003d getMin();\n     final double mid \u003d getStartValue();\n     final double hi \u003d getMax();\n     final ConvergenceChecker\u003cUnivariateRealPointValuePair\u003e checker \u003d getConvergenceChecker();\n     double a;\n     double b;\n     if (lo \u003c hi) {\n         a \u003d lo;\n         b \u003d hi;\n     } else {\n         a \u003d hi;\n         b \u003d lo;\n     }\n     double x \u003d mid;\n     double v \u003d x;\n     double w \u003d x;\n     double d \u003d 0;\n     double e \u003d 0;\n     double fx \u003d computeObjectiveValue(x);\n     if (!isMinim) {\n         fx \u003d -fx;\n     }\n     double fv \u003d fx;\n     double fw \u003d fx;\n     UnivariateRealPointValuePair previous \u003d null;\n     UnivariateRealPointValuePair current \u003d new UnivariateRealPointValuePair(x, isMinim ? fx : -fx);\n     int iter \u003d 0;\n     while (true) {\n         final double m \u003d 0.5 * (a + b);\n         final double tol1 \u003d relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n         final double tol2 \u003d 2 * tol1;\n         final boolean stop \u003d FastMath.abs(x - m) \u003c\u003d tol2 - 0.5 * (b - a);\n         if (!stop) {\n             double p \u003d 0;\n             double q \u003d 0;\n             double r \u003d 0;\n             double u \u003d 0;\n             if (FastMath.abs(e) \u003e tol1) {\n                 r \u003d (x - w) * (fx - fv);\n                 q \u003d (x - v) * (fx - fw);\n                 p \u003d (x - v) * q - (x - w) * r;\n                 q \u003d 2 * (q - r);\n                 if (q \u003e 0) {\n                     p \u003d -p;\n                 } else {\n                     q \u003d -q;\n                 }\n                 r \u003d e;\n                 e \u003d d;\n                 if (p \u003e q * (a - x) \u0026\u0026 p \u003c q * (b - x) \u0026\u0026 FastMath.abs(p) \u003c FastMath.abs(0.5 * q * r)) {\n                     d \u003d p / q;\n                     u \u003d x + d;\n                     if (u - a \u003c tol2 || b - u \u003c tol2) {\n                         if (x \u003c\u003d m) {\n                             d \u003d tol1;\n                         } else {\n                             d \u003d -tol1;\n                         }\n                     }\n                 } else {\n                     if (x \u003c m) {\n                         e \u003d b - x;\n                     } else {\n                         e \u003d a - x;\n                     }\n                     d \u003d GOLDEN_SECTION * e;\n                 }\n             } else {\n                 if (x \u003c m) {\n                     e \u003d b - x;\n                 } else {\n                     e \u003d a - x;\n                 }\n                 d \u003d GOLDEN_SECTION * e;\n             }\n             if (FastMath.abs(d) \u003c tol1) {\n                 if (d \u003e\u003d 0) {\n                     u \u003d x + tol1;\n                 } else {\n                     u \u003d x - tol1;\n                 }\n             } else {\n                 u \u003d x + d;\n             }\n             double fu \u003d computeObjectiveValue(u);\n             if (!isMinim) {\n                 fu \u003d -fu;\n             }\n             if (fu \u003c\u003d fx) {\n                 if (u \u003c x) {\n                     b \u003d x;\n                 } else {\n                     a \u003d x;\n                 }\n                 v \u003d w;\n                 fv \u003d fw;\n                 w \u003d x;\n                 fw \u003d fx;\n                 x \u003d u;\n                 fx \u003d fu;\n             } else {\n                 if (u \u003c x) {\n                     a \u003d u;\n                 } else {\n                     b \u003d u;\n                 }\n                 if (fu \u003c\u003d fw || MathUtils.equals(w, x)) {\n                     v \u003d w;\n                     fv \u003d fw;\n                     w \u003d u;\n                     fw \u003d fu;\n                 } else if (fu \u003c\u003d fv || MathUtils.equals(v, x) || MathUtils.equals(v, w)) {\n                     v \u003d u;\n                     fv \u003d fu;\n                 }\n             }\n             previous \u003d current;\n             current \u003d new UnivariateRealPointValuePair(x, isMinim ? fx : -fx);\n             if (checker !\u003d null) {\n                 if (checker.converged(iter, previous, current)) {\n                     return current;\n                 }\n             }\n         } else {\n             return current;\n         }\n         ++iter;\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[]",
        "newValue": "[MathUserException]"
      }
    },
    "7285331645183d45a7110d03b45e74acf46f8be3": {
      "type": "Yexceptionschange",
      "commitMessage": "MATH-441\nRemoved occurences of \"FunctionEvaluationException\".\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@1034996 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/14/10, 5:41 AM",
      "commitName": "7285331645183d45a7110d03b45e74acf46f8be3",
      "commitAuthor": "Gilles Sadowski",
      "commitDateOld": "11/3/10, 6:46 AM",
      "commitNameOld": "51ec76cc5685566569af3f312efee2aaccadddfc",
      "commitAuthorOld": "Gilles Sadowski",
      "daysBetweenCommits": 11.0,
      "commitsBetweenForRepo": 37,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected UnivariateRealPointValuePair doOptimize() {\n    final boolean isMinim \u003d getGoalType() \u003d\u003d GoalType.MINIMIZE;\n    final double lo \u003d getMin();\n    final double mid \u003d getStartValue();\n    final double hi \u003d getMax();\n    final ConvergenceChecker\u003cUnivariateRealPointValuePair\u003e checker \u003d getConvergenceChecker();\n    double a;\n    double b;\n    if (lo \u003c hi) {\n        a \u003d lo;\n        b \u003d hi;\n    } else {\n        a \u003d hi;\n        b \u003d lo;\n    }\n    double x \u003d mid;\n    double v \u003d x;\n    double w \u003d x;\n    double d \u003d 0;\n    double e \u003d 0;\n    double fx \u003d computeObjectiveValue(x);\n    if (!isMinim) {\n        fx \u003d -fx;\n    }\n    double fv \u003d fx;\n    double fw \u003d fx;\n    UnivariateRealPointValuePair previous \u003d null;\n    UnivariateRealPointValuePair current \u003d new UnivariateRealPointValuePair(x, isMinim ? fx : -fx);\n    int iter \u003d 0;\n    while (true) {\n        final double m \u003d 0.5 * (a + b);\n        final double tol1 \u003d relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n        final double tol2 \u003d 2 * tol1;\n        final boolean stop \u003d FastMath.abs(x - m) \u003c\u003d tol2 - 0.5 * (b - a);\n        if (!stop) {\n            double p \u003d 0;\n            double q \u003d 0;\n            double r \u003d 0;\n            double u \u003d 0;\n            if (FastMath.abs(e) \u003e tol1) {\n                r \u003d (x - w) * (fx - fv);\n                q \u003d (x - v) * (fx - fw);\n                p \u003d (x - v) * q - (x - w) * r;\n                q \u003d 2 * (q - r);\n                if (q \u003e 0) {\n                    p \u003d -p;\n                } else {\n                    q \u003d -q;\n                }\n                r \u003d e;\n                e \u003d d;\n                if (p \u003e q * (a - x) \u0026\u0026 p \u003c q * (b - x) \u0026\u0026 FastMath.abs(p) \u003c FastMath.abs(0.5 * q * r)) {\n                    d \u003d p / q;\n                    u \u003d x + d;\n                    if (u - a \u003c tol2 || b - u \u003c tol2) {\n                        if (x \u003c\u003d m) {\n                            d \u003d tol1;\n                        } else {\n                            d \u003d -tol1;\n                        }\n                    }\n                } else {\n                    if (x \u003c m) {\n                        e \u003d b - x;\n                    } else {\n                        e \u003d a - x;\n                    }\n                    d \u003d GOLDEN_SECTION * e;\n                }\n            } else {\n                if (x \u003c m) {\n                    e \u003d b - x;\n                } else {\n                    e \u003d a - x;\n                }\n                d \u003d GOLDEN_SECTION * e;\n            }\n            if (FastMath.abs(d) \u003c tol1) {\n                if (d \u003e\u003d 0) {\n                    u \u003d x + tol1;\n                } else {\n                    u \u003d x - tol1;\n                }\n            } else {\n                u \u003d x + d;\n            }\n            double fu \u003d computeObjectiveValue(u);\n            if (!isMinim) {\n                fu \u003d -fu;\n            }\n            if (fu \u003c\u003d fx) {\n                if (u \u003c x) {\n                    b \u003d x;\n                } else {\n                    a \u003d x;\n                }\n                v \u003d w;\n                fv \u003d fw;\n                w \u003d x;\n                fw \u003d fx;\n                x \u003d u;\n                fx \u003d fu;\n            } else {\n                if (u \u003c x) {\n                    a \u003d u;\n                } else {\n                    b \u003d u;\n                }\n                if (fu \u003c\u003d fw || MathUtils.equals(w, x)) {\n                    v \u003d w;\n                    fv \u003d fw;\n                    w \u003d u;\n                    fw \u003d fu;\n                } else if (fu \u003c\u003d fv || MathUtils.equals(v, x) || MathUtils.equals(v, w)) {\n                    v \u003d u;\n                    fv \u003d fu;\n                }\n            }\n            previous \u003d current;\n            current \u003d new UnivariateRealPointValuePair(x, isMinim ? fx : -fx);\n            if (checker !\u003d null) {\n                if (checker.converged(iter, previous, current)) {\n                    return current;\n                }\n            }\n        } else {\n            return current;\n        }\n        ++iter;\n    }\n}",
      "path": "src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java",
      "functionStartLine": 88,
      "functionName": "doOptimize",
      "functionAnnotation": "@Override",
      "functionDoc": "@inheritDoc}\n",
      "diff": "@@ -1,132 +1,132 @@\n @Override\n-protected UnivariateRealPointValuePair doOptimize() throws FunctionEvaluationException {\n+protected UnivariateRealPointValuePair doOptimize() {\n     final boolean isMinim \u003d getGoalType() \u003d\u003d GoalType.MINIMIZE;\n     final double lo \u003d getMin();\n     final double mid \u003d getStartValue();\n     final double hi \u003d getMax();\n     final ConvergenceChecker\u003cUnivariateRealPointValuePair\u003e checker \u003d getConvergenceChecker();\n     double a;\n     double b;\n     if (lo \u003c hi) {\n         a \u003d lo;\n         b \u003d hi;\n     } else {\n         a \u003d hi;\n         b \u003d lo;\n     }\n     double x \u003d mid;\n     double v \u003d x;\n     double w \u003d x;\n     double d \u003d 0;\n     double e \u003d 0;\n     double fx \u003d computeObjectiveValue(x);\n     if (!isMinim) {\n         fx \u003d -fx;\n     }\n     double fv \u003d fx;\n     double fw \u003d fx;\n     UnivariateRealPointValuePair previous \u003d null;\n     UnivariateRealPointValuePair current \u003d new UnivariateRealPointValuePair(x, isMinim ? fx : -fx);\n     int iter \u003d 0;\n     while (true) {\n         final double m \u003d 0.5 * (a + b);\n         final double tol1 \u003d relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n         final double tol2 \u003d 2 * tol1;\n         final boolean stop \u003d FastMath.abs(x - m) \u003c\u003d tol2 - 0.5 * (b - a);\n         if (!stop) {\n             double p \u003d 0;\n             double q \u003d 0;\n             double r \u003d 0;\n             double u \u003d 0;\n             if (FastMath.abs(e) \u003e tol1) {\n                 r \u003d (x - w) * (fx - fv);\n                 q \u003d (x - v) * (fx - fw);\n                 p \u003d (x - v) * q - (x - w) * r;\n                 q \u003d 2 * (q - r);\n                 if (q \u003e 0) {\n                     p \u003d -p;\n                 } else {\n                     q \u003d -q;\n                 }\n                 r \u003d e;\n                 e \u003d d;\n                 if (p \u003e q * (a - x) \u0026\u0026 p \u003c q * (b - x) \u0026\u0026 FastMath.abs(p) \u003c FastMath.abs(0.5 * q * r)) {\n                     d \u003d p / q;\n                     u \u003d x + d;\n                     if (u - a \u003c tol2 || b - u \u003c tol2) {\n                         if (x \u003c\u003d m) {\n                             d \u003d tol1;\n                         } else {\n                             d \u003d -tol1;\n                         }\n                     }\n                 } else {\n                     if (x \u003c m) {\n                         e \u003d b - x;\n                     } else {\n                         e \u003d a - x;\n                     }\n                     d \u003d GOLDEN_SECTION * e;\n                 }\n             } else {\n                 if (x \u003c m) {\n                     e \u003d b - x;\n                 } else {\n                     e \u003d a - x;\n                 }\n                 d \u003d GOLDEN_SECTION * e;\n             }\n             if (FastMath.abs(d) \u003c tol1) {\n                 if (d \u003e\u003d 0) {\n                     u \u003d x + tol1;\n                 } else {\n                     u \u003d x - tol1;\n                 }\n             } else {\n                 u \u003d x + d;\n             }\n             double fu \u003d computeObjectiveValue(u);\n             if (!isMinim) {\n                 fu \u003d -fu;\n             }\n             if (fu \u003c\u003d fx) {\n                 if (u \u003c x) {\n                     b \u003d x;\n                 } else {\n                     a \u003d x;\n                 }\n                 v \u003d w;\n                 fv \u003d fw;\n                 w \u003d x;\n                 fw \u003d fx;\n                 x \u003d u;\n                 fx \u003d fu;\n             } else {\n                 if (u \u003c x) {\n                     a \u003d u;\n                 } else {\n                     b \u003d u;\n                 }\n                 if (fu \u003c\u003d fw || MathUtils.equals(w, x)) {\n                     v \u003d w;\n                     fv \u003d fw;\n                     w \u003d u;\n                     fw \u003d fu;\n                 } else if (fu \u003c\u003d fv || MathUtils.equals(v, x) || MathUtils.equals(v, w)) {\n                     v \u003d u;\n                     fv \u003d fu;\n                 }\n             }\n             previous \u003d current;\n             current \u003d new UnivariateRealPointValuePair(x, isMinim ? fx : -fx);\n             if (checker !\u003d null) {\n                 if (checker.converged(iter, previous, current)) {\n                     return current;\n                 }\n             }\n         } else {\n             return current;\n         }\n         ++iter;\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[FunctionEvaluationException]",
        "newValue": "[]"
      }
    },
    "16727ebdc33f38d0a37aee0e87700500cc272a8b": {
      "type": "Yannotationchange",
      "commitMessage": "Add missing @Override marker\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@1003351 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "9/30/10, 6:50 PM",
      "commitName": "16727ebdc33f38d0a37aee0e87700500cc272a8b",
      "commitAuthor": "Sebastian Bazley",
      "commitDateOld": "9/8/10, 5:51 AM",
      "commitNameOld": "9707f8dd5e57662832967082a1a49518cb033d1e",
      "commitAuthorOld": "Gilles Sadowski",
      "daysBetweenCommits": 22.54,
      "commitsBetweenForRepo": 34,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\nprotected UnivariateRealPointValuePair doOptimize() throws FunctionEvaluationException {\n    final boolean isMinim \u003d getGoalType() \u003d\u003d GoalType.MINIMIZE;\n    final double lo \u003d getMin();\n    final double mid \u003d getStartValue();\n    final double hi \u003d getMax();\n    final ConvergenceChecker\u003cUnivariateRealPointValuePair\u003e checker \u003d getConvergenceChecker();\n    double a;\n    double b;\n    if (lo \u003c hi) {\n        a \u003d lo;\n        b \u003d hi;\n    } else {\n        a \u003d hi;\n        b \u003d lo;\n    }\n    double x \u003d mid;\n    double v \u003d x;\n    double w \u003d x;\n    double d \u003d 0;\n    double e \u003d 0;\n    double fx \u003d computeObjectiveValue(x);\n    if (!isMinim) {\n        fx \u003d -fx;\n    }\n    double fv \u003d fx;\n    double fw \u003d fx;\n    UnivariateRealPointValuePair previous \u003d null;\n    UnivariateRealPointValuePair current \u003d new UnivariateRealPointValuePair(x, isMinim ? fx : -fx);\n    int iter \u003d 0;\n    while (true) {\n        final double m \u003d 0.5 * (a + b);\n        final double tol1 \u003d relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n        final double tol2 \u003d 2 * tol1;\n        final boolean stop \u003d FastMath.abs(x - m) \u003c\u003d tol2 - 0.5 * (b - a);\n        if (!stop) {\n            double p \u003d 0;\n            double q \u003d 0;\n            double r \u003d 0;\n            double u \u003d 0;\n            if (FastMath.abs(e) \u003e tol1) {\n                r \u003d (x - w) * (fx - fv);\n                q \u003d (x - v) * (fx - fw);\n                p \u003d (x - v) * q - (x - w) * r;\n                q \u003d 2 * (q - r);\n                if (q \u003e 0) {\n                    p \u003d -p;\n                } else {\n                    q \u003d -q;\n                }\n                r \u003d e;\n                e \u003d d;\n                if (p \u003e q * (a - x) \u0026\u0026 p \u003c q * (b - x) \u0026\u0026 FastMath.abs(p) \u003c FastMath.abs(0.5 * q * r)) {\n                    d \u003d p / q;\n                    u \u003d x + d;\n                    if (u - a \u003c tol2 || b - u \u003c tol2) {\n                        if (x \u003c\u003d m) {\n                            d \u003d tol1;\n                        } else {\n                            d \u003d -tol1;\n                        }\n                    }\n                } else {\n                    if (x \u003c m) {\n                        e \u003d b - x;\n                    } else {\n                        e \u003d a - x;\n                    }\n                    d \u003d GOLDEN_SECTION * e;\n                }\n            } else {\n                if (x \u003c m) {\n                    e \u003d b - x;\n                } else {\n                    e \u003d a - x;\n                }\n                d \u003d GOLDEN_SECTION * e;\n            }\n            if (FastMath.abs(d) \u003c tol1) {\n                if (d \u003e\u003d 0) {\n                    u \u003d x + tol1;\n                } else {\n                    u \u003d x - tol1;\n                }\n            } else {\n                u \u003d x + d;\n            }\n            double fu \u003d computeObjectiveValue(u);\n            if (!isMinim) {\n                fu \u003d -fu;\n            }\n            if (fu \u003c\u003d fx) {\n                if (u \u003c x) {\n                    b \u003d x;\n                } else {\n                    a \u003d x;\n                }\n                v \u003d w;\n                fv \u003d fw;\n                w \u003d x;\n                fw \u003d fx;\n                x \u003d u;\n                fx \u003d fu;\n            } else {\n                if (u \u003c x) {\n                    a \u003d u;\n                } else {\n                    b \u003d u;\n                }\n                if (fu \u003c\u003d fw || MathUtils.equals(w, x)) {\n                    v \u003d w;\n                    fv \u003d fw;\n                    w \u003d u;\n                    fw \u003d fu;\n                } else if (fu \u003c\u003d fv || MathUtils.equals(v, x) || MathUtils.equals(v, w)) {\n                    v \u003d u;\n                    fv \u003d fu;\n                }\n            }\n            previous \u003d current;\n            current \u003d new UnivariateRealPointValuePair(x, isMinim ? fx : -fx);\n            if (checker !\u003d null) {\n                if (checker.converged(iter, previous, current)) {\n                    return current;\n                }\n            }\n        } else {\n            return current;\n        }\n        ++iter;\n    }\n}",
      "path": "src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java",
      "functionStartLine": 89,
      "functionName": "doOptimize",
      "functionAnnotation": "@Override",
      "functionDoc": "@inheritDoc}\n",
      "diff": "@@ -1,131 +1,132 @@\n+@Override\n protected UnivariateRealPointValuePair doOptimize() throws FunctionEvaluationException {\n     final boolean isMinim \u003d getGoalType() \u003d\u003d GoalType.MINIMIZE;\n     final double lo \u003d getMin();\n     final double mid \u003d getStartValue();\n     final double hi \u003d getMax();\n     final ConvergenceChecker\u003cUnivariateRealPointValuePair\u003e checker \u003d getConvergenceChecker();\n     double a;\n     double b;\n     if (lo \u003c hi) {\n         a \u003d lo;\n         b \u003d hi;\n     } else {\n         a \u003d hi;\n         b \u003d lo;\n     }\n     double x \u003d mid;\n     double v \u003d x;\n     double w \u003d x;\n     double d \u003d 0;\n     double e \u003d 0;\n     double fx \u003d computeObjectiveValue(x);\n     if (!isMinim) {\n         fx \u003d -fx;\n     }\n     double fv \u003d fx;\n     double fw \u003d fx;\n     UnivariateRealPointValuePair previous \u003d null;\n     UnivariateRealPointValuePair current \u003d new UnivariateRealPointValuePair(x, isMinim ? fx : -fx);\n     int iter \u003d 0;\n     while (true) {\n         final double m \u003d 0.5 * (a + b);\n         final double tol1 \u003d relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n         final double tol2 \u003d 2 * tol1;\n         final boolean stop \u003d FastMath.abs(x - m) \u003c\u003d tol2 - 0.5 * (b - a);\n         if (!stop) {\n             double p \u003d 0;\n             double q \u003d 0;\n             double r \u003d 0;\n             double u \u003d 0;\n             if (FastMath.abs(e) \u003e tol1) {\n                 r \u003d (x - w) * (fx - fv);\n                 q \u003d (x - v) * (fx - fw);\n                 p \u003d (x - v) * q - (x - w) * r;\n                 q \u003d 2 * (q - r);\n                 if (q \u003e 0) {\n                     p \u003d -p;\n                 } else {\n                     q \u003d -q;\n                 }\n                 r \u003d e;\n                 e \u003d d;\n                 if (p \u003e q * (a - x) \u0026\u0026 p \u003c q * (b - x) \u0026\u0026 FastMath.abs(p) \u003c FastMath.abs(0.5 * q * r)) {\n                     d \u003d p / q;\n                     u \u003d x + d;\n                     if (u - a \u003c tol2 || b - u \u003c tol2) {\n                         if (x \u003c\u003d m) {\n                             d \u003d tol1;\n                         } else {\n                             d \u003d -tol1;\n                         }\n                     }\n                 } else {\n                     if (x \u003c m) {\n                         e \u003d b - x;\n                     } else {\n                         e \u003d a - x;\n                     }\n                     d \u003d GOLDEN_SECTION * e;\n                 }\n             } else {\n                 if (x \u003c m) {\n                     e \u003d b - x;\n                 } else {\n                     e \u003d a - x;\n                 }\n                 d \u003d GOLDEN_SECTION * e;\n             }\n             if (FastMath.abs(d) \u003c tol1) {\n                 if (d \u003e\u003d 0) {\n                     u \u003d x + tol1;\n                 } else {\n                     u \u003d x - tol1;\n                 }\n             } else {\n                 u \u003d x + d;\n             }\n             double fu \u003d computeObjectiveValue(u);\n             if (!isMinim) {\n                 fu \u003d -fu;\n             }\n             if (fu \u003c\u003d fx) {\n                 if (u \u003c x) {\n                     b \u003d x;\n                 } else {\n                     a \u003d x;\n                 }\n                 v \u003d w;\n                 fv \u003d fw;\n                 w \u003d x;\n                 fw \u003d fx;\n                 x \u003d u;\n                 fx \u003d fu;\n             } else {\n                 if (u \u003c x) {\n                     a \u003d u;\n                 } else {\n                     b \u003d u;\n                 }\n                 if (fu \u003c\u003d fw || MathUtils.equals(w, x)) {\n                     v \u003d w;\n                     fv \u003d fw;\n                     w \u003d u;\n                     fw \u003d fu;\n                 } else if (fu \u003c\u003d fv || MathUtils.equals(v, x) || MathUtils.equals(v, w)) {\n                     v \u003d u;\n                     fv \u003d fu;\n                 }\n             }\n             previous \u003d current;\n             current \u003d new UnivariateRealPointValuePair(x, isMinim ? fx : -fx);\n             if (checker !\u003d null) {\n                 if (checker.converged(iter, previous, current)) {\n                     return current;\n                 }\n             }\n         } else {\n             return current;\n         }\n         ++iter;\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "",
        "newValue": "@Override"
      }
    },
    "9707f8dd5e57662832967082a1a49518cb033d1e": {
      "type": "Ybodychange",
      "commitMessage": "Removed strict equality comparison.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@995035 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "9/8/10, 5:51 AM",
      "commitName": "9707f8dd5e57662832967082a1a49518cb033d1e",
      "commitAuthor": "Gilles Sadowski",
      "commitDateOld": "9/8/10, 4:22 AM",
      "commitNameOld": "d4a0b9eb3d09bb697afe8a4c2b3340a46b97a53b",
      "commitAuthorOld": "Gilles Sadowski",
      "daysBetweenCommits": 0.06,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "protected UnivariateRealPointValuePair doOptimize() throws FunctionEvaluationException {\n    final boolean isMinim \u003d getGoalType() \u003d\u003d GoalType.MINIMIZE;\n    final double lo \u003d getMin();\n    final double mid \u003d getStartValue();\n    final double hi \u003d getMax();\n    final ConvergenceChecker\u003cUnivariateRealPointValuePair\u003e checker \u003d getConvergenceChecker();\n    double a;\n    double b;\n    if (lo \u003c hi) {\n        a \u003d lo;\n        b \u003d hi;\n    } else {\n        a \u003d hi;\n        b \u003d lo;\n    }\n    double x \u003d mid;\n    double v \u003d x;\n    double w \u003d x;\n    double d \u003d 0;\n    double e \u003d 0;\n    double fx \u003d computeObjectiveValue(x);\n    if (!isMinim) {\n        fx \u003d -fx;\n    }\n    double fv \u003d fx;\n    double fw \u003d fx;\n    UnivariateRealPointValuePair previous \u003d null;\n    UnivariateRealPointValuePair current \u003d new UnivariateRealPointValuePair(x, isMinim ? fx : -fx);\n    int iter \u003d 0;\n    while (true) {\n        final double m \u003d 0.5 * (a + b);\n        final double tol1 \u003d relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n        final double tol2 \u003d 2 * tol1;\n        final boolean stop \u003d FastMath.abs(x - m) \u003c\u003d tol2 - 0.5 * (b - a);\n        if (!stop) {\n            double p \u003d 0;\n            double q \u003d 0;\n            double r \u003d 0;\n            double u \u003d 0;\n            if (FastMath.abs(e) \u003e tol1) {\n                r \u003d (x - w) * (fx - fv);\n                q \u003d (x - v) * (fx - fw);\n                p \u003d (x - v) * q - (x - w) * r;\n                q \u003d 2 * (q - r);\n                if (q \u003e 0) {\n                    p \u003d -p;\n                } else {\n                    q \u003d -q;\n                }\n                r \u003d e;\n                e \u003d d;\n                if (p \u003e q * (a - x) \u0026\u0026 p \u003c q * (b - x) \u0026\u0026 FastMath.abs(p) \u003c FastMath.abs(0.5 * q * r)) {\n                    d \u003d p / q;\n                    u \u003d x + d;\n                    if (u - a \u003c tol2 || b - u \u003c tol2) {\n                        if (x \u003c\u003d m) {\n                            d \u003d tol1;\n                        } else {\n                            d \u003d -tol1;\n                        }\n                    }\n                } else {\n                    if (x \u003c m) {\n                        e \u003d b - x;\n                    } else {\n                        e \u003d a - x;\n                    }\n                    d \u003d GOLDEN_SECTION * e;\n                }\n            } else {\n                if (x \u003c m) {\n                    e \u003d b - x;\n                } else {\n                    e \u003d a - x;\n                }\n                d \u003d GOLDEN_SECTION * e;\n            }\n            if (FastMath.abs(d) \u003c tol1) {\n                if (d \u003e\u003d 0) {\n                    u \u003d x + tol1;\n                } else {\n                    u \u003d x - tol1;\n                }\n            } else {\n                u \u003d x + d;\n            }\n            double fu \u003d computeObjectiveValue(u);\n            if (!isMinim) {\n                fu \u003d -fu;\n            }\n            if (fu \u003c\u003d fx) {\n                if (u \u003c x) {\n                    b \u003d x;\n                } else {\n                    a \u003d x;\n                }\n                v \u003d w;\n                fv \u003d fw;\n                w \u003d x;\n                fw \u003d fx;\n                x \u003d u;\n                fx \u003d fu;\n            } else {\n                if (u \u003c x) {\n                    a \u003d u;\n                } else {\n                    b \u003d u;\n                }\n                if (fu \u003c\u003d fw || MathUtils.equals(w, x)) {\n                    v \u003d w;\n                    fv \u003d fw;\n                    w \u003d u;\n                    fw \u003d fu;\n                } else if (fu \u003c\u003d fv || MathUtils.equals(v, x) || MathUtils.equals(v, w)) {\n                    v \u003d u;\n                    fv \u003d fu;\n                }\n            }\n            previous \u003d current;\n            current \u003d new UnivariateRealPointValuePair(x, isMinim ? fx : -fx);\n            if (checker !\u003d null) {\n                if (checker.converged(iter, previous, current)) {\n                    return current;\n                }\n            }\n        } else {\n            return current;\n        }\n        ++iter;\n    }\n}",
      "path": "src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java",
      "functionStartLine": 88,
      "functionName": "doOptimize",
      "functionAnnotation": "",
      "functionDoc": "@inheritDoc}\n",
      "diff": "@@ -1,131 +1,131 @@\n protected UnivariateRealPointValuePair doOptimize() throws FunctionEvaluationException {\n     final boolean isMinim \u003d getGoalType() \u003d\u003d GoalType.MINIMIZE;\n     final double lo \u003d getMin();\n     final double mid \u003d getStartValue();\n     final double hi \u003d getMax();\n     final ConvergenceChecker\u003cUnivariateRealPointValuePair\u003e checker \u003d getConvergenceChecker();\n     double a;\n     double b;\n     if (lo \u003c hi) {\n         a \u003d lo;\n         b \u003d hi;\n     } else {\n         a \u003d hi;\n         b \u003d lo;\n     }\n     double x \u003d mid;\n     double v \u003d x;\n     double w \u003d x;\n     double d \u003d 0;\n     double e \u003d 0;\n     double fx \u003d computeObjectiveValue(x);\n     if (!isMinim) {\n         fx \u003d -fx;\n     }\n     double fv \u003d fx;\n     double fw \u003d fx;\n     UnivariateRealPointValuePair previous \u003d null;\n     UnivariateRealPointValuePair current \u003d new UnivariateRealPointValuePair(x, isMinim ? fx : -fx);\n     int iter \u003d 0;\n     while (true) {\n         final double m \u003d 0.5 * (a + b);\n         final double tol1 \u003d relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n         final double tol2 \u003d 2 * tol1;\n         final boolean stop \u003d FastMath.abs(x - m) \u003c\u003d tol2 - 0.5 * (b - a);\n         if (!stop) {\n             double p \u003d 0;\n             double q \u003d 0;\n             double r \u003d 0;\n             double u \u003d 0;\n             if (FastMath.abs(e) \u003e tol1) {\n                 r \u003d (x - w) * (fx - fv);\n                 q \u003d (x - v) * (fx - fw);\n                 p \u003d (x - v) * q - (x - w) * r;\n                 q \u003d 2 * (q - r);\n                 if (q \u003e 0) {\n                     p \u003d -p;\n                 } else {\n                     q \u003d -q;\n                 }\n                 r \u003d e;\n                 e \u003d d;\n                 if (p \u003e q * (a - x) \u0026\u0026 p \u003c q * (b - x) \u0026\u0026 FastMath.abs(p) \u003c FastMath.abs(0.5 * q * r)) {\n                     d \u003d p / q;\n                     u \u003d x + d;\n                     if (u - a \u003c tol2 || b - u \u003c tol2) {\n                         if (x \u003c\u003d m) {\n                             d \u003d tol1;\n                         } else {\n                             d \u003d -tol1;\n                         }\n                     }\n                 } else {\n                     if (x \u003c m) {\n                         e \u003d b - x;\n                     } else {\n                         e \u003d a - x;\n                     }\n                     d \u003d GOLDEN_SECTION * e;\n                 }\n             } else {\n                 if (x \u003c m) {\n                     e \u003d b - x;\n                 } else {\n                     e \u003d a - x;\n                 }\n                 d \u003d GOLDEN_SECTION * e;\n             }\n             if (FastMath.abs(d) \u003c tol1) {\n                 if (d \u003e\u003d 0) {\n                     u \u003d x + tol1;\n                 } else {\n                     u \u003d x - tol1;\n                 }\n             } else {\n                 u \u003d x + d;\n             }\n             double fu \u003d computeObjectiveValue(u);\n             if (!isMinim) {\n                 fu \u003d -fu;\n             }\n             if (fu \u003c\u003d fx) {\n                 if (u \u003c x) {\n                     b \u003d x;\n                 } else {\n                     a \u003d x;\n                 }\n                 v \u003d w;\n                 fv \u003d fw;\n                 w \u003d x;\n                 fw \u003d fx;\n                 x \u003d u;\n                 fx \u003d fu;\n             } else {\n                 if (u \u003c x) {\n                     a \u003d u;\n                 } else {\n                     b \u003d u;\n                 }\n-                if (fu \u003c\u003d fw || w \u003d\u003d x) {\n+                if (fu \u003c\u003d fw || MathUtils.equals(w, x)) {\n                     v \u003d w;\n                     fv \u003d fw;\n                     w \u003d u;\n                     fw \u003d fu;\n-                } else if (fu \u003c\u003d fv || v \u003d\u003d x || v \u003d\u003d w) {\n+                } else if (fu \u003c\u003d fv || MathUtils.equals(v, x) || MathUtils.equals(v, w)) {\n                     v \u003d u;\n                     fv \u003d fu;\n                 }\n             }\n             previous \u003d current;\n             current \u003d new UnivariateRealPointValuePair(x, isMinim ? fx : -fx);\n             if (checker !\u003d null) {\n                 if (checker.converged(iter, previous, current)) {\n                     return current;\n                 }\n             }\n         } else {\n             return current;\n         }\n         ++iter;\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d4a0b9eb3d09bb697afe8a4c2b3340a46b97a53b": {
      "type": "Ybodychange",
      "commitMessage": "Fixed \"checkstyle\" errors.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@994988 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "9/8/10, 4:22 AM",
      "commitName": "d4a0b9eb3d09bb697afe8a4c2b3340a46b97a53b",
      "commitAuthor": "Gilles Sadowski",
      "commitDateOld": "9/6/10, 2:06 AM",
      "commitNameOld": "43ed5002e1483019207c5130459ef469c24dab31",
      "commitAuthorOld": "Gilles Sadowski",
      "daysBetweenCommits": 2.09,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "protected UnivariateRealPointValuePair doOptimize() throws FunctionEvaluationException {\n    final boolean isMinim \u003d getGoalType() \u003d\u003d GoalType.MINIMIZE;\n    final double lo \u003d getMin();\n    final double mid \u003d getStartValue();\n    final double hi \u003d getMax();\n    final ConvergenceChecker\u003cUnivariateRealPointValuePair\u003e checker \u003d getConvergenceChecker();\n    double a;\n    double b;\n    if (lo \u003c hi) {\n        a \u003d lo;\n        b \u003d hi;\n    } else {\n        a \u003d hi;\n        b \u003d lo;\n    }\n    double x \u003d mid;\n    double v \u003d x;\n    double w \u003d x;\n    double d \u003d 0;\n    double e \u003d 0;\n    double fx \u003d computeObjectiveValue(x);\n    if (!isMinim) {\n        fx \u003d -fx;\n    }\n    double fv \u003d fx;\n    double fw \u003d fx;\n    UnivariateRealPointValuePair previous \u003d null;\n    UnivariateRealPointValuePair current \u003d new UnivariateRealPointValuePair(x, isMinim ? fx : -fx);\n    int iter \u003d 0;\n    while (true) {\n        final double m \u003d 0.5 * (a + b);\n        final double tol1 \u003d relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n        final double tol2 \u003d 2 * tol1;\n        final boolean stop \u003d FastMath.abs(x - m) \u003c\u003d tol2 - 0.5 * (b - a);\n        if (!stop) {\n            double p \u003d 0;\n            double q \u003d 0;\n            double r \u003d 0;\n            double u \u003d 0;\n            if (FastMath.abs(e) \u003e tol1) {\n                r \u003d (x - w) * (fx - fv);\n                q \u003d (x - v) * (fx - fw);\n                p \u003d (x - v) * q - (x - w) * r;\n                q \u003d 2 * (q - r);\n                if (q \u003e 0) {\n                    p \u003d -p;\n                } else {\n                    q \u003d -q;\n                }\n                r \u003d e;\n                e \u003d d;\n                if (p \u003e q * (a - x) \u0026\u0026 p \u003c q * (b - x) \u0026\u0026 FastMath.abs(p) \u003c FastMath.abs(0.5 * q * r)) {\n                    d \u003d p / q;\n                    u \u003d x + d;\n                    if (u - a \u003c tol2 || b - u \u003c tol2) {\n                        if (x \u003c\u003d m) {\n                            d \u003d tol1;\n                        } else {\n                            d \u003d -tol1;\n                        }\n                    }\n                } else {\n                    if (x \u003c m) {\n                        e \u003d b - x;\n                    } else {\n                        e \u003d a - x;\n                    }\n                    d \u003d GOLDEN_SECTION * e;\n                }\n            } else {\n                if (x \u003c m) {\n                    e \u003d b - x;\n                } else {\n                    e \u003d a - x;\n                }\n                d \u003d GOLDEN_SECTION * e;\n            }\n            if (FastMath.abs(d) \u003c tol1) {\n                if (d \u003e\u003d 0) {\n                    u \u003d x + tol1;\n                } else {\n                    u \u003d x - tol1;\n                }\n            } else {\n                u \u003d x + d;\n            }\n            double fu \u003d computeObjectiveValue(u);\n            if (!isMinim) {\n                fu \u003d -fu;\n            }\n            if (fu \u003c\u003d fx) {\n                if (u \u003c x) {\n                    b \u003d x;\n                } else {\n                    a \u003d x;\n                }\n                v \u003d w;\n                fv \u003d fw;\n                w \u003d x;\n                fw \u003d fx;\n                x \u003d u;\n                fx \u003d fu;\n            } else {\n                if (u \u003c x) {\n                    a \u003d u;\n                } else {\n                    b \u003d u;\n                }\n                if (fu \u003c\u003d fw || w \u003d\u003d x) {\n                    v \u003d w;\n                    fv \u003d fw;\n                    w \u003d u;\n                    fw \u003d fu;\n                } else if (fu \u003c\u003d fv || v \u003d\u003d x || v \u003d\u003d w) {\n                    v \u003d u;\n                    fv \u003d fu;\n                }\n            }\n            previous \u003d current;\n            current \u003d new UnivariateRealPointValuePair(x, isMinim ? fx : -fx);\n            if (checker !\u003d null) {\n                if (checker.converged(iter, previous, current)) {\n                    return current;\n                }\n            }\n        } else {\n            return current;\n        }\n        ++iter;\n    }\n}",
      "path": "src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java",
      "functionStartLine": 87,
      "functionName": "doOptimize",
      "functionAnnotation": "",
      "functionDoc": "@inheritDoc}\n",
      "diff": "@@ -1,131 +1,131 @@\n protected UnivariateRealPointValuePair doOptimize() throws FunctionEvaluationException {\n-    final boolean isMinim \u003d (getGoalType() \u003d\u003d GoalType.MINIMIZE);\n+    final boolean isMinim \u003d getGoalType() \u003d\u003d GoalType.MINIMIZE;\n     final double lo \u003d getMin();\n     final double mid \u003d getStartValue();\n     final double hi \u003d getMax();\n     final ConvergenceChecker\u003cUnivariateRealPointValuePair\u003e checker \u003d getConvergenceChecker();\n     double a;\n     double b;\n     if (lo \u003c hi) {\n         a \u003d lo;\n         b \u003d hi;\n     } else {\n         a \u003d hi;\n         b \u003d lo;\n     }\n     double x \u003d mid;\n     double v \u003d x;\n     double w \u003d x;\n     double d \u003d 0;\n     double e \u003d 0;\n     double fx \u003d computeObjectiveValue(x);\n     if (!isMinim) {\n         fx \u003d -fx;\n     }\n     double fv \u003d fx;\n     double fw \u003d fx;\n     UnivariateRealPointValuePair previous \u003d null;\n-    UnivariateRealPointValuePair current \u003d new UnivariateRealPointValuePair(x, (isMinim ? fx : -fx));\n+    UnivariateRealPointValuePair current \u003d new UnivariateRealPointValuePair(x, isMinim ? fx : -fx);\n     int iter \u003d 0;\n     while (true) {\n         final double m \u003d 0.5 * (a + b);\n         final double tol1 \u003d relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n         final double tol2 \u003d 2 * tol1;\n         final boolean stop \u003d FastMath.abs(x - m) \u003c\u003d tol2 - 0.5 * (b - a);\n         if (!stop) {\n             double p \u003d 0;\n             double q \u003d 0;\n             double r \u003d 0;\n             double u \u003d 0;\n             if (FastMath.abs(e) \u003e tol1) {\n                 r \u003d (x - w) * (fx - fv);\n                 q \u003d (x - v) * (fx - fw);\n                 p \u003d (x - v) * q - (x - w) * r;\n                 q \u003d 2 * (q - r);\n                 if (q \u003e 0) {\n                     p \u003d -p;\n                 } else {\n                     q \u003d -q;\n                 }\n                 r \u003d e;\n                 e \u003d d;\n                 if (p \u003e q * (a - x) \u0026\u0026 p \u003c q * (b - x) \u0026\u0026 FastMath.abs(p) \u003c FastMath.abs(0.5 * q * r)) {\n                     d \u003d p / q;\n                     u \u003d x + d;\n                     if (u - a \u003c tol2 || b - u \u003c tol2) {\n                         if (x \u003c\u003d m) {\n                             d \u003d tol1;\n                         } else {\n                             d \u003d -tol1;\n                         }\n                     }\n                 } else {\n                     if (x \u003c m) {\n                         e \u003d b - x;\n                     } else {\n                         e \u003d a - x;\n                     }\n                     d \u003d GOLDEN_SECTION * e;\n                 }\n             } else {\n                 if (x \u003c m) {\n                     e \u003d b - x;\n                 } else {\n                     e \u003d a - x;\n                 }\n                 d \u003d GOLDEN_SECTION * e;\n             }\n             if (FastMath.abs(d) \u003c tol1) {\n                 if (d \u003e\u003d 0) {\n                     u \u003d x + tol1;\n                 } else {\n                     u \u003d x - tol1;\n                 }\n             } else {\n                 u \u003d x + d;\n             }\n             double fu \u003d computeObjectiveValue(u);\n             if (!isMinim) {\n                 fu \u003d -fu;\n             }\n             if (fu \u003c\u003d fx) {\n                 if (u \u003c x) {\n                     b \u003d x;\n                 } else {\n                     a \u003d x;\n                 }\n                 v \u003d w;\n                 fv \u003d fw;\n                 w \u003d x;\n                 fw \u003d fx;\n                 x \u003d u;\n                 fx \u003d fu;\n             } else {\n                 if (u \u003c x) {\n                     a \u003d u;\n                 } else {\n                     b \u003d u;\n                 }\n                 if (fu \u003c\u003d fw || w \u003d\u003d x) {\n                     v \u003d w;\n                     fv \u003d fw;\n                     w \u003d u;\n                     fw \u003d fu;\n                 } else if (fu \u003c\u003d fv || v \u003d\u003d x || v \u003d\u003d w) {\n                     v \u003d u;\n                     fv \u003d fu;\n                 }\n             }\n             previous \u003d current;\n-            current \u003d new UnivariateRealPointValuePair(x, (isMinim ? fx : -fx));\n+            current \u003d new UnivariateRealPointValuePair(x, isMinim ? fx : -fx);\n             if (checker !\u003d null) {\n                 if (checker.converged(iter, previous, current)) {\n                     return current;\n                 }\n             }\n         } else {\n             return current;\n         }\n         ++iter;\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "43ed5002e1483019207c5130459ef469c24dab31": {
      "type": "Ybodychange",
      "commitMessage": "MATH-413 (points 1, 2 and 10)\nReverted to the original version of the convergence checker (using only the\nprevious and current best points).\n\"LevenberMarquardtOptimizer\": Removed setters (control parameters must be\nset at construction). Added a contructor.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@992976 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "9/6/10, 2:06 AM",
      "commitName": "43ed5002e1483019207c5130459ef469c24dab31",
      "commitAuthor": "Gilles Sadowski",
      "commitDateOld": "8/30/10, 6:06 AM",
      "commitNameOld": "9102bea5d82c6f97bf3cfb1d8525c13e58a9d418",
      "commitAuthorOld": "Gilles Sadowski",
      "daysBetweenCommits": 6.83,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "actualSource": "protected UnivariateRealPointValuePair doOptimize() throws FunctionEvaluationException {\n    final boolean isMinim \u003d (getGoalType() \u003d\u003d GoalType.MINIMIZE);\n    final double lo \u003d getMin();\n    final double mid \u003d getStartValue();\n    final double hi \u003d getMax();\n    final ConvergenceChecker\u003cUnivariateRealPointValuePair\u003e checker \u003d getConvergenceChecker();\n    double a;\n    double b;\n    if (lo \u003c hi) {\n        a \u003d lo;\n        b \u003d hi;\n    } else {\n        a \u003d hi;\n        b \u003d lo;\n    }\n    double x \u003d mid;\n    double v \u003d x;\n    double w \u003d x;\n    double d \u003d 0;\n    double e \u003d 0;\n    double fx \u003d computeObjectiveValue(x);\n    if (!isMinim) {\n        fx \u003d -fx;\n    }\n    double fv \u003d fx;\n    double fw \u003d fx;\n    UnivariateRealPointValuePair previous \u003d null;\n    UnivariateRealPointValuePair current \u003d new UnivariateRealPointValuePair(x, (isMinim ? fx : -fx));\n    int iter \u003d 0;\n    while (true) {\n        final double m \u003d 0.5 * (a + b);\n        final double tol1 \u003d relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n        final double tol2 \u003d 2 * tol1;\n        final boolean stop \u003d FastMath.abs(x - m) \u003c\u003d tol2 - 0.5 * (b - a);\n        if (!stop) {\n            double p \u003d 0;\n            double q \u003d 0;\n            double r \u003d 0;\n            double u \u003d 0;\n            if (FastMath.abs(e) \u003e tol1) {\n                r \u003d (x - w) * (fx - fv);\n                q \u003d (x - v) * (fx - fw);\n                p \u003d (x - v) * q - (x - w) * r;\n                q \u003d 2 * (q - r);\n                if (q \u003e 0) {\n                    p \u003d -p;\n                } else {\n                    q \u003d -q;\n                }\n                r \u003d e;\n                e \u003d d;\n                if (p \u003e q * (a - x) \u0026\u0026 p \u003c q * (b - x) \u0026\u0026 FastMath.abs(p) \u003c FastMath.abs(0.5 * q * r)) {\n                    d \u003d p / q;\n                    u \u003d x + d;\n                    if (u - a \u003c tol2 || b - u \u003c tol2) {\n                        if (x \u003c\u003d m) {\n                            d \u003d tol1;\n                        } else {\n                            d \u003d -tol1;\n                        }\n                    }\n                } else {\n                    if (x \u003c m) {\n                        e \u003d b - x;\n                    } else {\n                        e \u003d a - x;\n                    }\n                    d \u003d GOLDEN_SECTION * e;\n                }\n            } else {\n                if (x \u003c m) {\n                    e \u003d b - x;\n                } else {\n                    e \u003d a - x;\n                }\n                d \u003d GOLDEN_SECTION * e;\n            }\n            if (FastMath.abs(d) \u003c tol1) {\n                if (d \u003e\u003d 0) {\n                    u \u003d x + tol1;\n                } else {\n                    u \u003d x - tol1;\n                }\n            } else {\n                u \u003d x + d;\n            }\n            double fu \u003d computeObjectiveValue(u);\n            if (!isMinim) {\n                fu \u003d -fu;\n            }\n            if (fu \u003c\u003d fx) {\n                if (u \u003c x) {\n                    b \u003d x;\n                } else {\n                    a \u003d x;\n                }\n                v \u003d w;\n                fv \u003d fw;\n                w \u003d x;\n                fw \u003d fx;\n                x \u003d u;\n                fx \u003d fu;\n            } else {\n                if (u \u003c x) {\n                    a \u003d u;\n                } else {\n                    b \u003d u;\n                }\n                if (fu \u003c\u003d fw || w \u003d\u003d x) {\n                    v \u003d w;\n                    fv \u003d fw;\n                    w \u003d u;\n                    fw \u003d fu;\n                } else if (fu \u003c\u003d fv || v \u003d\u003d x || v \u003d\u003d w) {\n                    v \u003d u;\n                    fv \u003d fu;\n                }\n            }\n            previous \u003d current;\n            current \u003d new UnivariateRealPointValuePair(x, (isMinim ? fx : -fx));\n            if (checker !\u003d null) {\n                if (checker.converged(iter, previous, current)) {\n                    return current;\n                }\n            }\n        } else {\n            return current;\n        }\n        ++iter;\n    }\n}",
      "path": "src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java",
      "functionStartLine": 90,
      "functionName": "doOptimize",
      "functionAnnotation": "",
      "functionDoc": "@inheritDoc}\n",
      "diff": "@@ -1,123 +1,131 @@\n protected UnivariateRealPointValuePair doOptimize() throws FunctionEvaluationException {\n     final boolean isMinim \u003d (getGoalType() \u003d\u003d GoalType.MINIMIZE);\n     final double lo \u003d getMin();\n     final double mid \u003d getStartValue();\n     final double hi \u003d getMax();\n     final ConvergenceChecker\u003cUnivariateRealPointValuePair\u003e checker \u003d getConvergenceChecker();\n-    final double eps \u003d checker.getRelativeThreshold();\n-    final double t \u003d checker.getAbsoluteThreshold();\n     double a;\n     double b;\n     if (lo \u003c hi) {\n         a \u003d lo;\n         b \u003d hi;\n     } else {\n         a \u003d hi;\n         b \u003d lo;\n     }\n     double x \u003d mid;\n     double v \u003d x;\n     double w \u003d x;\n     double d \u003d 0;\n     double e \u003d 0;\n     double fx \u003d computeObjectiveValue(x);\n     if (!isMinim) {\n         fx \u003d -fx;\n     }\n     double fv \u003d fx;\n     double fw \u003d fx;\n+    UnivariateRealPointValuePair previous \u003d null;\n+    UnivariateRealPointValuePair current \u003d new UnivariateRealPointValuePair(x, (isMinim ? fx : -fx));\n     int iter \u003d 0;\n     while (true) {\n-        double m \u003d 0.5 * (a + b);\n-        final double tol1 \u003d eps * FastMath.abs(x) + t;\n+        final double m \u003d 0.5 * (a + b);\n+        final double tol1 \u003d relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n         final double tol2 \u003d 2 * tol1;\n-        if (!getConvergenceChecker().converged(iter, new UnivariateRealPointValuePair(a, Double.NaN), new UnivariateRealPointValuePair(x, Double.NaN), new UnivariateRealPointValuePair(b, Double.NaN))) {\n+        final boolean stop \u003d FastMath.abs(x - m) \u003c\u003d tol2 - 0.5 * (b - a);\n+        if (!stop) {\n             double p \u003d 0;\n             double q \u003d 0;\n             double r \u003d 0;\n             double u \u003d 0;\n             if (FastMath.abs(e) \u003e tol1) {\n                 r \u003d (x - w) * (fx - fv);\n                 q \u003d (x - v) * (fx - fw);\n                 p \u003d (x - v) * q - (x - w) * r;\n                 q \u003d 2 * (q - r);\n                 if (q \u003e 0) {\n                     p \u003d -p;\n                 } else {\n                     q \u003d -q;\n                 }\n                 r \u003d e;\n                 e \u003d d;\n                 if (p \u003e q * (a - x) \u0026\u0026 p \u003c q * (b - x) \u0026\u0026 FastMath.abs(p) \u003c FastMath.abs(0.5 * q * r)) {\n                     d \u003d p / q;\n                     u \u003d x + d;\n                     if (u - a \u003c tol2 || b - u \u003c tol2) {\n                         if (x \u003c\u003d m) {\n                             d \u003d tol1;\n                         } else {\n                             d \u003d -tol1;\n                         }\n                     }\n                 } else {\n                     if (x \u003c m) {\n                         e \u003d b - x;\n                     } else {\n                         e \u003d a - x;\n                     }\n                     d \u003d GOLDEN_SECTION * e;\n                 }\n             } else {\n                 if (x \u003c m) {\n                     e \u003d b - x;\n                 } else {\n                     e \u003d a - x;\n                 }\n                 d \u003d GOLDEN_SECTION * e;\n             }\n             if (FastMath.abs(d) \u003c tol1) {\n                 if (d \u003e\u003d 0) {\n                     u \u003d x + tol1;\n                 } else {\n                     u \u003d x - tol1;\n                 }\n             } else {\n                 u \u003d x + d;\n             }\n             double fu \u003d computeObjectiveValue(u);\n             if (!isMinim) {\n                 fu \u003d -fu;\n             }\n             if (fu \u003c\u003d fx) {\n                 if (u \u003c x) {\n                     b \u003d x;\n                 } else {\n                     a \u003d x;\n                 }\n                 v \u003d w;\n                 fv \u003d fw;\n                 w \u003d x;\n                 fw \u003d fx;\n                 x \u003d u;\n                 fx \u003d fu;\n             } else {\n                 if (u \u003c x) {\n                     a \u003d u;\n                 } else {\n                     b \u003d u;\n                 }\n                 if (fu \u003c\u003d fw || w \u003d\u003d x) {\n                     v \u003d w;\n                     fv \u003d fw;\n                     w \u003d u;\n                     fw \u003d fu;\n                 } else if (fu \u003c\u003d fv || v \u003d\u003d x || v \u003d\u003d w) {\n                     v \u003d u;\n                     fv \u003d fu;\n                 }\n             }\n+            previous \u003d current;\n+            current \u003d new UnivariateRealPointValuePair(x, (isMinim ? fx : -fx));\n+            if (checker !\u003d null) {\n+                if (checker.converged(iter, previous, current)) {\n+                    return current;\n+                }\n+            }\n         } else {\n-            return new UnivariateRealPointValuePair(x, (isMinim ? fx : -fx));\n+            return current;\n         }\n         ++iter;\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9102bea5d82c6f97bf3cfb1d8525c13e58a9d418": {
      "type": "Ymultichange(Yreturntypechange,Yexceptionschange,Ybodychange)",
      "commitMessage": "MATH-394, MATH-397, MATH-404\nOverhaul of the \"optimization\" package.\nRemoved lots of duplicate code.\nRemoved methods referring to the concept of \"iteration\".\nRemoved interface methods to access the number of evaluations of the\ngradient and Jacobian.\nRemoved all references to \"OptimizationException\" (replaced by\n\"ConvergenceException\").\nJavadoc comments updated.\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@990792 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "8/30/10, 6:06 AM",
      "commitName": "9102bea5d82c6f97bf3cfb1d8525c13e58a9d418",
      "commitAuthor": "Gilles Sadowski",
      "subchanges": [
        {
          "type": "Yreturntypechange",
          "commitMessage": "MATH-394, MATH-397, MATH-404\nOverhaul of the \"optimization\" package.\nRemoved lots of duplicate code.\nRemoved methods referring to the concept of \"iteration\".\nRemoved interface methods to access the number of evaluations of the\ngradient and Jacobian.\nRemoved all references to \"OptimizationException\" (replaced by\n\"ConvergenceException\").\nJavadoc comments updated.\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@990792 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "8/30/10, 6:06 AM",
          "commitName": "9102bea5d82c6f97bf3cfb1d8525c13e58a9d418",
          "commitAuthor": "Gilles Sadowski",
          "commitDateOld": "8/29/10, 3:04 PM",
          "commitNameOld": "80b1e90b42a34856b61cec628fcea6633d1000cd",
          "commitAuthorOld": "Luc Maisonobe",
          "daysBetweenCommits": 0.63,
          "commitsBetweenForRepo": 3,
          "commitsBetweenForFile": 1,
          "actualSource": "protected UnivariateRealPointValuePair doOptimize() throws FunctionEvaluationException {\n    final boolean isMinim \u003d (getGoalType() \u003d\u003d GoalType.MINIMIZE);\n    final double lo \u003d getMin();\n    final double mid \u003d getStartValue();\n    final double hi \u003d getMax();\n    final ConvergenceChecker\u003cUnivariateRealPointValuePair\u003e checker \u003d getConvergenceChecker();\n    final double eps \u003d checker.getRelativeThreshold();\n    final double t \u003d checker.getAbsoluteThreshold();\n    double a;\n    double b;\n    if (lo \u003c hi) {\n        a \u003d lo;\n        b \u003d hi;\n    } else {\n        a \u003d hi;\n        b \u003d lo;\n    }\n    double x \u003d mid;\n    double v \u003d x;\n    double w \u003d x;\n    double d \u003d 0;\n    double e \u003d 0;\n    double fx \u003d computeObjectiveValue(x);\n    if (!isMinim) {\n        fx \u003d -fx;\n    }\n    double fv \u003d fx;\n    double fw \u003d fx;\n    int iter \u003d 0;\n    while (true) {\n        double m \u003d 0.5 * (a + b);\n        final double tol1 \u003d eps * FastMath.abs(x) + t;\n        final double tol2 \u003d 2 * tol1;\n        if (!getConvergenceChecker().converged(iter, new UnivariateRealPointValuePair(a, Double.NaN), new UnivariateRealPointValuePair(x, Double.NaN), new UnivariateRealPointValuePair(b, Double.NaN))) {\n            double p \u003d 0;\n            double q \u003d 0;\n            double r \u003d 0;\n            double u \u003d 0;\n            if (FastMath.abs(e) \u003e tol1) {\n                r \u003d (x - w) * (fx - fv);\n                q \u003d (x - v) * (fx - fw);\n                p \u003d (x - v) * q - (x - w) * r;\n                q \u003d 2 * (q - r);\n                if (q \u003e 0) {\n                    p \u003d -p;\n                } else {\n                    q \u003d -q;\n                }\n                r \u003d e;\n                e \u003d d;\n                if (p \u003e q * (a - x) \u0026\u0026 p \u003c q * (b - x) \u0026\u0026 FastMath.abs(p) \u003c FastMath.abs(0.5 * q * r)) {\n                    d \u003d p / q;\n                    u \u003d x + d;\n                    if (u - a \u003c tol2 || b - u \u003c tol2) {\n                        if (x \u003c\u003d m) {\n                            d \u003d tol1;\n                        } else {\n                            d \u003d -tol1;\n                        }\n                    }\n                } else {\n                    if (x \u003c m) {\n                        e \u003d b - x;\n                    } else {\n                        e \u003d a - x;\n                    }\n                    d \u003d GOLDEN_SECTION * e;\n                }\n            } else {\n                if (x \u003c m) {\n                    e \u003d b - x;\n                } else {\n                    e \u003d a - x;\n                }\n                d \u003d GOLDEN_SECTION * e;\n            }\n            if (FastMath.abs(d) \u003c tol1) {\n                if (d \u003e\u003d 0) {\n                    u \u003d x + tol1;\n                } else {\n                    u \u003d x - tol1;\n                }\n            } else {\n                u \u003d x + d;\n            }\n            double fu \u003d computeObjectiveValue(u);\n            if (!isMinim) {\n                fu \u003d -fu;\n            }\n            if (fu \u003c\u003d fx) {\n                if (u \u003c x) {\n                    b \u003d x;\n                } else {\n                    a \u003d x;\n                }\n                v \u003d w;\n                fv \u003d fw;\n                w \u003d x;\n                fw \u003d fx;\n                x \u003d u;\n                fx \u003d fu;\n            } else {\n                if (u \u003c x) {\n                    a \u003d u;\n                } else {\n                    b \u003d u;\n                }\n                if (fu \u003c\u003d fw || w \u003d\u003d x) {\n                    v \u003d w;\n                    fv \u003d fw;\n                    w \u003d u;\n                    fw \u003d fu;\n                } else if (fu \u003c\u003d fv || v \u003d\u003d x || v \u003d\u003d w) {\n                    v \u003d u;\n                    fv \u003d fu;\n                }\n            }\n        } else {\n            return new UnivariateRealPointValuePair(x, (isMinim ? fx : -fx));\n        }\n        ++iter;\n    }\n}",
          "path": "src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java",
          "functionStartLine": 140,
          "functionName": "doOptimize",
          "functionAnnotation": "",
          "functionDoc": "@inheritDoc}\n",
          "diff": "@@ -1,3 +1,123 @@\n-protected double doOptimize() throws MaxIterationsExceededException, FunctionEvaluationException {\n-    return localMin(getGoalType() \u003d\u003d GoalType.MINIMIZE, getMin(), getStartValue(), getMax(), getRelativeAccuracy(), getAbsoluteAccuracy());\n+protected UnivariateRealPointValuePair doOptimize() throws FunctionEvaluationException {\n+    final boolean isMinim \u003d (getGoalType() \u003d\u003d GoalType.MINIMIZE);\n+    final double lo \u003d getMin();\n+    final double mid \u003d getStartValue();\n+    final double hi \u003d getMax();\n+    final ConvergenceChecker\u003cUnivariateRealPointValuePair\u003e checker \u003d getConvergenceChecker();\n+    final double eps \u003d checker.getRelativeThreshold();\n+    final double t \u003d checker.getAbsoluteThreshold();\n+    double a;\n+    double b;\n+    if (lo \u003c hi) {\n+        a \u003d lo;\n+        b \u003d hi;\n+    } else {\n+        a \u003d hi;\n+        b \u003d lo;\n+    }\n+    double x \u003d mid;\n+    double v \u003d x;\n+    double w \u003d x;\n+    double d \u003d 0;\n+    double e \u003d 0;\n+    double fx \u003d computeObjectiveValue(x);\n+    if (!isMinim) {\n+        fx \u003d -fx;\n+    }\n+    double fv \u003d fx;\n+    double fw \u003d fx;\n+    int iter \u003d 0;\n+    while (true) {\n+        double m \u003d 0.5 * (a + b);\n+        final double tol1 \u003d eps * FastMath.abs(x) + t;\n+        final double tol2 \u003d 2 * tol1;\n+        if (!getConvergenceChecker().converged(iter, new UnivariateRealPointValuePair(a, Double.NaN), new UnivariateRealPointValuePair(x, Double.NaN), new UnivariateRealPointValuePair(b, Double.NaN))) {\n+            double p \u003d 0;\n+            double q \u003d 0;\n+            double r \u003d 0;\n+            double u \u003d 0;\n+            if (FastMath.abs(e) \u003e tol1) {\n+                r \u003d (x - w) * (fx - fv);\n+                q \u003d (x - v) * (fx - fw);\n+                p \u003d (x - v) * q - (x - w) * r;\n+                q \u003d 2 * (q - r);\n+                if (q \u003e 0) {\n+                    p \u003d -p;\n+                } else {\n+                    q \u003d -q;\n+                }\n+                r \u003d e;\n+                e \u003d d;\n+                if (p \u003e q * (a - x) \u0026\u0026 p \u003c q * (b - x) \u0026\u0026 FastMath.abs(p) \u003c FastMath.abs(0.5 * q * r)) {\n+                    d \u003d p / q;\n+                    u \u003d x + d;\n+                    if (u - a \u003c tol2 || b - u \u003c tol2) {\n+                        if (x \u003c\u003d m) {\n+                            d \u003d tol1;\n+                        } else {\n+                            d \u003d -tol1;\n+                        }\n+                    }\n+                } else {\n+                    if (x \u003c m) {\n+                        e \u003d b - x;\n+                    } else {\n+                        e \u003d a - x;\n+                    }\n+                    d \u003d GOLDEN_SECTION * e;\n+                }\n+            } else {\n+                if (x \u003c m) {\n+                    e \u003d b - x;\n+                } else {\n+                    e \u003d a - x;\n+                }\n+                d \u003d GOLDEN_SECTION * e;\n+            }\n+            if (FastMath.abs(d) \u003c tol1) {\n+                if (d \u003e\u003d 0) {\n+                    u \u003d x + tol1;\n+                } else {\n+                    u \u003d x - tol1;\n+                }\n+            } else {\n+                u \u003d x + d;\n+            }\n+            double fu \u003d computeObjectiveValue(u);\n+            if (!isMinim) {\n+                fu \u003d -fu;\n+            }\n+            if (fu \u003c\u003d fx) {\n+                if (u \u003c x) {\n+                    b \u003d x;\n+                } else {\n+                    a \u003d x;\n+                }\n+                v \u003d w;\n+                fv \u003d fw;\n+                w \u003d x;\n+                fw \u003d fx;\n+                x \u003d u;\n+                fx \u003d fu;\n+            } else {\n+                if (u \u003c x) {\n+                    a \u003d u;\n+                } else {\n+                    b \u003d u;\n+                }\n+                if (fu \u003c\u003d fw || w \u003d\u003d x) {\n+                    v \u003d w;\n+                    fv \u003d fw;\n+                    w \u003d u;\n+                    fw \u003d fu;\n+                } else if (fu \u003c\u003d fv || v \u003d\u003d x || v \u003d\u003d w) {\n+                    v \u003d u;\n+                    fv \u003d fu;\n+                }\n+            }\n+        } else {\n+            return new UnivariateRealPointValuePair(x, (isMinim ? fx : -fx));\n+        }\n+        ++iter;\n+    }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "double",
            "newValue": "UnivariateRealPointValuePair"
          }
        },
        {
          "type": "Yexceptionschange",
          "commitMessage": "MATH-394, MATH-397, MATH-404\nOverhaul of the \"optimization\" package.\nRemoved lots of duplicate code.\nRemoved methods referring to the concept of \"iteration\".\nRemoved interface methods to access the number of evaluations of the\ngradient and Jacobian.\nRemoved all references to \"OptimizationException\" (replaced by\n\"ConvergenceException\").\nJavadoc comments updated.\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@990792 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "8/30/10, 6:06 AM",
          "commitName": "9102bea5d82c6f97bf3cfb1d8525c13e58a9d418",
          "commitAuthor": "Gilles Sadowski",
          "commitDateOld": "8/29/10, 3:04 PM",
          "commitNameOld": "80b1e90b42a34856b61cec628fcea6633d1000cd",
          "commitAuthorOld": "Luc Maisonobe",
          "daysBetweenCommits": 0.63,
          "commitsBetweenForRepo": 3,
          "commitsBetweenForFile": 1,
          "actualSource": "protected UnivariateRealPointValuePair doOptimize() throws FunctionEvaluationException {\n    final boolean isMinim \u003d (getGoalType() \u003d\u003d GoalType.MINIMIZE);\n    final double lo \u003d getMin();\n    final double mid \u003d getStartValue();\n    final double hi \u003d getMax();\n    final ConvergenceChecker\u003cUnivariateRealPointValuePair\u003e checker \u003d getConvergenceChecker();\n    final double eps \u003d checker.getRelativeThreshold();\n    final double t \u003d checker.getAbsoluteThreshold();\n    double a;\n    double b;\n    if (lo \u003c hi) {\n        a \u003d lo;\n        b \u003d hi;\n    } else {\n        a \u003d hi;\n        b \u003d lo;\n    }\n    double x \u003d mid;\n    double v \u003d x;\n    double w \u003d x;\n    double d \u003d 0;\n    double e \u003d 0;\n    double fx \u003d computeObjectiveValue(x);\n    if (!isMinim) {\n        fx \u003d -fx;\n    }\n    double fv \u003d fx;\n    double fw \u003d fx;\n    int iter \u003d 0;\n    while (true) {\n        double m \u003d 0.5 * (a + b);\n        final double tol1 \u003d eps * FastMath.abs(x) + t;\n        final double tol2 \u003d 2 * tol1;\n        if (!getConvergenceChecker().converged(iter, new UnivariateRealPointValuePair(a, Double.NaN), new UnivariateRealPointValuePair(x, Double.NaN), new UnivariateRealPointValuePair(b, Double.NaN))) {\n            double p \u003d 0;\n            double q \u003d 0;\n            double r \u003d 0;\n            double u \u003d 0;\n            if (FastMath.abs(e) \u003e tol1) {\n                r \u003d (x - w) * (fx - fv);\n                q \u003d (x - v) * (fx - fw);\n                p \u003d (x - v) * q - (x - w) * r;\n                q \u003d 2 * (q - r);\n                if (q \u003e 0) {\n                    p \u003d -p;\n                } else {\n                    q \u003d -q;\n                }\n                r \u003d e;\n                e \u003d d;\n                if (p \u003e q * (a - x) \u0026\u0026 p \u003c q * (b - x) \u0026\u0026 FastMath.abs(p) \u003c FastMath.abs(0.5 * q * r)) {\n                    d \u003d p / q;\n                    u \u003d x + d;\n                    if (u - a \u003c tol2 || b - u \u003c tol2) {\n                        if (x \u003c\u003d m) {\n                            d \u003d tol1;\n                        } else {\n                            d \u003d -tol1;\n                        }\n                    }\n                } else {\n                    if (x \u003c m) {\n                        e \u003d b - x;\n                    } else {\n                        e \u003d a - x;\n                    }\n                    d \u003d GOLDEN_SECTION * e;\n                }\n            } else {\n                if (x \u003c m) {\n                    e \u003d b - x;\n                } else {\n                    e \u003d a - x;\n                }\n                d \u003d GOLDEN_SECTION * e;\n            }\n            if (FastMath.abs(d) \u003c tol1) {\n                if (d \u003e\u003d 0) {\n                    u \u003d x + tol1;\n                } else {\n                    u \u003d x - tol1;\n                }\n            } else {\n                u \u003d x + d;\n            }\n            double fu \u003d computeObjectiveValue(u);\n            if (!isMinim) {\n                fu \u003d -fu;\n            }\n            if (fu \u003c\u003d fx) {\n                if (u \u003c x) {\n                    b \u003d x;\n                } else {\n                    a \u003d x;\n                }\n                v \u003d w;\n                fv \u003d fw;\n                w \u003d x;\n                fw \u003d fx;\n                x \u003d u;\n                fx \u003d fu;\n            } else {\n                if (u \u003c x) {\n                    a \u003d u;\n                } else {\n                    b \u003d u;\n                }\n                if (fu \u003c\u003d fw || w \u003d\u003d x) {\n                    v \u003d w;\n                    fv \u003d fw;\n                    w \u003d u;\n                    fw \u003d fu;\n                } else if (fu \u003c\u003d fv || v \u003d\u003d x || v \u003d\u003d w) {\n                    v \u003d u;\n                    fv \u003d fu;\n                }\n            }\n        } else {\n            return new UnivariateRealPointValuePair(x, (isMinim ? fx : -fx));\n        }\n        ++iter;\n    }\n}",
          "path": "src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java",
          "functionStartLine": 140,
          "functionName": "doOptimize",
          "functionAnnotation": "",
          "functionDoc": "@inheritDoc}\n",
          "diff": "@@ -1,3 +1,123 @@\n-protected double doOptimize() throws MaxIterationsExceededException, FunctionEvaluationException {\n-    return localMin(getGoalType() \u003d\u003d GoalType.MINIMIZE, getMin(), getStartValue(), getMax(), getRelativeAccuracy(), getAbsoluteAccuracy());\n+protected UnivariateRealPointValuePair doOptimize() throws FunctionEvaluationException {\n+    final boolean isMinim \u003d (getGoalType() \u003d\u003d GoalType.MINIMIZE);\n+    final double lo \u003d getMin();\n+    final double mid \u003d getStartValue();\n+    final double hi \u003d getMax();\n+    final ConvergenceChecker\u003cUnivariateRealPointValuePair\u003e checker \u003d getConvergenceChecker();\n+    final double eps \u003d checker.getRelativeThreshold();\n+    final double t \u003d checker.getAbsoluteThreshold();\n+    double a;\n+    double b;\n+    if (lo \u003c hi) {\n+        a \u003d lo;\n+        b \u003d hi;\n+    } else {\n+        a \u003d hi;\n+        b \u003d lo;\n+    }\n+    double x \u003d mid;\n+    double v \u003d x;\n+    double w \u003d x;\n+    double d \u003d 0;\n+    double e \u003d 0;\n+    double fx \u003d computeObjectiveValue(x);\n+    if (!isMinim) {\n+        fx \u003d -fx;\n+    }\n+    double fv \u003d fx;\n+    double fw \u003d fx;\n+    int iter \u003d 0;\n+    while (true) {\n+        double m \u003d 0.5 * (a + b);\n+        final double tol1 \u003d eps * FastMath.abs(x) + t;\n+        final double tol2 \u003d 2 * tol1;\n+        if (!getConvergenceChecker().converged(iter, new UnivariateRealPointValuePair(a, Double.NaN), new UnivariateRealPointValuePair(x, Double.NaN), new UnivariateRealPointValuePair(b, Double.NaN))) {\n+            double p \u003d 0;\n+            double q \u003d 0;\n+            double r \u003d 0;\n+            double u \u003d 0;\n+            if (FastMath.abs(e) \u003e tol1) {\n+                r \u003d (x - w) * (fx - fv);\n+                q \u003d (x - v) * (fx - fw);\n+                p \u003d (x - v) * q - (x - w) * r;\n+                q \u003d 2 * (q - r);\n+                if (q \u003e 0) {\n+                    p \u003d -p;\n+                } else {\n+                    q \u003d -q;\n+                }\n+                r \u003d e;\n+                e \u003d d;\n+                if (p \u003e q * (a - x) \u0026\u0026 p \u003c q * (b - x) \u0026\u0026 FastMath.abs(p) \u003c FastMath.abs(0.5 * q * r)) {\n+                    d \u003d p / q;\n+                    u \u003d x + d;\n+                    if (u - a \u003c tol2 || b - u \u003c tol2) {\n+                        if (x \u003c\u003d m) {\n+                            d \u003d tol1;\n+                        } else {\n+                            d \u003d -tol1;\n+                        }\n+                    }\n+                } else {\n+                    if (x \u003c m) {\n+                        e \u003d b - x;\n+                    } else {\n+                        e \u003d a - x;\n+                    }\n+                    d \u003d GOLDEN_SECTION * e;\n+                }\n+            } else {\n+                if (x \u003c m) {\n+                    e \u003d b - x;\n+                } else {\n+                    e \u003d a - x;\n+                }\n+                d \u003d GOLDEN_SECTION * e;\n+            }\n+            if (FastMath.abs(d) \u003c tol1) {\n+                if (d \u003e\u003d 0) {\n+                    u \u003d x + tol1;\n+                } else {\n+                    u \u003d x - tol1;\n+                }\n+            } else {\n+                u \u003d x + d;\n+            }\n+            double fu \u003d computeObjectiveValue(u);\n+            if (!isMinim) {\n+                fu \u003d -fu;\n+            }\n+            if (fu \u003c\u003d fx) {\n+                if (u \u003c x) {\n+                    b \u003d x;\n+                } else {\n+                    a \u003d x;\n+                }\n+                v \u003d w;\n+                fv \u003d fw;\n+                w \u003d x;\n+                fw \u003d fx;\n+                x \u003d u;\n+                fx \u003d fu;\n+            } else {\n+                if (u \u003c x) {\n+                    a \u003d u;\n+                } else {\n+                    b \u003d u;\n+                }\n+                if (fu \u003c\u003d fw || w \u003d\u003d x) {\n+                    v \u003d w;\n+                    fv \u003d fw;\n+                    w \u003d u;\n+                    fw \u003d fu;\n+                } else if (fu \u003c\u003d fv || v \u003d\u003d x || v \u003d\u003d w) {\n+                    v \u003d u;\n+                    fv \u003d fu;\n+                }\n+            }\n+        } else {\n+            return new UnivariateRealPointValuePair(x, (isMinim ? fx : -fx));\n+        }\n+        ++iter;\n+    }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[MaxIterationsExceededException, FunctionEvaluationException]",
            "newValue": "[FunctionEvaluationException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "MATH-394, MATH-397, MATH-404\nOverhaul of the \"optimization\" package.\nRemoved lots of duplicate code.\nRemoved methods referring to the concept of \"iteration\".\nRemoved interface methods to access the number of evaluations of the\ngradient and Jacobian.\nRemoved all references to \"OptimizationException\" (replaced by\n\"ConvergenceException\").\nJavadoc comments updated.\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@990792 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "8/30/10, 6:06 AM",
          "commitName": "9102bea5d82c6f97bf3cfb1d8525c13e58a9d418",
          "commitAuthor": "Gilles Sadowski",
          "commitDateOld": "8/29/10, 3:04 PM",
          "commitNameOld": "80b1e90b42a34856b61cec628fcea6633d1000cd",
          "commitAuthorOld": "Luc Maisonobe",
          "daysBetweenCommits": 0.63,
          "commitsBetweenForRepo": 3,
          "commitsBetweenForFile": 1,
          "actualSource": "protected UnivariateRealPointValuePair doOptimize() throws FunctionEvaluationException {\n    final boolean isMinim \u003d (getGoalType() \u003d\u003d GoalType.MINIMIZE);\n    final double lo \u003d getMin();\n    final double mid \u003d getStartValue();\n    final double hi \u003d getMax();\n    final ConvergenceChecker\u003cUnivariateRealPointValuePair\u003e checker \u003d getConvergenceChecker();\n    final double eps \u003d checker.getRelativeThreshold();\n    final double t \u003d checker.getAbsoluteThreshold();\n    double a;\n    double b;\n    if (lo \u003c hi) {\n        a \u003d lo;\n        b \u003d hi;\n    } else {\n        a \u003d hi;\n        b \u003d lo;\n    }\n    double x \u003d mid;\n    double v \u003d x;\n    double w \u003d x;\n    double d \u003d 0;\n    double e \u003d 0;\n    double fx \u003d computeObjectiveValue(x);\n    if (!isMinim) {\n        fx \u003d -fx;\n    }\n    double fv \u003d fx;\n    double fw \u003d fx;\n    int iter \u003d 0;\n    while (true) {\n        double m \u003d 0.5 * (a + b);\n        final double tol1 \u003d eps * FastMath.abs(x) + t;\n        final double tol2 \u003d 2 * tol1;\n        if (!getConvergenceChecker().converged(iter, new UnivariateRealPointValuePair(a, Double.NaN), new UnivariateRealPointValuePair(x, Double.NaN), new UnivariateRealPointValuePair(b, Double.NaN))) {\n            double p \u003d 0;\n            double q \u003d 0;\n            double r \u003d 0;\n            double u \u003d 0;\n            if (FastMath.abs(e) \u003e tol1) {\n                r \u003d (x - w) * (fx - fv);\n                q \u003d (x - v) * (fx - fw);\n                p \u003d (x - v) * q - (x - w) * r;\n                q \u003d 2 * (q - r);\n                if (q \u003e 0) {\n                    p \u003d -p;\n                } else {\n                    q \u003d -q;\n                }\n                r \u003d e;\n                e \u003d d;\n                if (p \u003e q * (a - x) \u0026\u0026 p \u003c q * (b - x) \u0026\u0026 FastMath.abs(p) \u003c FastMath.abs(0.5 * q * r)) {\n                    d \u003d p / q;\n                    u \u003d x + d;\n                    if (u - a \u003c tol2 || b - u \u003c tol2) {\n                        if (x \u003c\u003d m) {\n                            d \u003d tol1;\n                        } else {\n                            d \u003d -tol1;\n                        }\n                    }\n                } else {\n                    if (x \u003c m) {\n                        e \u003d b - x;\n                    } else {\n                        e \u003d a - x;\n                    }\n                    d \u003d GOLDEN_SECTION * e;\n                }\n            } else {\n                if (x \u003c m) {\n                    e \u003d b - x;\n                } else {\n                    e \u003d a - x;\n                }\n                d \u003d GOLDEN_SECTION * e;\n            }\n            if (FastMath.abs(d) \u003c tol1) {\n                if (d \u003e\u003d 0) {\n                    u \u003d x + tol1;\n                } else {\n                    u \u003d x - tol1;\n                }\n            } else {\n                u \u003d x + d;\n            }\n            double fu \u003d computeObjectiveValue(u);\n            if (!isMinim) {\n                fu \u003d -fu;\n            }\n            if (fu \u003c\u003d fx) {\n                if (u \u003c x) {\n                    b \u003d x;\n                } else {\n                    a \u003d x;\n                }\n                v \u003d w;\n                fv \u003d fw;\n                w \u003d x;\n                fw \u003d fx;\n                x \u003d u;\n                fx \u003d fu;\n            } else {\n                if (u \u003c x) {\n                    a \u003d u;\n                } else {\n                    b \u003d u;\n                }\n                if (fu \u003c\u003d fw || w \u003d\u003d x) {\n                    v \u003d w;\n                    fv \u003d fw;\n                    w \u003d u;\n                    fw \u003d fu;\n                } else if (fu \u003c\u003d fv || v \u003d\u003d x || v \u003d\u003d w) {\n                    v \u003d u;\n                    fv \u003d fu;\n                }\n            }\n        } else {\n            return new UnivariateRealPointValuePair(x, (isMinim ? fx : -fx));\n        }\n        ++iter;\n    }\n}",
          "path": "src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java",
          "functionStartLine": 140,
          "functionName": "doOptimize",
          "functionAnnotation": "",
          "functionDoc": "@inheritDoc}\n",
          "diff": "@@ -1,3 +1,123 @@\n-protected double doOptimize() throws MaxIterationsExceededException, FunctionEvaluationException {\n-    return localMin(getGoalType() \u003d\u003d GoalType.MINIMIZE, getMin(), getStartValue(), getMax(), getRelativeAccuracy(), getAbsoluteAccuracy());\n+protected UnivariateRealPointValuePair doOptimize() throws FunctionEvaluationException {\n+    final boolean isMinim \u003d (getGoalType() \u003d\u003d GoalType.MINIMIZE);\n+    final double lo \u003d getMin();\n+    final double mid \u003d getStartValue();\n+    final double hi \u003d getMax();\n+    final ConvergenceChecker\u003cUnivariateRealPointValuePair\u003e checker \u003d getConvergenceChecker();\n+    final double eps \u003d checker.getRelativeThreshold();\n+    final double t \u003d checker.getAbsoluteThreshold();\n+    double a;\n+    double b;\n+    if (lo \u003c hi) {\n+        a \u003d lo;\n+        b \u003d hi;\n+    } else {\n+        a \u003d hi;\n+        b \u003d lo;\n+    }\n+    double x \u003d mid;\n+    double v \u003d x;\n+    double w \u003d x;\n+    double d \u003d 0;\n+    double e \u003d 0;\n+    double fx \u003d computeObjectiveValue(x);\n+    if (!isMinim) {\n+        fx \u003d -fx;\n+    }\n+    double fv \u003d fx;\n+    double fw \u003d fx;\n+    int iter \u003d 0;\n+    while (true) {\n+        double m \u003d 0.5 * (a + b);\n+        final double tol1 \u003d eps * FastMath.abs(x) + t;\n+        final double tol2 \u003d 2 * tol1;\n+        if (!getConvergenceChecker().converged(iter, new UnivariateRealPointValuePair(a, Double.NaN), new UnivariateRealPointValuePair(x, Double.NaN), new UnivariateRealPointValuePair(b, Double.NaN))) {\n+            double p \u003d 0;\n+            double q \u003d 0;\n+            double r \u003d 0;\n+            double u \u003d 0;\n+            if (FastMath.abs(e) \u003e tol1) {\n+                r \u003d (x - w) * (fx - fv);\n+                q \u003d (x - v) * (fx - fw);\n+                p \u003d (x - v) * q - (x - w) * r;\n+                q \u003d 2 * (q - r);\n+                if (q \u003e 0) {\n+                    p \u003d -p;\n+                } else {\n+                    q \u003d -q;\n+                }\n+                r \u003d e;\n+                e \u003d d;\n+                if (p \u003e q * (a - x) \u0026\u0026 p \u003c q * (b - x) \u0026\u0026 FastMath.abs(p) \u003c FastMath.abs(0.5 * q * r)) {\n+                    d \u003d p / q;\n+                    u \u003d x + d;\n+                    if (u - a \u003c tol2 || b - u \u003c tol2) {\n+                        if (x \u003c\u003d m) {\n+                            d \u003d tol1;\n+                        } else {\n+                            d \u003d -tol1;\n+                        }\n+                    }\n+                } else {\n+                    if (x \u003c m) {\n+                        e \u003d b - x;\n+                    } else {\n+                        e \u003d a - x;\n+                    }\n+                    d \u003d GOLDEN_SECTION * e;\n+                }\n+            } else {\n+                if (x \u003c m) {\n+                    e \u003d b - x;\n+                } else {\n+                    e \u003d a - x;\n+                }\n+                d \u003d GOLDEN_SECTION * e;\n+            }\n+            if (FastMath.abs(d) \u003c tol1) {\n+                if (d \u003e\u003d 0) {\n+                    u \u003d x + tol1;\n+                } else {\n+                    u \u003d x - tol1;\n+                }\n+            } else {\n+                u \u003d x + d;\n+            }\n+            double fu \u003d computeObjectiveValue(u);\n+            if (!isMinim) {\n+                fu \u003d -fu;\n+            }\n+            if (fu \u003c\u003d fx) {\n+                if (u \u003c x) {\n+                    b \u003d x;\n+                } else {\n+                    a \u003d x;\n+                }\n+                v \u003d w;\n+                fv \u003d fw;\n+                w \u003d x;\n+                fw \u003d fx;\n+                x \u003d u;\n+                fx \u003d fu;\n+            } else {\n+                if (u \u003c x) {\n+                    a \u003d u;\n+                } else {\n+                    b \u003d u;\n+                }\n+                if (fu \u003c\u003d fw || w \u003d\u003d x) {\n+                    v \u003d w;\n+                    fv \u003d fw;\n+                    w \u003d u;\n+                    fw \u003d fu;\n+                } else if (fu \u003c\u003d fv || v \u003d\u003d x || v \u003d\u003d w) {\n+                    v \u003d u;\n+                    fv \u003d fu;\n+                }\n+            }\n+        } else {\n+            return new UnivariateRealPointValuePair(x, (isMinim ? fx : -fx));\n+        }\n+        ++iter;\n+    }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "ee555fecaf3a86dc55468b27c28cc28c2983e87b": {
      "type": "Ydocchange",
      "commitMessage": "fixed numerous checkstyle warnings (javadoc, trailing spaces, tabs, parenthesis, declaration order ...)\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@980981 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "7/30/10, 3:03 PM",
      "commitName": "ee555fecaf3a86dc55468b27c28cc28c2983e87b",
      "commitAuthor": "Luc Maisonobe",
      "commitDateOld": "7/30/10, 1:31 PM",
      "commitNameOld": "a74f9eb213eefeb43c5eba610c276682cb2e2e64",
      "commitAuthorOld": "Luc Maisonobe",
      "daysBetweenCommits": 0.06,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "protected double doOptimize() throws MaxIterationsExceededException, FunctionEvaluationException {\n    return localMin(getGoalType() \u003d\u003d GoalType.MINIMIZE, getMin(), getStartValue(), getMax(), getRelativeAccuracy(), getAbsoluteAccuracy());\n}",
      "path": "src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java",
      "functionStartLine": 50,
      "functionName": "doOptimize",
      "functionAnnotation": "",
      "functionDoc": "@inheritDoc}\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "Perform the optimization.\n\n@return the optimum.\n",
        "newValue": "@inheritDoc}\n"
      }
    },
    "76fcbc838c0f27d9b029c1f283390cb4f47f8895": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange,Ydocchange)",
      "commitMessage": "MATH-395: Another bug uncovered; all things being equal, the code now behaves\nlike the Puthon implementation.\nMATH-397: Modified \"BrentOptimizer\" following the changes in\n\"AbstractUnivariateRealOptimizer\".\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@980032 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "7/28/10, 5:03 AM",
      "commitName": "76fcbc838c0f27d9b029c1f283390cb4f47f8895",
      "commitAuthor": "Gilles Sadowski",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "MATH-395: Another bug uncovered; all things being equal, the code now behaves\nlike the Puthon implementation.\nMATH-397: Modified \"BrentOptimizer\" following the changes in\n\"AbstractUnivariateRealOptimizer\".\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@980032 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "7/28/10, 5:03 AM",
          "commitName": "76fcbc838c0f27d9b029c1f283390cb4f47f8895",
          "commitAuthor": "Gilles Sadowski",
          "commitDateOld": "7/28/10, 3:27 AM",
          "commitNameOld": "7bbad398dd4da51c933414be9a17b07179dee5e4",
          "commitAuthorOld": "Gilles Sadowski",
          "daysBetweenCommits": 0.07,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "protected double doOptimize() throws MaxIterationsExceededException, FunctionEvaluationException {\n    return localMin(getGoalType() \u003d\u003d GoalType.MINIMIZE, getMin(), getStartValue(), getMax(), getRelativeAccuracy(), getAbsoluteAccuracy());\n}",
          "path": "src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java",
          "functionStartLine": 55,
          "functionName": "doOptimize",
          "functionAnnotation": "",
          "functionDoc": "Perform the optimization.\n\n@return the optimum.\n",
          "diff": "@@ -1,3 +1,3 @@\n-protected double doOptimize() {\n-    throw new UnsupportedOperationException();\n+protected double doOptimize() throws MaxIterationsExceededException, FunctionEvaluationException {\n+    return localMin(getGoalType() \u003d\u003d GoalType.MINIMIZE, getMin(), getStartValue(), getMax(), getRelativeAccuracy(), getAbsoluteAccuracy());\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[MaxIterationsExceededException, FunctionEvaluationException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "MATH-395: Another bug uncovered; all things being equal, the code now behaves\nlike the Puthon implementation.\nMATH-397: Modified \"BrentOptimizer\" following the changes in\n\"AbstractUnivariateRealOptimizer\".\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@980032 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "7/28/10, 5:03 AM",
          "commitName": "76fcbc838c0f27d9b029c1f283390cb4f47f8895",
          "commitAuthor": "Gilles Sadowski",
          "commitDateOld": "7/28/10, 3:27 AM",
          "commitNameOld": "7bbad398dd4da51c933414be9a17b07179dee5e4",
          "commitAuthorOld": "Gilles Sadowski",
          "daysBetweenCommits": 0.07,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "protected double doOptimize() throws MaxIterationsExceededException, FunctionEvaluationException {\n    return localMin(getGoalType() \u003d\u003d GoalType.MINIMIZE, getMin(), getStartValue(), getMax(), getRelativeAccuracy(), getAbsoluteAccuracy());\n}",
          "path": "src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java",
          "functionStartLine": 55,
          "functionName": "doOptimize",
          "functionAnnotation": "",
          "functionDoc": "Perform the optimization.\n\n@return the optimum.\n",
          "diff": "@@ -1,3 +1,3 @@\n-protected double doOptimize() {\n-    throw new UnsupportedOperationException();\n+protected double doOptimize() throws MaxIterationsExceededException, FunctionEvaluationException {\n+    return localMin(getGoalType() \u003d\u003d GoalType.MINIMIZE, getMin(), getStartValue(), getMax(), getRelativeAccuracy(), getAbsoluteAccuracy());\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "MATH-395: Another bug uncovered; all things being equal, the code now behaves\nlike the Puthon implementation.\nMATH-397: Modified \"BrentOptimizer\" following the changes in\n\"AbstractUnivariateRealOptimizer\".\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@980032 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "7/28/10, 5:03 AM",
          "commitName": "76fcbc838c0f27d9b029c1f283390cb4f47f8895",
          "commitAuthor": "Gilles Sadowski",
          "commitDateOld": "7/28/10, 3:27 AM",
          "commitNameOld": "7bbad398dd4da51c933414be9a17b07179dee5e4",
          "commitAuthorOld": "Gilles Sadowski",
          "daysBetweenCommits": 0.07,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "protected double doOptimize() throws MaxIterationsExceededException, FunctionEvaluationException {\n    return localMin(getGoalType() \u003d\u003d GoalType.MINIMIZE, getMin(), getStartValue(), getMax(), getRelativeAccuracy(), getAbsoluteAccuracy());\n}",
          "path": "src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java",
          "functionStartLine": 55,
          "functionName": "doOptimize",
          "functionAnnotation": "",
          "functionDoc": "Perform the optimization.\n\n@return the optimum.\n",
          "diff": "@@ -1,3 +1,3 @@\n-protected double doOptimize() {\n-    throw new UnsupportedOperationException();\n+protected double doOptimize() throws MaxIterationsExceededException, FunctionEvaluationException {\n+    return localMin(getGoalType() \u003d\u003d GoalType.MINIMIZE, getMin(), getStartValue(), getMax(), getRelativeAccuracy(), getAbsoluteAccuracy());\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Temporary workaround.\n",
            "newValue": "Perform the optimization.\n\n@return the optimum.\n"
          }
        }
      ]
    },
    "7bbad398dd4da51c933414be9a17b07179dee5e4": {
      "type": "Yintroduced",
      "commitMessage": "MATH-397. Modified \"AbstractUnivariateRealOptimizer\" so that its usage is\nmore similar to what is done in package \"optimization.general\".\nDeprecated many methods as a consequence of the new layout.\nNew utility methods in \"ConvergingAlgorithmImpl\".\nTemporary workaround in \"BrentOptimizer\" (requirement from base class) to\navoid committing two issues at the same time...\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@980013 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "7/28/10, 3:27 AM",
      "commitName": "7bbad398dd4da51c933414be9a17b07179dee5e4",
      "commitAuthor": "Gilles Sadowski",
      "diff": "@@ -0,0 +1,3 @@\n+protected double doOptimize() {\n+    throw new UnsupportedOperationException();\n+}\n\\ No newline at end of file\n",
      "actualSource": "protected double doOptimize() {\n    throw new UnsupportedOperationException();\n}",
      "path": "src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java",
      "functionStartLine": 241,
      "functionName": "doOptimize",
      "functionAnnotation": "",
      "functionDoc": "Temporary workaround.\n"
    }
  }
}