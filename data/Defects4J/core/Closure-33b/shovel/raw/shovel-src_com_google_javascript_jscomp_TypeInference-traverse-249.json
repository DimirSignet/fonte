{
  "origin": "codeshovel",
  "repositoryName": "Closure-33b",
  "repositoryPath": "/tmp/Closure-33b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "TypeInference.java",
  "functionName": "traverse",
  "functionId": "traverse___n-Node__scope-FlowScope",
  "sourceFilePath": "src/com/google/javascript/jscomp/TypeInference.java",
  "functionAnnotation": "",
  "functionDoc": "",
  "functionStartLine": 249,
  "functionEndLine": 412,
  "numCommitsSeen": 69,
  "timeTaken": 5040,
  "changeHistory": [
    "c8d189698a5bf3362ccd820b42f3d62c550ec983",
    "39f629a8cfaab37da55288010640d7e516000b1f",
    "5524adbda991632656059566b69cc2771ba42b7d",
    "ec324a9bb23eb78c76f537f4c4170ba88d542f1c",
    "6641663fa9970c4d7bcdd96a6f31b83b18c3ee3d",
    "1c5d6203ab1152a6dee19149fdca2ecd1d8f585f",
    "b7b201a08e330c9638f52f5dfe824e426a34f2c5",
    "c764a46abf211d4677fadc33f7d466e5b14fa088",
    "52ecbc65e981b9f169466f8898155bc5f8bfad7a",
    "9afca869d4236594514b8461d771af9999c8a989",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3"
  ],
  "changeHistoryShort": {
    "c8d189698a5bf3362ccd820b42f3d62c550ec983": "Ybodychange",
    "39f629a8cfaab37da55288010640d7e516000b1f": "Ybodychange",
    "5524adbda991632656059566b69cc2771ba42b7d": "Ybodychange",
    "ec324a9bb23eb78c76f537f4c4170ba88d542f1c": "Ybodychange",
    "6641663fa9970c4d7bcdd96a6f31b83b18c3ee3d": "Ybodychange",
    "1c5d6203ab1152a6dee19149fdca2ecd1d8f585f": "Ybodychange",
    "b7b201a08e330c9638f52f5dfe824e426a34f2c5": "Ybodychange",
    "c764a46abf211d4677fadc33f7d466e5b14fa088": "Ybodychange",
    "52ecbc65e981b9f169466f8898155bc5f8bfad7a": "Ybodychange",
    "9afca869d4236594514b8461d771af9999c8a989": "Ybodychange",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "c8d189698a5bf3362ccd820b42f3d62c550ec983": {
      "type": "Ybodychange",
      "commitMessage": "\nreverse property inference based on return type\n\nR\u003dacleung\nDELTA\u003d57  (56 added, 1 deleted, 0 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3991\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1686 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "12/15/11, 12:56 PM",
      "commitName": "c8d189698a5bf3362ccd820b42f3d62c550ec983",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "11/15/11, 5:35 PM",
      "commitNameOld": "925a8f78c8c6a407435e6fb4513ad96d617643a3",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 29.81,
      "commitsBetweenForRepo": 72,
      "commitsBetweenForFile": 1,
      "actualSource": "private FlowScope traverse(Node n, FlowScope scope) {\n    switch(n.getType()) {\n        case Token.ASSIGN:\n            scope \u003d traverseAssign(n, scope);\n            break;\n        case Token.NAME:\n            scope \u003d traverseName(n, scope);\n            break;\n        case Token.GETPROP:\n            scope \u003d traverseGetProp(n, scope);\n            break;\n        case Token.AND:\n            scope \u003d traverseAnd(n, scope).getJoinedFlowScope().createChildFlowScope();\n            break;\n        case Token.OR:\n            scope \u003d traverseOr(n, scope).getJoinedFlowScope().createChildFlowScope();\n            break;\n        case Token.HOOK:\n            scope \u003d traverseHook(n, scope);\n            break;\n        case Token.OBJECTLIT:\n            scope \u003d traverseObjectLiteral(n, scope);\n            break;\n        case Token.CALL:\n            scope \u003d traverseCall(n, scope);\n            break;\n        case Token.NEW:\n            scope \u003d traverseNew(n, scope);\n            break;\n        case Token.ASSIGN_ADD:\n        case Token.ADD:\n            scope \u003d traverseAdd(n, scope);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            scope \u003d traverse(n.getFirstChild(), scope);\n            n.setJSType(getNativeType(NUMBER_TYPE));\n            break;\n        case Token.ARRAYLIT:\n            scope \u003d traverseArrayLiteral(n, scope);\n            break;\n        case Token.THIS:\n            n.setJSType(scope.getTypeOfThis());\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.ASSIGN_URSH:\n        case Token.URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_MUL:\n        case Token.ASSIGN_SUB:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITAND:\n        case Token.BITXOR:\n        case Token.BITOR:\n        case Token.MUL:\n        case Token.SUB:\n        case Token.DEC:\n        case Token.INC:\n        case Token.BITNOT:\n            scope \u003d traverseChildren(n, scope);\n            n.setJSType(getNativeType(NUMBER_TYPE));\n            break;\n        case Token.PARAM_LIST:\n            scope \u003d traverse(n.getFirstChild(), scope);\n            n.setJSType(getJSType(n.getFirstChild()));\n            break;\n        case Token.COMMA:\n            scope \u003d traverseChildren(n, scope);\n            n.setJSType(getJSType(n.getLastChild()));\n            break;\n        case Token.TYPEOF:\n            scope \u003d traverseChildren(n, scope);\n            n.setJSType(getNativeType(STRING_TYPE));\n            break;\n        case Token.DELPROP:\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n        case Token.NOT:\n        case Token.EQ:\n        case Token.NE:\n        case Token.SHEQ:\n        case Token.SHNE:\n        case Token.INSTANCEOF:\n        case Token.IN:\n            scope \u003d traverseChildren(n, scope);\n            n.setJSType(getNativeType(BOOLEAN_TYPE));\n            break;\n        case Token.GETELEM:\n            scope \u003d traverseGetElem(n, scope);\n            break;\n        case Token.EXPR_RESULT:\n            scope \u003d traverseChildren(n, scope);\n            if (n.getFirstChild().isGetProp()) {\n                ensurePropertyDeclared(n.getFirstChild());\n            }\n            break;\n        case Token.SWITCH:\n            scope \u003d traverse(n.getFirstChild(), scope);\n            break;\n        case Token.RETURN:\n            scope \u003d traverseReturn(n, scope);\n            break;\n        case Token.VAR:\n        case Token.THROW:\n            scope \u003d traverseChildren(n, scope);\n            break;\n        case Token.CATCH:\n            scope \u003d traverseCatch(n, scope);\n            break;\n    }\n    if (!n.isFunction()) {\n        JSDocInfo info \u003d n.getJSDocInfo();\n        if (info !\u003d null \u0026\u0026 info.hasType()) {\n            JSType castType \u003d info.getType().evaluate(syntacticScope, registry);\n            if (n.isQualifiedName() \u0026\u0026 n.getParent().isExprResult()) {\n                updateScopeForTypeChange(scope, n, n.getJSType(), castType);\n            }\n            n.setJSType(castType);\n        }\n    }\n    return scope;\n}",
      "path": "src/com/google/javascript/jscomp/TypeInference.java",
      "functionStartLine": 249,
      "functionName": "traverse",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,130 +1,132 @@\n private FlowScope traverse(Node n, FlowScope scope) {\n     switch(n.getType()) {\n         case Token.ASSIGN:\n             scope \u003d traverseAssign(n, scope);\n             break;\n         case Token.NAME:\n             scope \u003d traverseName(n, scope);\n             break;\n         case Token.GETPROP:\n             scope \u003d traverseGetProp(n, scope);\n             break;\n         case Token.AND:\n             scope \u003d traverseAnd(n, scope).getJoinedFlowScope().createChildFlowScope();\n             break;\n         case Token.OR:\n             scope \u003d traverseOr(n, scope).getJoinedFlowScope().createChildFlowScope();\n             break;\n         case Token.HOOK:\n             scope \u003d traverseHook(n, scope);\n             break;\n         case Token.OBJECTLIT:\n             scope \u003d traverseObjectLiteral(n, scope);\n             break;\n         case Token.CALL:\n             scope \u003d traverseCall(n, scope);\n             break;\n         case Token.NEW:\n             scope \u003d traverseNew(n, scope);\n             break;\n         case Token.ASSIGN_ADD:\n         case Token.ADD:\n             scope \u003d traverseAdd(n, scope);\n             break;\n         case Token.POS:\n         case Token.NEG:\n             scope \u003d traverse(n.getFirstChild(), scope);\n             n.setJSType(getNativeType(NUMBER_TYPE));\n             break;\n         case Token.ARRAYLIT:\n             scope \u003d traverseArrayLiteral(n, scope);\n             break;\n         case Token.THIS:\n             n.setJSType(scope.getTypeOfThis());\n             break;\n         case Token.ASSIGN_LSH:\n         case Token.ASSIGN_RSH:\n         case Token.LSH:\n         case Token.RSH:\n         case Token.ASSIGN_URSH:\n         case Token.URSH:\n         case Token.ASSIGN_DIV:\n         case Token.ASSIGN_MOD:\n         case Token.ASSIGN_BITAND:\n         case Token.ASSIGN_BITXOR:\n         case Token.ASSIGN_BITOR:\n         case Token.ASSIGN_MUL:\n         case Token.ASSIGN_SUB:\n         case Token.DIV:\n         case Token.MOD:\n         case Token.BITAND:\n         case Token.BITXOR:\n         case Token.BITOR:\n         case Token.MUL:\n         case Token.SUB:\n         case Token.DEC:\n         case Token.INC:\n         case Token.BITNOT:\n             scope \u003d traverseChildren(n, scope);\n             n.setJSType(getNativeType(NUMBER_TYPE));\n             break;\n         case Token.PARAM_LIST:\n             scope \u003d traverse(n.getFirstChild(), scope);\n             n.setJSType(getJSType(n.getFirstChild()));\n             break;\n         case Token.COMMA:\n             scope \u003d traverseChildren(n, scope);\n             n.setJSType(getJSType(n.getLastChild()));\n             break;\n         case Token.TYPEOF:\n             scope \u003d traverseChildren(n, scope);\n             n.setJSType(getNativeType(STRING_TYPE));\n             break;\n         case Token.DELPROP:\n         case Token.LT:\n         case Token.LE:\n         case Token.GT:\n         case Token.GE:\n         case Token.NOT:\n         case Token.EQ:\n         case Token.NE:\n         case Token.SHEQ:\n         case Token.SHNE:\n         case Token.INSTANCEOF:\n         case Token.IN:\n             scope \u003d traverseChildren(n, scope);\n             n.setJSType(getNativeType(BOOLEAN_TYPE));\n             break;\n         case Token.GETELEM:\n             scope \u003d traverseGetElem(n, scope);\n             break;\n         case Token.EXPR_RESULT:\n             scope \u003d traverseChildren(n, scope);\n             if (n.getFirstChild().isGetProp()) {\n                 ensurePropertyDeclared(n.getFirstChild());\n             }\n             break;\n         case Token.SWITCH:\n             scope \u003d traverse(n.getFirstChild(), scope);\n             break;\n-        case Token.VAR:\n         case Token.RETURN:\n+            scope \u003d traverseReturn(n, scope);\n+            break;\n+        case Token.VAR:\n         case Token.THROW:\n             scope \u003d traverseChildren(n, scope);\n             break;\n         case Token.CATCH:\n             scope \u003d traverseCatch(n, scope);\n             break;\n     }\n     if (!n.isFunction()) {\n         JSDocInfo info \u003d n.getJSDocInfo();\n         if (info !\u003d null \u0026\u0026 info.hasType()) {\n             JSType castType \u003d info.getType().evaluate(syntacticScope, registry);\n             if (n.isQualifiedName() \u0026\u0026 n.getParent().isExprResult()) {\n                 updateScopeForTypeChange(scope, n, n.getJSType(), castType);\n             }\n             n.setJSType(castType);\n         }\n     }\n     return scope;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "39f629a8cfaab37da55288010640d7e516000b1f": {
      "type": "Ybodychange",
      "commitMessage": "\nReplace calls of the form \"Node.getType() !\u003d Token.XX\" with\n\"!Node.isXX()\" calls.\n\nR\u003dnicksantos\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3706\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1598 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/14/11, 6:13 PM",
      "commitName": "39f629a8cfaab37da55288010640d7e516000b1f",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "11/14/11, 3:03 PM",
      "commitNameOld": "c5d7b308ecf260bf6ccf4b20ac256074fc42768f",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 0.13,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "private FlowScope traverse(Node n, FlowScope scope) {\n    switch(n.getType()) {\n        case Token.ASSIGN:\n            scope \u003d traverseAssign(n, scope);\n            break;\n        case Token.NAME:\n            scope \u003d traverseName(n, scope);\n            break;\n        case Token.GETPROP:\n            scope \u003d traverseGetProp(n, scope);\n            break;\n        case Token.AND:\n            scope \u003d traverseAnd(n, scope).getJoinedFlowScope().createChildFlowScope();\n            break;\n        case Token.OR:\n            scope \u003d traverseOr(n, scope).getJoinedFlowScope().createChildFlowScope();\n            break;\n        case Token.HOOK:\n            scope \u003d traverseHook(n, scope);\n            break;\n        case Token.OBJECTLIT:\n            scope \u003d traverseObjectLiteral(n, scope);\n            break;\n        case Token.CALL:\n            scope \u003d traverseCall(n, scope);\n            break;\n        case Token.NEW:\n            scope \u003d traverseNew(n, scope);\n            break;\n        case Token.ASSIGN_ADD:\n        case Token.ADD:\n            scope \u003d traverseAdd(n, scope);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            scope \u003d traverse(n.getFirstChild(), scope);\n            n.setJSType(getNativeType(NUMBER_TYPE));\n            break;\n        case Token.ARRAYLIT:\n            scope \u003d traverseArrayLiteral(n, scope);\n            break;\n        case Token.THIS:\n            n.setJSType(scope.getTypeOfThis());\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.ASSIGN_URSH:\n        case Token.URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_MUL:\n        case Token.ASSIGN_SUB:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITAND:\n        case Token.BITXOR:\n        case Token.BITOR:\n        case Token.MUL:\n        case Token.SUB:\n        case Token.DEC:\n        case Token.INC:\n        case Token.BITNOT:\n            scope \u003d traverseChildren(n, scope);\n            n.setJSType(getNativeType(NUMBER_TYPE));\n            break;\n        case Token.PARAM_LIST:\n            scope \u003d traverse(n.getFirstChild(), scope);\n            n.setJSType(getJSType(n.getFirstChild()));\n            break;\n        case Token.COMMA:\n            scope \u003d traverseChildren(n, scope);\n            n.setJSType(getJSType(n.getLastChild()));\n            break;\n        case Token.TYPEOF:\n            scope \u003d traverseChildren(n, scope);\n            n.setJSType(getNativeType(STRING_TYPE));\n            break;\n        case Token.DELPROP:\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n        case Token.NOT:\n        case Token.EQ:\n        case Token.NE:\n        case Token.SHEQ:\n        case Token.SHNE:\n        case Token.INSTANCEOF:\n        case Token.IN:\n            scope \u003d traverseChildren(n, scope);\n            n.setJSType(getNativeType(BOOLEAN_TYPE));\n            break;\n        case Token.GETELEM:\n            scope \u003d traverseGetElem(n, scope);\n            break;\n        case Token.EXPR_RESULT:\n            scope \u003d traverseChildren(n, scope);\n            if (n.getFirstChild().isGetProp()) {\n                ensurePropertyDeclared(n.getFirstChild());\n            }\n            break;\n        case Token.SWITCH:\n            scope \u003d traverse(n.getFirstChild(), scope);\n            break;\n        case Token.VAR:\n        case Token.RETURN:\n        case Token.THROW:\n            scope \u003d traverseChildren(n, scope);\n            break;\n        case Token.CATCH:\n            scope \u003d traverseCatch(n, scope);\n            break;\n    }\n    if (!n.isFunction()) {\n        JSDocInfo info \u003d n.getJSDocInfo();\n        if (info !\u003d null \u0026\u0026 info.hasType()) {\n            JSType castType \u003d info.getType().evaluate(syntacticScope, registry);\n            if (n.isQualifiedName() \u0026\u0026 n.getParent().isExprResult()) {\n                updateScopeForTypeChange(scope, n, n.getJSType(), castType);\n            }\n            n.setJSType(castType);\n        }\n    }\n    return scope;\n}",
      "path": "src/com/google/javascript/jscomp/TypeInference.java",
      "functionStartLine": 249,
      "functionName": "traverse",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,130 +1,130 @@\n private FlowScope traverse(Node n, FlowScope scope) {\n     switch(n.getType()) {\n         case Token.ASSIGN:\n             scope \u003d traverseAssign(n, scope);\n             break;\n         case Token.NAME:\n             scope \u003d traverseName(n, scope);\n             break;\n         case Token.GETPROP:\n             scope \u003d traverseGetProp(n, scope);\n             break;\n         case Token.AND:\n             scope \u003d traverseAnd(n, scope).getJoinedFlowScope().createChildFlowScope();\n             break;\n         case Token.OR:\n             scope \u003d traverseOr(n, scope).getJoinedFlowScope().createChildFlowScope();\n             break;\n         case Token.HOOK:\n             scope \u003d traverseHook(n, scope);\n             break;\n         case Token.OBJECTLIT:\n             scope \u003d traverseObjectLiteral(n, scope);\n             break;\n         case Token.CALL:\n             scope \u003d traverseCall(n, scope);\n             break;\n         case Token.NEW:\n             scope \u003d traverseNew(n, scope);\n             break;\n         case Token.ASSIGN_ADD:\n         case Token.ADD:\n             scope \u003d traverseAdd(n, scope);\n             break;\n         case Token.POS:\n         case Token.NEG:\n             scope \u003d traverse(n.getFirstChild(), scope);\n             n.setJSType(getNativeType(NUMBER_TYPE));\n             break;\n         case Token.ARRAYLIT:\n             scope \u003d traverseArrayLiteral(n, scope);\n             break;\n         case Token.THIS:\n             n.setJSType(scope.getTypeOfThis());\n             break;\n         case Token.ASSIGN_LSH:\n         case Token.ASSIGN_RSH:\n         case Token.LSH:\n         case Token.RSH:\n         case Token.ASSIGN_URSH:\n         case Token.URSH:\n         case Token.ASSIGN_DIV:\n         case Token.ASSIGN_MOD:\n         case Token.ASSIGN_BITAND:\n         case Token.ASSIGN_BITXOR:\n         case Token.ASSIGN_BITOR:\n         case Token.ASSIGN_MUL:\n         case Token.ASSIGN_SUB:\n         case Token.DIV:\n         case Token.MOD:\n         case Token.BITAND:\n         case Token.BITXOR:\n         case Token.BITOR:\n         case Token.MUL:\n         case Token.SUB:\n         case Token.DEC:\n         case Token.INC:\n         case Token.BITNOT:\n             scope \u003d traverseChildren(n, scope);\n             n.setJSType(getNativeType(NUMBER_TYPE));\n             break;\n         case Token.PARAM_LIST:\n             scope \u003d traverse(n.getFirstChild(), scope);\n             n.setJSType(getJSType(n.getFirstChild()));\n             break;\n         case Token.COMMA:\n             scope \u003d traverseChildren(n, scope);\n             n.setJSType(getJSType(n.getLastChild()));\n             break;\n         case Token.TYPEOF:\n             scope \u003d traverseChildren(n, scope);\n             n.setJSType(getNativeType(STRING_TYPE));\n             break;\n         case Token.DELPROP:\n         case Token.LT:\n         case Token.LE:\n         case Token.GT:\n         case Token.GE:\n         case Token.NOT:\n         case Token.EQ:\n         case Token.NE:\n         case Token.SHEQ:\n         case Token.SHNE:\n         case Token.INSTANCEOF:\n         case Token.IN:\n             scope \u003d traverseChildren(n, scope);\n             n.setJSType(getNativeType(BOOLEAN_TYPE));\n             break;\n         case Token.GETELEM:\n             scope \u003d traverseGetElem(n, scope);\n             break;\n         case Token.EXPR_RESULT:\n             scope \u003d traverseChildren(n, scope);\n             if (n.getFirstChild().isGetProp()) {\n                 ensurePropertyDeclared(n.getFirstChild());\n             }\n             break;\n         case Token.SWITCH:\n             scope \u003d traverse(n.getFirstChild(), scope);\n             break;\n         case Token.VAR:\n         case Token.RETURN:\n         case Token.THROW:\n             scope \u003d traverseChildren(n, scope);\n             break;\n         case Token.CATCH:\n             scope \u003d traverseCatch(n, scope);\n             break;\n     }\n-    if (n.getType() !\u003d Token.FUNCTION) {\n+    if (!n.isFunction()) {\n         JSDocInfo info \u003d n.getJSDocInfo();\n         if (info !\u003d null \u0026\u0026 info.hasType()) {\n             JSType castType \u003d info.getType().evaluate(syntacticScope, registry);\n             if (n.isQualifiedName() \u0026\u0026 n.getParent().isExprResult()) {\n                 updateScopeForTypeChange(scope, n, n.getJSType(), castType);\n             }\n             n.setJSType(castType);\n         }\n     }\n     return scope;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5524adbda991632656059566b69cc2771ba42b7d": {
      "type": "Ybodychange",
      "commitMessage": "\nRename a couple of AST nodes:\nDEFAULT becomes DEFAULT_CASE\nLP becomes PARAM_LIST\nGET becomes GETTER_DEF\nSET becomes SETTER_DEF\n\nR\u003dnicksantos\nDELTA\u003d215  (40 added, 5 deleted, 170 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3695\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1590 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/11/11, 4:42 PM",
      "commitName": "5524adbda991632656059566b69cc2771ba42b7d",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "11/10/11, 8:36 AM",
      "commitNameOld": "ec324a9bb23eb78c76f537f4c4170ba88d542f1c",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 1.34,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "private FlowScope traverse(Node n, FlowScope scope) {\n    switch(n.getType()) {\n        case Token.ASSIGN:\n            scope \u003d traverseAssign(n, scope);\n            break;\n        case Token.NAME:\n            scope \u003d traverseName(n, scope);\n            break;\n        case Token.GETPROP:\n            scope \u003d traverseGetProp(n, scope);\n            break;\n        case Token.AND:\n            scope \u003d traverseAnd(n, scope).getJoinedFlowScope().createChildFlowScope();\n            break;\n        case Token.OR:\n            scope \u003d traverseOr(n, scope).getJoinedFlowScope().createChildFlowScope();\n            break;\n        case Token.HOOK:\n            scope \u003d traverseHook(n, scope);\n            break;\n        case Token.OBJECTLIT:\n            scope \u003d traverseObjectLiteral(n, scope);\n            break;\n        case Token.CALL:\n            scope \u003d traverseCall(n, scope);\n            break;\n        case Token.NEW:\n            scope \u003d traverseNew(n, scope);\n            break;\n        case Token.ASSIGN_ADD:\n        case Token.ADD:\n            scope \u003d traverseAdd(n, scope);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            scope \u003d traverse(n.getFirstChild(), scope);\n            n.setJSType(getNativeType(NUMBER_TYPE));\n            break;\n        case Token.ARRAYLIT:\n            scope \u003d traverseArrayLiteral(n, scope);\n            break;\n        case Token.THIS:\n            n.setJSType(scope.getTypeOfThis());\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.ASSIGN_URSH:\n        case Token.URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_MUL:\n        case Token.ASSIGN_SUB:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITAND:\n        case Token.BITXOR:\n        case Token.BITOR:\n        case Token.MUL:\n        case Token.SUB:\n        case Token.DEC:\n        case Token.INC:\n        case Token.BITNOT:\n            scope \u003d traverseChildren(n, scope);\n            n.setJSType(getNativeType(NUMBER_TYPE));\n            break;\n        case Token.PARAM_LIST:\n            scope \u003d traverse(n.getFirstChild(), scope);\n            n.setJSType(getJSType(n.getFirstChild()));\n            break;\n        case Token.COMMA:\n            scope \u003d traverseChildren(n, scope);\n            n.setJSType(getJSType(n.getLastChild()));\n            break;\n        case Token.TYPEOF:\n            scope \u003d traverseChildren(n, scope);\n            n.setJSType(getNativeType(STRING_TYPE));\n            break;\n        case Token.DELPROP:\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n        case Token.NOT:\n        case Token.EQ:\n        case Token.NE:\n        case Token.SHEQ:\n        case Token.SHNE:\n        case Token.INSTANCEOF:\n        case Token.IN:\n            scope \u003d traverseChildren(n, scope);\n            n.setJSType(getNativeType(BOOLEAN_TYPE));\n            break;\n        case Token.GETELEM:\n            scope \u003d traverseGetElem(n, scope);\n            break;\n        case Token.EXPR_RESULT:\n            scope \u003d traverseChildren(n, scope);\n            if (n.getFirstChild().isGetProp()) {\n                ensurePropertyDeclared(n.getFirstChild());\n            }\n            break;\n        case Token.SWITCH:\n            scope \u003d traverse(n.getFirstChild(), scope);\n            break;\n        case Token.VAR:\n        case Token.RETURN:\n        case Token.THROW:\n            scope \u003d traverseChildren(n, scope);\n            break;\n        case Token.CATCH:\n            scope \u003d traverseCatch(n, scope);\n            break;\n    }\n    if (n.getType() !\u003d Token.FUNCTION) {\n        JSDocInfo info \u003d n.getJSDocInfo();\n        if (info !\u003d null \u0026\u0026 info.hasType()) {\n            JSType castType \u003d info.getType().evaluate(syntacticScope, registry);\n            if (n.isQualifiedName() \u0026\u0026 n.getParent().isExprResult()) {\n                updateScopeForTypeChange(scope, n, n.getJSType(), castType);\n            }\n            n.setJSType(castType);\n        }\n    }\n    return scope;\n}",
      "path": "src/com/google/javascript/jscomp/TypeInference.java",
      "functionStartLine": 249,
      "functionName": "traverse",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,130 +1,130 @@\n private FlowScope traverse(Node n, FlowScope scope) {\n     switch(n.getType()) {\n         case Token.ASSIGN:\n             scope \u003d traverseAssign(n, scope);\n             break;\n         case Token.NAME:\n             scope \u003d traverseName(n, scope);\n             break;\n         case Token.GETPROP:\n             scope \u003d traverseGetProp(n, scope);\n             break;\n         case Token.AND:\n             scope \u003d traverseAnd(n, scope).getJoinedFlowScope().createChildFlowScope();\n             break;\n         case Token.OR:\n             scope \u003d traverseOr(n, scope).getJoinedFlowScope().createChildFlowScope();\n             break;\n         case Token.HOOK:\n             scope \u003d traverseHook(n, scope);\n             break;\n         case Token.OBJECTLIT:\n             scope \u003d traverseObjectLiteral(n, scope);\n             break;\n         case Token.CALL:\n             scope \u003d traverseCall(n, scope);\n             break;\n         case Token.NEW:\n             scope \u003d traverseNew(n, scope);\n             break;\n         case Token.ASSIGN_ADD:\n         case Token.ADD:\n             scope \u003d traverseAdd(n, scope);\n             break;\n         case Token.POS:\n         case Token.NEG:\n             scope \u003d traverse(n.getFirstChild(), scope);\n             n.setJSType(getNativeType(NUMBER_TYPE));\n             break;\n         case Token.ARRAYLIT:\n             scope \u003d traverseArrayLiteral(n, scope);\n             break;\n         case Token.THIS:\n             n.setJSType(scope.getTypeOfThis());\n             break;\n         case Token.ASSIGN_LSH:\n         case Token.ASSIGN_RSH:\n         case Token.LSH:\n         case Token.RSH:\n         case Token.ASSIGN_URSH:\n         case Token.URSH:\n         case Token.ASSIGN_DIV:\n         case Token.ASSIGN_MOD:\n         case Token.ASSIGN_BITAND:\n         case Token.ASSIGN_BITXOR:\n         case Token.ASSIGN_BITOR:\n         case Token.ASSIGN_MUL:\n         case Token.ASSIGN_SUB:\n         case Token.DIV:\n         case Token.MOD:\n         case Token.BITAND:\n         case Token.BITXOR:\n         case Token.BITOR:\n         case Token.MUL:\n         case Token.SUB:\n         case Token.DEC:\n         case Token.INC:\n         case Token.BITNOT:\n             scope \u003d traverseChildren(n, scope);\n             n.setJSType(getNativeType(NUMBER_TYPE));\n             break;\n-        case Token.LP:\n+        case Token.PARAM_LIST:\n             scope \u003d traverse(n.getFirstChild(), scope);\n             n.setJSType(getJSType(n.getFirstChild()));\n             break;\n         case Token.COMMA:\n             scope \u003d traverseChildren(n, scope);\n             n.setJSType(getJSType(n.getLastChild()));\n             break;\n         case Token.TYPEOF:\n             scope \u003d traverseChildren(n, scope);\n             n.setJSType(getNativeType(STRING_TYPE));\n             break;\n         case Token.DELPROP:\n         case Token.LT:\n         case Token.LE:\n         case Token.GT:\n         case Token.GE:\n         case Token.NOT:\n         case Token.EQ:\n         case Token.NE:\n         case Token.SHEQ:\n         case Token.SHNE:\n         case Token.INSTANCEOF:\n         case Token.IN:\n             scope \u003d traverseChildren(n, scope);\n             n.setJSType(getNativeType(BOOLEAN_TYPE));\n             break;\n         case Token.GETELEM:\n             scope \u003d traverseGetElem(n, scope);\n             break;\n         case Token.EXPR_RESULT:\n             scope \u003d traverseChildren(n, scope);\n             if (n.getFirstChild().isGetProp()) {\n                 ensurePropertyDeclared(n.getFirstChild());\n             }\n             break;\n         case Token.SWITCH:\n             scope \u003d traverse(n.getFirstChild(), scope);\n             break;\n         case Token.VAR:\n         case Token.RETURN:\n         case Token.THROW:\n             scope \u003d traverseChildren(n, scope);\n             break;\n         case Token.CATCH:\n             scope \u003d traverseCatch(n, scope);\n             break;\n     }\n     if (n.getType() !\u003d Token.FUNCTION) {\n         JSDocInfo info \u003d n.getJSDocInfo();\n         if (info !\u003d null \u0026\u0026 info.hasType()) {\n             JSType castType \u003d info.getType().evaluate(syntacticScope, registry);\n             if (n.isQualifiedName() \u0026\u0026 n.getParent().isExprResult()) {\n                 updateScopeForTypeChange(scope, n, n.getJSType(), castType);\n             }\n             n.setJSType(castType);\n         }\n     }\n     return scope;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ec324a9bb23eb78c76f537f4c4170ba88d542f1c": {
      "type": "Ybodychange",
      "commitMessage": "\nReplace the bulk of the Node.getType() \u003d\u003d Token.XXX calls with\nNode.isXXX calls.\n\nR\u003dnicksantos\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3677\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1582 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/10/11, 8:36 AM",
      "commitName": "ec324a9bb23eb78c76f537f4c4170ba88d542f1c",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "11/7/11, 2:21 PM",
      "commitNameOld": "6641663fa9970c4d7bcdd96a6f31b83b18c3ee3d",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 2.76,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "actualSource": "private FlowScope traverse(Node n, FlowScope scope) {\n    switch(n.getType()) {\n        case Token.ASSIGN:\n            scope \u003d traverseAssign(n, scope);\n            break;\n        case Token.NAME:\n            scope \u003d traverseName(n, scope);\n            break;\n        case Token.GETPROP:\n            scope \u003d traverseGetProp(n, scope);\n            break;\n        case Token.AND:\n            scope \u003d traverseAnd(n, scope).getJoinedFlowScope().createChildFlowScope();\n            break;\n        case Token.OR:\n            scope \u003d traverseOr(n, scope).getJoinedFlowScope().createChildFlowScope();\n            break;\n        case Token.HOOK:\n            scope \u003d traverseHook(n, scope);\n            break;\n        case Token.OBJECTLIT:\n            scope \u003d traverseObjectLiteral(n, scope);\n            break;\n        case Token.CALL:\n            scope \u003d traverseCall(n, scope);\n            break;\n        case Token.NEW:\n            scope \u003d traverseNew(n, scope);\n            break;\n        case Token.ASSIGN_ADD:\n        case Token.ADD:\n            scope \u003d traverseAdd(n, scope);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            scope \u003d traverse(n.getFirstChild(), scope);\n            n.setJSType(getNativeType(NUMBER_TYPE));\n            break;\n        case Token.ARRAYLIT:\n            scope \u003d traverseArrayLiteral(n, scope);\n            break;\n        case Token.THIS:\n            n.setJSType(scope.getTypeOfThis());\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.ASSIGN_URSH:\n        case Token.URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_MUL:\n        case Token.ASSIGN_SUB:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITAND:\n        case Token.BITXOR:\n        case Token.BITOR:\n        case Token.MUL:\n        case Token.SUB:\n        case Token.DEC:\n        case Token.INC:\n        case Token.BITNOT:\n            scope \u003d traverseChildren(n, scope);\n            n.setJSType(getNativeType(NUMBER_TYPE));\n            break;\n        case Token.LP:\n            scope \u003d traverse(n.getFirstChild(), scope);\n            n.setJSType(getJSType(n.getFirstChild()));\n            break;\n        case Token.COMMA:\n            scope \u003d traverseChildren(n, scope);\n            n.setJSType(getJSType(n.getLastChild()));\n            break;\n        case Token.TYPEOF:\n            scope \u003d traverseChildren(n, scope);\n            n.setJSType(getNativeType(STRING_TYPE));\n            break;\n        case Token.DELPROP:\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n        case Token.NOT:\n        case Token.EQ:\n        case Token.NE:\n        case Token.SHEQ:\n        case Token.SHNE:\n        case Token.INSTANCEOF:\n        case Token.IN:\n            scope \u003d traverseChildren(n, scope);\n            n.setJSType(getNativeType(BOOLEAN_TYPE));\n            break;\n        case Token.GETELEM:\n            scope \u003d traverseGetElem(n, scope);\n            break;\n        case Token.EXPR_RESULT:\n            scope \u003d traverseChildren(n, scope);\n            if (n.getFirstChild().isGetProp()) {\n                ensurePropertyDeclared(n.getFirstChild());\n            }\n            break;\n        case Token.SWITCH:\n            scope \u003d traverse(n.getFirstChild(), scope);\n            break;\n        case Token.VAR:\n        case Token.RETURN:\n        case Token.THROW:\n            scope \u003d traverseChildren(n, scope);\n            break;\n        case Token.CATCH:\n            scope \u003d traverseCatch(n, scope);\n            break;\n    }\n    if (n.getType() !\u003d Token.FUNCTION) {\n        JSDocInfo info \u003d n.getJSDocInfo();\n        if (info !\u003d null \u0026\u0026 info.hasType()) {\n            JSType castType \u003d info.getType().evaluate(syntacticScope, registry);\n            if (n.isQualifiedName() \u0026\u0026 n.getParent().isExprResult()) {\n                updateScopeForTypeChange(scope, n, n.getJSType(), castType);\n            }\n            n.setJSType(castType);\n        }\n    }\n    return scope;\n}",
      "path": "src/com/google/javascript/jscomp/TypeInference.java",
      "functionStartLine": 249,
      "functionName": "traverse",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,130 +1,130 @@\n private FlowScope traverse(Node n, FlowScope scope) {\n     switch(n.getType()) {\n         case Token.ASSIGN:\n             scope \u003d traverseAssign(n, scope);\n             break;\n         case Token.NAME:\n             scope \u003d traverseName(n, scope);\n             break;\n         case Token.GETPROP:\n             scope \u003d traverseGetProp(n, scope);\n             break;\n         case Token.AND:\n             scope \u003d traverseAnd(n, scope).getJoinedFlowScope().createChildFlowScope();\n             break;\n         case Token.OR:\n             scope \u003d traverseOr(n, scope).getJoinedFlowScope().createChildFlowScope();\n             break;\n         case Token.HOOK:\n             scope \u003d traverseHook(n, scope);\n             break;\n         case Token.OBJECTLIT:\n             scope \u003d traverseObjectLiteral(n, scope);\n             break;\n         case Token.CALL:\n             scope \u003d traverseCall(n, scope);\n             break;\n         case Token.NEW:\n             scope \u003d traverseNew(n, scope);\n             break;\n         case Token.ASSIGN_ADD:\n         case Token.ADD:\n             scope \u003d traverseAdd(n, scope);\n             break;\n         case Token.POS:\n         case Token.NEG:\n             scope \u003d traverse(n.getFirstChild(), scope);\n             n.setJSType(getNativeType(NUMBER_TYPE));\n             break;\n         case Token.ARRAYLIT:\n             scope \u003d traverseArrayLiteral(n, scope);\n             break;\n         case Token.THIS:\n             n.setJSType(scope.getTypeOfThis());\n             break;\n         case Token.ASSIGN_LSH:\n         case Token.ASSIGN_RSH:\n         case Token.LSH:\n         case Token.RSH:\n         case Token.ASSIGN_URSH:\n         case Token.URSH:\n         case Token.ASSIGN_DIV:\n         case Token.ASSIGN_MOD:\n         case Token.ASSIGN_BITAND:\n         case Token.ASSIGN_BITXOR:\n         case Token.ASSIGN_BITOR:\n         case Token.ASSIGN_MUL:\n         case Token.ASSIGN_SUB:\n         case Token.DIV:\n         case Token.MOD:\n         case Token.BITAND:\n         case Token.BITXOR:\n         case Token.BITOR:\n         case Token.MUL:\n         case Token.SUB:\n         case Token.DEC:\n         case Token.INC:\n         case Token.BITNOT:\n             scope \u003d traverseChildren(n, scope);\n             n.setJSType(getNativeType(NUMBER_TYPE));\n             break;\n         case Token.LP:\n             scope \u003d traverse(n.getFirstChild(), scope);\n             n.setJSType(getJSType(n.getFirstChild()));\n             break;\n         case Token.COMMA:\n             scope \u003d traverseChildren(n, scope);\n             n.setJSType(getJSType(n.getLastChild()));\n             break;\n         case Token.TYPEOF:\n             scope \u003d traverseChildren(n, scope);\n             n.setJSType(getNativeType(STRING_TYPE));\n             break;\n         case Token.DELPROP:\n         case Token.LT:\n         case Token.LE:\n         case Token.GT:\n         case Token.GE:\n         case Token.NOT:\n         case Token.EQ:\n         case Token.NE:\n         case Token.SHEQ:\n         case Token.SHNE:\n         case Token.INSTANCEOF:\n         case Token.IN:\n             scope \u003d traverseChildren(n, scope);\n             n.setJSType(getNativeType(BOOLEAN_TYPE));\n             break;\n         case Token.GETELEM:\n             scope \u003d traverseGetElem(n, scope);\n             break;\n         case Token.EXPR_RESULT:\n             scope \u003d traverseChildren(n, scope);\n-            if (n.getFirstChild().getType() \u003d\u003d Token.GETPROP) {\n+            if (n.getFirstChild().isGetProp()) {\n                 ensurePropertyDeclared(n.getFirstChild());\n             }\n             break;\n         case Token.SWITCH:\n             scope \u003d traverse(n.getFirstChild(), scope);\n             break;\n         case Token.VAR:\n         case Token.RETURN:\n         case Token.THROW:\n             scope \u003d traverseChildren(n, scope);\n             break;\n         case Token.CATCH:\n             scope \u003d traverseCatch(n, scope);\n             break;\n     }\n     if (n.getType() !\u003d Token.FUNCTION) {\n         JSDocInfo info \u003d n.getJSDocInfo();\n         if (info !\u003d null \u0026\u0026 info.hasType()) {\n             JSType castType \u003d info.getType().evaluate(syntacticScope, registry);\n-            if (n.isQualifiedName() \u0026\u0026 n.getParent().getType() \u003d\u003d Token.EXPR_RESULT) {\n+            if (n.isQualifiedName() \u0026\u0026 n.getParent().isExprResult()) {\n                 updateScopeForTypeChange(scope, n, n.getJSType(), castType);\n             }\n             n.setJSType(castType);\n         }\n     }\n     return scope;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6641663fa9970c4d7bcdd96a6f31b83b18c3ee3d": {
      "type": "Ybodychange",
      "commitMessage": "\nRemove unused Token ids.\n\nR\u003dnicksantos\nDELTA\u003d1258  (4 added, 1244 deleted, 10 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3647\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1562 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/7/11, 2:21 PM",
      "commitName": "6641663fa9970c4d7bcdd96a6f31b83b18c3ee3d",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "10/13/11, 1:38 PM",
      "commitNameOld": "e5a39d3f2708e35fe6688446d25b26e76b71e25b",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 25.07,
      "commitsBetweenForRepo": 41,
      "commitsBetweenForFile": 1,
      "actualSource": "private FlowScope traverse(Node n, FlowScope scope) {\n    switch(n.getType()) {\n        case Token.ASSIGN:\n            scope \u003d traverseAssign(n, scope);\n            break;\n        case Token.NAME:\n            scope \u003d traverseName(n, scope);\n            break;\n        case Token.GETPROP:\n            scope \u003d traverseGetProp(n, scope);\n            break;\n        case Token.AND:\n            scope \u003d traverseAnd(n, scope).getJoinedFlowScope().createChildFlowScope();\n            break;\n        case Token.OR:\n            scope \u003d traverseOr(n, scope).getJoinedFlowScope().createChildFlowScope();\n            break;\n        case Token.HOOK:\n            scope \u003d traverseHook(n, scope);\n            break;\n        case Token.OBJECTLIT:\n            scope \u003d traverseObjectLiteral(n, scope);\n            break;\n        case Token.CALL:\n            scope \u003d traverseCall(n, scope);\n            break;\n        case Token.NEW:\n            scope \u003d traverseNew(n, scope);\n            break;\n        case Token.ASSIGN_ADD:\n        case Token.ADD:\n            scope \u003d traverseAdd(n, scope);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            scope \u003d traverse(n.getFirstChild(), scope);\n            n.setJSType(getNativeType(NUMBER_TYPE));\n            break;\n        case Token.ARRAYLIT:\n            scope \u003d traverseArrayLiteral(n, scope);\n            break;\n        case Token.THIS:\n            n.setJSType(scope.getTypeOfThis());\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.ASSIGN_URSH:\n        case Token.URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_MUL:\n        case Token.ASSIGN_SUB:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITAND:\n        case Token.BITXOR:\n        case Token.BITOR:\n        case Token.MUL:\n        case Token.SUB:\n        case Token.DEC:\n        case Token.INC:\n        case Token.BITNOT:\n            scope \u003d traverseChildren(n, scope);\n            n.setJSType(getNativeType(NUMBER_TYPE));\n            break;\n        case Token.LP:\n            scope \u003d traverse(n.getFirstChild(), scope);\n            n.setJSType(getJSType(n.getFirstChild()));\n            break;\n        case Token.COMMA:\n            scope \u003d traverseChildren(n, scope);\n            n.setJSType(getJSType(n.getLastChild()));\n            break;\n        case Token.TYPEOF:\n            scope \u003d traverseChildren(n, scope);\n            n.setJSType(getNativeType(STRING_TYPE));\n            break;\n        case Token.DELPROP:\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n        case Token.NOT:\n        case Token.EQ:\n        case Token.NE:\n        case Token.SHEQ:\n        case Token.SHNE:\n        case Token.INSTANCEOF:\n        case Token.IN:\n            scope \u003d traverseChildren(n, scope);\n            n.setJSType(getNativeType(BOOLEAN_TYPE));\n            break;\n        case Token.GETELEM:\n            scope \u003d traverseGetElem(n, scope);\n            break;\n        case Token.EXPR_RESULT:\n            scope \u003d traverseChildren(n, scope);\n            if (n.getFirstChild().getType() \u003d\u003d Token.GETPROP) {\n                ensurePropertyDeclared(n.getFirstChild());\n            }\n            break;\n        case Token.SWITCH:\n            scope \u003d traverse(n.getFirstChild(), scope);\n            break;\n        case Token.VAR:\n        case Token.RETURN:\n        case Token.THROW:\n            scope \u003d traverseChildren(n, scope);\n            break;\n        case Token.CATCH:\n            scope \u003d traverseCatch(n, scope);\n            break;\n    }\n    if (n.getType() !\u003d Token.FUNCTION) {\n        JSDocInfo info \u003d n.getJSDocInfo();\n        if (info !\u003d null \u0026\u0026 info.hasType()) {\n            JSType castType \u003d info.getType().evaluate(syntacticScope, registry);\n            if (n.isQualifiedName() \u0026\u0026 n.getParent().getType() \u003d\u003d Token.EXPR_RESULT) {\n                updateScopeForTypeChange(scope, n, n.getJSType(), castType);\n            }\n            n.setJSType(castType);\n        }\n    }\n    return scope;\n}",
      "path": "src/com/google/javascript/jscomp/TypeInference.java",
      "functionStartLine": 249,
      "functionName": "traverse",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,131 +1,130 @@\n private FlowScope traverse(Node n, FlowScope scope) {\n     switch(n.getType()) {\n         case Token.ASSIGN:\n             scope \u003d traverseAssign(n, scope);\n             break;\n         case Token.NAME:\n             scope \u003d traverseName(n, scope);\n             break;\n         case Token.GETPROP:\n             scope \u003d traverseGetProp(n, scope);\n             break;\n         case Token.AND:\n             scope \u003d traverseAnd(n, scope).getJoinedFlowScope().createChildFlowScope();\n             break;\n         case Token.OR:\n             scope \u003d traverseOr(n, scope).getJoinedFlowScope().createChildFlowScope();\n             break;\n         case Token.HOOK:\n             scope \u003d traverseHook(n, scope);\n             break;\n         case Token.OBJECTLIT:\n             scope \u003d traverseObjectLiteral(n, scope);\n             break;\n         case Token.CALL:\n             scope \u003d traverseCall(n, scope);\n             break;\n         case Token.NEW:\n             scope \u003d traverseNew(n, scope);\n             break;\n         case Token.ASSIGN_ADD:\n         case Token.ADD:\n             scope \u003d traverseAdd(n, scope);\n             break;\n         case Token.POS:\n         case Token.NEG:\n             scope \u003d traverse(n.getFirstChild(), scope);\n             n.setJSType(getNativeType(NUMBER_TYPE));\n             break;\n         case Token.ARRAYLIT:\n             scope \u003d traverseArrayLiteral(n, scope);\n             break;\n         case Token.THIS:\n             n.setJSType(scope.getTypeOfThis());\n             break;\n         case Token.ASSIGN_LSH:\n         case Token.ASSIGN_RSH:\n         case Token.LSH:\n         case Token.RSH:\n         case Token.ASSIGN_URSH:\n         case Token.URSH:\n         case Token.ASSIGN_DIV:\n         case Token.ASSIGN_MOD:\n         case Token.ASSIGN_BITAND:\n         case Token.ASSIGN_BITXOR:\n         case Token.ASSIGN_BITOR:\n         case Token.ASSIGN_MUL:\n         case Token.ASSIGN_SUB:\n         case Token.DIV:\n         case Token.MOD:\n         case Token.BITAND:\n         case Token.BITXOR:\n         case Token.BITOR:\n         case Token.MUL:\n         case Token.SUB:\n         case Token.DEC:\n         case Token.INC:\n         case Token.BITNOT:\n             scope \u003d traverseChildren(n, scope);\n             n.setJSType(getNativeType(NUMBER_TYPE));\n             break;\n         case Token.LP:\n-        case Token.GET_REF:\n             scope \u003d traverse(n.getFirstChild(), scope);\n             n.setJSType(getJSType(n.getFirstChild()));\n             break;\n         case Token.COMMA:\n             scope \u003d traverseChildren(n, scope);\n             n.setJSType(getJSType(n.getLastChild()));\n             break;\n         case Token.TYPEOF:\n             scope \u003d traverseChildren(n, scope);\n             n.setJSType(getNativeType(STRING_TYPE));\n             break;\n         case Token.DELPROP:\n         case Token.LT:\n         case Token.LE:\n         case Token.GT:\n         case Token.GE:\n         case Token.NOT:\n         case Token.EQ:\n         case Token.NE:\n         case Token.SHEQ:\n         case Token.SHNE:\n         case Token.INSTANCEOF:\n         case Token.IN:\n             scope \u003d traverseChildren(n, scope);\n             n.setJSType(getNativeType(BOOLEAN_TYPE));\n             break;\n         case Token.GETELEM:\n             scope \u003d traverseGetElem(n, scope);\n             break;\n         case Token.EXPR_RESULT:\n             scope \u003d traverseChildren(n, scope);\n             if (n.getFirstChild().getType() \u003d\u003d Token.GETPROP) {\n                 ensurePropertyDeclared(n.getFirstChild());\n             }\n             break;\n         case Token.SWITCH:\n             scope \u003d traverse(n.getFirstChild(), scope);\n             break;\n         case Token.VAR:\n         case Token.RETURN:\n         case Token.THROW:\n             scope \u003d traverseChildren(n, scope);\n             break;\n         case Token.CATCH:\n             scope \u003d traverseCatch(n, scope);\n             break;\n     }\n     if (n.getType() !\u003d Token.FUNCTION) {\n         JSDocInfo info \u003d n.getJSDocInfo();\n         if (info !\u003d null \u0026\u0026 info.hasType()) {\n             JSType castType \u003d info.getType().evaluate(syntacticScope, registry);\n             if (n.isQualifiedName() \u0026\u0026 n.getParent().getType() \u003d\u003d Token.EXPR_RESULT) {\n                 updateScopeForTypeChange(scope, n, n.getJSType(), castType);\n             }\n             n.setJSType(castType);\n         }\n     }\n     return scope;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1c5d6203ab1152a6dee19149fdca2ecd1d8f585f": {
      "type": "Ybodychange",
      "commitMessage": "\ntype inference in the delete operator\n\nR\u003djohnlenz\nDELTA\u003d34  (28 added, 0 deleted, 6 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d717\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@840 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "3/1/11, 5:40 PM",
      "commitName": "1c5d6203ab1152a6dee19149fdca2ecd1d8f585f",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "1/28/11, 10:24 AM",
      "commitNameOld": "06484feebf8fc124b48eb1c252e57bc4e6f76d6f",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 32.3,
      "commitsBetweenForRepo": 100,
      "commitsBetweenForFile": 1,
      "actualSource": "private FlowScope traverse(Node n, FlowScope scope) {\n    switch(n.getType()) {\n        case Token.ASSIGN:\n            scope \u003d traverseAssign(n, scope);\n            break;\n        case Token.NAME:\n            scope \u003d traverseName(n, scope);\n            break;\n        case Token.GETPROP:\n            scope \u003d traverseGetProp(n, scope);\n            break;\n        case Token.AND:\n            scope \u003d traverseAnd(n, scope).getJoinedFlowScope().createChildFlowScope();\n            break;\n        case Token.OR:\n            scope \u003d traverseOr(n, scope).getJoinedFlowScope().createChildFlowScope();\n            break;\n        case Token.HOOK:\n            scope \u003d traverseHook(n, scope);\n            break;\n        case Token.OBJECTLIT:\n            scope \u003d traverseObjectLiteral(n, scope);\n            break;\n        case Token.CALL:\n            scope \u003d traverseCall(n, scope);\n            break;\n        case Token.NEW:\n            scope \u003d traverseNew(n, scope);\n            break;\n        case Token.ASSIGN_ADD:\n        case Token.ADD:\n            scope \u003d traverseAdd(n, scope);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            scope \u003d traverse(n.getFirstChild(), scope);\n            n.setJSType(getNativeType(NUMBER_TYPE));\n            break;\n        case Token.ARRAYLIT:\n            scope \u003d traverseArrayLiteral(n, scope);\n            break;\n        case Token.THIS:\n            n.setJSType(scope.getTypeOfThis());\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.ASSIGN_URSH:\n        case Token.URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_MUL:\n        case Token.ASSIGN_SUB:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITAND:\n        case Token.BITXOR:\n        case Token.BITOR:\n        case Token.MUL:\n        case Token.SUB:\n        case Token.DEC:\n        case Token.INC:\n        case Token.BITNOT:\n            scope \u003d traverseChildren(n, scope);\n            n.setJSType(getNativeType(NUMBER_TYPE));\n            break;\n        case Token.LP:\n        case Token.GET_REF:\n            scope \u003d traverse(n.getFirstChild(), scope);\n            n.setJSType(getJSType(n.getFirstChild()));\n            break;\n        case Token.COMMA:\n            scope \u003d traverseChildren(n, scope);\n            n.setJSType(getJSType(n.getLastChild()));\n            break;\n        case Token.TYPEOF:\n            scope \u003d traverseChildren(n, scope);\n            n.setJSType(getNativeType(STRING_TYPE));\n            break;\n        case Token.DELPROP:\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n        case Token.NOT:\n        case Token.EQ:\n        case Token.NE:\n        case Token.SHEQ:\n        case Token.SHNE:\n        case Token.INSTANCEOF:\n        case Token.IN:\n            scope \u003d traverseChildren(n, scope);\n            n.setJSType(getNativeType(BOOLEAN_TYPE));\n            break;\n        case Token.GETELEM:\n            scope \u003d traverseGetElem(n, scope);\n            break;\n        case Token.EXPR_RESULT:\n            scope \u003d traverseChildren(n, scope);\n            if (n.getFirstChild().getType() \u003d\u003d Token.GETPROP) {\n                ensurePropertyDeclared(n.getFirstChild());\n            }\n            break;\n        case Token.SWITCH:\n            scope \u003d traverse(n.getFirstChild(), scope);\n            break;\n        case Token.VAR:\n        case Token.RETURN:\n        case Token.THROW:\n            scope \u003d traverseChildren(n, scope);\n            break;\n        case Token.CATCH:\n            scope \u003d traverseCatch(n, scope);\n            break;\n    }\n    if (n.getType() !\u003d Token.FUNCTION) {\n        JSDocInfo info \u003d n.getJSDocInfo();\n        if (info !\u003d null \u0026\u0026 info.hasType()) {\n            JSType castType \u003d info.getType().evaluate(syntacticScope, registry);\n            if (n.isQualifiedName() \u0026\u0026 n.getParent().getType() \u003d\u003d Token.EXPR_RESULT) {\n                updateScopeForTypeChange(scope, n, n.getJSType(), castType);\n            }\n            n.setJSType(castType);\n        }\n    }\n    return scope;\n}",
      "path": "src/com/google/javascript/jscomp/TypeInference.java",
      "functionStartLine": 306,
      "functionName": "traverse",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,130 +1,131 @@\n private FlowScope traverse(Node n, FlowScope scope) {\n     switch(n.getType()) {\n         case Token.ASSIGN:\n             scope \u003d traverseAssign(n, scope);\n             break;\n         case Token.NAME:\n             scope \u003d traverseName(n, scope);\n             break;\n         case Token.GETPROP:\n             scope \u003d traverseGetProp(n, scope);\n             break;\n         case Token.AND:\n             scope \u003d traverseAnd(n, scope).getJoinedFlowScope().createChildFlowScope();\n             break;\n         case Token.OR:\n             scope \u003d traverseOr(n, scope).getJoinedFlowScope().createChildFlowScope();\n             break;\n         case Token.HOOK:\n             scope \u003d traverseHook(n, scope);\n             break;\n         case Token.OBJECTLIT:\n             scope \u003d traverseObjectLiteral(n, scope);\n             break;\n         case Token.CALL:\n             scope \u003d traverseCall(n, scope);\n             break;\n         case Token.NEW:\n             scope \u003d traverseNew(n, scope);\n             break;\n         case Token.ASSIGN_ADD:\n         case Token.ADD:\n             scope \u003d traverseAdd(n, scope);\n             break;\n         case Token.POS:\n         case Token.NEG:\n             scope \u003d traverse(n.getFirstChild(), scope);\n             n.setJSType(getNativeType(NUMBER_TYPE));\n             break;\n         case Token.ARRAYLIT:\n             scope \u003d traverseArrayLiteral(n, scope);\n             break;\n         case Token.THIS:\n             n.setJSType(scope.getTypeOfThis());\n             break;\n         case Token.ASSIGN_LSH:\n         case Token.ASSIGN_RSH:\n         case Token.LSH:\n         case Token.RSH:\n         case Token.ASSIGN_URSH:\n         case Token.URSH:\n         case Token.ASSIGN_DIV:\n         case Token.ASSIGN_MOD:\n         case Token.ASSIGN_BITAND:\n         case Token.ASSIGN_BITXOR:\n         case Token.ASSIGN_BITOR:\n         case Token.ASSIGN_MUL:\n         case Token.ASSIGN_SUB:\n         case Token.DIV:\n         case Token.MOD:\n         case Token.BITAND:\n         case Token.BITXOR:\n         case Token.BITOR:\n         case Token.MUL:\n         case Token.SUB:\n         case Token.DEC:\n         case Token.INC:\n         case Token.BITNOT:\n             scope \u003d traverseChildren(n, scope);\n             n.setJSType(getNativeType(NUMBER_TYPE));\n             break;\n         case Token.LP:\n         case Token.GET_REF:\n             scope \u003d traverse(n.getFirstChild(), scope);\n             n.setJSType(getJSType(n.getFirstChild()));\n             break;\n         case Token.COMMA:\n             scope \u003d traverseChildren(n, scope);\n             n.setJSType(getJSType(n.getLastChild()));\n             break;\n         case Token.TYPEOF:\n             scope \u003d traverseChildren(n, scope);\n             n.setJSType(getNativeType(STRING_TYPE));\n             break;\n+        case Token.DELPROP:\n         case Token.LT:\n         case Token.LE:\n         case Token.GT:\n         case Token.GE:\n         case Token.NOT:\n         case Token.EQ:\n         case Token.NE:\n         case Token.SHEQ:\n         case Token.SHNE:\n         case Token.INSTANCEOF:\n         case Token.IN:\n             scope \u003d traverseChildren(n, scope);\n             n.setJSType(getNativeType(BOOLEAN_TYPE));\n             break;\n         case Token.GETELEM:\n             scope \u003d traverseGetElem(n, scope);\n             break;\n         case Token.EXPR_RESULT:\n             scope \u003d traverseChildren(n, scope);\n             if (n.getFirstChild().getType() \u003d\u003d Token.GETPROP) {\n                 ensurePropertyDeclared(n.getFirstChild());\n             }\n             break;\n         case Token.SWITCH:\n             scope \u003d traverse(n.getFirstChild(), scope);\n             break;\n         case Token.VAR:\n         case Token.RETURN:\n         case Token.THROW:\n             scope \u003d traverseChildren(n, scope);\n             break;\n         case Token.CATCH:\n             scope \u003d traverseCatch(n, scope);\n             break;\n     }\n     if (n.getType() !\u003d Token.FUNCTION) {\n         JSDocInfo info \u003d n.getJSDocInfo();\n         if (info !\u003d null \u0026\u0026 info.hasType()) {\n             JSType castType \u003d info.getType().evaluate(syntacticScope, registry);\n             if (n.isQualifiedName() \u0026\u0026 n.getParent().getType() \u003d\u003d Token.EXPR_RESULT) {\n                 updateScopeForTypeChange(scope, n, n.getJSType(), castType);\n             }\n             n.setJSType(castType);\n         }\n     }\n     return scope;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b7b201a08e330c9638f52f5dfe824e426a34f2c5": {
      "type": "Ybodychange",
      "commitMessage": "\nAttach types to literals at scope-creation time instead of at\ninference time.\nScope-creation already attaches types to function literals at\nscope-creation type, so this makes the other literals more consistent\nwith function literals.\n\nR\u003djohnlenz\nDELTA\u003d167  (102 added, 53 deleted, 12 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d209649\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@411 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "9/8/10, 12:26 PM",
      "commitName": "b7b201a08e330c9638f52f5dfe824e426a34f2c5",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "8/12/10, 6:02 PM",
      "commitNameOld": "15acafb00636f99295b394145b9b60a5e624ddfa",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 26.77,
      "commitsBetweenForRepo": 52,
      "commitsBetweenForFile": 1,
      "actualSource": "private FlowScope traverse(Node n, FlowScope scope) {\n    switch(n.getType()) {\n        case Token.ASSIGN:\n            scope \u003d traverseAssign(n, scope);\n            break;\n        case Token.NAME:\n            scope \u003d traverseName(n, scope);\n            break;\n        case Token.GETPROP:\n            scope \u003d traverseGetProp(n, scope);\n            break;\n        case Token.AND:\n            scope \u003d traverseAnd(n, scope).getJoinedFlowScope().createChildFlowScope();\n            break;\n        case Token.OR:\n            scope \u003d traverseOr(n, scope).getJoinedFlowScope().createChildFlowScope();\n            break;\n        case Token.HOOK:\n            scope \u003d traverseHook(n, scope);\n            break;\n        case Token.OBJECTLIT:\n            scope \u003d traverseObjectLiteral(n, scope);\n            break;\n        case Token.CALL:\n            scope \u003d traverseCall(n, scope);\n            break;\n        case Token.NEW:\n            scope \u003d traverseNew(n, scope);\n            break;\n        case Token.ASSIGN_ADD:\n        case Token.ADD:\n            scope \u003d traverseAdd(n, scope);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            scope \u003d traverse(n.getFirstChild(), scope);\n            n.setJSType(getNativeType(NUMBER_TYPE));\n            break;\n        case Token.ARRAYLIT:\n            scope \u003d traverseArrayLiteral(n, scope);\n            break;\n        case Token.THIS:\n            n.setJSType(scope.getTypeOfThis());\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.ASSIGN_URSH:\n        case Token.URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_MUL:\n        case Token.ASSIGN_SUB:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITAND:\n        case Token.BITXOR:\n        case Token.BITOR:\n        case Token.MUL:\n        case Token.SUB:\n        case Token.DEC:\n        case Token.INC:\n        case Token.BITNOT:\n            scope \u003d traverseChildren(n, scope);\n            n.setJSType(getNativeType(NUMBER_TYPE));\n            break;\n        case Token.LP:\n        case Token.GET_REF:\n            scope \u003d traverse(n.getFirstChild(), scope);\n            n.setJSType(getJSType(n.getFirstChild()));\n            break;\n        case Token.COMMA:\n            scope \u003d traverseChildren(n, scope);\n            n.setJSType(getJSType(n.getLastChild()));\n            break;\n        case Token.TYPEOF:\n            scope \u003d traverseChildren(n, scope);\n            n.setJSType(getNativeType(STRING_TYPE));\n            break;\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n        case Token.NOT:\n        case Token.EQ:\n        case Token.NE:\n        case Token.SHEQ:\n        case Token.SHNE:\n        case Token.INSTANCEOF:\n        case Token.IN:\n            scope \u003d traverseChildren(n, scope);\n            n.setJSType(getNativeType(BOOLEAN_TYPE));\n            break;\n        case Token.GETELEM:\n            scope \u003d traverseGetElem(n, scope);\n            break;\n        case Token.EXPR_RESULT:\n            scope \u003d traverseChildren(n, scope);\n            if (n.getFirstChild().getType() \u003d\u003d Token.GETPROP) {\n                ensurePropertyDeclared(n.getFirstChild());\n            }\n            break;\n        case Token.SWITCH:\n            scope \u003d traverse(n.getFirstChild(), scope);\n            break;\n        case Token.VAR:\n        case Token.RETURN:\n        case Token.THROW:\n            scope \u003d traverseChildren(n, scope);\n            break;\n        case Token.CATCH:\n            scope \u003d traverseCatch(n, scope);\n            break;\n    }\n    if (n.getType() !\u003d Token.FUNCTION) {\n        JSDocInfo info \u003d n.getJSDocInfo();\n        if (info !\u003d null \u0026\u0026 info.hasType()) {\n            JSType castType \u003d info.getType().evaluate(syntacticScope, registry);\n            if (n.isQualifiedName() \u0026\u0026 n.getParent().getType() \u003d\u003d Token.EXPR_RESULT) {\n                updateScopeForTypeChange(scope, n, n.getJSType(), castType);\n            }\n            n.setJSType(castType);\n        }\n    }\n    return scope;\n}",
      "path": "src/com/google/javascript/jscomp/TypeInference.java",
      "functionStartLine": 284,
      "functionName": "traverse",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,146 +1,130 @@\n private FlowScope traverse(Node n, FlowScope scope) {\n     switch(n.getType()) {\n         case Token.ASSIGN:\n             scope \u003d traverseAssign(n, scope);\n             break;\n         case Token.NAME:\n             scope \u003d traverseName(n, scope);\n             break;\n         case Token.GETPROP:\n             scope \u003d traverseGetProp(n, scope);\n             break;\n         case Token.AND:\n             scope \u003d traverseAnd(n, scope).getJoinedFlowScope().createChildFlowScope();\n             break;\n         case Token.OR:\n             scope \u003d traverseOr(n, scope).getJoinedFlowScope().createChildFlowScope();\n             break;\n         case Token.HOOK:\n             scope \u003d traverseHook(n, scope);\n             break;\n         case Token.OBJECTLIT:\n             scope \u003d traverseObjectLiteral(n, scope);\n             break;\n         case Token.CALL:\n             scope \u003d traverseCall(n, scope);\n             break;\n         case Token.NEW:\n             scope \u003d traverseNew(n, scope);\n             break;\n         case Token.ASSIGN_ADD:\n         case Token.ADD:\n             scope \u003d traverseAdd(n, scope);\n             break;\n         case Token.POS:\n         case Token.NEG:\n             scope \u003d traverse(n.getFirstChild(), scope);\n             n.setJSType(getNativeType(NUMBER_TYPE));\n             break;\n-        case Token.NULL:\n-            n.setJSType(getNativeType(NULL_TYPE));\n-            break;\n-        case Token.VOID:\n-            n.setJSType(getNativeType(VOID_TYPE));\n-            break;\n         case Token.ARRAYLIT:\n             scope \u003d traverseArrayLiteral(n, scope);\n             break;\n-        case Token.REF_SPECIAL:\n-            n.setJSType(getNativeType(UNKNOWN_TYPE));\n-            break;\n-        case Token.REGEXP:\n-            n.setJSType(getNativeType(REGEXP_TYPE));\n-            break;\n         case Token.THIS:\n             n.setJSType(scope.getTypeOfThis());\n             break;\n         case Token.ASSIGN_LSH:\n         case Token.ASSIGN_RSH:\n         case Token.LSH:\n         case Token.RSH:\n         case Token.ASSIGN_URSH:\n         case Token.URSH:\n         case Token.ASSIGN_DIV:\n         case Token.ASSIGN_MOD:\n         case Token.ASSIGN_BITAND:\n         case Token.ASSIGN_BITXOR:\n         case Token.ASSIGN_BITOR:\n         case Token.ASSIGN_MUL:\n         case Token.ASSIGN_SUB:\n         case Token.DIV:\n         case Token.MOD:\n         case Token.BITAND:\n         case Token.BITXOR:\n         case Token.BITOR:\n         case Token.MUL:\n         case Token.SUB:\n         case Token.DEC:\n         case Token.INC:\n         case Token.BITNOT:\n-        case Token.NUMBER:\n             scope \u003d traverseChildren(n, scope);\n             n.setJSType(getNativeType(NUMBER_TYPE));\n             break;\n         case Token.LP:\n         case Token.GET_REF:\n             scope \u003d traverse(n.getFirstChild(), scope);\n             n.setJSType(getJSType(n.getFirstChild()));\n             break;\n         case Token.COMMA:\n             scope \u003d traverseChildren(n, scope);\n             n.setJSType(getJSType(n.getLastChild()));\n             break;\n-        case Token.STRING:\n         case Token.TYPEOF:\n             scope \u003d traverseChildren(n, scope);\n             n.setJSType(getNativeType(STRING_TYPE));\n             break;\n         case Token.LT:\n         case Token.LE:\n         case Token.GT:\n         case Token.GE:\n         case Token.NOT:\n         case Token.EQ:\n         case Token.NE:\n         case Token.SHEQ:\n         case Token.SHNE:\n         case Token.INSTANCEOF:\n         case Token.IN:\n-        case Token.TRUE:\n-        case Token.FALSE:\n             scope \u003d traverseChildren(n, scope);\n             n.setJSType(getNativeType(BOOLEAN_TYPE));\n             break;\n         case Token.GETELEM:\n             scope \u003d traverseGetElem(n, scope);\n             break;\n         case Token.EXPR_RESULT:\n             scope \u003d traverseChildren(n, scope);\n             if (n.getFirstChild().getType() \u003d\u003d Token.GETPROP) {\n                 ensurePropertyDeclared(n.getFirstChild());\n             }\n             break;\n         case Token.SWITCH:\n             scope \u003d traverse(n.getFirstChild(), scope);\n             break;\n         case Token.VAR:\n         case Token.RETURN:\n         case Token.THROW:\n             scope \u003d traverseChildren(n, scope);\n             break;\n         case Token.CATCH:\n             scope \u003d traverseCatch(n, scope);\n             break;\n     }\n     if (n.getType() !\u003d Token.FUNCTION) {\n         JSDocInfo info \u003d n.getJSDocInfo();\n         if (info !\u003d null \u0026\u0026 info.hasType()) {\n             JSType castType \u003d info.getType().evaluate(syntacticScope, registry);\n             if (n.isQualifiedName() \u0026\u0026 n.getParent().getType() \u003d\u003d Token.EXPR_RESULT) {\n                 updateScopeForTypeChange(scope, n, n.getJSType(), castType);\n             }\n             n.setJSType(castType);\n         }\n     }\n     return scope;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c764a46abf211d4677fadc33f7d466e5b14fa088": {
      "type": "Ybodychange",
      "commitMessage": "\nChange on 2010/04/13 by john\n\n        Here is a crazy thought, let\u0027s not require the JSTypeRegistry during\n        parsing.\n\n        There are basically two changes here:\n        1) The IRFactory was looking for enums to seed the JSTypeRegistry, so\n        we do that when we setup for type interence.\n        2) The JSDocParser was checking the types of @defines objects, now do\n        that during ProcessDefines.\n\n        R\u003drobert,mark\n        DELTA\u003d207  (82 added, 89 deleted, 36 changed)\n\nChange on 2010/04/14 by nick\n\n        Add a debugging function for JSType hashcodes.\n        i found this useful, and thought others might too.\n\n        R\u003djohn\n        DELTA\u003d69  (69 added, 0 deleted, 0 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003dfqsoxx\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@183 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/14/10, 9:15 AM",
      "commitName": "c764a46abf211d4677fadc33f7d466e5b14fa088",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "3/18/10, 4:07 PM",
      "commitNameOld": "1f5edbcd2b5b09ec59151137e643d9ce75ef1055",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 26.71,
      "commitsBetweenForRepo": 38,
      "commitsBetweenForFile": 1,
      "actualSource": "private FlowScope traverse(Node n, FlowScope scope) {\n    switch(n.getType()) {\n        case Token.ASSIGN:\n            scope \u003d traverseAssign(n, scope);\n            break;\n        case Token.NAME:\n            scope \u003d traverseName(n, scope);\n            break;\n        case Token.GETPROP:\n            scope \u003d traverseGetProp(n, scope);\n            break;\n        case Token.AND:\n            scope \u003d traverseAnd(n, scope).getJoinedFlowScope().createChildFlowScope();\n            break;\n        case Token.OR:\n            scope \u003d traverseOr(n, scope).getJoinedFlowScope().createChildFlowScope();\n            break;\n        case Token.HOOK:\n            scope \u003d traverseHook(n, scope);\n            break;\n        case Token.OBJECTLIT:\n            scope \u003d traverseObjectLiteral(n, scope);\n            break;\n        case Token.CALL:\n            scope \u003d traverseCall(n, scope);\n            break;\n        case Token.NEW:\n            scope \u003d traverseNew(n, scope);\n            break;\n        case Token.ASSIGN_ADD:\n        case Token.ADD:\n            scope \u003d traverseAdd(n, scope);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            scope \u003d traverse(n.getFirstChild(), scope);\n            n.setJSType(getNativeType(NUMBER_TYPE));\n            break;\n        case Token.NULL:\n            n.setJSType(getNativeType(NULL_TYPE));\n            break;\n        case Token.VOID:\n            n.setJSType(getNativeType(VOID_TYPE));\n            break;\n        case Token.ARRAYLIT:\n            scope \u003d traverseArrayLiteral(n, scope);\n            break;\n        case Token.REF_SPECIAL:\n            n.setJSType(getNativeType(UNKNOWN_TYPE));\n            break;\n        case Token.REGEXP:\n            n.setJSType(getNativeType(REGEXP_TYPE));\n            break;\n        case Token.THIS:\n            n.setJSType(scope.getTypeOfThis());\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.ASSIGN_URSH:\n        case Token.URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_MUL:\n        case Token.ASSIGN_SUB:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITAND:\n        case Token.BITXOR:\n        case Token.BITOR:\n        case Token.MUL:\n        case Token.SUB:\n        case Token.DEC:\n        case Token.INC:\n        case Token.BITNOT:\n        case Token.NUMBER:\n            scope \u003d traverseChildren(n, scope);\n            n.setJSType(getNativeType(NUMBER_TYPE));\n            break;\n        case Token.LP:\n        case Token.GET_REF:\n            scope \u003d traverse(n.getFirstChild(), scope);\n            n.setJSType(getJSType(n.getFirstChild()));\n            break;\n        case Token.COMMA:\n            scope \u003d traverseChildren(n, scope);\n            n.setJSType(getJSType(n.getLastChild()));\n            break;\n        case Token.STRING:\n        case Token.TYPEOF:\n            scope \u003d traverseChildren(n, scope);\n            n.setJSType(getNativeType(STRING_TYPE));\n            break;\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n        case Token.NOT:\n        case Token.EQ:\n        case Token.NE:\n        case Token.SHEQ:\n        case Token.SHNE:\n        case Token.INSTANCEOF:\n        case Token.IN:\n        case Token.TRUE:\n        case Token.FALSE:\n            scope \u003d traverseChildren(n, scope);\n            n.setJSType(getNativeType(BOOLEAN_TYPE));\n            break;\n        case Token.GETELEM:\n            scope \u003d traverseGetElem(n, scope);\n            break;\n        case Token.EXPR_RESULT:\n            scope \u003d traverseChildren(n, scope);\n            if (n.getFirstChild().getType() \u003d\u003d Token.GETPROP) {\n                ensurePropertyDeclared(n.getFirstChild());\n            }\n            break;\n        case Token.SWITCH:\n            scope \u003d traverse(n.getFirstChild(), scope);\n            break;\n        case Token.VAR:\n        case Token.RETURN:\n        case Token.THROW:\n            scope \u003d traverseChildren(n, scope);\n            break;\n        case Token.CATCH:\n            scope \u003d traverseCatch(n, scope);\n            break;\n    }\n    if (n.getType() !\u003d Token.FUNCTION) {\n        JSDocInfo info \u003d n.getJSDocInfo();\n        if (info !\u003d null \u0026\u0026 info.hasType()) {\n            JSType castType \u003d info.getType().evaluate(syntacticScope, registry);\n            if (n.isQualifiedName() \u0026\u0026 n.getParent().getType() \u003d\u003d Token.EXPR_RESULT) {\n                updateScopeForTypeChange(scope, n, n.getJSType(), castType);\n            }\n            n.setJSType(castType);\n        }\n    }\n    return scope;\n}",
      "path": "src/com/google/javascript/jscomp/TypeInference.java",
      "functionStartLine": 278,
      "functionName": "traverse",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,146 +1,146 @@\n private FlowScope traverse(Node n, FlowScope scope) {\n     switch(n.getType()) {\n         case Token.ASSIGN:\n             scope \u003d traverseAssign(n, scope);\n             break;\n         case Token.NAME:\n             scope \u003d traverseName(n, scope);\n             break;\n         case Token.GETPROP:\n             scope \u003d traverseGetProp(n, scope);\n             break;\n         case Token.AND:\n             scope \u003d traverseAnd(n, scope).getJoinedFlowScope().createChildFlowScope();\n             break;\n         case Token.OR:\n             scope \u003d traverseOr(n, scope).getJoinedFlowScope().createChildFlowScope();\n             break;\n         case Token.HOOK:\n             scope \u003d traverseHook(n, scope);\n             break;\n         case Token.OBJECTLIT:\n             scope \u003d traverseObjectLiteral(n, scope);\n             break;\n         case Token.CALL:\n             scope \u003d traverseCall(n, scope);\n             break;\n         case Token.NEW:\n             scope \u003d traverseNew(n, scope);\n             break;\n         case Token.ASSIGN_ADD:\n         case Token.ADD:\n             scope \u003d traverseAdd(n, scope);\n             break;\n         case Token.POS:\n         case Token.NEG:\n             scope \u003d traverse(n.getFirstChild(), scope);\n             n.setJSType(getNativeType(NUMBER_TYPE));\n             break;\n         case Token.NULL:\n             n.setJSType(getNativeType(NULL_TYPE));\n             break;\n         case Token.VOID:\n             n.setJSType(getNativeType(VOID_TYPE));\n             break;\n         case Token.ARRAYLIT:\n             scope \u003d traverseArrayLiteral(n, scope);\n             break;\n         case Token.REF_SPECIAL:\n             n.setJSType(getNativeType(UNKNOWN_TYPE));\n             break;\n         case Token.REGEXP:\n             n.setJSType(getNativeType(REGEXP_TYPE));\n             break;\n         case Token.THIS:\n             n.setJSType(scope.getTypeOfThis());\n             break;\n         case Token.ASSIGN_LSH:\n         case Token.ASSIGN_RSH:\n         case Token.LSH:\n         case Token.RSH:\n         case Token.ASSIGN_URSH:\n         case Token.URSH:\n         case Token.ASSIGN_DIV:\n         case Token.ASSIGN_MOD:\n         case Token.ASSIGN_BITAND:\n         case Token.ASSIGN_BITXOR:\n         case Token.ASSIGN_BITOR:\n         case Token.ASSIGN_MUL:\n         case Token.ASSIGN_SUB:\n         case Token.DIV:\n         case Token.MOD:\n         case Token.BITAND:\n         case Token.BITXOR:\n         case Token.BITOR:\n         case Token.MUL:\n         case Token.SUB:\n         case Token.DEC:\n         case Token.INC:\n         case Token.BITNOT:\n         case Token.NUMBER:\n             scope \u003d traverseChildren(n, scope);\n             n.setJSType(getNativeType(NUMBER_TYPE));\n             break;\n         case Token.LP:\n         case Token.GET_REF:\n             scope \u003d traverse(n.getFirstChild(), scope);\n             n.setJSType(getJSType(n.getFirstChild()));\n             break;\n         case Token.COMMA:\n             scope \u003d traverseChildren(n, scope);\n             n.setJSType(getJSType(n.getLastChild()));\n             break;\n         case Token.STRING:\n         case Token.TYPEOF:\n             scope \u003d traverseChildren(n, scope);\n             n.setJSType(getNativeType(STRING_TYPE));\n             break;\n         case Token.LT:\n         case Token.LE:\n         case Token.GT:\n         case Token.GE:\n         case Token.NOT:\n         case Token.EQ:\n         case Token.NE:\n         case Token.SHEQ:\n         case Token.SHNE:\n         case Token.INSTANCEOF:\n         case Token.IN:\n         case Token.TRUE:\n         case Token.FALSE:\n             scope \u003d traverseChildren(n, scope);\n             n.setJSType(getNativeType(BOOLEAN_TYPE));\n             break;\n         case Token.GETELEM:\n             scope \u003d traverseGetElem(n, scope);\n             break;\n         case Token.EXPR_RESULT:\n             scope \u003d traverseChildren(n, scope);\n             if (n.getFirstChild().getType() \u003d\u003d Token.GETPROP) {\n                 ensurePropertyDeclared(n.getFirstChild());\n             }\n             break;\n         case Token.SWITCH:\n             scope \u003d traverse(n.getFirstChild(), scope);\n             break;\n         case Token.VAR:\n         case Token.RETURN:\n         case Token.THROW:\n             scope \u003d traverseChildren(n, scope);\n             break;\n         case Token.CATCH:\n             scope \u003d traverseCatch(n, scope);\n             break;\n     }\n     if (n.getType() !\u003d Token.FUNCTION) {\n         JSDocInfo info \u003d n.getJSDocInfo();\n         if (info !\u003d null \u0026\u0026 info.hasType()) {\n-            JSType castType \u003d info.getType().evaluate(syntacticScope);\n+            JSType castType \u003d info.getType().evaluate(syntacticScope, registry);\n             if (n.isQualifiedName() \u0026\u0026 n.getParent().getType() \u003d\u003d Token.EXPR_RESULT) {\n                 updateScopeForTypeChange(scope, n, n.getJSType(), castType);\n             }\n             n.setJSType(castType);\n         }\n     }\n     return scope;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "52ecbc65e981b9f169466f8898155bc5f8bfad7a": {
      "type": "Ybodychange",
      "commitMessage": "Add some new externs files: webkit notifications, web storage, and file access.\n\nFix a minor bug in type checking \u0027in\u0027 operators.\n\nFix a bug in warnings filtering.\n\nAdd a @javadispatch annotation.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@81 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "1/28/10, 1:52 PM",
      "commitName": "52ecbc65e981b9f169466f8898155bc5f8bfad7a",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "1/22/10, 12:29 PM",
      "commitNameOld": "9afca869d4236594514b8461d771af9999c8a989",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 6.06,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "private FlowScope traverse(Node n, FlowScope scope) {\n    switch(n.getType()) {\n        case Token.ASSIGN:\n            scope \u003d traverseAssign(n, scope);\n            break;\n        case Token.NAME:\n            scope \u003d traverseName(n, scope);\n            break;\n        case Token.GETPROP:\n            scope \u003d traverseGetProp(n, scope);\n            break;\n        case Token.AND:\n            scope \u003d traverseAnd(n, scope).getJoinedFlowScope().createChildFlowScope();\n            break;\n        case Token.OR:\n            scope \u003d traverseOr(n, scope).getJoinedFlowScope().createChildFlowScope();\n            break;\n        case Token.HOOK:\n            scope \u003d traverseHook(n, scope);\n            break;\n        case Token.OBJECTLIT:\n            scope \u003d traverseObjectLiteral(n, scope);\n            break;\n        case Token.CALL:\n            scope \u003d traverseCall(n, scope);\n            break;\n        case Token.NEW:\n            scope \u003d traverseNew(n, scope);\n            break;\n        case Token.ASSIGN_ADD:\n        case Token.ADD:\n            scope \u003d traverseAdd(n, scope);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            scope \u003d traverse(n.getFirstChild(), scope);\n            n.setJSType(getNativeType(NUMBER_TYPE));\n            break;\n        case Token.NULL:\n            n.setJSType(getNativeType(NULL_TYPE));\n            break;\n        case Token.VOID:\n            n.setJSType(getNativeType(VOID_TYPE));\n            break;\n        case Token.ARRAYLIT:\n            scope \u003d traverseArrayLiteral(n, scope);\n            break;\n        case Token.REF_SPECIAL:\n            n.setJSType(getNativeType(UNKNOWN_TYPE));\n            break;\n        case Token.REGEXP:\n            n.setJSType(getNativeType(REGEXP_TYPE));\n            break;\n        case Token.THIS:\n            n.setJSType(scope.getTypeOfThis());\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.ASSIGN_URSH:\n        case Token.URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_MUL:\n        case Token.ASSIGN_SUB:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITAND:\n        case Token.BITXOR:\n        case Token.BITOR:\n        case Token.MUL:\n        case Token.SUB:\n        case Token.DEC:\n        case Token.INC:\n        case Token.BITNOT:\n        case Token.NUMBER:\n            scope \u003d traverseChildren(n, scope);\n            n.setJSType(getNativeType(NUMBER_TYPE));\n            break;\n        case Token.LP:\n        case Token.GET_REF:\n            scope \u003d traverse(n.getFirstChild(), scope);\n            n.setJSType(getJSType(n.getFirstChild()));\n            break;\n        case Token.COMMA:\n            scope \u003d traverseChildren(n, scope);\n            n.setJSType(getJSType(n.getLastChild()));\n            break;\n        case Token.STRING:\n        case Token.TYPEOF:\n            scope \u003d traverseChildren(n, scope);\n            n.setJSType(getNativeType(STRING_TYPE));\n            break;\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n        case Token.NOT:\n        case Token.EQ:\n        case Token.NE:\n        case Token.SHEQ:\n        case Token.SHNE:\n        case Token.INSTANCEOF:\n        case Token.IN:\n        case Token.TRUE:\n        case Token.FALSE:\n            scope \u003d traverseChildren(n, scope);\n            n.setJSType(getNativeType(BOOLEAN_TYPE));\n            break;\n        case Token.GETELEM:\n            scope \u003d traverseGetElem(n, scope);\n            break;\n        case Token.EXPR_RESULT:\n            scope \u003d traverseChildren(n, scope);\n            if (n.getFirstChild().getType() \u003d\u003d Token.GETPROP) {\n                ensurePropertyDeclared(n.getFirstChild());\n            }\n            break;\n        case Token.SWITCH:\n            scope \u003d traverse(n.getFirstChild(), scope);\n            break;\n        case Token.VAR:\n        case Token.RETURN:\n        case Token.THROW:\n            scope \u003d traverseChildren(n, scope);\n            break;\n        case Token.CATCH:\n            scope \u003d traverseCatch(n, scope);\n            break;\n    }\n    if (n.getType() !\u003d Token.FUNCTION) {\n        JSDocInfo info \u003d n.getJSDocInfo();\n        if (info !\u003d null \u0026\u0026 info.hasType()) {\n            JSType castType \u003d info.getType().evaluate(syntacticScope);\n            if (n.isQualifiedName() \u0026\u0026 n.getParent().getType() \u003d\u003d Token.EXPR_RESULT) {\n                updateScopeForTypeChange(scope, n, n.getJSType(), castType);\n            }\n            n.setJSType(castType);\n        }\n    }\n    return scope;\n}",
      "path": "src/com/google/javascript/jscomp/TypeInference.java",
      "functionStartLine": 232,
      "functionName": "traverse",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,145 +1,146 @@\n private FlowScope traverse(Node n, FlowScope scope) {\n     switch(n.getType()) {\n         case Token.ASSIGN:\n             scope \u003d traverseAssign(n, scope);\n             break;\n         case Token.NAME:\n             scope \u003d traverseName(n, scope);\n             break;\n         case Token.GETPROP:\n             scope \u003d traverseGetProp(n, scope);\n             break;\n         case Token.AND:\n             scope \u003d traverseAnd(n, scope).getJoinedFlowScope().createChildFlowScope();\n             break;\n         case Token.OR:\n             scope \u003d traverseOr(n, scope).getJoinedFlowScope().createChildFlowScope();\n             break;\n         case Token.HOOK:\n             scope \u003d traverseHook(n, scope);\n             break;\n         case Token.OBJECTLIT:\n             scope \u003d traverseObjectLiteral(n, scope);\n             break;\n         case Token.CALL:\n             scope \u003d traverseCall(n, scope);\n             break;\n         case Token.NEW:\n             scope \u003d traverseNew(n, scope);\n             break;\n         case Token.ASSIGN_ADD:\n         case Token.ADD:\n             scope \u003d traverseAdd(n, scope);\n             break;\n         case Token.POS:\n         case Token.NEG:\n             scope \u003d traverse(n.getFirstChild(), scope);\n             n.setJSType(getNativeType(NUMBER_TYPE));\n             break;\n         case Token.NULL:\n             n.setJSType(getNativeType(NULL_TYPE));\n             break;\n         case Token.VOID:\n             n.setJSType(getNativeType(VOID_TYPE));\n             break;\n         case Token.ARRAYLIT:\n             scope \u003d traverseArrayLiteral(n, scope);\n             break;\n         case Token.REF_SPECIAL:\n             n.setJSType(getNativeType(UNKNOWN_TYPE));\n             break;\n         case Token.REGEXP:\n             n.setJSType(getNativeType(REGEXP_TYPE));\n             break;\n         case Token.THIS:\n             n.setJSType(scope.getTypeOfThis());\n             break;\n         case Token.ASSIGN_LSH:\n         case Token.ASSIGN_RSH:\n         case Token.LSH:\n         case Token.RSH:\n         case Token.ASSIGN_URSH:\n         case Token.URSH:\n         case Token.ASSIGN_DIV:\n         case Token.ASSIGN_MOD:\n         case Token.ASSIGN_BITAND:\n         case Token.ASSIGN_BITXOR:\n         case Token.ASSIGN_BITOR:\n         case Token.ASSIGN_MUL:\n         case Token.ASSIGN_SUB:\n         case Token.DIV:\n         case Token.MOD:\n         case Token.BITAND:\n         case Token.BITXOR:\n         case Token.BITOR:\n         case Token.MUL:\n         case Token.SUB:\n         case Token.DEC:\n         case Token.INC:\n         case Token.BITNOT:\n         case Token.NUMBER:\n             scope \u003d traverseChildren(n, scope);\n             n.setJSType(getNativeType(NUMBER_TYPE));\n             break;\n         case Token.LP:\n         case Token.GET_REF:\n             scope \u003d traverse(n.getFirstChild(), scope);\n             n.setJSType(getJSType(n.getFirstChild()));\n             break;\n         case Token.COMMA:\n             scope \u003d traverseChildren(n, scope);\n             n.setJSType(getJSType(n.getLastChild()));\n             break;\n         case Token.STRING:\n         case Token.TYPEOF:\n             scope \u003d traverseChildren(n, scope);\n             n.setJSType(getNativeType(STRING_TYPE));\n             break;\n         case Token.LT:\n         case Token.LE:\n         case Token.GT:\n         case Token.GE:\n         case Token.NOT:\n         case Token.EQ:\n         case Token.NE:\n         case Token.SHEQ:\n         case Token.SHNE:\n         case Token.INSTANCEOF:\n+        case Token.IN:\n         case Token.TRUE:\n         case Token.FALSE:\n             scope \u003d traverseChildren(n, scope);\n             n.setJSType(getNativeType(BOOLEAN_TYPE));\n             break;\n         case Token.GETELEM:\n             scope \u003d traverseGetElem(n, scope);\n             break;\n         case Token.EXPR_RESULT:\n             scope \u003d traverseChildren(n, scope);\n             if (n.getFirstChild().getType() \u003d\u003d Token.GETPROP) {\n                 ensurePropertyDeclared(n.getFirstChild());\n             }\n             break;\n         case Token.SWITCH:\n             scope \u003d traverse(n.getFirstChild(), scope);\n             break;\n         case Token.VAR:\n         case Token.RETURN:\n         case Token.THROW:\n             scope \u003d traverseChildren(n, scope);\n             break;\n         case Token.CATCH:\n             scope \u003d traverseCatch(n, scope);\n             break;\n     }\n     if (n.getType() !\u003d Token.FUNCTION) {\n         JSDocInfo info \u003d n.getJSDocInfo();\n         if (info !\u003d null \u0026\u0026 info.hasType()) {\n             JSType castType \u003d info.getType().evaluate(syntacticScope);\n             if (n.isQualifiedName() \u0026\u0026 n.getParent().getType() \u003d\u003d Token.EXPR_RESULT) {\n                 updateScopeForTypeChange(scope, n, n.getJSType(), castType);\n             }\n             n.setJSType(castType);\n         }\n     }\n     return scope;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9afca869d4236594514b8461d771af9999c8a989": {
      "type": "Ybodychange",
      "commitMessage": "Better type checking for switch/case conditions.\n\nCustomizable input delimiters.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@75 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "1/22/10, 12:29 PM",
      "commitName": "9afca869d4236594514b8461d771af9999c8a989",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "1/4/10, 12:18 PM",
      "commitNameOld": "77b7c78d4aeeb6471f2f668a06c0f61a68f95ccd",
      "commitAuthorOld": "nicholas.j.santos@gmail.com",
      "daysBetweenCommits": 18.01,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "actualSource": "private FlowScope traverse(Node n, FlowScope scope) {\n    switch(n.getType()) {\n        case Token.ASSIGN:\n            scope \u003d traverseAssign(n, scope);\n            break;\n        case Token.NAME:\n            scope \u003d traverseName(n, scope);\n            break;\n        case Token.GETPROP:\n            scope \u003d traverseGetProp(n, scope);\n            break;\n        case Token.AND:\n            scope \u003d traverseAnd(n, scope).getJoinedFlowScope().createChildFlowScope();\n            break;\n        case Token.OR:\n            scope \u003d traverseOr(n, scope).getJoinedFlowScope().createChildFlowScope();\n            break;\n        case Token.HOOK:\n            scope \u003d traverseHook(n, scope);\n            break;\n        case Token.OBJECTLIT:\n            scope \u003d traverseObjectLiteral(n, scope);\n            break;\n        case Token.CALL:\n            scope \u003d traverseCall(n, scope);\n            break;\n        case Token.NEW:\n            scope \u003d traverseNew(n, scope);\n            break;\n        case Token.ASSIGN_ADD:\n        case Token.ADD:\n            scope \u003d traverseAdd(n, scope);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            scope \u003d traverse(n.getFirstChild(), scope);\n            n.setJSType(getNativeType(NUMBER_TYPE));\n            break;\n        case Token.NULL:\n            n.setJSType(getNativeType(NULL_TYPE));\n            break;\n        case Token.VOID:\n            n.setJSType(getNativeType(VOID_TYPE));\n            break;\n        case Token.ARRAYLIT:\n            scope \u003d traverseArrayLiteral(n, scope);\n            break;\n        case Token.REF_SPECIAL:\n            n.setJSType(getNativeType(UNKNOWN_TYPE));\n            break;\n        case Token.REGEXP:\n            n.setJSType(getNativeType(REGEXP_TYPE));\n            break;\n        case Token.THIS:\n            n.setJSType(scope.getTypeOfThis());\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.ASSIGN_URSH:\n        case Token.URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_MUL:\n        case Token.ASSIGN_SUB:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITAND:\n        case Token.BITXOR:\n        case Token.BITOR:\n        case Token.MUL:\n        case Token.SUB:\n        case Token.DEC:\n        case Token.INC:\n        case Token.BITNOT:\n        case Token.NUMBER:\n            scope \u003d traverseChildren(n, scope);\n            n.setJSType(getNativeType(NUMBER_TYPE));\n            break;\n        case Token.LP:\n        case Token.GET_REF:\n            scope \u003d traverse(n.getFirstChild(), scope);\n            n.setJSType(getJSType(n.getFirstChild()));\n            break;\n        case Token.COMMA:\n            scope \u003d traverseChildren(n, scope);\n            n.setJSType(getJSType(n.getLastChild()));\n            break;\n        case Token.STRING:\n        case Token.TYPEOF:\n            scope \u003d traverseChildren(n, scope);\n            n.setJSType(getNativeType(STRING_TYPE));\n            break;\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n        case Token.NOT:\n        case Token.EQ:\n        case Token.NE:\n        case Token.SHEQ:\n        case Token.SHNE:\n        case Token.INSTANCEOF:\n        case Token.TRUE:\n        case Token.FALSE:\n            scope \u003d traverseChildren(n, scope);\n            n.setJSType(getNativeType(BOOLEAN_TYPE));\n            break;\n        case Token.GETELEM:\n            scope \u003d traverseGetElem(n, scope);\n            break;\n        case Token.EXPR_RESULT:\n            scope \u003d traverseChildren(n, scope);\n            if (n.getFirstChild().getType() \u003d\u003d Token.GETPROP) {\n                ensurePropertyDeclared(n.getFirstChild());\n            }\n            break;\n        case Token.SWITCH:\n            scope \u003d traverse(n.getFirstChild(), scope);\n            break;\n        case Token.VAR:\n        case Token.RETURN:\n        case Token.THROW:\n            scope \u003d traverseChildren(n, scope);\n            break;\n        case Token.CATCH:\n            scope \u003d traverseCatch(n, scope);\n            break;\n    }\n    if (n.getType() !\u003d Token.FUNCTION) {\n        JSDocInfo info \u003d n.getJSDocInfo();\n        if (info !\u003d null \u0026\u0026 info.hasType()) {\n            JSType castType \u003d info.getType().evaluate(syntacticScope);\n            if (n.isQualifiedName() \u0026\u0026 n.getParent().getType() \u003d\u003d Token.EXPR_RESULT) {\n                updateScopeForTypeChange(scope, n, n.getJSType(), castType);\n            }\n            n.setJSType(castType);\n        }\n    }\n    return scope;\n}",
      "path": "src/com/google/javascript/jscomp/TypeInference.java",
      "functionStartLine": 232,
      "functionName": "traverse",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,142 +1,145 @@\n private FlowScope traverse(Node n, FlowScope scope) {\n     switch(n.getType()) {\n         case Token.ASSIGN:\n             scope \u003d traverseAssign(n, scope);\n             break;\n         case Token.NAME:\n             scope \u003d traverseName(n, scope);\n             break;\n         case Token.GETPROP:\n             scope \u003d traverseGetProp(n, scope);\n             break;\n         case Token.AND:\n             scope \u003d traverseAnd(n, scope).getJoinedFlowScope().createChildFlowScope();\n             break;\n         case Token.OR:\n             scope \u003d traverseOr(n, scope).getJoinedFlowScope().createChildFlowScope();\n             break;\n         case Token.HOOK:\n             scope \u003d traverseHook(n, scope);\n             break;\n         case Token.OBJECTLIT:\n             scope \u003d traverseObjectLiteral(n, scope);\n             break;\n         case Token.CALL:\n             scope \u003d traverseCall(n, scope);\n             break;\n         case Token.NEW:\n             scope \u003d traverseNew(n, scope);\n             break;\n         case Token.ASSIGN_ADD:\n         case Token.ADD:\n             scope \u003d traverseAdd(n, scope);\n             break;\n         case Token.POS:\n         case Token.NEG:\n             scope \u003d traverse(n.getFirstChild(), scope);\n             n.setJSType(getNativeType(NUMBER_TYPE));\n             break;\n         case Token.NULL:\n             n.setJSType(getNativeType(NULL_TYPE));\n             break;\n         case Token.VOID:\n             n.setJSType(getNativeType(VOID_TYPE));\n             break;\n         case Token.ARRAYLIT:\n             scope \u003d traverseArrayLiteral(n, scope);\n             break;\n         case Token.REF_SPECIAL:\n             n.setJSType(getNativeType(UNKNOWN_TYPE));\n             break;\n         case Token.REGEXP:\n             n.setJSType(getNativeType(REGEXP_TYPE));\n             break;\n         case Token.THIS:\n             n.setJSType(scope.getTypeOfThis());\n             break;\n         case Token.ASSIGN_LSH:\n         case Token.ASSIGN_RSH:\n         case Token.LSH:\n         case Token.RSH:\n         case Token.ASSIGN_URSH:\n         case Token.URSH:\n         case Token.ASSIGN_DIV:\n         case Token.ASSIGN_MOD:\n         case Token.ASSIGN_BITAND:\n         case Token.ASSIGN_BITXOR:\n         case Token.ASSIGN_BITOR:\n         case Token.ASSIGN_MUL:\n         case Token.ASSIGN_SUB:\n         case Token.DIV:\n         case Token.MOD:\n         case Token.BITAND:\n         case Token.BITXOR:\n         case Token.BITOR:\n         case Token.MUL:\n         case Token.SUB:\n         case Token.DEC:\n         case Token.INC:\n         case Token.BITNOT:\n         case Token.NUMBER:\n             scope \u003d traverseChildren(n, scope);\n             n.setJSType(getNativeType(NUMBER_TYPE));\n             break;\n         case Token.LP:\n         case Token.GET_REF:\n             scope \u003d traverse(n.getFirstChild(), scope);\n             n.setJSType(getJSType(n.getFirstChild()));\n             break;\n         case Token.COMMA:\n             scope \u003d traverseChildren(n, scope);\n             n.setJSType(getJSType(n.getLastChild()));\n             break;\n         case Token.STRING:\n         case Token.TYPEOF:\n             scope \u003d traverseChildren(n, scope);\n             n.setJSType(getNativeType(STRING_TYPE));\n             break;\n         case Token.LT:\n         case Token.LE:\n         case Token.GT:\n         case Token.GE:\n         case Token.NOT:\n         case Token.EQ:\n         case Token.NE:\n         case Token.SHEQ:\n         case Token.SHNE:\n         case Token.INSTANCEOF:\n         case Token.TRUE:\n         case Token.FALSE:\n             scope \u003d traverseChildren(n, scope);\n             n.setJSType(getNativeType(BOOLEAN_TYPE));\n             break;\n         case Token.GETELEM:\n             scope \u003d traverseGetElem(n, scope);\n             break;\n         case Token.EXPR_RESULT:\n             scope \u003d traverseChildren(n, scope);\n             if (n.getFirstChild().getType() \u003d\u003d Token.GETPROP) {\n                 ensurePropertyDeclared(n.getFirstChild());\n             }\n             break;\n+        case Token.SWITCH:\n+            scope \u003d traverse(n.getFirstChild(), scope);\n+            break;\n         case Token.VAR:\n         case Token.RETURN:\n         case Token.THROW:\n             scope \u003d traverseChildren(n, scope);\n             break;\n         case Token.CATCH:\n             scope \u003d traverseCatch(n, scope);\n             break;\n     }\n     if (n.getType() !\u003d Token.FUNCTION) {\n         JSDocInfo info \u003d n.getJSDocInfo();\n         if (info !\u003d null \u0026\u0026 info.hasType()) {\n             JSType castType \u003d info.getType().evaluate(syntacticScope);\n             if (n.isQualifiedName() \u0026\u0026 n.getParent().getType() \u003d\u003d Token.EXPR_RESULT) {\n                 updateScopeForTypeChange(scope, n, n.getJSType(), castType);\n             }\n             n.setJSType(castType);\n         }\n     }\n     return scope;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": {
      "type": "Yintroduced",
      "commitMessage": "Initial commit.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/3/09, 3:51 PM",
      "commitName": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "diff": "@@ -0,0 +1,142 @@\n+private FlowScope traverse(Node n, FlowScope scope) {\n+    switch(n.getType()) {\n+        case Token.ASSIGN:\n+            scope \u003d traverseAssign(n, scope);\n+            break;\n+        case Token.NAME:\n+            scope \u003d traverseName(n, scope);\n+            break;\n+        case Token.GETPROP:\n+            scope \u003d traverseGetProp(n, scope);\n+            break;\n+        case Token.AND:\n+            scope \u003d traverseAnd(n, scope).getJoinedFlowScope().createChildFlowScope();\n+            break;\n+        case Token.OR:\n+            scope \u003d traverseOr(n, scope).getJoinedFlowScope().createChildFlowScope();\n+            break;\n+        case Token.HOOK:\n+            scope \u003d traverseHook(n, scope);\n+            break;\n+        case Token.OBJECTLIT:\n+            scope \u003d traverseObjectLiteral(n, scope);\n+            break;\n+        case Token.CALL:\n+            scope \u003d traverseCall(n, scope);\n+            break;\n+        case Token.NEW:\n+            scope \u003d traverseNew(n, scope);\n+            break;\n+        case Token.ASSIGN_ADD:\n+        case Token.ADD:\n+            scope \u003d traverseAdd(n, scope);\n+            break;\n+        case Token.POS:\n+        case Token.NEG:\n+            scope \u003d traverse(n.getFirstChild(), scope);\n+            n.setJSType(getNativeType(NUMBER_TYPE));\n+            break;\n+        case Token.NULL:\n+            n.setJSType(getNativeType(NULL_TYPE));\n+            break;\n+        case Token.VOID:\n+            n.setJSType(getNativeType(VOID_TYPE));\n+            break;\n+        case Token.ARRAYLIT:\n+            scope \u003d traverseArrayLiteral(n, scope);\n+            break;\n+        case Token.REF_SPECIAL:\n+            n.setJSType(getNativeType(UNKNOWN_TYPE));\n+            break;\n+        case Token.REGEXP:\n+            n.setJSType(getNativeType(REGEXP_TYPE));\n+            break;\n+        case Token.THIS:\n+            n.setJSType(scope.getTypeOfThis());\n+            break;\n+        case Token.ASSIGN_LSH:\n+        case Token.ASSIGN_RSH:\n+        case Token.LSH:\n+        case Token.RSH:\n+        case Token.ASSIGN_URSH:\n+        case Token.URSH:\n+        case Token.ASSIGN_DIV:\n+        case Token.ASSIGN_MOD:\n+        case Token.ASSIGN_BITAND:\n+        case Token.ASSIGN_BITXOR:\n+        case Token.ASSIGN_BITOR:\n+        case Token.ASSIGN_MUL:\n+        case Token.ASSIGN_SUB:\n+        case Token.DIV:\n+        case Token.MOD:\n+        case Token.BITAND:\n+        case Token.BITXOR:\n+        case Token.BITOR:\n+        case Token.MUL:\n+        case Token.SUB:\n+        case Token.DEC:\n+        case Token.INC:\n+        case Token.BITNOT:\n+        case Token.NUMBER:\n+            scope \u003d traverseChildren(n, scope);\n+            n.setJSType(getNativeType(NUMBER_TYPE));\n+            break;\n+        case Token.LP:\n+        case Token.GET_REF:\n+            scope \u003d traverse(n.getFirstChild(), scope);\n+            n.setJSType(getJSType(n.getFirstChild()));\n+            break;\n+        case Token.COMMA:\n+            scope \u003d traverseChildren(n, scope);\n+            n.setJSType(getJSType(n.getLastChild()));\n+            break;\n+        case Token.STRING:\n+        case Token.TYPEOF:\n+            scope \u003d traverseChildren(n, scope);\n+            n.setJSType(getNativeType(STRING_TYPE));\n+            break;\n+        case Token.LT:\n+        case Token.LE:\n+        case Token.GT:\n+        case Token.GE:\n+        case Token.NOT:\n+        case Token.EQ:\n+        case Token.NE:\n+        case Token.SHEQ:\n+        case Token.SHNE:\n+        case Token.INSTANCEOF:\n+        case Token.TRUE:\n+        case Token.FALSE:\n+            scope \u003d traverseChildren(n, scope);\n+            n.setJSType(getNativeType(BOOLEAN_TYPE));\n+            break;\n+        case Token.GETELEM:\n+            scope \u003d traverseGetElem(n, scope);\n+            break;\n+        case Token.EXPR_RESULT:\n+            scope \u003d traverseChildren(n, scope);\n+            if (n.getFirstChild().getType() \u003d\u003d Token.GETPROP) {\n+                ensurePropertyDeclared(n.getFirstChild());\n+            }\n+            break;\n+        case Token.VAR:\n+        case Token.RETURN:\n+        case Token.THROW:\n+            scope \u003d traverseChildren(n, scope);\n+            break;\n+        case Token.CATCH:\n+            scope \u003d traverseCatch(n, scope);\n+            break;\n+    }\n+    if (n.getType() !\u003d Token.FUNCTION) {\n+        JSDocInfo info \u003d n.getJSDocInfo();\n+        if (info !\u003d null \u0026\u0026 info.hasType()) {\n+            JSType castType \u003d info.getType().evaluate(syntacticScope);\n+            if (n.isQualifiedName() \u0026\u0026 n.getParent().getType() \u003d\u003d Token.EXPR_RESULT) {\n+                updateScopeForTypeChange(scope, n, n.getJSType(), castType);\n+            }\n+            n.setJSType(castType);\n+        }\n+    }\n+    return scope;\n+}\n\\ No newline at end of file\n",
      "actualSource": "private FlowScope traverse(Node n, FlowScope scope) {\n    switch(n.getType()) {\n        case Token.ASSIGN:\n            scope \u003d traverseAssign(n, scope);\n            break;\n        case Token.NAME:\n            scope \u003d traverseName(n, scope);\n            break;\n        case Token.GETPROP:\n            scope \u003d traverseGetProp(n, scope);\n            break;\n        case Token.AND:\n            scope \u003d traverseAnd(n, scope).getJoinedFlowScope().createChildFlowScope();\n            break;\n        case Token.OR:\n            scope \u003d traverseOr(n, scope).getJoinedFlowScope().createChildFlowScope();\n            break;\n        case Token.HOOK:\n            scope \u003d traverseHook(n, scope);\n            break;\n        case Token.OBJECTLIT:\n            scope \u003d traverseObjectLiteral(n, scope);\n            break;\n        case Token.CALL:\n            scope \u003d traverseCall(n, scope);\n            break;\n        case Token.NEW:\n            scope \u003d traverseNew(n, scope);\n            break;\n        case Token.ASSIGN_ADD:\n        case Token.ADD:\n            scope \u003d traverseAdd(n, scope);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            scope \u003d traverse(n.getFirstChild(), scope);\n            n.setJSType(getNativeType(NUMBER_TYPE));\n            break;\n        case Token.NULL:\n            n.setJSType(getNativeType(NULL_TYPE));\n            break;\n        case Token.VOID:\n            n.setJSType(getNativeType(VOID_TYPE));\n            break;\n        case Token.ARRAYLIT:\n            scope \u003d traverseArrayLiteral(n, scope);\n            break;\n        case Token.REF_SPECIAL:\n            n.setJSType(getNativeType(UNKNOWN_TYPE));\n            break;\n        case Token.REGEXP:\n            n.setJSType(getNativeType(REGEXP_TYPE));\n            break;\n        case Token.THIS:\n            n.setJSType(scope.getTypeOfThis());\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.ASSIGN_URSH:\n        case Token.URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_MUL:\n        case Token.ASSIGN_SUB:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITAND:\n        case Token.BITXOR:\n        case Token.BITOR:\n        case Token.MUL:\n        case Token.SUB:\n        case Token.DEC:\n        case Token.INC:\n        case Token.BITNOT:\n        case Token.NUMBER:\n            scope \u003d traverseChildren(n, scope);\n            n.setJSType(getNativeType(NUMBER_TYPE));\n            break;\n        case Token.LP:\n        case Token.GET_REF:\n            scope \u003d traverse(n.getFirstChild(), scope);\n            n.setJSType(getJSType(n.getFirstChild()));\n            break;\n        case Token.COMMA:\n            scope \u003d traverseChildren(n, scope);\n            n.setJSType(getJSType(n.getLastChild()));\n            break;\n        case Token.STRING:\n        case Token.TYPEOF:\n            scope \u003d traverseChildren(n, scope);\n            n.setJSType(getNativeType(STRING_TYPE));\n            break;\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n        case Token.NOT:\n        case Token.EQ:\n        case Token.NE:\n        case Token.SHEQ:\n        case Token.SHNE:\n        case Token.INSTANCEOF:\n        case Token.TRUE:\n        case Token.FALSE:\n            scope \u003d traverseChildren(n, scope);\n            n.setJSType(getNativeType(BOOLEAN_TYPE));\n            break;\n        case Token.GETELEM:\n            scope \u003d traverseGetElem(n, scope);\n            break;\n        case Token.EXPR_RESULT:\n            scope \u003d traverseChildren(n, scope);\n            if (n.getFirstChild().getType() \u003d\u003d Token.GETPROP) {\n                ensurePropertyDeclared(n.getFirstChild());\n            }\n            break;\n        case Token.VAR:\n        case Token.RETURN:\n        case Token.THROW:\n            scope \u003d traverseChildren(n, scope);\n            break;\n        case Token.CATCH:\n            scope \u003d traverseCatch(n, scope);\n            break;\n    }\n    if (n.getType() !\u003d Token.FUNCTION) {\n        JSDocInfo info \u003d n.getJSDocInfo();\n        if (info !\u003d null \u0026\u0026 info.hasType()) {\n            JSType castType \u003d info.getType().evaluate(syntacticScope);\n            if (n.isQualifiedName() \u0026\u0026 n.getParent().getType() \u003d\u003d Token.EXPR_RESULT) {\n                updateScopeForTypeChange(scope, n, n.getJSType(), castType);\n            }\n            n.setJSType(castType);\n        }\n    }\n    return scope;\n}",
      "path": "src/com/google/javascript/jscomp/TypeInference.java",
      "functionStartLine": 255,
      "functionName": "traverse",
      "functionAnnotation": "",
      "functionDoc": ""
    }
  }
}