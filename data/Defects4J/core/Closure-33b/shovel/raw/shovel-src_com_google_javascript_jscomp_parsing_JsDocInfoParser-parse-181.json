{
  "origin": "codeshovel",
  "repositoryName": "Closure-33b",
  "repositoryPath": "/tmp/Closure-33b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "JsDocInfoParser.java",
  "functionName": "parse",
  "functionId": "parse",
  "sourceFilePath": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
  "functionAnnotation": "",
  "functionDoc": "Parses a {@link JSDocInfo} object. This parsing method reads all tokens\nreturned by the {@link JsDocTokenStream#getJsDocToken()} method until the\n{@link JsDocToken#EOC} is returned.\n\n@return @code true} if JSDoc information was correctly parsed,\n    {@code false} otherwise\n",
  "functionStartLine": 181,
  "functionEndLine": 949,
  "numCommitsSeen": 57,
  "timeTaken": 7221,
  "changeHistory": [
    "262e522d93c967c7a80c27c087f166e5e7b903c4",
    "b8086ea9d7cd87db9f1624f8eb0d6e4550e55495",
    "8ef31dd36e38599736e1c9b6ea1d1e546cba510a",
    "cc5786f9a83ec0035c7aaf6a792c99e5cd6d81e9",
    "9d5a6e3082dd99f6c44df1b3526b9e83b79aa7da",
    "cc628d6050107e3dfcc7bd2748708c12ef15b4e0",
    "4fe0dd22b4462cbd3943f3a8d77db8136ff4d9b7",
    "9b04e62d89c89cfa636ae803e210ddbeb007a626",
    "5709ec1d0bbe5b7726a14d06f7eab9c35150e314",
    "11e59819ec6134736004cebf264b030517a7bff1",
    "9d72612f028076aa43a9b259c29b2a940398465f",
    "eb3e25de7fc6ee4858b9805519c0dc7a13e1b183",
    "5b3bc3fa01328cdbbde6b865c4d3ff7562bc9d6f",
    "22775ad7cad0bea94d56726e1d6a80f31604c118",
    "e33e925eea3a8e4de958864e531e1adc4da62e18",
    "c764a46abf211d4677fadc33f7d466e5b14fa088",
    "52ecbc65e981b9f169466f8898155bc5f8bfad7a",
    "a478193982ce1fb9271e3f7ebcc1369913c9a859",
    "5af11d33f8b3f5403c9987104601f544cddb96c1",
    "2acd6c1986e36bfdbae85c09eb83ac1940b86c73",
    "efd3c178e471df6a689c1a50fbd7c404e778bfaa",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3"
  ],
  "changeHistoryShort": {
    "262e522d93c967c7a80c27c087f166e5e7b903c4": "Ybodychange",
    "b8086ea9d7cd87db9f1624f8eb0d6e4550e55495": "Ybodychange",
    "8ef31dd36e38599736e1c9b6ea1d1e546cba510a": "Ybodychange",
    "cc5786f9a83ec0035c7aaf6a792c99e5cd6d81e9": "Ybodychange",
    "9d5a6e3082dd99f6c44df1b3526b9e83b79aa7da": "Ybodychange",
    "cc628d6050107e3dfcc7bd2748708c12ef15b4e0": "Ybodychange",
    "4fe0dd22b4462cbd3943f3a8d77db8136ff4d9b7": "Ybodychange",
    "9b04e62d89c89cfa636ae803e210ddbeb007a626": "Ybodychange",
    "5709ec1d0bbe5b7726a14d06f7eab9c35150e314": "Ybodychange",
    "11e59819ec6134736004cebf264b030517a7bff1": "Ybodychange",
    "9d72612f028076aa43a9b259c29b2a940398465f": "Ybodychange",
    "eb3e25de7fc6ee4858b9805519c0dc7a13e1b183": "Ybodychange",
    "5b3bc3fa01328cdbbde6b865c4d3ff7562bc9d6f": "Ybodychange",
    "22775ad7cad0bea94d56726e1d6a80f31604c118": "Ybodychange",
    "e33e925eea3a8e4de958864e531e1adc4da62e18": "Ybodychange",
    "c764a46abf211d4677fadc33f7d466e5b14fa088": "Ybodychange",
    "52ecbc65e981b9f169466f8898155bc5f8bfad7a": "Ybodychange",
    "a478193982ce1fb9271e3f7ebcc1369913c9a859": "Ybodychange",
    "5af11d33f8b3f5403c9987104601f544cddb96c1": "Ybodychange",
    "2acd6c1986e36bfdbae85c09eb83ac1940b86c73": "Ybodychange",
    "efd3c178e471df6a689c1a50fbd7c404e778bfaa": "Ybodychange",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "262e522d93c967c7a80c27c087f166e5e7b903c4": {
      "type": "Ybodychange",
      "commitMessage": "\nadd an @expose annotation\n\nR\u003djohnlenz\nDELTA\u003d50  (50 added, 0 deleted, 0 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d4350\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1826 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "3/9/12, 4:23 PM",
      "commitName": "262e522d93c967c7a80c27c087f166e5e7b903c4",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "2/8/12, 3:00 PM",
      "commitNameOld": "3706221fa9c7bec26ea69889da16b03587838708",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 30.06,
      "commitsBetweenForRepo": 47,
      "commitsBetweenForFile": 1,
      "actualSource": "boolean parse() {\n    int lineno;\n    int charno;\n    JSTypeExpression type;\n    state \u003d State.SEARCHING_ANNOTATION;\n    skipEOLs();\n    JsDocToken token \u003d next();\n    List\u003cExtendedTypeInfo\u003e extendedTypes \u003d Lists.newArrayList();\n    if (jsdocBuilder.shouldParseDocumentation()) {\n        ExtractionInfo blockInfo \u003d extractBlockComment(token);\n        token \u003d blockInfo.token;\n        if (!blockInfo.string.isEmpty()) {\n            jsdocBuilder.recordBlockDescription(blockInfo.string);\n        }\n    } else {\n        if (token !\u003d JsDocToken.ANNOTATION \u0026\u0026 token !\u003d JsDocToken.EOC) {\n            jsdocBuilder.recordBlockDescription(\"\");\n        }\n    }\n    retry: for (; ; ) {\n        switch(token) {\n            case ANNOTATION:\n                if (state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                    state \u003d State.SEARCHING_NEWLINE;\n                    lineno \u003d stream.getLineno();\n                    charno \u003d stream.getCharno();\n                    String annotationName \u003d stream.getString();\n                    Annotation annotation \u003d annotationNames.get(annotationName);\n                    if (annotation \u003d\u003d null) {\n                        parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno());\n                    } else {\n                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n                        switch(annotation) {\n                            case AUTHOR:\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo authorInfo \u003d extractSingleLineBlock();\n                                    String author \u003d authorInfo.string;\n                                    if (author.length() \u003d\u003d 0) {\n                                        parser.addParserWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        jsdocBuilder.addAuthor(author);\n                                    }\n                                    token \u003d authorInfo.token;\n                                } else {\n                                    token \u003d eatTokensUntilEOL(token);\n                                }\n                                continue retry;\n                            case CONSISTENTIDGENERATOR:\n                                if (!jsdocBuilder.recordConsistentIdGenerator()) {\n                                    parser.addParserWarning(\"msg.jsdoc.consistidgen\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case CONSTANT:\n                                if (!jsdocBuilder.recordConstancy()) {\n                                    parser.addParserWarning(\"msg.jsdoc.const\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case CONSTRUCTOR:\n                                if (!jsdocBuilder.recordConstructor()) {\n                                    if (jsdocBuilder.isInterfaceRecorded()) {\n                                        parser.addTypeWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        parser.addTypeWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case DEPRECATED:\n                                if (!jsdocBuilder.recordDeprecated()) {\n                                    parser.addParserWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno());\n                                }\n                                ExtractionInfo reasonInfo \u003d extractMultilineTextualBlock(token);\n                                String reason \u003d reasonInfo.string;\n                                if (reason.length() \u003e 0) {\n                                    jsdocBuilder.recordDeprecationReason(reason);\n                                }\n                                token \u003d reasonInfo.token;\n                                continue retry;\n                            case INTERFACE:\n                                if (!jsdocBuilder.recordInterface()) {\n                                    if (jsdocBuilder.isConstructorRecorded()) {\n                                        parser.addTypeWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        parser.addTypeWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case DESC:\n                                if (jsdocBuilder.isDescriptionRecorded()) {\n                                    parser.addParserWarning(\"msg.jsdoc.desc.extra\", stream.getLineno(), stream.getCharno());\n                                    token \u003d eatTokensUntilEOL();\n                                    continue retry;\n                                } else {\n                                    ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                    String description \u003d descriptionInfo.string;\n                                    jsdocBuilder.recordDescription(description);\n                                    token \u003d descriptionInfo.token;\n                                    continue retry;\n                                }\n                            case FILE_OVERVIEW:\n                                String fileOverview \u003d \"\";\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo fileOverviewInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.TRIM);\n                                    fileOverview \u003d fileOverviewInfo.string;\n                                    token \u003d fileOverviewInfo.token;\n                                } else {\n                                    token \u003d eatTokensUntilEOL(token);\n                                }\n                                if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo !\u003d null) {\n                                    parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno());\n                                }\n                                continue retry;\n                            case LICENSE:\n                            case PRESERVE:\n                                ExtractionInfo preserveInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);\n                                String preserve \u003d preserveInfo.string;\n                                if (preserve.length() \u003e 0) {\n                                    if (fileLevelJsDocBuilder !\u003d null) {\n                                        fileLevelJsDocBuilder.append(preserve);\n                                    }\n                                }\n                                token \u003d preserveInfo.token;\n                                continue retry;\n                            case ENUM:\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                }\n                                if (type \u003d\u003d null) {\n                                    type \u003d createJSTypeExpression(newStringNode(\"number\"));\n                                }\n                                if (!jsdocBuilder.recordEnumParameterType(type)) {\n                                    parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                }\n                                token \u003d eatTokensUntilEOL(token);\n                                continue retry;\n                            case EXPORT:\n                                if (!jsdocBuilder.recordExport()) {\n                                    parser.addParserWarning(\"msg.jsdoc.export\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case EXPOSE:\n                                if (!jsdocBuilder.recordExpose()) {\n                                    parser.addParserWarning(\"msg.jsdoc.expose\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case EXTERNS:\n                                if (!jsdocBuilder.recordExterns()) {\n                                    parser.addParserWarning(\"msg.jsdoc.externs\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case JAVA_DISPATCH:\n                                if (!jsdocBuilder.recordJavaDispatch()) {\n                                    parser.addParserWarning(\"msg.jsdoc.javadispatch\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case EXTENDS:\n                            case IMPLEMENTS:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                boolean matchingRc \u003d false;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    token \u003d next();\n                                    matchingRc \u003d true;\n                                }\n                                if (token \u003d\u003d JsDocToken.STRING) {\n                                    Node typeNode \u003d parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);\n                                    lineno \u003d stream.getLineno();\n                                    charno \u003d stream.getCharno();\n                                    typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                    if (typeNode !\u003d null \u0026\u0026 !matchingRc) {\n                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                    }\n                                    type \u003d createJSTypeExpression(typeNode);\n                                    if (annotation \u003d\u003d Annotation.EXTENDS) {\n                                        extendedTypes.add(new ExtendedTypeInfo(type, stream.getLineno(), stream.getCharno()));\n                                    } else {\n                                        Preconditions.checkState(annotation \u003d\u003d Annotation.IMPLEMENTS);\n                                        if (!jsdocBuilder.recordImplementedInterface(type)) {\n                                            parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\", lineno, charno);\n                                        }\n                                    }\n                                    token \u003d next();\n                                    if (matchingRc) {\n                                        if (token !\u003d JsDocToken.RC) {\n                                            parser.addTypeWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                        }\n                                    } else if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOF \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                        parser.addTypeWarning(\"msg.end.annotation.expected\", stream.getLineno(), stream.getCharno());\n                                    }\n                                } else {\n                                    parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);\n                                }\n                                token \u003d eatTokensUntilEOL(token);\n                                continue retry;\n                            case HIDDEN:\n                                if (!jsdocBuilder.recordHiddenness()) {\n                                    parser.addParserWarning(\"msg.jsdoc.hidden\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case LENDS:\n                                skipEOLs();\n                                matchingRc \u003d false;\n                                if (match(JsDocToken.LC)) {\n                                    token \u003d next();\n                                    matchingRc \u003d true;\n                                }\n                                if (match(JsDocToken.STRING)) {\n                                    token \u003d next();\n                                    if (!jsdocBuilder.recordLends(stream.getString())) {\n                                        parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\", stream.getLineno(), stream.getCharno());\n                                    }\n                                } else {\n                                    parser.addTypeWarning(\"msg.jsdoc.lends.missing\", stream.getLineno(), stream.getCharno());\n                                }\n                                if (matchingRc \u0026\u0026 !match(JsDocToken.RC)) {\n                                    parser.addTypeWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case MEANING:\n                                ExtractionInfo meaningInfo \u003d extractMultilineTextualBlock(token);\n                                String meaning \u003d meaningInfo.string;\n                                token \u003d meaningInfo.token;\n                                if (!jsdocBuilder.recordMeaning(meaning)) {\n                                    parser.addParserWarning(\"msg.jsdoc.meaning.extra\", stream.getLineno(), stream.getCharno());\n                                }\n                                continue retry;\n                            case NO_ALIAS:\n                                if (!jsdocBuilder.recordNoAlias()) {\n                                    parser.addParserWarning(\"msg.jsdoc.noalias\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_COMPILE:\n                                if (!jsdocBuilder.recordNoCompile()) {\n                                    parser.addParserWarning(\"msg.jsdoc.nocompile\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_TYPE_CHECK:\n                                if (!jsdocBuilder.recordNoTypeCheck()) {\n                                    parser.addParserWarning(\"msg.jsdoc.nocheck\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NOT_IMPLEMENTED:\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case INHERIT_DOC:\n                            case OVERRIDE:\n                                if (!jsdocBuilder.recordOverride()) {\n                                    parser.addTypeWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case THROWS:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                    if (type \u003d\u003d null) {\n                                        token \u003d eatTokensUntilEOL();\n                                        continue retry;\n                                    }\n                                }\n                                token \u003d current();\n                                jsdocBuilder.recordThrowType(type);\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                    String description \u003d descriptionInfo.string;\n                                    if (description.length() \u003e 0) {\n                                        jsdocBuilder.recordThrowDescription(type, description);\n                                    }\n                                    token \u003d descriptionInfo.token;\n                                } else {\n                                    token \u003d eatTokensUntilEOL(token);\n                                }\n                                continue retry;\n                            case PARAM:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordParamTypeNode(token));\n                                    if (type \u003d\u003d null) {\n                                        token \u003d eatTokensUntilEOL();\n                                        continue retry;\n                                    }\n                                    skipEOLs();\n                                    token \u003d next();\n                                    lineno \u003d stream.getLineno();\n                                    charno \u003d stream.getCharno();\n                                }\n                                String name \u003d null;\n                                boolean isBracketedParam \u003d JsDocToken.LB \u003d\u003d token;\n                                if (isBracketedParam) {\n                                    token \u003d next();\n                                }\n                                if (JsDocToken.STRING !\u003d token) {\n                                    parser.addTypeWarning(\"msg.missing.variable.name\", lineno, charno);\n                                } else {\n                                    name \u003d stream.getString();\n                                    if (isBracketedParam) {\n                                        token \u003d next();\n                                        if (JsDocToken.EQUALS \u003d\u003d token) {\n                                            token \u003d next();\n                                            if (JsDocToken.STRING \u003d\u003d token) {\n                                                token \u003d next();\n                                            }\n                                        }\n                                        if (JsDocToken.RB !\u003d token) {\n                                            reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                                        } else if (type !\u003d null) {\n                                            type \u003d JSTypeExpression.makeOptionalArg(type);\n                                        }\n                                    }\n                                    if (name.indexOf(\u0027.\u0027) \u003e -1) {\n                                        name \u003d null;\n                                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                                        if (jsdocBuilder.hasParameter(name)) {\n                                            parser.addTypeWarning(\"msg.dup.variable.name\", name, lineno, charno);\n                                        } else {\n                                            parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name, lineno, charno);\n                                        }\n                                    }\n                                }\n                                if (name \u003d\u003d null) {\n                                    token \u003d eatTokensUntilEOL(token);\n                                    continue retry;\n                                }\n                                jsdocBuilder.markName(name, sourceFile, lineno, charno);\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo paramDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                    String paramDescription \u003d paramDescriptionInfo.string;\n                                    if (paramDescription.length() \u003e 0) {\n                                        jsdocBuilder.recordParameterDescription(name, paramDescription);\n                                    }\n                                    token \u003d paramDescriptionInfo.token;\n                                } else {\n                                    token \u003d eatTokensUntilEOL(token);\n                                }\n                                continue retry;\n                            case PRESERVE_TRY:\n                                if (!jsdocBuilder.recordPreserveTry()) {\n                                    parser.addParserWarning(\"msg.jsdoc.preservertry\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PRIVATE:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                                    parser.addParserWarning(\"msg.jsdoc.visibility.private\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PROTECTED:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                                    parser.addParserWarning(\"msg.jsdoc.visibility.protected\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PUBLIC:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                                    parser.addParserWarning(\"msg.jsdoc.visibility.public\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_SHADOW:\n                                if (!jsdocBuilder.recordNoShadow()) {\n                                    parser.addParserWarning(\"msg.jsdoc.noshadow\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_SIDE_EFFECTS:\n                                if (!jsdocBuilder.recordNoSideEffects()) {\n                                    parser.addParserWarning(\"msg.jsdoc.nosideeffects\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case MODIFIES:\n                                token \u003d parseModifiesTag(next());\n                                continue retry;\n                            case IMPLICIT_CAST:\n                                if (!jsdocBuilder.recordImplicitCast()) {\n                                    parser.addTypeWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case SEE:\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo referenceInfo \u003d extractSingleLineBlock();\n                                    String reference \u003d referenceInfo.string;\n                                    if (reference.length() \u003d\u003d 0) {\n                                        parser.addParserWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        jsdocBuilder.addReference(reference);\n                                    }\n                                    token \u003d referenceInfo.token;\n                                } else {\n                                    token \u003d eatTokensUntilEOL(token);\n                                }\n                                continue retry;\n                            case SUPPRESS:\n                                token \u003d parseSuppressTag(next());\n                                continue retry;\n                            case TEMPLATE:\n                                ExtractionInfo templateInfo \u003d extractSingleLineBlock();\n                                String templateTypeName \u003d templateInfo.string;\n                                if (templateTypeName.length() \u003d\u003d 0) {\n                                    parser.addTypeWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno());\n                                } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {\n                                    parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d templateInfo.token;\n                                continue retry;\n                            case IDGENERATOR:\n                                if (!jsdocBuilder.recordIdGenerator()) {\n                                    parser.addParserWarning(\"msg.jsdoc.idgen\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case VERSION:\n                                ExtractionInfo versionInfo \u003d extractSingleLineBlock();\n                                String version \u003d versionInfo.string;\n                                if (version.length() \u003d\u003d 0) {\n                                    parser.addParserWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno());\n                                } else {\n                                    if (!jsdocBuilder.recordVersion(version)) {\n                                        parser.addParserWarning(\"msg.jsdoc.extraversion\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d versionInfo.token;\n                                continue retry;\n                            case DEFINE:\n                            case RETURN:\n                            case THIS:\n                            case TYPE:\n                            case TYPEDEF:\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                Node typeNode \u003d null;\n                                if (!lookAheadForTypeAnnotation() \u0026\u0026 annotation \u003d\u003d Annotation.RETURN) {\n                                    typeNode \u003d newNode(Token.QMARK);\n                                } else {\n                                    skipEOLs();\n                                    token \u003d next();\n                                    typeNode \u003d parseAndRecordTypeNode(token);\n                                }\n                                if (annotation \u003d\u003d Annotation.THIS) {\n                                    typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                    if (typeNode !\u003d null \u0026\u0026 token !\u003d JsDocToken.LC) {\n                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                    }\n                                }\n                                type \u003d createJSTypeExpression(typeNode);\n                                if (type \u003d\u003d null) {\n                                } else {\n                                    switch(annotation) {\n                                        case DEFINE:\n                                            if (!jsdocBuilder.recordDefineType(type)) {\n                                                parser.addParserWarning(\"msg.jsdoc.define\", lineno, charno);\n                                            }\n                                            break;\n                                        case RETURN:\n                                            if (!jsdocBuilder.recordReturnType(type)) {\n                                                parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                                break;\n                                            }\n                                            if (jsdocBuilder.shouldParseDocumentation()) {\n                                                ExtractionInfo returnDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                                String returnDescription \u003d returnDescriptionInfo.string;\n                                                if (returnDescription.length() \u003e 0) {\n                                                    jsdocBuilder.recordReturnDescription(returnDescription);\n                                                }\n                                                token \u003d returnDescriptionInfo.token;\n                                            } else {\n                                                token \u003d eatTokensUntilEOL(token);\n                                            }\n                                            continue retry;\n                                        case THIS:\n                                            if (!jsdocBuilder.recordThisType(type)) {\n                                                parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                        case TYPE:\n                                            if (!jsdocBuilder.recordType(type)) {\n                                                parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                        case TYPEDEF:\n                                            if (!jsdocBuilder.recordTypedef(type)) {\n                                                parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                    }\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                        }\n                    }\n                }\n                break;\n            case EOC:\n                if (hasParsedFileOverviewDocInfo()) {\n                    fileOverviewJSDocInfo \u003d retrieveAndResetParsedJSDocInfo();\n                }\n                checkExtendedTypes(extendedTypes);\n                return true;\n            case EOF:\n                jsdocBuilder.build(null);\n                parser.addParserWarning(\"msg.unexpected.eof\", stream.getLineno(), stream.getCharno());\n                checkExtendedTypes(extendedTypes);\n                return false;\n            case EOL:\n                if (state \u003d\u003d State.SEARCHING_NEWLINE) {\n                    state \u003d State.SEARCHING_ANNOTATION;\n                }\n                token \u003d next();\n                continue retry;\n            default:\n                if (token \u003d\u003d JsDocToken.STAR \u0026\u0026 state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                    token \u003d next();\n                    continue retry;\n                } else {\n                    state \u003d State.SEARCHING_NEWLINE;\n                    token \u003d eatTokensUntilEOL();\n                    continue retry;\n                }\n        }\n        token \u003d next();\n    }\n}",
      "path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
      "functionStartLine": 181,
      "functionName": "parse",
      "functionAnnotation": "",
      "functionDoc": "Parses a {@link JSDocInfo} object. This parsing method reads all tokens\nreturned by the {@link JsDocTokenStream#getJsDocToken()} method until the\n{@link JsDocToken#EOC} is returned.\n\n@return @code true} if JSDoc information was correctly parsed,\n    {@code false} otherwise\n",
      "diff": "@@ -1,544 +1,550 @@\n boolean parse() {\n     int lineno;\n     int charno;\n     JSTypeExpression type;\n     state \u003d State.SEARCHING_ANNOTATION;\n     skipEOLs();\n     JsDocToken token \u003d next();\n     List\u003cExtendedTypeInfo\u003e extendedTypes \u003d Lists.newArrayList();\n     if (jsdocBuilder.shouldParseDocumentation()) {\n         ExtractionInfo blockInfo \u003d extractBlockComment(token);\n         token \u003d blockInfo.token;\n         if (!blockInfo.string.isEmpty()) {\n             jsdocBuilder.recordBlockDescription(blockInfo.string);\n         }\n     } else {\n         if (token !\u003d JsDocToken.ANNOTATION \u0026\u0026 token !\u003d JsDocToken.EOC) {\n             jsdocBuilder.recordBlockDescription(\"\");\n         }\n     }\n     retry: for (; ; ) {\n         switch(token) {\n             case ANNOTATION:\n                 if (state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                     state \u003d State.SEARCHING_NEWLINE;\n                     lineno \u003d stream.getLineno();\n                     charno \u003d stream.getCharno();\n                     String annotationName \u003d stream.getString();\n                     Annotation annotation \u003d annotationNames.get(annotationName);\n                     if (annotation \u003d\u003d null) {\n                         parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno());\n                     } else {\n                         jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n                         switch(annotation) {\n                             case AUTHOR:\n                                 if (jsdocBuilder.shouldParseDocumentation()) {\n                                     ExtractionInfo authorInfo \u003d extractSingleLineBlock();\n                                     String author \u003d authorInfo.string;\n                                     if (author.length() \u003d\u003d 0) {\n                                         parser.addParserWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno());\n                                     } else {\n                                         jsdocBuilder.addAuthor(author);\n                                     }\n                                     token \u003d authorInfo.token;\n                                 } else {\n                                     token \u003d eatTokensUntilEOL(token);\n                                 }\n                                 continue retry;\n                             case CONSISTENTIDGENERATOR:\n                                 if (!jsdocBuilder.recordConsistentIdGenerator()) {\n                                     parser.addParserWarning(\"msg.jsdoc.consistidgen\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case CONSTANT:\n                                 if (!jsdocBuilder.recordConstancy()) {\n                                     parser.addParserWarning(\"msg.jsdoc.const\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case CONSTRUCTOR:\n                                 if (!jsdocBuilder.recordConstructor()) {\n                                     if (jsdocBuilder.isInterfaceRecorded()) {\n                                         parser.addTypeWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                     } else {\n                                         parser.addTypeWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case DEPRECATED:\n                                 if (!jsdocBuilder.recordDeprecated()) {\n                                     parser.addParserWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 ExtractionInfo reasonInfo \u003d extractMultilineTextualBlock(token);\n                                 String reason \u003d reasonInfo.string;\n                                 if (reason.length() \u003e 0) {\n                                     jsdocBuilder.recordDeprecationReason(reason);\n                                 }\n                                 token \u003d reasonInfo.token;\n                                 continue retry;\n                             case INTERFACE:\n                                 if (!jsdocBuilder.recordInterface()) {\n                                     if (jsdocBuilder.isConstructorRecorded()) {\n                                         parser.addTypeWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                     } else {\n                                         parser.addTypeWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case DESC:\n                                 if (jsdocBuilder.isDescriptionRecorded()) {\n                                     parser.addParserWarning(\"msg.jsdoc.desc.extra\", stream.getLineno(), stream.getCharno());\n                                     token \u003d eatTokensUntilEOL();\n                                     continue retry;\n                                 } else {\n                                     ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                     String description \u003d descriptionInfo.string;\n                                     jsdocBuilder.recordDescription(description);\n                                     token \u003d descriptionInfo.token;\n                                     continue retry;\n                                 }\n                             case FILE_OVERVIEW:\n                                 String fileOverview \u003d \"\";\n                                 if (jsdocBuilder.shouldParseDocumentation()) {\n                                     ExtractionInfo fileOverviewInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.TRIM);\n                                     fileOverview \u003d fileOverviewInfo.string;\n                                     token \u003d fileOverviewInfo.token;\n                                 } else {\n                                     token \u003d eatTokensUntilEOL(token);\n                                 }\n                                 if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo !\u003d null) {\n                                     parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 continue retry;\n                             case LICENSE:\n                             case PRESERVE:\n                                 ExtractionInfo preserveInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);\n                                 String preserve \u003d preserveInfo.string;\n                                 if (preserve.length() \u003e 0) {\n                                     if (fileLevelJsDocBuilder !\u003d null) {\n                                         fileLevelJsDocBuilder.append(preserve);\n                                     }\n                                 }\n                                 token \u003d preserveInfo.token;\n                                 continue retry;\n                             case ENUM:\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                 }\n                                 if (type \u003d\u003d null) {\n                                     type \u003d createJSTypeExpression(newStringNode(\"number\"));\n                                 }\n                                 if (!jsdocBuilder.recordEnumParameterType(type)) {\n                                     parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                 }\n                                 token \u003d eatTokensUntilEOL(token);\n                                 continue retry;\n                             case EXPORT:\n                                 if (!jsdocBuilder.recordExport()) {\n                                     parser.addParserWarning(\"msg.jsdoc.export\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n+                            case EXPOSE:\n+                                if (!jsdocBuilder.recordExpose()) {\n+                                    parser.addParserWarning(\"msg.jsdoc.expose\", stream.getLineno(), stream.getCharno());\n+                                }\n+                                token \u003d eatTokensUntilEOL();\n+                                continue retry;\n                             case EXTERNS:\n                                 if (!jsdocBuilder.recordExterns()) {\n                                     parser.addParserWarning(\"msg.jsdoc.externs\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case JAVA_DISPATCH:\n                                 if (!jsdocBuilder.recordJavaDispatch()) {\n                                     parser.addParserWarning(\"msg.jsdoc.javadispatch\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case EXTENDS:\n                             case IMPLEMENTS:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 boolean matchingRc \u003d false;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     token \u003d next();\n                                     matchingRc \u003d true;\n                                 }\n                                 if (token \u003d\u003d JsDocToken.STRING) {\n                                     Node typeNode \u003d parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);\n                                     lineno \u003d stream.getLineno();\n                                     charno \u003d stream.getCharno();\n                                     typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                     if (typeNode !\u003d null \u0026\u0026 !matchingRc) {\n                                         typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                     }\n                                     type \u003d createJSTypeExpression(typeNode);\n                                     if (annotation \u003d\u003d Annotation.EXTENDS) {\n                                         extendedTypes.add(new ExtendedTypeInfo(type, stream.getLineno(), stream.getCharno()));\n                                     } else {\n                                         Preconditions.checkState(annotation \u003d\u003d Annotation.IMPLEMENTS);\n                                         if (!jsdocBuilder.recordImplementedInterface(type)) {\n                                             parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\", lineno, charno);\n                                         }\n                                     }\n                                     token \u003d next();\n                                     if (matchingRc) {\n                                         if (token !\u003d JsDocToken.RC) {\n                                             parser.addTypeWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                         }\n                                     } else if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOF \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                         parser.addTypeWarning(\"msg.end.annotation.expected\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 } else {\n                                     parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);\n                                 }\n                                 token \u003d eatTokensUntilEOL(token);\n                                 continue retry;\n                             case HIDDEN:\n                                 if (!jsdocBuilder.recordHiddenness()) {\n                                     parser.addParserWarning(\"msg.jsdoc.hidden\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case LENDS:\n                                 skipEOLs();\n                                 matchingRc \u003d false;\n                                 if (match(JsDocToken.LC)) {\n                                     token \u003d next();\n                                     matchingRc \u003d true;\n                                 }\n                                 if (match(JsDocToken.STRING)) {\n                                     token \u003d next();\n                                     if (!jsdocBuilder.recordLends(stream.getString())) {\n                                         parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 } else {\n                                     parser.addTypeWarning(\"msg.jsdoc.lends.missing\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 if (matchingRc \u0026\u0026 !match(JsDocToken.RC)) {\n                                     parser.addTypeWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case MEANING:\n                                 ExtractionInfo meaningInfo \u003d extractMultilineTextualBlock(token);\n                                 String meaning \u003d meaningInfo.string;\n                                 token \u003d meaningInfo.token;\n                                 if (!jsdocBuilder.recordMeaning(meaning)) {\n                                     parser.addParserWarning(\"msg.jsdoc.meaning.extra\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 continue retry;\n                             case NO_ALIAS:\n                                 if (!jsdocBuilder.recordNoAlias()) {\n                                     parser.addParserWarning(\"msg.jsdoc.noalias\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_COMPILE:\n                                 if (!jsdocBuilder.recordNoCompile()) {\n                                     parser.addParserWarning(\"msg.jsdoc.nocompile\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_TYPE_CHECK:\n                                 if (!jsdocBuilder.recordNoTypeCheck()) {\n                                     parser.addParserWarning(\"msg.jsdoc.nocheck\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NOT_IMPLEMENTED:\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case INHERIT_DOC:\n                             case OVERRIDE:\n                                 if (!jsdocBuilder.recordOverride()) {\n                                     parser.addTypeWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case THROWS:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                     if (type \u003d\u003d null) {\n                                         token \u003d eatTokensUntilEOL();\n                                         continue retry;\n                                     }\n                                 }\n                                 token \u003d current();\n                                 jsdocBuilder.recordThrowType(type);\n                                 if (jsdocBuilder.shouldParseDocumentation()) {\n                                     ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                     String description \u003d descriptionInfo.string;\n                                     if (description.length() \u003e 0) {\n                                         jsdocBuilder.recordThrowDescription(type, description);\n                                     }\n                                     token \u003d descriptionInfo.token;\n                                 } else {\n                                     token \u003d eatTokensUntilEOL(token);\n                                 }\n                                 continue retry;\n                             case PARAM:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordParamTypeNode(token));\n                                     if (type \u003d\u003d null) {\n                                         token \u003d eatTokensUntilEOL();\n                                         continue retry;\n                                     }\n                                     skipEOLs();\n                                     token \u003d next();\n                                     lineno \u003d stream.getLineno();\n                                     charno \u003d stream.getCharno();\n                                 }\n                                 String name \u003d null;\n                                 boolean isBracketedParam \u003d JsDocToken.LB \u003d\u003d token;\n                                 if (isBracketedParam) {\n                                     token \u003d next();\n                                 }\n                                 if (JsDocToken.STRING !\u003d token) {\n                                     parser.addTypeWarning(\"msg.missing.variable.name\", lineno, charno);\n                                 } else {\n                                     name \u003d stream.getString();\n                                     if (isBracketedParam) {\n                                         token \u003d next();\n                                         if (JsDocToken.EQUALS \u003d\u003d token) {\n                                             token \u003d next();\n                                             if (JsDocToken.STRING \u003d\u003d token) {\n                                                 token \u003d next();\n                                             }\n                                         }\n                                         if (JsDocToken.RB !\u003d token) {\n                                             reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                                         } else if (type !\u003d null) {\n                                             type \u003d JSTypeExpression.makeOptionalArg(type);\n                                         }\n                                     }\n                                     if (name.indexOf(\u0027.\u0027) \u003e -1) {\n                                         name \u003d null;\n                                     } else if (!jsdocBuilder.recordParameter(name, type)) {\n                                         if (jsdocBuilder.hasParameter(name)) {\n                                             parser.addTypeWarning(\"msg.dup.variable.name\", name, lineno, charno);\n                                         } else {\n                                             parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name, lineno, charno);\n                                         }\n                                     }\n                                 }\n                                 if (name \u003d\u003d null) {\n                                     token \u003d eatTokensUntilEOL(token);\n                                     continue retry;\n                                 }\n                                 jsdocBuilder.markName(name, sourceFile, lineno, charno);\n                                 if (jsdocBuilder.shouldParseDocumentation()) {\n                                     ExtractionInfo paramDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                     String paramDescription \u003d paramDescriptionInfo.string;\n                                     if (paramDescription.length() \u003e 0) {\n                                         jsdocBuilder.recordParameterDescription(name, paramDescription);\n                                     }\n                                     token \u003d paramDescriptionInfo.token;\n                                 } else {\n                                     token \u003d eatTokensUntilEOL(token);\n                                 }\n                                 continue retry;\n                             case PRESERVE_TRY:\n                                 if (!jsdocBuilder.recordPreserveTry()) {\n                                     parser.addParserWarning(\"msg.jsdoc.preservertry\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PRIVATE:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                                     parser.addParserWarning(\"msg.jsdoc.visibility.private\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PROTECTED:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                                     parser.addParserWarning(\"msg.jsdoc.visibility.protected\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PUBLIC:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                                     parser.addParserWarning(\"msg.jsdoc.visibility.public\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_SHADOW:\n                                 if (!jsdocBuilder.recordNoShadow()) {\n                                     parser.addParserWarning(\"msg.jsdoc.noshadow\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_SIDE_EFFECTS:\n                                 if (!jsdocBuilder.recordNoSideEffects()) {\n                                     parser.addParserWarning(\"msg.jsdoc.nosideeffects\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case MODIFIES:\n                                 token \u003d parseModifiesTag(next());\n                                 continue retry;\n                             case IMPLICIT_CAST:\n                                 if (!jsdocBuilder.recordImplicitCast()) {\n                                     parser.addTypeWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case SEE:\n                                 if (jsdocBuilder.shouldParseDocumentation()) {\n                                     ExtractionInfo referenceInfo \u003d extractSingleLineBlock();\n                                     String reference \u003d referenceInfo.string;\n                                     if (reference.length() \u003d\u003d 0) {\n                                         parser.addParserWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno());\n                                     } else {\n                                         jsdocBuilder.addReference(reference);\n                                     }\n                                     token \u003d referenceInfo.token;\n                                 } else {\n                                     token \u003d eatTokensUntilEOL(token);\n                                 }\n                                 continue retry;\n                             case SUPPRESS:\n                                 token \u003d parseSuppressTag(next());\n                                 continue retry;\n                             case TEMPLATE:\n                                 ExtractionInfo templateInfo \u003d extractSingleLineBlock();\n                                 String templateTypeName \u003d templateInfo.string;\n                                 if (templateTypeName.length() \u003d\u003d 0) {\n                                     parser.addTypeWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno());\n                                 } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {\n                                     parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d templateInfo.token;\n                                 continue retry;\n                             case IDGENERATOR:\n                                 if (!jsdocBuilder.recordIdGenerator()) {\n                                     parser.addParserWarning(\"msg.jsdoc.idgen\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case VERSION:\n                                 ExtractionInfo versionInfo \u003d extractSingleLineBlock();\n                                 String version \u003d versionInfo.string;\n                                 if (version.length() \u003d\u003d 0) {\n                                     parser.addParserWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno());\n                                 } else {\n                                     if (!jsdocBuilder.recordVersion(version)) {\n                                         parser.addParserWarning(\"msg.jsdoc.extraversion\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d versionInfo.token;\n                                 continue retry;\n                             case DEFINE:\n                             case RETURN:\n                             case THIS:\n                             case TYPE:\n                             case TYPEDEF:\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 Node typeNode \u003d null;\n                                 if (!lookAheadForTypeAnnotation() \u0026\u0026 annotation \u003d\u003d Annotation.RETURN) {\n                                     typeNode \u003d newNode(Token.QMARK);\n                                 } else {\n                                     skipEOLs();\n                                     token \u003d next();\n                                     typeNode \u003d parseAndRecordTypeNode(token);\n                                 }\n                                 if (annotation \u003d\u003d Annotation.THIS) {\n                                     typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                     if (typeNode !\u003d null \u0026\u0026 token !\u003d JsDocToken.LC) {\n                                         typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                     }\n                                 }\n                                 type \u003d createJSTypeExpression(typeNode);\n                                 if (type \u003d\u003d null) {\n                                 } else {\n                                     switch(annotation) {\n                                         case DEFINE:\n                                             if (!jsdocBuilder.recordDefineType(type)) {\n                                                 parser.addParserWarning(\"msg.jsdoc.define\", lineno, charno);\n                                             }\n                                             break;\n                                         case RETURN:\n                                             if (!jsdocBuilder.recordReturnType(type)) {\n                                                 parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                                 break;\n                                             }\n                                             if (jsdocBuilder.shouldParseDocumentation()) {\n                                                 ExtractionInfo returnDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                                 String returnDescription \u003d returnDescriptionInfo.string;\n                                                 if (returnDescription.length() \u003e 0) {\n                                                     jsdocBuilder.recordReturnDescription(returnDescription);\n                                                 }\n                                                 token \u003d returnDescriptionInfo.token;\n                                             } else {\n                                                 token \u003d eatTokensUntilEOL(token);\n                                             }\n                                             continue retry;\n                                         case THIS:\n                                             if (!jsdocBuilder.recordThisType(type)) {\n                                                 parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                         case TYPE:\n                                             if (!jsdocBuilder.recordType(type)) {\n                                                 parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                         case TYPEDEF:\n                                             if (!jsdocBuilder.recordTypedef(type)) {\n                                                 parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                     }\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                         }\n                     }\n                 }\n                 break;\n             case EOC:\n                 if (hasParsedFileOverviewDocInfo()) {\n                     fileOverviewJSDocInfo \u003d retrieveAndResetParsedJSDocInfo();\n                 }\n                 checkExtendedTypes(extendedTypes);\n                 return true;\n             case EOF:\n                 jsdocBuilder.build(null);\n                 parser.addParserWarning(\"msg.unexpected.eof\", stream.getLineno(), stream.getCharno());\n                 checkExtendedTypes(extendedTypes);\n                 return false;\n             case EOL:\n                 if (state \u003d\u003d State.SEARCHING_NEWLINE) {\n                     state \u003d State.SEARCHING_ANNOTATION;\n                 }\n                 token \u003d next();\n                 continue retry;\n             default:\n                 if (token \u003d\u003d JsDocToken.STAR \u0026\u0026 state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                     token \u003d next();\n                     continue retry;\n                 } else {\n                     state \u003d State.SEARCHING_NEWLINE;\n                     token \u003d eatTokensUntilEOL();\n                     continue retry;\n                 }\n         }\n         token \u003d next();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b8086ea9d7cd87db9f1624f8eb0d6e4550e55495": {
      "type": "Ybodychange",
      "commitMessage": "\nRecord the source file in params, so that they get proper source info\n\nR\u003djschorr\nDELTA\u003d35  (24 added, 0 deleted, 11 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3361\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1468 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "9/28/11, 4:25 PM",
      "commitName": "b8086ea9d7cd87db9f1624f8eb0d6e4550e55495",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "9/14/11, 8:18 AM",
      "commitNameOld": "ff67789e6125face69d6dc28697121cb3b6df854",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 14.34,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "actualSource": "boolean parse() {\n    int lineno;\n    int charno;\n    JSTypeExpression type;\n    state \u003d State.SEARCHING_ANNOTATION;\n    skipEOLs();\n    JsDocToken token \u003d next();\n    List\u003cExtendedTypeInfo\u003e extendedTypes \u003d Lists.newArrayList();\n    if (jsdocBuilder.shouldParseDocumentation()) {\n        ExtractionInfo blockInfo \u003d extractBlockComment(token);\n        token \u003d blockInfo.token;\n        if (!blockInfo.string.isEmpty()) {\n            jsdocBuilder.recordBlockDescription(blockInfo.string);\n        }\n    } else {\n        if (token !\u003d JsDocToken.ANNOTATION \u0026\u0026 token !\u003d JsDocToken.EOC) {\n            jsdocBuilder.recordBlockDescription(\"\");\n        }\n    }\n    retry: for (; ; ) {\n        switch(token) {\n            case ANNOTATION:\n                if (state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                    state \u003d State.SEARCHING_NEWLINE;\n                    lineno \u003d stream.getLineno();\n                    charno \u003d stream.getCharno();\n                    String annotationName \u003d stream.getString();\n                    Annotation annotation \u003d annotationNames.get(annotationName);\n                    if (annotation \u003d\u003d null) {\n                        parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno());\n                    } else {\n                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n                        switch(annotation) {\n                            case AUTHOR:\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo authorInfo \u003d extractSingleLineBlock();\n                                    String author \u003d authorInfo.string;\n                                    if (author.length() \u003d\u003d 0) {\n                                        parser.addParserWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        jsdocBuilder.addAuthor(author);\n                                    }\n                                    token \u003d authorInfo.token;\n                                } else {\n                                    token \u003d eatTokensUntilEOL(token);\n                                }\n                                continue retry;\n                            case CONSISTENTIDGENERATOR:\n                                if (!jsdocBuilder.recordConsistentIdGenerator()) {\n                                    parser.addParserWarning(\"msg.jsdoc.consistidgen\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case CONSTANT:\n                                if (!jsdocBuilder.recordConstancy()) {\n                                    parser.addParserWarning(\"msg.jsdoc.const\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case CONSTRUCTOR:\n                                if (!jsdocBuilder.recordConstructor()) {\n                                    if (jsdocBuilder.isInterfaceRecorded()) {\n                                        parser.addTypeWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        parser.addTypeWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case DEPRECATED:\n                                if (!jsdocBuilder.recordDeprecated()) {\n                                    parser.addParserWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno());\n                                }\n                                ExtractionInfo reasonInfo \u003d extractMultilineTextualBlock(token);\n                                String reason \u003d reasonInfo.string;\n                                if (reason.length() \u003e 0) {\n                                    jsdocBuilder.recordDeprecationReason(reason);\n                                }\n                                token \u003d reasonInfo.token;\n                                continue retry;\n                            case INTERFACE:\n                                if (!jsdocBuilder.recordInterface()) {\n                                    if (jsdocBuilder.isConstructorRecorded()) {\n                                        parser.addTypeWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        parser.addTypeWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case DESC:\n                                if (jsdocBuilder.isDescriptionRecorded()) {\n                                    parser.addParserWarning(\"msg.jsdoc.desc.extra\", stream.getLineno(), stream.getCharno());\n                                    token \u003d eatTokensUntilEOL();\n                                    continue retry;\n                                } else {\n                                    ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                    String description \u003d descriptionInfo.string;\n                                    jsdocBuilder.recordDescription(description);\n                                    token \u003d descriptionInfo.token;\n                                    continue retry;\n                                }\n                            case FILE_OVERVIEW:\n                                String fileOverview \u003d \"\";\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo fileOverviewInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.TRIM);\n                                    fileOverview \u003d fileOverviewInfo.string;\n                                    token \u003d fileOverviewInfo.token;\n                                } else {\n                                    token \u003d eatTokensUntilEOL(token);\n                                }\n                                if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo !\u003d null) {\n                                    parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno());\n                                }\n                                continue retry;\n                            case LICENSE:\n                            case PRESERVE:\n                                ExtractionInfo preserveInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);\n                                String preserve \u003d preserveInfo.string;\n                                if (preserve.length() \u003e 0) {\n                                    if (fileLevelJsDocBuilder !\u003d null) {\n                                        fileLevelJsDocBuilder.append(preserve);\n                                    }\n                                }\n                                token \u003d preserveInfo.token;\n                                continue retry;\n                            case ENUM:\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                }\n                                if (type \u003d\u003d null) {\n                                    type \u003d createJSTypeExpression(newStringNode(\"number\"));\n                                }\n                                if (!jsdocBuilder.recordEnumParameterType(type)) {\n                                    parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                }\n                                token \u003d eatTokensUntilEOL(token);\n                                continue retry;\n                            case EXPORT:\n                                if (!jsdocBuilder.recordExport()) {\n                                    parser.addParserWarning(\"msg.jsdoc.export\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case EXTERNS:\n                                if (!jsdocBuilder.recordExterns()) {\n                                    parser.addParserWarning(\"msg.jsdoc.externs\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case JAVA_DISPATCH:\n                                if (!jsdocBuilder.recordJavaDispatch()) {\n                                    parser.addParserWarning(\"msg.jsdoc.javadispatch\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case EXTENDS:\n                            case IMPLEMENTS:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                boolean matchingRc \u003d false;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    token \u003d next();\n                                    matchingRc \u003d true;\n                                }\n                                if (token \u003d\u003d JsDocToken.STRING) {\n                                    Node typeNode \u003d parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);\n                                    lineno \u003d stream.getLineno();\n                                    charno \u003d stream.getCharno();\n                                    typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                    if (typeNode !\u003d null \u0026\u0026 !matchingRc) {\n                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                    }\n                                    type \u003d createJSTypeExpression(typeNode);\n                                    if (annotation \u003d\u003d Annotation.EXTENDS) {\n                                        extendedTypes.add(new ExtendedTypeInfo(type, stream.getLineno(), stream.getCharno()));\n                                    } else {\n                                        Preconditions.checkState(annotation \u003d\u003d Annotation.IMPLEMENTS);\n                                        if (!jsdocBuilder.recordImplementedInterface(type)) {\n                                            parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\", lineno, charno);\n                                        }\n                                    }\n                                    token \u003d next();\n                                    if (matchingRc) {\n                                        if (token !\u003d JsDocToken.RC) {\n                                            parser.addTypeWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                        }\n                                    } else if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOF \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                        parser.addTypeWarning(\"msg.end.annotation.expected\", stream.getLineno(), stream.getCharno());\n                                    }\n                                } else {\n                                    parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);\n                                }\n                                token \u003d eatTokensUntilEOL(token);\n                                continue retry;\n                            case HIDDEN:\n                                if (!jsdocBuilder.recordHiddenness()) {\n                                    parser.addParserWarning(\"msg.jsdoc.hidden\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case LENDS:\n                                skipEOLs();\n                                matchingRc \u003d false;\n                                if (match(JsDocToken.LC)) {\n                                    token \u003d next();\n                                    matchingRc \u003d true;\n                                }\n                                if (match(JsDocToken.STRING)) {\n                                    token \u003d next();\n                                    if (!jsdocBuilder.recordLends(stream.getString())) {\n                                        parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\", stream.getLineno(), stream.getCharno());\n                                    }\n                                } else {\n                                    parser.addTypeWarning(\"msg.jsdoc.lends.missing\", stream.getLineno(), stream.getCharno());\n                                }\n                                if (matchingRc \u0026\u0026 !match(JsDocToken.RC)) {\n                                    parser.addTypeWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case MEANING:\n                                ExtractionInfo meaningInfo \u003d extractMultilineTextualBlock(token);\n                                String meaning \u003d meaningInfo.string;\n                                token \u003d meaningInfo.token;\n                                if (!jsdocBuilder.recordMeaning(meaning)) {\n                                    parser.addParserWarning(\"msg.jsdoc.meaning.extra\", stream.getLineno(), stream.getCharno());\n                                }\n                                continue retry;\n                            case NO_ALIAS:\n                                if (!jsdocBuilder.recordNoAlias()) {\n                                    parser.addParserWarning(\"msg.jsdoc.noalias\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_COMPILE:\n                                if (!jsdocBuilder.recordNoCompile()) {\n                                    parser.addParserWarning(\"msg.jsdoc.nocompile\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_TYPE_CHECK:\n                                if (!jsdocBuilder.recordNoTypeCheck()) {\n                                    parser.addParserWarning(\"msg.jsdoc.nocheck\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NOT_IMPLEMENTED:\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case INHERIT_DOC:\n                            case OVERRIDE:\n                                if (!jsdocBuilder.recordOverride()) {\n                                    parser.addTypeWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case THROWS:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                    if (type \u003d\u003d null) {\n                                        token \u003d eatTokensUntilEOL();\n                                        continue retry;\n                                    }\n                                }\n                                token \u003d current();\n                                jsdocBuilder.recordThrowType(type);\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                    String description \u003d descriptionInfo.string;\n                                    if (description.length() \u003e 0) {\n                                        jsdocBuilder.recordThrowDescription(type, description);\n                                    }\n                                    token \u003d descriptionInfo.token;\n                                } else {\n                                    token \u003d eatTokensUntilEOL(token);\n                                }\n                                continue retry;\n                            case PARAM:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordParamTypeNode(token));\n                                    if (type \u003d\u003d null) {\n                                        token \u003d eatTokensUntilEOL();\n                                        continue retry;\n                                    }\n                                    skipEOLs();\n                                    token \u003d next();\n                                    lineno \u003d stream.getLineno();\n                                    charno \u003d stream.getCharno();\n                                }\n                                String name \u003d null;\n                                boolean isBracketedParam \u003d JsDocToken.LB \u003d\u003d token;\n                                if (isBracketedParam) {\n                                    token \u003d next();\n                                }\n                                if (JsDocToken.STRING !\u003d token) {\n                                    parser.addTypeWarning(\"msg.missing.variable.name\", lineno, charno);\n                                } else {\n                                    name \u003d stream.getString();\n                                    if (isBracketedParam) {\n                                        token \u003d next();\n                                        if (JsDocToken.EQUALS \u003d\u003d token) {\n                                            token \u003d next();\n                                            if (JsDocToken.STRING \u003d\u003d token) {\n                                                token \u003d next();\n                                            }\n                                        }\n                                        if (JsDocToken.RB !\u003d token) {\n                                            reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                                        } else if (type !\u003d null) {\n                                            type \u003d JSTypeExpression.makeOptionalArg(type);\n                                        }\n                                    }\n                                    if (name.indexOf(\u0027.\u0027) \u003e -1) {\n                                        name \u003d null;\n                                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                                        if (jsdocBuilder.hasParameter(name)) {\n                                            parser.addTypeWarning(\"msg.dup.variable.name\", name, lineno, charno);\n                                        } else {\n                                            parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name, lineno, charno);\n                                        }\n                                    }\n                                }\n                                if (name \u003d\u003d null) {\n                                    token \u003d eatTokensUntilEOL(token);\n                                    continue retry;\n                                }\n                                jsdocBuilder.markName(name, sourceFile, lineno, charno);\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo paramDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                    String paramDescription \u003d paramDescriptionInfo.string;\n                                    if (paramDescription.length() \u003e 0) {\n                                        jsdocBuilder.recordParameterDescription(name, paramDescription);\n                                    }\n                                    token \u003d paramDescriptionInfo.token;\n                                } else {\n                                    token \u003d eatTokensUntilEOL(token);\n                                }\n                                continue retry;\n                            case PRESERVE_TRY:\n                                if (!jsdocBuilder.recordPreserveTry()) {\n                                    parser.addParserWarning(\"msg.jsdoc.preservertry\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PRIVATE:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                                    parser.addParserWarning(\"msg.jsdoc.visibility.private\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PROTECTED:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                                    parser.addParserWarning(\"msg.jsdoc.visibility.protected\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PUBLIC:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                                    parser.addParserWarning(\"msg.jsdoc.visibility.public\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_SHADOW:\n                                if (!jsdocBuilder.recordNoShadow()) {\n                                    parser.addParserWarning(\"msg.jsdoc.noshadow\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_SIDE_EFFECTS:\n                                if (!jsdocBuilder.recordNoSideEffects()) {\n                                    parser.addParserWarning(\"msg.jsdoc.nosideeffects\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case MODIFIES:\n                                token \u003d parseModifiesTag(next());\n                                continue retry;\n                            case IMPLICIT_CAST:\n                                if (!jsdocBuilder.recordImplicitCast()) {\n                                    parser.addTypeWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case SEE:\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo referenceInfo \u003d extractSingleLineBlock();\n                                    String reference \u003d referenceInfo.string;\n                                    if (reference.length() \u003d\u003d 0) {\n                                        parser.addParserWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        jsdocBuilder.addReference(reference);\n                                    }\n                                    token \u003d referenceInfo.token;\n                                } else {\n                                    token \u003d eatTokensUntilEOL(token);\n                                }\n                                continue retry;\n                            case SUPPRESS:\n                                token \u003d parseSuppressTag(next());\n                                continue retry;\n                            case TEMPLATE:\n                                ExtractionInfo templateInfo \u003d extractSingleLineBlock();\n                                String templateTypeName \u003d templateInfo.string;\n                                if (templateTypeName.length() \u003d\u003d 0) {\n                                    parser.addTypeWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno());\n                                } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {\n                                    parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d templateInfo.token;\n                                continue retry;\n                            case IDGENERATOR:\n                                if (!jsdocBuilder.recordIdGenerator()) {\n                                    parser.addParserWarning(\"msg.jsdoc.idgen\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case VERSION:\n                                ExtractionInfo versionInfo \u003d extractSingleLineBlock();\n                                String version \u003d versionInfo.string;\n                                if (version.length() \u003d\u003d 0) {\n                                    parser.addParserWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno());\n                                } else {\n                                    if (!jsdocBuilder.recordVersion(version)) {\n                                        parser.addParserWarning(\"msg.jsdoc.extraversion\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d versionInfo.token;\n                                continue retry;\n                            case DEFINE:\n                            case RETURN:\n                            case THIS:\n                            case TYPE:\n                            case TYPEDEF:\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                Node typeNode \u003d null;\n                                if (!lookAheadForTypeAnnotation() \u0026\u0026 annotation \u003d\u003d Annotation.RETURN) {\n                                    typeNode \u003d newNode(Token.QMARK);\n                                } else {\n                                    skipEOLs();\n                                    token \u003d next();\n                                    typeNode \u003d parseAndRecordTypeNode(token);\n                                }\n                                if (annotation \u003d\u003d Annotation.THIS) {\n                                    typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                    if (typeNode !\u003d null \u0026\u0026 token !\u003d JsDocToken.LC) {\n                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                    }\n                                }\n                                type \u003d createJSTypeExpression(typeNode);\n                                if (type \u003d\u003d null) {\n                                } else {\n                                    switch(annotation) {\n                                        case DEFINE:\n                                            if (!jsdocBuilder.recordDefineType(type)) {\n                                                parser.addParserWarning(\"msg.jsdoc.define\", lineno, charno);\n                                            }\n                                            break;\n                                        case RETURN:\n                                            if (!jsdocBuilder.recordReturnType(type)) {\n                                                parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                                break;\n                                            }\n                                            if (jsdocBuilder.shouldParseDocumentation()) {\n                                                ExtractionInfo returnDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                                String returnDescription \u003d returnDescriptionInfo.string;\n                                                if (returnDescription.length() \u003e 0) {\n                                                    jsdocBuilder.recordReturnDescription(returnDescription);\n                                                }\n                                                token \u003d returnDescriptionInfo.token;\n                                            } else {\n                                                token \u003d eatTokensUntilEOL(token);\n                                            }\n                                            continue retry;\n                                        case THIS:\n                                            if (!jsdocBuilder.recordThisType(type)) {\n                                                parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                        case TYPE:\n                                            if (!jsdocBuilder.recordType(type)) {\n                                                parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                        case TYPEDEF:\n                                            if (!jsdocBuilder.recordTypedef(type)) {\n                                                parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                    }\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                        }\n                    }\n                }\n                break;\n            case EOC:\n                if (hasParsedFileOverviewDocInfo()) {\n                    fileOverviewJSDocInfo \u003d retrieveAndResetParsedJSDocInfo();\n                }\n                checkExtendedTypes(extendedTypes);\n                return true;\n            case EOF:\n                jsdocBuilder.build(null);\n                parser.addParserWarning(\"msg.unexpected.eof\", stream.getLineno(), stream.getCharno());\n                checkExtendedTypes(extendedTypes);\n                return false;\n            case EOL:\n                if (state \u003d\u003d State.SEARCHING_NEWLINE) {\n                    state \u003d State.SEARCHING_ANNOTATION;\n                }\n                token \u003d next();\n                continue retry;\n            default:\n                if (token \u003d\u003d JsDocToken.STAR \u0026\u0026 state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                    token \u003d next();\n                    continue retry;\n                } else {\n                    state \u003d State.SEARCHING_NEWLINE;\n                    token \u003d eatTokensUntilEOL();\n                    continue retry;\n                }\n        }\n        token \u003d next();\n    }\n}",
      "path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
      "functionStartLine": 180,
      "functionName": "parse",
      "functionAnnotation": "",
      "functionDoc": "Parses a {@link JSDocInfo} object. This parsing method reads all tokens\nreturned by the {@link JsDocTokenStream#getJsDocToken()} method until the\n{@link JsDocToken#EOC} is returned.\n\n@return @code true} if JSDoc information was correctly parsed,\n    {@code false} otherwise\n",
      "diff": "@@ -1,544 +1,544 @@\n boolean parse() {\n     int lineno;\n     int charno;\n     JSTypeExpression type;\n     state \u003d State.SEARCHING_ANNOTATION;\n     skipEOLs();\n     JsDocToken token \u003d next();\n     List\u003cExtendedTypeInfo\u003e extendedTypes \u003d Lists.newArrayList();\n     if (jsdocBuilder.shouldParseDocumentation()) {\n         ExtractionInfo blockInfo \u003d extractBlockComment(token);\n         token \u003d blockInfo.token;\n         if (!blockInfo.string.isEmpty()) {\n             jsdocBuilder.recordBlockDescription(blockInfo.string);\n         }\n     } else {\n         if (token !\u003d JsDocToken.ANNOTATION \u0026\u0026 token !\u003d JsDocToken.EOC) {\n             jsdocBuilder.recordBlockDescription(\"\");\n         }\n     }\n     retry: for (; ; ) {\n         switch(token) {\n             case ANNOTATION:\n                 if (state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                     state \u003d State.SEARCHING_NEWLINE;\n                     lineno \u003d stream.getLineno();\n                     charno \u003d stream.getCharno();\n                     String annotationName \u003d stream.getString();\n                     Annotation annotation \u003d annotationNames.get(annotationName);\n                     if (annotation \u003d\u003d null) {\n                         parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno());\n                     } else {\n                         jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n                         switch(annotation) {\n                             case AUTHOR:\n                                 if (jsdocBuilder.shouldParseDocumentation()) {\n                                     ExtractionInfo authorInfo \u003d extractSingleLineBlock();\n                                     String author \u003d authorInfo.string;\n                                     if (author.length() \u003d\u003d 0) {\n                                         parser.addParserWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno());\n                                     } else {\n                                         jsdocBuilder.addAuthor(author);\n                                     }\n                                     token \u003d authorInfo.token;\n                                 } else {\n                                     token \u003d eatTokensUntilEOL(token);\n                                 }\n                                 continue retry;\n                             case CONSISTENTIDGENERATOR:\n                                 if (!jsdocBuilder.recordConsistentIdGenerator()) {\n                                     parser.addParserWarning(\"msg.jsdoc.consistidgen\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case CONSTANT:\n                                 if (!jsdocBuilder.recordConstancy()) {\n                                     parser.addParserWarning(\"msg.jsdoc.const\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case CONSTRUCTOR:\n                                 if (!jsdocBuilder.recordConstructor()) {\n                                     if (jsdocBuilder.isInterfaceRecorded()) {\n                                         parser.addTypeWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                     } else {\n                                         parser.addTypeWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case DEPRECATED:\n                                 if (!jsdocBuilder.recordDeprecated()) {\n                                     parser.addParserWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 ExtractionInfo reasonInfo \u003d extractMultilineTextualBlock(token);\n                                 String reason \u003d reasonInfo.string;\n                                 if (reason.length() \u003e 0) {\n                                     jsdocBuilder.recordDeprecationReason(reason);\n                                 }\n                                 token \u003d reasonInfo.token;\n                                 continue retry;\n                             case INTERFACE:\n                                 if (!jsdocBuilder.recordInterface()) {\n                                     if (jsdocBuilder.isConstructorRecorded()) {\n                                         parser.addTypeWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                     } else {\n                                         parser.addTypeWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case DESC:\n                                 if (jsdocBuilder.isDescriptionRecorded()) {\n                                     parser.addParserWarning(\"msg.jsdoc.desc.extra\", stream.getLineno(), stream.getCharno());\n                                     token \u003d eatTokensUntilEOL();\n                                     continue retry;\n                                 } else {\n                                     ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                     String description \u003d descriptionInfo.string;\n                                     jsdocBuilder.recordDescription(description);\n                                     token \u003d descriptionInfo.token;\n                                     continue retry;\n                                 }\n                             case FILE_OVERVIEW:\n                                 String fileOverview \u003d \"\";\n                                 if (jsdocBuilder.shouldParseDocumentation()) {\n                                     ExtractionInfo fileOverviewInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.TRIM);\n                                     fileOverview \u003d fileOverviewInfo.string;\n                                     token \u003d fileOverviewInfo.token;\n                                 } else {\n                                     token \u003d eatTokensUntilEOL(token);\n                                 }\n                                 if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo !\u003d null) {\n                                     parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 continue retry;\n                             case LICENSE:\n                             case PRESERVE:\n                                 ExtractionInfo preserveInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);\n                                 String preserve \u003d preserveInfo.string;\n                                 if (preserve.length() \u003e 0) {\n                                     if (fileLevelJsDocBuilder !\u003d null) {\n                                         fileLevelJsDocBuilder.append(preserve);\n                                     }\n                                 }\n                                 token \u003d preserveInfo.token;\n                                 continue retry;\n                             case ENUM:\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                 }\n                                 if (type \u003d\u003d null) {\n                                     type \u003d createJSTypeExpression(newStringNode(\"number\"));\n                                 }\n                                 if (!jsdocBuilder.recordEnumParameterType(type)) {\n                                     parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                 }\n                                 token \u003d eatTokensUntilEOL(token);\n                                 continue retry;\n                             case EXPORT:\n                                 if (!jsdocBuilder.recordExport()) {\n                                     parser.addParserWarning(\"msg.jsdoc.export\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case EXTERNS:\n                                 if (!jsdocBuilder.recordExterns()) {\n                                     parser.addParserWarning(\"msg.jsdoc.externs\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case JAVA_DISPATCH:\n                                 if (!jsdocBuilder.recordJavaDispatch()) {\n                                     parser.addParserWarning(\"msg.jsdoc.javadispatch\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case EXTENDS:\n                             case IMPLEMENTS:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 boolean matchingRc \u003d false;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     token \u003d next();\n                                     matchingRc \u003d true;\n                                 }\n                                 if (token \u003d\u003d JsDocToken.STRING) {\n                                     Node typeNode \u003d parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);\n                                     lineno \u003d stream.getLineno();\n                                     charno \u003d stream.getCharno();\n                                     typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                     if (typeNode !\u003d null \u0026\u0026 !matchingRc) {\n                                         typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                     }\n                                     type \u003d createJSTypeExpression(typeNode);\n                                     if (annotation \u003d\u003d Annotation.EXTENDS) {\n                                         extendedTypes.add(new ExtendedTypeInfo(type, stream.getLineno(), stream.getCharno()));\n                                     } else {\n                                         Preconditions.checkState(annotation \u003d\u003d Annotation.IMPLEMENTS);\n                                         if (!jsdocBuilder.recordImplementedInterface(type)) {\n                                             parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\", lineno, charno);\n                                         }\n                                     }\n                                     token \u003d next();\n                                     if (matchingRc) {\n                                         if (token !\u003d JsDocToken.RC) {\n                                             parser.addTypeWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                         }\n                                     } else if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOF \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                         parser.addTypeWarning(\"msg.end.annotation.expected\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 } else {\n                                     parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);\n                                 }\n                                 token \u003d eatTokensUntilEOL(token);\n                                 continue retry;\n                             case HIDDEN:\n                                 if (!jsdocBuilder.recordHiddenness()) {\n                                     parser.addParserWarning(\"msg.jsdoc.hidden\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case LENDS:\n                                 skipEOLs();\n                                 matchingRc \u003d false;\n                                 if (match(JsDocToken.LC)) {\n                                     token \u003d next();\n                                     matchingRc \u003d true;\n                                 }\n                                 if (match(JsDocToken.STRING)) {\n                                     token \u003d next();\n                                     if (!jsdocBuilder.recordLends(stream.getString())) {\n                                         parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 } else {\n                                     parser.addTypeWarning(\"msg.jsdoc.lends.missing\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 if (matchingRc \u0026\u0026 !match(JsDocToken.RC)) {\n                                     parser.addTypeWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case MEANING:\n                                 ExtractionInfo meaningInfo \u003d extractMultilineTextualBlock(token);\n                                 String meaning \u003d meaningInfo.string;\n                                 token \u003d meaningInfo.token;\n                                 if (!jsdocBuilder.recordMeaning(meaning)) {\n                                     parser.addParserWarning(\"msg.jsdoc.meaning.extra\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 continue retry;\n                             case NO_ALIAS:\n                                 if (!jsdocBuilder.recordNoAlias()) {\n                                     parser.addParserWarning(\"msg.jsdoc.noalias\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_COMPILE:\n                                 if (!jsdocBuilder.recordNoCompile()) {\n                                     parser.addParserWarning(\"msg.jsdoc.nocompile\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_TYPE_CHECK:\n                                 if (!jsdocBuilder.recordNoTypeCheck()) {\n                                     parser.addParserWarning(\"msg.jsdoc.nocheck\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NOT_IMPLEMENTED:\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case INHERIT_DOC:\n                             case OVERRIDE:\n                                 if (!jsdocBuilder.recordOverride()) {\n                                     parser.addTypeWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case THROWS:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                     if (type \u003d\u003d null) {\n                                         token \u003d eatTokensUntilEOL();\n                                         continue retry;\n                                     }\n                                 }\n                                 token \u003d current();\n                                 jsdocBuilder.recordThrowType(type);\n                                 if (jsdocBuilder.shouldParseDocumentation()) {\n                                     ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                     String description \u003d descriptionInfo.string;\n                                     if (description.length() \u003e 0) {\n                                         jsdocBuilder.recordThrowDescription(type, description);\n                                     }\n                                     token \u003d descriptionInfo.token;\n                                 } else {\n                                     token \u003d eatTokensUntilEOL(token);\n                                 }\n                                 continue retry;\n                             case PARAM:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordParamTypeNode(token));\n                                     if (type \u003d\u003d null) {\n                                         token \u003d eatTokensUntilEOL();\n                                         continue retry;\n                                     }\n                                     skipEOLs();\n                                     token \u003d next();\n                                     lineno \u003d stream.getLineno();\n                                     charno \u003d stream.getCharno();\n                                 }\n                                 String name \u003d null;\n                                 boolean isBracketedParam \u003d JsDocToken.LB \u003d\u003d token;\n                                 if (isBracketedParam) {\n                                     token \u003d next();\n                                 }\n                                 if (JsDocToken.STRING !\u003d token) {\n                                     parser.addTypeWarning(\"msg.missing.variable.name\", lineno, charno);\n                                 } else {\n                                     name \u003d stream.getString();\n                                     if (isBracketedParam) {\n                                         token \u003d next();\n                                         if (JsDocToken.EQUALS \u003d\u003d token) {\n                                             token \u003d next();\n                                             if (JsDocToken.STRING \u003d\u003d token) {\n                                                 token \u003d next();\n                                             }\n                                         }\n                                         if (JsDocToken.RB !\u003d token) {\n                                             reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                                         } else if (type !\u003d null) {\n                                             type \u003d JSTypeExpression.makeOptionalArg(type);\n                                         }\n                                     }\n                                     if (name.indexOf(\u0027.\u0027) \u003e -1) {\n                                         name \u003d null;\n                                     } else if (!jsdocBuilder.recordParameter(name, type)) {\n                                         if (jsdocBuilder.hasParameter(name)) {\n                                             parser.addTypeWarning(\"msg.dup.variable.name\", name, lineno, charno);\n                                         } else {\n                                             parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name, lineno, charno);\n                                         }\n                                     }\n                                 }\n                                 if (name \u003d\u003d null) {\n                                     token \u003d eatTokensUntilEOL(token);\n                                     continue retry;\n                                 }\n-                                jsdocBuilder.markName(name, lineno, charno);\n+                                jsdocBuilder.markName(name, sourceFile, lineno, charno);\n                                 if (jsdocBuilder.shouldParseDocumentation()) {\n                                     ExtractionInfo paramDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                     String paramDescription \u003d paramDescriptionInfo.string;\n                                     if (paramDescription.length() \u003e 0) {\n                                         jsdocBuilder.recordParameterDescription(name, paramDescription);\n                                     }\n                                     token \u003d paramDescriptionInfo.token;\n                                 } else {\n                                     token \u003d eatTokensUntilEOL(token);\n                                 }\n                                 continue retry;\n                             case PRESERVE_TRY:\n                                 if (!jsdocBuilder.recordPreserveTry()) {\n                                     parser.addParserWarning(\"msg.jsdoc.preservertry\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PRIVATE:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                                     parser.addParserWarning(\"msg.jsdoc.visibility.private\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PROTECTED:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                                     parser.addParserWarning(\"msg.jsdoc.visibility.protected\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PUBLIC:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                                     parser.addParserWarning(\"msg.jsdoc.visibility.public\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_SHADOW:\n                                 if (!jsdocBuilder.recordNoShadow()) {\n                                     parser.addParserWarning(\"msg.jsdoc.noshadow\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_SIDE_EFFECTS:\n                                 if (!jsdocBuilder.recordNoSideEffects()) {\n                                     parser.addParserWarning(\"msg.jsdoc.nosideeffects\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case MODIFIES:\n                                 token \u003d parseModifiesTag(next());\n                                 continue retry;\n                             case IMPLICIT_CAST:\n                                 if (!jsdocBuilder.recordImplicitCast()) {\n                                     parser.addTypeWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case SEE:\n                                 if (jsdocBuilder.shouldParseDocumentation()) {\n                                     ExtractionInfo referenceInfo \u003d extractSingleLineBlock();\n                                     String reference \u003d referenceInfo.string;\n                                     if (reference.length() \u003d\u003d 0) {\n                                         parser.addParserWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno());\n                                     } else {\n                                         jsdocBuilder.addReference(reference);\n                                     }\n                                     token \u003d referenceInfo.token;\n                                 } else {\n                                     token \u003d eatTokensUntilEOL(token);\n                                 }\n                                 continue retry;\n                             case SUPPRESS:\n                                 token \u003d parseSuppressTag(next());\n                                 continue retry;\n                             case TEMPLATE:\n                                 ExtractionInfo templateInfo \u003d extractSingleLineBlock();\n                                 String templateTypeName \u003d templateInfo.string;\n                                 if (templateTypeName.length() \u003d\u003d 0) {\n                                     parser.addTypeWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno());\n                                 } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {\n                                     parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d templateInfo.token;\n                                 continue retry;\n                             case IDGENERATOR:\n                                 if (!jsdocBuilder.recordIdGenerator()) {\n                                     parser.addParserWarning(\"msg.jsdoc.idgen\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case VERSION:\n                                 ExtractionInfo versionInfo \u003d extractSingleLineBlock();\n                                 String version \u003d versionInfo.string;\n                                 if (version.length() \u003d\u003d 0) {\n                                     parser.addParserWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno());\n                                 } else {\n                                     if (!jsdocBuilder.recordVersion(version)) {\n                                         parser.addParserWarning(\"msg.jsdoc.extraversion\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d versionInfo.token;\n                                 continue retry;\n                             case DEFINE:\n                             case RETURN:\n                             case THIS:\n                             case TYPE:\n                             case TYPEDEF:\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 Node typeNode \u003d null;\n                                 if (!lookAheadForTypeAnnotation() \u0026\u0026 annotation \u003d\u003d Annotation.RETURN) {\n                                     typeNode \u003d newNode(Token.QMARK);\n                                 } else {\n                                     skipEOLs();\n                                     token \u003d next();\n                                     typeNode \u003d parseAndRecordTypeNode(token);\n                                 }\n                                 if (annotation \u003d\u003d Annotation.THIS) {\n                                     typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                     if (typeNode !\u003d null \u0026\u0026 token !\u003d JsDocToken.LC) {\n                                         typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                     }\n                                 }\n                                 type \u003d createJSTypeExpression(typeNode);\n                                 if (type \u003d\u003d null) {\n                                 } else {\n                                     switch(annotation) {\n                                         case DEFINE:\n                                             if (!jsdocBuilder.recordDefineType(type)) {\n                                                 parser.addParserWarning(\"msg.jsdoc.define\", lineno, charno);\n                                             }\n                                             break;\n                                         case RETURN:\n                                             if (!jsdocBuilder.recordReturnType(type)) {\n                                                 parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                                 break;\n                                             }\n                                             if (jsdocBuilder.shouldParseDocumentation()) {\n                                                 ExtractionInfo returnDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                                 String returnDescription \u003d returnDescriptionInfo.string;\n                                                 if (returnDescription.length() \u003e 0) {\n                                                     jsdocBuilder.recordReturnDescription(returnDescription);\n                                                 }\n                                                 token \u003d returnDescriptionInfo.token;\n                                             } else {\n                                                 token \u003d eatTokensUntilEOL(token);\n                                             }\n                                             continue retry;\n                                         case THIS:\n                                             if (!jsdocBuilder.recordThisType(type)) {\n                                                 parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                         case TYPE:\n                                             if (!jsdocBuilder.recordType(type)) {\n                                                 parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                         case TYPEDEF:\n                                             if (!jsdocBuilder.recordTypedef(type)) {\n                                                 parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                     }\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                         }\n                     }\n                 }\n                 break;\n             case EOC:\n                 if (hasParsedFileOverviewDocInfo()) {\n                     fileOverviewJSDocInfo \u003d retrieveAndResetParsedJSDocInfo();\n                 }\n                 checkExtendedTypes(extendedTypes);\n                 return true;\n             case EOF:\n                 jsdocBuilder.build(null);\n                 parser.addParserWarning(\"msg.unexpected.eof\", stream.getLineno(), stream.getCharno());\n                 checkExtendedTypes(extendedTypes);\n                 return false;\n             case EOL:\n                 if (state \u003d\u003d State.SEARCHING_NEWLINE) {\n                     state \u003d State.SEARCHING_ANNOTATION;\n                 }\n                 token \u003d next();\n                 continue retry;\n             default:\n                 if (token \u003d\u003d JsDocToken.STAR \u0026\u0026 state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                     token \u003d next();\n                     continue retry;\n                 } else {\n                     state \u003d State.SEARCHING_NEWLINE;\n                     token \u003d eatTokensUntilEOL();\n                     continue retry;\n                 }\n         }\n         token \u003d next();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8ef31dd36e38599736e1c9b6ea1d1e546cba510a": {
      "type": "Ybodychange",
      "commitMessage": "\nId Generator Annotations.\n\nR\u003dmgoodman,kai\nDELTA\u003d298  (260 added, 4 deleted, 34 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d2765\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1298 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "7/27/11, 5:53 PM",
      "commitName": "8ef31dd36e38599736e1c9b6ea1d1e546cba510a",
      "commitAuthor": "acleung@google.com",
      "commitDateOld": "6/30/11, 1:25 PM",
      "commitNameOld": "9320feca198878ca9464aae089399a8891c314d7",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 27.19,
      "commitsBetweenForRepo": 56,
      "commitsBetweenForFile": 1,
      "actualSource": "boolean parse() {\n    int lineno;\n    int charno;\n    JSTypeExpression type;\n    state \u003d State.SEARCHING_ANNOTATION;\n    skipEOLs();\n    JsDocToken token \u003d next();\n    List\u003cExtendedTypeInfo\u003e extendedTypes \u003d Lists.newArrayList();\n    if (jsdocBuilder.shouldParseDocumentation()) {\n        ExtractionInfo blockInfo \u003d extractBlockComment(token);\n        token \u003d blockInfo.token;\n        if (!blockInfo.string.isEmpty()) {\n            jsdocBuilder.recordBlockDescription(blockInfo.string);\n        }\n    } else {\n        if (token !\u003d JsDocToken.ANNOTATION \u0026\u0026 token !\u003d JsDocToken.EOC) {\n            jsdocBuilder.recordBlockDescription(\"\");\n        }\n    }\n    retry: for (; ; ) {\n        switch(token) {\n            case ANNOTATION:\n                if (state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                    state \u003d State.SEARCHING_NEWLINE;\n                    lineno \u003d stream.getLineno();\n                    charno \u003d stream.getCharno();\n                    String annotationName \u003d stream.getString();\n                    Annotation annotation \u003d annotationNames.get(annotationName);\n                    if (annotation \u003d\u003d null) {\n                        parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno());\n                    } else {\n                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n                        switch(annotation) {\n                            case AUTHOR:\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo authorInfo \u003d extractSingleLineBlock();\n                                    String author \u003d authorInfo.string;\n                                    if (author.length() \u003d\u003d 0) {\n                                        parser.addParserWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        jsdocBuilder.addAuthor(author);\n                                    }\n                                    token \u003d authorInfo.token;\n                                } else {\n                                    token \u003d eatTokensUntilEOL(token);\n                                }\n                                continue retry;\n                            case CONSISTENTIDGENERATOR:\n                                if (!jsdocBuilder.recordConsistentIdGenerator()) {\n                                    parser.addParserWarning(\"msg.jsdoc.consistidgen\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case CONSTANT:\n                                if (!jsdocBuilder.recordConstancy()) {\n                                    parser.addParserWarning(\"msg.jsdoc.const\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case CONSTRUCTOR:\n                                if (!jsdocBuilder.recordConstructor()) {\n                                    if (jsdocBuilder.isInterfaceRecorded()) {\n                                        parser.addTypeWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        parser.addTypeWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case DEPRECATED:\n                                if (!jsdocBuilder.recordDeprecated()) {\n                                    parser.addParserWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno());\n                                }\n                                ExtractionInfo reasonInfo \u003d extractMultilineTextualBlock(token);\n                                String reason \u003d reasonInfo.string;\n                                if (reason.length() \u003e 0) {\n                                    jsdocBuilder.recordDeprecationReason(reason);\n                                }\n                                token \u003d reasonInfo.token;\n                                continue retry;\n                            case INTERFACE:\n                                if (!jsdocBuilder.recordInterface()) {\n                                    if (jsdocBuilder.isConstructorRecorded()) {\n                                        parser.addTypeWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        parser.addTypeWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case DESC:\n                                if (jsdocBuilder.isDescriptionRecorded()) {\n                                    parser.addParserWarning(\"msg.jsdoc.desc.extra\", stream.getLineno(), stream.getCharno());\n                                    token \u003d eatTokensUntilEOL();\n                                    continue retry;\n                                } else {\n                                    ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                    String description \u003d descriptionInfo.string;\n                                    jsdocBuilder.recordDescription(description);\n                                    token \u003d descriptionInfo.token;\n                                    continue retry;\n                                }\n                            case FILE_OVERVIEW:\n                                String fileOverview \u003d \"\";\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo fileOverviewInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.TRIM);\n                                    fileOverview \u003d fileOverviewInfo.string;\n                                    token \u003d fileOverviewInfo.token;\n                                } else {\n                                    token \u003d eatTokensUntilEOL(token);\n                                }\n                                if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo !\u003d null) {\n                                    parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno());\n                                }\n                                continue retry;\n                            case LICENSE:\n                            case PRESERVE:\n                                ExtractionInfo preserveInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);\n                                String preserve \u003d preserveInfo.string;\n                                if (preserve.length() \u003e 0) {\n                                    if (fileLevelJsDocBuilder !\u003d null) {\n                                        fileLevelJsDocBuilder.append(preserve);\n                                    }\n                                }\n                                token \u003d preserveInfo.token;\n                                continue retry;\n                            case ENUM:\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                }\n                                if (type \u003d\u003d null) {\n                                    type \u003d createJSTypeExpression(newStringNode(\"number\"));\n                                }\n                                if (!jsdocBuilder.recordEnumParameterType(type)) {\n                                    parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                }\n                                token \u003d eatTokensUntilEOL(token);\n                                continue retry;\n                            case EXPORT:\n                                if (!jsdocBuilder.recordExport()) {\n                                    parser.addParserWarning(\"msg.jsdoc.export\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case EXTERNS:\n                                if (!jsdocBuilder.recordExterns()) {\n                                    parser.addParserWarning(\"msg.jsdoc.externs\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case JAVA_DISPATCH:\n                                if (!jsdocBuilder.recordJavaDispatch()) {\n                                    parser.addParserWarning(\"msg.jsdoc.javadispatch\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case EXTENDS:\n                            case IMPLEMENTS:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                boolean matchingRc \u003d false;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    token \u003d next();\n                                    matchingRc \u003d true;\n                                }\n                                if (token \u003d\u003d JsDocToken.STRING) {\n                                    Node typeNode \u003d parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);\n                                    lineno \u003d stream.getLineno();\n                                    charno \u003d stream.getCharno();\n                                    typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                    if (typeNode !\u003d null \u0026\u0026 !matchingRc) {\n                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                    }\n                                    type \u003d createJSTypeExpression(typeNode);\n                                    if (annotation \u003d\u003d Annotation.EXTENDS) {\n                                        extendedTypes.add(new ExtendedTypeInfo(type, stream.getLineno(), stream.getCharno()));\n                                    } else {\n                                        Preconditions.checkState(annotation \u003d\u003d Annotation.IMPLEMENTS);\n                                        if (!jsdocBuilder.recordImplementedInterface(type)) {\n                                            parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\", lineno, charno);\n                                        }\n                                    }\n                                    token \u003d next();\n                                    if (matchingRc) {\n                                        if (token !\u003d JsDocToken.RC) {\n                                            parser.addTypeWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                        }\n                                    } else if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOF \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                        parser.addTypeWarning(\"msg.end.annotation.expected\", stream.getLineno(), stream.getCharno());\n                                    }\n                                } else {\n                                    parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);\n                                }\n                                token \u003d eatTokensUntilEOL(token);\n                                continue retry;\n                            case HIDDEN:\n                                if (!jsdocBuilder.recordHiddenness()) {\n                                    parser.addParserWarning(\"msg.jsdoc.hidden\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case LENDS:\n                                skipEOLs();\n                                matchingRc \u003d false;\n                                if (match(JsDocToken.LC)) {\n                                    token \u003d next();\n                                    matchingRc \u003d true;\n                                }\n                                if (match(JsDocToken.STRING)) {\n                                    token \u003d next();\n                                    if (!jsdocBuilder.recordLends(stream.getString())) {\n                                        parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\", stream.getLineno(), stream.getCharno());\n                                    }\n                                } else {\n                                    parser.addTypeWarning(\"msg.jsdoc.lends.missing\", stream.getLineno(), stream.getCharno());\n                                }\n                                if (matchingRc \u0026\u0026 !match(JsDocToken.RC)) {\n                                    parser.addTypeWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case MEANING:\n                                ExtractionInfo meaningInfo \u003d extractMultilineTextualBlock(token);\n                                String meaning \u003d meaningInfo.string;\n                                token \u003d meaningInfo.token;\n                                if (!jsdocBuilder.recordMeaning(meaning)) {\n                                    parser.addParserWarning(\"msg.jsdoc.meaning.extra\", stream.getLineno(), stream.getCharno());\n                                }\n                                continue retry;\n                            case NO_ALIAS:\n                                if (!jsdocBuilder.recordNoAlias()) {\n                                    parser.addParserWarning(\"msg.jsdoc.noalias\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_COMPILE:\n                                if (!jsdocBuilder.recordNoCompile()) {\n                                    parser.addParserWarning(\"msg.jsdoc.nocompile\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_TYPE_CHECK:\n                                if (!jsdocBuilder.recordNoTypeCheck()) {\n                                    parser.addParserWarning(\"msg.jsdoc.nocheck\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NOT_IMPLEMENTED:\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case INHERIT_DOC:\n                            case OVERRIDE:\n                                if (!jsdocBuilder.recordOverride()) {\n                                    parser.addTypeWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case THROWS:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                    if (type \u003d\u003d null) {\n                                        token \u003d eatTokensUntilEOL();\n                                        continue retry;\n                                    }\n                                }\n                                token \u003d current();\n                                jsdocBuilder.recordThrowType(type);\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                    String description \u003d descriptionInfo.string;\n                                    if (description.length() \u003e 0) {\n                                        jsdocBuilder.recordThrowDescription(type, description);\n                                    }\n                                    token \u003d descriptionInfo.token;\n                                } else {\n                                    token \u003d eatTokensUntilEOL(token);\n                                }\n                                continue retry;\n                            case PARAM:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordParamTypeNode(token));\n                                    if (type \u003d\u003d null) {\n                                        token \u003d eatTokensUntilEOL();\n                                        continue retry;\n                                    }\n                                    skipEOLs();\n                                    token \u003d next();\n                                    lineno \u003d stream.getLineno();\n                                    charno \u003d stream.getCharno();\n                                }\n                                String name \u003d null;\n                                boolean isBracketedParam \u003d JsDocToken.LB \u003d\u003d token;\n                                if (isBracketedParam) {\n                                    token \u003d next();\n                                }\n                                if (JsDocToken.STRING !\u003d token) {\n                                    parser.addTypeWarning(\"msg.missing.variable.name\", lineno, charno);\n                                } else {\n                                    name \u003d stream.getString();\n                                    if (isBracketedParam) {\n                                        token \u003d next();\n                                        if (JsDocToken.EQUALS \u003d\u003d token) {\n                                            token \u003d next();\n                                            if (JsDocToken.STRING \u003d\u003d token) {\n                                                token \u003d next();\n                                            }\n                                        }\n                                        if (JsDocToken.RB !\u003d token) {\n                                            reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                                        } else if (type !\u003d null) {\n                                            type \u003d JSTypeExpression.makeOptionalArg(type);\n                                        }\n                                    }\n                                    if (name.indexOf(\u0027.\u0027) \u003e -1) {\n                                        name \u003d null;\n                                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                                        if (jsdocBuilder.hasParameter(name)) {\n                                            parser.addTypeWarning(\"msg.dup.variable.name\", name, lineno, charno);\n                                        } else {\n                                            parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name, lineno, charno);\n                                        }\n                                    }\n                                }\n                                if (name \u003d\u003d null) {\n                                    token \u003d eatTokensUntilEOL(token);\n                                    continue retry;\n                                }\n                                jsdocBuilder.markName(name, lineno, charno);\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo paramDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                    String paramDescription \u003d paramDescriptionInfo.string;\n                                    if (paramDescription.length() \u003e 0) {\n                                        jsdocBuilder.recordParameterDescription(name, paramDescription);\n                                    }\n                                    token \u003d paramDescriptionInfo.token;\n                                } else {\n                                    token \u003d eatTokensUntilEOL(token);\n                                }\n                                continue retry;\n                            case PRESERVE_TRY:\n                                if (!jsdocBuilder.recordPreserveTry()) {\n                                    parser.addParserWarning(\"msg.jsdoc.preservertry\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PRIVATE:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                                    parser.addParserWarning(\"msg.jsdoc.visibility.private\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PROTECTED:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                                    parser.addParserWarning(\"msg.jsdoc.visibility.protected\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PUBLIC:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                                    parser.addParserWarning(\"msg.jsdoc.visibility.public\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_SHADOW:\n                                if (!jsdocBuilder.recordNoShadow()) {\n                                    parser.addParserWarning(\"msg.jsdoc.noshadow\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_SIDE_EFFECTS:\n                                if (!jsdocBuilder.recordNoSideEffects()) {\n                                    parser.addParserWarning(\"msg.jsdoc.nosideeffects\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case MODIFIES:\n                                token \u003d parseModifiesTag(next());\n                                continue retry;\n                            case IMPLICIT_CAST:\n                                if (!jsdocBuilder.recordImplicitCast()) {\n                                    parser.addTypeWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case SEE:\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo referenceInfo \u003d extractSingleLineBlock();\n                                    String reference \u003d referenceInfo.string;\n                                    if (reference.length() \u003d\u003d 0) {\n                                        parser.addParserWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        jsdocBuilder.addReference(reference);\n                                    }\n                                    token \u003d referenceInfo.token;\n                                } else {\n                                    token \u003d eatTokensUntilEOL(token);\n                                }\n                                continue retry;\n                            case SUPPRESS:\n                                token \u003d parseSuppressTag(next());\n                                continue retry;\n                            case TEMPLATE:\n                                ExtractionInfo templateInfo \u003d extractSingleLineBlock();\n                                String templateTypeName \u003d templateInfo.string;\n                                if (templateTypeName.length() \u003d\u003d 0) {\n                                    parser.addTypeWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno());\n                                } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {\n                                    parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d templateInfo.token;\n                                continue retry;\n                            case IDGENERATOR:\n                                if (!jsdocBuilder.recordIdGenerator()) {\n                                    parser.addParserWarning(\"msg.jsdoc.idgen\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case VERSION:\n                                ExtractionInfo versionInfo \u003d extractSingleLineBlock();\n                                String version \u003d versionInfo.string;\n                                if (version.length() \u003d\u003d 0) {\n                                    parser.addParserWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno());\n                                } else {\n                                    if (!jsdocBuilder.recordVersion(version)) {\n                                        parser.addParserWarning(\"msg.jsdoc.extraversion\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d versionInfo.token;\n                                continue retry;\n                            case DEFINE:\n                            case RETURN:\n                            case THIS:\n                            case TYPE:\n                            case TYPEDEF:\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                Node typeNode \u003d null;\n                                if (!lookAheadForTypeAnnotation() \u0026\u0026 annotation \u003d\u003d Annotation.RETURN) {\n                                    typeNode \u003d newNode(Token.QMARK);\n                                } else {\n                                    skipEOLs();\n                                    token \u003d next();\n                                    typeNode \u003d parseAndRecordTypeNode(token);\n                                }\n                                if (annotation \u003d\u003d Annotation.THIS) {\n                                    typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                    if (typeNode !\u003d null \u0026\u0026 token !\u003d JsDocToken.LC) {\n                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                    }\n                                }\n                                type \u003d createJSTypeExpression(typeNode);\n                                if (type \u003d\u003d null) {\n                                } else {\n                                    switch(annotation) {\n                                        case DEFINE:\n                                            if (!jsdocBuilder.recordDefineType(type)) {\n                                                parser.addParserWarning(\"msg.jsdoc.define\", lineno, charno);\n                                            }\n                                            break;\n                                        case RETURN:\n                                            if (!jsdocBuilder.recordReturnType(type)) {\n                                                parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                                break;\n                                            }\n                                            if (jsdocBuilder.shouldParseDocumentation()) {\n                                                ExtractionInfo returnDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                                String returnDescription \u003d returnDescriptionInfo.string;\n                                                if (returnDescription.length() \u003e 0) {\n                                                    jsdocBuilder.recordReturnDescription(returnDescription);\n                                                }\n                                                token \u003d returnDescriptionInfo.token;\n                                            } else {\n                                                token \u003d eatTokensUntilEOL(token);\n                                            }\n                                            continue retry;\n                                        case THIS:\n                                            if (!jsdocBuilder.recordThisType(type)) {\n                                                parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                        case TYPE:\n                                            if (!jsdocBuilder.recordType(type)) {\n                                                parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                        case TYPEDEF:\n                                            if (!jsdocBuilder.recordTypedef(type)) {\n                                                parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                    }\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                        }\n                    }\n                }\n                break;\n            case EOC:\n                if (hasParsedFileOverviewDocInfo()) {\n                    fileOverviewJSDocInfo \u003d retrieveAndResetParsedJSDocInfo();\n                }\n                checkExtendedTypes(extendedTypes);\n                return true;\n            case EOF:\n                jsdocBuilder.build(null);\n                parser.addParserWarning(\"msg.unexpected.eof\", stream.getLineno(), stream.getCharno());\n                checkExtendedTypes(extendedTypes);\n                return false;\n            case EOL:\n                if (state \u003d\u003d State.SEARCHING_NEWLINE) {\n                    state \u003d State.SEARCHING_ANNOTATION;\n                }\n                token \u003d next();\n                continue retry;\n            default:\n                if (token \u003d\u003d JsDocToken.STAR \u0026\u0026 state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                    token \u003d next();\n                    continue retry;\n                } else {\n                    state \u003d State.SEARCHING_NEWLINE;\n                    token \u003d eatTokensUntilEOL();\n                    continue retry;\n                }\n        }\n        token \u003d next();\n    }\n}",
      "path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
      "functionStartLine": 176,
      "functionName": "parse",
      "functionAnnotation": "",
      "functionDoc": "Parses a {@link JSDocInfo} object. This parsing method reads all tokens\nreturned by the {@link JsDocTokenStream#getJsDocToken()} method until the\n{@link JsDocToken#EOC} is returned.\n\n@return @code true} if JSDoc information was correctly parsed,\n    {@code false} otherwise\n",
      "diff": "@@ -1,532 +1,544 @@\n boolean parse() {\n     int lineno;\n     int charno;\n     JSTypeExpression type;\n     state \u003d State.SEARCHING_ANNOTATION;\n     skipEOLs();\n     JsDocToken token \u003d next();\n     List\u003cExtendedTypeInfo\u003e extendedTypes \u003d Lists.newArrayList();\n     if (jsdocBuilder.shouldParseDocumentation()) {\n         ExtractionInfo blockInfo \u003d extractBlockComment(token);\n         token \u003d blockInfo.token;\n         if (!blockInfo.string.isEmpty()) {\n             jsdocBuilder.recordBlockDescription(blockInfo.string);\n         }\n     } else {\n         if (token !\u003d JsDocToken.ANNOTATION \u0026\u0026 token !\u003d JsDocToken.EOC) {\n             jsdocBuilder.recordBlockDescription(\"\");\n         }\n     }\n     retry: for (; ; ) {\n         switch(token) {\n             case ANNOTATION:\n                 if (state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                     state \u003d State.SEARCHING_NEWLINE;\n                     lineno \u003d stream.getLineno();\n                     charno \u003d stream.getCharno();\n                     String annotationName \u003d stream.getString();\n                     Annotation annotation \u003d annotationNames.get(annotationName);\n                     if (annotation \u003d\u003d null) {\n                         parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno());\n                     } else {\n                         jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n                         switch(annotation) {\n                             case AUTHOR:\n                                 if (jsdocBuilder.shouldParseDocumentation()) {\n                                     ExtractionInfo authorInfo \u003d extractSingleLineBlock();\n                                     String author \u003d authorInfo.string;\n                                     if (author.length() \u003d\u003d 0) {\n                                         parser.addParserWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno());\n                                     } else {\n                                         jsdocBuilder.addAuthor(author);\n                                     }\n                                     token \u003d authorInfo.token;\n                                 } else {\n                                     token \u003d eatTokensUntilEOL(token);\n                                 }\n                                 continue retry;\n+                            case CONSISTENTIDGENERATOR:\n+                                if (!jsdocBuilder.recordConsistentIdGenerator()) {\n+                                    parser.addParserWarning(\"msg.jsdoc.consistidgen\", stream.getLineno(), stream.getCharno());\n+                                }\n+                                token \u003d eatTokensUntilEOL();\n+                                continue retry;\n                             case CONSTANT:\n                                 if (!jsdocBuilder.recordConstancy()) {\n                                     parser.addParserWarning(\"msg.jsdoc.const\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case CONSTRUCTOR:\n                                 if (!jsdocBuilder.recordConstructor()) {\n                                     if (jsdocBuilder.isInterfaceRecorded()) {\n                                         parser.addTypeWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                     } else {\n                                         parser.addTypeWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case DEPRECATED:\n                                 if (!jsdocBuilder.recordDeprecated()) {\n                                     parser.addParserWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 ExtractionInfo reasonInfo \u003d extractMultilineTextualBlock(token);\n                                 String reason \u003d reasonInfo.string;\n                                 if (reason.length() \u003e 0) {\n                                     jsdocBuilder.recordDeprecationReason(reason);\n                                 }\n                                 token \u003d reasonInfo.token;\n                                 continue retry;\n                             case INTERFACE:\n                                 if (!jsdocBuilder.recordInterface()) {\n                                     if (jsdocBuilder.isConstructorRecorded()) {\n                                         parser.addTypeWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                     } else {\n                                         parser.addTypeWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case DESC:\n                                 if (jsdocBuilder.isDescriptionRecorded()) {\n                                     parser.addParserWarning(\"msg.jsdoc.desc.extra\", stream.getLineno(), stream.getCharno());\n                                     token \u003d eatTokensUntilEOL();\n                                     continue retry;\n                                 } else {\n                                     ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                     String description \u003d descriptionInfo.string;\n                                     jsdocBuilder.recordDescription(description);\n                                     token \u003d descriptionInfo.token;\n                                     continue retry;\n                                 }\n                             case FILE_OVERVIEW:\n                                 String fileOverview \u003d \"\";\n                                 if (jsdocBuilder.shouldParseDocumentation()) {\n                                     ExtractionInfo fileOverviewInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.TRIM);\n                                     fileOverview \u003d fileOverviewInfo.string;\n                                     token \u003d fileOverviewInfo.token;\n                                 } else {\n                                     token \u003d eatTokensUntilEOL(token);\n                                 }\n                                 if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo !\u003d null) {\n                                     parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 continue retry;\n                             case LICENSE:\n                             case PRESERVE:\n                                 ExtractionInfo preserveInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);\n                                 String preserve \u003d preserveInfo.string;\n                                 if (preserve.length() \u003e 0) {\n                                     if (fileLevelJsDocBuilder !\u003d null) {\n                                         fileLevelJsDocBuilder.append(preserve);\n                                     }\n                                 }\n                                 token \u003d preserveInfo.token;\n                                 continue retry;\n                             case ENUM:\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                 }\n                                 if (type \u003d\u003d null) {\n                                     type \u003d createJSTypeExpression(newStringNode(\"number\"));\n                                 }\n                                 if (!jsdocBuilder.recordEnumParameterType(type)) {\n                                     parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                 }\n                                 token \u003d eatTokensUntilEOL(token);\n                                 continue retry;\n                             case EXPORT:\n                                 if (!jsdocBuilder.recordExport()) {\n                                     parser.addParserWarning(\"msg.jsdoc.export\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case EXTERNS:\n                                 if (!jsdocBuilder.recordExterns()) {\n                                     parser.addParserWarning(\"msg.jsdoc.externs\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case JAVA_DISPATCH:\n                                 if (!jsdocBuilder.recordJavaDispatch()) {\n                                     parser.addParserWarning(\"msg.jsdoc.javadispatch\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case EXTENDS:\n                             case IMPLEMENTS:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 boolean matchingRc \u003d false;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     token \u003d next();\n                                     matchingRc \u003d true;\n                                 }\n                                 if (token \u003d\u003d JsDocToken.STRING) {\n                                     Node typeNode \u003d parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);\n                                     lineno \u003d stream.getLineno();\n                                     charno \u003d stream.getCharno();\n                                     typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                     if (typeNode !\u003d null \u0026\u0026 !matchingRc) {\n                                         typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                     }\n                                     type \u003d createJSTypeExpression(typeNode);\n                                     if (annotation \u003d\u003d Annotation.EXTENDS) {\n                                         extendedTypes.add(new ExtendedTypeInfo(type, stream.getLineno(), stream.getCharno()));\n                                     } else {\n                                         Preconditions.checkState(annotation \u003d\u003d Annotation.IMPLEMENTS);\n                                         if (!jsdocBuilder.recordImplementedInterface(type)) {\n                                             parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\", lineno, charno);\n                                         }\n                                     }\n                                     token \u003d next();\n                                     if (matchingRc) {\n                                         if (token !\u003d JsDocToken.RC) {\n                                             parser.addTypeWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                         }\n                                     } else if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOF \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                         parser.addTypeWarning(\"msg.end.annotation.expected\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 } else {\n                                     parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);\n                                 }\n                                 token \u003d eatTokensUntilEOL(token);\n                                 continue retry;\n                             case HIDDEN:\n                                 if (!jsdocBuilder.recordHiddenness()) {\n                                     parser.addParserWarning(\"msg.jsdoc.hidden\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case LENDS:\n                                 skipEOLs();\n                                 matchingRc \u003d false;\n                                 if (match(JsDocToken.LC)) {\n                                     token \u003d next();\n                                     matchingRc \u003d true;\n                                 }\n                                 if (match(JsDocToken.STRING)) {\n                                     token \u003d next();\n                                     if (!jsdocBuilder.recordLends(stream.getString())) {\n                                         parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 } else {\n                                     parser.addTypeWarning(\"msg.jsdoc.lends.missing\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 if (matchingRc \u0026\u0026 !match(JsDocToken.RC)) {\n                                     parser.addTypeWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case MEANING:\n                                 ExtractionInfo meaningInfo \u003d extractMultilineTextualBlock(token);\n                                 String meaning \u003d meaningInfo.string;\n                                 token \u003d meaningInfo.token;\n                                 if (!jsdocBuilder.recordMeaning(meaning)) {\n                                     parser.addParserWarning(\"msg.jsdoc.meaning.extra\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 continue retry;\n                             case NO_ALIAS:\n                                 if (!jsdocBuilder.recordNoAlias()) {\n                                     parser.addParserWarning(\"msg.jsdoc.noalias\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_COMPILE:\n                                 if (!jsdocBuilder.recordNoCompile()) {\n                                     parser.addParserWarning(\"msg.jsdoc.nocompile\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_TYPE_CHECK:\n                                 if (!jsdocBuilder.recordNoTypeCheck()) {\n                                     parser.addParserWarning(\"msg.jsdoc.nocheck\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NOT_IMPLEMENTED:\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case INHERIT_DOC:\n                             case OVERRIDE:\n                                 if (!jsdocBuilder.recordOverride()) {\n                                     parser.addTypeWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case THROWS:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                     if (type \u003d\u003d null) {\n                                         token \u003d eatTokensUntilEOL();\n                                         continue retry;\n                                     }\n                                 }\n                                 token \u003d current();\n                                 jsdocBuilder.recordThrowType(type);\n                                 if (jsdocBuilder.shouldParseDocumentation()) {\n                                     ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                     String description \u003d descriptionInfo.string;\n                                     if (description.length() \u003e 0) {\n                                         jsdocBuilder.recordThrowDescription(type, description);\n                                     }\n                                     token \u003d descriptionInfo.token;\n                                 } else {\n                                     token \u003d eatTokensUntilEOL(token);\n                                 }\n                                 continue retry;\n                             case PARAM:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordParamTypeNode(token));\n                                     if (type \u003d\u003d null) {\n                                         token \u003d eatTokensUntilEOL();\n                                         continue retry;\n                                     }\n                                     skipEOLs();\n                                     token \u003d next();\n                                     lineno \u003d stream.getLineno();\n                                     charno \u003d stream.getCharno();\n                                 }\n                                 String name \u003d null;\n                                 boolean isBracketedParam \u003d JsDocToken.LB \u003d\u003d token;\n                                 if (isBracketedParam) {\n                                     token \u003d next();\n                                 }\n                                 if (JsDocToken.STRING !\u003d token) {\n                                     parser.addTypeWarning(\"msg.missing.variable.name\", lineno, charno);\n                                 } else {\n                                     name \u003d stream.getString();\n                                     if (isBracketedParam) {\n                                         token \u003d next();\n                                         if (JsDocToken.EQUALS \u003d\u003d token) {\n                                             token \u003d next();\n                                             if (JsDocToken.STRING \u003d\u003d token) {\n                                                 token \u003d next();\n                                             }\n                                         }\n                                         if (JsDocToken.RB !\u003d token) {\n                                             reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                                         } else if (type !\u003d null) {\n                                             type \u003d JSTypeExpression.makeOptionalArg(type);\n                                         }\n                                     }\n                                     if (name.indexOf(\u0027.\u0027) \u003e -1) {\n                                         name \u003d null;\n                                     } else if (!jsdocBuilder.recordParameter(name, type)) {\n                                         if (jsdocBuilder.hasParameter(name)) {\n                                             parser.addTypeWarning(\"msg.dup.variable.name\", name, lineno, charno);\n                                         } else {\n                                             parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name, lineno, charno);\n                                         }\n                                     }\n                                 }\n                                 if (name \u003d\u003d null) {\n                                     token \u003d eatTokensUntilEOL(token);\n                                     continue retry;\n                                 }\n                                 jsdocBuilder.markName(name, lineno, charno);\n                                 if (jsdocBuilder.shouldParseDocumentation()) {\n                                     ExtractionInfo paramDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                     String paramDescription \u003d paramDescriptionInfo.string;\n                                     if (paramDescription.length() \u003e 0) {\n                                         jsdocBuilder.recordParameterDescription(name, paramDescription);\n                                     }\n                                     token \u003d paramDescriptionInfo.token;\n                                 } else {\n                                     token \u003d eatTokensUntilEOL(token);\n                                 }\n                                 continue retry;\n                             case PRESERVE_TRY:\n                                 if (!jsdocBuilder.recordPreserveTry()) {\n                                     parser.addParserWarning(\"msg.jsdoc.preservertry\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PRIVATE:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                                     parser.addParserWarning(\"msg.jsdoc.visibility.private\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PROTECTED:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                                     parser.addParserWarning(\"msg.jsdoc.visibility.protected\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PUBLIC:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                                     parser.addParserWarning(\"msg.jsdoc.visibility.public\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_SHADOW:\n                                 if (!jsdocBuilder.recordNoShadow()) {\n                                     parser.addParserWarning(\"msg.jsdoc.noshadow\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_SIDE_EFFECTS:\n                                 if (!jsdocBuilder.recordNoSideEffects()) {\n                                     parser.addParserWarning(\"msg.jsdoc.nosideeffects\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case MODIFIES:\n                                 token \u003d parseModifiesTag(next());\n                                 continue retry;\n                             case IMPLICIT_CAST:\n                                 if (!jsdocBuilder.recordImplicitCast()) {\n                                     parser.addTypeWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case SEE:\n                                 if (jsdocBuilder.shouldParseDocumentation()) {\n                                     ExtractionInfo referenceInfo \u003d extractSingleLineBlock();\n                                     String reference \u003d referenceInfo.string;\n                                     if (reference.length() \u003d\u003d 0) {\n                                         parser.addParserWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno());\n                                     } else {\n                                         jsdocBuilder.addReference(reference);\n                                     }\n                                     token \u003d referenceInfo.token;\n                                 } else {\n                                     token \u003d eatTokensUntilEOL(token);\n                                 }\n                                 continue retry;\n                             case SUPPRESS:\n                                 token \u003d parseSuppressTag(next());\n                                 continue retry;\n                             case TEMPLATE:\n                                 ExtractionInfo templateInfo \u003d extractSingleLineBlock();\n                                 String templateTypeName \u003d templateInfo.string;\n                                 if (templateTypeName.length() \u003d\u003d 0) {\n                                     parser.addTypeWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno());\n                                 } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {\n                                     parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d templateInfo.token;\n                                 continue retry;\n+                            case IDGENERATOR:\n+                                if (!jsdocBuilder.recordIdGenerator()) {\n+                                    parser.addParserWarning(\"msg.jsdoc.idgen\", stream.getLineno(), stream.getCharno());\n+                                }\n+                                token \u003d eatTokensUntilEOL();\n+                                continue retry;\n                             case VERSION:\n                                 ExtractionInfo versionInfo \u003d extractSingleLineBlock();\n                                 String version \u003d versionInfo.string;\n                                 if (version.length() \u003d\u003d 0) {\n                                     parser.addParserWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno());\n                                 } else {\n                                     if (!jsdocBuilder.recordVersion(version)) {\n                                         parser.addParserWarning(\"msg.jsdoc.extraversion\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d versionInfo.token;\n                                 continue retry;\n                             case DEFINE:\n                             case RETURN:\n                             case THIS:\n                             case TYPE:\n                             case TYPEDEF:\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 Node typeNode \u003d null;\n                                 if (!lookAheadForTypeAnnotation() \u0026\u0026 annotation \u003d\u003d Annotation.RETURN) {\n                                     typeNode \u003d newNode(Token.QMARK);\n                                 } else {\n                                     skipEOLs();\n                                     token \u003d next();\n                                     typeNode \u003d parseAndRecordTypeNode(token);\n                                 }\n                                 if (annotation \u003d\u003d Annotation.THIS) {\n                                     typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                     if (typeNode !\u003d null \u0026\u0026 token !\u003d JsDocToken.LC) {\n                                         typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                     }\n                                 }\n                                 type \u003d createJSTypeExpression(typeNode);\n                                 if (type \u003d\u003d null) {\n                                 } else {\n                                     switch(annotation) {\n                                         case DEFINE:\n                                             if (!jsdocBuilder.recordDefineType(type)) {\n                                                 parser.addParserWarning(\"msg.jsdoc.define\", lineno, charno);\n                                             }\n                                             break;\n                                         case RETURN:\n                                             if (!jsdocBuilder.recordReturnType(type)) {\n                                                 parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                                 break;\n                                             }\n                                             if (jsdocBuilder.shouldParseDocumentation()) {\n                                                 ExtractionInfo returnDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                                 String returnDescription \u003d returnDescriptionInfo.string;\n                                                 if (returnDescription.length() \u003e 0) {\n                                                     jsdocBuilder.recordReturnDescription(returnDescription);\n                                                 }\n                                                 token \u003d returnDescriptionInfo.token;\n                                             } else {\n                                                 token \u003d eatTokensUntilEOL(token);\n                                             }\n                                             continue retry;\n                                         case THIS:\n                                             if (!jsdocBuilder.recordThisType(type)) {\n                                                 parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                         case TYPE:\n                                             if (!jsdocBuilder.recordType(type)) {\n                                                 parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                         case TYPEDEF:\n                                             if (!jsdocBuilder.recordTypedef(type)) {\n                                                 parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                     }\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                         }\n                     }\n                 }\n                 break;\n             case EOC:\n                 if (hasParsedFileOverviewDocInfo()) {\n                     fileOverviewJSDocInfo \u003d retrieveAndResetParsedJSDocInfo();\n                 }\n                 checkExtendedTypes(extendedTypes);\n                 return true;\n             case EOF:\n                 jsdocBuilder.build(null);\n                 parser.addParserWarning(\"msg.unexpected.eof\", stream.getLineno(), stream.getCharno());\n                 checkExtendedTypes(extendedTypes);\n                 return false;\n             case EOL:\n                 if (state \u003d\u003d State.SEARCHING_NEWLINE) {\n                     state \u003d State.SEARCHING_ANNOTATION;\n                 }\n                 token \u003d next();\n                 continue retry;\n             default:\n                 if (token \u003d\u003d JsDocToken.STAR \u0026\u0026 state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                     token \u003d next();\n                     continue retry;\n                 } else {\n                     state \u003d State.SEARCHING_NEWLINE;\n                     token \u003d eatTokensUntilEOL();\n                     continue retry;\n                 }\n         }\n         token \u003d next();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "cc5786f9a83ec0035c7aaf6a792c99e5cd6d81e9": {
      "type": "Ybodychange",
      "commitMessage": "\nfix a regression in marker placement\n\nR\u003djschorr\nDELTA\u003d21  (3 added, 15 deleted, 3 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d2229\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1168 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "6/9/11, 8:18 AM",
      "commitName": "cc5786f9a83ec0035c7aaf6a792c99e5cd6d81e9",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "6/3/11, 4:42 PM",
      "commitNameOld": "9d5a6e3082dd99f6c44df1b3526b9e83b79aa7da",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 5.65,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "actualSource": "boolean parse() {\n    int lineno;\n    int charno;\n    JSTypeExpression type;\n    state \u003d State.SEARCHING_ANNOTATION;\n    skipEOLs();\n    JsDocToken token \u003d next();\n    List\u003cExtendedTypeInfo\u003e extendedTypes \u003d Lists.newArrayList();\n    if (jsdocBuilder.shouldParseDocumentation()) {\n        ExtractionInfo blockInfo \u003d extractBlockComment(token);\n        token \u003d blockInfo.token;\n        if (!blockInfo.string.isEmpty()) {\n            jsdocBuilder.recordBlockDescription(blockInfo.string);\n        }\n    } else {\n        if (token !\u003d JsDocToken.ANNOTATION \u0026\u0026 token !\u003d JsDocToken.EOC) {\n            jsdocBuilder.recordBlockDescription(\"\");\n        }\n    }\n    retry: for (; ; ) {\n        switch(token) {\n            case ANNOTATION:\n                if (state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                    state \u003d State.SEARCHING_NEWLINE;\n                    lineno \u003d stream.getLineno();\n                    charno \u003d stream.getCharno();\n                    String annotationName \u003d stream.getString();\n                    Annotation annotation \u003d annotationNames.get(annotationName);\n                    if (annotation \u003d\u003d null) {\n                        parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno());\n                    } else {\n                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n                        switch(annotation) {\n                            case AUTHOR:\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo authorInfo \u003d extractSingleLineBlock();\n                                    String author \u003d authorInfo.string;\n                                    if (author.length() \u003d\u003d 0) {\n                                        parser.addParserWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        jsdocBuilder.addAuthor(author);\n                                    }\n                                    token \u003d authorInfo.token;\n                                } else {\n                                    token \u003d eatTokensUntilEOL(token);\n                                }\n                                continue retry;\n                            case CONSTANT:\n                                if (!jsdocBuilder.recordConstancy()) {\n                                    parser.addParserWarning(\"msg.jsdoc.const\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case CONSTRUCTOR:\n                                if (!jsdocBuilder.recordConstructor()) {\n                                    if (jsdocBuilder.isInterfaceRecorded()) {\n                                        parser.addTypeWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        parser.addTypeWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case DEPRECATED:\n                                if (!jsdocBuilder.recordDeprecated()) {\n                                    parser.addParserWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno());\n                                }\n                                ExtractionInfo reasonInfo \u003d extractMultilineTextualBlock(token);\n                                String reason \u003d reasonInfo.string;\n                                if (reason.length() \u003e 0) {\n                                    jsdocBuilder.recordDeprecationReason(reason);\n                                }\n                                token \u003d reasonInfo.token;\n                                continue retry;\n                            case INTERFACE:\n                                if (!jsdocBuilder.recordInterface()) {\n                                    if (jsdocBuilder.isConstructorRecorded()) {\n                                        parser.addTypeWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        parser.addTypeWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case DESC:\n                                if (jsdocBuilder.isDescriptionRecorded()) {\n                                    parser.addParserWarning(\"msg.jsdoc.desc.extra\", stream.getLineno(), stream.getCharno());\n                                    token \u003d eatTokensUntilEOL();\n                                    continue retry;\n                                } else {\n                                    ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                    String description \u003d descriptionInfo.string;\n                                    jsdocBuilder.recordDescription(description);\n                                    token \u003d descriptionInfo.token;\n                                    continue retry;\n                                }\n                            case FILE_OVERVIEW:\n                                String fileOverview \u003d \"\";\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo fileOverviewInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.TRIM);\n                                    fileOverview \u003d fileOverviewInfo.string;\n                                    token \u003d fileOverviewInfo.token;\n                                } else {\n                                    token \u003d eatTokensUntilEOL(token);\n                                }\n                                if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo !\u003d null) {\n                                    parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno());\n                                }\n                                continue retry;\n                            case LICENSE:\n                            case PRESERVE:\n                                ExtractionInfo preserveInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);\n                                String preserve \u003d preserveInfo.string;\n                                if (preserve.length() \u003e 0) {\n                                    if (fileLevelJsDocBuilder !\u003d null) {\n                                        fileLevelJsDocBuilder.append(preserve);\n                                    }\n                                }\n                                token \u003d preserveInfo.token;\n                                continue retry;\n                            case ENUM:\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                }\n                                if (type \u003d\u003d null) {\n                                    type \u003d createJSTypeExpression(newStringNode(\"number\"));\n                                }\n                                if (!jsdocBuilder.recordEnumParameterType(type)) {\n                                    parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                }\n                                token \u003d eatTokensUntilEOL(token);\n                                continue retry;\n                            case EXPORT:\n                                if (!jsdocBuilder.recordExport()) {\n                                    parser.addParserWarning(\"msg.jsdoc.export\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case EXTERNS:\n                                if (!jsdocBuilder.recordExterns()) {\n                                    parser.addParserWarning(\"msg.jsdoc.externs\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case JAVA_DISPATCH:\n                                if (!jsdocBuilder.recordJavaDispatch()) {\n                                    parser.addParserWarning(\"msg.jsdoc.javadispatch\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case EXTENDS:\n                            case IMPLEMENTS:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                boolean matchingRc \u003d false;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    token \u003d next();\n                                    matchingRc \u003d true;\n                                }\n                                if (token \u003d\u003d JsDocToken.STRING) {\n                                    Node typeNode \u003d parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);\n                                    lineno \u003d stream.getLineno();\n                                    charno \u003d stream.getCharno();\n                                    typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                    if (typeNode !\u003d null \u0026\u0026 !matchingRc) {\n                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                    }\n                                    type \u003d createJSTypeExpression(typeNode);\n                                    if (annotation \u003d\u003d Annotation.EXTENDS) {\n                                        extendedTypes.add(new ExtendedTypeInfo(type, stream.getLineno(), stream.getCharno()));\n                                    } else {\n                                        Preconditions.checkState(annotation \u003d\u003d Annotation.IMPLEMENTS);\n                                        if (!jsdocBuilder.recordImplementedInterface(type)) {\n                                            parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\", lineno, charno);\n                                        }\n                                    }\n                                    token \u003d next();\n                                    if (matchingRc) {\n                                        if (token !\u003d JsDocToken.RC) {\n                                            parser.addTypeWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                        }\n                                    } else if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOF \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                        parser.addTypeWarning(\"msg.end.annotation.expected\", stream.getLineno(), stream.getCharno());\n                                    }\n                                } else {\n                                    parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);\n                                }\n                                token \u003d eatTokensUntilEOL(token);\n                                continue retry;\n                            case HIDDEN:\n                                if (!jsdocBuilder.recordHiddenness()) {\n                                    parser.addParserWarning(\"msg.jsdoc.hidden\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case LENDS:\n                                skipEOLs();\n                                matchingRc \u003d false;\n                                if (match(JsDocToken.LC)) {\n                                    token \u003d next();\n                                    matchingRc \u003d true;\n                                }\n                                if (match(JsDocToken.STRING)) {\n                                    token \u003d next();\n                                    if (!jsdocBuilder.recordLends(stream.getString())) {\n                                        parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\", stream.getLineno(), stream.getCharno());\n                                    }\n                                } else {\n                                    parser.addTypeWarning(\"msg.jsdoc.lends.missing\", stream.getLineno(), stream.getCharno());\n                                }\n                                if (matchingRc \u0026\u0026 !match(JsDocToken.RC)) {\n                                    parser.addTypeWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case MEANING:\n                                ExtractionInfo meaningInfo \u003d extractMultilineTextualBlock(token);\n                                String meaning \u003d meaningInfo.string;\n                                token \u003d meaningInfo.token;\n                                if (!jsdocBuilder.recordMeaning(meaning)) {\n                                    parser.addParserWarning(\"msg.jsdoc.meaning.extra\", stream.getLineno(), stream.getCharno());\n                                }\n                                continue retry;\n                            case NO_ALIAS:\n                                if (!jsdocBuilder.recordNoAlias()) {\n                                    parser.addParserWarning(\"msg.jsdoc.noalias\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_COMPILE:\n                                if (!jsdocBuilder.recordNoCompile()) {\n                                    parser.addParserWarning(\"msg.jsdoc.nocompile\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_TYPE_CHECK:\n                                if (!jsdocBuilder.recordNoTypeCheck()) {\n                                    parser.addParserWarning(\"msg.jsdoc.nocheck\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NOT_IMPLEMENTED:\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case INHERIT_DOC:\n                            case OVERRIDE:\n                                if (!jsdocBuilder.recordOverride()) {\n                                    parser.addTypeWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case THROWS:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                    if (type \u003d\u003d null) {\n                                        token \u003d eatTokensUntilEOL();\n                                        continue retry;\n                                    }\n                                }\n                                token \u003d current();\n                                jsdocBuilder.recordThrowType(type);\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                    String description \u003d descriptionInfo.string;\n                                    if (description.length() \u003e 0) {\n                                        jsdocBuilder.recordThrowDescription(type, description);\n                                    }\n                                    token \u003d descriptionInfo.token;\n                                } else {\n                                    token \u003d eatTokensUntilEOL(token);\n                                }\n                                continue retry;\n                            case PARAM:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordParamTypeNode(token));\n                                    if (type \u003d\u003d null) {\n                                        token \u003d eatTokensUntilEOL();\n                                        continue retry;\n                                    }\n                                    skipEOLs();\n                                    token \u003d next();\n                                    lineno \u003d stream.getLineno();\n                                    charno \u003d stream.getCharno();\n                                }\n                                String name \u003d null;\n                                boolean isBracketedParam \u003d JsDocToken.LB \u003d\u003d token;\n                                if (isBracketedParam) {\n                                    token \u003d next();\n                                }\n                                if (JsDocToken.STRING !\u003d token) {\n                                    parser.addTypeWarning(\"msg.missing.variable.name\", lineno, charno);\n                                } else {\n                                    name \u003d stream.getString();\n                                    if (isBracketedParam) {\n                                        token \u003d next();\n                                        if (JsDocToken.EQUALS \u003d\u003d token) {\n                                            token \u003d next();\n                                            if (JsDocToken.STRING \u003d\u003d token) {\n                                                token \u003d next();\n                                            }\n                                        }\n                                        if (JsDocToken.RB !\u003d token) {\n                                            reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                                        } else if (type !\u003d null) {\n                                            type \u003d JSTypeExpression.makeOptionalArg(type);\n                                        }\n                                    }\n                                    if (name.indexOf(\u0027.\u0027) \u003e -1) {\n                                        name \u003d null;\n                                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                                        if (jsdocBuilder.hasParameter(name)) {\n                                            parser.addTypeWarning(\"msg.dup.variable.name\", name, lineno, charno);\n                                        } else {\n                                            parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name, lineno, charno);\n                                        }\n                                    }\n                                }\n                                if (name \u003d\u003d null) {\n                                    token \u003d eatTokensUntilEOL(token);\n                                    continue retry;\n                                }\n                                jsdocBuilder.markName(name, lineno, charno);\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo paramDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                    String paramDescription \u003d paramDescriptionInfo.string;\n                                    if (paramDescription.length() \u003e 0) {\n                                        jsdocBuilder.recordParameterDescription(name, paramDescription);\n                                    }\n                                    token \u003d paramDescriptionInfo.token;\n                                } else {\n                                    token \u003d eatTokensUntilEOL(token);\n                                }\n                                continue retry;\n                            case PRESERVE_TRY:\n                                if (!jsdocBuilder.recordPreserveTry()) {\n                                    parser.addParserWarning(\"msg.jsdoc.preservertry\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PRIVATE:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                                    parser.addParserWarning(\"msg.jsdoc.visibility.private\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PROTECTED:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                                    parser.addParserWarning(\"msg.jsdoc.visibility.protected\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PUBLIC:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                                    parser.addParserWarning(\"msg.jsdoc.visibility.public\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_SHADOW:\n                                if (!jsdocBuilder.recordNoShadow()) {\n                                    parser.addParserWarning(\"msg.jsdoc.noshadow\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_SIDE_EFFECTS:\n                                if (!jsdocBuilder.recordNoSideEffects()) {\n                                    parser.addParserWarning(\"msg.jsdoc.nosideeffects\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case MODIFIES:\n                                token \u003d parseModifiesTag(next());\n                                continue retry;\n                            case IMPLICIT_CAST:\n                                if (!jsdocBuilder.recordImplicitCast()) {\n                                    parser.addTypeWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case SEE:\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo referenceInfo \u003d extractSingleLineBlock();\n                                    String reference \u003d referenceInfo.string;\n                                    if (reference.length() \u003d\u003d 0) {\n                                        parser.addParserWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        jsdocBuilder.addReference(reference);\n                                    }\n                                    token \u003d referenceInfo.token;\n                                } else {\n                                    token \u003d eatTokensUntilEOL(token);\n                                }\n                                continue retry;\n                            case SUPPRESS:\n                                token \u003d parseSuppressTag(next());\n                                continue retry;\n                            case TEMPLATE:\n                                ExtractionInfo templateInfo \u003d extractSingleLineBlock();\n                                String templateTypeName \u003d templateInfo.string;\n                                if (templateTypeName.length() \u003d\u003d 0) {\n                                    parser.addTypeWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno());\n                                } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {\n                                    parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d templateInfo.token;\n                                continue retry;\n                            case VERSION:\n                                ExtractionInfo versionInfo \u003d extractSingleLineBlock();\n                                String version \u003d versionInfo.string;\n                                if (version.length() \u003d\u003d 0) {\n                                    parser.addParserWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno());\n                                } else {\n                                    if (!jsdocBuilder.recordVersion(version)) {\n                                        parser.addParserWarning(\"msg.jsdoc.extraversion\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d versionInfo.token;\n                                continue retry;\n                            case DEFINE:\n                            case RETURN:\n                            case THIS:\n                            case TYPE:\n                            case TYPEDEF:\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                Node typeNode \u003d null;\n                                if (!lookAheadForTypeAnnotation() \u0026\u0026 annotation \u003d\u003d Annotation.RETURN) {\n                                    typeNode \u003d newNode(Token.QMARK);\n                                } else {\n                                    skipEOLs();\n                                    token \u003d next();\n                                    typeNode \u003d parseAndRecordTypeNode(token);\n                                }\n                                if (annotation \u003d\u003d Annotation.THIS) {\n                                    typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                    if (typeNode !\u003d null \u0026\u0026 token !\u003d JsDocToken.LC) {\n                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                    }\n                                }\n                                type \u003d createJSTypeExpression(typeNode);\n                                if (type \u003d\u003d null) {\n                                } else {\n                                    switch(annotation) {\n                                        case DEFINE:\n                                            if (!jsdocBuilder.recordDefineType(type)) {\n                                                parser.addParserWarning(\"msg.jsdoc.define\", lineno, charno);\n                                            }\n                                            break;\n                                        case RETURN:\n                                            if (!jsdocBuilder.recordReturnType(type)) {\n                                                parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                                break;\n                                            }\n                                            if (jsdocBuilder.shouldParseDocumentation()) {\n                                                ExtractionInfo returnDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                                String returnDescription \u003d returnDescriptionInfo.string;\n                                                if (returnDescription.length() \u003e 0) {\n                                                    jsdocBuilder.recordReturnDescription(returnDescription);\n                                                }\n                                                token \u003d returnDescriptionInfo.token;\n                                            } else {\n                                                token \u003d eatTokensUntilEOL(token);\n                                            }\n                                            continue retry;\n                                        case THIS:\n                                            if (!jsdocBuilder.recordThisType(type)) {\n                                                parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                        case TYPE:\n                                            if (!jsdocBuilder.recordType(type)) {\n                                                parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                        case TYPEDEF:\n                                            if (!jsdocBuilder.recordTypedef(type)) {\n                                                parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                    }\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                        }\n                    }\n                }\n                break;\n            case EOC:\n                if (hasParsedFileOverviewDocInfo()) {\n                    fileOverviewJSDocInfo \u003d retrieveAndResetParsedJSDocInfo();\n                }\n                checkExtendedTypes(extendedTypes);\n                return true;\n            case EOF:\n                jsdocBuilder.build(null);\n                parser.addParserWarning(\"msg.unexpected.eof\", stream.getLineno(), stream.getCharno());\n                checkExtendedTypes(extendedTypes);\n                return false;\n            case EOL:\n                if (state \u003d\u003d State.SEARCHING_NEWLINE) {\n                    state \u003d State.SEARCHING_ANNOTATION;\n                }\n                token \u003d next();\n                continue retry;\n            default:\n                if (token \u003d\u003d JsDocToken.STAR \u0026\u0026 state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                    token \u003d next();\n                    continue retry;\n                } else {\n                    state \u003d State.SEARCHING_NEWLINE;\n                    token \u003d eatTokensUntilEOL();\n                    continue retry;\n                }\n        }\n        token \u003d next();\n    }\n}",
      "path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
      "functionStartLine": 169,
      "functionName": "parse",
      "functionAnnotation": "",
      "functionDoc": "Parses a {@link JSDocInfo} object. This parsing method reads all tokens\nreturned by the {@link JsDocTokenStream#getJsDocToken()} method until the\n{@link JsDocToken#EOC} is returned.\n\n@return @code true} if JSDoc information was correctly parsed,\n    {@code false} otherwise\n",
      "diff": "@@ -1,532 +1,532 @@\n boolean parse() {\n     int lineno;\n     int charno;\n     JSTypeExpression type;\n     state \u003d State.SEARCHING_ANNOTATION;\n     skipEOLs();\n     JsDocToken token \u003d next();\n     List\u003cExtendedTypeInfo\u003e extendedTypes \u003d Lists.newArrayList();\n     if (jsdocBuilder.shouldParseDocumentation()) {\n         ExtractionInfo blockInfo \u003d extractBlockComment(token);\n         token \u003d blockInfo.token;\n         if (!blockInfo.string.isEmpty()) {\n             jsdocBuilder.recordBlockDescription(blockInfo.string);\n         }\n     } else {\n         if (token !\u003d JsDocToken.ANNOTATION \u0026\u0026 token !\u003d JsDocToken.EOC) {\n             jsdocBuilder.recordBlockDescription(\"\");\n         }\n     }\n     retry: for (; ; ) {\n         switch(token) {\n             case ANNOTATION:\n                 if (state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                     state \u003d State.SEARCHING_NEWLINE;\n                     lineno \u003d stream.getLineno();\n                     charno \u003d stream.getCharno();\n                     String annotationName \u003d stream.getString();\n                     Annotation annotation \u003d annotationNames.get(annotationName);\n                     if (annotation \u003d\u003d null) {\n                         parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno());\n                     } else {\n                         jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n                         switch(annotation) {\n                             case AUTHOR:\n                                 if (jsdocBuilder.shouldParseDocumentation()) {\n                                     ExtractionInfo authorInfo \u003d extractSingleLineBlock();\n                                     String author \u003d authorInfo.string;\n                                     if (author.length() \u003d\u003d 0) {\n                                         parser.addParserWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno());\n                                     } else {\n                                         jsdocBuilder.addAuthor(author);\n                                     }\n                                     token \u003d authorInfo.token;\n                                 } else {\n                                     token \u003d eatTokensUntilEOL(token);\n                                 }\n                                 continue retry;\n                             case CONSTANT:\n                                 if (!jsdocBuilder.recordConstancy()) {\n                                     parser.addParserWarning(\"msg.jsdoc.const\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case CONSTRUCTOR:\n                                 if (!jsdocBuilder.recordConstructor()) {\n                                     if (jsdocBuilder.isInterfaceRecorded()) {\n                                         parser.addTypeWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                     } else {\n                                         parser.addTypeWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case DEPRECATED:\n                                 if (!jsdocBuilder.recordDeprecated()) {\n                                     parser.addParserWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 ExtractionInfo reasonInfo \u003d extractMultilineTextualBlock(token);\n                                 String reason \u003d reasonInfo.string;\n                                 if (reason.length() \u003e 0) {\n                                     jsdocBuilder.recordDeprecationReason(reason);\n                                 }\n                                 token \u003d reasonInfo.token;\n                                 continue retry;\n                             case INTERFACE:\n                                 if (!jsdocBuilder.recordInterface()) {\n                                     if (jsdocBuilder.isConstructorRecorded()) {\n                                         parser.addTypeWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                     } else {\n                                         parser.addTypeWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case DESC:\n                                 if (jsdocBuilder.isDescriptionRecorded()) {\n                                     parser.addParserWarning(\"msg.jsdoc.desc.extra\", stream.getLineno(), stream.getCharno());\n                                     token \u003d eatTokensUntilEOL();\n                                     continue retry;\n                                 } else {\n                                     ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                     String description \u003d descriptionInfo.string;\n                                     jsdocBuilder.recordDescription(description);\n                                     token \u003d descriptionInfo.token;\n                                     continue retry;\n                                 }\n                             case FILE_OVERVIEW:\n                                 String fileOverview \u003d \"\";\n                                 if (jsdocBuilder.shouldParseDocumentation()) {\n                                     ExtractionInfo fileOverviewInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.TRIM);\n                                     fileOverview \u003d fileOverviewInfo.string;\n                                     token \u003d fileOverviewInfo.token;\n                                 } else {\n                                     token \u003d eatTokensUntilEOL(token);\n                                 }\n                                 if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo !\u003d null) {\n                                     parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 continue retry;\n                             case LICENSE:\n                             case PRESERVE:\n                                 ExtractionInfo preserveInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);\n                                 String preserve \u003d preserveInfo.string;\n                                 if (preserve.length() \u003e 0) {\n                                     if (fileLevelJsDocBuilder !\u003d null) {\n                                         fileLevelJsDocBuilder.append(preserve);\n                                     }\n                                 }\n                                 token \u003d preserveInfo.token;\n                                 continue retry;\n                             case ENUM:\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                 }\n                                 if (type \u003d\u003d null) {\n                                     type \u003d createJSTypeExpression(newStringNode(\"number\"));\n                                 }\n                                 if (!jsdocBuilder.recordEnumParameterType(type)) {\n                                     parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                 }\n                                 token \u003d eatTokensUntilEOL(token);\n                                 continue retry;\n                             case EXPORT:\n                                 if (!jsdocBuilder.recordExport()) {\n                                     parser.addParserWarning(\"msg.jsdoc.export\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case EXTERNS:\n                                 if (!jsdocBuilder.recordExterns()) {\n                                     parser.addParserWarning(\"msg.jsdoc.externs\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case JAVA_DISPATCH:\n                                 if (!jsdocBuilder.recordJavaDispatch()) {\n                                     parser.addParserWarning(\"msg.jsdoc.javadispatch\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case EXTENDS:\n                             case IMPLEMENTS:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 boolean matchingRc \u003d false;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     token \u003d next();\n                                     matchingRc \u003d true;\n                                 }\n                                 if (token \u003d\u003d JsDocToken.STRING) {\n                                     Node typeNode \u003d parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);\n                                     lineno \u003d stream.getLineno();\n                                     charno \u003d stream.getCharno();\n                                     typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                     if (typeNode !\u003d null \u0026\u0026 !matchingRc) {\n                                         typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                     }\n                                     type \u003d createJSTypeExpression(typeNode);\n                                     if (annotation \u003d\u003d Annotation.EXTENDS) {\n                                         extendedTypes.add(new ExtendedTypeInfo(type, stream.getLineno(), stream.getCharno()));\n                                     } else {\n                                         Preconditions.checkState(annotation \u003d\u003d Annotation.IMPLEMENTS);\n                                         if (!jsdocBuilder.recordImplementedInterface(type)) {\n                                             parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\", lineno, charno);\n                                         }\n                                     }\n                                     token \u003d next();\n                                     if (matchingRc) {\n                                         if (token !\u003d JsDocToken.RC) {\n                                             parser.addTypeWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                         }\n                                     } else if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOF \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                         parser.addTypeWarning(\"msg.end.annotation.expected\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 } else {\n                                     parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);\n                                 }\n                                 token \u003d eatTokensUntilEOL(token);\n                                 continue retry;\n                             case HIDDEN:\n                                 if (!jsdocBuilder.recordHiddenness()) {\n                                     parser.addParserWarning(\"msg.jsdoc.hidden\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case LENDS:\n                                 skipEOLs();\n                                 matchingRc \u003d false;\n                                 if (match(JsDocToken.LC)) {\n                                     token \u003d next();\n                                     matchingRc \u003d true;\n                                 }\n                                 if (match(JsDocToken.STRING)) {\n                                     token \u003d next();\n                                     if (!jsdocBuilder.recordLends(stream.getString())) {\n                                         parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 } else {\n                                     parser.addTypeWarning(\"msg.jsdoc.lends.missing\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 if (matchingRc \u0026\u0026 !match(JsDocToken.RC)) {\n                                     parser.addTypeWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case MEANING:\n                                 ExtractionInfo meaningInfo \u003d extractMultilineTextualBlock(token);\n                                 String meaning \u003d meaningInfo.string;\n                                 token \u003d meaningInfo.token;\n                                 if (!jsdocBuilder.recordMeaning(meaning)) {\n                                     parser.addParserWarning(\"msg.jsdoc.meaning.extra\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 continue retry;\n                             case NO_ALIAS:\n                                 if (!jsdocBuilder.recordNoAlias()) {\n                                     parser.addParserWarning(\"msg.jsdoc.noalias\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_COMPILE:\n                                 if (!jsdocBuilder.recordNoCompile()) {\n                                     parser.addParserWarning(\"msg.jsdoc.nocompile\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_TYPE_CHECK:\n                                 if (!jsdocBuilder.recordNoTypeCheck()) {\n                                     parser.addParserWarning(\"msg.jsdoc.nocheck\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NOT_IMPLEMENTED:\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case INHERIT_DOC:\n                             case OVERRIDE:\n                                 if (!jsdocBuilder.recordOverride()) {\n                                     parser.addTypeWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case THROWS:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                     if (type \u003d\u003d null) {\n                                         token \u003d eatTokensUntilEOL();\n                                         continue retry;\n                                     }\n                                 }\n                                 token \u003d current();\n                                 jsdocBuilder.recordThrowType(type);\n                                 if (jsdocBuilder.shouldParseDocumentation()) {\n                                     ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                     String description \u003d descriptionInfo.string;\n                                     if (description.length() \u003e 0) {\n                                         jsdocBuilder.recordThrowDescription(type, description);\n                                     }\n                                     token \u003d descriptionInfo.token;\n                                 } else {\n                                     token \u003d eatTokensUntilEOL(token);\n                                 }\n                                 continue retry;\n                             case PARAM:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordParamTypeNode(token));\n                                     if (type \u003d\u003d null) {\n                                         token \u003d eatTokensUntilEOL();\n                                         continue retry;\n                                     }\n                                     skipEOLs();\n                                     token \u003d next();\n                                     lineno \u003d stream.getLineno();\n                                     charno \u003d stream.getCharno();\n                                 }\n                                 String name \u003d null;\n                                 boolean isBracketedParam \u003d JsDocToken.LB \u003d\u003d token;\n                                 if (isBracketedParam) {\n                                     token \u003d next();\n                                 }\n                                 if (JsDocToken.STRING !\u003d token) {\n                                     parser.addTypeWarning(\"msg.missing.variable.name\", lineno, charno);\n                                 } else {\n                                     name \u003d stream.getString();\n                                     if (isBracketedParam) {\n                                         token \u003d next();\n                                         if (JsDocToken.EQUALS \u003d\u003d token) {\n                                             token \u003d next();\n                                             if (JsDocToken.STRING \u003d\u003d token) {\n                                                 token \u003d next();\n                                             }\n                                         }\n                                         if (JsDocToken.RB !\u003d token) {\n                                             reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                                         } else if (type !\u003d null) {\n                                             type \u003d JSTypeExpression.makeOptionalArg(type);\n                                         }\n                                     }\n                                     if (name.indexOf(\u0027.\u0027) \u003e -1) {\n                                         name \u003d null;\n                                     } else if (!jsdocBuilder.recordParameter(name, type)) {\n                                         if (jsdocBuilder.hasParameter(name)) {\n                                             parser.addTypeWarning(\"msg.dup.variable.name\", name, lineno, charno);\n                                         } else {\n                                             parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name, lineno, charno);\n                                         }\n                                     }\n                                 }\n                                 if (name \u003d\u003d null) {\n                                     token \u003d eatTokensUntilEOL(token);\n                                     continue retry;\n                                 }\n                                 jsdocBuilder.markName(name, lineno, charno);\n                                 if (jsdocBuilder.shouldParseDocumentation()) {\n                                     ExtractionInfo paramDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                     String paramDescription \u003d paramDescriptionInfo.string;\n                                     if (paramDescription.length() \u003e 0) {\n                                         jsdocBuilder.recordParameterDescription(name, paramDescription);\n                                     }\n                                     token \u003d paramDescriptionInfo.token;\n                                 } else {\n                                     token \u003d eatTokensUntilEOL(token);\n                                 }\n                                 continue retry;\n                             case PRESERVE_TRY:\n                                 if (!jsdocBuilder.recordPreserveTry()) {\n                                     parser.addParserWarning(\"msg.jsdoc.preservertry\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PRIVATE:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                                     parser.addParserWarning(\"msg.jsdoc.visibility.private\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PROTECTED:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                                     parser.addParserWarning(\"msg.jsdoc.visibility.protected\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PUBLIC:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                                     parser.addParserWarning(\"msg.jsdoc.visibility.public\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_SHADOW:\n                                 if (!jsdocBuilder.recordNoShadow()) {\n                                     parser.addParserWarning(\"msg.jsdoc.noshadow\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_SIDE_EFFECTS:\n                                 if (!jsdocBuilder.recordNoSideEffects()) {\n                                     parser.addParserWarning(\"msg.jsdoc.nosideeffects\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case MODIFIES:\n                                 token \u003d parseModifiesTag(next());\n                                 continue retry;\n                             case IMPLICIT_CAST:\n                                 if (!jsdocBuilder.recordImplicitCast()) {\n                                     parser.addTypeWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case SEE:\n                                 if (jsdocBuilder.shouldParseDocumentation()) {\n                                     ExtractionInfo referenceInfo \u003d extractSingleLineBlock();\n                                     String reference \u003d referenceInfo.string;\n                                     if (reference.length() \u003d\u003d 0) {\n                                         parser.addParserWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno());\n                                     } else {\n                                         jsdocBuilder.addReference(reference);\n                                     }\n                                     token \u003d referenceInfo.token;\n                                 } else {\n                                     token \u003d eatTokensUntilEOL(token);\n                                 }\n                                 continue retry;\n                             case SUPPRESS:\n                                 token \u003d parseSuppressTag(next());\n                                 continue retry;\n                             case TEMPLATE:\n                                 ExtractionInfo templateInfo \u003d extractSingleLineBlock();\n                                 String templateTypeName \u003d templateInfo.string;\n                                 if (templateTypeName.length() \u003d\u003d 0) {\n                                     parser.addTypeWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno());\n                                 } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {\n                                     parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d templateInfo.token;\n                                 continue retry;\n                             case VERSION:\n                                 ExtractionInfo versionInfo \u003d extractSingleLineBlock();\n                                 String version \u003d versionInfo.string;\n                                 if (version.length() \u003d\u003d 0) {\n                                     parser.addParserWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno());\n                                 } else {\n                                     if (!jsdocBuilder.recordVersion(version)) {\n                                         parser.addParserWarning(\"msg.jsdoc.extraversion\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d versionInfo.token;\n                                 continue retry;\n                             case DEFINE:\n                             case RETURN:\n                             case THIS:\n                             case TYPE:\n                             case TYPEDEF:\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 Node typeNode \u003d null;\n                                 if (!lookAheadForTypeAnnotation() \u0026\u0026 annotation \u003d\u003d Annotation.RETURN) {\n                                     typeNode \u003d newNode(Token.QMARK);\n                                 } else {\n                                     skipEOLs();\n                                     token \u003d next();\n-                                    typeNode \u003d parseAndRecordTypeNode(token, lineno, charno);\n+                                    typeNode \u003d parseAndRecordTypeNode(token);\n                                 }\n                                 if (annotation \u003d\u003d Annotation.THIS) {\n                                     typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                     if (typeNode !\u003d null \u0026\u0026 token !\u003d JsDocToken.LC) {\n                                         typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                     }\n                                 }\n                                 type \u003d createJSTypeExpression(typeNode);\n                                 if (type \u003d\u003d null) {\n                                 } else {\n                                     switch(annotation) {\n                                         case DEFINE:\n                                             if (!jsdocBuilder.recordDefineType(type)) {\n                                                 parser.addParserWarning(\"msg.jsdoc.define\", lineno, charno);\n                                             }\n                                             break;\n                                         case RETURN:\n                                             if (!jsdocBuilder.recordReturnType(type)) {\n                                                 parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                                 break;\n                                             }\n                                             if (jsdocBuilder.shouldParseDocumentation()) {\n                                                 ExtractionInfo returnDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                                 String returnDescription \u003d returnDescriptionInfo.string;\n                                                 if (returnDescription.length() \u003e 0) {\n                                                     jsdocBuilder.recordReturnDescription(returnDescription);\n                                                 }\n                                                 token \u003d returnDescriptionInfo.token;\n                                             } else {\n                                                 token \u003d eatTokensUntilEOL(token);\n                                             }\n                                             continue retry;\n                                         case THIS:\n                                             if (!jsdocBuilder.recordThisType(type)) {\n                                                 parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                         case TYPE:\n                                             if (!jsdocBuilder.recordType(type)) {\n                                                 parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                         case TYPEDEF:\n                                             if (!jsdocBuilder.recordTypedef(type)) {\n                                                 parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                     }\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                         }\n                     }\n                 }\n                 break;\n             case EOC:\n                 if (hasParsedFileOverviewDocInfo()) {\n                     fileOverviewJSDocInfo \u003d retrieveAndResetParsedJSDocInfo();\n                 }\n                 checkExtendedTypes(extendedTypes);\n                 return true;\n             case EOF:\n                 jsdocBuilder.build(null);\n                 parser.addParserWarning(\"msg.unexpected.eof\", stream.getLineno(), stream.getCharno());\n                 checkExtendedTypes(extendedTypes);\n                 return false;\n             case EOL:\n                 if (state \u003d\u003d State.SEARCHING_NEWLINE) {\n                     state \u003d State.SEARCHING_ANNOTATION;\n                 }\n                 token \u003d next();\n                 continue retry;\n             default:\n                 if (token \u003d\u003d JsDocToken.STAR \u0026\u0026 state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                     token \u003d next();\n                     continue retry;\n                 } else {\n                     state \u003d State.SEARCHING_NEWLINE;\n                     token \u003d eatTokensUntilEOL();\n                     continue retry;\n                 }\n         }\n         token \u003d next();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9d5a6e3082dd99f6c44df1b3526b9e83b79aa7da": {
      "type": "Ybodychange",
      "commitMessage": "\nFix a jsdoc parser bug where it was dropping the EndOfComment token\nFixes issue 477\n\nR\u003dacleung\nDELTA\u003d15  (12 added, 0 deleted, 3 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d2193\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1158 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "6/3/11, 4:42 PM",
      "commitName": "9d5a6e3082dd99f6c44df1b3526b9e83b79aa7da",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "5/16/11, 12:57 PM",
      "commitNameOld": "c438dfd06013f82daa648d23b864842ff1881695",
      "commitAuthorOld": "zhuyi@google.com",
      "daysBetweenCommits": 18.16,
      "commitsBetweenForRepo": 52,
      "commitsBetweenForFile": 1,
      "actualSource": "boolean parse() {\n    int lineno;\n    int charno;\n    JSTypeExpression type;\n    state \u003d State.SEARCHING_ANNOTATION;\n    skipEOLs();\n    JsDocToken token \u003d next();\n    List\u003cExtendedTypeInfo\u003e extendedTypes \u003d Lists.newArrayList();\n    if (jsdocBuilder.shouldParseDocumentation()) {\n        ExtractionInfo blockInfo \u003d extractBlockComment(token);\n        token \u003d blockInfo.token;\n        if (!blockInfo.string.isEmpty()) {\n            jsdocBuilder.recordBlockDescription(blockInfo.string);\n        }\n    } else {\n        if (token !\u003d JsDocToken.ANNOTATION \u0026\u0026 token !\u003d JsDocToken.EOC) {\n            jsdocBuilder.recordBlockDescription(\"\");\n        }\n    }\n    retry: for (; ; ) {\n        switch(token) {\n            case ANNOTATION:\n                if (state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                    state \u003d State.SEARCHING_NEWLINE;\n                    lineno \u003d stream.getLineno();\n                    charno \u003d stream.getCharno();\n                    String annotationName \u003d stream.getString();\n                    Annotation annotation \u003d annotationNames.get(annotationName);\n                    if (annotation \u003d\u003d null) {\n                        parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno());\n                    } else {\n                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n                        switch(annotation) {\n                            case AUTHOR:\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo authorInfo \u003d extractSingleLineBlock();\n                                    String author \u003d authorInfo.string;\n                                    if (author.length() \u003d\u003d 0) {\n                                        parser.addParserWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        jsdocBuilder.addAuthor(author);\n                                    }\n                                    token \u003d authorInfo.token;\n                                } else {\n                                    token \u003d eatTokensUntilEOL(token);\n                                }\n                                continue retry;\n                            case CONSTANT:\n                                if (!jsdocBuilder.recordConstancy()) {\n                                    parser.addParserWarning(\"msg.jsdoc.const\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case CONSTRUCTOR:\n                                if (!jsdocBuilder.recordConstructor()) {\n                                    if (jsdocBuilder.isInterfaceRecorded()) {\n                                        parser.addTypeWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        parser.addTypeWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case DEPRECATED:\n                                if (!jsdocBuilder.recordDeprecated()) {\n                                    parser.addParserWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno());\n                                }\n                                ExtractionInfo reasonInfo \u003d extractMultilineTextualBlock(token);\n                                String reason \u003d reasonInfo.string;\n                                if (reason.length() \u003e 0) {\n                                    jsdocBuilder.recordDeprecationReason(reason);\n                                }\n                                token \u003d reasonInfo.token;\n                                continue retry;\n                            case INTERFACE:\n                                if (!jsdocBuilder.recordInterface()) {\n                                    if (jsdocBuilder.isConstructorRecorded()) {\n                                        parser.addTypeWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        parser.addTypeWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case DESC:\n                                if (jsdocBuilder.isDescriptionRecorded()) {\n                                    parser.addParserWarning(\"msg.jsdoc.desc.extra\", stream.getLineno(), stream.getCharno());\n                                    token \u003d eatTokensUntilEOL();\n                                    continue retry;\n                                } else {\n                                    ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                    String description \u003d descriptionInfo.string;\n                                    jsdocBuilder.recordDescription(description);\n                                    token \u003d descriptionInfo.token;\n                                    continue retry;\n                                }\n                            case FILE_OVERVIEW:\n                                String fileOverview \u003d \"\";\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo fileOverviewInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.TRIM);\n                                    fileOverview \u003d fileOverviewInfo.string;\n                                    token \u003d fileOverviewInfo.token;\n                                } else {\n                                    token \u003d eatTokensUntilEOL(token);\n                                }\n                                if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo !\u003d null) {\n                                    parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno());\n                                }\n                                continue retry;\n                            case LICENSE:\n                            case PRESERVE:\n                                ExtractionInfo preserveInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);\n                                String preserve \u003d preserveInfo.string;\n                                if (preserve.length() \u003e 0) {\n                                    if (fileLevelJsDocBuilder !\u003d null) {\n                                        fileLevelJsDocBuilder.append(preserve);\n                                    }\n                                }\n                                token \u003d preserveInfo.token;\n                                continue retry;\n                            case ENUM:\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                }\n                                if (type \u003d\u003d null) {\n                                    type \u003d createJSTypeExpression(newStringNode(\"number\"));\n                                }\n                                if (!jsdocBuilder.recordEnumParameterType(type)) {\n                                    parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                }\n                                token \u003d eatTokensUntilEOL(token);\n                                continue retry;\n                            case EXPORT:\n                                if (!jsdocBuilder.recordExport()) {\n                                    parser.addParserWarning(\"msg.jsdoc.export\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case EXTERNS:\n                                if (!jsdocBuilder.recordExterns()) {\n                                    parser.addParserWarning(\"msg.jsdoc.externs\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case JAVA_DISPATCH:\n                                if (!jsdocBuilder.recordJavaDispatch()) {\n                                    parser.addParserWarning(\"msg.jsdoc.javadispatch\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case EXTENDS:\n                            case IMPLEMENTS:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                boolean matchingRc \u003d false;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    token \u003d next();\n                                    matchingRc \u003d true;\n                                }\n                                if (token \u003d\u003d JsDocToken.STRING) {\n                                    Node typeNode \u003d parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);\n                                    lineno \u003d stream.getLineno();\n                                    charno \u003d stream.getCharno();\n                                    typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                    if (typeNode !\u003d null \u0026\u0026 !matchingRc) {\n                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                    }\n                                    type \u003d createJSTypeExpression(typeNode);\n                                    if (annotation \u003d\u003d Annotation.EXTENDS) {\n                                        extendedTypes.add(new ExtendedTypeInfo(type, stream.getLineno(), stream.getCharno()));\n                                    } else {\n                                        Preconditions.checkState(annotation \u003d\u003d Annotation.IMPLEMENTS);\n                                        if (!jsdocBuilder.recordImplementedInterface(type)) {\n                                            parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\", lineno, charno);\n                                        }\n                                    }\n                                    token \u003d next();\n                                    if (matchingRc) {\n                                        if (token !\u003d JsDocToken.RC) {\n                                            parser.addTypeWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                        }\n                                    } else if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOF \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                        parser.addTypeWarning(\"msg.end.annotation.expected\", stream.getLineno(), stream.getCharno());\n                                    }\n                                } else {\n                                    parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);\n                                }\n                                token \u003d eatTokensUntilEOL(token);\n                                continue retry;\n                            case HIDDEN:\n                                if (!jsdocBuilder.recordHiddenness()) {\n                                    parser.addParserWarning(\"msg.jsdoc.hidden\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case LENDS:\n                                skipEOLs();\n                                matchingRc \u003d false;\n                                if (match(JsDocToken.LC)) {\n                                    token \u003d next();\n                                    matchingRc \u003d true;\n                                }\n                                if (match(JsDocToken.STRING)) {\n                                    token \u003d next();\n                                    if (!jsdocBuilder.recordLends(stream.getString())) {\n                                        parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\", stream.getLineno(), stream.getCharno());\n                                    }\n                                } else {\n                                    parser.addTypeWarning(\"msg.jsdoc.lends.missing\", stream.getLineno(), stream.getCharno());\n                                }\n                                if (matchingRc \u0026\u0026 !match(JsDocToken.RC)) {\n                                    parser.addTypeWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case MEANING:\n                                ExtractionInfo meaningInfo \u003d extractMultilineTextualBlock(token);\n                                String meaning \u003d meaningInfo.string;\n                                token \u003d meaningInfo.token;\n                                if (!jsdocBuilder.recordMeaning(meaning)) {\n                                    parser.addParserWarning(\"msg.jsdoc.meaning.extra\", stream.getLineno(), stream.getCharno());\n                                }\n                                continue retry;\n                            case NO_ALIAS:\n                                if (!jsdocBuilder.recordNoAlias()) {\n                                    parser.addParserWarning(\"msg.jsdoc.noalias\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_COMPILE:\n                                if (!jsdocBuilder.recordNoCompile()) {\n                                    parser.addParserWarning(\"msg.jsdoc.nocompile\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_TYPE_CHECK:\n                                if (!jsdocBuilder.recordNoTypeCheck()) {\n                                    parser.addParserWarning(\"msg.jsdoc.nocheck\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NOT_IMPLEMENTED:\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case INHERIT_DOC:\n                            case OVERRIDE:\n                                if (!jsdocBuilder.recordOverride()) {\n                                    parser.addTypeWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case THROWS:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                    if (type \u003d\u003d null) {\n                                        token \u003d eatTokensUntilEOL();\n                                        continue retry;\n                                    }\n                                }\n                                token \u003d current();\n                                jsdocBuilder.recordThrowType(type);\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                    String description \u003d descriptionInfo.string;\n                                    if (description.length() \u003e 0) {\n                                        jsdocBuilder.recordThrowDescription(type, description);\n                                    }\n                                    token \u003d descriptionInfo.token;\n                                } else {\n                                    token \u003d eatTokensUntilEOL(token);\n                                }\n                                continue retry;\n                            case PARAM:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordParamTypeNode(token));\n                                    if (type \u003d\u003d null) {\n                                        token \u003d eatTokensUntilEOL();\n                                        continue retry;\n                                    }\n                                    skipEOLs();\n                                    token \u003d next();\n                                    lineno \u003d stream.getLineno();\n                                    charno \u003d stream.getCharno();\n                                }\n                                String name \u003d null;\n                                boolean isBracketedParam \u003d JsDocToken.LB \u003d\u003d token;\n                                if (isBracketedParam) {\n                                    token \u003d next();\n                                }\n                                if (JsDocToken.STRING !\u003d token) {\n                                    parser.addTypeWarning(\"msg.missing.variable.name\", lineno, charno);\n                                } else {\n                                    name \u003d stream.getString();\n                                    if (isBracketedParam) {\n                                        token \u003d next();\n                                        if (JsDocToken.EQUALS \u003d\u003d token) {\n                                            token \u003d next();\n                                            if (JsDocToken.STRING \u003d\u003d token) {\n                                                token \u003d next();\n                                            }\n                                        }\n                                        if (JsDocToken.RB !\u003d token) {\n                                            reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                                        } else if (type !\u003d null) {\n                                            type \u003d JSTypeExpression.makeOptionalArg(type);\n                                        }\n                                    }\n                                    if (name.indexOf(\u0027.\u0027) \u003e -1) {\n                                        name \u003d null;\n                                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                                        if (jsdocBuilder.hasParameter(name)) {\n                                            parser.addTypeWarning(\"msg.dup.variable.name\", name, lineno, charno);\n                                        } else {\n                                            parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name, lineno, charno);\n                                        }\n                                    }\n                                }\n                                if (name \u003d\u003d null) {\n                                    token \u003d eatTokensUntilEOL(token);\n                                    continue retry;\n                                }\n                                jsdocBuilder.markName(name, lineno, charno);\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo paramDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                    String paramDescription \u003d paramDescriptionInfo.string;\n                                    if (paramDescription.length() \u003e 0) {\n                                        jsdocBuilder.recordParameterDescription(name, paramDescription);\n                                    }\n                                    token \u003d paramDescriptionInfo.token;\n                                } else {\n                                    token \u003d eatTokensUntilEOL(token);\n                                }\n                                continue retry;\n                            case PRESERVE_TRY:\n                                if (!jsdocBuilder.recordPreserveTry()) {\n                                    parser.addParserWarning(\"msg.jsdoc.preservertry\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PRIVATE:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                                    parser.addParserWarning(\"msg.jsdoc.visibility.private\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PROTECTED:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                                    parser.addParserWarning(\"msg.jsdoc.visibility.protected\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PUBLIC:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                                    parser.addParserWarning(\"msg.jsdoc.visibility.public\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_SHADOW:\n                                if (!jsdocBuilder.recordNoShadow()) {\n                                    parser.addParserWarning(\"msg.jsdoc.noshadow\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_SIDE_EFFECTS:\n                                if (!jsdocBuilder.recordNoSideEffects()) {\n                                    parser.addParserWarning(\"msg.jsdoc.nosideeffects\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case MODIFIES:\n                                token \u003d parseModifiesTag(next());\n                                continue retry;\n                            case IMPLICIT_CAST:\n                                if (!jsdocBuilder.recordImplicitCast()) {\n                                    parser.addTypeWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case SEE:\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo referenceInfo \u003d extractSingleLineBlock();\n                                    String reference \u003d referenceInfo.string;\n                                    if (reference.length() \u003d\u003d 0) {\n                                        parser.addParserWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        jsdocBuilder.addReference(reference);\n                                    }\n                                    token \u003d referenceInfo.token;\n                                } else {\n                                    token \u003d eatTokensUntilEOL(token);\n                                }\n                                continue retry;\n                            case SUPPRESS:\n                                token \u003d parseSuppressTag(next());\n                                continue retry;\n                            case TEMPLATE:\n                                ExtractionInfo templateInfo \u003d extractSingleLineBlock();\n                                String templateTypeName \u003d templateInfo.string;\n                                if (templateTypeName.length() \u003d\u003d 0) {\n                                    parser.addTypeWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno());\n                                } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {\n                                    parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d templateInfo.token;\n                                continue retry;\n                            case VERSION:\n                                ExtractionInfo versionInfo \u003d extractSingleLineBlock();\n                                String version \u003d versionInfo.string;\n                                if (version.length() \u003d\u003d 0) {\n                                    parser.addParserWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno());\n                                } else {\n                                    if (!jsdocBuilder.recordVersion(version)) {\n                                        parser.addParserWarning(\"msg.jsdoc.extraversion\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d versionInfo.token;\n                                continue retry;\n                            case DEFINE:\n                            case RETURN:\n                            case THIS:\n                            case TYPE:\n                            case TYPEDEF:\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                Node typeNode \u003d null;\n                                if (!lookAheadForTypeAnnotation() \u0026\u0026 annotation \u003d\u003d Annotation.RETURN) {\n                                    typeNode \u003d newNode(Token.QMARK);\n                                } else {\n                                    skipEOLs();\n                                    token \u003d next();\n                                    typeNode \u003d parseAndRecordTypeNode(token, lineno, charno);\n                                }\n                                if (annotation \u003d\u003d Annotation.THIS) {\n                                    typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                    if (typeNode !\u003d null \u0026\u0026 token !\u003d JsDocToken.LC) {\n                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                    }\n                                }\n                                type \u003d createJSTypeExpression(typeNode);\n                                if (type \u003d\u003d null) {\n                                } else {\n                                    switch(annotation) {\n                                        case DEFINE:\n                                            if (!jsdocBuilder.recordDefineType(type)) {\n                                                parser.addParserWarning(\"msg.jsdoc.define\", lineno, charno);\n                                            }\n                                            break;\n                                        case RETURN:\n                                            if (!jsdocBuilder.recordReturnType(type)) {\n                                                parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                                break;\n                                            }\n                                            if (jsdocBuilder.shouldParseDocumentation()) {\n                                                ExtractionInfo returnDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                                String returnDescription \u003d returnDescriptionInfo.string;\n                                                if (returnDescription.length() \u003e 0) {\n                                                    jsdocBuilder.recordReturnDescription(returnDescription);\n                                                }\n                                                token \u003d returnDescriptionInfo.token;\n                                            } else {\n                                                token \u003d eatTokensUntilEOL(token);\n                                            }\n                                            continue retry;\n                                        case THIS:\n                                            if (!jsdocBuilder.recordThisType(type)) {\n                                                parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                        case TYPE:\n                                            if (!jsdocBuilder.recordType(type)) {\n                                                parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                        case TYPEDEF:\n                                            if (!jsdocBuilder.recordTypedef(type)) {\n                                                parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                    }\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                        }\n                    }\n                }\n                break;\n            case EOC:\n                if (hasParsedFileOverviewDocInfo()) {\n                    fileOverviewJSDocInfo \u003d retrieveAndResetParsedJSDocInfo();\n                }\n                checkExtendedTypes(extendedTypes);\n                return true;\n            case EOF:\n                jsdocBuilder.build(null);\n                parser.addParserWarning(\"msg.unexpected.eof\", stream.getLineno(), stream.getCharno());\n                checkExtendedTypes(extendedTypes);\n                return false;\n            case EOL:\n                if (state \u003d\u003d State.SEARCHING_NEWLINE) {\n                    state \u003d State.SEARCHING_ANNOTATION;\n                }\n                token \u003d next();\n                continue retry;\n            default:\n                if (token \u003d\u003d JsDocToken.STAR \u0026\u0026 state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                    token \u003d next();\n                    continue retry;\n                } else {\n                    state \u003d State.SEARCHING_NEWLINE;\n                    token \u003d eatTokensUntilEOL();\n                    continue retry;\n                }\n        }\n        token \u003d next();\n    }\n}",
      "path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
      "functionStartLine": 169,
      "functionName": "parse",
      "functionAnnotation": "",
      "functionDoc": "Parses a {@link JSDocInfo} object. This parsing method reads all tokens\nreturned by the {@link JsDocTokenStream#getJsDocToken()} method until the\n{@link JsDocToken#EOC} is returned.\n\n@return @code true} if JSDoc information was correctly parsed,\n    {@code false} otherwise\n",
      "diff": "@@ -1,532 +1,532 @@\n boolean parse() {\n     int lineno;\n     int charno;\n     JSTypeExpression type;\n     state \u003d State.SEARCHING_ANNOTATION;\n     skipEOLs();\n     JsDocToken token \u003d next();\n     List\u003cExtendedTypeInfo\u003e extendedTypes \u003d Lists.newArrayList();\n     if (jsdocBuilder.shouldParseDocumentation()) {\n         ExtractionInfo blockInfo \u003d extractBlockComment(token);\n         token \u003d blockInfo.token;\n         if (!blockInfo.string.isEmpty()) {\n             jsdocBuilder.recordBlockDescription(blockInfo.string);\n         }\n     } else {\n         if (token !\u003d JsDocToken.ANNOTATION \u0026\u0026 token !\u003d JsDocToken.EOC) {\n             jsdocBuilder.recordBlockDescription(\"\");\n         }\n     }\n     retry: for (; ; ) {\n         switch(token) {\n             case ANNOTATION:\n                 if (state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                     state \u003d State.SEARCHING_NEWLINE;\n                     lineno \u003d stream.getLineno();\n                     charno \u003d stream.getCharno();\n                     String annotationName \u003d stream.getString();\n                     Annotation annotation \u003d annotationNames.get(annotationName);\n                     if (annotation \u003d\u003d null) {\n                         parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno());\n                     } else {\n                         jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n                         switch(annotation) {\n                             case AUTHOR:\n                                 if (jsdocBuilder.shouldParseDocumentation()) {\n                                     ExtractionInfo authorInfo \u003d extractSingleLineBlock();\n                                     String author \u003d authorInfo.string;\n                                     if (author.length() \u003d\u003d 0) {\n                                         parser.addParserWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno());\n                                     } else {\n                                         jsdocBuilder.addAuthor(author);\n                                     }\n                                     token \u003d authorInfo.token;\n                                 } else {\n                                     token \u003d eatTokensUntilEOL(token);\n                                 }\n                                 continue retry;\n                             case CONSTANT:\n                                 if (!jsdocBuilder.recordConstancy()) {\n                                     parser.addParserWarning(\"msg.jsdoc.const\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case CONSTRUCTOR:\n                                 if (!jsdocBuilder.recordConstructor()) {\n                                     if (jsdocBuilder.isInterfaceRecorded()) {\n                                         parser.addTypeWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                     } else {\n                                         parser.addTypeWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case DEPRECATED:\n                                 if (!jsdocBuilder.recordDeprecated()) {\n                                     parser.addParserWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 ExtractionInfo reasonInfo \u003d extractMultilineTextualBlock(token);\n                                 String reason \u003d reasonInfo.string;\n                                 if (reason.length() \u003e 0) {\n                                     jsdocBuilder.recordDeprecationReason(reason);\n                                 }\n                                 token \u003d reasonInfo.token;\n                                 continue retry;\n                             case INTERFACE:\n                                 if (!jsdocBuilder.recordInterface()) {\n                                     if (jsdocBuilder.isConstructorRecorded()) {\n                                         parser.addTypeWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                     } else {\n                                         parser.addTypeWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case DESC:\n                                 if (jsdocBuilder.isDescriptionRecorded()) {\n                                     parser.addParserWarning(\"msg.jsdoc.desc.extra\", stream.getLineno(), stream.getCharno());\n                                     token \u003d eatTokensUntilEOL();\n                                     continue retry;\n                                 } else {\n                                     ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                     String description \u003d descriptionInfo.string;\n                                     jsdocBuilder.recordDescription(description);\n                                     token \u003d descriptionInfo.token;\n                                     continue retry;\n                                 }\n                             case FILE_OVERVIEW:\n                                 String fileOverview \u003d \"\";\n                                 if (jsdocBuilder.shouldParseDocumentation()) {\n                                     ExtractionInfo fileOverviewInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.TRIM);\n                                     fileOverview \u003d fileOverviewInfo.string;\n                                     token \u003d fileOverviewInfo.token;\n                                 } else {\n                                     token \u003d eatTokensUntilEOL(token);\n                                 }\n                                 if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo !\u003d null) {\n                                     parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 continue retry;\n                             case LICENSE:\n                             case PRESERVE:\n                                 ExtractionInfo preserveInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);\n                                 String preserve \u003d preserveInfo.string;\n                                 if (preserve.length() \u003e 0) {\n                                     if (fileLevelJsDocBuilder !\u003d null) {\n                                         fileLevelJsDocBuilder.append(preserve);\n                                     }\n                                 }\n                                 token \u003d preserveInfo.token;\n                                 continue retry;\n                             case ENUM:\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                 }\n                                 if (type \u003d\u003d null) {\n                                     type \u003d createJSTypeExpression(newStringNode(\"number\"));\n                                 }\n                                 if (!jsdocBuilder.recordEnumParameterType(type)) {\n                                     parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                 }\n                                 token \u003d eatTokensUntilEOL(token);\n                                 continue retry;\n                             case EXPORT:\n                                 if (!jsdocBuilder.recordExport()) {\n                                     parser.addParserWarning(\"msg.jsdoc.export\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case EXTERNS:\n                                 if (!jsdocBuilder.recordExterns()) {\n                                     parser.addParserWarning(\"msg.jsdoc.externs\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case JAVA_DISPATCH:\n                                 if (!jsdocBuilder.recordJavaDispatch()) {\n                                     parser.addParserWarning(\"msg.jsdoc.javadispatch\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case EXTENDS:\n                             case IMPLEMENTS:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 boolean matchingRc \u003d false;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     token \u003d next();\n                                     matchingRc \u003d true;\n                                 }\n                                 if (token \u003d\u003d JsDocToken.STRING) {\n                                     Node typeNode \u003d parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);\n                                     lineno \u003d stream.getLineno();\n                                     charno \u003d stream.getCharno();\n                                     typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                     if (typeNode !\u003d null \u0026\u0026 !matchingRc) {\n                                         typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                     }\n                                     type \u003d createJSTypeExpression(typeNode);\n                                     if (annotation \u003d\u003d Annotation.EXTENDS) {\n                                         extendedTypes.add(new ExtendedTypeInfo(type, stream.getLineno(), stream.getCharno()));\n                                     } else {\n                                         Preconditions.checkState(annotation \u003d\u003d Annotation.IMPLEMENTS);\n                                         if (!jsdocBuilder.recordImplementedInterface(type)) {\n                                             parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\", lineno, charno);\n                                         }\n                                     }\n                                     token \u003d next();\n                                     if (matchingRc) {\n                                         if (token !\u003d JsDocToken.RC) {\n                                             parser.addTypeWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                         }\n                                     } else if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOF \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                         parser.addTypeWarning(\"msg.end.annotation.expected\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 } else {\n                                     parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);\n                                 }\n                                 token \u003d eatTokensUntilEOL(token);\n                                 continue retry;\n                             case HIDDEN:\n                                 if (!jsdocBuilder.recordHiddenness()) {\n                                     parser.addParserWarning(\"msg.jsdoc.hidden\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case LENDS:\n                                 skipEOLs();\n                                 matchingRc \u003d false;\n                                 if (match(JsDocToken.LC)) {\n                                     token \u003d next();\n                                     matchingRc \u003d true;\n                                 }\n                                 if (match(JsDocToken.STRING)) {\n                                     token \u003d next();\n                                     if (!jsdocBuilder.recordLends(stream.getString())) {\n                                         parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 } else {\n                                     parser.addTypeWarning(\"msg.jsdoc.lends.missing\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 if (matchingRc \u0026\u0026 !match(JsDocToken.RC)) {\n                                     parser.addTypeWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case MEANING:\n                                 ExtractionInfo meaningInfo \u003d extractMultilineTextualBlock(token);\n                                 String meaning \u003d meaningInfo.string;\n                                 token \u003d meaningInfo.token;\n                                 if (!jsdocBuilder.recordMeaning(meaning)) {\n                                     parser.addParserWarning(\"msg.jsdoc.meaning.extra\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 continue retry;\n                             case NO_ALIAS:\n                                 if (!jsdocBuilder.recordNoAlias()) {\n                                     parser.addParserWarning(\"msg.jsdoc.noalias\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_COMPILE:\n                                 if (!jsdocBuilder.recordNoCompile()) {\n                                     parser.addParserWarning(\"msg.jsdoc.nocompile\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_TYPE_CHECK:\n                                 if (!jsdocBuilder.recordNoTypeCheck()) {\n                                     parser.addParserWarning(\"msg.jsdoc.nocheck\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NOT_IMPLEMENTED:\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case INHERIT_DOC:\n                             case OVERRIDE:\n                                 if (!jsdocBuilder.recordOverride()) {\n                                     parser.addTypeWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case THROWS:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                     if (type \u003d\u003d null) {\n                                         token \u003d eatTokensUntilEOL();\n                                         continue retry;\n                                     }\n                                 }\n                                 token \u003d current();\n                                 jsdocBuilder.recordThrowType(type);\n                                 if (jsdocBuilder.shouldParseDocumentation()) {\n                                     ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                     String description \u003d descriptionInfo.string;\n                                     if (description.length() \u003e 0) {\n                                         jsdocBuilder.recordThrowDescription(type, description);\n                                     }\n                                     token \u003d descriptionInfo.token;\n                                 } else {\n                                     token \u003d eatTokensUntilEOL(token);\n                                 }\n                                 continue retry;\n                             case PARAM:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordParamTypeNode(token));\n                                     if (type \u003d\u003d null) {\n                                         token \u003d eatTokensUntilEOL();\n                                         continue retry;\n                                     }\n                                     skipEOLs();\n                                     token \u003d next();\n                                     lineno \u003d stream.getLineno();\n                                     charno \u003d stream.getCharno();\n                                 }\n                                 String name \u003d null;\n                                 boolean isBracketedParam \u003d JsDocToken.LB \u003d\u003d token;\n                                 if (isBracketedParam) {\n                                     token \u003d next();\n                                 }\n                                 if (JsDocToken.STRING !\u003d token) {\n                                     parser.addTypeWarning(\"msg.missing.variable.name\", lineno, charno);\n                                 } else {\n                                     name \u003d stream.getString();\n                                     if (isBracketedParam) {\n                                         token \u003d next();\n                                         if (JsDocToken.EQUALS \u003d\u003d token) {\n                                             token \u003d next();\n                                             if (JsDocToken.STRING \u003d\u003d token) {\n                                                 token \u003d next();\n                                             }\n                                         }\n                                         if (JsDocToken.RB !\u003d token) {\n                                             reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                                         } else if (type !\u003d null) {\n                                             type \u003d JSTypeExpression.makeOptionalArg(type);\n                                         }\n                                     }\n                                     if (name.indexOf(\u0027.\u0027) \u003e -1) {\n                                         name \u003d null;\n                                     } else if (!jsdocBuilder.recordParameter(name, type)) {\n                                         if (jsdocBuilder.hasParameter(name)) {\n                                             parser.addTypeWarning(\"msg.dup.variable.name\", name, lineno, charno);\n                                         } else {\n                                             parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name, lineno, charno);\n                                         }\n                                     }\n                                 }\n                                 if (name \u003d\u003d null) {\n                                     token \u003d eatTokensUntilEOL(token);\n                                     continue retry;\n                                 }\n                                 jsdocBuilder.markName(name, lineno, charno);\n                                 if (jsdocBuilder.shouldParseDocumentation()) {\n                                     ExtractionInfo paramDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                     String paramDescription \u003d paramDescriptionInfo.string;\n                                     if (paramDescription.length() \u003e 0) {\n                                         jsdocBuilder.recordParameterDescription(name, paramDescription);\n                                     }\n                                     token \u003d paramDescriptionInfo.token;\n                                 } else {\n                                     token \u003d eatTokensUntilEOL(token);\n                                 }\n                                 continue retry;\n                             case PRESERVE_TRY:\n                                 if (!jsdocBuilder.recordPreserveTry()) {\n                                     parser.addParserWarning(\"msg.jsdoc.preservertry\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PRIVATE:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                                     parser.addParserWarning(\"msg.jsdoc.visibility.private\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PROTECTED:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                                     parser.addParserWarning(\"msg.jsdoc.visibility.protected\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PUBLIC:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                                     parser.addParserWarning(\"msg.jsdoc.visibility.public\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_SHADOW:\n                                 if (!jsdocBuilder.recordNoShadow()) {\n                                     parser.addParserWarning(\"msg.jsdoc.noshadow\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_SIDE_EFFECTS:\n                                 if (!jsdocBuilder.recordNoSideEffects()) {\n                                     parser.addParserWarning(\"msg.jsdoc.nosideeffects\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case MODIFIES:\n                                 token \u003d parseModifiesTag(next());\n                                 continue retry;\n                             case IMPLICIT_CAST:\n                                 if (!jsdocBuilder.recordImplicitCast()) {\n                                     parser.addTypeWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case SEE:\n                                 if (jsdocBuilder.shouldParseDocumentation()) {\n                                     ExtractionInfo referenceInfo \u003d extractSingleLineBlock();\n                                     String reference \u003d referenceInfo.string;\n                                     if (reference.length() \u003d\u003d 0) {\n                                         parser.addParserWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno());\n                                     } else {\n                                         jsdocBuilder.addReference(reference);\n                                     }\n                                     token \u003d referenceInfo.token;\n                                 } else {\n                                     token \u003d eatTokensUntilEOL(token);\n                                 }\n                                 continue retry;\n                             case SUPPRESS:\n                                 token \u003d parseSuppressTag(next());\n                                 continue retry;\n                             case TEMPLATE:\n                                 ExtractionInfo templateInfo \u003d extractSingleLineBlock();\n                                 String templateTypeName \u003d templateInfo.string;\n                                 if (templateTypeName.length() \u003d\u003d 0) {\n                                     parser.addTypeWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno());\n                                 } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {\n                                     parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d templateInfo.token;\n                                 continue retry;\n                             case VERSION:\n                                 ExtractionInfo versionInfo \u003d extractSingleLineBlock();\n                                 String version \u003d versionInfo.string;\n                                 if (version.length() \u003d\u003d 0) {\n                                     parser.addParserWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno());\n                                 } else {\n                                     if (!jsdocBuilder.recordVersion(version)) {\n                                         parser.addParserWarning(\"msg.jsdoc.extraversion\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d versionInfo.token;\n                                 continue retry;\n                             case DEFINE:\n                             case RETURN:\n                             case THIS:\n                             case TYPE:\n                             case TYPEDEF:\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 Node typeNode \u003d null;\n                                 if (!lookAheadForTypeAnnotation() \u0026\u0026 annotation \u003d\u003d Annotation.RETURN) {\n                                     typeNode \u003d newNode(Token.QMARK);\n                                 } else {\n                                     skipEOLs();\n                                     token \u003d next();\n                                     typeNode \u003d parseAndRecordTypeNode(token, lineno, charno);\n                                 }\n                                 if (annotation \u003d\u003d Annotation.THIS) {\n                                     typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                     if (typeNode !\u003d null \u0026\u0026 token !\u003d JsDocToken.LC) {\n                                         typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                     }\n                                 }\n                                 type \u003d createJSTypeExpression(typeNode);\n                                 if (type \u003d\u003d null) {\n                                 } else {\n                                     switch(annotation) {\n                                         case DEFINE:\n                                             if (!jsdocBuilder.recordDefineType(type)) {\n                                                 parser.addParserWarning(\"msg.jsdoc.define\", lineno, charno);\n                                             }\n                                             break;\n                                         case RETURN:\n                                             if (!jsdocBuilder.recordReturnType(type)) {\n                                                 parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                                 break;\n                                             }\n                                             if (jsdocBuilder.shouldParseDocumentation()) {\n                                                 ExtractionInfo returnDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                                 String returnDescription \u003d returnDescriptionInfo.string;\n                                                 if (returnDescription.length() \u003e 0) {\n                                                     jsdocBuilder.recordReturnDescription(returnDescription);\n                                                 }\n                                                 token \u003d returnDescriptionInfo.token;\n                                             } else {\n                                                 token \u003d eatTokensUntilEOL(token);\n                                             }\n                                             continue retry;\n                                         case THIS:\n                                             if (!jsdocBuilder.recordThisType(type)) {\n                                                 parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                         case TYPE:\n                                             if (!jsdocBuilder.recordType(type)) {\n                                                 parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                         case TYPEDEF:\n                                             if (!jsdocBuilder.recordTypedef(type)) {\n                                                 parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                     }\n-                                    token \u003d eatTokensUntilEOL();\n                                 }\n+                                token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                         }\n                     }\n                 }\n                 break;\n             case EOC:\n                 if (hasParsedFileOverviewDocInfo()) {\n                     fileOverviewJSDocInfo \u003d retrieveAndResetParsedJSDocInfo();\n                 }\n                 checkExtendedTypes(extendedTypes);\n                 return true;\n             case EOF:\n                 jsdocBuilder.build(null);\n                 parser.addParserWarning(\"msg.unexpected.eof\", stream.getLineno(), stream.getCharno());\n                 checkExtendedTypes(extendedTypes);\n                 return false;\n             case EOL:\n                 if (state \u003d\u003d State.SEARCHING_NEWLINE) {\n                     state \u003d State.SEARCHING_ANNOTATION;\n                 }\n                 token \u003d next();\n                 continue retry;\n             default:\n                 if (token \u003d\u003d JsDocToken.STAR \u0026\u0026 state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                     token \u003d next();\n                     continue retry;\n                 } else {\n                     state \u003d State.SEARCHING_NEWLINE;\n                     token \u003d eatTokensUntilEOL();\n                     continue retry;\n                 }\n         }\n         token \u003d next();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "cc628d6050107e3dfcc7bd2748708c12ef15b4e0": {
      "type": "Ybodychange",
      "commitMessage": "\nAdd multiple extends annotations for interfaces in JsDoc\n\nR\u003dnicksantos,johnlenz\nDELTA\u003d151  (143 added, 1 deleted, 7 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d1505\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1022 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/19/11, 1:05 PM",
      "commitName": "cc628d6050107e3dfcc7bd2748708c12ef15b4e0",
      "commitAuthor": "zhuyi@google.com",
      "commitDateOld": "4/12/11, 12:15 PM",
      "commitNameOld": "f322be0e576d5e2114cb59c0a6537197997b9c59",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 7.03,
      "commitsBetweenForRepo": 22,
      "commitsBetweenForFile": 1,
      "actualSource": "boolean parse() {\n    int lineno;\n    int charno;\n    JSTypeExpression type;\n    state \u003d State.SEARCHING_ANNOTATION;\n    skipEOLs();\n    JsDocToken token \u003d next();\n    List\u003cExtendedTypeInfo\u003e extendedTypes \u003d Lists.newArrayList();\n    if (jsdocBuilder.shouldParseDocumentation()) {\n        ExtractionInfo blockInfo \u003d extractBlockComment(token);\n        token \u003d blockInfo.token;\n        if (!blockInfo.string.isEmpty()) {\n            jsdocBuilder.recordBlockDescription(blockInfo.string);\n        }\n    } else {\n        if (token !\u003d JsDocToken.ANNOTATION \u0026\u0026 token !\u003d JsDocToken.EOC) {\n            jsdocBuilder.recordBlockDescription(\"\");\n        }\n    }\n    retry: for (; ; ) {\n        switch(token) {\n            case ANNOTATION:\n                if (state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                    state \u003d State.SEARCHING_NEWLINE;\n                    lineno \u003d stream.getLineno();\n                    charno \u003d stream.getCharno();\n                    String annotationName \u003d stream.getString();\n                    Annotation annotation \u003d annotationNames.get(annotationName);\n                    if (annotation \u003d\u003d null) {\n                        parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno());\n                    } else {\n                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n                        switch(annotation) {\n                            case AUTHOR:\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo authorInfo \u003d extractSingleLineBlock();\n                                    String author \u003d authorInfo.string;\n                                    if (author.length() \u003d\u003d 0) {\n                                        parser.addParserWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        jsdocBuilder.addAuthor(author);\n                                    }\n                                    token \u003d authorInfo.token;\n                                } else {\n                                    token \u003d eatTokensUntilEOL(token);\n                                }\n                                continue retry;\n                            case CONSTANT:\n                                if (!jsdocBuilder.recordConstancy()) {\n                                    parser.addParserWarning(\"msg.jsdoc.const\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case CONSTRUCTOR:\n                                if (!jsdocBuilder.recordConstructor()) {\n                                    if (jsdocBuilder.isInterfaceRecorded()) {\n                                        parser.addTypeWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        parser.addTypeWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case DEPRECATED:\n                                if (!jsdocBuilder.recordDeprecated()) {\n                                    parser.addParserWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno());\n                                }\n                                ExtractionInfo reasonInfo \u003d extractMultilineTextualBlock(token);\n                                String reason \u003d reasonInfo.string;\n                                if (reason.length() \u003e 0) {\n                                    jsdocBuilder.recordDeprecationReason(reason);\n                                }\n                                token \u003d reasonInfo.token;\n                                continue retry;\n                            case INTERFACE:\n                                if (!jsdocBuilder.recordInterface()) {\n                                    if (jsdocBuilder.isConstructorRecorded()) {\n                                        parser.addTypeWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        parser.addTypeWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case DESC:\n                                if (jsdocBuilder.isDescriptionRecorded()) {\n                                    parser.addParserWarning(\"msg.jsdoc.desc.extra\", stream.getLineno(), stream.getCharno());\n                                    token \u003d eatTokensUntilEOL();\n                                    continue retry;\n                                } else {\n                                    ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                    String description \u003d descriptionInfo.string;\n                                    jsdocBuilder.recordDescription(description);\n                                    token \u003d descriptionInfo.token;\n                                    continue retry;\n                                }\n                            case FILE_OVERVIEW:\n                                String fileOverview \u003d \"\";\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo fileOverviewInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.TRIM);\n                                    fileOverview \u003d fileOverviewInfo.string;\n                                    token \u003d fileOverviewInfo.token;\n                                } else {\n                                    token \u003d eatTokensUntilEOL(token);\n                                }\n                                if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo !\u003d null) {\n                                    parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno());\n                                }\n                                continue retry;\n                            case LICENSE:\n                            case PRESERVE:\n                                ExtractionInfo preserveInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);\n                                String preserve \u003d preserveInfo.string;\n                                if (preserve.length() \u003e 0) {\n                                    if (fileLevelJsDocBuilder !\u003d null) {\n                                        fileLevelJsDocBuilder.append(preserve);\n                                    }\n                                }\n                                token \u003d preserveInfo.token;\n                                continue retry;\n                            case ENUM:\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                }\n                                if (type \u003d\u003d null) {\n                                    type \u003d createJSTypeExpression(newStringNode(\"number\"));\n                                }\n                                if (!jsdocBuilder.recordEnumParameterType(type)) {\n                                    parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                }\n                                token \u003d eatTokensUntilEOL(token);\n                                continue retry;\n                            case EXPORT:\n                                if (!jsdocBuilder.recordExport()) {\n                                    parser.addParserWarning(\"msg.jsdoc.export\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case EXTERNS:\n                                if (!jsdocBuilder.recordExterns()) {\n                                    parser.addParserWarning(\"msg.jsdoc.externs\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case JAVA_DISPATCH:\n                                if (!jsdocBuilder.recordJavaDispatch()) {\n                                    parser.addParserWarning(\"msg.jsdoc.javadispatch\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case EXTENDS:\n                            case IMPLEMENTS:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                boolean matchingRc \u003d false;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    token \u003d next();\n                                    matchingRc \u003d true;\n                                }\n                                if (token \u003d\u003d JsDocToken.STRING) {\n                                    Node typeNode \u003d parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);\n                                    lineno \u003d stream.getLineno();\n                                    charno \u003d stream.getCharno();\n                                    typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                    if (typeNode !\u003d null \u0026\u0026 !matchingRc) {\n                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                    }\n                                    type \u003d createJSTypeExpression(typeNode);\n                                    if (annotation \u003d\u003d Annotation.EXTENDS) {\n                                        extendedTypes.add(new ExtendedTypeInfo(type, stream.getLineno(), stream.getCharno()));\n                                    } else {\n                                        Preconditions.checkState(annotation \u003d\u003d Annotation.IMPLEMENTS);\n                                        if (!jsdocBuilder.recordImplementedInterface(type)) {\n                                            parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\", lineno, charno);\n                                        }\n                                    }\n                                    token \u003d next();\n                                    if (matchingRc) {\n                                        if (token !\u003d JsDocToken.RC) {\n                                            parser.addTypeWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                        }\n                                    } else if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOF \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                        parser.addTypeWarning(\"msg.end.annotation.expected\", stream.getLineno(), stream.getCharno());\n                                    }\n                                } else {\n                                    parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);\n                                }\n                                token \u003d eatTokensUntilEOL(token);\n                                continue retry;\n                            case HIDDEN:\n                                if (!jsdocBuilder.recordHiddenness()) {\n                                    parser.addParserWarning(\"msg.jsdoc.hidden\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case LENDS:\n                                skipEOLs();\n                                matchingRc \u003d false;\n                                if (match(JsDocToken.LC)) {\n                                    token \u003d next();\n                                    matchingRc \u003d true;\n                                }\n                                if (match(JsDocToken.STRING)) {\n                                    token \u003d next();\n                                    if (!jsdocBuilder.recordLends(stream.getString())) {\n                                        parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\", stream.getLineno(), stream.getCharno());\n                                    }\n                                } else {\n                                    parser.addTypeWarning(\"msg.jsdoc.lends.missing\", stream.getLineno(), stream.getCharno());\n                                }\n                                if (matchingRc \u0026\u0026 !match(JsDocToken.RC)) {\n                                    parser.addTypeWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case MEANING:\n                                ExtractionInfo meaningInfo \u003d extractMultilineTextualBlock(token);\n                                String meaning \u003d meaningInfo.string;\n                                token \u003d meaningInfo.token;\n                                if (!jsdocBuilder.recordMeaning(meaning)) {\n                                    parser.addParserWarning(\"msg.jsdoc.meaning.extra\", stream.getLineno(), stream.getCharno());\n                                }\n                                continue retry;\n                            case NO_ALIAS:\n                                if (!jsdocBuilder.recordNoAlias()) {\n                                    parser.addParserWarning(\"msg.jsdoc.noalias\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_COMPILE:\n                                if (!jsdocBuilder.recordNoCompile()) {\n                                    parser.addParserWarning(\"msg.jsdoc.nocompile\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_TYPE_CHECK:\n                                if (!jsdocBuilder.recordNoTypeCheck()) {\n                                    parser.addParserWarning(\"msg.jsdoc.nocheck\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NOT_IMPLEMENTED:\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case INHERIT_DOC:\n                            case OVERRIDE:\n                                if (!jsdocBuilder.recordOverride()) {\n                                    parser.addTypeWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case THROWS:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                    if (type \u003d\u003d null) {\n                                        token \u003d eatTokensUntilEOL();\n                                        continue retry;\n                                    }\n                                }\n                                token \u003d current();\n                                jsdocBuilder.recordThrowType(type);\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                    String description \u003d descriptionInfo.string;\n                                    if (description.length() \u003e 0) {\n                                        jsdocBuilder.recordThrowDescription(type, description);\n                                    }\n                                    token \u003d descriptionInfo.token;\n                                } else {\n                                    token \u003d eatTokensUntilEOL(token);\n                                }\n                                continue retry;\n                            case PARAM:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordParamTypeNode(token));\n                                    if (type \u003d\u003d null) {\n                                        token \u003d eatTokensUntilEOL();\n                                        continue retry;\n                                    }\n                                    skipEOLs();\n                                    token \u003d next();\n                                    lineno \u003d stream.getLineno();\n                                    charno \u003d stream.getCharno();\n                                }\n                                String name \u003d null;\n                                boolean isBracketedParam \u003d JsDocToken.LB \u003d\u003d token;\n                                if (isBracketedParam) {\n                                    token \u003d next();\n                                }\n                                if (JsDocToken.STRING !\u003d token) {\n                                    parser.addTypeWarning(\"msg.missing.variable.name\", lineno, charno);\n                                } else {\n                                    name \u003d stream.getString();\n                                    if (isBracketedParam) {\n                                        token \u003d next();\n                                        if (JsDocToken.EQUALS \u003d\u003d token) {\n                                            token \u003d next();\n                                            if (JsDocToken.STRING \u003d\u003d token) {\n                                                token \u003d next();\n                                            }\n                                        }\n                                        if (JsDocToken.RB !\u003d token) {\n                                            reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                                        } else if (type !\u003d null) {\n                                            type \u003d JSTypeExpression.makeOptionalArg(type);\n                                        }\n                                    }\n                                    if (name.indexOf(\u0027.\u0027) \u003e -1) {\n                                        name \u003d null;\n                                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                                        if (jsdocBuilder.hasParameter(name)) {\n                                            parser.addTypeWarning(\"msg.dup.variable.name\", name, lineno, charno);\n                                        } else {\n                                            parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name, lineno, charno);\n                                        }\n                                    }\n                                }\n                                if (name \u003d\u003d null) {\n                                    token \u003d eatTokensUntilEOL(token);\n                                    continue retry;\n                                }\n                                jsdocBuilder.markName(name, lineno, charno);\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo paramDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                    String paramDescription \u003d paramDescriptionInfo.string;\n                                    if (paramDescription.length() \u003e 0) {\n                                        jsdocBuilder.recordParameterDescription(name, paramDescription);\n                                    }\n                                    token \u003d paramDescriptionInfo.token;\n                                } else {\n                                    token \u003d eatTokensUntilEOL(token);\n                                }\n                                continue retry;\n                            case PRESERVE_TRY:\n                                if (!jsdocBuilder.recordPreserveTry()) {\n                                    parser.addParserWarning(\"msg.jsdoc.preservertry\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PRIVATE:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                                    parser.addParserWarning(\"msg.jsdoc.visibility.private\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PROTECTED:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                                    parser.addParserWarning(\"msg.jsdoc.visibility.protected\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PUBLIC:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                                    parser.addParserWarning(\"msg.jsdoc.visibility.public\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_SHADOW:\n                                if (!jsdocBuilder.recordNoShadow()) {\n                                    parser.addParserWarning(\"msg.jsdoc.noshadow\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_SIDE_EFFECTS:\n                                if (!jsdocBuilder.recordNoSideEffects()) {\n                                    parser.addParserWarning(\"msg.jsdoc.nosideeffects\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case MODIFIES:\n                                token \u003d parseModifiesTag(next());\n                                continue retry;\n                            case IMPLICIT_CAST:\n                                if (!jsdocBuilder.recordImplicitCast()) {\n                                    parser.addTypeWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case SEE:\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo referenceInfo \u003d extractSingleLineBlock();\n                                    String reference \u003d referenceInfo.string;\n                                    if (reference.length() \u003d\u003d 0) {\n                                        parser.addParserWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        jsdocBuilder.addReference(reference);\n                                    }\n                                    token \u003d referenceInfo.token;\n                                } else {\n                                    token \u003d eatTokensUntilEOL(token);\n                                }\n                                continue retry;\n                            case SUPPRESS:\n                                token \u003d parseSuppressTag(next());\n                                continue retry;\n                            case TEMPLATE:\n                                ExtractionInfo templateInfo \u003d extractSingleLineBlock();\n                                String templateTypeName \u003d templateInfo.string;\n                                if (templateTypeName.length() \u003d\u003d 0) {\n                                    parser.addTypeWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno());\n                                } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {\n                                    parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d templateInfo.token;\n                                continue retry;\n                            case VERSION:\n                                ExtractionInfo versionInfo \u003d extractSingleLineBlock();\n                                String version \u003d versionInfo.string;\n                                if (version.length() \u003d\u003d 0) {\n                                    parser.addParserWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno());\n                                } else {\n                                    if (!jsdocBuilder.recordVersion(version)) {\n                                        parser.addParserWarning(\"msg.jsdoc.extraversion\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d versionInfo.token;\n                                continue retry;\n                            case DEFINE:\n                            case RETURN:\n                            case THIS:\n                            case TYPE:\n                            case TYPEDEF:\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                Node typeNode \u003d null;\n                                if (!lookAheadForTypeAnnotation() \u0026\u0026 annotation \u003d\u003d Annotation.RETURN) {\n                                    typeNode \u003d newNode(Token.QMARK);\n                                } else {\n                                    skipEOLs();\n                                    token \u003d next();\n                                    typeNode \u003d parseAndRecordTypeNode(token, lineno, charno);\n                                }\n                                if (annotation \u003d\u003d Annotation.THIS) {\n                                    typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                    if (typeNode !\u003d null \u0026\u0026 token !\u003d JsDocToken.LC) {\n                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                    }\n                                }\n                                type \u003d createJSTypeExpression(typeNode);\n                                if (type \u003d\u003d null) {\n                                } else {\n                                    switch(annotation) {\n                                        case DEFINE:\n                                            if (!jsdocBuilder.recordDefineType(type)) {\n                                                parser.addParserWarning(\"msg.jsdoc.define\", lineno, charno);\n                                            }\n                                            break;\n                                        case RETURN:\n                                            if (!jsdocBuilder.recordReturnType(type)) {\n                                                parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                                break;\n                                            }\n                                            if (jsdocBuilder.shouldParseDocumentation()) {\n                                                ExtractionInfo returnDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                                String returnDescription \u003d returnDescriptionInfo.string;\n                                                if (returnDescription.length() \u003e 0) {\n                                                    jsdocBuilder.recordReturnDescription(returnDescription);\n                                                }\n                                                token \u003d returnDescriptionInfo.token;\n                                            } else {\n                                                token \u003d eatTokensUntilEOL(token);\n                                            }\n                                            continue retry;\n                                        case THIS:\n                                            if (!jsdocBuilder.recordThisType(type)) {\n                                                parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                        case TYPE:\n                                            if (!jsdocBuilder.recordType(type)) {\n                                                parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                        case TYPEDEF:\n                                            if (!jsdocBuilder.recordTypedef(type)) {\n                                                parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                    }\n                                    token \u003d eatTokensUntilEOL();\n                                }\n                                continue retry;\n                        }\n                    }\n                }\n                break;\n            case EOC:\n                if (hasParsedFileOverviewDocInfo()) {\n                    fileOverviewJSDocInfo \u003d retrieveAndResetParsedJSDocInfo();\n                }\n                checkExtendedTypes(extendedTypes);\n                return true;\n            case EOF:\n                jsdocBuilder.build(null);\n                parser.addParserWarning(\"msg.unexpected.eof\", stream.getLineno(), stream.getCharno());\n                checkExtendedTypes(extendedTypes);\n                return false;\n            case EOL:\n                if (state \u003d\u003d State.SEARCHING_NEWLINE) {\n                    state \u003d State.SEARCHING_ANNOTATION;\n                }\n                token \u003d next();\n                continue retry;\n            default:\n                if (token \u003d\u003d JsDocToken.STAR \u0026\u0026 state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                    token \u003d next();\n                    continue retry;\n                } else {\n                    state \u003d State.SEARCHING_NEWLINE;\n                    token \u003d eatTokensUntilEOL();\n                    continue retry;\n                }\n        }\n        token \u003d next();\n    }\n}",
      "path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
      "functionStartLine": 169,
      "functionName": "parse",
      "functionAnnotation": "",
      "functionDoc": "Parses a {@link JSDocInfo} object. This parsing method reads all tokens\nreturned by the {@link JsDocTokenStream#getJsDocToken()} method until the\n{@link JsDocToken#EOC} is returned.\n\n@return @code true} if JSDoc information was correctly parsed,\n    {@code false} otherwise\n",
      "diff": "@@ -1,531 +1,532 @@\n boolean parse() {\n     int lineno;\n     int charno;\n     JSTypeExpression type;\n     state \u003d State.SEARCHING_ANNOTATION;\n     skipEOLs();\n     JsDocToken token \u003d next();\n+    List\u003cExtendedTypeInfo\u003e extendedTypes \u003d Lists.newArrayList();\n     if (jsdocBuilder.shouldParseDocumentation()) {\n         ExtractionInfo blockInfo \u003d extractBlockComment(token);\n         token \u003d blockInfo.token;\n         if (!blockInfo.string.isEmpty()) {\n             jsdocBuilder.recordBlockDescription(blockInfo.string);\n         }\n     } else {\n         if (token !\u003d JsDocToken.ANNOTATION \u0026\u0026 token !\u003d JsDocToken.EOC) {\n             jsdocBuilder.recordBlockDescription(\"\");\n         }\n     }\n     retry: for (; ; ) {\n         switch(token) {\n             case ANNOTATION:\n                 if (state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                     state \u003d State.SEARCHING_NEWLINE;\n                     lineno \u003d stream.getLineno();\n                     charno \u003d stream.getCharno();\n                     String annotationName \u003d stream.getString();\n                     Annotation annotation \u003d annotationNames.get(annotationName);\n                     if (annotation \u003d\u003d null) {\n                         parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno());\n                     } else {\n                         jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n                         switch(annotation) {\n                             case AUTHOR:\n                                 if (jsdocBuilder.shouldParseDocumentation()) {\n                                     ExtractionInfo authorInfo \u003d extractSingleLineBlock();\n                                     String author \u003d authorInfo.string;\n                                     if (author.length() \u003d\u003d 0) {\n                                         parser.addParserWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno());\n                                     } else {\n                                         jsdocBuilder.addAuthor(author);\n                                     }\n                                     token \u003d authorInfo.token;\n                                 } else {\n                                     token \u003d eatTokensUntilEOL(token);\n                                 }\n                                 continue retry;\n                             case CONSTANT:\n                                 if (!jsdocBuilder.recordConstancy()) {\n                                     parser.addParserWarning(\"msg.jsdoc.const\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case CONSTRUCTOR:\n                                 if (!jsdocBuilder.recordConstructor()) {\n                                     if (jsdocBuilder.isInterfaceRecorded()) {\n                                         parser.addTypeWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                     } else {\n                                         parser.addTypeWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case DEPRECATED:\n                                 if (!jsdocBuilder.recordDeprecated()) {\n                                     parser.addParserWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 ExtractionInfo reasonInfo \u003d extractMultilineTextualBlock(token);\n                                 String reason \u003d reasonInfo.string;\n                                 if (reason.length() \u003e 0) {\n                                     jsdocBuilder.recordDeprecationReason(reason);\n                                 }\n                                 token \u003d reasonInfo.token;\n                                 continue retry;\n                             case INTERFACE:\n                                 if (!jsdocBuilder.recordInterface()) {\n                                     if (jsdocBuilder.isConstructorRecorded()) {\n                                         parser.addTypeWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                     } else {\n                                         parser.addTypeWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case DESC:\n                                 if (jsdocBuilder.isDescriptionRecorded()) {\n                                     parser.addParserWarning(\"msg.jsdoc.desc.extra\", stream.getLineno(), stream.getCharno());\n                                     token \u003d eatTokensUntilEOL();\n                                     continue retry;\n                                 } else {\n                                     ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                     String description \u003d descriptionInfo.string;\n                                     jsdocBuilder.recordDescription(description);\n                                     token \u003d descriptionInfo.token;\n                                     continue retry;\n                                 }\n                             case FILE_OVERVIEW:\n                                 String fileOverview \u003d \"\";\n                                 if (jsdocBuilder.shouldParseDocumentation()) {\n                                     ExtractionInfo fileOverviewInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.TRIM);\n                                     fileOverview \u003d fileOverviewInfo.string;\n                                     token \u003d fileOverviewInfo.token;\n                                 } else {\n                                     token \u003d eatTokensUntilEOL(token);\n                                 }\n                                 if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo !\u003d null) {\n                                     parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 continue retry;\n                             case LICENSE:\n                             case PRESERVE:\n                                 ExtractionInfo preserveInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);\n                                 String preserve \u003d preserveInfo.string;\n                                 if (preserve.length() \u003e 0) {\n                                     if (fileLevelJsDocBuilder !\u003d null) {\n                                         fileLevelJsDocBuilder.append(preserve);\n                                     }\n                                 }\n                                 token \u003d preserveInfo.token;\n                                 continue retry;\n                             case ENUM:\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                 }\n                                 if (type \u003d\u003d null) {\n                                     type \u003d createJSTypeExpression(newStringNode(\"number\"));\n                                 }\n                                 if (!jsdocBuilder.recordEnumParameterType(type)) {\n                                     parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                 }\n                                 token \u003d eatTokensUntilEOL(token);\n                                 continue retry;\n                             case EXPORT:\n                                 if (!jsdocBuilder.recordExport()) {\n                                     parser.addParserWarning(\"msg.jsdoc.export\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case EXTERNS:\n                                 if (!jsdocBuilder.recordExterns()) {\n                                     parser.addParserWarning(\"msg.jsdoc.externs\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case JAVA_DISPATCH:\n                                 if (!jsdocBuilder.recordJavaDispatch()) {\n                                     parser.addParserWarning(\"msg.jsdoc.javadispatch\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case EXTENDS:\n                             case IMPLEMENTS:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 boolean matchingRc \u003d false;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     token \u003d next();\n                                     matchingRc \u003d true;\n                                 }\n                                 if (token \u003d\u003d JsDocToken.STRING) {\n                                     Node typeNode \u003d parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);\n                                     lineno \u003d stream.getLineno();\n                                     charno \u003d stream.getCharno();\n                                     typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                     if (typeNode !\u003d null \u0026\u0026 !matchingRc) {\n                                         typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                     }\n                                     type \u003d createJSTypeExpression(typeNode);\n                                     if (annotation \u003d\u003d Annotation.EXTENDS) {\n-                                        if (!jsdocBuilder.recordBaseType(type)) {\n-                                            parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n-                                        }\n+                                        extendedTypes.add(new ExtendedTypeInfo(type, stream.getLineno(), stream.getCharno()));\n                                     } else {\n                                         Preconditions.checkState(annotation \u003d\u003d Annotation.IMPLEMENTS);\n                                         if (!jsdocBuilder.recordImplementedInterface(type)) {\n                                             parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\", lineno, charno);\n                                         }\n                                     }\n                                     token \u003d next();\n                                     if (matchingRc) {\n                                         if (token !\u003d JsDocToken.RC) {\n                                             parser.addTypeWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                         }\n                                     } else if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOF \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                         parser.addTypeWarning(\"msg.end.annotation.expected\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 } else {\n                                     parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);\n                                 }\n                                 token \u003d eatTokensUntilEOL(token);\n                                 continue retry;\n                             case HIDDEN:\n                                 if (!jsdocBuilder.recordHiddenness()) {\n                                     parser.addParserWarning(\"msg.jsdoc.hidden\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case LENDS:\n                                 skipEOLs();\n                                 matchingRc \u003d false;\n                                 if (match(JsDocToken.LC)) {\n                                     token \u003d next();\n                                     matchingRc \u003d true;\n                                 }\n                                 if (match(JsDocToken.STRING)) {\n                                     token \u003d next();\n                                     if (!jsdocBuilder.recordLends(stream.getString())) {\n                                         parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 } else {\n                                     parser.addTypeWarning(\"msg.jsdoc.lends.missing\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 if (matchingRc \u0026\u0026 !match(JsDocToken.RC)) {\n                                     parser.addTypeWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case MEANING:\n                                 ExtractionInfo meaningInfo \u003d extractMultilineTextualBlock(token);\n                                 String meaning \u003d meaningInfo.string;\n                                 token \u003d meaningInfo.token;\n                                 if (!jsdocBuilder.recordMeaning(meaning)) {\n                                     parser.addParserWarning(\"msg.jsdoc.meaning.extra\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 continue retry;\n                             case NO_ALIAS:\n                                 if (!jsdocBuilder.recordNoAlias()) {\n                                     parser.addParserWarning(\"msg.jsdoc.noalias\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_COMPILE:\n                                 if (!jsdocBuilder.recordNoCompile()) {\n                                     parser.addParserWarning(\"msg.jsdoc.nocompile\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_TYPE_CHECK:\n                                 if (!jsdocBuilder.recordNoTypeCheck()) {\n                                     parser.addParserWarning(\"msg.jsdoc.nocheck\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NOT_IMPLEMENTED:\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case INHERIT_DOC:\n                             case OVERRIDE:\n                                 if (!jsdocBuilder.recordOverride()) {\n                                     parser.addTypeWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case THROWS:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                     if (type \u003d\u003d null) {\n                                         token \u003d eatTokensUntilEOL();\n                                         continue retry;\n                                     }\n                                 }\n                                 token \u003d current();\n                                 jsdocBuilder.recordThrowType(type);\n                                 if (jsdocBuilder.shouldParseDocumentation()) {\n                                     ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                     String description \u003d descriptionInfo.string;\n                                     if (description.length() \u003e 0) {\n                                         jsdocBuilder.recordThrowDescription(type, description);\n                                     }\n                                     token \u003d descriptionInfo.token;\n                                 } else {\n                                     token \u003d eatTokensUntilEOL(token);\n                                 }\n                                 continue retry;\n                             case PARAM:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordParamTypeNode(token));\n                                     if (type \u003d\u003d null) {\n                                         token \u003d eatTokensUntilEOL();\n                                         continue retry;\n                                     }\n                                     skipEOLs();\n                                     token \u003d next();\n                                     lineno \u003d stream.getLineno();\n                                     charno \u003d stream.getCharno();\n                                 }\n                                 String name \u003d null;\n                                 boolean isBracketedParam \u003d JsDocToken.LB \u003d\u003d token;\n                                 if (isBracketedParam) {\n                                     token \u003d next();\n                                 }\n                                 if (JsDocToken.STRING !\u003d token) {\n                                     parser.addTypeWarning(\"msg.missing.variable.name\", lineno, charno);\n                                 } else {\n                                     name \u003d stream.getString();\n                                     if (isBracketedParam) {\n                                         token \u003d next();\n                                         if (JsDocToken.EQUALS \u003d\u003d token) {\n                                             token \u003d next();\n                                             if (JsDocToken.STRING \u003d\u003d token) {\n                                                 token \u003d next();\n                                             }\n                                         }\n                                         if (JsDocToken.RB !\u003d token) {\n                                             reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                                         } else if (type !\u003d null) {\n                                             type \u003d JSTypeExpression.makeOptionalArg(type);\n                                         }\n                                     }\n                                     if (name.indexOf(\u0027.\u0027) \u003e -1) {\n                                         name \u003d null;\n                                     } else if (!jsdocBuilder.recordParameter(name, type)) {\n                                         if (jsdocBuilder.hasParameter(name)) {\n                                             parser.addTypeWarning(\"msg.dup.variable.name\", name, lineno, charno);\n                                         } else {\n                                             parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name, lineno, charno);\n                                         }\n                                     }\n                                 }\n                                 if (name \u003d\u003d null) {\n                                     token \u003d eatTokensUntilEOL(token);\n                                     continue retry;\n                                 }\n                                 jsdocBuilder.markName(name, lineno, charno);\n                                 if (jsdocBuilder.shouldParseDocumentation()) {\n                                     ExtractionInfo paramDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                     String paramDescription \u003d paramDescriptionInfo.string;\n                                     if (paramDescription.length() \u003e 0) {\n                                         jsdocBuilder.recordParameterDescription(name, paramDescription);\n                                     }\n                                     token \u003d paramDescriptionInfo.token;\n                                 } else {\n                                     token \u003d eatTokensUntilEOL(token);\n                                 }\n                                 continue retry;\n                             case PRESERVE_TRY:\n                                 if (!jsdocBuilder.recordPreserveTry()) {\n                                     parser.addParserWarning(\"msg.jsdoc.preservertry\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PRIVATE:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                                     parser.addParserWarning(\"msg.jsdoc.visibility.private\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PROTECTED:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                                     parser.addParserWarning(\"msg.jsdoc.visibility.protected\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PUBLIC:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                                     parser.addParserWarning(\"msg.jsdoc.visibility.public\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_SHADOW:\n                                 if (!jsdocBuilder.recordNoShadow()) {\n                                     parser.addParserWarning(\"msg.jsdoc.noshadow\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_SIDE_EFFECTS:\n                                 if (!jsdocBuilder.recordNoSideEffects()) {\n                                     parser.addParserWarning(\"msg.jsdoc.nosideeffects\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case MODIFIES:\n                                 token \u003d parseModifiesTag(next());\n                                 continue retry;\n                             case IMPLICIT_CAST:\n                                 if (!jsdocBuilder.recordImplicitCast()) {\n                                     parser.addTypeWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case SEE:\n                                 if (jsdocBuilder.shouldParseDocumentation()) {\n                                     ExtractionInfo referenceInfo \u003d extractSingleLineBlock();\n                                     String reference \u003d referenceInfo.string;\n                                     if (reference.length() \u003d\u003d 0) {\n                                         parser.addParserWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno());\n                                     } else {\n                                         jsdocBuilder.addReference(reference);\n                                     }\n                                     token \u003d referenceInfo.token;\n                                 } else {\n                                     token \u003d eatTokensUntilEOL(token);\n                                 }\n                                 continue retry;\n                             case SUPPRESS:\n                                 token \u003d parseSuppressTag(next());\n                                 continue retry;\n                             case TEMPLATE:\n                                 ExtractionInfo templateInfo \u003d extractSingleLineBlock();\n                                 String templateTypeName \u003d templateInfo.string;\n                                 if (templateTypeName.length() \u003d\u003d 0) {\n                                     parser.addTypeWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno());\n                                 } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {\n                                     parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d templateInfo.token;\n                                 continue retry;\n                             case VERSION:\n                                 ExtractionInfo versionInfo \u003d extractSingleLineBlock();\n                                 String version \u003d versionInfo.string;\n                                 if (version.length() \u003d\u003d 0) {\n                                     parser.addParserWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno());\n                                 } else {\n                                     if (!jsdocBuilder.recordVersion(version)) {\n                                         parser.addParserWarning(\"msg.jsdoc.extraversion\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d versionInfo.token;\n                                 continue retry;\n                             case DEFINE:\n                             case RETURN:\n                             case THIS:\n                             case TYPE:\n                             case TYPEDEF:\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 Node typeNode \u003d null;\n                                 if (!lookAheadForTypeAnnotation() \u0026\u0026 annotation \u003d\u003d Annotation.RETURN) {\n                                     typeNode \u003d newNode(Token.QMARK);\n                                 } else {\n                                     skipEOLs();\n                                     token \u003d next();\n                                     typeNode \u003d parseAndRecordTypeNode(token, lineno, charno);\n                                 }\n                                 if (annotation \u003d\u003d Annotation.THIS) {\n                                     typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                     if (typeNode !\u003d null \u0026\u0026 token !\u003d JsDocToken.LC) {\n                                         typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                     }\n                                 }\n                                 type \u003d createJSTypeExpression(typeNode);\n                                 if (type \u003d\u003d null) {\n                                 } else {\n                                     switch(annotation) {\n                                         case DEFINE:\n                                             if (!jsdocBuilder.recordDefineType(type)) {\n                                                 parser.addParserWarning(\"msg.jsdoc.define\", lineno, charno);\n                                             }\n                                             break;\n                                         case RETURN:\n                                             if (!jsdocBuilder.recordReturnType(type)) {\n                                                 parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                                 break;\n                                             }\n                                             if (jsdocBuilder.shouldParseDocumentation()) {\n                                                 ExtractionInfo returnDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                                 String returnDescription \u003d returnDescriptionInfo.string;\n                                                 if (returnDescription.length() \u003e 0) {\n                                                     jsdocBuilder.recordReturnDescription(returnDescription);\n                                                 }\n                                                 token \u003d returnDescriptionInfo.token;\n                                             } else {\n                                                 token \u003d eatTokensUntilEOL(token);\n                                             }\n                                             continue retry;\n                                         case THIS:\n                                             if (!jsdocBuilder.recordThisType(type)) {\n                                                 parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                         case TYPE:\n                                             if (!jsdocBuilder.recordType(type)) {\n                                                 parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                         case TYPEDEF:\n                                             if (!jsdocBuilder.recordTypedef(type)) {\n                                                 parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                     }\n                                     token \u003d eatTokensUntilEOL();\n                                 }\n                                 continue retry;\n                         }\n                     }\n                 }\n                 break;\n             case EOC:\n                 if (hasParsedFileOverviewDocInfo()) {\n                     fileOverviewJSDocInfo \u003d retrieveAndResetParsedJSDocInfo();\n                 }\n+                checkExtendedTypes(extendedTypes);\n                 return true;\n             case EOF:\n                 jsdocBuilder.build(null);\n                 parser.addParserWarning(\"msg.unexpected.eof\", stream.getLineno(), stream.getCharno());\n+                checkExtendedTypes(extendedTypes);\n                 return false;\n             case EOL:\n                 if (state \u003d\u003d State.SEARCHING_NEWLINE) {\n                     state \u003d State.SEARCHING_ANNOTATION;\n                 }\n                 token \u003d next();\n                 continue retry;\n             default:\n                 if (token \u003d\u003d JsDocToken.STAR \u0026\u0026 state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                     token \u003d next();\n                     continue retry;\n                 } else {\n                     state \u003d State.SEARCHING_NEWLINE;\n                     token \u003d eatTokensUntilEOL();\n                     continue retry;\n                 }\n         }\n         token \u003d next();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4fe0dd22b4462cbd3943f3a8d77db8136ff4d9b7": {
      "type": "Ybodychange",
      "commitMessage": "\nDon\u0027t eat the first token of the @return description.\nThis is kind of a hack because it mixes the character stream up\nwith the token stream, but it\u0027s probably more maintainable\nand has less overhead than trying to manage the description\nin the token stream\n(which is the \"pure-but-lots-of-work\" solution).\n\nR\u003djschorr\nDELTA\u003d58  (48 added, 7 deleted, 3 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d1178\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@954 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "3/30/11, 10:44 AM",
      "commitName": "4fe0dd22b4462cbd3943f3a8d77db8136ff4d9b7",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "3/14/11, 1:14 PM",
      "commitNameOld": "9b04e62d89c89cfa636ae803e210ddbeb007a626",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 15.9,
      "commitsBetweenForRepo": 62,
      "commitsBetweenForFile": 1,
      "actualSource": "boolean parse() {\n    int lineno;\n    int charno;\n    JSTypeExpression type;\n    state \u003d State.SEARCHING_ANNOTATION;\n    skipEOLs();\n    JsDocToken token \u003d next();\n    if (jsdocBuilder.shouldParseDocumentation()) {\n        ExtractionInfo blockInfo \u003d extractBlockComment(token);\n        token \u003d blockInfo.token;\n        if (!blockInfo.string.isEmpty()) {\n            jsdocBuilder.recordBlockDescription(blockInfo.string);\n        }\n    } else {\n        if (token !\u003d JsDocToken.ANNOTATION \u0026\u0026 token !\u003d JsDocToken.EOC) {\n            jsdocBuilder.recordBlockDescription(\"\");\n        }\n    }\n    retry: for (; ; ) {\n        switch(token) {\n            case ANNOTATION:\n                if (state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                    state \u003d State.SEARCHING_NEWLINE;\n                    lineno \u003d stream.getLineno();\n                    charno \u003d stream.getCharno();\n                    String annotationName \u003d stream.getString();\n                    Annotation annotation \u003d annotationNames.get(annotationName);\n                    if (annotation \u003d\u003d null) {\n                        parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno());\n                    } else {\n                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n                        switch(annotation) {\n                            case AUTHOR:\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo authorInfo \u003d extractSingleLineBlock();\n                                    String author \u003d authorInfo.string;\n                                    if (author.length() \u003d\u003d 0) {\n                                        parser.addParserWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        jsdocBuilder.addAuthor(author);\n                                    }\n                                    token \u003d authorInfo.token;\n                                } else {\n                                    token \u003d eatTokensUntilEOL(token);\n                                }\n                                continue retry;\n                            case CONSTANT:\n                                if (!jsdocBuilder.recordConstancy()) {\n                                    parser.addParserWarning(\"msg.jsdoc.const\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case CONSTRUCTOR:\n                                if (!jsdocBuilder.recordConstructor()) {\n                                    if (jsdocBuilder.isInterfaceRecorded()) {\n                                        parser.addTypeWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        parser.addTypeWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case DEPRECATED:\n                                if (!jsdocBuilder.recordDeprecated()) {\n                                    parser.addParserWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno());\n                                }\n                                ExtractionInfo reasonInfo \u003d extractMultilineTextualBlock(token);\n                                String reason \u003d reasonInfo.string;\n                                if (reason.length() \u003e 0) {\n                                    jsdocBuilder.recordDeprecationReason(reason);\n                                }\n                                token \u003d reasonInfo.token;\n                                continue retry;\n                            case INTERFACE:\n                                if (!jsdocBuilder.recordInterface()) {\n                                    if (jsdocBuilder.isConstructorRecorded()) {\n                                        parser.addTypeWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        parser.addTypeWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case DESC:\n                                if (jsdocBuilder.isDescriptionRecorded()) {\n                                    parser.addParserWarning(\"msg.jsdoc.desc.extra\", stream.getLineno(), stream.getCharno());\n                                    token \u003d eatTokensUntilEOL();\n                                    continue retry;\n                                } else {\n                                    ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                    String description \u003d descriptionInfo.string;\n                                    jsdocBuilder.recordDescription(description);\n                                    token \u003d descriptionInfo.token;\n                                    continue retry;\n                                }\n                            case FILE_OVERVIEW:\n                                String fileOverview \u003d \"\";\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo fileOverviewInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.TRIM);\n                                    fileOverview \u003d fileOverviewInfo.string;\n                                    token \u003d fileOverviewInfo.token;\n                                } else {\n                                    token \u003d eatTokensUntilEOL(token);\n                                }\n                                if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo !\u003d null) {\n                                    parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno());\n                                }\n                                continue retry;\n                            case LICENSE:\n                            case PRESERVE:\n                                ExtractionInfo preserveInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);\n                                String preserve \u003d preserveInfo.string;\n                                if (preserve.length() \u003e 0) {\n                                    if (fileLevelJsDocBuilder !\u003d null) {\n                                        fileLevelJsDocBuilder.append(preserve);\n                                    }\n                                }\n                                token \u003d preserveInfo.token;\n                                continue retry;\n                            case ENUM:\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                }\n                                if (type \u003d\u003d null) {\n                                    type \u003d createJSTypeExpression(newStringNode(\"number\"));\n                                }\n                                if (!jsdocBuilder.recordEnumParameterType(type)) {\n                                    parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                }\n                                token \u003d eatTokensUntilEOL(token);\n                                continue retry;\n                            case EXPORT:\n                                if (!jsdocBuilder.recordExport()) {\n                                    parser.addParserWarning(\"msg.jsdoc.export\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case EXTERNS:\n                                if (!jsdocBuilder.recordExterns()) {\n                                    parser.addParserWarning(\"msg.jsdoc.externs\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case JAVA_DISPATCH:\n                                if (!jsdocBuilder.recordJavaDispatch()) {\n                                    parser.addParserWarning(\"msg.jsdoc.javadispatch\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case EXTENDS:\n                            case IMPLEMENTS:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                boolean matchingRc \u003d false;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    token \u003d next();\n                                    matchingRc \u003d true;\n                                }\n                                if (token \u003d\u003d JsDocToken.STRING) {\n                                    Node typeNode \u003d parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);\n                                    lineno \u003d stream.getLineno();\n                                    charno \u003d stream.getCharno();\n                                    typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                    if (typeNode !\u003d null \u0026\u0026 !matchingRc) {\n                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                    }\n                                    type \u003d createJSTypeExpression(typeNode);\n                                    if (annotation \u003d\u003d Annotation.EXTENDS) {\n                                        if (!jsdocBuilder.recordBaseType(type)) {\n                                            parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                        }\n                                    } else {\n                                        Preconditions.checkState(annotation \u003d\u003d Annotation.IMPLEMENTS);\n                                        if (!jsdocBuilder.recordImplementedInterface(type)) {\n                                            parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\", lineno, charno);\n                                        }\n                                    }\n                                    token \u003d next();\n                                    if (matchingRc) {\n                                        if (token !\u003d JsDocToken.RC) {\n                                            parser.addTypeWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                        }\n                                    } else if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOF \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                        parser.addTypeWarning(\"msg.end.annotation.expected\", stream.getLineno(), stream.getCharno());\n                                    }\n                                } else {\n                                    parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);\n                                }\n                                token \u003d eatTokensUntilEOL(token);\n                                continue retry;\n                            case HIDDEN:\n                                if (!jsdocBuilder.recordHiddenness()) {\n                                    parser.addParserWarning(\"msg.jsdoc.hidden\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case LENDS:\n                                skipEOLs();\n                                matchingRc \u003d false;\n                                if (match(JsDocToken.LC)) {\n                                    token \u003d next();\n                                    matchingRc \u003d true;\n                                }\n                                if (match(JsDocToken.STRING)) {\n                                    token \u003d next();\n                                    if (!jsdocBuilder.recordLends(stream.getString())) {\n                                        parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\", stream.getLineno(), stream.getCharno());\n                                    }\n                                } else {\n                                    parser.addTypeWarning(\"msg.jsdoc.lends.missing\", stream.getLineno(), stream.getCharno());\n                                }\n                                if (matchingRc \u0026\u0026 !match(JsDocToken.RC)) {\n                                    parser.addTypeWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case MEANING:\n                                ExtractionInfo meaningInfo \u003d extractMultilineTextualBlock(token);\n                                String meaning \u003d meaningInfo.string;\n                                token \u003d meaningInfo.token;\n                                if (!jsdocBuilder.recordMeaning(meaning)) {\n                                    parser.addParserWarning(\"msg.jsdoc.meaning.extra\", stream.getLineno(), stream.getCharno());\n                                }\n                                continue retry;\n                            case NO_ALIAS:\n                                if (!jsdocBuilder.recordNoAlias()) {\n                                    parser.addParserWarning(\"msg.jsdoc.noalias\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_COMPILE:\n                                if (!jsdocBuilder.recordNoCompile()) {\n                                    parser.addParserWarning(\"msg.jsdoc.nocompile\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_TYPE_CHECK:\n                                if (!jsdocBuilder.recordNoTypeCheck()) {\n                                    parser.addParserWarning(\"msg.jsdoc.nocheck\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NOT_IMPLEMENTED:\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case INHERIT_DOC:\n                            case OVERRIDE:\n                                if (!jsdocBuilder.recordOverride()) {\n                                    parser.addTypeWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case THROWS:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                    if (type \u003d\u003d null) {\n                                        token \u003d eatTokensUntilEOL();\n                                        continue retry;\n                                    }\n                                }\n                                token \u003d current();\n                                jsdocBuilder.recordThrowType(type);\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                    String description \u003d descriptionInfo.string;\n                                    if (description.length() \u003e 0) {\n                                        jsdocBuilder.recordThrowDescription(type, description);\n                                    }\n                                    token \u003d descriptionInfo.token;\n                                } else {\n                                    token \u003d eatTokensUntilEOL(token);\n                                }\n                                continue retry;\n                            case PARAM:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordParamTypeNode(token));\n                                    if (type \u003d\u003d null) {\n                                        token \u003d eatTokensUntilEOL();\n                                        continue retry;\n                                    }\n                                    skipEOLs();\n                                    token \u003d next();\n                                    lineno \u003d stream.getLineno();\n                                    charno \u003d stream.getCharno();\n                                }\n                                String name \u003d null;\n                                boolean isBracketedParam \u003d JsDocToken.LB \u003d\u003d token;\n                                if (isBracketedParam) {\n                                    token \u003d next();\n                                }\n                                if (JsDocToken.STRING !\u003d token) {\n                                    parser.addTypeWarning(\"msg.missing.variable.name\", lineno, charno);\n                                } else {\n                                    name \u003d stream.getString();\n                                    if (isBracketedParam) {\n                                        token \u003d next();\n                                        if (JsDocToken.EQUALS \u003d\u003d token) {\n                                            token \u003d next();\n                                            if (JsDocToken.STRING \u003d\u003d token) {\n                                                token \u003d next();\n                                            }\n                                        }\n                                        if (JsDocToken.RB !\u003d token) {\n                                            reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                                        } else if (type !\u003d null) {\n                                            type \u003d JSTypeExpression.makeOptionalArg(type);\n                                        }\n                                    }\n                                    if (name.indexOf(\u0027.\u0027) \u003e -1) {\n                                        name \u003d null;\n                                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                                        if (jsdocBuilder.hasParameter(name)) {\n                                            parser.addTypeWarning(\"msg.dup.variable.name\", name, lineno, charno);\n                                        } else {\n                                            parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name, lineno, charno);\n                                        }\n                                    }\n                                }\n                                if (name \u003d\u003d null) {\n                                    token \u003d eatTokensUntilEOL(token);\n                                    continue retry;\n                                }\n                                jsdocBuilder.markName(name, lineno, charno);\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo paramDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                    String paramDescription \u003d paramDescriptionInfo.string;\n                                    if (paramDescription.length() \u003e 0) {\n                                        jsdocBuilder.recordParameterDescription(name, paramDescription);\n                                    }\n                                    token \u003d paramDescriptionInfo.token;\n                                } else {\n                                    token \u003d eatTokensUntilEOL(token);\n                                }\n                                continue retry;\n                            case PRESERVE_TRY:\n                                if (!jsdocBuilder.recordPreserveTry()) {\n                                    parser.addParserWarning(\"msg.jsdoc.preservertry\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PRIVATE:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                                    parser.addParserWarning(\"msg.jsdoc.visibility.private\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PROTECTED:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                                    parser.addParserWarning(\"msg.jsdoc.visibility.protected\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PUBLIC:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                                    parser.addParserWarning(\"msg.jsdoc.visibility.public\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_SHADOW:\n                                if (!jsdocBuilder.recordNoShadow()) {\n                                    parser.addParserWarning(\"msg.jsdoc.noshadow\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_SIDE_EFFECTS:\n                                if (!jsdocBuilder.recordNoSideEffects()) {\n                                    parser.addParserWarning(\"msg.jsdoc.nosideeffects\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case MODIFIES:\n                                token \u003d parseModifiesTag(next());\n                                continue retry;\n                            case IMPLICIT_CAST:\n                                if (!jsdocBuilder.recordImplicitCast()) {\n                                    parser.addTypeWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case SEE:\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo referenceInfo \u003d extractSingleLineBlock();\n                                    String reference \u003d referenceInfo.string;\n                                    if (reference.length() \u003d\u003d 0) {\n                                        parser.addParserWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        jsdocBuilder.addReference(reference);\n                                    }\n                                    token \u003d referenceInfo.token;\n                                } else {\n                                    token \u003d eatTokensUntilEOL(token);\n                                }\n                                continue retry;\n                            case SUPPRESS:\n                                token \u003d parseSuppressTag(next());\n                                continue retry;\n                            case TEMPLATE:\n                                ExtractionInfo templateInfo \u003d extractSingleLineBlock();\n                                String templateTypeName \u003d templateInfo.string;\n                                if (templateTypeName.length() \u003d\u003d 0) {\n                                    parser.addTypeWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno());\n                                } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {\n                                    parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d templateInfo.token;\n                                continue retry;\n                            case VERSION:\n                                ExtractionInfo versionInfo \u003d extractSingleLineBlock();\n                                String version \u003d versionInfo.string;\n                                if (version.length() \u003d\u003d 0) {\n                                    parser.addParserWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno());\n                                } else {\n                                    if (!jsdocBuilder.recordVersion(version)) {\n                                        parser.addParserWarning(\"msg.jsdoc.extraversion\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d versionInfo.token;\n                                continue retry;\n                            case DEFINE:\n                            case RETURN:\n                            case THIS:\n                            case TYPE:\n                            case TYPEDEF:\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                Node typeNode \u003d null;\n                                if (!lookAheadForTypeAnnotation() \u0026\u0026 annotation \u003d\u003d Annotation.RETURN) {\n                                    typeNode \u003d newNode(Token.QMARK);\n                                } else {\n                                    skipEOLs();\n                                    token \u003d next();\n                                    typeNode \u003d parseAndRecordTypeNode(token, lineno, charno);\n                                }\n                                if (annotation \u003d\u003d Annotation.THIS) {\n                                    typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                    if (typeNode !\u003d null \u0026\u0026 token !\u003d JsDocToken.LC) {\n                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                    }\n                                }\n                                type \u003d createJSTypeExpression(typeNode);\n                                if (type \u003d\u003d null) {\n                                } else {\n                                    switch(annotation) {\n                                        case DEFINE:\n                                            if (!jsdocBuilder.recordDefineType(type)) {\n                                                parser.addParserWarning(\"msg.jsdoc.define\", lineno, charno);\n                                            }\n                                            break;\n                                        case RETURN:\n                                            if (!jsdocBuilder.recordReturnType(type)) {\n                                                parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                                break;\n                                            }\n                                            if (jsdocBuilder.shouldParseDocumentation()) {\n                                                ExtractionInfo returnDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                                String returnDescription \u003d returnDescriptionInfo.string;\n                                                if (returnDescription.length() \u003e 0) {\n                                                    jsdocBuilder.recordReturnDescription(returnDescription);\n                                                }\n                                                token \u003d returnDescriptionInfo.token;\n                                            } else {\n                                                token \u003d eatTokensUntilEOL(token);\n                                            }\n                                            continue retry;\n                                        case THIS:\n                                            if (!jsdocBuilder.recordThisType(type)) {\n                                                parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                        case TYPE:\n                                            if (!jsdocBuilder.recordType(type)) {\n                                                parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                        case TYPEDEF:\n                                            if (!jsdocBuilder.recordTypedef(type)) {\n                                                parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                    }\n                                    token \u003d eatTokensUntilEOL();\n                                }\n                                continue retry;\n                        }\n                    }\n                }\n                break;\n            case EOC:\n                if (hasParsedFileOverviewDocInfo()) {\n                    fileOverviewJSDocInfo \u003d retrieveAndResetParsedJSDocInfo();\n                }\n                return true;\n            case EOF:\n                jsdocBuilder.build(null);\n                parser.addParserWarning(\"msg.unexpected.eof\", stream.getLineno(), stream.getCharno());\n                return false;\n            case EOL:\n                if (state \u003d\u003d State.SEARCHING_NEWLINE) {\n                    state \u003d State.SEARCHING_ANNOTATION;\n                }\n                token \u003d next();\n                continue retry;\n            default:\n                if (token \u003d\u003d JsDocToken.STAR \u0026\u0026 state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                    token \u003d next();\n                    continue retry;\n                } else {\n                    state \u003d State.SEARCHING_NEWLINE;\n                    token \u003d eatTokensUntilEOL();\n                    continue retry;\n                }\n        }\n        token \u003d next();\n    }\n}",
      "path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
      "functionStartLine": 167,
      "functionName": "parse",
      "functionAnnotation": "",
      "functionDoc": "Parses a {@link JSDocInfo} object. This parsing method reads all tokens\nreturned by the {@link JsDocTokenStream#getJsDocToken()} method until the\n{@link JsDocToken#EOC} is returned.\n\n@return @code true} if JSDoc information was correctly parsed,\n    {@code false} otherwise\n",
      "diff": "@@ -1,532 +1,531 @@\n boolean parse() {\n     int lineno;\n     int charno;\n     JSTypeExpression type;\n     state \u003d State.SEARCHING_ANNOTATION;\n     skipEOLs();\n     JsDocToken token \u003d next();\n     if (jsdocBuilder.shouldParseDocumentation()) {\n         ExtractionInfo blockInfo \u003d extractBlockComment(token);\n         token \u003d blockInfo.token;\n         if (!blockInfo.string.isEmpty()) {\n             jsdocBuilder.recordBlockDescription(blockInfo.string);\n         }\n     } else {\n         if (token !\u003d JsDocToken.ANNOTATION \u0026\u0026 token !\u003d JsDocToken.EOC) {\n             jsdocBuilder.recordBlockDescription(\"\");\n         }\n     }\n     retry: for (; ; ) {\n         switch(token) {\n             case ANNOTATION:\n                 if (state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                     state \u003d State.SEARCHING_NEWLINE;\n                     lineno \u003d stream.getLineno();\n                     charno \u003d stream.getCharno();\n                     String annotationName \u003d stream.getString();\n                     Annotation annotation \u003d annotationNames.get(annotationName);\n                     if (annotation \u003d\u003d null) {\n                         parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno());\n                     } else {\n                         jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n                         switch(annotation) {\n                             case AUTHOR:\n                                 if (jsdocBuilder.shouldParseDocumentation()) {\n                                     ExtractionInfo authorInfo \u003d extractSingleLineBlock();\n                                     String author \u003d authorInfo.string;\n                                     if (author.length() \u003d\u003d 0) {\n                                         parser.addParserWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno());\n                                     } else {\n                                         jsdocBuilder.addAuthor(author);\n                                     }\n                                     token \u003d authorInfo.token;\n                                 } else {\n                                     token \u003d eatTokensUntilEOL(token);\n                                 }\n                                 continue retry;\n                             case CONSTANT:\n                                 if (!jsdocBuilder.recordConstancy()) {\n                                     parser.addParserWarning(\"msg.jsdoc.const\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case CONSTRUCTOR:\n                                 if (!jsdocBuilder.recordConstructor()) {\n                                     if (jsdocBuilder.isInterfaceRecorded()) {\n                                         parser.addTypeWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                     } else {\n                                         parser.addTypeWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case DEPRECATED:\n                                 if (!jsdocBuilder.recordDeprecated()) {\n                                     parser.addParserWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 ExtractionInfo reasonInfo \u003d extractMultilineTextualBlock(token);\n                                 String reason \u003d reasonInfo.string;\n                                 if (reason.length() \u003e 0) {\n                                     jsdocBuilder.recordDeprecationReason(reason);\n                                 }\n                                 token \u003d reasonInfo.token;\n                                 continue retry;\n                             case INTERFACE:\n                                 if (!jsdocBuilder.recordInterface()) {\n                                     if (jsdocBuilder.isConstructorRecorded()) {\n                                         parser.addTypeWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                     } else {\n                                         parser.addTypeWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case DESC:\n                                 if (jsdocBuilder.isDescriptionRecorded()) {\n                                     parser.addParserWarning(\"msg.jsdoc.desc.extra\", stream.getLineno(), stream.getCharno());\n                                     token \u003d eatTokensUntilEOL();\n                                     continue retry;\n                                 } else {\n                                     ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                     String description \u003d descriptionInfo.string;\n                                     jsdocBuilder.recordDescription(description);\n                                     token \u003d descriptionInfo.token;\n                                     continue retry;\n                                 }\n                             case FILE_OVERVIEW:\n                                 String fileOverview \u003d \"\";\n                                 if (jsdocBuilder.shouldParseDocumentation()) {\n                                     ExtractionInfo fileOverviewInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.TRIM);\n                                     fileOverview \u003d fileOverviewInfo.string;\n                                     token \u003d fileOverviewInfo.token;\n                                 } else {\n                                     token \u003d eatTokensUntilEOL(token);\n                                 }\n                                 if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo !\u003d null) {\n                                     parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 continue retry;\n                             case LICENSE:\n                             case PRESERVE:\n                                 ExtractionInfo preserveInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);\n                                 String preserve \u003d preserveInfo.string;\n                                 if (preserve.length() \u003e 0) {\n                                     if (fileLevelJsDocBuilder !\u003d null) {\n                                         fileLevelJsDocBuilder.append(preserve);\n                                     }\n                                 }\n                                 token \u003d preserveInfo.token;\n                                 continue retry;\n                             case ENUM:\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                 }\n                                 if (type \u003d\u003d null) {\n                                     type \u003d createJSTypeExpression(newStringNode(\"number\"));\n                                 }\n                                 if (!jsdocBuilder.recordEnumParameterType(type)) {\n                                     parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                 }\n                                 token \u003d eatTokensUntilEOL(token);\n                                 continue retry;\n                             case EXPORT:\n                                 if (!jsdocBuilder.recordExport()) {\n                                     parser.addParserWarning(\"msg.jsdoc.export\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case EXTERNS:\n                                 if (!jsdocBuilder.recordExterns()) {\n                                     parser.addParserWarning(\"msg.jsdoc.externs\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case JAVA_DISPATCH:\n                                 if (!jsdocBuilder.recordJavaDispatch()) {\n                                     parser.addParserWarning(\"msg.jsdoc.javadispatch\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case EXTENDS:\n                             case IMPLEMENTS:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 boolean matchingRc \u003d false;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     token \u003d next();\n                                     matchingRc \u003d true;\n                                 }\n                                 if (token \u003d\u003d JsDocToken.STRING) {\n                                     Node typeNode \u003d parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);\n                                     lineno \u003d stream.getLineno();\n                                     charno \u003d stream.getCharno();\n                                     typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                     if (typeNode !\u003d null \u0026\u0026 !matchingRc) {\n                                         typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                     }\n                                     type \u003d createJSTypeExpression(typeNode);\n                                     if (annotation \u003d\u003d Annotation.EXTENDS) {\n                                         if (!jsdocBuilder.recordBaseType(type)) {\n                                             parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                         }\n                                     } else {\n                                         Preconditions.checkState(annotation \u003d\u003d Annotation.IMPLEMENTS);\n                                         if (!jsdocBuilder.recordImplementedInterface(type)) {\n                                             parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\", lineno, charno);\n                                         }\n                                     }\n                                     token \u003d next();\n                                     if (matchingRc) {\n                                         if (token !\u003d JsDocToken.RC) {\n                                             parser.addTypeWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                         }\n                                     } else if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOF \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                         parser.addTypeWarning(\"msg.end.annotation.expected\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 } else {\n                                     parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);\n                                 }\n                                 token \u003d eatTokensUntilEOL(token);\n                                 continue retry;\n                             case HIDDEN:\n                                 if (!jsdocBuilder.recordHiddenness()) {\n                                     parser.addParserWarning(\"msg.jsdoc.hidden\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case LENDS:\n                                 skipEOLs();\n                                 matchingRc \u003d false;\n                                 if (match(JsDocToken.LC)) {\n                                     token \u003d next();\n                                     matchingRc \u003d true;\n                                 }\n                                 if (match(JsDocToken.STRING)) {\n                                     token \u003d next();\n                                     if (!jsdocBuilder.recordLends(stream.getString())) {\n                                         parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 } else {\n                                     parser.addTypeWarning(\"msg.jsdoc.lends.missing\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 if (matchingRc \u0026\u0026 !match(JsDocToken.RC)) {\n                                     parser.addTypeWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case MEANING:\n                                 ExtractionInfo meaningInfo \u003d extractMultilineTextualBlock(token);\n                                 String meaning \u003d meaningInfo.string;\n                                 token \u003d meaningInfo.token;\n                                 if (!jsdocBuilder.recordMeaning(meaning)) {\n                                     parser.addParserWarning(\"msg.jsdoc.meaning.extra\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 continue retry;\n                             case NO_ALIAS:\n                                 if (!jsdocBuilder.recordNoAlias()) {\n                                     parser.addParserWarning(\"msg.jsdoc.noalias\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_COMPILE:\n                                 if (!jsdocBuilder.recordNoCompile()) {\n                                     parser.addParserWarning(\"msg.jsdoc.nocompile\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_TYPE_CHECK:\n                                 if (!jsdocBuilder.recordNoTypeCheck()) {\n                                     parser.addParserWarning(\"msg.jsdoc.nocheck\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NOT_IMPLEMENTED:\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case INHERIT_DOC:\n                             case OVERRIDE:\n                                 if (!jsdocBuilder.recordOverride()) {\n                                     parser.addTypeWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case THROWS:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                     if (type \u003d\u003d null) {\n                                         token \u003d eatTokensUntilEOL();\n                                         continue retry;\n                                     }\n                                 }\n                                 token \u003d current();\n                                 jsdocBuilder.recordThrowType(type);\n                                 if (jsdocBuilder.shouldParseDocumentation()) {\n                                     ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                     String description \u003d descriptionInfo.string;\n                                     if (description.length() \u003e 0) {\n                                         jsdocBuilder.recordThrowDescription(type, description);\n                                     }\n                                     token \u003d descriptionInfo.token;\n                                 } else {\n                                     token \u003d eatTokensUntilEOL(token);\n                                 }\n                                 continue retry;\n                             case PARAM:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordParamTypeNode(token));\n                                     if (type \u003d\u003d null) {\n                                         token \u003d eatTokensUntilEOL();\n                                         continue retry;\n                                     }\n                                     skipEOLs();\n                                     token \u003d next();\n                                     lineno \u003d stream.getLineno();\n                                     charno \u003d stream.getCharno();\n                                 }\n                                 String name \u003d null;\n                                 boolean isBracketedParam \u003d JsDocToken.LB \u003d\u003d token;\n                                 if (isBracketedParam) {\n                                     token \u003d next();\n                                 }\n                                 if (JsDocToken.STRING !\u003d token) {\n                                     parser.addTypeWarning(\"msg.missing.variable.name\", lineno, charno);\n                                 } else {\n                                     name \u003d stream.getString();\n                                     if (isBracketedParam) {\n                                         token \u003d next();\n                                         if (JsDocToken.EQUALS \u003d\u003d token) {\n                                             token \u003d next();\n                                             if (JsDocToken.STRING \u003d\u003d token) {\n                                                 token \u003d next();\n                                             }\n                                         }\n                                         if (JsDocToken.RB !\u003d token) {\n                                             reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                                         } else if (type !\u003d null) {\n                                             type \u003d JSTypeExpression.makeOptionalArg(type);\n                                         }\n                                     }\n                                     if (name.indexOf(\u0027.\u0027) \u003e -1) {\n                                         name \u003d null;\n                                     } else if (!jsdocBuilder.recordParameter(name, type)) {\n                                         if (jsdocBuilder.hasParameter(name)) {\n                                             parser.addTypeWarning(\"msg.dup.variable.name\", name, lineno, charno);\n                                         } else {\n                                             parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name, lineno, charno);\n                                         }\n                                     }\n                                 }\n                                 if (name \u003d\u003d null) {\n                                     token \u003d eatTokensUntilEOL(token);\n                                     continue retry;\n                                 }\n                                 jsdocBuilder.markName(name, lineno, charno);\n                                 if (jsdocBuilder.shouldParseDocumentation()) {\n                                     ExtractionInfo paramDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                     String paramDescription \u003d paramDescriptionInfo.string;\n                                     if (paramDescription.length() \u003e 0) {\n                                         jsdocBuilder.recordParameterDescription(name, paramDescription);\n                                     }\n                                     token \u003d paramDescriptionInfo.token;\n                                 } else {\n                                     token \u003d eatTokensUntilEOL(token);\n                                 }\n                                 continue retry;\n                             case PRESERVE_TRY:\n                                 if (!jsdocBuilder.recordPreserveTry()) {\n                                     parser.addParserWarning(\"msg.jsdoc.preservertry\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PRIVATE:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                                     parser.addParserWarning(\"msg.jsdoc.visibility.private\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PROTECTED:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                                     parser.addParserWarning(\"msg.jsdoc.visibility.protected\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PUBLIC:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                                     parser.addParserWarning(\"msg.jsdoc.visibility.public\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_SHADOW:\n                                 if (!jsdocBuilder.recordNoShadow()) {\n                                     parser.addParserWarning(\"msg.jsdoc.noshadow\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_SIDE_EFFECTS:\n                                 if (!jsdocBuilder.recordNoSideEffects()) {\n                                     parser.addParserWarning(\"msg.jsdoc.nosideeffects\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case MODIFIES:\n                                 token \u003d parseModifiesTag(next());\n                                 continue retry;\n                             case IMPLICIT_CAST:\n                                 if (!jsdocBuilder.recordImplicitCast()) {\n                                     parser.addTypeWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case SEE:\n                                 if (jsdocBuilder.shouldParseDocumentation()) {\n                                     ExtractionInfo referenceInfo \u003d extractSingleLineBlock();\n                                     String reference \u003d referenceInfo.string;\n                                     if (reference.length() \u003d\u003d 0) {\n                                         parser.addParserWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno());\n                                     } else {\n                                         jsdocBuilder.addReference(reference);\n                                     }\n                                     token \u003d referenceInfo.token;\n                                 } else {\n                                     token \u003d eatTokensUntilEOL(token);\n                                 }\n                                 continue retry;\n                             case SUPPRESS:\n                                 token \u003d parseSuppressTag(next());\n                                 continue retry;\n                             case TEMPLATE:\n                                 ExtractionInfo templateInfo \u003d extractSingleLineBlock();\n                                 String templateTypeName \u003d templateInfo.string;\n                                 if (templateTypeName.length() \u003d\u003d 0) {\n                                     parser.addTypeWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno());\n                                 } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {\n                                     parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d templateInfo.token;\n                                 continue retry;\n                             case VERSION:\n                                 ExtractionInfo versionInfo \u003d extractSingleLineBlock();\n                                 String version \u003d versionInfo.string;\n                                 if (version.length() \u003d\u003d 0) {\n                                     parser.addParserWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno());\n                                 } else {\n                                     if (!jsdocBuilder.recordVersion(version)) {\n                                         parser.addParserWarning(\"msg.jsdoc.extraversion\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d versionInfo.token;\n                                 continue retry;\n                             case DEFINE:\n                             case RETURN:\n                             case THIS:\n                             case TYPE:\n                             case TYPEDEF:\n-                                skipEOLs();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n-                                token \u003d next();\n                                 Node typeNode \u003d null;\n-                                if (annotation \u003d\u003d Annotation.RETURN \u0026\u0026 token !\u003d JsDocToken.LC) {\n+                                if (!lookAheadForTypeAnnotation() \u0026\u0026 annotation \u003d\u003d Annotation.RETURN) {\n                                     typeNode \u003d newNode(Token.QMARK);\n                                 } else {\n+                                    skipEOLs();\n+                                    token \u003d next();\n                                     typeNode \u003d parseAndRecordTypeNode(token, lineno, charno);\n                                 }\n                                 if (annotation \u003d\u003d Annotation.THIS) {\n                                     typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                     if (typeNode !\u003d null \u0026\u0026 token !\u003d JsDocToken.LC) {\n                                         typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                     }\n                                 }\n                                 type \u003d createJSTypeExpression(typeNode);\n                                 if (type \u003d\u003d null) {\n                                 } else {\n                                     switch(annotation) {\n                                         case DEFINE:\n                                             if (!jsdocBuilder.recordDefineType(type)) {\n                                                 parser.addParserWarning(\"msg.jsdoc.define\", lineno, charno);\n                                             }\n                                             break;\n                                         case RETURN:\n                                             if (!jsdocBuilder.recordReturnType(type)) {\n                                                 parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                                 break;\n                                             }\n-                                            token \u003d current();\n                                             if (jsdocBuilder.shouldParseDocumentation()) {\n                                                 ExtractionInfo returnDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                                 String returnDescription \u003d returnDescriptionInfo.string;\n                                                 if (returnDescription.length() \u003e 0) {\n                                                     jsdocBuilder.recordReturnDescription(returnDescription);\n                                                 }\n                                                 token \u003d returnDescriptionInfo.token;\n                                             } else {\n                                                 token \u003d eatTokensUntilEOL(token);\n                                             }\n                                             continue retry;\n                                         case THIS:\n                                             if (!jsdocBuilder.recordThisType(type)) {\n                                                 parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                         case TYPE:\n                                             if (!jsdocBuilder.recordType(type)) {\n                                                 parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                         case TYPEDEF:\n                                             if (!jsdocBuilder.recordTypedef(type)) {\n                                                 parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                     }\n                                     token \u003d eatTokensUntilEOL();\n                                 }\n                                 continue retry;\n                         }\n                     }\n                 }\n                 break;\n             case EOC:\n                 if (hasParsedFileOverviewDocInfo()) {\n                     fileOverviewJSDocInfo \u003d retrieveAndResetParsedJSDocInfo();\n                 }\n                 return true;\n             case EOF:\n                 jsdocBuilder.build(null);\n                 parser.addParserWarning(\"msg.unexpected.eof\", stream.getLineno(), stream.getCharno());\n                 return false;\n             case EOL:\n                 if (state \u003d\u003d State.SEARCHING_NEWLINE) {\n                     state \u003d State.SEARCHING_ANNOTATION;\n                 }\n                 token \u003d next();\n                 continue retry;\n             default:\n                 if (token \u003d\u003d JsDocToken.STAR \u0026\u0026 state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                     token \u003d next();\n                     continue retry;\n                 } else {\n                     state \u003d State.SEARCHING_NEWLINE;\n                     token \u003d eatTokensUntilEOL();\n                     continue retry;\n                 }\n         }\n         token \u003d next();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9b04e62d89c89cfa636ae803e210ddbeb007a626": {
      "type": "Ybodychange",
      "commitMessage": "\n@return should only treat stuff in {} as type annotations\n\nR\u003dacleung\nDELTA\u003d118  (28 added, 2 deleted, 88 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d856\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@884 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "3/14/11, 1:14 PM",
      "commitName": "9b04e62d89c89cfa636ae803e210ddbeb007a626",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "3/7/11, 12:59 PM",
      "commitNameOld": "5709ec1d0bbe5b7726a14d06f7eab9c35150e314",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 6.97,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "actualSource": "boolean parse() {\n    int lineno;\n    int charno;\n    JSTypeExpression type;\n    state \u003d State.SEARCHING_ANNOTATION;\n    skipEOLs();\n    JsDocToken token \u003d next();\n    if (jsdocBuilder.shouldParseDocumentation()) {\n        ExtractionInfo blockInfo \u003d extractBlockComment(token);\n        token \u003d blockInfo.token;\n        if (!blockInfo.string.isEmpty()) {\n            jsdocBuilder.recordBlockDescription(blockInfo.string);\n        }\n    } else {\n        if (token !\u003d JsDocToken.ANNOTATION \u0026\u0026 token !\u003d JsDocToken.EOC) {\n            jsdocBuilder.recordBlockDescription(\"\");\n        }\n    }\n    retry: for (; ; ) {\n        switch(token) {\n            case ANNOTATION:\n                if (state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                    state \u003d State.SEARCHING_NEWLINE;\n                    lineno \u003d stream.getLineno();\n                    charno \u003d stream.getCharno();\n                    String annotationName \u003d stream.getString();\n                    Annotation annotation \u003d annotationNames.get(annotationName);\n                    if (annotation \u003d\u003d null) {\n                        parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno());\n                    } else {\n                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n                        switch(annotation) {\n                            case AUTHOR:\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo authorInfo \u003d extractSingleLineBlock();\n                                    String author \u003d authorInfo.string;\n                                    if (author.length() \u003d\u003d 0) {\n                                        parser.addParserWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        jsdocBuilder.addAuthor(author);\n                                    }\n                                    token \u003d authorInfo.token;\n                                } else {\n                                    token \u003d eatTokensUntilEOL(token);\n                                }\n                                continue retry;\n                            case CONSTANT:\n                                if (!jsdocBuilder.recordConstancy()) {\n                                    parser.addParserWarning(\"msg.jsdoc.const\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case CONSTRUCTOR:\n                                if (!jsdocBuilder.recordConstructor()) {\n                                    if (jsdocBuilder.isInterfaceRecorded()) {\n                                        parser.addTypeWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        parser.addTypeWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case DEPRECATED:\n                                if (!jsdocBuilder.recordDeprecated()) {\n                                    parser.addParserWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno());\n                                }\n                                ExtractionInfo reasonInfo \u003d extractMultilineTextualBlock(token);\n                                String reason \u003d reasonInfo.string;\n                                if (reason.length() \u003e 0) {\n                                    jsdocBuilder.recordDeprecationReason(reason);\n                                }\n                                token \u003d reasonInfo.token;\n                                continue retry;\n                            case INTERFACE:\n                                if (!jsdocBuilder.recordInterface()) {\n                                    if (jsdocBuilder.isConstructorRecorded()) {\n                                        parser.addTypeWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        parser.addTypeWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case DESC:\n                                if (jsdocBuilder.isDescriptionRecorded()) {\n                                    parser.addParserWarning(\"msg.jsdoc.desc.extra\", stream.getLineno(), stream.getCharno());\n                                    token \u003d eatTokensUntilEOL();\n                                    continue retry;\n                                } else {\n                                    ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                    String description \u003d descriptionInfo.string;\n                                    jsdocBuilder.recordDescription(description);\n                                    token \u003d descriptionInfo.token;\n                                    continue retry;\n                                }\n                            case FILE_OVERVIEW:\n                                String fileOverview \u003d \"\";\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo fileOverviewInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.TRIM);\n                                    fileOverview \u003d fileOverviewInfo.string;\n                                    token \u003d fileOverviewInfo.token;\n                                } else {\n                                    token \u003d eatTokensUntilEOL(token);\n                                }\n                                if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo !\u003d null) {\n                                    parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno());\n                                }\n                                continue retry;\n                            case LICENSE:\n                            case PRESERVE:\n                                ExtractionInfo preserveInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);\n                                String preserve \u003d preserveInfo.string;\n                                if (preserve.length() \u003e 0) {\n                                    if (fileLevelJsDocBuilder !\u003d null) {\n                                        fileLevelJsDocBuilder.append(preserve);\n                                    }\n                                }\n                                token \u003d preserveInfo.token;\n                                continue retry;\n                            case ENUM:\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                }\n                                if (type \u003d\u003d null) {\n                                    type \u003d createJSTypeExpression(newStringNode(\"number\"));\n                                }\n                                if (!jsdocBuilder.recordEnumParameterType(type)) {\n                                    parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                }\n                                token \u003d eatTokensUntilEOL(token);\n                                continue retry;\n                            case EXPORT:\n                                if (!jsdocBuilder.recordExport()) {\n                                    parser.addParserWarning(\"msg.jsdoc.export\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case EXTERNS:\n                                if (!jsdocBuilder.recordExterns()) {\n                                    parser.addParserWarning(\"msg.jsdoc.externs\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case JAVA_DISPATCH:\n                                if (!jsdocBuilder.recordJavaDispatch()) {\n                                    parser.addParserWarning(\"msg.jsdoc.javadispatch\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case EXTENDS:\n                            case IMPLEMENTS:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                boolean matchingRc \u003d false;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    token \u003d next();\n                                    matchingRc \u003d true;\n                                }\n                                if (token \u003d\u003d JsDocToken.STRING) {\n                                    Node typeNode \u003d parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);\n                                    lineno \u003d stream.getLineno();\n                                    charno \u003d stream.getCharno();\n                                    typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                    if (typeNode !\u003d null \u0026\u0026 !matchingRc) {\n                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                    }\n                                    type \u003d createJSTypeExpression(typeNode);\n                                    if (annotation \u003d\u003d Annotation.EXTENDS) {\n                                        if (!jsdocBuilder.recordBaseType(type)) {\n                                            parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                        }\n                                    } else {\n                                        Preconditions.checkState(annotation \u003d\u003d Annotation.IMPLEMENTS);\n                                        if (!jsdocBuilder.recordImplementedInterface(type)) {\n                                            parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\", lineno, charno);\n                                        }\n                                    }\n                                    token \u003d next();\n                                    if (matchingRc) {\n                                        if (token !\u003d JsDocToken.RC) {\n                                            parser.addTypeWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                        }\n                                    } else if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOF \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                        parser.addTypeWarning(\"msg.end.annotation.expected\", stream.getLineno(), stream.getCharno());\n                                    }\n                                } else {\n                                    parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);\n                                }\n                                token \u003d eatTokensUntilEOL(token);\n                                continue retry;\n                            case HIDDEN:\n                                if (!jsdocBuilder.recordHiddenness()) {\n                                    parser.addParserWarning(\"msg.jsdoc.hidden\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case LENDS:\n                                skipEOLs();\n                                matchingRc \u003d false;\n                                if (match(JsDocToken.LC)) {\n                                    token \u003d next();\n                                    matchingRc \u003d true;\n                                }\n                                if (match(JsDocToken.STRING)) {\n                                    token \u003d next();\n                                    if (!jsdocBuilder.recordLends(stream.getString())) {\n                                        parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\", stream.getLineno(), stream.getCharno());\n                                    }\n                                } else {\n                                    parser.addTypeWarning(\"msg.jsdoc.lends.missing\", stream.getLineno(), stream.getCharno());\n                                }\n                                if (matchingRc \u0026\u0026 !match(JsDocToken.RC)) {\n                                    parser.addTypeWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case MEANING:\n                                ExtractionInfo meaningInfo \u003d extractMultilineTextualBlock(token);\n                                String meaning \u003d meaningInfo.string;\n                                token \u003d meaningInfo.token;\n                                if (!jsdocBuilder.recordMeaning(meaning)) {\n                                    parser.addParserWarning(\"msg.jsdoc.meaning.extra\", stream.getLineno(), stream.getCharno());\n                                }\n                                continue retry;\n                            case NO_ALIAS:\n                                if (!jsdocBuilder.recordNoAlias()) {\n                                    parser.addParserWarning(\"msg.jsdoc.noalias\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_COMPILE:\n                                if (!jsdocBuilder.recordNoCompile()) {\n                                    parser.addParserWarning(\"msg.jsdoc.nocompile\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_TYPE_CHECK:\n                                if (!jsdocBuilder.recordNoTypeCheck()) {\n                                    parser.addParserWarning(\"msg.jsdoc.nocheck\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NOT_IMPLEMENTED:\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case INHERIT_DOC:\n                            case OVERRIDE:\n                                if (!jsdocBuilder.recordOverride()) {\n                                    parser.addTypeWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case THROWS:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                    if (type \u003d\u003d null) {\n                                        token \u003d eatTokensUntilEOL();\n                                        continue retry;\n                                    }\n                                }\n                                token \u003d current();\n                                jsdocBuilder.recordThrowType(type);\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                    String description \u003d descriptionInfo.string;\n                                    if (description.length() \u003e 0) {\n                                        jsdocBuilder.recordThrowDescription(type, description);\n                                    }\n                                    token \u003d descriptionInfo.token;\n                                } else {\n                                    token \u003d eatTokensUntilEOL(token);\n                                }\n                                continue retry;\n                            case PARAM:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordParamTypeNode(token));\n                                    if (type \u003d\u003d null) {\n                                        token \u003d eatTokensUntilEOL();\n                                        continue retry;\n                                    }\n                                    skipEOLs();\n                                    token \u003d next();\n                                    lineno \u003d stream.getLineno();\n                                    charno \u003d stream.getCharno();\n                                }\n                                String name \u003d null;\n                                boolean isBracketedParam \u003d JsDocToken.LB \u003d\u003d token;\n                                if (isBracketedParam) {\n                                    token \u003d next();\n                                }\n                                if (JsDocToken.STRING !\u003d token) {\n                                    parser.addTypeWarning(\"msg.missing.variable.name\", lineno, charno);\n                                } else {\n                                    name \u003d stream.getString();\n                                    if (isBracketedParam) {\n                                        token \u003d next();\n                                        if (JsDocToken.EQUALS \u003d\u003d token) {\n                                            token \u003d next();\n                                            if (JsDocToken.STRING \u003d\u003d token) {\n                                                token \u003d next();\n                                            }\n                                        }\n                                        if (JsDocToken.RB !\u003d token) {\n                                            reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                                        } else if (type !\u003d null) {\n                                            type \u003d JSTypeExpression.makeOptionalArg(type);\n                                        }\n                                    }\n                                    if (name.indexOf(\u0027.\u0027) \u003e -1) {\n                                        name \u003d null;\n                                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                                        if (jsdocBuilder.hasParameter(name)) {\n                                            parser.addTypeWarning(\"msg.dup.variable.name\", name, lineno, charno);\n                                        } else {\n                                            parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name, lineno, charno);\n                                        }\n                                    }\n                                }\n                                if (name \u003d\u003d null) {\n                                    token \u003d eatTokensUntilEOL(token);\n                                    continue retry;\n                                }\n                                jsdocBuilder.markName(name, lineno, charno);\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo paramDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                    String paramDescription \u003d paramDescriptionInfo.string;\n                                    if (paramDescription.length() \u003e 0) {\n                                        jsdocBuilder.recordParameterDescription(name, paramDescription);\n                                    }\n                                    token \u003d paramDescriptionInfo.token;\n                                } else {\n                                    token \u003d eatTokensUntilEOL(token);\n                                }\n                                continue retry;\n                            case PRESERVE_TRY:\n                                if (!jsdocBuilder.recordPreserveTry()) {\n                                    parser.addParserWarning(\"msg.jsdoc.preservertry\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PRIVATE:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                                    parser.addParserWarning(\"msg.jsdoc.visibility.private\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PROTECTED:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                                    parser.addParserWarning(\"msg.jsdoc.visibility.protected\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PUBLIC:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                                    parser.addParserWarning(\"msg.jsdoc.visibility.public\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_SHADOW:\n                                if (!jsdocBuilder.recordNoShadow()) {\n                                    parser.addParserWarning(\"msg.jsdoc.noshadow\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_SIDE_EFFECTS:\n                                if (!jsdocBuilder.recordNoSideEffects()) {\n                                    parser.addParserWarning(\"msg.jsdoc.nosideeffects\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case MODIFIES:\n                                token \u003d parseModifiesTag(next());\n                                continue retry;\n                            case IMPLICIT_CAST:\n                                if (!jsdocBuilder.recordImplicitCast()) {\n                                    parser.addTypeWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case SEE:\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo referenceInfo \u003d extractSingleLineBlock();\n                                    String reference \u003d referenceInfo.string;\n                                    if (reference.length() \u003d\u003d 0) {\n                                        parser.addParserWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        jsdocBuilder.addReference(reference);\n                                    }\n                                    token \u003d referenceInfo.token;\n                                } else {\n                                    token \u003d eatTokensUntilEOL(token);\n                                }\n                                continue retry;\n                            case SUPPRESS:\n                                token \u003d parseSuppressTag(next());\n                                continue retry;\n                            case TEMPLATE:\n                                ExtractionInfo templateInfo \u003d extractSingleLineBlock();\n                                String templateTypeName \u003d templateInfo.string;\n                                if (templateTypeName.length() \u003d\u003d 0) {\n                                    parser.addTypeWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno());\n                                } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {\n                                    parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d templateInfo.token;\n                                continue retry;\n                            case VERSION:\n                                ExtractionInfo versionInfo \u003d extractSingleLineBlock();\n                                String version \u003d versionInfo.string;\n                                if (version.length() \u003d\u003d 0) {\n                                    parser.addParserWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno());\n                                } else {\n                                    if (!jsdocBuilder.recordVersion(version)) {\n                                        parser.addParserWarning(\"msg.jsdoc.extraversion\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d versionInfo.token;\n                                continue retry;\n                            case DEFINE:\n                            case RETURN:\n                            case THIS:\n                            case TYPE:\n                            case TYPEDEF:\n                                skipEOLs();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                token \u003d next();\n                                Node typeNode \u003d null;\n                                if (annotation \u003d\u003d Annotation.RETURN \u0026\u0026 token !\u003d JsDocToken.LC) {\n                                    typeNode \u003d newNode(Token.QMARK);\n                                } else {\n                                    typeNode \u003d parseAndRecordTypeNode(token, lineno, charno);\n                                }\n                                if (annotation \u003d\u003d Annotation.THIS) {\n                                    typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                    if (typeNode !\u003d null \u0026\u0026 token !\u003d JsDocToken.LC) {\n                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                    }\n                                }\n                                type \u003d createJSTypeExpression(typeNode);\n                                if (type \u003d\u003d null) {\n                                } else {\n                                    switch(annotation) {\n                                        case DEFINE:\n                                            if (!jsdocBuilder.recordDefineType(type)) {\n                                                parser.addParserWarning(\"msg.jsdoc.define\", lineno, charno);\n                                            }\n                                            break;\n                                        case RETURN:\n                                            if (!jsdocBuilder.recordReturnType(type)) {\n                                                parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                                break;\n                                            }\n                                            token \u003d current();\n                                            if (jsdocBuilder.shouldParseDocumentation()) {\n                                                ExtractionInfo returnDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                                String returnDescription \u003d returnDescriptionInfo.string;\n                                                if (returnDescription.length() \u003e 0) {\n                                                    jsdocBuilder.recordReturnDescription(returnDescription);\n                                                }\n                                                token \u003d returnDescriptionInfo.token;\n                                            } else {\n                                                token \u003d eatTokensUntilEOL(token);\n                                            }\n                                            continue retry;\n                                        case THIS:\n                                            if (!jsdocBuilder.recordThisType(type)) {\n                                                parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                        case TYPE:\n                                            if (!jsdocBuilder.recordType(type)) {\n                                                parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                        case TYPEDEF:\n                                            if (!jsdocBuilder.recordTypedef(type)) {\n                                                parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                    }\n                                    token \u003d eatTokensUntilEOL();\n                                }\n                                continue retry;\n                        }\n                    }\n                }\n                break;\n            case EOC:\n                if (hasParsedFileOverviewDocInfo()) {\n                    fileOverviewJSDocInfo \u003d retrieveAndResetParsedJSDocInfo();\n                }\n                return true;\n            case EOF:\n                jsdocBuilder.build(null);\n                parser.addParserWarning(\"msg.unexpected.eof\", stream.getLineno(), stream.getCharno());\n                return false;\n            case EOL:\n                if (state \u003d\u003d State.SEARCHING_NEWLINE) {\n                    state \u003d State.SEARCHING_ANNOTATION;\n                }\n                token \u003d next();\n                continue retry;\n            default:\n                if (token \u003d\u003d JsDocToken.STAR \u0026\u0026 state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                    token \u003d next();\n                    continue retry;\n                } else {\n                    state \u003d State.SEARCHING_NEWLINE;\n                    token \u003d eatTokensUntilEOL();\n                    continue retry;\n                }\n        }\n        token \u003d next();\n    }\n}",
      "path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
      "functionStartLine": 167,
      "functionName": "parse",
      "functionAnnotation": "",
      "functionDoc": "Parses a {@link JSDocInfo} object. This parsing method reads all tokens\nreturned by the {@link JsDocTokenStream#getJsDocToken()} method until the\n{@link JsDocToken#EOC} is returned.\n\n@return @code true} if JSDoc information was correctly parsed,\n    {@code false} otherwise\n",
      "diff": "@@ -1,527 +1,532 @@\n boolean parse() {\n     int lineno;\n     int charno;\n     JSTypeExpression type;\n     state \u003d State.SEARCHING_ANNOTATION;\n     skipEOLs();\n     JsDocToken token \u003d next();\n     if (jsdocBuilder.shouldParseDocumentation()) {\n         ExtractionInfo blockInfo \u003d extractBlockComment(token);\n         token \u003d blockInfo.token;\n         if (!blockInfo.string.isEmpty()) {\n             jsdocBuilder.recordBlockDescription(blockInfo.string);\n         }\n     } else {\n         if (token !\u003d JsDocToken.ANNOTATION \u0026\u0026 token !\u003d JsDocToken.EOC) {\n             jsdocBuilder.recordBlockDescription(\"\");\n         }\n     }\n     retry: for (; ; ) {\n         switch(token) {\n             case ANNOTATION:\n                 if (state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                     state \u003d State.SEARCHING_NEWLINE;\n                     lineno \u003d stream.getLineno();\n                     charno \u003d stream.getCharno();\n                     String annotationName \u003d stream.getString();\n                     Annotation annotation \u003d annotationNames.get(annotationName);\n                     if (annotation \u003d\u003d null) {\n                         parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno());\n                     } else {\n                         jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n                         switch(annotation) {\n                             case AUTHOR:\n                                 if (jsdocBuilder.shouldParseDocumentation()) {\n                                     ExtractionInfo authorInfo \u003d extractSingleLineBlock();\n                                     String author \u003d authorInfo.string;\n                                     if (author.length() \u003d\u003d 0) {\n                                         parser.addParserWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno());\n                                     } else {\n                                         jsdocBuilder.addAuthor(author);\n                                     }\n                                     token \u003d authorInfo.token;\n                                 } else {\n                                     token \u003d eatTokensUntilEOL(token);\n                                 }\n                                 continue retry;\n                             case CONSTANT:\n                                 if (!jsdocBuilder.recordConstancy()) {\n                                     parser.addParserWarning(\"msg.jsdoc.const\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case CONSTRUCTOR:\n                                 if (!jsdocBuilder.recordConstructor()) {\n                                     if (jsdocBuilder.isInterfaceRecorded()) {\n                                         parser.addTypeWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                     } else {\n                                         parser.addTypeWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case DEPRECATED:\n                                 if (!jsdocBuilder.recordDeprecated()) {\n                                     parser.addParserWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 ExtractionInfo reasonInfo \u003d extractMultilineTextualBlock(token);\n                                 String reason \u003d reasonInfo.string;\n                                 if (reason.length() \u003e 0) {\n                                     jsdocBuilder.recordDeprecationReason(reason);\n                                 }\n                                 token \u003d reasonInfo.token;\n                                 continue retry;\n                             case INTERFACE:\n                                 if (!jsdocBuilder.recordInterface()) {\n                                     if (jsdocBuilder.isConstructorRecorded()) {\n                                         parser.addTypeWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                     } else {\n                                         parser.addTypeWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case DESC:\n                                 if (jsdocBuilder.isDescriptionRecorded()) {\n                                     parser.addParserWarning(\"msg.jsdoc.desc.extra\", stream.getLineno(), stream.getCharno());\n                                     token \u003d eatTokensUntilEOL();\n                                     continue retry;\n                                 } else {\n                                     ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                     String description \u003d descriptionInfo.string;\n                                     jsdocBuilder.recordDescription(description);\n                                     token \u003d descriptionInfo.token;\n                                     continue retry;\n                                 }\n                             case FILE_OVERVIEW:\n                                 String fileOverview \u003d \"\";\n                                 if (jsdocBuilder.shouldParseDocumentation()) {\n                                     ExtractionInfo fileOverviewInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.TRIM);\n                                     fileOverview \u003d fileOverviewInfo.string;\n                                     token \u003d fileOverviewInfo.token;\n                                 } else {\n                                     token \u003d eatTokensUntilEOL(token);\n                                 }\n                                 if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo !\u003d null) {\n                                     parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 continue retry;\n                             case LICENSE:\n                             case PRESERVE:\n                                 ExtractionInfo preserveInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);\n                                 String preserve \u003d preserveInfo.string;\n                                 if (preserve.length() \u003e 0) {\n                                     if (fileLevelJsDocBuilder !\u003d null) {\n                                         fileLevelJsDocBuilder.append(preserve);\n                                     }\n                                 }\n                                 token \u003d preserveInfo.token;\n                                 continue retry;\n                             case ENUM:\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                 }\n                                 if (type \u003d\u003d null) {\n                                     type \u003d createJSTypeExpression(newStringNode(\"number\"));\n                                 }\n                                 if (!jsdocBuilder.recordEnumParameterType(type)) {\n                                     parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                 }\n                                 token \u003d eatTokensUntilEOL(token);\n                                 continue retry;\n                             case EXPORT:\n                                 if (!jsdocBuilder.recordExport()) {\n                                     parser.addParserWarning(\"msg.jsdoc.export\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case EXTERNS:\n                                 if (!jsdocBuilder.recordExterns()) {\n                                     parser.addParserWarning(\"msg.jsdoc.externs\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case JAVA_DISPATCH:\n                                 if (!jsdocBuilder.recordJavaDispatch()) {\n                                     parser.addParserWarning(\"msg.jsdoc.javadispatch\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case EXTENDS:\n                             case IMPLEMENTS:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 boolean matchingRc \u003d false;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     token \u003d next();\n                                     matchingRc \u003d true;\n                                 }\n                                 if (token \u003d\u003d JsDocToken.STRING) {\n                                     Node typeNode \u003d parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);\n                                     lineno \u003d stream.getLineno();\n                                     charno \u003d stream.getCharno();\n                                     typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                     if (typeNode !\u003d null \u0026\u0026 !matchingRc) {\n                                         typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                     }\n                                     type \u003d createJSTypeExpression(typeNode);\n                                     if (annotation \u003d\u003d Annotation.EXTENDS) {\n                                         if (!jsdocBuilder.recordBaseType(type)) {\n                                             parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                         }\n                                     } else {\n                                         Preconditions.checkState(annotation \u003d\u003d Annotation.IMPLEMENTS);\n                                         if (!jsdocBuilder.recordImplementedInterface(type)) {\n                                             parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\", lineno, charno);\n                                         }\n                                     }\n                                     token \u003d next();\n                                     if (matchingRc) {\n                                         if (token !\u003d JsDocToken.RC) {\n                                             parser.addTypeWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                         }\n                                     } else if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOF \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                         parser.addTypeWarning(\"msg.end.annotation.expected\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 } else {\n                                     parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);\n                                 }\n                                 token \u003d eatTokensUntilEOL(token);\n                                 continue retry;\n                             case HIDDEN:\n                                 if (!jsdocBuilder.recordHiddenness()) {\n                                     parser.addParserWarning(\"msg.jsdoc.hidden\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case LENDS:\n                                 skipEOLs();\n                                 matchingRc \u003d false;\n                                 if (match(JsDocToken.LC)) {\n                                     token \u003d next();\n                                     matchingRc \u003d true;\n                                 }\n                                 if (match(JsDocToken.STRING)) {\n                                     token \u003d next();\n                                     if (!jsdocBuilder.recordLends(stream.getString())) {\n                                         parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 } else {\n                                     parser.addTypeWarning(\"msg.jsdoc.lends.missing\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 if (matchingRc \u0026\u0026 !match(JsDocToken.RC)) {\n                                     parser.addTypeWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case MEANING:\n                                 ExtractionInfo meaningInfo \u003d extractMultilineTextualBlock(token);\n                                 String meaning \u003d meaningInfo.string;\n                                 token \u003d meaningInfo.token;\n                                 if (!jsdocBuilder.recordMeaning(meaning)) {\n                                     parser.addParserWarning(\"msg.jsdoc.meaning.extra\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 continue retry;\n                             case NO_ALIAS:\n                                 if (!jsdocBuilder.recordNoAlias()) {\n                                     parser.addParserWarning(\"msg.jsdoc.noalias\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_COMPILE:\n                                 if (!jsdocBuilder.recordNoCompile()) {\n                                     parser.addParserWarning(\"msg.jsdoc.nocompile\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_TYPE_CHECK:\n                                 if (!jsdocBuilder.recordNoTypeCheck()) {\n                                     parser.addParserWarning(\"msg.jsdoc.nocheck\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NOT_IMPLEMENTED:\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case INHERIT_DOC:\n                             case OVERRIDE:\n                                 if (!jsdocBuilder.recordOverride()) {\n                                     parser.addTypeWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case THROWS:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                     if (type \u003d\u003d null) {\n                                         token \u003d eatTokensUntilEOL();\n                                         continue retry;\n                                     }\n                                 }\n                                 token \u003d current();\n                                 jsdocBuilder.recordThrowType(type);\n                                 if (jsdocBuilder.shouldParseDocumentation()) {\n                                     ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                     String description \u003d descriptionInfo.string;\n                                     if (description.length() \u003e 0) {\n                                         jsdocBuilder.recordThrowDescription(type, description);\n                                     }\n                                     token \u003d descriptionInfo.token;\n                                 } else {\n                                     token \u003d eatTokensUntilEOL(token);\n                                 }\n                                 continue retry;\n                             case PARAM:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordParamTypeNode(token));\n                                     if (type \u003d\u003d null) {\n                                         token \u003d eatTokensUntilEOL();\n                                         continue retry;\n                                     }\n                                     skipEOLs();\n                                     token \u003d next();\n                                     lineno \u003d stream.getLineno();\n                                     charno \u003d stream.getCharno();\n                                 }\n                                 String name \u003d null;\n                                 boolean isBracketedParam \u003d JsDocToken.LB \u003d\u003d token;\n                                 if (isBracketedParam) {\n                                     token \u003d next();\n                                 }\n                                 if (JsDocToken.STRING !\u003d token) {\n                                     parser.addTypeWarning(\"msg.missing.variable.name\", lineno, charno);\n                                 } else {\n                                     name \u003d stream.getString();\n                                     if (isBracketedParam) {\n                                         token \u003d next();\n                                         if (JsDocToken.EQUALS \u003d\u003d token) {\n                                             token \u003d next();\n                                             if (JsDocToken.STRING \u003d\u003d token) {\n                                                 token \u003d next();\n                                             }\n                                         }\n                                         if (JsDocToken.RB !\u003d token) {\n                                             reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                                         } else if (type !\u003d null) {\n                                             type \u003d JSTypeExpression.makeOptionalArg(type);\n                                         }\n                                     }\n                                     if (name.indexOf(\u0027.\u0027) \u003e -1) {\n                                         name \u003d null;\n                                     } else if (!jsdocBuilder.recordParameter(name, type)) {\n                                         if (jsdocBuilder.hasParameter(name)) {\n                                             parser.addTypeWarning(\"msg.dup.variable.name\", name, lineno, charno);\n                                         } else {\n                                             parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name, lineno, charno);\n                                         }\n                                     }\n                                 }\n                                 if (name \u003d\u003d null) {\n                                     token \u003d eatTokensUntilEOL(token);\n                                     continue retry;\n                                 }\n                                 jsdocBuilder.markName(name, lineno, charno);\n                                 if (jsdocBuilder.shouldParseDocumentation()) {\n                                     ExtractionInfo paramDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                     String paramDescription \u003d paramDescriptionInfo.string;\n                                     if (paramDescription.length() \u003e 0) {\n                                         jsdocBuilder.recordParameterDescription(name, paramDescription);\n                                     }\n                                     token \u003d paramDescriptionInfo.token;\n                                 } else {\n                                     token \u003d eatTokensUntilEOL(token);\n                                 }\n                                 continue retry;\n                             case PRESERVE_TRY:\n                                 if (!jsdocBuilder.recordPreserveTry()) {\n                                     parser.addParserWarning(\"msg.jsdoc.preservertry\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PRIVATE:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                                     parser.addParserWarning(\"msg.jsdoc.visibility.private\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PROTECTED:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                                     parser.addParserWarning(\"msg.jsdoc.visibility.protected\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PUBLIC:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                                     parser.addParserWarning(\"msg.jsdoc.visibility.public\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_SHADOW:\n                                 if (!jsdocBuilder.recordNoShadow()) {\n                                     parser.addParserWarning(\"msg.jsdoc.noshadow\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_SIDE_EFFECTS:\n                                 if (!jsdocBuilder.recordNoSideEffects()) {\n                                     parser.addParserWarning(\"msg.jsdoc.nosideeffects\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case MODIFIES:\n                                 token \u003d parseModifiesTag(next());\n                                 continue retry;\n                             case IMPLICIT_CAST:\n                                 if (!jsdocBuilder.recordImplicitCast()) {\n                                     parser.addTypeWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case SEE:\n                                 if (jsdocBuilder.shouldParseDocumentation()) {\n                                     ExtractionInfo referenceInfo \u003d extractSingleLineBlock();\n                                     String reference \u003d referenceInfo.string;\n                                     if (reference.length() \u003d\u003d 0) {\n                                         parser.addParserWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno());\n                                     } else {\n                                         jsdocBuilder.addReference(reference);\n                                     }\n                                     token \u003d referenceInfo.token;\n                                 } else {\n                                     token \u003d eatTokensUntilEOL(token);\n                                 }\n                                 continue retry;\n                             case SUPPRESS:\n                                 token \u003d parseSuppressTag(next());\n                                 continue retry;\n                             case TEMPLATE:\n                                 ExtractionInfo templateInfo \u003d extractSingleLineBlock();\n                                 String templateTypeName \u003d templateInfo.string;\n                                 if (templateTypeName.length() \u003d\u003d 0) {\n                                     parser.addTypeWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno());\n                                 } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {\n                                     parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d templateInfo.token;\n                                 continue retry;\n                             case VERSION:\n                                 ExtractionInfo versionInfo \u003d extractSingleLineBlock();\n                                 String version \u003d versionInfo.string;\n                                 if (version.length() \u003d\u003d 0) {\n                                     parser.addParserWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno());\n                                 } else {\n                                     if (!jsdocBuilder.recordVersion(version)) {\n                                         parser.addParserWarning(\"msg.jsdoc.extraversion\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d versionInfo.token;\n                                 continue retry;\n                             case DEFINE:\n                             case RETURN:\n                             case THIS:\n                             case TYPE:\n                             case TYPEDEF:\n                                 skipEOLs();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 token \u003d next();\n-                                Node typeNode \u003d parseAndRecordTypeNode(token, lineno, charno);\n+                                Node typeNode \u003d null;\n+                                if (annotation \u003d\u003d Annotation.RETURN \u0026\u0026 token !\u003d JsDocToken.LC) {\n+                                    typeNode \u003d newNode(Token.QMARK);\n+                                } else {\n+                                    typeNode \u003d parseAndRecordTypeNode(token, lineno, charno);\n+                                }\n                                 if (annotation \u003d\u003d Annotation.THIS) {\n                                     typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                     if (typeNode !\u003d null \u0026\u0026 token !\u003d JsDocToken.LC) {\n                                         typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                     }\n                                 }\n                                 type \u003d createJSTypeExpression(typeNode);\n                                 if (type \u003d\u003d null) {\n                                 } else {\n                                     switch(annotation) {\n                                         case DEFINE:\n                                             if (!jsdocBuilder.recordDefineType(type)) {\n                                                 parser.addParserWarning(\"msg.jsdoc.define\", lineno, charno);\n                                             }\n                                             break;\n                                         case RETURN:\n                                             if (!jsdocBuilder.recordReturnType(type)) {\n                                                 parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                                 break;\n                                             }\n                                             token \u003d current();\n                                             if (jsdocBuilder.shouldParseDocumentation()) {\n                                                 ExtractionInfo returnDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                                 String returnDescription \u003d returnDescriptionInfo.string;\n                                                 if (returnDescription.length() \u003e 0) {\n                                                     jsdocBuilder.recordReturnDescription(returnDescription);\n                                                 }\n                                                 token \u003d returnDescriptionInfo.token;\n                                             } else {\n                                                 token \u003d eatTokensUntilEOL(token);\n                                             }\n                                             continue retry;\n                                         case THIS:\n                                             if (!jsdocBuilder.recordThisType(type)) {\n                                                 parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                         case TYPE:\n                                             if (!jsdocBuilder.recordType(type)) {\n                                                 parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                         case TYPEDEF:\n                                             if (!jsdocBuilder.recordTypedef(type)) {\n                                                 parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                     }\n                                     token \u003d eatTokensUntilEOL();\n                                 }\n                                 continue retry;\n                         }\n                     }\n                 }\n                 break;\n             case EOC:\n                 if (hasParsedFileOverviewDocInfo()) {\n                     fileOverviewJSDocInfo \u003d retrieveAndResetParsedJSDocInfo();\n                 }\n                 return true;\n             case EOF:\n                 jsdocBuilder.build(null);\n                 parser.addParserWarning(\"msg.unexpected.eof\", stream.getLineno(), stream.getCharno());\n                 return false;\n             case EOL:\n                 if (state \u003d\u003d State.SEARCHING_NEWLINE) {\n                     state \u003d State.SEARCHING_ANNOTATION;\n                 }\n                 token \u003d next();\n                 continue retry;\n             default:\n                 if (token \u003d\u003d JsDocToken.STAR \u0026\u0026 state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                     token \u003d next();\n                     continue retry;\n                 } else {\n                     state \u003d State.SEARCHING_NEWLINE;\n                     token \u003d eatTokensUntilEOL();\n                     continue retry;\n                 }\n         }\n         token \u003d next();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5709ec1d0bbe5b7726a14d06f7eab9c35150e314": {
      "type": "Ybodychange",
      "commitMessage": "\nPut bad type annotations behind a diagnostic group, so that they\naren\u0027t reported if type-checking isn\u0027t on.\n\nR\u003dacleung\nDELTA\u003d300  (110 added, 11 deleted, 179 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d780\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@857 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "3/7/11, 12:59 PM",
      "commitName": "5709ec1d0bbe5b7726a14d06f7eab9c35150e314",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "3/4/11, 4:48 PM",
      "commitNameOld": "82d3c01785f8b25113ca3fd7cc8b37da5d8a44a4",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 2.84,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "boolean parse() {\n    int lineno;\n    int charno;\n    JSTypeExpression type;\n    state \u003d State.SEARCHING_ANNOTATION;\n    skipEOLs();\n    JsDocToken token \u003d next();\n    if (jsdocBuilder.shouldParseDocumentation()) {\n        ExtractionInfo blockInfo \u003d extractBlockComment(token);\n        token \u003d blockInfo.token;\n        if (!blockInfo.string.isEmpty()) {\n            jsdocBuilder.recordBlockDescription(blockInfo.string);\n        }\n    } else {\n        if (token !\u003d JsDocToken.ANNOTATION \u0026\u0026 token !\u003d JsDocToken.EOC) {\n            jsdocBuilder.recordBlockDescription(\"\");\n        }\n    }\n    retry: for (; ; ) {\n        switch(token) {\n            case ANNOTATION:\n                if (state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                    state \u003d State.SEARCHING_NEWLINE;\n                    lineno \u003d stream.getLineno();\n                    charno \u003d stream.getCharno();\n                    String annotationName \u003d stream.getString();\n                    Annotation annotation \u003d annotationNames.get(annotationName);\n                    if (annotation \u003d\u003d null) {\n                        parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno());\n                    } else {\n                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n                        switch(annotation) {\n                            case AUTHOR:\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo authorInfo \u003d extractSingleLineBlock();\n                                    String author \u003d authorInfo.string;\n                                    if (author.length() \u003d\u003d 0) {\n                                        parser.addParserWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        jsdocBuilder.addAuthor(author);\n                                    }\n                                    token \u003d authorInfo.token;\n                                } else {\n                                    token \u003d eatTokensUntilEOL(token);\n                                }\n                                continue retry;\n                            case CONSTANT:\n                                if (!jsdocBuilder.recordConstancy()) {\n                                    parser.addParserWarning(\"msg.jsdoc.const\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case CONSTRUCTOR:\n                                if (!jsdocBuilder.recordConstructor()) {\n                                    if (jsdocBuilder.isInterfaceRecorded()) {\n                                        parser.addTypeWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        parser.addTypeWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case DEPRECATED:\n                                if (!jsdocBuilder.recordDeprecated()) {\n                                    parser.addParserWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno());\n                                }\n                                ExtractionInfo reasonInfo \u003d extractMultilineTextualBlock(token);\n                                String reason \u003d reasonInfo.string;\n                                if (reason.length() \u003e 0) {\n                                    jsdocBuilder.recordDeprecationReason(reason);\n                                }\n                                token \u003d reasonInfo.token;\n                                continue retry;\n                            case INTERFACE:\n                                if (!jsdocBuilder.recordInterface()) {\n                                    if (jsdocBuilder.isConstructorRecorded()) {\n                                        parser.addTypeWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        parser.addTypeWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case DESC:\n                                if (jsdocBuilder.isDescriptionRecorded()) {\n                                    parser.addParserWarning(\"msg.jsdoc.desc.extra\", stream.getLineno(), stream.getCharno());\n                                    token \u003d eatTokensUntilEOL();\n                                    continue retry;\n                                } else {\n                                    ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                    String description \u003d descriptionInfo.string;\n                                    jsdocBuilder.recordDescription(description);\n                                    token \u003d descriptionInfo.token;\n                                    continue retry;\n                                }\n                            case FILE_OVERVIEW:\n                                String fileOverview \u003d \"\";\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo fileOverviewInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.TRIM);\n                                    fileOverview \u003d fileOverviewInfo.string;\n                                    token \u003d fileOverviewInfo.token;\n                                } else {\n                                    token \u003d eatTokensUntilEOL(token);\n                                }\n                                if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo !\u003d null) {\n                                    parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno());\n                                }\n                                continue retry;\n                            case LICENSE:\n                            case PRESERVE:\n                                ExtractionInfo preserveInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);\n                                String preserve \u003d preserveInfo.string;\n                                if (preserve.length() \u003e 0) {\n                                    if (fileLevelJsDocBuilder !\u003d null) {\n                                        fileLevelJsDocBuilder.append(preserve);\n                                    }\n                                }\n                                token \u003d preserveInfo.token;\n                                continue retry;\n                            case ENUM:\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                }\n                                if (type \u003d\u003d null) {\n                                    type \u003d createJSTypeExpression(newStringNode(\"number\"));\n                                }\n                                if (!jsdocBuilder.recordEnumParameterType(type)) {\n                                    parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                }\n                                token \u003d eatTokensUntilEOL(token);\n                                continue retry;\n                            case EXPORT:\n                                if (!jsdocBuilder.recordExport()) {\n                                    parser.addParserWarning(\"msg.jsdoc.export\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case EXTERNS:\n                                if (!jsdocBuilder.recordExterns()) {\n                                    parser.addParserWarning(\"msg.jsdoc.externs\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case JAVA_DISPATCH:\n                                if (!jsdocBuilder.recordJavaDispatch()) {\n                                    parser.addParserWarning(\"msg.jsdoc.javadispatch\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case EXTENDS:\n                            case IMPLEMENTS:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                boolean matchingRc \u003d false;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    token \u003d next();\n                                    matchingRc \u003d true;\n                                }\n                                if (token \u003d\u003d JsDocToken.STRING) {\n                                    Node typeNode \u003d parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);\n                                    lineno \u003d stream.getLineno();\n                                    charno \u003d stream.getCharno();\n                                    typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                    if (typeNode !\u003d null \u0026\u0026 !matchingRc) {\n                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                    }\n                                    type \u003d createJSTypeExpression(typeNode);\n                                    if (annotation \u003d\u003d Annotation.EXTENDS) {\n                                        if (!jsdocBuilder.recordBaseType(type)) {\n                                            parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                        }\n                                    } else {\n                                        Preconditions.checkState(annotation \u003d\u003d Annotation.IMPLEMENTS);\n                                        if (!jsdocBuilder.recordImplementedInterface(type)) {\n                                            parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\", lineno, charno);\n                                        }\n                                    }\n                                    token \u003d next();\n                                    if (matchingRc) {\n                                        if (token !\u003d JsDocToken.RC) {\n                                            parser.addTypeWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                        }\n                                    } else if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOF \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                        parser.addTypeWarning(\"msg.end.annotation.expected\", stream.getLineno(), stream.getCharno());\n                                    }\n                                } else {\n                                    parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);\n                                }\n                                token \u003d eatTokensUntilEOL(token);\n                                continue retry;\n                            case HIDDEN:\n                                if (!jsdocBuilder.recordHiddenness()) {\n                                    parser.addParserWarning(\"msg.jsdoc.hidden\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case LENDS:\n                                skipEOLs();\n                                matchingRc \u003d false;\n                                if (match(JsDocToken.LC)) {\n                                    token \u003d next();\n                                    matchingRc \u003d true;\n                                }\n                                if (match(JsDocToken.STRING)) {\n                                    token \u003d next();\n                                    if (!jsdocBuilder.recordLends(stream.getString())) {\n                                        parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\", stream.getLineno(), stream.getCharno());\n                                    }\n                                } else {\n                                    parser.addTypeWarning(\"msg.jsdoc.lends.missing\", stream.getLineno(), stream.getCharno());\n                                }\n                                if (matchingRc \u0026\u0026 !match(JsDocToken.RC)) {\n                                    parser.addTypeWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case MEANING:\n                                ExtractionInfo meaningInfo \u003d extractMultilineTextualBlock(token);\n                                String meaning \u003d meaningInfo.string;\n                                token \u003d meaningInfo.token;\n                                if (!jsdocBuilder.recordMeaning(meaning)) {\n                                    parser.addParserWarning(\"msg.jsdoc.meaning.extra\", stream.getLineno(), stream.getCharno());\n                                }\n                                continue retry;\n                            case NO_ALIAS:\n                                if (!jsdocBuilder.recordNoAlias()) {\n                                    parser.addParserWarning(\"msg.jsdoc.noalias\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_COMPILE:\n                                if (!jsdocBuilder.recordNoCompile()) {\n                                    parser.addParserWarning(\"msg.jsdoc.nocompile\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_TYPE_CHECK:\n                                if (!jsdocBuilder.recordNoTypeCheck()) {\n                                    parser.addParserWarning(\"msg.jsdoc.nocheck\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NOT_IMPLEMENTED:\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case INHERIT_DOC:\n                            case OVERRIDE:\n                                if (!jsdocBuilder.recordOverride()) {\n                                    parser.addTypeWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case THROWS:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                    if (type \u003d\u003d null) {\n                                        token \u003d eatTokensUntilEOL();\n                                        continue retry;\n                                    }\n                                }\n                                token \u003d current();\n                                jsdocBuilder.recordThrowType(type);\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                    String description \u003d descriptionInfo.string;\n                                    if (description.length() \u003e 0) {\n                                        jsdocBuilder.recordThrowDescription(type, description);\n                                    }\n                                    token \u003d descriptionInfo.token;\n                                } else {\n                                    token \u003d eatTokensUntilEOL(token);\n                                }\n                                continue retry;\n                            case PARAM:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordParamTypeNode(token));\n                                    if (type \u003d\u003d null) {\n                                        token \u003d eatTokensUntilEOL();\n                                        continue retry;\n                                    }\n                                    skipEOLs();\n                                    token \u003d next();\n                                    lineno \u003d stream.getLineno();\n                                    charno \u003d stream.getCharno();\n                                }\n                                String name \u003d null;\n                                boolean isBracketedParam \u003d JsDocToken.LB \u003d\u003d token;\n                                if (isBracketedParam) {\n                                    token \u003d next();\n                                }\n                                if (JsDocToken.STRING !\u003d token) {\n                                    parser.addTypeWarning(\"msg.missing.variable.name\", lineno, charno);\n                                } else {\n                                    name \u003d stream.getString();\n                                    if (isBracketedParam) {\n                                        token \u003d next();\n                                        if (JsDocToken.EQUALS \u003d\u003d token) {\n                                            token \u003d next();\n                                            if (JsDocToken.STRING \u003d\u003d token) {\n                                                token \u003d next();\n                                            }\n                                        }\n                                        if (JsDocToken.RB !\u003d token) {\n                                            reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                                        } else if (type !\u003d null) {\n                                            type \u003d JSTypeExpression.makeOptionalArg(type);\n                                        }\n                                    }\n                                    if (name.indexOf(\u0027.\u0027) \u003e -1) {\n                                        name \u003d null;\n                                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                                        if (jsdocBuilder.hasParameter(name)) {\n                                            parser.addTypeWarning(\"msg.dup.variable.name\", name, lineno, charno);\n                                        } else {\n                                            parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name, lineno, charno);\n                                        }\n                                    }\n                                }\n                                if (name \u003d\u003d null) {\n                                    token \u003d eatTokensUntilEOL(token);\n                                    continue retry;\n                                }\n                                jsdocBuilder.markName(name, lineno, charno);\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo paramDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                    String paramDescription \u003d paramDescriptionInfo.string;\n                                    if (paramDescription.length() \u003e 0) {\n                                        jsdocBuilder.recordParameterDescription(name, paramDescription);\n                                    }\n                                    token \u003d paramDescriptionInfo.token;\n                                } else {\n                                    token \u003d eatTokensUntilEOL(token);\n                                }\n                                continue retry;\n                            case PRESERVE_TRY:\n                                if (!jsdocBuilder.recordPreserveTry()) {\n                                    parser.addParserWarning(\"msg.jsdoc.preservertry\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PRIVATE:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                                    parser.addParserWarning(\"msg.jsdoc.visibility.private\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PROTECTED:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                                    parser.addParserWarning(\"msg.jsdoc.visibility.protected\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PUBLIC:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                                    parser.addParserWarning(\"msg.jsdoc.visibility.public\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_SHADOW:\n                                if (!jsdocBuilder.recordNoShadow()) {\n                                    parser.addParserWarning(\"msg.jsdoc.noshadow\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_SIDE_EFFECTS:\n                                if (!jsdocBuilder.recordNoSideEffects()) {\n                                    parser.addParserWarning(\"msg.jsdoc.nosideeffects\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case MODIFIES:\n                                token \u003d parseModifiesTag(next());\n                                continue retry;\n                            case IMPLICIT_CAST:\n                                if (!jsdocBuilder.recordImplicitCast()) {\n                                    parser.addTypeWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case SEE:\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo referenceInfo \u003d extractSingleLineBlock();\n                                    String reference \u003d referenceInfo.string;\n                                    if (reference.length() \u003d\u003d 0) {\n                                        parser.addParserWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        jsdocBuilder.addReference(reference);\n                                    }\n                                    token \u003d referenceInfo.token;\n                                } else {\n                                    token \u003d eatTokensUntilEOL(token);\n                                }\n                                continue retry;\n                            case SUPPRESS:\n                                token \u003d parseSuppressTag(next());\n                                continue retry;\n                            case TEMPLATE:\n                                ExtractionInfo templateInfo \u003d extractSingleLineBlock();\n                                String templateTypeName \u003d templateInfo.string;\n                                if (templateTypeName.length() \u003d\u003d 0) {\n                                    parser.addTypeWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno());\n                                } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {\n                                    parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d templateInfo.token;\n                                continue retry;\n                            case VERSION:\n                                ExtractionInfo versionInfo \u003d extractSingleLineBlock();\n                                String version \u003d versionInfo.string;\n                                if (version.length() \u003d\u003d 0) {\n                                    parser.addParserWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno());\n                                } else {\n                                    if (!jsdocBuilder.recordVersion(version)) {\n                                        parser.addParserWarning(\"msg.jsdoc.extraversion\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d versionInfo.token;\n                                continue retry;\n                            case DEFINE:\n                            case RETURN:\n                            case THIS:\n                            case TYPE:\n                            case TYPEDEF:\n                                skipEOLs();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                token \u003d next();\n                                Node typeNode \u003d parseAndRecordTypeNode(token, lineno, charno);\n                                if (annotation \u003d\u003d Annotation.THIS) {\n                                    typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                    if (typeNode !\u003d null \u0026\u0026 token !\u003d JsDocToken.LC) {\n                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                    }\n                                }\n                                type \u003d createJSTypeExpression(typeNode);\n                                if (type \u003d\u003d null) {\n                                } else {\n                                    switch(annotation) {\n                                        case DEFINE:\n                                            if (!jsdocBuilder.recordDefineType(type)) {\n                                                parser.addParserWarning(\"msg.jsdoc.define\", lineno, charno);\n                                            }\n                                            break;\n                                        case RETURN:\n                                            if (!jsdocBuilder.recordReturnType(type)) {\n                                                parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                                break;\n                                            }\n                                            token \u003d current();\n                                            if (jsdocBuilder.shouldParseDocumentation()) {\n                                                ExtractionInfo returnDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                                String returnDescription \u003d returnDescriptionInfo.string;\n                                                if (returnDescription.length() \u003e 0) {\n                                                    jsdocBuilder.recordReturnDescription(returnDescription);\n                                                }\n                                                token \u003d returnDescriptionInfo.token;\n                                            } else {\n                                                token \u003d eatTokensUntilEOL(token);\n                                            }\n                                            continue retry;\n                                        case THIS:\n                                            if (!jsdocBuilder.recordThisType(type)) {\n                                                parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                        case TYPE:\n                                            if (!jsdocBuilder.recordType(type)) {\n                                                parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                        case TYPEDEF:\n                                            if (!jsdocBuilder.recordTypedef(type)) {\n                                                parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                    }\n                                    token \u003d eatTokensUntilEOL();\n                                }\n                                continue retry;\n                        }\n                    }\n                }\n                break;\n            case EOC:\n                if (hasParsedFileOverviewDocInfo()) {\n                    fileOverviewJSDocInfo \u003d retrieveAndResetParsedJSDocInfo();\n                }\n                return true;\n            case EOF:\n                jsdocBuilder.build(null);\n                parser.addParserWarning(\"msg.unexpected.eof\", stream.getLineno(), stream.getCharno());\n                return false;\n            case EOL:\n                if (state \u003d\u003d State.SEARCHING_NEWLINE) {\n                    state \u003d State.SEARCHING_ANNOTATION;\n                }\n                token \u003d next();\n                continue retry;\n            default:\n                if (token \u003d\u003d JsDocToken.STAR \u0026\u0026 state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                    token \u003d next();\n                    continue retry;\n                } else {\n                    state \u003d State.SEARCHING_NEWLINE;\n                    token \u003d eatTokensUntilEOL();\n                    continue retry;\n                }\n        }\n        token \u003d next();\n    }\n}",
      "path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
      "functionStartLine": 167,
      "functionName": "parse",
      "functionAnnotation": "",
      "functionDoc": "Parses a {@link JSDocInfo} object. This parsing method reads all tokens\nreturned by the {@link JsDocTokenStream#getJsDocToken()} method until the\n{@link JsDocToken#EOC} is returned.\n\n@return @code true} if JSDoc information was correctly parsed,\n    {@code false} otherwise\n",
      "diff": "@@ -1,527 +1,527 @@\n boolean parse() {\n     int lineno;\n     int charno;\n     JSTypeExpression type;\n     state \u003d State.SEARCHING_ANNOTATION;\n     skipEOLs();\n     JsDocToken token \u003d next();\n     if (jsdocBuilder.shouldParseDocumentation()) {\n         ExtractionInfo blockInfo \u003d extractBlockComment(token);\n         token \u003d blockInfo.token;\n         if (!blockInfo.string.isEmpty()) {\n             jsdocBuilder.recordBlockDescription(blockInfo.string);\n         }\n     } else {\n         if (token !\u003d JsDocToken.ANNOTATION \u0026\u0026 token !\u003d JsDocToken.EOC) {\n             jsdocBuilder.recordBlockDescription(\"\");\n         }\n     }\n     retry: for (; ; ) {\n         switch(token) {\n             case ANNOTATION:\n                 if (state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                     state \u003d State.SEARCHING_NEWLINE;\n                     lineno \u003d stream.getLineno();\n                     charno \u003d stream.getCharno();\n                     String annotationName \u003d stream.getString();\n                     Annotation annotation \u003d annotationNames.get(annotationName);\n                     if (annotation \u003d\u003d null) {\n-                        parser.addWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno());\n+                        parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno());\n                     } else {\n                         jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n                         switch(annotation) {\n                             case AUTHOR:\n                                 if (jsdocBuilder.shouldParseDocumentation()) {\n                                     ExtractionInfo authorInfo \u003d extractSingleLineBlock();\n                                     String author \u003d authorInfo.string;\n                                     if (author.length() \u003d\u003d 0) {\n-                                        parser.addWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno());\n+                                        parser.addParserWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno());\n                                     } else {\n                                         jsdocBuilder.addAuthor(author);\n                                     }\n                                     token \u003d authorInfo.token;\n                                 } else {\n                                     token \u003d eatTokensUntilEOL(token);\n                                 }\n                                 continue retry;\n                             case CONSTANT:\n                                 if (!jsdocBuilder.recordConstancy()) {\n-                                    parser.addWarning(\"msg.jsdoc.const\", stream.getLineno(), stream.getCharno());\n+                                    parser.addParserWarning(\"msg.jsdoc.const\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case CONSTRUCTOR:\n                                 if (!jsdocBuilder.recordConstructor()) {\n                                     if (jsdocBuilder.isInterfaceRecorded()) {\n-                                        parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n+                                        parser.addTypeWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                     } else {\n-                                        parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n+                                        parser.addTypeWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case DEPRECATED:\n                                 if (!jsdocBuilder.recordDeprecated()) {\n-                                    parser.addWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno());\n+                                    parser.addParserWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 ExtractionInfo reasonInfo \u003d extractMultilineTextualBlock(token);\n                                 String reason \u003d reasonInfo.string;\n                                 if (reason.length() \u003e 0) {\n                                     jsdocBuilder.recordDeprecationReason(reason);\n                                 }\n                                 token \u003d reasonInfo.token;\n                                 continue retry;\n                             case INTERFACE:\n                                 if (!jsdocBuilder.recordInterface()) {\n                                     if (jsdocBuilder.isConstructorRecorded()) {\n-                                        parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n+                                        parser.addTypeWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                     } else {\n-                                        parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n+                                        parser.addTypeWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case DESC:\n                                 if (jsdocBuilder.isDescriptionRecorded()) {\n-                                    parser.addWarning(\"msg.jsdoc.desc.extra\", stream.getLineno(), stream.getCharno());\n+                                    parser.addParserWarning(\"msg.jsdoc.desc.extra\", stream.getLineno(), stream.getCharno());\n                                     token \u003d eatTokensUntilEOL();\n                                     continue retry;\n                                 } else {\n                                     ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                     String description \u003d descriptionInfo.string;\n                                     jsdocBuilder.recordDescription(description);\n                                     token \u003d descriptionInfo.token;\n                                     continue retry;\n                                 }\n                             case FILE_OVERVIEW:\n                                 String fileOverview \u003d \"\";\n                                 if (jsdocBuilder.shouldParseDocumentation()) {\n                                     ExtractionInfo fileOverviewInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.TRIM);\n                                     fileOverview \u003d fileOverviewInfo.string;\n                                     token \u003d fileOverviewInfo.token;\n                                 } else {\n                                     token \u003d eatTokensUntilEOL(token);\n                                 }\n                                 if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo !\u003d null) {\n-                                    parser.addWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno());\n+                                    parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 continue retry;\n                             case LICENSE:\n                             case PRESERVE:\n                                 ExtractionInfo preserveInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);\n                                 String preserve \u003d preserveInfo.string;\n                                 if (preserve.length() \u003e 0) {\n                                     if (fileLevelJsDocBuilder !\u003d null) {\n                                         fileLevelJsDocBuilder.append(preserve);\n                                     }\n                                 }\n                                 token \u003d preserveInfo.token;\n                                 continue retry;\n                             case ENUM:\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                 }\n                                 if (type \u003d\u003d null) {\n                                     type \u003d createJSTypeExpression(newStringNode(\"number\"));\n                                 }\n                                 if (!jsdocBuilder.recordEnumParameterType(type)) {\n-                                    parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n+                                    parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                 }\n                                 token \u003d eatTokensUntilEOL(token);\n                                 continue retry;\n                             case EXPORT:\n                                 if (!jsdocBuilder.recordExport()) {\n-                                    parser.addWarning(\"msg.jsdoc.export\", stream.getLineno(), stream.getCharno());\n+                                    parser.addParserWarning(\"msg.jsdoc.export\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case EXTERNS:\n                                 if (!jsdocBuilder.recordExterns()) {\n-                                    parser.addWarning(\"msg.jsdoc.externs\", stream.getLineno(), stream.getCharno());\n+                                    parser.addParserWarning(\"msg.jsdoc.externs\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case JAVA_DISPATCH:\n                                 if (!jsdocBuilder.recordJavaDispatch()) {\n-                                    parser.addWarning(\"msg.jsdoc.javadispatch\", stream.getLineno(), stream.getCharno());\n+                                    parser.addParserWarning(\"msg.jsdoc.javadispatch\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case EXTENDS:\n                             case IMPLEMENTS:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 boolean matchingRc \u003d false;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     token \u003d next();\n                                     matchingRc \u003d true;\n                                 }\n                                 if (token \u003d\u003d JsDocToken.STRING) {\n                                     Node typeNode \u003d parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);\n                                     lineno \u003d stream.getLineno();\n                                     charno \u003d stream.getCharno();\n                                     typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                     if (typeNode !\u003d null \u0026\u0026 !matchingRc) {\n                                         typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                     }\n                                     type \u003d createJSTypeExpression(typeNode);\n                                     if (annotation \u003d\u003d Annotation.EXTENDS) {\n                                         if (!jsdocBuilder.recordBaseType(type)) {\n-                                            parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n+                                            parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                         }\n                                     } else {\n                                         Preconditions.checkState(annotation \u003d\u003d Annotation.IMPLEMENTS);\n                                         if (!jsdocBuilder.recordImplementedInterface(type)) {\n-                                            parser.addWarning(\"msg.jsdoc.implements.duplicate\", lineno, charno);\n+                                            parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\", lineno, charno);\n                                         }\n                                     }\n                                     token \u003d next();\n                                     if (matchingRc) {\n                                         if (token !\u003d JsDocToken.RC) {\n-                                            parser.addWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n+                                            parser.addTypeWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                         }\n                                     } else if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOF \u0026\u0026 token !\u003d JsDocToken.EOC) {\n-                                        parser.addWarning(\"msg.end.annotation.expected\", stream.getLineno(), stream.getCharno());\n+                                        parser.addTypeWarning(\"msg.end.annotation.expected\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 } else {\n-                                    parser.addWarning(\"msg.no.type.name\", lineno, charno);\n+                                    parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);\n                                 }\n                                 token \u003d eatTokensUntilEOL(token);\n                                 continue retry;\n                             case HIDDEN:\n                                 if (!jsdocBuilder.recordHiddenness()) {\n-                                    parser.addWarning(\"msg.jsdoc.hidden\", stream.getLineno(), stream.getCharno());\n+                                    parser.addParserWarning(\"msg.jsdoc.hidden\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case LENDS:\n                                 skipEOLs();\n                                 matchingRc \u003d false;\n                                 if (match(JsDocToken.LC)) {\n                                     token \u003d next();\n                                     matchingRc \u003d true;\n                                 }\n                                 if (match(JsDocToken.STRING)) {\n                                     token \u003d next();\n                                     if (!jsdocBuilder.recordLends(stream.getString())) {\n-                                        parser.addWarning(\"msg.jsdoc.lends.incompatible\", stream.getLineno(), stream.getCharno());\n+                                        parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 } else {\n-                                    parser.addWarning(\"msg.jsdoc.lends.missing\", stream.getLineno(), stream.getCharno());\n+                                    parser.addTypeWarning(\"msg.jsdoc.lends.missing\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 if (matchingRc \u0026\u0026 !match(JsDocToken.RC)) {\n-                                    parser.addWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n+                                    parser.addTypeWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case MEANING:\n                                 ExtractionInfo meaningInfo \u003d extractMultilineTextualBlock(token);\n                                 String meaning \u003d meaningInfo.string;\n                                 token \u003d meaningInfo.token;\n                                 if (!jsdocBuilder.recordMeaning(meaning)) {\n-                                    parser.addWarning(\"msg.jsdoc.meaning.extra\", stream.getLineno(), stream.getCharno());\n+                                    parser.addParserWarning(\"msg.jsdoc.meaning.extra\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 continue retry;\n                             case NO_ALIAS:\n                                 if (!jsdocBuilder.recordNoAlias()) {\n-                                    parser.addWarning(\"msg.jsdoc.noalias\", stream.getLineno(), stream.getCharno());\n+                                    parser.addParserWarning(\"msg.jsdoc.noalias\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_COMPILE:\n                                 if (!jsdocBuilder.recordNoCompile()) {\n-                                    parser.addWarning(\"msg.jsdoc.nocompile\", stream.getLineno(), stream.getCharno());\n+                                    parser.addParserWarning(\"msg.jsdoc.nocompile\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_TYPE_CHECK:\n                                 if (!jsdocBuilder.recordNoTypeCheck()) {\n-                                    parser.addWarning(\"msg.jsdoc.nocheck\", stream.getLineno(), stream.getCharno());\n+                                    parser.addParserWarning(\"msg.jsdoc.nocheck\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NOT_IMPLEMENTED:\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case INHERIT_DOC:\n                             case OVERRIDE:\n                                 if (!jsdocBuilder.recordOverride()) {\n-                                    parser.addWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno());\n+                                    parser.addTypeWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case THROWS:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                     if (type \u003d\u003d null) {\n                                         token \u003d eatTokensUntilEOL();\n                                         continue retry;\n                                     }\n                                 }\n                                 token \u003d current();\n                                 jsdocBuilder.recordThrowType(type);\n                                 if (jsdocBuilder.shouldParseDocumentation()) {\n                                     ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                     String description \u003d descriptionInfo.string;\n                                     if (description.length() \u003e 0) {\n                                         jsdocBuilder.recordThrowDescription(type, description);\n                                     }\n                                     token \u003d descriptionInfo.token;\n                                 } else {\n                                     token \u003d eatTokensUntilEOL(token);\n                                 }\n                                 continue retry;\n                             case PARAM:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordParamTypeNode(token));\n                                     if (type \u003d\u003d null) {\n                                         token \u003d eatTokensUntilEOL();\n                                         continue retry;\n                                     }\n                                     skipEOLs();\n                                     token \u003d next();\n                                     lineno \u003d stream.getLineno();\n                                     charno \u003d stream.getCharno();\n                                 }\n                                 String name \u003d null;\n                                 boolean isBracketedParam \u003d JsDocToken.LB \u003d\u003d token;\n                                 if (isBracketedParam) {\n                                     token \u003d next();\n                                 }\n                                 if (JsDocToken.STRING !\u003d token) {\n-                                    parser.addWarning(\"msg.missing.variable.name\", lineno, charno);\n+                                    parser.addTypeWarning(\"msg.missing.variable.name\", lineno, charno);\n                                 } else {\n                                     name \u003d stream.getString();\n                                     if (isBracketedParam) {\n                                         token \u003d next();\n                                         if (JsDocToken.EQUALS \u003d\u003d token) {\n                                             token \u003d next();\n                                             if (JsDocToken.STRING \u003d\u003d token) {\n                                                 token \u003d next();\n                                             }\n                                         }\n                                         if (JsDocToken.RB !\u003d token) {\n                                             reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                                         } else if (type !\u003d null) {\n                                             type \u003d JSTypeExpression.makeOptionalArg(type);\n                                         }\n                                     }\n                                     if (name.indexOf(\u0027.\u0027) \u003e -1) {\n                                         name \u003d null;\n                                     } else if (!jsdocBuilder.recordParameter(name, type)) {\n                                         if (jsdocBuilder.hasParameter(name)) {\n-                                            parser.addWarning(\"msg.dup.variable.name\", name, lineno, charno);\n+                                            parser.addTypeWarning(\"msg.dup.variable.name\", name, lineno, charno);\n                                         } else {\n-                                            parser.addWarning(\"msg.jsdoc.incompat.type\", name, lineno, charno);\n+                                            parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name, lineno, charno);\n                                         }\n                                     }\n                                 }\n                                 if (name \u003d\u003d null) {\n                                     token \u003d eatTokensUntilEOL(token);\n                                     continue retry;\n                                 }\n                                 jsdocBuilder.markName(name, lineno, charno);\n                                 if (jsdocBuilder.shouldParseDocumentation()) {\n                                     ExtractionInfo paramDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                     String paramDescription \u003d paramDescriptionInfo.string;\n                                     if (paramDescription.length() \u003e 0) {\n                                         jsdocBuilder.recordParameterDescription(name, paramDescription);\n                                     }\n                                     token \u003d paramDescriptionInfo.token;\n                                 } else {\n                                     token \u003d eatTokensUntilEOL(token);\n                                 }\n                                 continue retry;\n                             case PRESERVE_TRY:\n                                 if (!jsdocBuilder.recordPreserveTry()) {\n-                                    parser.addWarning(\"msg.jsdoc.preservertry\", stream.getLineno(), stream.getCharno());\n+                                    parser.addParserWarning(\"msg.jsdoc.preservertry\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PRIVATE:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n-                                    parser.addWarning(\"msg.jsdoc.visibility.private\", stream.getLineno(), stream.getCharno());\n+                                    parser.addParserWarning(\"msg.jsdoc.visibility.private\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PROTECTED:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n-                                    parser.addWarning(\"msg.jsdoc.visibility.protected\", stream.getLineno(), stream.getCharno());\n+                                    parser.addParserWarning(\"msg.jsdoc.visibility.protected\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PUBLIC:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n-                                    parser.addWarning(\"msg.jsdoc.visibility.public\", stream.getLineno(), stream.getCharno());\n+                                    parser.addParserWarning(\"msg.jsdoc.visibility.public\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_SHADOW:\n                                 if (!jsdocBuilder.recordNoShadow()) {\n-                                    parser.addWarning(\"msg.jsdoc.noshadow\", stream.getLineno(), stream.getCharno());\n+                                    parser.addParserWarning(\"msg.jsdoc.noshadow\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_SIDE_EFFECTS:\n                                 if (!jsdocBuilder.recordNoSideEffects()) {\n-                                    parser.addWarning(\"msg.jsdoc.nosideeffects\", stream.getLineno(), stream.getCharno());\n+                                    parser.addParserWarning(\"msg.jsdoc.nosideeffects\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case MODIFIES:\n                                 token \u003d parseModifiesTag(next());\n                                 continue retry;\n                             case IMPLICIT_CAST:\n                                 if (!jsdocBuilder.recordImplicitCast()) {\n-                                    parser.addWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno());\n+                                    parser.addTypeWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case SEE:\n                                 if (jsdocBuilder.shouldParseDocumentation()) {\n                                     ExtractionInfo referenceInfo \u003d extractSingleLineBlock();\n                                     String reference \u003d referenceInfo.string;\n                                     if (reference.length() \u003d\u003d 0) {\n-                                        parser.addWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno());\n+                                        parser.addParserWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno());\n                                     } else {\n                                         jsdocBuilder.addReference(reference);\n                                     }\n                                     token \u003d referenceInfo.token;\n                                 } else {\n                                     token \u003d eatTokensUntilEOL(token);\n                                 }\n                                 continue retry;\n                             case SUPPRESS:\n                                 token \u003d parseSuppressTag(next());\n                                 continue retry;\n                             case TEMPLATE:\n                                 ExtractionInfo templateInfo \u003d extractSingleLineBlock();\n                                 String templateTypeName \u003d templateInfo.string;\n                                 if (templateTypeName.length() \u003d\u003d 0) {\n-                                    parser.addWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno());\n+                                    parser.addTypeWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno());\n                                 } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {\n-                                    parser.addWarning(\"msg.jsdoc.template.at.most.once\", stream.getLineno(), stream.getCharno());\n+                                    parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d templateInfo.token;\n                                 continue retry;\n                             case VERSION:\n                                 ExtractionInfo versionInfo \u003d extractSingleLineBlock();\n                                 String version \u003d versionInfo.string;\n                                 if (version.length() \u003d\u003d 0) {\n-                                    parser.addWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno());\n+                                    parser.addParserWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno());\n                                 } else {\n                                     if (!jsdocBuilder.recordVersion(version)) {\n-                                        parser.addWarning(\"msg.jsdoc.extraversion\", stream.getLineno(), stream.getCharno());\n+                                        parser.addParserWarning(\"msg.jsdoc.extraversion\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d versionInfo.token;\n                                 continue retry;\n                             case DEFINE:\n                             case RETURN:\n                             case THIS:\n                             case TYPE:\n                             case TYPEDEF:\n                                 skipEOLs();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 token \u003d next();\n                                 Node typeNode \u003d parseAndRecordTypeNode(token, lineno, charno);\n                                 if (annotation \u003d\u003d Annotation.THIS) {\n                                     typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                     if (typeNode !\u003d null \u0026\u0026 token !\u003d JsDocToken.LC) {\n                                         typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                     }\n                                 }\n                                 type \u003d createJSTypeExpression(typeNode);\n                                 if (type \u003d\u003d null) {\n                                 } else {\n                                     switch(annotation) {\n                                         case DEFINE:\n                                             if (!jsdocBuilder.recordDefineType(type)) {\n-                                                parser.addWarning(\"msg.jsdoc.define\", lineno, charno);\n+                                                parser.addParserWarning(\"msg.jsdoc.define\", lineno, charno);\n                                             }\n                                             break;\n                                         case RETURN:\n                                             if (!jsdocBuilder.recordReturnType(type)) {\n-                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n+                                                parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                                 break;\n                                             }\n                                             token \u003d current();\n                                             if (jsdocBuilder.shouldParseDocumentation()) {\n                                                 ExtractionInfo returnDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                                 String returnDescription \u003d returnDescriptionInfo.string;\n                                                 if (returnDescription.length() \u003e 0) {\n                                                     jsdocBuilder.recordReturnDescription(returnDescription);\n                                                 }\n                                                 token \u003d returnDescriptionInfo.token;\n                                             } else {\n                                                 token \u003d eatTokensUntilEOL(token);\n                                             }\n                                             continue retry;\n                                         case THIS:\n                                             if (!jsdocBuilder.recordThisType(type)) {\n-                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n+                                                parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                         case TYPE:\n                                             if (!jsdocBuilder.recordType(type)) {\n-                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n+                                                parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                         case TYPEDEF:\n                                             if (!jsdocBuilder.recordTypedef(type)) {\n-                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n+                                                parser.addTypeWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                     }\n                                     token \u003d eatTokensUntilEOL();\n                                 }\n                                 continue retry;\n                         }\n                     }\n                 }\n                 break;\n             case EOC:\n                 if (hasParsedFileOverviewDocInfo()) {\n                     fileOverviewJSDocInfo \u003d retrieveAndResetParsedJSDocInfo();\n                 }\n                 return true;\n             case EOF:\n                 jsdocBuilder.build(null);\n-                parser.addWarning(\"msg.unexpected.eof\", stream.getLineno(), stream.getCharno());\n+                parser.addParserWarning(\"msg.unexpected.eof\", stream.getLineno(), stream.getCharno());\n                 return false;\n             case EOL:\n                 if (state \u003d\u003d State.SEARCHING_NEWLINE) {\n                     state \u003d State.SEARCHING_ANNOTATION;\n                 }\n                 token \u003d next();\n                 continue retry;\n             default:\n                 if (token \u003d\u003d JsDocToken.STAR \u0026\u0026 state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                     token \u003d next();\n                     continue retry;\n                 } else {\n                     state \u003d State.SEARCHING_NEWLINE;\n                     token \u003d eatTokensUntilEOL();\n                     continue retry;\n                 }\n         }\n         token \u003d next();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "11e59819ec6134736004cebf264b030517a7bff1": {
      "type": "Ybodychange",
      "commitMessage": "\nAllow type names to be split across multiple lines.\nTo avoid parsing ambiguities, we insist that the type name must\nend in a \u0027.\u0027 to get this behavior.\n\nR\u003dacleung\nDELTA\u003d49  (40 added, 0 deleted, 9 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d579\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@802 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "2/22/11, 6:33 AM",
      "commitName": "11e59819ec6134736004cebf264b030517a7bff1",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "2/8/11, 9:38 PM",
      "commitNameOld": "d38121222cc7c1d5e8dd2c34dcea4c2dc7468450",
      "commitAuthorOld": "kochi@google.com",
      "daysBetweenCommits": 13.37,
      "commitsBetweenForRepo": 31,
      "commitsBetweenForFile": 1,
      "actualSource": "boolean parse() {\n    int lineno;\n    int charno;\n    JSTypeExpression type;\n    state \u003d State.SEARCHING_ANNOTATION;\n    skipEOLs();\n    JsDocToken token \u003d next();\n    if (jsdocBuilder.shouldParseDocumentation()) {\n        ExtractionInfo blockInfo \u003d extractBlockComment(token);\n        token \u003d blockInfo.token;\n        if (!blockInfo.string.isEmpty()) {\n            jsdocBuilder.recordBlockDescription(blockInfo.string);\n        }\n    } else {\n        if (token !\u003d JsDocToken.ANNOTATION \u0026\u0026 token !\u003d JsDocToken.EOC) {\n            jsdocBuilder.recordBlockDescription(\"\");\n        }\n    }\n    retry: for (; ; ) {\n        switch(token) {\n            case ANNOTATION:\n                if (state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                    state \u003d State.SEARCHING_NEWLINE;\n                    lineno \u003d stream.getLineno();\n                    charno \u003d stream.getCharno();\n                    String annotationName \u003d stream.getString();\n                    Annotation annotation \u003d annotationNames.get(annotationName);\n                    if (annotation \u003d\u003d null) {\n                        parser.addWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno());\n                    } else {\n                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n                        switch(annotation) {\n                            case AUTHOR:\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo authorInfo \u003d extractSingleLineBlock();\n                                    String author \u003d authorInfo.string;\n                                    if (author.length() \u003d\u003d 0) {\n                                        parser.addWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        jsdocBuilder.addAuthor(author);\n                                    }\n                                    token \u003d authorInfo.token;\n                                } else {\n                                    token \u003d eatTokensUntilEOL(token);\n                                }\n                                continue retry;\n                            case CONSTANT:\n                                if (!jsdocBuilder.recordConstancy()) {\n                                    parser.addWarning(\"msg.jsdoc.const\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case CONSTRUCTOR:\n                                if (!jsdocBuilder.recordConstructor()) {\n                                    if (jsdocBuilder.isInterfaceRecorded()) {\n                                        parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case DEPRECATED:\n                                if (!jsdocBuilder.recordDeprecated()) {\n                                    parser.addWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno());\n                                }\n                                ExtractionInfo reasonInfo \u003d extractMultilineTextualBlock(token);\n                                String reason \u003d reasonInfo.string;\n                                if (reason.length() \u003e 0) {\n                                    jsdocBuilder.recordDeprecationReason(reason);\n                                }\n                                token \u003d reasonInfo.token;\n                                continue retry;\n                            case INTERFACE:\n                                if (!jsdocBuilder.recordInterface()) {\n                                    if (jsdocBuilder.isConstructorRecorded()) {\n                                        parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case DESC:\n                                if (jsdocBuilder.isDescriptionRecorded()) {\n                                    parser.addWarning(\"msg.jsdoc.desc.extra\", stream.getLineno(), stream.getCharno());\n                                    token \u003d eatTokensUntilEOL();\n                                    continue retry;\n                                } else {\n                                    ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                    String description \u003d descriptionInfo.string;\n                                    jsdocBuilder.recordDescription(description);\n                                    token \u003d descriptionInfo.token;\n                                    continue retry;\n                                }\n                            case FILE_OVERVIEW:\n                                String fileOverview \u003d \"\";\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo fileOverviewInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.TRIM);\n                                    fileOverview \u003d fileOverviewInfo.string;\n                                    token \u003d fileOverviewInfo.token;\n                                } else {\n                                    token \u003d eatTokensUntilEOL(token);\n                                }\n                                if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo !\u003d null) {\n                                    parser.addWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno());\n                                }\n                                continue retry;\n                            case LICENSE:\n                            case PRESERVE:\n                                ExtractionInfo preserveInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);\n                                String preserve \u003d preserveInfo.string;\n                                if (preserve.length() \u003e 0) {\n                                    if (fileLevelJsDocBuilder !\u003d null) {\n                                        fileLevelJsDocBuilder.append(preserve);\n                                    }\n                                }\n                                token \u003d preserveInfo.token;\n                                continue retry;\n                            case ENUM:\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                }\n                                if (type \u003d\u003d null) {\n                                    type \u003d createJSTypeExpression(newStringNode(\"number\"));\n                                }\n                                if (!jsdocBuilder.recordEnumParameterType(type)) {\n                                    parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                }\n                                token \u003d eatTokensUntilEOL(token);\n                                continue retry;\n                            case EXPORT:\n                                if (!jsdocBuilder.recordExport()) {\n                                    parser.addWarning(\"msg.jsdoc.export\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case EXTERNS:\n                                if (!jsdocBuilder.recordExterns()) {\n                                    parser.addWarning(\"msg.jsdoc.externs\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case JAVA_DISPATCH:\n                                if (!jsdocBuilder.recordJavaDispatch()) {\n                                    parser.addWarning(\"msg.jsdoc.javadispatch\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case EXTENDS:\n                            case IMPLEMENTS:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                boolean matchingRc \u003d false;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    token \u003d next();\n                                    matchingRc \u003d true;\n                                }\n                                if (token \u003d\u003d JsDocToken.STRING) {\n                                    Node typeNode \u003d parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);\n                                    lineno \u003d stream.getLineno();\n                                    charno \u003d stream.getCharno();\n                                    typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                    if (typeNode !\u003d null \u0026\u0026 !matchingRc) {\n                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                    }\n                                    type \u003d createJSTypeExpression(typeNode);\n                                    if (annotation \u003d\u003d Annotation.EXTENDS) {\n                                        if (!jsdocBuilder.recordBaseType(type)) {\n                                            parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                        }\n                                    } else {\n                                        Preconditions.checkState(annotation \u003d\u003d Annotation.IMPLEMENTS);\n                                        if (!jsdocBuilder.recordImplementedInterface(type)) {\n                                            parser.addWarning(\"msg.jsdoc.implements.duplicate\", lineno, charno);\n                                        }\n                                    }\n                                    token \u003d next();\n                                    if (matchingRc) {\n                                        if (token !\u003d JsDocToken.RC) {\n                                            parser.addWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                        }\n                                    } else if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOF \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                        parser.addWarning(\"msg.end.annotation.expected\", stream.getLineno(), stream.getCharno());\n                                    }\n                                } else {\n                                    parser.addWarning(\"msg.no.type.name\", lineno, charno);\n                                }\n                                token \u003d eatTokensUntilEOL(token);\n                                continue retry;\n                            case HIDDEN:\n                                if (!jsdocBuilder.recordHiddenness()) {\n                                    parser.addWarning(\"msg.jsdoc.hidden\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case LENDS:\n                                skipEOLs();\n                                matchingRc \u003d false;\n                                if (match(JsDocToken.LC)) {\n                                    token \u003d next();\n                                    matchingRc \u003d true;\n                                }\n                                if (match(JsDocToken.STRING)) {\n                                    token \u003d next();\n                                    if (!jsdocBuilder.recordLends(stream.getString())) {\n                                        parser.addWarning(\"msg.jsdoc.lends.incompatible\", stream.getLineno(), stream.getCharno());\n                                    }\n                                } else {\n                                    parser.addWarning(\"msg.jsdoc.lends.missing\", stream.getLineno(), stream.getCharno());\n                                }\n                                if (matchingRc \u0026\u0026 !match(JsDocToken.RC)) {\n                                    parser.addWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case MEANING:\n                                ExtractionInfo meaningInfo \u003d extractMultilineTextualBlock(token);\n                                String meaning \u003d meaningInfo.string;\n                                token \u003d meaningInfo.token;\n                                if (!jsdocBuilder.recordMeaning(meaning)) {\n                                    parser.addWarning(\"msg.jsdoc.meaning.extra\", stream.getLineno(), stream.getCharno());\n                                }\n                                continue retry;\n                            case NO_ALIAS:\n                                if (!jsdocBuilder.recordNoAlias()) {\n                                    parser.addWarning(\"msg.jsdoc.noalias\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_COMPILE:\n                                if (!jsdocBuilder.recordNoCompile()) {\n                                    parser.addWarning(\"msg.jsdoc.nocompile\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_TYPE_CHECK:\n                                if (!jsdocBuilder.recordNoTypeCheck()) {\n                                    parser.addWarning(\"msg.jsdoc.nocheck\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NOT_IMPLEMENTED:\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case INHERIT_DOC:\n                            case OVERRIDE:\n                                if (!jsdocBuilder.recordOverride()) {\n                                    parser.addWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case THROWS:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                    if (type \u003d\u003d null) {\n                                        token \u003d eatTokensUntilEOL();\n                                        continue retry;\n                                    }\n                                }\n                                token \u003d current();\n                                jsdocBuilder.recordThrowType(type);\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                    String description \u003d descriptionInfo.string;\n                                    if (description.length() \u003e 0) {\n                                        jsdocBuilder.recordThrowDescription(type, description);\n                                    }\n                                    token \u003d descriptionInfo.token;\n                                } else {\n                                    token \u003d eatTokensUntilEOL(token);\n                                }\n                                continue retry;\n                            case PARAM:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordParamTypeNode(token));\n                                    if (type \u003d\u003d null) {\n                                        token \u003d eatTokensUntilEOL();\n                                        continue retry;\n                                    }\n                                    skipEOLs();\n                                    token \u003d next();\n                                    lineno \u003d stream.getLineno();\n                                    charno \u003d stream.getCharno();\n                                }\n                                String name \u003d null;\n                                boolean isBracketedParam \u003d JsDocToken.LB \u003d\u003d token;\n                                if (isBracketedParam) {\n                                    token \u003d next();\n                                }\n                                if (JsDocToken.STRING !\u003d token) {\n                                    parser.addWarning(\"msg.missing.variable.name\", lineno, charno);\n                                } else {\n                                    name \u003d stream.getString();\n                                    if (isBracketedParam) {\n                                        token \u003d next();\n                                        if (JsDocToken.EQUALS \u003d\u003d token) {\n                                            token \u003d next();\n                                            if (JsDocToken.STRING \u003d\u003d token) {\n                                                token \u003d next();\n                                            }\n                                        }\n                                        if (JsDocToken.RB !\u003d token) {\n                                            reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                                        } else if (type !\u003d null) {\n                                            type \u003d JSTypeExpression.makeOptionalArg(type);\n                                        }\n                                    }\n                                    if (name.indexOf(\u0027.\u0027) \u003e -1) {\n                                        name \u003d null;\n                                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                                        if (jsdocBuilder.hasParameter(name)) {\n                                            parser.addWarning(\"msg.dup.variable.name\", name, lineno, charno);\n                                        } else {\n                                            parser.addWarning(\"msg.jsdoc.incompat.type\", name, lineno, charno);\n                                        }\n                                    }\n                                }\n                                if (name \u003d\u003d null) {\n                                    token \u003d eatTokensUntilEOL(token);\n                                    continue retry;\n                                }\n                                jsdocBuilder.markName(name, lineno, charno);\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo paramDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                    String paramDescription \u003d paramDescriptionInfo.string;\n                                    if (paramDescription.length() \u003e 0) {\n                                        jsdocBuilder.recordParameterDescription(name, paramDescription);\n                                    }\n                                    token \u003d paramDescriptionInfo.token;\n                                } else {\n                                    token \u003d eatTokensUntilEOL(token);\n                                }\n                                continue retry;\n                            case PRESERVE_TRY:\n                                if (!jsdocBuilder.recordPreserveTry()) {\n                                    parser.addWarning(\"msg.jsdoc.preservertry\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PRIVATE:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                                    parser.addWarning(\"msg.jsdoc.visibility.private\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PROTECTED:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                                    parser.addWarning(\"msg.jsdoc.visibility.protected\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PUBLIC:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                                    parser.addWarning(\"msg.jsdoc.visibility.public\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_SHADOW:\n                                if (!jsdocBuilder.recordNoShadow()) {\n                                    parser.addWarning(\"msg.jsdoc.noshadow\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_SIDE_EFFECTS:\n                                if (!jsdocBuilder.recordNoSideEffects()) {\n                                    parser.addWarning(\"msg.jsdoc.nosideeffects\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case MODIFIES:\n                                token \u003d parseModifiesTag(next());\n                                continue retry;\n                            case IMPLICIT_CAST:\n                                if (!jsdocBuilder.recordImplicitCast()) {\n                                    parser.addWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case SEE:\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo referenceInfo \u003d extractSingleLineBlock();\n                                    String reference \u003d referenceInfo.string;\n                                    if (reference.length() \u003d\u003d 0) {\n                                        parser.addWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        jsdocBuilder.addReference(reference);\n                                    }\n                                    token \u003d referenceInfo.token;\n                                } else {\n                                    token \u003d eatTokensUntilEOL(token);\n                                }\n                                continue retry;\n                            case SUPPRESS:\n                                token \u003d parseSuppressTag(next());\n                                continue retry;\n                            case TEMPLATE:\n                                ExtractionInfo templateInfo \u003d extractSingleLineBlock();\n                                String templateTypeName \u003d templateInfo.string;\n                                if (templateTypeName.length() \u003d\u003d 0) {\n                                    parser.addWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno());\n                                } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {\n                                    parser.addWarning(\"msg.jsdoc.template.at.most.once\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d templateInfo.token;\n                                continue retry;\n                            case VERSION:\n                                ExtractionInfo versionInfo \u003d extractSingleLineBlock();\n                                String version \u003d versionInfo.string;\n                                if (version.length() \u003d\u003d 0) {\n                                    parser.addWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno());\n                                } else {\n                                    if (!jsdocBuilder.recordVersion(version)) {\n                                        parser.addWarning(\"msg.jsdoc.extraversion\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d versionInfo.token;\n                                continue retry;\n                            case DEFINE:\n                            case RETURN:\n                            case THIS:\n                            case TYPE:\n                            case TYPEDEF:\n                                skipEOLs();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                token \u003d next();\n                                Node typeNode \u003d parseAndRecordTypeNode(token, lineno, charno);\n                                if (annotation \u003d\u003d Annotation.THIS) {\n                                    typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                    if (typeNode !\u003d null \u0026\u0026 token !\u003d JsDocToken.LC) {\n                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                    }\n                                }\n                                type \u003d createJSTypeExpression(typeNode);\n                                if (type \u003d\u003d null) {\n                                } else {\n                                    switch(annotation) {\n                                        case DEFINE:\n                                            if (!jsdocBuilder.recordDefineType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.define\", lineno, charno);\n                                            }\n                                            break;\n                                        case RETURN:\n                                            if (!jsdocBuilder.recordReturnType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                                break;\n                                            }\n                                            token \u003d current();\n                                            if (jsdocBuilder.shouldParseDocumentation()) {\n                                                ExtractionInfo returnDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                                String returnDescription \u003d returnDescriptionInfo.string;\n                                                if (returnDescription.length() \u003e 0) {\n                                                    jsdocBuilder.recordReturnDescription(returnDescription);\n                                                }\n                                                token \u003d returnDescriptionInfo.token;\n                                            } else {\n                                                token \u003d eatTokensUntilEOL(token);\n                                            }\n                                            continue retry;\n                                        case THIS:\n                                            if (!jsdocBuilder.recordThisType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                        case TYPE:\n                                            if (!jsdocBuilder.recordType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                        case TYPEDEF:\n                                            if (!jsdocBuilder.recordTypedef(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                    }\n                                    token \u003d eatTokensUntilEOL();\n                                }\n                                continue retry;\n                        }\n                    }\n                }\n                break;\n            case EOC:\n                if (hasParsedFileOverviewDocInfo()) {\n                    fileOverviewJSDocInfo \u003d retrieveAndResetParsedJSDocInfo();\n                }\n                return true;\n            case EOF:\n                jsdocBuilder.build(null);\n                parser.addWarning(\"msg.unexpected.eof\", stream.getLineno(), stream.getCharno());\n                return false;\n            case EOL:\n                if (state \u003d\u003d State.SEARCHING_NEWLINE) {\n                    state \u003d State.SEARCHING_ANNOTATION;\n                }\n                token \u003d next();\n                continue retry;\n            default:\n                if (token \u003d\u003d JsDocToken.STAR \u0026\u0026 state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                    token \u003d next();\n                    continue retry;\n                } else {\n                    state \u003d State.SEARCHING_NEWLINE;\n                    token \u003d eatTokensUntilEOL();\n                    continue retry;\n                }\n        }\n        token \u003d next();\n    }\n}",
      "path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
      "functionStartLine": 150,
      "functionName": "parse",
      "functionAnnotation": "",
      "functionDoc": "Parses a {@link JSDocInfo} object. This parsing method reads all tokens\nreturned by the {@link JsDocTokenStream#getJsDocToken()} method until the\n{@link JsDocToken#EOC} is returned.\n\n@return @code true} if JSDoc information was correctly parsed,\n    {@code false} otherwise\n",
      "diff": "",
      "extendedDetails": {}
    },
    "9d72612f028076aa43a9b259c29b2a940398465f": {
      "type": "Ybodychange",
      "commitMessage": "\nAdd parsing logic for the lends annotation.\n\nR\u003djohnlenz\nDELTA\u003d100  (99 added, 0 deleted, 1 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d283472\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@473 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "10/1/10, 1:41 PM",
      "commitName": "9d72612f028076aa43a9b259c29b2a940398465f",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "9/22/10, 4:19 PM",
      "commitNameOld": "eb3e25de7fc6ee4858b9805519c0dc7a13e1b183",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 8.89,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "actualSource": "boolean parse() {\n    int lineno;\n    int charno;\n    JSTypeExpression type;\n    state \u003d State.SEARCHING_ANNOTATION;\n    skipEOLs();\n    JsDocToken token \u003d next();\n    if (jsdocBuilder.shouldParseDocumentation()) {\n        ExtractionInfo blockInfo \u003d extractBlockComment(token);\n        token \u003d blockInfo.token;\n        if (!blockInfo.string.isEmpty()) {\n            jsdocBuilder.recordBlockDescription(blockInfo.string);\n        }\n    } else {\n        if (token !\u003d JsDocToken.ANNOTATION \u0026\u0026 token !\u003d JsDocToken.EOC) {\n            jsdocBuilder.recordBlockDescription(\"\");\n        }\n    }\n    retry: for (; ; ) {\n        switch(token) {\n            case ANNOTATION:\n                if (state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                    state \u003d State.SEARCHING_NEWLINE;\n                    lineno \u003d stream.getLineno();\n                    charno \u003d stream.getCharno();\n                    String annotationName \u003d stream.getString();\n                    Annotation annotation \u003d annotationNames.get(annotationName);\n                    if (annotation \u003d\u003d null) {\n                        parser.addWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno());\n                    } else {\n                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n                        switch(annotation) {\n                            case AUTHOR:\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo authorInfo \u003d extractSingleLineBlock();\n                                    String author \u003d authorInfo.string;\n                                    if (author.length() \u003d\u003d 0) {\n                                        parser.addWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        jsdocBuilder.addAuthor(author);\n                                    }\n                                    token \u003d authorInfo.token;\n                                } else {\n                                    token \u003d eatTokensUntilEOL(token);\n                                }\n                                continue retry;\n                            case CONSTANT:\n                                if (!jsdocBuilder.recordConstancy()) {\n                                    parser.addWarning(\"msg.jsdoc.const\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case CONSTRUCTOR:\n                                if (!jsdocBuilder.recordConstructor()) {\n                                    if (jsdocBuilder.isInterfaceRecorded()) {\n                                        parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case DEPRECATED:\n                                if (!jsdocBuilder.recordDeprecated()) {\n                                    parser.addWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno());\n                                }\n                                ExtractionInfo reasonInfo \u003d extractMultilineTextualBlock(token);\n                                String reason \u003d reasonInfo.string;\n                                if (reason.length() \u003e 0) {\n                                    jsdocBuilder.recordDeprecationReason(reason);\n                                }\n                                token \u003d reasonInfo.token;\n                                continue retry;\n                            case INTERFACE:\n                                if (!jsdocBuilder.recordInterface()) {\n                                    if (jsdocBuilder.isConstructorRecorded()) {\n                                        parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case DESC:\n                                if (jsdocBuilder.isDescriptionRecorded()) {\n                                    parser.addWarning(\"msg.jsdoc.desc.extra\", stream.getLineno(), stream.getCharno());\n                                    token \u003d eatTokensUntilEOL();\n                                    continue retry;\n                                } else {\n                                    ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                    String description \u003d descriptionInfo.string;\n                                    jsdocBuilder.recordDescription(description);\n                                    token \u003d descriptionInfo.token;\n                                    continue retry;\n                                }\n                            case FILE_OVERVIEW:\n                                String fileOverview \u003d \"\";\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo fileOverviewInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.TRIM);\n                                    fileOverview \u003d fileOverviewInfo.string;\n                                    token \u003d fileOverviewInfo.token;\n                                } else {\n                                    token \u003d eatTokensUntilEOL(token);\n                                }\n                                if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo !\u003d null) {\n                                    parser.addWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno());\n                                }\n                                continue retry;\n                            case LICENSE:\n                            case PRESERVE:\n                                ExtractionInfo preserveInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);\n                                String preserve \u003d preserveInfo.string;\n                                if (preserve.length() \u003e 0) {\n                                    if (fileLevelJsDocBuilder !\u003d null) {\n                                        fileLevelJsDocBuilder.append(preserve);\n                                    }\n                                }\n                                token \u003d preserveInfo.token;\n                                continue retry;\n                            case ENUM:\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                }\n                                if (type \u003d\u003d null) {\n                                    type \u003d createJSTypeExpression(newStringNode(\"number\"));\n                                }\n                                if (!jsdocBuilder.recordEnumParameterType(type)) {\n                                    parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                }\n                                token \u003d eatTokensUntilEOL(token);\n                                continue retry;\n                            case EXPORT:\n                                if (!jsdocBuilder.recordExport()) {\n                                    parser.addWarning(\"msg.jsdoc.export\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case EXTERNS:\n                                if (!jsdocBuilder.recordExterns()) {\n                                    parser.addWarning(\"msg.jsdoc.externs\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case JAVA_DISPATCH:\n                                if (!jsdocBuilder.recordJavaDispatch()) {\n                                    parser.addWarning(\"msg.jsdoc.javadispatch\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case EXTENDS:\n                            case IMPLEMENTS:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                boolean matchingRc \u003d false;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    token \u003d next();\n                                    matchingRc \u003d true;\n                                }\n                                if (token \u003d\u003d JsDocToken.STRING) {\n                                    Node typeNode \u003d parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);\n                                    lineno \u003d stream.getLineno();\n                                    charno \u003d stream.getCharno();\n                                    typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                    if (typeNode !\u003d null \u0026\u0026 !matchingRc) {\n                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                    }\n                                    type \u003d createJSTypeExpression(typeNode);\n                                    if (annotation \u003d\u003d Annotation.EXTENDS) {\n                                        if (!jsdocBuilder.recordBaseType(type)) {\n                                            parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                        }\n                                    } else {\n                                        Preconditions.checkState(annotation \u003d\u003d Annotation.IMPLEMENTS);\n                                        if (!jsdocBuilder.recordImplementedInterface(type)) {\n                                            parser.addWarning(\"msg.jsdoc.implements.duplicate\", lineno, charno);\n                                        }\n                                    }\n                                    token \u003d next();\n                                    if (matchingRc) {\n                                        if (token !\u003d JsDocToken.RC) {\n                                            parser.addWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                        }\n                                    } else if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOF \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                        parser.addWarning(\"msg.end.annotation.expected\", stream.getLineno(), stream.getCharno());\n                                    }\n                                } else {\n                                    parser.addWarning(\"msg.no.type.name\", lineno, charno);\n                                }\n                                token \u003d eatTokensUntilEOL(token);\n                                continue retry;\n                            case HIDDEN:\n                                if (!jsdocBuilder.recordHiddenness()) {\n                                    parser.addWarning(\"msg.jsdoc.hidden\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case LENDS:\n                                skipEOLs();\n                                matchingRc \u003d false;\n                                if (match(JsDocToken.LC)) {\n                                    token \u003d next();\n                                    matchingRc \u003d true;\n                                }\n                                if (match(JsDocToken.STRING)) {\n                                    token \u003d next();\n                                    if (!jsdocBuilder.recordLends(stream.getString())) {\n                                        parser.addWarning(\"msg.jsdoc.lends.incompatible\", stream.getLineno(), stream.getCharno());\n                                    }\n                                } else {\n                                    parser.addWarning(\"msg.jsdoc.lends.missing\", stream.getLineno(), stream.getCharno());\n                                }\n                                if (matchingRc \u0026\u0026 !match(JsDocToken.RC)) {\n                                    parser.addWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case MEANING:\n                                ExtractionInfo meaningInfo \u003d extractMultilineTextualBlock(token);\n                                String meaning \u003d meaningInfo.string;\n                                token \u003d meaningInfo.token;\n                                if (!jsdocBuilder.recordMeaning(meaning)) {\n                                    parser.addWarning(\"msg.jsdoc.meaning.extra\", stream.getLineno(), stream.getCharno());\n                                }\n                                continue retry;\n                            case NO_ALIAS:\n                                if (!jsdocBuilder.recordNoAlias()) {\n                                    parser.addWarning(\"msg.jsdoc.noalias\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_COMPILE:\n                                if (!jsdocBuilder.recordNoCompile()) {\n                                    parser.addWarning(\"msg.jsdoc.nocompile\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_TYPE_CHECK:\n                                if (!jsdocBuilder.recordNoTypeCheck()) {\n                                    parser.addWarning(\"msg.jsdoc.nocheck\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NOT_IMPLEMENTED:\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case INHERIT_DOC:\n                            case OVERRIDE:\n                                if (!jsdocBuilder.recordOverride()) {\n                                    parser.addWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case THROWS:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                    if (type \u003d\u003d null) {\n                                        token \u003d eatTokensUntilEOL();\n                                        continue retry;\n                                    }\n                                }\n                                token \u003d current();\n                                jsdocBuilder.recordThrowType(type);\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                    String description \u003d descriptionInfo.string;\n                                    if (description.length() \u003e 0) {\n                                        jsdocBuilder.recordThrowDescription(type, description);\n                                    }\n                                    token \u003d descriptionInfo.token;\n                                } else {\n                                    token \u003d eatTokensUntilEOL(token);\n                                }\n                                continue retry;\n                            case PARAM:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordParamTypeNode(token));\n                                    if (type \u003d\u003d null) {\n                                        token \u003d eatTokensUntilEOL();\n                                        continue retry;\n                                    }\n                                    skipEOLs();\n                                    token \u003d next();\n                                    lineno \u003d stream.getLineno();\n                                    charno \u003d stream.getCharno();\n                                }\n                                String name \u003d null;\n                                boolean isBracketedParam \u003d JsDocToken.LB \u003d\u003d token;\n                                if (isBracketedParam) {\n                                    token \u003d next();\n                                }\n                                if (JsDocToken.STRING !\u003d token) {\n                                    parser.addWarning(\"msg.missing.variable.name\", lineno, charno);\n                                } else {\n                                    name \u003d stream.getString();\n                                    if (isBracketedParam) {\n                                        token \u003d next();\n                                        if (JsDocToken.EQUALS \u003d\u003d token) {\n                                            token \u003d next();\n                                            if (JsDocToken.STRING \u003d\u003d token) {\n                                                token \u003d next();\n                                            }\n                                        }\n                                        if (JsDocToken.RB !\u003d token) {\n                                            reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                                        } else if (type !\u003d null) {\n                                            type \u003d JSTypeExpression.makeOptionalArg(type);\n                                        }\n                                    }\n                                    if (name.indexOf(\u0027.\u0027) \u003e -1) {\n                                        name \u003d null;\n                                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                                        if (jsdocBuilder.hasParameter(name)) {\n                                            parser.addWarning(\"msg.dup.variable.name\", name, lineno, charno);\n                                        } else {\n                                            parser.addWarning(\"msg.jsdoc.incompat.type\", name, lineno, charno);\n                                        }\n                                    }\n                                }\n                                if (name \u003d\u003d null) {\n                                    token \u003d eatTokensUntilEOL(token);\n                                    continue retry;\n                                }\n                                jsdocBuilder.markName(name, lineno, charno);\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo paramDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                    String paramDescription \u003d paramDescriptionInfo.string;\n                                    if (paramDescription.length() \u003e 0) {\n                                        jsdocBuilder.recordParameterDescription(name, paramDescription);\n                                    }\n                                    token \u003d paramDescriptionInfo.token;\n                                } else {\n                                    token \u003d eatTokensUntilEOL(token);\n                                }\n                                continue retry;\n                            case PRESERVE_TRY:\n                                if (!jsdocBuilder.recordPreserveTry()) {\n                                    parser.addWarning(\"msg.jsdoc.preservertry\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PRIVATE:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                                    parser.addWarning(\"msg.jsdoc.visibility.private\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PROTECTED:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                                    parser.addWarning(\"msg.jsdoc.visibility.protected\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PUBLIC:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                                    parser.addWarning(\"msg.jsdoc.visibility.public\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_SHADOW:\n                                if (!jsdocBuilder.recordNoShadow()) {\n                                    parser.addWarning(\"msg.jsdoc.noshadow\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_SIDE_EFFECTS:\n                                if (!jsdocBuilder.recordNoSideEffects()) {\n                                    parser.addWarning(\"msg.jsdoc.nosideeffects\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case MODIFIES:\n                                token \u003d parseModifiesTag(next());\n                                continue retry;\n                            case IMPLICIT_CAST:\n                                if (!jsdocBuilder.recordImplicitCast()) {\n                                    parser.addWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case SEE:\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo referenceInfo \u003d extractSingleLineBlock();\n                                    String reference \u003d referenceInfo.string;\n                                    if (reference.length() \u003d\u003d 0) {\n                                        parser.addWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        jsdocBuilder.addReference(reference);\n                                    }\n                                    token \u003d referenceInfo.token;\n                                } else {\n                                    token \u003d eatTokensUntilEOL(token);\n                                }\n                                continue retry;\n                            case SUPPRESS:\n                                token \u003d parseSuppressTag(next());\n                                continue retry;\n                            case TEMPLATE:\n                                ExtractionInfo templateInfo \u003d extractSingleLineBlock();\n                                String templateTypeName \u003d templateInfo.string;\n                                if (templateTypeName.length() \u003d\u003d 0) {\n                                    parser.addWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno());\n                                } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {\n                                    parser.addWarning(\"msg.jsdoc.template.at.most.once\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d templateInfo.token;\n                                continue retry;\n                            case VERSION:\n                                ExtractionInfo versionInfo \u003d extractSingleLineBlock();\n                                String version \u003d versionInfo.string;\n                                if (version.length() \u003d\u003d 0) {\n                                    parser.addWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno());\n                                } else {\n                                    if (!jsdocBuilder.recordVersion(version)) {\n                                        parser.addWarning(\"msg.jsdoc.extraversion\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d versionInfo.token;\n                                continue retry;\n                            case DEFINE:\n                            case RETURN:\n                            case THIS:\n                            case TYPE:\n                            case TYPEDEF:\n                                skipEOLs();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                token \u003d next();\n                                Node typeNode \u003d parseAndRecordTypeNode(token, lineno, charno);\n                                if (annotation \u003d\u003d Annotation.THIS) {\n                                    typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                    if (typeNode !\u003d null \u0026\u0026 token !\u003d JsDocToken.LC) {\n                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                    }\n                                }\n                                type \u003d createJSTypeExpression(typeNode);\n                                if (type \u003d\u003d null) {\n                                } else {\n                                    switch(annotation) {\n                                        case DEFINE:\n                                            if (!jsdocBuilder.recordDefineType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.define\", lineno, charno);\n                                            }\n                                            break;\n                                        case RETURN:\n                                            if (!jsdocBuilder.recordReturnType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                                break;\n                                            }\n                                            token \u003d current();\n                                            if (jsdocBuilder.shouldParseDocumentation()) {\n                                                ExtractionInfo returnDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                                String returnDescription \u003d returnDescriptionInfo.string;\n                                                if (returnDescription.length() \u003e 0) {\n                                                    jsdocBuilder.recordReturnDescription(returnDescription);\n                                                }\n                                                token \u003d returnDescriptionInfo.token;\n                                            } else {\n                                                token \u003d eatTokensUntilEOL(token);\n                                            }\n                                            continue retry;\n                                        case THIS:\n                                            if (!jsdocBuilder.recordThisType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                        case TYPE:\n                                            if (!jsdocBuilder.recordType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                        case TYPEDEF:\n                                            if (!jsdocBuilder.recordTypedef(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                    }\n                                    token \u003d eatTokensUntilEOL();\n                                }\n                                continue retry;\n                        }\n                    }\n                }\n                break;\n            case EOC:\n                if (hasParsedFileOverviewDocInfo()) {\n                    fileOverviewJSDocInfo \u003d retrieveAndResetParsedJSDocInfo();\n                }\n                return true;\n            case EOF:\n                jsdocBuilder.build(null);\n                parser.addWarning(\"msg.unexpected.eof\", stream.getLineno(), stream.getCharno());\n                return false;\n            case EOL:\n                if (state \u003d\u003d State.SEARCHING_NEWLINE) {\n                    state \u003d State.SEARCHING_ANNOTATION;\n                }\n                token \u003d next();\n                continue retry;\n            default:\n                if (token \u003d\u003d JsDocToken.STAR \u0026\u0026 state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                    token \u003d next();\n                    continue retry;\n                } else {\n                    state \u003d State.SEARCHING_NEWLINE;\n                    token \u003d eatTokensUntilEOL();\n                    continue retry;\n                }\n        }\n        token \u003d next();\n    }\n}",
      "path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
      "functionStartLine": 137,
      "functionName": "parse",
      "functionAnnotation": "",
      "functionDoc": "Parses a {@link JSDocInfo} object. This parsing method reads all tokens\nreturned by the {@link JsDocTokenStream#getJsDocToken()} method until the\n{@link JsDocToken#EOC} is returned.\n\n@return @code true} if JSDoc information was correctly parsed,\n    {@code false} otherwise\n",
      "diff": "@@ -1,507 +1,527 @@\n boolean parse() {\n     int lineno;\n     int charno;\n     JSTypeExpression type;\n     state \u003d State.SEARCHING_ANNOTATION;\n     skipEOLs();\n     JsDocToken token \u003d next();\n     if (jsdocBuilder.shouldParseDocumentation()) {\n         ExtractionInfo blockInfo \u003d extractBlockComment(token);\n         token \u003d blockInfo.token;\n         if (!blockInfo.string.isEmpty()) {\n             jsdocBuilder.recordBlockDescription(blockInfo.string);\n         }\n     } else {\n         if (token !\u003d JsDocToken.ANNOTATION \u0026\u0026 token !\u003d JsDocToken.EOC) {\n             jsdocBuilder.recordBlockDescription(\"\");\n         }\n     }\n     retry: for (; ; ) {\n         switch(token) {\n             case ANNOTATION:\n                 if (state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                     state \u003d State.SEARCHING_NEWLINE;\n                     lineno \u003d stream.getLineno();\n                     charno \u003d stream.getCharno();\n                     String annotationName \u003d stream.getString();\n                     Annotation annotation \u003d annotationNames.get(annotationName);\n                     if (annotation \u003d\u003d null) {\n                         parser.addWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno());\n                     } else {\n                         jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n                         switch(annotation) {\n                             case AUTHOR:\n                                 if (jsdocBuilder.shouldParseDocumentation()) {\n                                     ExtractionInfo authorInfo \u003d extractSingleLineBlock();\n                                     String author \u003d authorInfo.string;\n                                     if (author.length() \u003d\u003d 0) {\n                                         parser.addWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno());\n                                     } else {\n                                         jsdocBuilder.addAuthor(author);\n                                     }\n                                     token \u003d authorInfo.token;\n                                 } else {\n                                     token \u003d eatTokensUntilEOL(token);\n                                 }\n                                 continue retry;\n                             case CONSTANT:\n                                 if (!jsdocBuilder.recordConstancy()) {\n                                     parser.addWarning(\"msg.jsdoc.const\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case CONSTRUCTOR:\n                                 if (!jsdocBuilder.recordConstructor()) {\n                                     if (jsdocBuilder.isInterfaceRecorded()) {\n                                         parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                     } else {\n                                         parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case DEPRECATED:\n                                 if (!jsdocBuilder.recordDeprecated()) {\n                                     parser.addWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 ExtractionInfo reasonInfo \u003d extractMultilineTextualBlock(token);\n                                 String reason \u003d reasonInfo.string;\n                                 if (reason.length() \u003e 0) {\n                                     jsdocBuilder.recordDeprecationReason(reason);\n                                 }\n                                 token \u003d reasonInfo.token;\n                                 continue retry;\n                             case INTERFACE:\n                                 if (!jsdocBuilder.recordInterface()) {\n                                     if (jsdocBuilder.isConstructorRecorded()) {\n                                         parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                     } else {\n                                         parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case DESC:\n                                 if (jsdocBuilder.isDescriptionRecorded()) {\n                                     parser.addWarning(\"msg.jsdoc.desc.extra\", stream.getLineno(), stream.getCharno());\n                                     token \u003d eatTokensUntilEOL();\n                                     continue retry;\n                                 } else {\n                                     ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                     String description \u003d descriptionInfo.string;\n                                     jsdocBuilder.recordDescription(description);\n                                     token \u003d descriptionInfo.token;\n                                     continue retry;\n                                 }\n                             case FILE_OVERVIEW:\n                                 String fileOverview \u003d \"\";\n                                 if (jsdocBuilder.shouldParseDocumentation()) {\n                                     ExtractionInfo fileOverviewInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.TRIM);\n                                     fileOverview \u003d fileOverviewInfo.string;\n                                     token \u003d fileOverviewInfo.token;\n                                 } else {\n                                     token \u003d eatTokensUntilEOL(token);\n                                 }\n                                 if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo !\u003d null) {\n                                     parser.addWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 continue retry;\n                             case LICENSE:\n                             case PRESERVE:\n                                 ExtractionInfo preserveInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);\n                                 String preserve \u003d preserveInfo.string;\n                                 if (preserve.length() \u003e 0) {\n                                     if (fileLevelJsDocBuilder !\u003d null) {\n                                         fileLevelJsDocBuilder.append(preserve);\n                                     }\n                                 }\n                                 token \u003d preserveInfo.token;\n                                 continue retry;\n                             case ENUM:\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                 }\n                                 if (type \u003d\u003d null) {\n                                     type \u003d createJSTypeExpression(newStringNode(\"number\"));\n                                 }\n                                 if (!jsdocBuilder.recordEnumParameterType(type)) {\n                                     parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                 }\n                                 token \u003d eatTokensUntilEOL(token);\n                                 continue retry;\n                             case EXPORT:\n                                 if (!jsdocBuilder.recordExport()) {\n                                     parser.addWarning(\"msg.jsdoc.export\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case EXTERNS:\n                                 if (!jsdocBuilder.recordExterns()) {\n                                     parser.addWarning(\"msg.jsdoc.externs\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case JAVA_DISPATCH:\n                                 if (!jsdocBuilder.recordJavaDispatch()) {\n                                     parser.addWarning(\"msg.jsdoc.javadispatch\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case EXTENDS:\n                             case IMPLEMENTS:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 boolean matchingRc \u003d false;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     token \u003d next();\n                                     matchingRc \u003d true;\n                                 }\n                                 if (token \u003d\u003d JsDocToken.STRING) {\n                                     Node typeNode \u003d parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);\n                                     lineno \u003d stream.getLineno();\n                                     charno \u003d stream.getCharno();\n                                     typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                     if (typeNode !\u003d null \u0026\u0026 !matchingRc) {\n                                         typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                     }\n                                     type \u003d createJSTypeExpression(typeNode);\n                                     if (annotation \u003d\u003d Annotation.EXTENDS) {\n                                         if (!jsdocBuilder.recordBaseType(type)) {\n                                             parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                         }\n                                     } else {\n                                         Preconditions.checkState(annotation \u003d\u003d Annotation.IMPLEMENTS);\n                                         if (!jsdocBuilder.recordImplementedInterface(type)) {\n                                             parser.addWarning(\"msg.jsdoc.implements.duplicate\", lineno, charno);\n                                         }\n                                     }\n                                     token \u003d next();\n                                     if (matchingRc) {\n                                         if (token !\u003d JsDocToken.RC) {\n                                             parser.addWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                         }\n                                     } else if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOF \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                         parser.addWarning(\"msg.end.annotation.expected\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 } else {\n                                     parser.addWarning(\"msg.no.type.name\", lineno, charno);\n                                 }\n                                 token \u003d eatTokensUntilEOL(token);\n                                 continue retry;\n                             case HIDDEN:\n                                 if (!jsdocBuilder.recordHiddenness()) {\n                                     parser.addWarning(\"msg.jsdoc.hidden\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n+                            case LENDS:\n+                                skipEOLs();\n+                                matchingRc \u003d false;\n+                                if (match(JsDocToken.LC)) {\n+                                    token \u003d next();\n+                                    matchingRc \u003d true;\n+                                }\n+                                if (match(JsDocToken.STRING)) {\n+                                    token \u003d next();\n+                                    if (!jsdocBuilder.recordLends(stream.getString())) {\n+                                        parser.addWarning(\"msg.jsdoc.lends.incompatible\", stream.getLineno(), stream.getCharno());\n+                                    }\n+                                } else {\n+                                    parser.addWarning(\"msg.jsdoc.lends.missing\", stream.getLineno(), stream.getCharno());\n+                                }\n+                                if (matchingRc \u0026\u0026 !match(JsDocToken.RC)) {\n+                                    parser.addWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n+                                }\n+                                token \u003d eatTokensUntilEOL();\n+                                continue retry;\n                             case MEANING:\n                                 ExtractionInfo meaningInfo \u003d extractMultilineTextualBlock(token);\n                                 String meaning \u003d meaningInfo.string;\n                                 token \u003d meaningInfo.token;\n                                 if (!jsdocBuilder.recordMeaning(meaning)) {\n                                     parser.addWarning(\"msg.jsdoc.meaning.extra\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 continue retry;\n                             case NO_ALIAS:\n                                 if (!jsdocBuilder.recordNoAlias()) {\n                                     parser.addWarning(\"msg.jsdoc.noalias\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_COMPILE:\n                                 if (!jsdocBuilder.recordNoCompile()) {\n                                     parser.addWarning(\"msg.jsdoc.nocompile\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_TYPE_CHECK:\n                                 if (!jsdocBuilder.recordNoTypeCheck()) {\n                                     parser.addWarning(\"msg.jsdoc.nocheck\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NOT_IMPLEMENTED:\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case INHERIT_DOC:\n                             case OVERRIDE:\n                                 if (!jsdocBuilder.recordOverride()) {\n                                     parser.addWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case THROWS:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                     if (type \u003d\u003d null) {\n                                         token \u003d eatTokensUntilEOL();\n                                         continue retry;\n                                     }\n                                 }\n                                 token \u003d current();\n                                 jsdocBuilder.recordThrowType(type);\n                                 if (jsdocBuilder.shouldParseDocumentation()) {\n                                     ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                     String description \u003d descriptionInfo.string;\n                                     if (description.length() \u003e 0) {\n                                         jsdocBuilder.recordThrowDescription(type, description);\n                                     }\n                                     token \u003d descriptionInfo.token;\n                                 } else {\n                                     token \u003d eatTokensUntilEOL(token);\n                                 }\n                                 continue retry;\n                             case PARAM:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordParamTypeNode(token));\n                                     if (type \u003d\u003d null) {\n                                         token \u003d eatTokensUntilEOL();\n                                         continue retry;\n                                     }\n                                     skipEOLs();\n                                     token \u003d next();\n                                     lineno \u003d stream.getLineno();\n                                     charno \u003d stream.getCharno();\n                                 }\n                                 String name \u003d null;\n                                 boolean isBracketedParam \u003d JsDocToken.LB \u003d\u003d token;\n                                 if (isBracketedParam) {\n                                     token \u003d next();\n                                 }\n                                 if (JsDocToken.STRING !\u003d token) {\n                                     parser.addWarning(\"msg.missing.variable.name\", lineno, charno);\n                                 } else {\n                                     name \u003d stream.getString();\n                                     if (isBracketedParam) {\n                                         token \u003d next();\n                                         if (JsDocToken.EQUALS \u003d\u003d token) {\n                                             token \u003d next();\n                                             if (JsDocToken.STRING \u003d\u003d token) {\n                                                 token \u003d next();\n                                             }\n                                         }\n                                         if (JsDocToken.RB !\u003d token) {\n                                             reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                                         } else if (type !\u003d null) {\n                                             type \u003d JSTypeExpression.makeOptionalArg(type);\n                                         }\n                                     }\n                                     if (name.indexOf(\u0027.\u0027) \u003e -1) {\n                                         name \u003d null;\n                                     } else if (!jsdocBuilder.recordParameter(name, type)) {\n                                         if (jsdocBuilder.hasParameter(name)) {\n                                             parser.addWarning(\"msg.dup.variable.name\", name, lineno, charno);\n                                         } else {\n                                             parser.addWarning(\"msg.jsdoc.incompat.type\", name, lineno, charno);\n                                         }\n                                     }\n                                 }\n                                 if (name \u003d\u003d null) {\n                                     token \u003d eatTokensUntilEOL(token);\n                                     continue retry;\n                                 }\n                                 jsdocBuilder.markName(name, lineno, charno);\n                                 if (jsdocBuilder.shouldParseDocumentation()) {\n                                     ExtractionInfo paramDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                     String paramDescription \u003d paramDescriptionInfo.string;\n                                     if (paramDescription.length() \u003e 0) {\n                                         jsdocBuilder.recordParameterDescription(name, paramDescription);\n                                     }\n                                     token \u003d paramDescriptionInfo.token;\n                                 } else {\n                                     token \u003d eatTokensUntilEOL(token);\n                                 }\n                                 continue retry;\n                             case PRESERVE_TRY:\n                                 if (!jsdocBuilder.recordPreserveTry()) {\n                                     parser.addWarning(\"msg.jsdoc.preservertry\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PRIVATE:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                                     parser.addWarning(\"msg.jsdoc.visibility.private\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PROTECTED:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                                     parser.addWarning(\"msg.jsdoc.visibility.protected\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PUBLIC:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                                     parser.addWarning(\"msg.jsdoc.visibility.public\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_SHADOW:\n                                 if (!jsdocBuilder.recordNoShadow()) {\n                                     parser.addWarning(\"msg.jsdoc.noshadow\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_SIDE_EFFECTS:\n                                 if (!jsdocBuilder.recordNoSideEffects()) {\n                                     parser.addWarning(\"msg.jsdoc.nosideeffects\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case MODIFIES:\n                                 token \u003d parseModifiesTag(next());\n                                 continue retry;\n                             case IMPLICIT_CAST:\n                                 if (!jsdocBuilder.recordImplicitCast()) {\n                                     parser.addWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case SEE:\n                                 if (jsdocBuilder.shouldParseDocumentation()) {\n                                     ExtractionInfo referenceInfo \u003d extractSingleLineBlock();\n                                     String reference \u003d referenceInfo.string;\n                                     if (reference.length() \u003d\u003d 0) {\n                                         parser.addWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno());\n                                     } else {\n                                         jsdocBuilder.addReference(reference);\n                                     }\n                                     token \u003d referenceInfo.token;\n                                 } else {\n                                     token \u003d eatTokensUntilEOL(token);\n                                 }\n                                 continue retry;\n                             case SUPPRESS:\n                                 token \u003d parseSuppressTag(next());\n                                 continue retry;\n                             case TEMPLATE:\n                                 ExtractionInfo templateInfo \u003d extractSingleLineBlock();\n                                 String templateTypeName \u003d templateInfo.string;\n                                 if (templateTypeName.length() \u003d\u003d 0) {\n                                     parser.addWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno());\n                                 } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {\n                                     parser.addWarning(\"msg.jsdoc.template.at.most.once\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d templateInfo.token;\n                                 continue retry;\n                             case VERSION:\n                                 ExtractionInfo versionInfo \u003d extractSingleLineBlock();\n                                 String version \u003d versionInfo.string;\n                                 if (version.length() \u003d\u003d 0) {\n                                     parser.addWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno());\n                                 } else {\n                                     if (!jsdocBuilder.recordVersion(version)) {\n                                         parser.addWarning(\"msg.jsdoc.extraversion\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d versionInfo.token;\n                                 continue retry;\n                             case DEFINE:\n                             case RETURN:\n                             case THIS:\n                             case TYPE:\n                             case TYPEDEF:\n                                 skipEOLs();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 token \u003d next();\n                                 Node typeNode \u003d parseAndRecordTypeNode(token, lineno, charno);\n                                 if (annotation \u003d\u003d Annotation.THIS) {\n                                     typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                     if (typeNode !\u003d null \u0026\u0026 token !\u003d JsDocToken.LC) {\n                                         typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                     }\n                                 }\n                                 type \u003d createJSTypeExpression(typeNode);\n                                 if (type \u003d\u003d null) {\n                                 } else {\n                                     switch(annotation) {\n                                         case DEFINE:\n                                             if (!jsdocBuilder.recordDefineType(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.define\", lineno, charno);\n                                             }\n                                             break;\n                                         case RETURN:\n                                             if (!jsdocBuilder.recordReturnType(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                                 break;\n                                             }\n                                             token \u003d current();\n                                             if (jsdocBuilder.shouldParseDocumentation()) {\n                                                 ExtractionInfo returnDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                                 String returnDescription \u003d returnDescriptionInfo.string;\n                                                 if (returnDescription.length() \u003e 0) {\n                                                     jsdocBuilder.recordReturnDescription(returnDescription);\n                                                 }\n                                                 token \u003d returnDescriptionInfo.token;\n                                             } else {\n                                                 token \u003d eatTokensUntilEOL(token);\n                                             }\n                                             continue retry;\n                                         case THIS:\n                                             if (!jsdocBuilder.recordThisType(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                         case TYPE:\n                                             if (!jsdocBuilder.recordType(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                         case TYPEDEF:\n                                             if (!jsdocBuilder.recordTypedef(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                     }\n                                     token \u003d eatTokensUntilEOL();\n                                 }\n                                 continue retry;\n                         }\n                     }\n                 }\n                 break;\n             case EOC:\n                 if (hasParsedFileOverviewDocInfo()) {\n                     fileOverviewJSDocInfo \u003d retrieveAndResetParsedJSDocInfo();\n                 }\n                 return true;\n             case EOF:\n                 jsdocBuilder.build(null);\n                 parser.addWarning(\"msg.unexpected.eof\", stream.getLineno(), stream.getCharno());\n                 return false;\n             case EOL:\n                 if (state \u003d\u003d State.SEARCHING_NEWLINE) {\n                     state \u003d State.SEARCHING_ANNOTATION;\n                 }\n                 token \u003d next();\n                 continue retry;\n             default:\n                 if (token \u003d\u003d JsDocToken.STAR \u0026\u0026 state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                     token \u003d next();\n                     continue retry;\n                 } else {\n                     state \u003d State.SEARCHING_NEWLINE;\n                     token \u003d eatTokensUntilEOL();\n                     continue retry;\n                 }\n         }\n         token \u003d next();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "eb3e25de7fc6ee4858b9805519c0dc7a13e1b183": {
      "type": "Ybodychange",
      "commitMessage": "\nAdd support for \"@modifies{this}\" and \"@modifies{arguments}\".\n\nR\u003dnicksantos\nDELTA\u003d220  (218 added, 0 deleted, 2 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d244022\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@456 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "9/22/10, 4:19 PM",
      "commitName": "eb3e25de7fc6ee4858b9805519c0dc7a13e1b183",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "9/16/10, 2:10 PM",
      "commitNameOld": "5b3bc3fa01328cdbbde6b865c4d3ff7562bc9d6f",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 6.09,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "actualSource": "boolean parse() {\n    int lineno;\n    int charno;\n    JSTypeExpression type;\n    state \u003d State.SEARCHING_ANNOTATION;\n    skipEOLs();\n    JsDocToken token \u003d next();\n    if (jsdocBuilder.shouldParseDocumentation()) {\n        ExtractionInfo blockInfo \u003d extractBlockComment(token);\n        token \u003d blockInfo.token;\n        if (!blockInfo.string.isEmpty()) {\n            jsdocBuilder.recordBlockDescription(blockInfo.string);\n        }\n    } else {\n        if (token !\u003d JsDocToken.ANNOTATION \u0026\u0026 token !\u003d JsDocToken.EOC) {\n            jsdocBuilder.recordBlockDescription(\"\");\n        }\n    }\n    retry: for (; ; ) {\n        switch(token) {\n            case ANNOTATION:\n                if (state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                    state \u003d State.SEARCHING_NEWLINE;\n                    lineno \u003d stream.getLineno();\n                    charno \u003d stream.getCharno();\n                    String annotationName \u003d stream.getString();\n                    Annotation annotation \u003d annotationNames.get(annotationName);\n                    if (annotation \u003d\u003d null) {\n                        parser.addWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno());\n                    } else {\n                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n                        switch(annotation) {\n                            case AUTHOR:\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo authorInfo \u003d extractSingleLineBlock();\n                                    String author \u003d authorInfo.string;\n                                    if (author.length() \u003d\u003d 0) {\n                                        parser.addWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        jsdocBuilder.addAuthor(author);\n                                    }\n                                    token \u003d authorInfo.token;\n                                } else {\n                                    token \u003d eatTokensUntilEOL(token);\n                                }\n                                continue retry;\n                            case CONSTANT:\n                                if (!jsdocBuilder.recordConstancy()) {\n                                    parser.addWarning(\"msg.jsdoc.const\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case CONSTRUCTOR:\n                                if (!jsdocBuilder.recordConstructor()) {\n                                    if (jsdocBuilder.isInterfaceRecorded()) {\n                                        parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case DEPRECATED:\n                                if (!jsdocBuilder.recordDeprecated()) {\n                                    parser.addWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno());\n                                }\n                                ExtractionInfo reasonInfo \u003d extractMultilineTextualBlock(token);\n                                String reason \u003d reasonInfo.string;\n                                if (reason.length() \u003e 0) {\n                                    jsdocBuilder.recordDeprecationReason(reason);\n                                }\n                                token \u003d reasonInfo.token;\n                                continue retry;\n                            case INTERFACE:\n                                if (!jsdocBuilder.recordInterface()) {\n                                    if (jsdocBuilder.isConstructorRecorded()) {\n                                        parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case DESC:\n                                if (jsdocBuilder.isDescriptionRecorded()) {\n                                    parser.addWarning(\"msg.jsdoc.desc.extra\", stream.getLineno(), stream.getCharno());\n                                    token \u003d eatTokensUntilEOL();\n                                    continue retry;\n                                } else {\n                                    ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                    String description \u003d descriptionInfo.string;\n                                    jsdocBuilder.recordDescription(description);\n                                    token \u003d descriptionInfo.token;\n                                    continue retry;\n                                }\n                            case FILE_OVERVIEW:\n                                String fileOverview \u003d \"\";\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo fileOverviewInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.TRIM);\n                                    fileOverview \u003d fileOverviewInfo.string;\n                                    token \u003d fileOverviewInfo.token;\n                                } else {\n                                    token \u003d eatTokensUntilEOL(token);\n                                }\n                                if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo !\u003d null) {\n                                    parser.addWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno());\n                                }\n                                continue retry;\n                            case LICENSE:\n                            case PRESERVE:\n                                ExtractionInfo preserveInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);\n                                String preserve \u003d preserveInfo.string;\n                                if (preserve.length() \u003e 0) {\n                                    if (fileLevelJsDocBuilder !\u003d null) {\n                                        fileLevelJsDocBuilder.append(preserve);\n                                    }\n                                }\n                                token \u003d preserveInfo.token;\n                                continue retry;\n                            case ENUM:\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                }\n                                if (type \u003d\u003d null) {\n                                    type \u003d createJSTypeExpression(newStringNode(\"number\"));\n                                }\n                                if (!jsdocBuilder.recordEnumParameterType(type)) {\n                                    parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                }\n                                token \u003d eatTokensUntilEOL(token);\n                                continue retry;\n                            case EXPORT:\n                                if (!jsdocBuilder.recordExport()) {\n                                    parser.addWarning(\"msg.jsdoc.export\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case EXTERNS:\n                                if (!jsdocBuilder.recordExterns()) {\n                                    parser.addWarning(\"msg.jsdoc.externs\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case JAVA_DISPATCH:\n                                if (!jsdocBuilder.recordJavaDispatch()) {\n                                    parser.addWarning(\"msg.jsdoc.javadispatch\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case EXTENDS:\n                            case IMPLEMENTS:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                boolean matchingRc \u003d false;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    token \u003d next();\n                                    matchingRc \u003d true;\n                                }\n                                if (token \u003d\u003d JsDocToken.STRING) {\n                                    Node typeNode \u003d parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);\n                                    lineno \u003d stream.getLineno();\n                                    charno \u003d stream.getCharno();\n                                    typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                    if (typeNode !\u003d null \u0026\u0026 !matchingRc) {\n                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                    }\n                                    type \u003d createJSTypeExpression(typeNode);\n                                    if (annotation \u003d\u003d Annotation.EXTENDS) {\n                                        if (!jsdocBuilder.recordBaseType(type)) {\n                                            parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                        }\n                                    } else {\n                                        Preconditions.checkState(annotation \u003d\u003d Annotation.IMPLEMENTS);\n                                        if (!jsdocBuilder.recordImplementedInterface(type)) {\n                                            parser.addWarning(\"msg.jsdoc.implements.duplicate\", lineno, charno);\n                                        }\n                                    }\n                                    token \u003d next();\n                                    if (matchingRc) {\n                                        if (token !\u003d JsDocToken.RC) {\n                                            parser.addWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                        }\n                                    } else if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOF \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                        parser.addWarning(\"msg.end.annotation.expected\", stream.getLineno(), stream.getCharno());\n                                    }\n                                } else {\n                                    parser.addWarning(\"msg.no.type.name\", lineno, charno);\n                                }\n                                token \u003d eatTokensUntilEOL(token);\n                                continue retry;\n                            case HIDDEN:\n                                if (!jsdocBuilder.recordHiddenness()) {\n                                    parser.addWarning(\"msg.jsdoc.hidden\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case MEANING:\n                                ExtractionInfo meaningInfo \u003d extractMultilineTextualBlock(token);\n                                String meaning \u003d meaningInfo.string;\n                                token \u003d meaningInfo.token;\n                                if (!jsdocBuilder.recordMeaning(meaning)) {\n                                    parser.addWarning(\"msg.jsdoc.meaning.extra\", stream.getLineno(), stream.getCharno());\n                                }\n                                continue retry;\n                            case NO_ALIAS:\n                                if (!jsdocBuilder.recordNoAlias()) {\n                                    parser.addWarning(\"msg.jsdoc.noalias\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_COMPILE:\n                                if (!jsdocBuilder.recordNoCompile()) {\n                                    parser.addWarning(\"msg.jsdoc.nocompile\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_TYPE_CHECK:\n                                if (!jsdocBuilder.recordNoTypeCheck()) {\n                                    parser.addWarning(\"msg.jsdoc.nocheck\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NOT_IMPLEMENTED:\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case INHERIT_DOC:\n                            case OVERRIDE:\n                                if (!jsdocBuilder.recordOverride()) {\n                                    parser.addWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case THROWS:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                    if (type \u003d\u003d null) {\n                                        token \u003d eatTokensUntilEOL();\n                                        continue retry;\n                                    }\n                                }\n                                token \u003d current();\n                                jsdocBuilder.recordThrowType(type);\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                    String description \u003d descriptionInfo.string;\n                                    if (description.length() \u003e 0) {\n                                        jsdocBuilder.recordThrowDescription(type, description);\n                                    }\n                                    token \u003d descriptionInfo.token;\n                                } else {\n                                    token \u003d eatTokensUntilEOL(token);\n                                }\n                                continue retry;\n                            case PARAM:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordParamTypeNode(token));\n                                    if (type \u003d\u003d null) {\n                                        token \u003d eatTokensUntilEOL();\n                                        continue retry;\n                                    }\n                                    skipEOLs();\n                                    token \u003d next();\n                                    lineno \u003d stream.getLineno();\n                                    charno \u003d stream.getCharno();\n                                }\n                                String name \u003d null;\n                                boolean isBracketedParam \u003d JsDocToken.LB \u003d\u003d token;\n                                if (isBracketedParam) {\n                                    token \u003d next();\n                                }\n                                if (JsDocToken.STRING !\u003d token) {\n                                    parser.addWarning(\"msg.missing.variable.name\", lineno, charno);\n                                } else {\n                                    name \u003d stream.getString();\n                                    if (isBracketedParam) {\n                                        token \u003d next();\n                                        if (JsDocToken.EQUALS \u003d\u003d token) {\n                                            token \u003d next();\n                                            if (JsDocToken.STRING \u003d\u003d token) {\n                                                token \u003d next();\n                                            }\n                                        }\n                                        if (JsDocToken.RB !\u003d token) {\n                                            reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                                        } else if (type !\u003d null) {\n                                            type \u003d JSTypeExpression.makeOptionalArg(type);\n                                        }\n                                    }\n                                    if (name.indexOf(\u0027.\u0027) \u003e -1) {\n                                        name \u003d null;\n                                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                                        if (jsdocBuilder.hasParameter(name)) {\n                                            parser.addWarning(\"msg.dup.variable.name\", name, lineno, charno);\n                                        } else {\n                                            parser.addWarning(\"msg.jsdoc.incompat.type\", name, lineno, charno);\n                                        }\n                                    }\n                                }\n                                if (name \u003d\u003d null) {\n                                    token \u003d eatTokensUntilEOL(token);\n                                    continue retry;\n                                }\n                                jsdocBuilder.markName(name, lineno, charno);\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo paramDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                    String paramDescription \u003d paramDescriptionInfo.string;\n                                    if (paramDescription.length() \u003e 0) {\n                                        jsdocBuilder.recordParameterDescription(name, paramDescription);\n                                    }\n                                    token \u003d paramDescriptionInfo.token;\n                                } else {\n                                    token \u003d eatTokensUntilEOL(token);\n                                }\n                                continue retry;\n                            case PRESERVE_TRY:\n                                if (!jsdocBuilder.recordPreserveTry()) {\n                                    parser.addWarning(\"msg.jsdoc.preservertry\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PRIVATE:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                                    parser.addWarning(\"msg.jsdoc.visibility.private\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PROTECTED:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                                    parser.addWarning(\"msg.jsdoc.visibility.protected\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PUBLIC:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                                    parser.addWarning(\"msg.jsdoc.visibility.public\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_SHADOW:\n                                if (!jsdocBuilder.recordNoShadow()) {\n                                    parser.addWarning(\"msg.jsdoc.noshadow\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_SIDE_EFFECTS:\n                                if (!jsdocBuilder.recordNoSideEffects()) {\n                                    parser.addWarning(\"msg.jsdoc.nosideeffects\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case MODIFIES:\n                                token \u003d parseModifiesTag(next());\n                                continue retry;\n                            case IMPLICIT_CAST:\n                                if (!jsdocBuilder.recordImplicitCast()) {\n                                    parser.addWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case SEE:\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo referenceInfo \u003d extractSingleLineBlock();\n                                    String reference \u003d referenceInfo.string;\n                                    if (reference.length() \u003d\u003d 0) {\n                                        parser.addWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        jsdocBuilder.addReference(reference);\n                                    }\n                                    token \u003d referenceInfo.token;\n                                } else {\n                                    token \u003d eatTokensUntilEOL(token);\n                                }\n                                continue retry;\n                            case SUPPRESS:\n                                token \u003d parseSuppressTag(next());\n                                continue retry;\n                            case TEMPLATE:\n                                ExtractionInfo templateInfo \u003d extractSingleLineBlock();\n                                String templateTypeName \u003d templateInfo.string;\n                                if (templateTypeName.length() \u003d\u003d 0) {\n                                    parser.addWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno());\n                                } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {\n                                    parser.addWarning(\"msg.jsdoc.template.at.most.once\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d templateInfo.token;\n                                continue retry;\n                            case VERSION:\n                                ExtractionInfo versionInfo \u003d extractSingleLineBlock();\n                                String version \u003d versionInfo.string;\n                                if (version.length() \u003d\u003d 0) {\n                                    parser.addWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno());\n                                } else {\n                                    if (!jsdocBuilder.recordVersion(version)) {\n                                        parser.addWarning(\"msg.jsdoc.extraversion\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d versionInfo.token;\n                                continue retry;\n                            case DEFINE:\n                            case RETURN:\n                            case THIS:\n                            case TYPE:\n                            case TYPEDEF:\n                                skipEOLs();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                token \u003d next();\n                                Node typeNode \u003d parseAndRecordTypeNode(token, lineno, charno);\n                                if (annotation \u003d\u003d Annotation.THIS) {\n                                    typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                    if (typeNode !\u003d null \u0026\u0026 token !\u003d JsDocToken.LC) {\n                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                    }\n                                }\n                                type \u003d createJSTypeExpression(typeNode);\n                                if (type \u003d\u003d null) {\n                                } else {\n                                    switch(annotation) {\n                                        case DEFINE:\n                                            if (!jsdocBuilder.recordDefineType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.define\", lineno, charno);\n                                            }\n                                            break;\n                                        case RETURN:\n                                            if (!jsdocBuilder.recordReturnType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                                break;\n                                            }\n                                            token \u003d current();\n                                            if (jsdocBuilder.shouldParseDocumentation()) {\n                                                ExtractionInfo returnDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                                String returnDescription \u003d returnDescriptionInfo.string;\n                                                if (returnDescription.length() \u003e 0) {\n                                                    jsdocBuilder.recordReturnDescription(returnDescription);\n                                                }\n                                                token \u003d returnDescriptionInfo.token;\n                                            } else {\n                                                token \u003d eatTokensUntilEOL(token);\n                                            }\n                                            continue retry;\n                                        case THIS:\n                                            if (!jsdocBuilder.recordThisType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                        case TYPE:\n                                            if (!jsdocBuilder.recordType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                        case TYPEDEF:\n                                            if (!jsdocBuilder.recordTypedef(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                    }\n                                    token \u003d eatTokensUntilEOL();\n                                }\n                                continue retry;\n                        }\n                    }\n                }\n                break;\n            case EOC:\n                if (hasParsedFileOverviewDocInfo()) {\n                    fileOverviewJSDocInfo \u003d retrieveAndResetParsedJSDocInfo();\n                }\n                return true;\n            case EOF:\n                jsdocBuilder.build(null);\n                parser.addWarning(\"msg.unexpected.eof\", stream.getLineno(), stream.getCharno());\n                return false;\n            case EOL:\n                if (state \u003d\u003d State.SEARCHING_NEWLINE) {\n                    state \u003d State.SEARCHING_ANNOTATION;\n                }\n                token \u003d next();\n                continue retry;\n            default:\n                if (token \u003d\u003d JsDocToken.STAR \u0026\u0026 state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                    token \u003d next();\n                    continue retry;\n                } else {\n                    state \u003d State.SEARCHING_NEWLINE;\n                    token \u003d eatTokensUntilEOL();\n                    continue retry;\n                }\n        }\n        token \u003d next();\n    }\n}",
      "path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
      "functionStartLine": 137,
      "functionName": "parse",
      "functionAnnotation": "",
      "functionDoc": "Parses a {@link JSDocInfo} object. This parsing method reads all tokens\nreturned by the {@link JsDocTokenStream#getJsDocToken()} method until the\n{@link JsDocToken#EOC} is returned.\n\n@return @code true} if JSDoc information was correctly parsed,\n    {@code false} otherwise\n",
      "diff": "@@ -1,504 +1,507 @@\n boolean parse() {\n     int lineno;\n     int charno;\n     JSTypeExpression type;\n     state \u003d State.SEARCHING_ANNOTATION;\n     skipEOLs();\n     JsDocToken token \u003d next();\n     if (jsdocBuilder.shouldParseDocumentation()) {\n         ExtractionInfo blockInfo \u003d extractBlockComment(token);\n         token \u003d blockInfo.token;\n         if (!blockInfo.string.isEmpty()) {\n             jsdocBuilder.recordBlockDescription(blockInfo.string);\n         }\n     } else {\n         if (token !\u003d JsDocToken.ANNOTATION \u0026\u0026 token !\u003d JsDocToken.EOC) {\n             jsdocBuilder.recordBlockDescription(\"\");\n         }\n     }\n     retry: for (; ; ) {\n         switch(token) {\n             case ANNOTATION:\n                 if (state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                     state \u003d State.SEARCHING_NEWLINE;\n                     lineno \u003d stream.getLineno();\n                     charno \u003d stream.getCharno();\n                     String annotationName \u003d stream.getString();\n                     Annotation annotation \u003d annotationNames.get(annotationName);\n                     if (annotation \u003d\u003d null) {\n                         parser.addWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno());\n                     } else {\n                         jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n                         switch(annotation) {\n                             case AUTHOR:\n                                 if (jsdocBuilder.shouldParseDocumentation()) {\n                                     ExtractionInfo authorInfo \u003d extractSingleLineBlock();\n                                     String author \u003d authorInfo.string;\n                                     if (author.length() \u003d\u003d 0) {\n                                         parser.addWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno());\n                                     } else {\n                                         jsdocBuilder.addAuthor(author);\n                                     }\n                                     token \u003d authorInfo.token;\n                                 } else {\n                                     token \u003d eatTokensUntilEOL(token);\n                                 }\n                                 continue retry;\n                             case CONSTANT:\n                                 if (!jsdocBuilder.recordConstancy()) {\n                                     parser.addWarning(\"msg.jsdoc.const\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case CONSTRUCTOR:\n                                 if (!jsdocBuilder.recordConstructor()) {\n                                     if (jsdocBuilder.isInterfaceRecorded()) {\n                                         parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                     } else {\n                                         parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case DEPRECATED:\n                                 if (!jsdocBuilder.recordDeprecated()) {\n                                     parser.addWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 ExtractionInfo reasonInfo \u003d extractMultilineTextualBlock(token);\n                                 String reason \u003d reasonInfo.string;\n                                 if (reason.length() \u003e 0) {\n                                     jsdocBuilder.recordDeprecationReason(reason);\n                                 }\n                                 token \u003d reasonInfo.token;\n                                 continue retry;\n                             case INTERFACE:\n                                 if (!jsdocBuilder.recordInterface()) {\n                                     if (jsdocBuilder.isConstructorRecorded()) {\n                                         parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                     } else {\n                                         parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case DESC:\n                                 if (jsdocBuilder.isDescriptionRecorded()) {\n                                     parser.addWarning(\"msg.jsdoc.desc.extra\", stream.getLineno(), stream.getCharno());\n                                     token \u003d eatTokensUntilEOL();\n                                     continue retry;\n                                 } else {\n                                     ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                     String description \u003d descriptionInfo.string;\n                                     jsdocBuilder.recordDescription(description);\n                                     token \u003d descriptionInfo.token;\n                                     continue retry;\n                                 }\n                             case FILE_OVERVIEW:\n                                 String fileOverview \u003d \"\";\n                                 if (jsdocBuilder.shouldParseDocumentation()) {\n                                     ExtractionInfo fileOverviewInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.TRIM);\n                                     fileOverview \u003d fileOverviewInfo.string;\n                                     token \u003d fileOverviewInfo.token;\n                                 } else {\n                                     token \u003d eatTokensUntilEOL(token);\n                                 }\n                                 if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo !\u003d null) {\n                                     parser.addWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 continue retry;\n                             case LICENSE:\n                             case PRESERVE:\n                                 ExtractionInfo preserveInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);\n                                 String preserve \u003d preserveInfo.string;\n                                 if (preserve.length() \u003e 0) {\n                                     if (fileLevelJsDocBuilder !\u003d null) {\n                                         fileLevelJsDocBuilder.append(preserve);\n                                     }\n                                 }\n                                 token \u003d preserveInfo.token;\n                                 continue retry;\n                             case ENUM:\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                 }\n                                 if (type \u003d\u003d null) {\n                                     type \u003d createJSTypeExpression(newStringNode(\"number\"));\n                                 }\n                                 if (!jsdocBuilder.recordEnumParameterType(type)) {\n                                     parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                 }\n                                 token \u003d eatTokensUntilEOL(token);\n                                 continue retry;\n                             case EXPORT:\n                                 if (!jsdocBuilder.recordExport()) {\n                                     parser.addWarning(\"msg.jsdoc.export\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case EXTERNS:\n                                 if (!jsdocBuilder.recordExterns()) {\n                                     parser.addWarning(\"msg.jsdoc.externs\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case JAVA_DISPATCH:\n                                 if (!jsdocBuilder.recordJavaDispatch()) {\n                                     parser.addWarning(\"msg.jsdoc.javadispatch\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case EXTENDS:\n                             case IMPLEMENTS:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 boolean matchingRc \u003d false;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     token \u003d next();\n                                     matchingRc \u003d true;\n                                 }\n                                 if (token \u003d\u003d JsDocToken.STRING) {\n                                     Node typeNode \u003d parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);\n                                     lineno \u003d stream.getLineno();\n                                     charno \u003d stream.getCharno();\n                                     typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                     if (typeNode !\u003d null \u0026\u0026 !matchingRc) {\n                                         typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                     }\n                                     type \u003d createJSTypeExpression(typeNode);\n                                     if (annotation \u003d\u003d Annotation.EXTENDS) {\n                                         if (!jsdocBuilder.recordBaseType(type)) {\n                                             parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                         }\n                                     } else {\n                                         Preconditions.checkState(annotation \u003d\u003d Annotation.IMPLEMENTS);\n                                         if (!jsdocBuilder.recordImplementedInterface(type)) {\n                                             parser.addWarning(\"msg.jsdoc.implements.duplicate\", lineno, charno);\n                                         }\n                                     }\n                                     token \u003d next();\n                                     if (matchingRc) {\n                                         if (token !\u003d JsDocToken.RC) {\n                                             parser.addWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                         }\n                                     } else if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOF \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                         parser.addWarning(\"msg.end.annotation.expected\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 } else {\n                                     parser.addWarning(\"msg.no.type.name\", lineno, charno);\n                                 }\n                                 token \u003d eatTokensUntilEOL(token);\n                                 continue retry;\n                             case HIDDEN:\n                                 if (!jsdocBuilder.recordHiddenness()) {\n                                     parser.addWarning(\"msg.jsdoc.hidden\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case MEANING:\n                                 ExtractionInfo meaningInfo \u003d extractMultilineTextualBlock(token);\n                                 String meaning \u003d meaningInfo.string;\n                                 token \u003d meaningInfo.token;\n                                 if (!jsdocBuilder.recordMeaning(meaning)) {\n                                     parser.addWarning(\"msg.jsdoc.meaning.extra\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 continue retry;\n                             case NO_ALIAS:\n                                 if (!jsdocBuilder.recordNoAlias()) {\n                                     parser.addWarning(\"msg.jsdoc.noalias\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_COMPILE:\n                                 if (!jsdocBuilder.recordNoCompile()) {\n                                     parser.addWarning(\"msg.jsdoc.nocompile\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_TYPE_CHECK:\n                                 if (!jsdocBuilder.recordNoTypeCheck()) {\n                                     parser.addWarning(\"msg.jsdoc.nocheck\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NOT_IMPLEMENTED:\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case INHERIT_DOC:\n                             case OVERRIDE:\n                                 if (!jsdocBuilder.recordOverride()) {\n                                     parser.addWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case THROWS:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                     if (type \u003d\u003d null) {\n                                         token \u003d eatTokensUntilEOL();\n                                         continue retry;\n                                     }\n                                 }\n                                 token \u003d current();\n                                 jsdocBuilder.recordThrowType(type);\n                                 if (jsdocBuilder.shouldParseDocumentation()) {\n                                     ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                     String description \u003d descriptionInfo.string;\n                                     if (description.length() \u003e 0) {\n                                         jsdocBuilder.recordThrowDescription(type, description);\n                                     }\n                                     token \u003d descriptionInfo.token;\n                                 } else {\n                                     token \u003d eatTokensUntilEOL(token);\n                                 }\n                                 continue retry;\n                             case PARAM:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordParamTypeNode(token));\n                                     if (type \u003d\u003d null) {\n                                         token \u003d eatTokensUntilEOL();\n                                         continue retry;\n                                     }\n                                     skipEOLs();\n                                     token \u003d next();\n                                     lineno \u003d stream.getLineno();\n                                     charno \u003d stream.getCharno();\n                                 }\n                                 String name \u003d null;\n                                 boolean isBracketedParam \u003d JsDocToken.LB \u003d\u003d token;\n                                 if (isBracketedParam) {\n                                     token \u003d next();\n                                 }\n                                 if (JsDocToken.STRING !\u003d token) {\n                                     parser.addWarning(\"msg.missing.variable.name\", lineno, charno);\n                                 } else {\n                                     name \u003d stream.getString();\n                                     if (isBracketedParam) {\n                                         token \u003d next();\n                                         if (JsDocToken.EQUALS \u003d\u003d token) {\n                                             token \u003d next();\n                                             if (JsDocToken.STRING \u003d\u003d token) {\n                                                 token \u003d next();\n                                             }\n                                         }\n                                         if (JsDocToken.RB !\u003d token) {\n                                             reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                                         } else if (type !\u003d null) {\n                                             type \u003d JSTypeExpression.makeOptionalArg(type);\n                                         }\n                                     }\n                                     if (name.indexOf(\u0027.\u0027) \u003e -1) {\n                                         name \u003d null;\n                                     } else if (!jsdocBuilder.recordParameter(name, type)) {\n                                         if (jsdocBuilder.hasParameter(name)) {\n                                             parser.addWarning(\"msg.dup.variable.name\", name, lineno, charno);\n                                         } else {\n                                             parser.addWarning(\"msg.jsdoc.incompat.type\", name, lineno, charno);\n                                         }\n                                     }\n                                 }\n                                 if (name \u003d\u003d null) {\n                                     token \u003d eatTokensUntilEOL(token);\n                                     continue retry;\n                                 }\n                                 jsdocBuilder.markName(name, lineno, charno);\n                                 if (jsdocBuilder.shouldParseDocumentation()) {\n                                     ExtractionInfo paramDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                     String paramDescription \u003d paramDescriptionInfo.string;\n                                     if (paramDescription.length() \u003e 0) {\n                                         jsdocBuilder.recordParameterDescription(name, paramDescription);\n                                     }\n                                     token \u003d paramDescriptionInfo.token;\n                                 } else {\n                                     token \u003d eatTokensUntilEOL(token);\n                                 }\n                                 continue retry;\n                             case PRESERVE_TRY:\n                                 if (!jsdocBuilder.recordPreserveTry()) {\n                                     parser.addWarning(\"msg.jsdoc.preservertry\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PRIVATE:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                                     parser.addWarning(\"msg.jsdoc.visibility.private\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PROTECTED:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                                     parser.addWarning(\"msg.jsdoc.visibility.protected\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PUBLIC:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                                     parser.addWarning(\"msg.jsdoc.visibility.public\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_SHADOW:\n                                 if (!jsdocBuilder.recordNoShadow()) {\n                                     parser.addWarning(\"msg.jsdoc.noshadow\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_SIDE_EFFECTS:\n                                 if (!jsdocBuilder.recordNoSideEffects()) {\n                                     parser.addWarning(\"msg.jsdoc.nosideeffects\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n+                            case MODIFIES:\n+                                token \u003d parseModifiesTag(next());\n+                                continue retry;\n                             case IMPLICIT_CAST:\n                                 if (!jsdocBuilder.recordImplicitCast()) {\n                                     parser.addWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case SEE:\n                                 if (jsdocBuilder.shouldParseDocumentation()) {\n                                     ExtractionInfo referenceInfo \u003d extractSingleLineBlock();\n                                     String reference \u003d referenceInfo.string;\n                                     if (reference.length() \u003d\u003d 0) {\n                                         parser.addWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno());\n                                     } else {\n                                         jsdocBuilder.addReference(reference);\n                                     }\n                                     token \u003d referenceInfo.token;\n                                 } else {\n                                     token \u003d eatTokensUntilEOL(token);\n                                 }\n                                 continue retry;\n                             case SUPPRESS:\n                                 token \u003d parseSuppressTag(next());\n                                 continue retry;\n                             case TEMPLATE:\n                                 ExtractionInfo templateInfo \u003d extractSingleLineBlock();\n                                 String templateTypeName \u003d templateInfo.string;\n                                 if (templateTypeName.length() \u003d\u003d 0) {\n                                     parser.addWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno());\n                                 } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {\n                                     parser.addWarning(\"msg.jsdoc.template.at.most.once\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d templateInfo.token;\n                                 continue retry;\n                             case VERSION:\n                                 ExtractionInfo versionInfo \u003d extractSingleLineBlock();\n                                 String version \u003d versionInfo.string;\n                                 if (version.length() \u003d\u003d 0) {\n                                     parser.addWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno());\n                                 } else {\n                                     if (!jsdocBuilder.recordVersion(version)) {\n                                         parser.addWarning(\"msg.jsdoc.extraversion\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d versionInfo.token;\n                                 continue retry;\n                             case DEFINE:\n                             case RETURN:\n                             case THIS:\n                             case TYPE:\n                             case TYPEDEF:\n                                 skipEOLs();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 token \u003d next();\n                                 Node typeNode \u003d parseAndRecordTypeNode(token, lineno, charno);\n                                 if (annotation \u003d\u003d Annotation.THIS) {\n                                     typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                     if (typeNode !\u003d null \u0026\u0026 token !\u003d JsDocToken.LC) {\n                                         typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                     }\n                                 }\n                                 type \u003d createJSTypeExpression(typeNode);\n                                 if (type \u003d\u003d null) {\n                                 } else {\n                                     switch(annotation) {\n                                         case DEFINE:\n                                             if (!jsdocBuilder.recordDefineType(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.define\", lineno, charno);\n                                             }\n                                             break;\n                                         case RETURN:\n                                             if (!jsdocBuilder.recordReturnType(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                                 break;\n                                             }\n                                             token \u003d current();\n                                             if (jsdocBuilder.shouldParseDocumentation()) {\n                                                 ExtractionInfo returnDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                                 String returnDescription \u003d returnDescriptionInfo.string;\n                                                 if (returnDescription.length() \u003e 0) {\n                                                     jsdocBuilder.recordReturnDescription(returnDescription);\n                                                 }\n                                                 token \u003d returnDescriptionInfo.token;\n                                             } else {\n                                                 token \u003d eatTokensUntilEOL(token);\n                                             }\n                                             continue retry;\n                                         case THIS:\n                                             if (!jsdocBuilder.recordThisType(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                         case TYPE:\n                                             if (!jsdocBuilder.recordType(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                         case TYPEDEF:\n                                             if (!jsdocBuilder.recordTypedef(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                     }\n                                     token \u003d eatTokensUntilEOL();\n                                 }\n                                 continue retry;\n                         }\n                     }\n                 }\n                 break;\n             case EOC:\n                 if (hasParsedFileOverviewDocInfo()) {\n                     fileOverviewJSDocInfo \u003d retrieveAndResetParsedJSDocInfo();\n                 }\n                 return true;\n             case EOF:\n                 jsdocBuilder.build(null);\n                 parser.addWarning(\"msg.unexpected.eof\", stream.getLineno(), stream.getCharno());\n                 return false;\n             case EOL:\n                 if (state \u003d\u003d State.SEARCHING_NEWLINE) {\n                     state \u003d State.SEARCHING_ANNOTATION;\n                 }\n                 token \u003d next();\n                 continue retry;\n             default:\n                 if (token \u003d\u003d JsDocToken.STAR \u0026\u0026 state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                     token \u003d next();\n                     continue retry;\n                 } else {\n                     state \u003d State.SEARCHING_NEWLINE;\n                     token \u003d eatTokensUntilEOL();\n                     continue retry;\n                 }\n         }\n         token \u003d next();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5b3bc3fa01328cdbbde6b865c4d3ff7562bc9d6f": {
      "type": "Ybodychange",
      "commitMessage": "\ndon\u0027t parse documentation that we have no plans on using.\n\nR\u003djschorr\nDELTA\u003d123  (62 added, 7 deleted, 54 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d222681\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@438 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "9/16/10, 2:10 PM",
      "commitName": "5b3bc3fa01328cdbbde6b865c4d3ff7562bc9d6f",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "9/13/10, 11:12 AM",
      "commitNameOld": "4c6e1039b80859f17de5f3cbcfeba61ed8ea0485",
      "commitAuthorOld": "elbaum@google.com",
      "daysBetweenCommits": 3.12,
      "commitsBetweenForRepo": 18,
      "commitsBetweenForFile": 1,
      "actualSource": "boolean parse() {\n    int lineno;\n    int charno;\n    JSTypeExpression type;\n    state \u003d State.SEARCHING_ANNOTATION;\n    skipEOLs();\n    JsDocToken token \u003d next();\n    if (jsdocBuilder.shouldParseDocumentation()) {\n        ExtractionInfo blockInfo \u003d extractBlockComment(token);\n        token \u003d blockInfo.token;\n        if (!blockInfo.string.isEmpty()) {\n            jsdocBuilder.recordBlockDescription(blockInfo.string);\n        }\n    } else {\n        if (token !\u003d JsDocToken.ANNOTATION \u0026\u0026 token !\u003d JsDocToken.EOC) {\n            jsdocBuilder.recordBlockDescription(\"\");\n        }\n    }\n    retry: for (; ; ) {\n        switch(token) {\n            case ANNOTATION:\n                if (state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                    state \u003d State.SEARCHING_NEWLINE;\n                    lineno \u003d stream.getLineno();\n                    charno \u003d stream.getCharno();\n                    String annotationName \u003d stream.getString();\n                    Annotation annotation \u003d annotationNames.get(annotationName);\n                    if (annotation \u003d\u003d null) {\n                        parser.addWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno());\n                    } else {\n                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n                        switch(annotation) {\n                            case AUTHOR:\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo authorInfo \u003d extractSingleLineBlock();\n                                    String author \u003d authorInfo.string;\n                                    if (author.length() \u003d\u003d 0) {\n                                        parser.addWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        jsdocBuilder.addAuthor(author);\n                                    }\n                                    token \u003d authorInfo.token;\n                                } else {\n                                    token \u003d eatTokensUntilEOL(token);\n                                }\n                                continue retry;\n                            case CONSTANT:\n                                if (!jsdocBuilder.recordConstancy()) {\n                                    parser.addWarning(\"msg.jsdoc.const\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case CONSTRUCTOR:\n                                if (!jsdocBuilder.recordConstructor()) {\n                                    if (jsdocBuilder.isInterfaceRecorded()) {\n                                        parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case DEPRECATED:\n                                if (!jsdocBuilder.recordDeprecated()) {\n                                    parser.addWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno());\n                                }\n                                ExtractionInfo reasonInfo \u003d extractMultilineTextualBlock(token);\n                                String reason \u003d reasonInfo.string;\n                                if (reason.length() \u003e 0) {\n                                    jsdocBuilder.recordDeprecationReason(reason);\n                                }\n                                token \u003d reasonInfo.token;\n                                continue retry;\n                            case INTERFACE:\n                                if (!jsdocBuilder.recordInterface()) {\n                                    if (jsdocBuilder.isConstructorRecorded()) {\n                                        parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case DESC:\n                                if (jsdocBuilder.isDescriptionRecorded()) {\n                                    parser.addWarning(\"msg.jsdoc.desc.extra\", stream.getLineno(), stream.getCharno());\n                                    token \u003d eatTokensUntilEOL();\n                                    continue retry;\n                                } else {\n                                    ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                    String description \u003d descriptionInfo.string;\n                                    jsdocBuilder.recordDescription(description);\n                                    token \u003d descriptionInfo.token;\n                                    continue retry;\n                                }\n                            case FILE_OVERVIEW:\n                                String fileOverview \u003d \"\";\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo fileOverviewInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.TRIM);\n                                    fileOverview \u003d fileOverviewInfo.string;\n                                    token \u003d fileOverviewInfo.token;\n                                } else {\n                                    token \u003d eatTokensUntilEOL(token);\n                                }\n                                if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo !\u003d null) {\n                                    parser.addWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno());\n                                }\n                                continue retry;\n                            case LICENSE:\n                            case PRESERVE:\n                                ExtractionInfo preserveInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);\n                                String preserve \u003d preserveInfo.string;\n                                if (preserve.length() \u003e 0) {\n                                    if (fileLevelJsDocBuilder !\u003d null) {\n                                        fileLevelJsDocBuilder.append(preserve);\n                                    }\n                                }\n                                token \u003d preserveInfo.token;\n                                continue retry;\n                            case ENUM:\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                }\n                                if (type \u003d\u003d null) {\n                                    type \u003d createJSTypeExpression(newStringNode(\"number\"));\n                                }\n                                if (!jsdocBuilder.recordEnumParameterType(type)) {\n                                    parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                }\n                                token \u003d eatTokensUntilEOL(token);\n                                continue retry;\n                            case EXPORT:\n                                if (!jsdocBuilder.recordExport()) {\n                                    parser.addWarning(\"msg.jsdoc.export\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case EXTERNS:\n                                if (!jsdocBuilder.recordExterns()) {\n                                    parser.addWarning(\"msg.jsdoc.externs\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case JAVA_DISPATCH:\n                                if (!jsdocBuilder.recordJavaDispatch()) {\n                                    parser.addWarning(\"msg.jsdoc.javadispatch\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case EXTENDS:\n                            case IMPLEMENTS:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                boolean matchingRc \u003d false;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    token \u003d next();\n                                    matchingRc \u003d true;\n                                }\n                                if (token \u003d\u003d JsDocToken.STRING) {\n                                    Node typeNode \u003d parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);\n                                    lineno \u003d stream.getLineno();\n                                    charno \u003d stream.getCharno();\n                                    typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                    if (typeNode !\u003d null \u0026\u0026 !matchingRc) {\n                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                    }\n                                    type \u003d createJSTypeExpression(typeNode);\n                                    if (annotation \u003d\u003d Annotation.EXTENDS) {\n                                        if (!jsdocBuilder.recordBaseType(type)) {\n                                            parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                        }\n                                    } else {\n                                        Preconditions.checkState(annotation \u003d\u003d Annotation.IMPLEMENTS);\n                                        if (!jsdocBuilder.recordImplementedInterface(type)) {\n                                            parser.addWarning(\"msg.jsdoc.implements.duplicate\", lineno, charno);\n                                        }\n                                    }\n                                    token \u003d next();\n                                    if (matchingRc) {\n                                        if (token !\u003d JsDocToken.RC) {\n                                            parser.addWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                        }\n                                    } else if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOF \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                        parser.addWarning(\"msg.end.annotation.expected\", stream.getLineno(), stream.getCharno());\n                                    }\n                                } else {\n                                    parser.addWarning(\"msg.no.type.name\", lineno, charno);\n                                }\n                                token \u003d eatTokensUntilEOL(token);\n                                continue retry;\n                            case HIDDEN:\n                                if (!jsdocBuilder.recordHiddenness()) {\n                                    parser.addWarning(\"msg.jsdoc.hidden\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case MEANING:\n                                ExtractionInfo meaningInfo \u003d extractMultilineTextualBlock(token);\n                                String meaning \u003d meaningInfo.string;\n                                token \u003d meaningInfo.token;\n                                if (!jsdocBuilder.recordMeaning(meaning)) {\n                                    parser.addWarning(\"msg.jsdoc.meaning.extra\", stream.getLineno(), stream.getCharno());\n                                }\n                                continue retry;\n                            case NO_ALIAS:\n                                if (!jsdocBuilder.recordNoAlias()) {\n                                    parser.addWarning(\"msg.jsdoc.noalias\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_COMPILE:\n                                if (!jsdocBuilder.recordNoCompile()) {\n                                    parser.addWarning(\"msg.jsdoc.nocompile\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_TYPE_CHECK:\n                                if (!jsdocBuilder.recordNoTypeCheck()) {\n                                    parser.addWarning(\"msg.jsdoc.nocheck\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NOT_IMPLEMENTED:\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case INHERIT_DOC:\n                            case OVERRIDE:\n                                if (!jsdocBuilder.recordOverride()) {\n                                    parser.addWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case THROWS:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                    if (type \u003d\u003d null) {\n                                        token \u003d eatTokensUntilEOL();\n                                        continue retry;\n                                    }\n                                }\n                                token \u003d current();\n                                jsdocBuilder.recordThrowType(type);\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                    String description \u003d descriptionInfo.string;\n                                    if (description.length() \u003e 0) {\n                                        jsdocBuilder.recordThrowDescription(type, description);\n                                    }\n                                    token \u003d descriptionInfo.token;\n                                } else {\n                                    token \u003d eatTokensUntilEOL(token);\n                                }\n                                continue retry;\n                            case PARAM:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordParamTypeNode(token));\n                                    if (type \u003d\u003d null) {\n                                        token \u003d eatTokensUntilEOL();\n                                        continue retry;\n                                    }\n                                    skipEOLs();\n                                    token \u003d next();\n                                    lineno \u003d stream.getLineno();\n                                    charno \u003d stream.getCharno();\n                                }\n                                String name \u003d null;\n                                boolean isBracketedParam \u003d JsDocToken.LB \u003d\u003d token;\n                                if (isBracketedParam) {\n                                    token \u003d next();\n                                }\n                                if (JsDocToken.STRING !\u003d token) {\n                                    parser.addWarning(\"msg.missing.variable.name\", lineno, charno);\n                                } else {\n                                    name \u003d stream.getString();\n                                    if (isBracketedParam) {\n                                        token \u003d next();\n                                        if (JsDocToken.EQUALS \u003d\u003d token) {\n                                            token \u003d next();\n                                            if (JsDocToken.STRING \u003d\u003d token) {\n                                                token \u003d next();\n                                            }\n                                        }\n                                        if (JsDocToken.RB !\u003d token) {\n                                            reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                                        } else if (type !\u003d null) {\n                                            type \u003d JSTypeExpression.makeOptionalArg(type);\n                                        }\n                                    }\n                                    if (name.indexOf(\u0027.\u0027) \u003e -1) {\n                                        name \u003d null;\n                                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                                        if (jsdocBuilder.hasParameter(name)) {\n                                            parser.addWarning(\"msg.dup.variable.name\", name, lineno, charno);\n                                        } else {\n                                            parser.addWarning(\"msg.jsdoc.incompat.type\", name, lineno, charno);\n                                        }\n                                    }\n                                }\n                                if (name \u003d\u003d null) {\n                                    token \u003d eatTokensUntilEOL(token);\n                                    continue retry;\n                                }\n                                jsdocBuilder.markName(name, lineno, charno);\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo paramDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                    String paramDescription \u003d paramDescriptionInfo.string;\n                                    if (paramDescription.length() \u003e 0) {\n                                        jsdocBuilder.recordParameterDescription(name, paramDescription);\n                                    }\n                                    token \u003d paramDescriptionInfo.token;\n                                } else {\n                                    token \u003d eatTokensUntilEOL(token);\n                                }\n                                continue retry;\n                            case PRESERVE_TRY:\n                                if (!jsdocBuilder.recordPreserveTry()) {\n                                    parser.addWarning(\"msg.jsdoc.preservertry\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PRIVATE:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                                    parser.addWarning(\"msg.jsdoc.visibility.private\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PROTECTED:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                                    parser.addWarning(\"msg.jsdoc.visibility.protected\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PUBLIC:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                                    parser.addWarning(\"msg.jsdoc.visibility.public\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_SHADOW:\n                                if (!jsdocBuilder.recordNoShadow()) {\n                                    parser.addWarning(\"msg.jsdoc.noshadow\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_SIDE_EFFECTS:\n                                if (!jsdocBuilder.recordNoSideEffects()) {\n                                    parser.addWarning(\"msg.jsdoc.nosideeffects\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case IMPLICIT_CAST:\n                                if (!jsdocBuilder.recordImplicitCast()) {\n                                    parser.addWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case SEE:\n                                if (jsdocBuilder.shouldParseDocumentation()) {\n                                    ExtractionInfo referenceInfo \u003d extractSingleLineBlock();\n                                    String reference \u003d referenceInfo.string;\n                                    if (reference.length() \u003d\u003d 0) {\n                                        parser.addWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        jsdocBuilder.addReference(reference);\n                                    }\n                                    token \u003d referenceInfo.token;\n                                } else {\n                                    token \u003d eatTokensUntilEOL(token);\n                                }\n                                continue retry;\n                            case SUPPRESS:\n                                token \u003d parseSuppressTag(next());\n                                continue retry;\n                            case TEMPLATE:\n                                ExtractionInfo templateInfo \u003d extractSingleLineBlock();\n                                String templateTypeName \u003d templateInfo.string;\n                                if (templateTypeName.length() \u003d\u003d 0) {\n                                    parser.addWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno());\n                                } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {\n                                    parser.addWarning(\"msg.jsdoc.template.at.most.once\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d templateInfo.token;\n                                continue retry;\n                            case VERSION:\n                                ExtractionInfo versionInfo \u003d extractSingleLineBlock();\n                                String version \u003d versionInfo.string;\n                                if (version.length() \u003d\u003d 0) {\n                                    parser.addWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno());\n                                } else {\n                                    if (!jsdocBuilder.recordVersion(version)) {\n                                        parser.addWarning(\"msg.jsdoc.extraversion\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d versionInfo.token;\n                                continue retry;\n                            case DEFINE:\n                            case RETURN:\n                            case THIS:\n                            case TYPE:\n                            case TYPEDEF:\n                                skipEOLs();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                token \u003d next();\n                                Node typeNode \u003d parseAndRecordTypeNode(token, lineno, charno);\n                                if (annotation \u003d\u003d Annotation.THIS) {\n                                    typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                    if (typeNode !\u003d null \u0026\u0026 token !\u003d JsDocToken.LC) {\n                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                    }\n                                }\n                                type \u003d createJSTypeExpression(typeNode);\n                                if (type \u003d\u003d null) {\n                                } else {\n                                    switch(annotation) {\n                                        case DEFINE:\n                                            if (!jsdocBuilder.recordDefineType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.define\", lineno, charno);\n                                            }\n                                            break;\n                                        case RETURN:\n                                            if (!jsdocBuilder.recordReturnType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                                break;\n                                            }\n                                            token \u003d current();\n                                            if (jsdocBuilder.shouldParseDocumentation()) {\n                                                ExtractionInfo returnDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                                String returnDescription \u003d returnDescriptionInfo.string;\n                                                if (returnDescription.length() \u003e 0) {\n                                                    jsdocBuilder.recordReturnDescription(returnDescription);\n                                                }\n                                                token \u003d returnDescriptionInfo.token;\n                                            } else {\n                                                token \u003d eatTokensUntilEOL(token);\n                                            }\n                                            continue retry;\n                                        case THIS:\n                                            if (!jsdocBuilder.recordThisType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                        case TYPE:\n                                            if (!jsdocBuilder.recordType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                        case TYPEDEF:\n                                            if (!jsdocBuilder.recordTypedef(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                    }\n                                    token \u003d eatTokensUntilEOL();\n                                }\n                                continue retry;\n                        }\n                    }\n                }\n                break;\n            case EOC:\n                if (hasParsedFileOverviewDocInfo()) {\n                    fileOverviewJSDocInfo \u003d retrieveAndResetParsedJSDocInfo();\n                }\n                return true;\n            case EOF:\n                jsdocBuilder.build(null);\n                parser.addWarning(\"msg.unexpected.eof\", stream.getLineno(), stream.getCharno());\n                return false;\n            case EOL:\n                if (state \u003d\u003d State.SEARCHING_NEWLINE) {\n                    state \u003d State.SEARCHING_ANNOTATION;\n                }\n                token \u003d next();\n                continue retry;\n            default:\n                if (token \u003d\u003d JsDocToken.STAR \u0026\u0026 state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                    token \u003d next();\n                    continue retry;\n                } else {\n                    state \u003d State.SEARCHING_NEWLINE;\n                    token \u003d eatTokensUntilEOL();\n                    continue retry;\n                }\n        }\n        token \u003d next();\n    }\n}",
      "path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
      "functionStartLine": 134,
      "functionName": "parse",
      "functionAnnotation": "",
      "functionDoc": "Parses a {@link JSDocInfo} object. This parsing method reads all tokens\nreturned by the {@link JsDocTokenStream#getJsDocToken()} method until the\n{@link JsDocToken#EOC} is returned.\n\n@return @code true} if JSDoc information was correctly parsed,\n    {@code false} otherwise\n",
      "diff": "@@ -1,472 +1,504 @@\n boolean parse() {\n     int lineno;\n     int charno;\n     JSTypeExpression type;\n     state \u003d State.SEARCHING_ANNOTATION;\n+    skipEOLs();\n     JsDocToken token \u003d next();\n-    ExtractionInfo blockInfo \u003d extractBlockComment(token);\n-    token \u003d blockInfo.token;\n-    if (blockInfo.string.length() \u003e 0) {\n-        jsdocBuilder.recordBlockDescription(blockInfo.string);\n+    if (jsdocBuilder.shouldParseDocumentation()) {\n+        ExtractionInfo blockInfo \u003d extractBlockComment(token);\n+        token \u003d blockInfo.token;\n+        if (!blockInfo.string.isEmpty()) {\n+            jsdocBuilder.recordBlockDescription(blockInfo.string);\n+        }\n+    } else {\n+        if (token !\u003d JsDocToken.ANNOTATION \u0026\u0026 token !\u003d JsDocToken.EOC) {\n+            jsdocBuilder.recordBlockDescription(\"\");\n+        }\n     }\n     retry: for (; ; ) {\n         switch(token) {\n             case ANNOTATION:\n                 if (state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                     state \u003d State.SEARCHING_NEWLINE;\n                     lineno \u003d stream.getLineno();\n                     charno \u003d stream.getCharno();\n                     String annotationName \u003d stream.getString();\n                     Annotation annotation \u003d annotationNames.get(annotationName);\n                     if (annotation \u003d\u003d null) {\n                         parser.addWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno());\n                     } else {\n                         jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n                         switch(annotation) {\n                             case AUTHOR:\n-                                ExtractionInfo authorInfo \u003d extractSingleLineBlock();\n-                                String author \u003d authorInfo.string;\n-                                if (author.length() \u003d\u003d 0) {\n-                                    parser.addWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno());\n+                                if (jsdocBuilder.shouldParseDocumentation()) {\n+                                    ExtractionInfo authorInfo \u003d extractSingleLineBlock();\n+                                    String author \u003d authorInfo.string;\n+                                    if (author.length() \u003d\u003d 0) {\n+                                        parser.addWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno());\n+                                    } else {\n+                                        jsdocBuilder.addAuthor(author);\n+                                    }\n+                                    token \u003d authorInfo.token;\n                                 } else {\n-                                    jsdocBuilder.addAuthor(author);\n+                                    token \u003d eatTokensUntilEOL(token);\n                                 }\n-                                token \u003d authorInfo.token;\n                                 continue retry;\n                             case CONSTANT:\n                                 if (!jsdocBuilder.recordConstancy()) {\n                                     parser.addWarning(\"msg.jsdoc.const\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case CONSTRUCTOR:\n                                 if (!jsdocBuilder.recordConstructor()) {\n                                     if (jsdocBuilder.isInterfaceRecorded()) {\n                                         parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                     } else {\n                                         parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case DEPRECATED:\n                                 if (!jsdocBuilder.recordDeprecated()) {\n                                     parser.addWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 ExtractionInfo reasonInfo \u003d extractMultilineTextualBlock(token);\n                                 String reason \u003d reasonInfo.string;\n                                 if (reason.length() \u003e 0) {\n                                     jsdocBuilder.recordDeprecationReason(reason);\n                                 }\n                                 token \u003d reasonInfo.token;\n                                 continue retry;\n                             case INTERFACE:\n                                 if (!jsdocBuilder.recordInterface()) {\n                                     if (jsdocBuilder.isConstructorRecorded()) {\n                                         parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                     } else {\n                                         parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case DESC:\n                                 if (jsdocBuilder.isDescriptionRecorded()) {\n                                     parser.addWarning(\"msg.jsdoc.desc.extra\", stream.getLineno(), stream.getCharno());\n                                     token \u003d eatTokensUntilEOL();\n                                     continue retry;\n                                 } else {\n                                     ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                     String description \u003d descriptionInfo.string;\n                                     jsdocBuilder.recordDescription(description);\n                                     token \u003d descriptionInfo.token;\n                                     continue retry;\n                                 }\n                             case FILE_OVERVIEW:\n-                                ExtractionInfo fileOverviewInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.TRIM);\n-                                String fileOverview \u003d fileOverviewInfo.string;\n+                                String fileOverview \u003d \"\";\n+                                if (jsdocBuilder.shouldParseDocumentation()) {\n+                                    ExtractionInfo fileOverviewInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.TRIM);\n+                                    fileOverview \u003d fileOverviewInfo.string;\n+                                    token \u003d fileOverviewInfo.token;\n+                                } else {\n+                                    token \u003d eatTokensUntilEOL(token);\n+                                }\n                                 if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo !\u003d null) {\n                                     parser.addWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno());\n                                 }\n-                                token \u003d fileOverviewInfo.token;\n                                 continue retry;\n                             case LICENSE:\n                             case PRESERVE:\n                                 ExtractionInfo preserveInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);\n                                 String preserve \u003d preserveInfo.string;\n                                 if (preserve.length() \u003e 0) {\n                                     if (fileLevelJsDocBuilder !\u003d null) {\n                                         fileLevelJsDocBuilder.append(preserve);\n                                     }\n                                 }\n                                 token \u003d preserveInfo.token;\n                                 continue retry;\n                             case ENUM:\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                 }\n                                 if (type \u003d\u003d null) {\n                                     type \u003d createJSTypeExpression(newStringNode(\"number\"));\n                                 }\n                                 if (!jsdocBuilder.recordEnumParameterType(type)) {\n                                     parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                 }\n                                 token \u003d eatTokensUntilEOL(token);\n                                 continue retry;\n                             case EXPORT:\n                                 if (!jsdocBuilder.recordExport()) {\n                                     parser.addWarning(\"msg.jsdoc.export\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case EXTERNS:\n                                 if (!jsdocBuilder.recordExterns()) {\n                                     parser.addWarning(\"msg.jsdoc.externs\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case JAVA_DISPATCH:\n                                 if (!jsdocBuilder.recordJavaDispatch()) {\n                                     parser.addWarning(\"msg.jsdoc.javadispatch\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case EXTENDS:\n                             case IMPLEMENTS:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 boolean matchingRc \u003d false;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     token \u003d next();\n                                     matchingRc \u003d true;\n                                 }\n                                 if (token \u003d\u003d JsDocToken.STRING) {\n                                     Node typeNode \u003d parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);\n                                     lineno \u003d stream.getLineno();\n                                     charno \u003d stream.getCharno();\n                                     typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                     if (typeNode !\u003d null \u0026\u0026 !matchingRc) {\n                                         typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                     }\n                                     type \u003d createJSTypeExpression(typeNode);\n                                     if (annotation \u003d\u003d Annotation.EXTENDS) {\n                                         if (!jsdocBuilder.recordBaseType(type)) {\n                                             parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                         }\n                                     } else {\n                                         Preconditions.checkState(annotation \u003d\u003d Annotation.IMPLEMENTS);\n                                         if (!jsdocBuilder.recordImplementedInterface(type)) {\n                                             parser.addWarning(\"msg.jsdoc.implements.duplicate\", lineno, charno);\n                                         }\n                                     }\n                                     token \u003d next();\n                                     if (matchingRc) {\n                                         if (token !\u003d JsDocToken.RC) {\n                                             parser.addWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                         }\n                                     } else if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOF \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                         parser.addWarning(\"msg.end.annotation.expected\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 } else {\n                                     parser.addWarning(\"msg.no.type.name\", lineno, charno);\n                                 }\n                                 token \u003d eatTokensUntilEOL(token);\n                                 continue retry;\n                             case HIDDEN:\n                                 if (!jsdocBuilder.recordHiddenness()) {\n                                     parser.addWarning(\"msg.jsdoc.hidden\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case MEANING:\n                                 ExtractionInfo meaningInfo \u003d extractMultilineTextualBlock(token);\n                                 String meaning \u003d meaningInfo.string;\n                                 token \u003d meaningInfo.token;\n                                 if (!jsdocBuilder.recordMeaning(meaning)) {\n                                     parser.addWarning(\"msg.jsdoc.meaning.extra\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 continue retry;\n                             case NO_ALIAS:\n                                 if (!jsdocBuilder.recordNoAlias()) {\n                                     parser.addWarning(\"msg.jsdoc.noalias\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_COMPILE:\n                                 if (!jsdocBuilder.recordNoCompile()) {\n                                     parser.addWarning(\"msg.jsdoc.nocompile\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_TYPE_CHECK:\n                                 if (!jsdocBuilder.recordNoTypeCheck()) {\n                                     parser.addWarning(\"msg.jsdoc.nocheck\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NOT_IMPLEMENTED:\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case INHERIT_DOC:\n                             case OVERRIDE:\n                                 if (!jsdocBuilder.recordOverride()) {\n                                     parser.addWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case THROWS:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                     if (type \u003d\u003d null) {\n                                         token \u003d eatTokensUntilEOL();\n                                         continue retry;\n                                     }\n                                 }\n                                 token \u003d current();\n                                 jsdocBuilder.recordThrowType(type);\n-                                ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n-                                String description \u003d descriptionInfo.string;\n-                                if (description.length() \u003e 0) {\n-                                    jsdocBuilder.recordThrowDescription(type, description);\n+                                if (jsdocBuilder.shouldParseDocumentation()) {\n+                                    ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n+                                    String description \u003d descriptionInfo.string;\n+                                    if (description.length() \u003e 0) {\n+                                        jsdocBuilder.recordThrowDescription(type, description);\n+                                    }\n+                                    token \u003d descriptionInfo.token;\n+                                } else {\n+                                    token \u003d eatTokensUntilEOL(token);\n                                 }\n-                                token \u003d descriptionInfo.token;\n                                 continue retry;\n                             case PARAM:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordParamTypeNode(token));\n                                     if (type \u003d\u003d null) {\n                                         token \u003d eatTokensUntilEOL();\n                                         continue retry;\n                                     }\n                                     skipEOLs();\n                                     token \u003d next();\n                                     lineno \u003d stream.getLineno();\n                                     charno \u003d stream.getCharno();\n                                 }\n                                 String name \u003d null;\n                                 boolean isBracketedParam \u003d JsDocToken.LB \u003d\u003d token;\n                                 if (isBracketedParam) {\n                                     token \u003d next();\n                                 }\n                                 if (JsDocToken.STRING !\u003d token) {\n                                     parser.addWarning(\"msg.missing.variable.name\", lineno, charno);\n                                 } else {\n                                     name \u003d stream.getString();\n                                     if (isBracketedParam) {\n                                         token \u003d next();\n                                         if (JsDocToken.EQUALS \u003d\u003d token) {\n                                             token \u003d next();\n                                             if (JsDocToken.STRING \u003d\u003d token) {\n                                                 token \u003d next();\n                                             }\n                                         }\n                                         if (JsDocToken.RB !\u003d token) {\n                                             reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                                         } else if (type !\u003d null) {\n                                             type \u003d JSTypeExpression.makeOptionalArg(type);\n                                         }\n                                     }\n                                     if (name.indexOf(\u0027.\u0027) \u003e -1) {\n                                         name \u003d null;\n                                     } else if (!jsdocBuilder.recordParameter(name, type)) {\n                                         if (jsdocBuilder.hasParameter(name)) {\n                                             parser.addWarning(\"msg.dup.variable.name\", name, lineno, charno);\n                                         } else {\n                                             parser.addWarning(\"msg.jsdoc.incompat.type\", name, lineno, charno);\n                                         }\n                                     }\n                                 }\n                                 if (name \u003d\u003d null) {\n                                     token \u003d eatTokensUntilEOL(token);\n                                     continue retry;\n                                 }\n                                 jsdocBuilder.markName(name, lineno, charno);\n-                                ExtractionInfo paramDescriptionInfo \u003d extractMultilineTextualBlock(token);\n-                                String paramDescription \u003d paramDescriptionInfo.string;\n-                                if (paramDescription.length() \u003e 0) {\n-                                    jsdocBuilder.recordParameterDescription(name, paramDescription);\n+                                if (jsdocBuilder.shouldParseDocumentation()) {\n+                                    ExtractionInfo paramDescriptionInfo \u003d extractMultilineTextualBlock(token);\n+                                    String paramDescription \u003d paramDescriptionInfo.string;\n+                                    if (paramDescription.length() \u003e 0) {\n+                                        jsdocBuilder.recordParameterDescription(name, paramDescription);\n+                                    }\n+                                    token \u003d paramDescriptionInfo.token;\n+                                } else {\n+                                    token \u003d eatTokensUntilEOL(token);\n                                 }\n-                                token \u003d paramDescriptionInfo.token;\n                                 continue retry;\n                             case PRESERVE_TRY:\n                                 if (!jsdocBuilder.recordPreserveTry()) {\n                                     parser.addWarning(\"msg.jsdoc.preservertry\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PRIVATE:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                                     parser.addWarning(\"msg.jsdoc.visibility.private\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PROTECTED:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                                     parser.addWarning(\"msg.jsdoc.visibility.protected\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PUBLIC:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                                     parser.addWarning(\"msg.jsdoc.visibility.public\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_SHADOW:\n                                 if (!jsdocBuilder.recordNoShadow()) {\n                                     parser.addWarning(\"msg.jsdoc.noshadow\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_SIDE_EFFECTS:\n                                 if (!jsdocBuilder.recordNoSideEffects()) {\n                                     parser.addWarning(\"msg.jsdoc.nosideeffects\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case IMPLICIT_CAST:\n                                 if (!jsdocBuilder.recordImplicitCast()) {\n                                     parser.addWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case SEE:\n-                                ExtractionInfo referenceInfo \u003d extractSingleLineBlock();\n-                                String reference \u003d referenceInfo.string;\n-                                if (reference.length() \u003d\u003d 0) {\n-                                    parser.addWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno());\n+                                if (jsdocBuilder.shouldParseDocumentation()) {\n+                                    ExtractionInfo referenceInfo \u003d extractSingleLineBlock();\n+                                    String reference \u003d referenceInfo.string;\n+                                    if (reference.length() \u003d\u003d 0) {\n+                                        parser.addWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno());\n+                                    } else {\n+                                        jsdocBuilder.addReference(reference);\n+                                    }\n+                                    token \u003d referenceInfo.token;\n                                 } else {\n-                                    jsdocBuilder.addReference(reference);\n+                                    token \u003d eatTokensUntilEOL(token);\n                                 }\n-                                token \u003d referenceInfo.token;\n                                 continue retry;\n                             case SUPPRESS:\n                                 token \u003d parseSuppressTag(next());\n                                 continue retry;\n                             case TEMPLATE:\n                                 ExtractionInfo templateInfo \u003d extractSingleLineBlock();\n                                 String templateTypeName \u003d templateInfo.string;\n                                 if (templateTypeName.length() \u003d\u003d 0) {\n                                     parser.addWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno());\n                                 } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {\n                                     parser.addWarning(\"msg.jsdoc.template.at.most.once\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d templateInfo.token;\n                                 continue retry;\n                             case VERSION:\n                                 ExtractionInfo versionInfo \u003d extractSingleLineBlock();\n                                 String version \u003d versionInfo.string;\n                                 if (version.length() \u003d\u003d 0) {\n                                     parser.addWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno());\n                                 } else {\n                                     if (!jsdocBuilder.recordVersion(version)) {\n                                         parser.addWarning(\"msg.jsdoc.extraversion\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d versionInfo.token;\n                                 continue retry;\n                             case DEFINE:\n                             case RETURN:\n                             case THIS:\n                             case TYPE:\n                             case TYPEDEF:\n                                 skipEOLs();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 token \u003d next();\n                                 Node typeNode \u003d parseAndRecordTypeNode(token, lineno, charno);\n                                 if (annotation \u003d\u003d Annotation.THIS) {\n                                     typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                     if (typeNode !\u003d null \u0026\u0026 token !\u003d JsDocToken.LC) {\n                                         typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                     }\n                                 }\n                                 type \u003d createJSTypeExpression(typeNode);\n                                 if (type \u003d\u003d null) {\n                                 } else {\n                                     switch(annotation) {\n                                         case DEFINE:\n                                             if (!jsdocBuilder.recordDefineType(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.define\", lineno, charno);\n                                             }\n                                             break;\n                                         case RETURN:\n                                             if (!jsdocBuilder.recordReturnType(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                                 break;\n                                             }\n                                             token \u003d current();\n-                                            ExtractionInfo returnDescriptionInfo \u003d extractMultilineTextualBlock(token);\n-                                            String returnDescription \u003d returnDescriptionInfo.string;\n-                                            if (returnDescription.length() \u003e 0) {\n-                                                jsdocBuilder.recordReturnDescription(returnDescription);\n+                                            if (jsdocBuilder.shouldParseDocumentation()) {\n+                                                ExtractionInfo returnDescriptionInfo \u003d extractMultilineTextualBlock(token);\n+                                                String returnDescription \u003d returnDescriptionInfo.string;\n+                                                if (returnDescription.length() \u003e 0) {\n+                                                    jsdocBuilder.recordReturnDescription(returnDescription);\n+                                                }\n+                                                token \u003d returnDescriptionInfo.token;\n+                                            } else {\n+                                                token \u003d eatTokensUntilEOL(token);\n                                             }\n-                                            token \u003d returnDescriptionInfo.token;\n                                             continue retry;\n                                         case THIS:\n                                             if (!jsdocBuilder.recordThisType(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                         case TYPE:\n                                             if (!jsdocBuilder.recordType(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                         case TYPEDEF:\n                                             if (!jsdocBuilder.recordTypedef(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                     }\n                                     token \u003d eatTokensUntilEOL();\n                                 }\n                                 continue retry;\n                         }\n                     }\n                 }\n                 break;\n             case EOC:\n                 if (hasParsedFileOverviewDocInfo()) {\n                     fileOverviewJSDocInfo \u003d retrieveAndResetParsedJSDocInfo();\n                 }\n                 return true;\n             case EOF:\n                 jsdocBuilder.build(null);\n                 parser.addWarning(\"msg.unexpected.eof\", stream.getLineno(), stream.getCharno());\n                 return false;\n             case EOL:\n                 if (state \u003d\u003d State.SEARCHING_NEWLINE) {\n                     state \u003d State.SEARCHING_ANNOTATION;\n                 }\n                 token \u003d next();\n                 continue retry;\n             default:\n                 if (token \u003d\u003d JsDocToken.STAR \u0026\u0026 state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                     token \u003d next();\n                     continue retry;\n                 } else {\n                     state \u003d State.SEARCHING_NEWLINE;\n                     token \u003d eatTokensUntilEOL();\n                     continue retry;\n                 }\n         }\n         token \u003d next();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "22775ad7cad0bea94d56726e1d6a80f31604c118": {
      "type": "Ybodychange",
      "commitMessage": "\nAdd a @meaning annotation so that soy templates can inject meaning.\n\nR\u003djschorr\nDELTA\u003d76  (76 added, 0 deleted, 0 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d206098\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@404 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "9/2/10, 2:52 PM",
      "commitName": "22775ad7cad0bea94d56726e1d6a80f31604c118",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "8/12/10, 6:02 PM",
      "commitNameOld": "15acafb00636f99295b394145b9b60a5e624ddfa",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 20.87,
      "commitsBetweenForRepo": 45,
      "commitsBetweenForFile": 1,
      "actualSource": "boolean parse() {\n    int lineno;\n    int charno;\n    JSTypeExpression type;\n    state \u003d State.SEARCHING_ANNOTATION;\n    JsDocToken token \u003d next();\n    ExtractionInfo blockInfo \u003d extractBlockComment(token);\n    token \u003d blockInfo.token;\n    if (blockInfo.string.length() \u003e 0) {\n        jsdocBuilder.recordBlockDescription(blockInfo.string);\n    }\n    retry: for (; ; ) {\n        switch(token) {\n            case ANNOTATION:\n                if (state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                    state \u003d State.SEARCHING_NEWLINE;\n                    lineno \u003d stream.getLineno();\n                    charno \u003d stream.getCharno();\n                    String annotationName \u003d stream.getString();\n                    Annotation annotation \u003d annotationNames.get(annotationName);\n                    if (annotation \u003d\u003d null) {\n                        parser.addWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno());\n                    } else {\n                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n                        switch(annotation) {\n                            case AUTHOR:\n                                ExtractionInfo authorInfo \u003d extractSingleLineBlock();\n                                String author \u003d authorInfo.string;\n                                if (author.length() \u003d\u003d 0) {\n                                    parser.addWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno());\n                                } else {\n                                    jsdocBuilder.addAuthor(author);\n                                }\n                                token \u003d authorInfo.token;\n                                continue retry;\n                            case CONSTANT:\n                                if (!jsdocBuilder.recordConstancy()) {\n                                    parser.addWarning(\"msg.jsdoc.const\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case CONSTRUCTOR:\n                                if (!jsdocBuilder.recordConstructor()) {\n                                    if (jsdocBuilder.isInterfaceRecorded()) {\n                                        parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case DEPRECATED:\n                                if (!jsdocBuilder.recordDeprecated()) {\n                                    parser.addWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno());\n                                }\n                                ExtractionInfo reasonInfo \u003d extractMultilineTextualBlock(token);\n                                String reason \u003d reasonInfo.string;\n                                if (reason.length() \u003e 0) {\n                                    jsdocBuilder.recordDeprecationReason(reason);\n                                }\n                                token \u003d reasonInfo.token;\n                                continue retry;\n                            case INTERFACE:\n                                if (!jsdocBuilder.recordInterface()) {\n                                    if (jsdocBuilder.isConstructorRecorded()) {\n                                        parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case DESC:\n                                if (jsdocBuilder.isDescriptionRecorded()) {\n                                    parser.addWarning(\"msg.jsdoc.desc.extra\", stream.getLineno(), stream.getCharno());\n                                    token \u003d eatTokensUntilEOL();\n                                    continue retry;\n                                } else {\n                                    ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                    String description \u003d descriptionInfo.string;\n                                    jsdocBuilder.recordDescription(description);\n                                    token \u003d descriptionInfo.token;\n                                    continue retry;\n                                }\n                            case FILE_OVERVIEW:\n                                ExtractionInfo fileOverviewInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.TRIM);\n                                String fileOverview \u003d fileOverviewInfo.string;\n                                if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo !\u003d null) {\n                                    parser.addWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d fileOverviewInfo.token;\n                                continue retry;\n                            case LICENSE:\n                            case PRESERVE:\n                                ExtractionInfo preserveInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);\n                                String preserve \u003d preserveInfo.string;\n                                if (preserve.length() \u003e 0) {\n                                    if (fileLevelJsDocBuilder !\u003d null) {\n                                        fileLevelJsDocBuilder.append(preserve);\n                                    }\n                                }\n                                token \u003d preserveInfo.token;\n                                continue retry;\n                            case ENUM:\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                }\n                                if (type \u003d\u003d null) {\n                                    type \u003d createJSTypeExpression(newStringNode(\"number\"));\n                                }\n                                if (!jsdocBuilder.recordEnumParameterType(type)) {\n                                    parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                }\n                                token \u003d eatTokensUntilEOL(token);\n                                continue retry;\n                            case EXPORT:\n                                if (!jsdocBuilder.recordExport()) {\n                                    parser.addWarning(\"msg.jsdoc.export\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case EXTERNS:\n                                if (!jsdocBuilder.recordExterns()) {\n                                    parser.addWarning(\"msg.jsdoc.externs\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case JAVA_DISPATCH:\n                                if (!jsdocBuilder.recordJavaDispatch()) {\n                                    parser.addWarning(\"msg.jsdoc.javadispatch\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case EXTENDS:\n                            case IMPLEMENTS:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                boolean matchingRc \u003d false;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    token \u003d next();\n                                    matchingRc \u003d true;\n                                }\n                                if (token \u003d\u003d JsDocToken.STRING) {\n                                    Node typeNode \u003d parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);\n                                    lineno \u003d stream.getLineno();\n                                    charno \u003d stream.getCharno();\n                                    typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                    if (typeNode !\u003d null \u0026\u0026 !matchingRc) {\n                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                    }\n                                    type \u003d createJSTypeExpression(typeNode);\n                                    if (annotation \u003d\u003d Annotation.EXTENDS) {\n                                        if (!jsdocBuilder.recordBaseType(type)) {\n                                            parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                        }\n                                    } else {\n                                        Preconditions.checkState(annotation \u003d\u003d Annotation.IMPLEMENTS);\n                                        if (!jsdocBuilder.recordImplementedInterface(type)) {\n                                            parser.addWarning(\"msg.jsdoc.implements.duplicate\", lineno, charno);\n                                        }\n                                    }\n                                    token \u003d next();\n                                    if (matchingRc) {\n                                        if (token !\u003d JsDocToken.RC) {\n                                            parser.addWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                        }\n                                    } else if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOF \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                        parser.addWarning(\"msg.end.annotation.expected\", stream.getLineno(), stream.getCharno());\n                                    }\n                                } else {\n                                    parser.addWarning(\"msg.no.type.name\", lineno, charno);\n                                }\n                                token \u003d eatTokensUntilEOL(token);\n                                continue retry;\n                            case HIDDEN:\n                                if (!jsdocBuilder.recordHiddenness()) {\n                                    parser.addWarning(\"msg.jsdoc.hidden\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case MEANING:\n                                ExtractionInfo meaningInfo \u003d extractMultilineTextualBlock(token);\n                                String meaning \u003d meaningInfo.string;\n                                token \u003d meaningInfo.token;\n                                if (!jsdocBuilder.recordMeaning(meaning)) {\n                                    parser.addWarning(\"msg.jsdoc.meaning.extra\", stream.getLineno(), stream.getCharno());\n                                }\n                                continue retry;\n                            case NO_ALIAS:\n                                if (!jsdocBuilder.recordNoAlias()) {\n                                    parser.addWarning(\"msg.jsdoc.noalias\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_COMPILE:\n                                if (!jsdocBuilder.recordNoCompile()) {\n                                    parser.addWarning(\"msg.jsdoc.nocompile\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_TYPE_CHECK:\n                                if (!jsdocBuilder.recordNoTypeCheck()) {\n                                    parser.addWarning(\"msg.jsdoc.nocheck\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NOT_IMPLEMENTED:\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case INHERIT_DOC:\n                            case OVERRIDE:\n                                if (!jsdocBuilder.recordOverride()) {\n                                    parser.addWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case THROWS:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                    if (type \u003d\u003d null) {\n                                        token \u003d eatTokensUntilEOL();\n                                        continue retry;\n                                    }\n                                }\n                                token \u003d current();\n                                jsdocBuilder.recordThrowType(type);\n                                ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                String description \u003d descriptionInfo.string;\n                                if (description.length() \u003e 0) {\n                                    jsdocBuilder.recordThrowDescription(type, description);\n                                }\n                                token \u003d descriptionInfo.token;\n                                continue retry;\n                            case PARAM:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordParamTypeNode(token));\n                                    if (type \u003d\u003d null) {\n                                        token \u003d eatTokensUntilEOL();\n                                        continue retry;\n                                    }\n                                    skipEOLs();\n                                    token \u003d next();\n                                    lineno \u003d stream.getLineno();\n                                    charno \u003d stream.getCharno();\n                                }\n                                String name \u003d null;\n                                boolean isBracketedParam \u003d JsDocToken.LB \u003d\u003d token;\n                                if (isBracketedParam) {\n                                    token \u003d next();\n                                }\n                                if (JsDocToken.STRING !\u003d token) {\n                                    parser.addWarning(\"msg.missing.variable.name\", lineno, charno);\n                                } else {\n                                    name \u003d stream.getString();\n                                    if (isBracketedParam) {\n                                        token \u003d next();\n                                        if (JsDocToken.EQUALS \u003d\u003d token) {\n                                            token \u003d next();\n                                            if (JsDocToken.STRING \u003d\u003d token) {\n                                                token \u003d next();\n                                            }\n                                        }\n                                        if (JsDocToken.RB !\u003d token) {\n                                            reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                                        } else if (type !\u003d null) {\n                                            type \u003d JSTypeExpression.makeOptionalArg(type);\n                                        }\n                                    }\n                                    if (name.indexOf(\u0027.\u0027) \u003e -1) {\n                                        name \u003d null;\n                                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                                        if (jsdocBuilder.hasParameter(name)) {\n                                            parser.addWarning(\"msg.dup.variable.name\", name, lineno, charno);\n                                        } else {\n                                            parser.addWarning(\"msg.jsdoc.incompat.type\", name, lineno, charno);\n                                        }\n                                    }\n                                }\n                                if (name \u003d\u003d null) {\n                                    token \u003d eatTokensUntilEOL(token);\n                                    continue retry;\n                                }\n                                jsdocBuilder.markName(name, lineno, charno);\n                                ExtractionInfo paramDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                String paramDescription \u003d paramDescriptionInfo.string;\n                                if (paramDescription.length() \u003e 0) {\n                                    jsdocBuilder.recordParameterDescription(name, paramDescription);\n                                }\n                                token \u003d paramDescriptionInfo.token;\n                                continue retry;\n                            case PRESERVE_TRY:\n                                if (!jsdocBuilder.recordPreserveTry()) {\n                                    parser.addWarning(\"msg.jsdoc.preservertry\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PRIVATE:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                                    parser.addWarning(\"msg.jsdoc.visibility.private\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PROTECTED:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                                    parser.addWarning(\"msg.jsdoc.visibility.protected\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PUBLIC:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                                    parser.addWarning(\"msg.jsdoc.visibility.public\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_SHADOW:\n                                if (!jsdocBuilder.recordNoShadow()) {\n                                    parser.addWarning(\"msg.jsdoc.noshadow\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_SIDE_EFFECTS:\n                                if (!jsdocBuilder.recordNoSideEffects()) {\n                                    parser.addWarning(\"msg.jsdoc.nosideeffects\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case IMPLICIT_CAST:\n                                if (!jsdocBuilder.recordImplicitCast()) {\n                                    parser.addWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case SEE:\n                                ExtractionInfo referenceInfo \u003d extractSingleLineBlock();\n                                String reference \u003d referenceInfo.string;\n                                if (reference.length() \u003d\u003d 0) {\n                                    parser.addWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno());\n                                } else {\n                                    jsdocBuilder.addReference(reference);\n                                }\n                                token \u003d referenceInfo.token;\n                                continue retry;\n                            case SUPPRESS:\n                                token \u003d parseSuppressTag(next());\n                                continue retry;\n                            case TEMPLATE:\n                                ExtractionInfo templateInfo \u003d extractSingleLineBlock();\n                                String templateTypeName \u003d templateInfo.string;\n                                if (templateTypeName.length() \u003d\u003d 0) {\n                                    parser.addWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno());\n                                } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {\n                                    parser.addWarning(\"msg.jsdoc.template.at.most.once\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d templateInfo.token;\n                                continue retry;\n                            case VERSION:\n                                ExtractionInfo versionInfo \u003d extractSingleLineBlock();\n                                String version \u003d versionInfo.string;\n                                if (version.length() \u003d\u003d 0) {\n                                    parser.addWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno());\n                                } else {\n                                    if (!jsdocBuilder.recordVersion(version)) {\n                                        parser.addWarning(\"msg.jsdoc.extraversion\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d versionInfo.token;\n                                continue retry;\n                            case DEFINE:\n                            case RETURN:\n                            case THIS:\n                            case TYPE:\n                            case TYPEDEF:\n                                skipEOLs();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                token \u003d next();\n                                Node typeNode \u003d parseAndRecordTypeNode(token, lineno, charno);\n                                if (annotation \u003d\u003d Annotation.THIS) {\n                                    typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                    if (typeNode !\u003d null \u0026\u0026 token !\u003d JsDocToken.LC) {\n                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                    }\n                                }\n                                type \u003d createJSTypeExpression(typeNode);\n                                if (type \u003d\u003d null) {\n                                } else {\n                                    switch(annotation) {\n                                        case DEFINE:\n                                            if (!jsdocBuilder.recordDefineType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.define\", lineno, charno);\n                                            }\n                                            break;\n                                        case RETURN:\n                                            if (!jsdocBuilder.recordReturnType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                                break;\n                                            }\n                                            token \u003d current();\n                                            ExtractionInfo returnDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                            String returnDescription \u003d returnDescriptionInfo.string;\n                                            if (returnDescription.length() \u003e 0) {\n                                                jsdocBuilder.recordReturnDescription(returnDescription);\n                                            }\n                                            token \u003d returnDescriptionInfo.token;\n                                            continue retry;\n                                        case THIS:\n                                            if (!jsdocBuilder.recordThisType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                        case TYPE:\n                                            if (!jsdocBuilder.recordType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                        case TYPEDEF:\n                                            if (!jsdocBuilder.recordTypedef(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                    }\n                                    token \u003d eatTokensUntilEOL();\n                                }\n                                continue retry;\n                        }\n                    }\n                }\n                break;\n            case EOC:\n                if (hasParsedFileOverviewDocInfo()) {\n                    fileOverviewJSDocInfo \u003d retrieveAndResetParsedJSDocInfo();\n                }\n                return true;\n            case EOF:\n                jsdocBuilder.build(null);\n                parser.addWarning(\"msg.unexpected.eof\", stream.getLineno(), stream.getCharno());\n                return false;\n            case EOL:\n                if (state \u003d\u003d State.SEARCHING_NEWLINE) {\n                    state \u003d State.SEARCHING_ANNOTATION;\n                }\n                token \u003d next();\n                continue retry;\n            default:\n                if (token \u003d\u003d JsDocToken.STAR \u0026\u0026 state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                    token \u003d next();\n                    continue retry;\n                } else {\n                    state \u003d State.SEARCHING_NEWLINE;\n                    token \u003d eatTokensUntilEOL();\n                    continue retry;\n                }\n        }\n        token \u003d next();\n    }\n}",
      "path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
      "functionStartLine": 136,
      "functionName": "parse",
      "functionAnnotation": "",
      "functionDoc": "Parses a {@link JSDocInfo} object. This parsing method reads all tokens\nreturned by the {@link JsDocTokenStream#getJsDocToken()} method until the\n{@link JsDocToken#EOC} is returned.\n\n@return @code true} if JSDoc information was correctly parsed,\n    {@code false} otherwise\n",
      "diff": "@@ -1,464 +1,472 @@\n boolean parse() {\n     int lineno;\n     int charno;\n     JSTypeExpression type;\n     state \u003d State.SEARCHING_ANNOTATION;\n     JsDocToken token \u003d next();\n     ExtractionInfo blockInfo \u003d extractBlockComment(token);\n     token \u003d blockInfo.token;\n     if (blockInfo.string.length() \u003e 0) {\n         jsdocBuilder.recordBlockDescription(blockInfo.string);\n     }\n     retry: for (; ; ) {\n         switch(token) {\n             case ANNOTATION:\n                 if (state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                     state \u003d State.SEARCHING_NEWLINE;\n                     lineno \u003d stream.getLineno();\n                     charno \u003d stream.getCharno();\n                     String annotationName \u003d stream.getString();\n                     Annotation annotation \u003d annotationNames.get(annotationName);\n                     if (annotation \u003d\u003d null) {\n                         parser.addWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno());\n                     } else {\n                         jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n                         switch(annotation) {\n                             case AUTHOR:\n                                 ExtractionInfo authorInfo \u003d extractSingleLineBlock();\n                                 String author \u003d authorInfo.string;\n                                 if (author.length() \u003d\u003d 0) {\n                                     parser.addWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno());\n                                 } else {\n                                     jsdocBuilder.addAuthor(author);\n                                 }\n                                 token \u003d authorInfo.token;\n                                 continue retry;\n                             case CONSTANT:\n                                 if (!jsdocBuilder.recordConstancy()) {\n                                     parser.addWarning(\"msg.jsdoc.const\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case CONSTRUCTOR:\n                                 if (!jsdocBuilder.recordConstructor()) {\n                                     if (jsdocBuilder.isInterfaceRecorded()) {\n                                         parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                     } else {\n                                         parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case DEPRECATED:\n                                 if (!jsdocBuilder.recordDeprecated()) {\n                                     parser.addWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 ExtractionInfo reasonInfo \u003d extractMultilineTextualBlock(token);\n                                 String reason \u003d reasonInfo.string;\n                                 if (reason.length() \u003e 0) {\n                                     jsdocBuilder.recordDeprecationReason(reason);\n                                 }\n                                 token \u003d reasonInfo.token;\n                                 continue retry;\n                             case INTERFACE:\n                                 if (!jsdocBuilder.recordInterface()) {\n                                     if (jsdocBuilder.isConstructorRecorded()) {\n                                         parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                     } else {\n                                         parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case DESC:\n                                 if (jsdocBuilder.isDescriptionRecorded()) {\n                                     parser.addWarning(\"msg.jsdoc.desc.extra\", stream.getLineno(), stream.getCharno());\n                                     token \u003d eatTokensUntilEOL();\n                                     continue retry;\n                                 } else {\n                                     ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                     String description \u003d descriptionInfo.string;\n                                     jsdocBuilder.recordDescription(description);\n                                     token \u003d descriptionInfo.token;\n                                     continue retry;\n                                 }\n                             case FILE_OVERVIEW:\n                                 ExtractionInfo fileOverviewInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.TRIM);\n                                 String fileOverview \u003d fileOverviewInfo.string;\n                                 if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo !\u003d null) {\n                                     parser.addWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d fileOverviewInfo.token;\n                                 continue retry;\n                             case LICENSE:\n                             case PRESERVE:\n                                 ExtractionInfo preserveInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);\n                                 String preserve \u003d preserveInfo.string;\n                                 if (preserve.length() \u003e 0) {\n                                     if (fileLevelJsDocBuilder !\u003d null) {\n                                         fileLevelJsDocBuilder.append(preserve);\n                                     }\n                                 }\n                                 token \u003d preserveInfo.token;\n                                 continue retry;\n                             case ENUM:\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                 }\n                                 if (type \u003d\u003d null) {\n                                     type \u003d createJSTypeExpression(newStringNode(\"number\"));\n                                 }\n                                 if (!jsdocBuilder.recordEnumParameterType(type)) {\n                                     parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                 }\n                                 token \u003d eatTokensUntilEOL(token);\n                                 continue retry;\n                             case EXPORT:\n                                 if (!jsdocBuilder.recordExport()) {\n                                     parser.addWarning(\"msg.jsdoc.export\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case EXTERNS:\n                                 if (!jsdocBuilder.recordExterns()) {\n                                     parser.addWarning(\"msg.jsdoc.externs\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case JAVA_DISPATCH:\n                                 if (!jsdocBuilder.recordJavaDispatch()) {\n                                     parser.addWarning(\"msg.jsdoc.javadispatch\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case EXTENDS:\n                             case IMPLEMENTS:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 boolean matchingRc \u003d false;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     token \u003d next();\n                                     matchingRc \u003d true;\n                                 }\n                                 if (token \u003d\u003d JsDocToken.STRING) {\n                                     Node typeNode \u003d parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);\n                                     lineno \u003d stream.getLineno();\n                                     charno \u003d stream.getCharno();\n                                     typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                     if (typeNode !\u003d null \u0026\u0026 !matchingRc) {\n                                         typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                     }\n                                     type \u003d createJSTypeExpression(typeNode);\n                                     if (annotation \u003d\u003d Annotation.EXTENDS) {\n                                         if (!jsdocBuilder.recordBaseType(type)) {\n                                             parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                         }\n                                     } else {\n                                         Preconditions.checkState(annotation \u003d\u003d Annotation.IMPLEMENTS);\n                                         if (!jsdocBuilder.recordImplementedInterface(type)) {\n                                             parser.addWarning(\"msg.jsdoc.implements.duplicate\", lineno, charno);\n                                         }\n                                     }\n                                     token \u003d next();\n                                     if (matchingRc) {\n                                         if (token !\u003d JsDocToken.RC) {\n                                             parser.addWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                         }\n                                     } else if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOF \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                         parser.addWarning(\"msg.end.annotation.expected\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 } else {\n                                     parser.addWarning(\"msg.no.type.name\", lineno, charno);\n                                 }\n                                 token \u003d eatTokensUntilEOL(token);\n                                 continue retry;\n                             case HIDDEN:\n                                 if (!jsdocBuilder.recordHiddenness()) {\n                                     parser.addWarning(\"msg.jsdoc.hidden\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n+                            case MEANING:\n+                                ExtractionInfo meaningInfo \u003d extractMultilineTextualBlock(token);\n+                                String meaning \u003d meaningInfo.string;\n+                                token \u003d meaningInfo.token;\n+                                if (!jsdocBuilder.recordMeaning(meaning)) {\n+                                    parser.addWarning(\"msg.jsdoc.meaning.extra\", stream.getLineno(), stream.getCharno());\n+                                }\n+                                continue retry;\n                             case NO_ALIAS:\n                                 if (!jsdocBuilder.recordNoAlias()) {\n                                     parser.addWarning(\"msg.jsdoc.noalias\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_COMPILE:\n                                 if (!jsdocBuilder.recordNoCompile()) {\n                                     parser.addWarning(\"msg.jsdoc.nocompile\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_TYPE_CHECK:\n                                 if (!jsdocBuilder.recordNoTypeCheck()) {\n                                     parser.addWarning(\"msg.jsdoc.nocheck\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NOT_IMPLEMENTED:\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case INHERIT_DOC:\n                             case OVERRIDE:\n                                 if (!jsdocBuilder.recordOverride()) {\n                                     parser.addWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case THROWS:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                     if (type \u003d\u003d null) {\n                                         token \u003d eatTokensUntilEOL();\n                                         continue retry;\n                                     }\n                                 }\n                                 token \u003d current();\n                                 jsdocBuilder.recordThrowType(type);\n                                 ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                 String description \u003d descriptionInfo.string;\n                                 if (description.length() \u003e 0) {\n                                     jsdocBuilder.recordThrowDescription(type, description);\n                                 }\n                                 token \u003d descriptionInfo.token;\n                                 continue retry;\n                             case PARAM:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordParamTypeNode(token));\n                                     if (type \u003d\u003d null) {\n                                         token \u003d eatTokensUntilEOL();\n                                         continue retry;\n                                     }\n                                     skipEOLs();\n                                     token \u003d next();\n                                     lineno \u003d stream.getLineno();\n                                     charno \u003d stream.getCharno();\n                                 }\n                                 String name \u003d null;\n                                 boolean isBracketedParam \u003d JsDocToken.LB \u003d\u003d token;\n                                 if (isBracketedParam) {\n                                     token \u003d next();\n                                 }\n                                 if (JsDocToken.STRING !\u003d token) {\n                                     parser.addWarning(\"msg.missing.variable.name\", lineno, charno);\n                                 } else {\n                                     name \u003d stream.getString();\n                                     if (isBracketedParam) {\n                                         token \u003d next();\n                                         if (JsDocToken.EQUALS \u003d\u003d token) {\n                                             token \u003d next();\n                                             if (JsDocToken.STRING \u003d\u003d token) {\n                                                 token \u003d next();\n                                             }\n                                         }\n                                         if (JsDocToken.RB !\u003d token) {\n                                             reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                                         } else if (type !\u003d null) {\n                                             type \u003d JSTypeExpression.makeOptionalArg(type);\n                                         }\n                                     }\n                                     if (name.indexOf(\u0027.\u0027) \u003e -1) {\n                                         name \u003d null;\n                                     } else if (!jsdocBuilder.recordParameter(name, type)) {\n                                         if (jsdocBuilder.hasParameter(name)) {\n                                             parser.addWarning(\"msg.dup.variable.name\", name, lineno, charno);\n                                         } else {\n                                             parser.addWarning(\"msg.jsdoc.incompat.type\", name, lineno, charno);\n                                         }\n                                     }\n                                 }\n                                 if (name \u003d\u003d null) {\n                                     token \u003d eatTokensUntilEOL(token);\n                                     continue retry;\n                                 }\n                                 jsdocBuilder.markName(name, lineno, charno);\n                                 ExtractionInfo paramDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                 String paramDescription \u003d paramDescriptionInfo.string;\n                                 if (paramDescription.length() \u003e 0) {\n                                     jsdocBuilder.recordParameterDescription(name, paramDescription);\n                                 }\n                                 token \u003d paramDescriptionInfo.token;\n                                 continue retry;\n                             case PRESERVE_TRY:\n                                 if (!jsdocBuilder.recordPreserveTry()) {\n                                     parser.addWarning(\"msg.jsdoc.preservertry\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PRIVATE:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                                     parser.addWarning(\"msg.jsdoc.visibility.private\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PROTECTED:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                                     parser.addWarning(\"msg.jsdoc.visibility.protected\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PUBLIC:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                                     parser.addWarning(\"msg.jsdoc.visibility.public\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_SHADOW:\n                                 if (!jsdocBuilder.recordNoShadow()) {\n                                     parser.addWarning(\"msg.jsdoc.noshadow\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_SIDE_EFFECTS:\n                                 if (!jsdocBuilder.recordNoSideEffects()) {\n                                     parser.addWarning(\"msg.jsdoc.nosideeffects\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case IMPLICIT_CAST:\n                                 if (!jsdocBuilder.recordImplicitCast()) {\n                                     parser.addWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case SEE:\n                                 ExtractionInfo referenceInfo \u003d extractSingleLineBlock();\n                                 String reference \u003d referenceInfo.string;\n                                 if (reference.length() \u003d\u003d 0) {\n                                     parser.addWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno());\n                                 } else {\n                                     jsdocBuilder.addReference(reference);\n                                 }\n                                 token \u003d referenceInfo.token;\n                                 continue retry;\n                             case SUPPRESS:\n                                 token \u003d parseSuppressTag(next());\n                                 continue retry;\n                             case TEMPLATE:\n                                 ExtractionInfo templateInfo \u003d extractSingleLineBlock();\n                                 String templateTypeName \u003d templateInfo.string;\n                                 if (templateTypeName.length() \u003d\u003d 0) {\n                                     parser.addWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno());\n                                 } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {\n                                     parser.addWarning(\"msg.jsdoc.template.at.most.once\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d templateInfo.token;\n                                 continue retry;\n                             case VERSION:\n                                 ExtractionInfo versionInfo \u003d extractSingleLineBlock();\n                                 String version \u003d versionInfo.string;\n                                 if (version.length() \u003d\u003d 0) {\n                                     parser.addWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno());\n                                 } else {\n                                     if (!jsdocBuilder.recordVersion(version)) {\n                                         parser.addWarning(\"msg.jsdoc.extraversion\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d versionInfo.token;\n                                 continue retry;\n                             case DEFINE:\n                             case RETURN:\n                             case THIS:\n                             case TYPE:\n                             case TYPEDEF:\n                                 skipEOLs();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 token \u003d next();\n                                 Node typeNode \u003d parseAndRecordTypeNode(token, lineno, charno);\n                                 if (annotation \u003d\u003d Annotation.THIS) {\n                                     typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                     if (typeNode !\u003d null \u0026\u0026 token !\u003d JsDocToken.LC) {\n                                         typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                     }\n                                 }\n                                 type \u003d createJSTypeExpression(typeNode);\n                                 if (type \u003d\u003d null) {\n                                 } else {\n                                     switch(annotation) {\n                                         case DEFINE:\n                                             if (!jsdocBuilder.recordDefineType(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.define\", lineno, charno);\n                                             }\n                                             break;\n                                         case RETURN:\n                                             if (!jsdocBuilder.recordReturnType(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                                 break;\n                                             }\n                                             token \u003d current();\n                                             ExtractionInfo returnDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                             String returnDescription \u003d returnDescriptionInfo.string;\n                                             if (returnDescription.length() \u003e 0) {\n                                                 jsdocBuilder.recordReturnDescription(returnDescription);\n                                             }\n                                             token \u003d returnDescriptionInfo.token;\n                                             continue retry;\n                                         case THIS:\n                                             if (!jsdocBuilder.recordThisType(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                         case TYPE:\n                                             if (!jsdocBuilder.recordType(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                         case TYPEDEF:\n                                             if (!jsdocBuilder.recordTypedef(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                     }\n                                     token \u003d eatTokensUntilEOL();\n                                 }\n                                 continue retry;\n                         }\n                     }\n                 }\n                 break;\n             case EOC:\n                 if (hasParsedFileOverviewDocInfo()) {\n                     fileOverviewJSDocInfo \u003d retrieveAndResetParsedJSDocInfo();\n                 }\n                 return true;\n             case EOF:\n                 jsdocBuilder.build(null);\n                 parser.addWarning(\"msg.unexpected.eof\", stream.getLineno(), stream.getCharno());\n                 return false;\n             case EOL:\n                 if (state \u003d\u003d State.SEARCHING_NEWLINE) {\n                     state \u003d State.SEARCHING_ANNOTATION;\n                 }\n                 token \u003d next();\n                 continue retry;\n             default:\n                 if (token \u003d\u003d JsDocToken.STAR \u0026\u0026 state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                     token \u003d next();\n                     continue retry;\n                 } else {\n                     state \u003d State.SEARCHING_NEWLINE;\n                     token \u003d eatTokensUntilEOL();\n                     continue retry;\n                 }\n         }\n         token \u003d next();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e33e925eea3a8e4de958864e531e1adc4da62e18": {
      "type": "Ybodychange",
      "commitMessage": "\nChange on 2010/06/14 by johnlenz\n\n        Remove unneed parenthese from hook expressions.\n\n        R\u003dacleung\n        DELTA\u003d76  (20 added, 4 deleted, 52 changed)\n\nChange on 2010/06/14 by johnlenz\n\n        Fix non-determinisim.\n\n        R\u003djschorr\n        DELTA\u003d5  (3 added, 0 deleted, 2 changed)\n\nChange on 2010/06/15 by nicksantos\n\n        fix a regression caused by a change in the ordering in which\n        constant folding is done.\n        parts of PeepholeSubstituteAlternateSyntax will crash if they\n        see a NEG node with a NUMBER child.\n        They were assuming that FoldConstants would fold these into one node.\n\n        R\u003ddcc,acleung\n        DELTA\u003d153  (70 added, 6 deleted, 77 changed)\n\nChange on 2010/06/15 by johnlenz\n\n        More debug diffing improvements: convert unique globally unique names\n        to locally unique names for reproduciblity.\n\n        R\u003dacleung\n        DELTA\u003d222  (44 added, 7 deleted, 171 changed)\n\nChange on 2010/06/15 by nicksantos\n\n        Add the @nocompile annotation as a signal that this file should\n        be dropped silently if it gets pulled into a --manage_closure_dependencies\n        build.\n\n        R\u003dbowdidge,gboyer\n        DELTA\u003d82  (60 added, 1 deleted, 21 changed)\n\nChange on 2010/06/15 by dcc\n\n        Refactor FoldConstants dead code removal into PeepholeRemoveDeadCode.\n\n        R\u003dacleung\n        DELTA\u003d744  (403 added, 307 deleted, 34 changed)\n\nChange on 2010/06/15 by dcc\n\n        ExternExports test now emits type annotation for exported externs.\n                - Changed ExternExportsPass to generate the externs as an AST and then print\n        to a String rather than ad hoc with a StringBuilder.\n                - Changed TypedCodeGenerator to generate \u0027*\u0027 (AllType) for parameters with unknown types rather than \u0027?\u0027 (UnknownType) since \u0027?\u0027 is not valid JSDoc.\n\n        R\u003dacleung\n        DELTA\u003d643  (496 added, 66 deleted, 81 changed)\n\nChange on 2010/06/16 by johnlenz\n\n        Tweak to PureFunctionIndentifier to propagate the side-effects for\n        anonymous function expressions like: (Date.now||function(){return\n        +new Date})()\n\n        R\u003davd\n        DELTA\u003d42  (39 added, 0 deleted, 3 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d29010\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@243 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "6/16/10, 12:33 PM",
      "commitName": "e33e925eea3a8e4de958864e531e1adc4da62e18",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "5/27/10, 10:18 PM",
      "commitNameOld": "6d00ac1a68612aade8a19d7ecc9b180f00ae5234",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 19.59,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "actualSource": "boolean parse() {\n    int lineno;\n    int charno;\n    JSTypeExpression type;\n    state \u003d State.SEARCHING_ANNOTATION;\n    JsDocToken token \u003d next();\n    ExtractionInfo blockInfo \u003d extractBlockComment(token);\n    token \u003d blockInfo.token;\n    if (blockInfo.string.length() \u003e 0) {\n        jsdocBuilder.recordBlockDescription(blockInfo.string);\n    }\n    retry: for (; ; ) {\n        switch(token) {\n            case ANNOTATION:\n                if (state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                    state \u003d State.SEARCHING_NEWLINE;\n                    lineno \u003d stream.getLineno();\n                    charno \u003d stream.getCharno();\n                    String annotationName \u003d stream.getString();\n                    Annotation annotation \u003d annotationNames.get(annotationName);\n                    if (annotation \u003d\u003d null) {\n                        parser.addWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno());\n                    } else {\n                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n                        switch(annotation) {\n                            case AUTHOR:\n                                ExtractionInfo authorInfo \u003d extractSingleLineBlock();\n                                String author \u003d authorInfo.string;\n                                if (author.length() \u003d\u003d 0) {\n                                    parser.addWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno());\n                                } else {\n                                    jsdocBuilder.addAuthor(author);\n                                }\n                                token \u003d authorInfo.token;\n                                continue retry;\n                            case CONSTANT:\n                                if (!jsdocBuilder.recordConstancy()) {\n                                    parser.addWarning(\"msg.jsdoc.const\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case CONSTRUCTOR:\n                                if (!jsdocBuilder.recordConstructor()) {\n                                    if (jsdocBuilder.isInterfaceRecorded()) {\n                                        parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case DEPRECATED:\n                                if (!jsdocBuilder.recordDeprecated()) {\n                                    parser.addWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno());\n                                }\n                                ExtractionInfo reasonInfo \u003d extractMultilineTextualBlock(token);\n                                String reason \u003d reasonInfo.string;\n                                if (reason.length() \u003e 0) {\n                                    jsdocBuilder.recordDeprecationReason(reason);\n                                }\n                                token \u003d reasonInfo.token;\n                                continue retry;\n                            case INTERFACE:\n                                if (!jsdocBuilder.recordInterface()) {\n                                    if (jsdocBuilder.isConstructorRecorded()) {\n                                        parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case DESC:\n                                if (jsdocBuilder.isDescriptionRecorded()) {\n                                    parser.addWarning(\"msg.jsdoc.desc.extra\", stream.getLineno(), stream.getCharno());\n                                    token \u003d eatTokensUntilEOL();\n                                    continue retry;\n                                } else {\n                                    ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                    String description \u003d descriptionInfo.string;\n                                    jsdocBuilder.recordDescription(description);\n                                    token \u003d descriptionInfo.token;\n                                    continue retry;\n                                }\n                            case FILE_OVERVIEW:\n                                ExtractionInfo fileOverviewInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.TRIM);\n                                String fileOverview \u003d fileOverviewInfo.string;\n                                if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo !\u003d null) {\n                                    parser.addWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d fileOverviewInfo.token;\n                                continue retry;\n                            case LICENSE:\n                            case PRESERVE:\n                                ExtractionInfo preserveInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);\n                                String preserve \u003d preserveInfo.string;\n                                if (preserve.length() \u003e 0) {\n                                    if (fileLevelJsDocBuilder !\u003d null) {\n                                        fileLevelJsDocBuilder.append(preserve);\n                                    }\n                                }\n                                token \u003d preserveInfo.token;\n                                continue retry;\n                            case ENUM:\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                }\n                                if (type \u003d\u003d null) {\n                                    type \u003d createJSTypeExpression(newStringNode(\"number\"));\n                                }\n                                if (!jsdocBuilder.recordEnumParameterType(type)) {\n                                    parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                }\n                                token \u003d eatTokensUntilEOL(token);\n                                continue retry;\n                            case EXPORT:\n                                if (!jsdocBuilder.recordExport()) {\n                                    parser.addWarning(\"msg.jsdoc.export\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case EXTERNS:\n                                if (!jsdocBuilder.recordExterns()) {\n                                    parser.addWarning(\"msg.jsdoc.externs\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case JAVA_DISPATCH:\n                                if (!jsdocBuilder.recordJavaDispatch()) {\n                                    parser.addWarning(\"msg.jsdoc.javadispatch\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case EXTENDS:\n                            case IMPLEMENTS:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                boolean matchingRc \u003d false;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    token \u003d next();\n                                    matchingRc \u003d true;\n                                }\n                                if (token \u003d\u003d JsDocToken.STRING) {\n                                    Node typeNode \u003d parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);\n                                    lineno \u003d stream.getLineno();\n                                    charno \u003d stream.getCharno();\n                                    typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                    if (typeNode !\u003d null \u0026\u0026 !matchingRc) {\n                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                    }\n                                    type \u003d createJSTypeExpression(typeNode);\n                                    if (annotation \u003d\u003d Annotation.EXTENDS) {\n                                        if (!jsdocBuilder.recordBaseType(type)) {\n                                            parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                        }\n                                    } else {\n                                        Preconditions.checkState(annotation \u003d\u003d Annotation.IMPLEMENTS);\n                                        if (!jsdocBuilder.recordImplementedInterface(type)) {\n                                            parser.addWarning(\"msg.jsdoc.implements.duplicate\", lineno, charno);\n                                        }\n                                    }\n                                    token \u003d next();\n                                    if (matchingRc) {\n                                        if (token !\u003d JsDocToken.RC) {\n                                            parser.addWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                        }\n                                    } else if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOF \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                        parser.addWarning(\"msg.end.annotation.expected\", stream.getLineno(), stream.getCharno());\n                                    }\n                                } else {\n                                    parser.addWarning(\"msg.no.type.name\", lineno, charno);\n                                }\n                                token \u003d eatTokensUntilEOL(token);\n                                continue retry;\n                            case HIDDEN:\n                                if (!jsdocBuilder.recordHiddenness()) {\n                                    parser.addWarning(\"msg.jsdoc.hidden\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_ALIAS:\n                                if (!jsdocBuilder.recordNoAlias()) {\n                                    parser.addWarning(\"msg.jsdoc.noalias\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_COMPILE:\n                                if (!jsdocBuilder.recordNoCompile()) {\n                                    parser.addWarning(\"msg.jsdoc.nocompile\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_TYPE_CHECK:\n                                if (!jsdocBuilder.recordNoTypeCheck()) {\n                                    parser.addWarning(\"msg.jsdoc.nocheck\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NOT_IMPLEMENTED:\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case INHERIT_DOC:\n                            case OVERRIDE:\n                                if (!jsdocBuilder.recordOverride()) {\n                                    parser.addWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case THROWS:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                    if (type \u003d\u003d null) {\n                                        token \u003d eatTokensUntilEOL();\n                                        continue retry;\n                                    }\n                                }\n                                token \u003d current();\n                                jsdocBuilder.recordThrowType(type);\n                                ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                String description \u003d descriptionInfo.string;\n                                if (description.length() \u003e 0) {\n                                    jsdocBuilder.recordThrowDescription(type, description);\n                                }\n                                token \u003d descriptionInfo.token;\n                                continue retry;\n                            case PARAM:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordParamTypeNode(token));\n                                    if (type \u003d\u003d null) {\n                                        token \u003d eatTokensUntilEOL();\n                                        continue retry;\n                                    }\n                                    skipEOLs();\n                                    token \u003d next();\n                                    lineno \u003d stream.getLineno();\n                                    charno \u003d stream.getCharno();\n                                }\n                                String name \u003d null;\n                                boolean isBracketedParam \u003d JsDocToken.LB \u003d\u003d token;\n                                if (isBracketedParam) {\n                                    token \u003d next();\n                                }\n                                if (JsDocToken.STRING !\u003d token) {\n                                    parser.addWarning(\"msg.missing.variable.name\", lineno, charno);\n                                } else {\n                                    name \u003d stream.getString();\n                                    if (isBracketedParam) {\n                                        token \u003d next();\n                                        if (JsDocToken.EQUALS \u003d\u003d token) {\n                                            token \u003d next();\n                                            if (JsDocToken.STRING \u003d\u003d token) {\n                                                token \u003d next();\n                                            }\n                                        }\n                                        if (JsDocToken.RB !\u003d token) {\n                                            reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                                        } else if (type !\u003d null) {\n                                            type \u003d JSTypeExpression.makeOptionalArg(type);\n                                        }\n                                    }\n                                    if (name.indexOf(\u0027.\u0027) \u003e -1) {\n                                        name \u003d null;\n                                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                                        if (jsdocBuilder.hasParameter(name)) {\n                                            parser.addWarning(\"msg.dup.variable.name\", name, lineno, charno);\n                                        } else {\n                                            parser.addWarning(\"msg.jsdoc.incompat.type\", name, lineno, charno);\n                                        }\n                                    }\n                                }\n                                if (name \u003d\u003d null) {\n                                    token \u003d eatTokensUntilEOL(token);\n                                    continue retry;\n                                }\n                                jsdocBuilder.markName(name, lineno, charno);\n                                ExtractionInfo paramDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                String paramDescription \u003d paramDescriptionInfo.string;\n                                if (paramDescription.length() \u003e 0) {\n                                    jsdocBuilder.recordParameterDescription(name, paramDescription);\n                                }\n                                token \u003d paramDescriptionInfo.token;\n                                continue retry;\n                            case PRESERVE_TRY:\n                                if (!jsdocBuilder.recordPreserveTry()) {\n                                    parser.addWarning(\"msg.jsdoc.preservertry\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PRIVATE:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                                    parser.addWarning(\"msg.jsdoc.visibility.private\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PROTECTED:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                                    parser.addWarning(\"msg.jsdoc.visibility.protected\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PUBLIC:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                                    parser.addWarning(\"msg.jsdoc.visibility.public\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_SHADOW:\n                                if (!jsdocBuilder.recordNoShadow()) {\n                                    parser.addWarning(\"msg.jsdoc.noshadow\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_SIDE_EFFECTS:\n                                if (!jsdocBuilder.recordNoSideEffects()) {\n                                    parser.addWarning(\"msg.jsdoc.nosideeffects\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case IMPLICIT_CAST:\n                                if (!jsdocBuilder.recordImplicitCast()) {\n                                    parser.addWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case SEE:\n                                ExtractionInfo referenceInfo \u003d extractSingleLineBlock();\n                                String reference \u003d referenceInfo.string;\n                                if (reference.length() \u003d\u003d 0) {\n                                    parser.addWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno());\n                                } else {\n                                    jsdocBuilder.addReference(reference);\n                                }\n                                token \u003d referenceInfo.token;\n                                continue retry;\n                            case SUPPRESS:\n                                token \u003d parseSuppressTag(next());\n                                continue retry;\n                            case TEMPLATE:\n                                ExtractionInfo templateInfo \u003d extractSingleLineBlock();\n                                String templateTypeName \u003d templateInfo.string;\n                                if (templateTypeName.length() \u003d\u003d 0) {\n                                    parser.addWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno());\n                                } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {\n                                    parser.addWarning(\"msg.jsdoc.template.at.most.once\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d templateInfo.token;\n                                continue retry;\n                            case VERSION:\n                                ExtractionInfo versionInfo \u003d extractSingleLineBlock();\n                                String version \u003d versionInfo.string;\n                                if (version.length() \u003d\u003d 0) {\n                                    parser.addWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno());\n                                } else {\n                                    if (!jsdocBuilder.recordVersion(version)) {\n                                        parser.addWarning(\"msg.jsdoc.extraversion\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d versionInfo.token;\n                                continue retry;\n                            case DEFINE:\n                            case RETURN:\n                            case THIS:\n                            case TYPE:\n                            case TYPEDEF:\n                                skipEOLs();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                token \u003d next();\n                                Node typeNode \u003d parseAndRecordTypeNode(token, lineno, charno);\n                                if (annotation \u003d\u003d Annotation.THIS) {\n                                    typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                    if (typeNode !\u003d null \u0026\u0026 token !\u003d JsDocToken.LC) {\n                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                    }\n                                }\n                                type \u003d createJSTypeExpression(typeNode);\n                                if (type \u003d\u003d null) {\n                                } else {\n                                    switch(annotation) {\n                                        case DEFINE:\n                                            if (!jsdocBuilder.recordDefineType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.define\", lineno, charno);\n                                            }\n                                            break;\n                                        case RETURN:\n                                            if (!jsdocBuilder.recordReturnType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                                break;\n                                            }\n                                            token \u003d current();\n                                            ExtractionInfo returnDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                            String returnDescription \u003d returnDescriptionInfo.string;\n                                            if (returnDescription.length() \u003e 0) {\n                                                jsdocBuilder.recordReturnDescription(returnDescription);\n                                            }\n                                            token \u003d returnDescriptionInfo.token;\n                                            continue retry;\n                                        case THIS:\n                                            if (!jsdocBuilder.recordThisType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                        case TYPE:\n                                            if (!jsdocBuilder.recordType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                        case TYPEDEF:\n                                            if (!jsdocBuilder.recordTypedef(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                    }\n                                    token \u003d eatTokensUntilEOL();\n                                }\n                                continue retry;\n                        }\n                    }\n                }\n                break;\n            case EOC:\n                if (hasParsedFileOverviewDocInfo()) {\n                    fileOverviewJSDocInfo \u003d retrieveAndResetParsedJSDocInfo();\n                }\n                return true;\n            case EOF:\n                jsdocBuilder.build(null);\n                parser.addWarning(\"msg.unexpected.eof\", stream.getLineno(), stream.getCharno());\n                return false;\n            case EOL:\n                if (state \u003d\u003d State.SEARCHING_NEWLINE) {\n                    state \u003d State.SEARCHING_ANNOTATION;\n                }\n                token \u003d next();\n                continue retry;\n            default:\n                if (token \u003d\u003d JsDocToken.STAR \u0026\u0026 state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                    token \u003d next();\n                    continue retry;\n                } else {\n                    state \u003d State.SEARCHING_NEWLINE;\n                    token \u003d eatTokensUntilEOL();\n                    continue retry;\n                }\n        }\n        token \u003d next();\n    }\n}",
      "path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
      "functionStartLine": 136,
      "functionName": "parse",
      "functionAnnotation": "",
      "functionDoc": "Parses a {@link JSDocInfo} object. This parsing method reads all tokens\nreturned by the {@link JsDocTokenStream#getJsDocToken()} method until the\n{@link JsDocToken#EOC} is returned.\n\n@return @code true} if JSDoc information was correctly parsed,\n    {@code false} otherwise\n",
      "diff": "@@ -1,458 +1,464 @@\n boolean parse() {\n     int lineno;\n     int charno;\n     JSTypeExpression type;\n     state \u003d State.SEARCHING_ANNOTATION;\n     JsDocToken token \u003d next();\n     ExtractionInfo blockInfo \u003d extractBlockComment(token);\n     token \u003d blockInfo.token;\n     if (blockInfo.string.length() \u003e 0) {\n         jsdocBuilder.recordBlockDescription(blockInfo.string);\n     }\n     retry: for (; ; ) {\n         switch(token) {\n             case ANNOTATION:\n                 if (state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                     state \u003d State.SEARCHING_NEWLINE;\n                     lineno \u003d stream.getLineno();\n                     charno \u003d stream.getCharno();\n                     String annotationName \u003d stream.getString();\n                     Annotation annotation \u003d annotationNames.get(annotationName);\n                     if (annotation \u003d\u003d null) {\n                         parser.addWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno());\n                     } else {\n                         jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n                         switch(annotation) {\n                             case AUTHOR:\n                                 ExtractionInfo authorInfo \u003d extractSingleLineBlock();\n                                 String author \u003d authorInfo.string;\n                                 if (author.length() \u003d\u003d 0) {\n                                     parser.addWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno());\n                                 } else {\n                                     jsdocBuilder.addAuthor(author);\n                                 }\n                                 token \u003d authorInfo.token;\n                                 continue retry;\n                             case CONSTANT:\n                                 if (!jsdocBuilder.recordConstancy()) {\n                                     parser.addWarning(\"msg.jsdoc.const\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case CONSTRUCTOR:\n                                 if (!jsdocBuilder.recordConstructor()) {\n                                     if (jsdocBuilder.isInterfaceRecorded()) {\n                                         parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                     } else {\n                                         parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case DEPRECATED:\n                                 if (!jsdocBuilder.recordDeprecated()) {\n                                     parser.addWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 ExtractionInfo reasonInfo \u003d extractMultilineTextualBlock(token);\n                                 String reason \u003d reasonInfo.string;\n                                 if (reason.length() \u003e 0) {\n                                     jsdocBuilder.recordDeprecationReason(reason);\n                                 }\n                                 token \u003d reasonInfo.token;\n                                 continue retry;\n                             case INTERFACE:\n                                 if (!jsdocBuilder.recordInterface()) {\n                                     if (jsdocBuilder.isConstructorRecorded()) {\n                                         parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                     } else {\n                                         parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case DESC:\n                                 if (jsdocBuilder.isDescriptionRecorded()) {\n                                     parser.addWarning(\"msg.jsdoc.desc.extra\", stream.getLineno(), stream.getCharno());\n                                     token \u003d eatTokensUntilEOL();\n                                     continue retry;\n                                 } else {\n                                     ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                     String description \u003d descriptionInfo.string;\n                                     jsdocBuilder.recordDescription(description);\n                                     token \u003d descriptionInfo.token;\n                                     continue retry;\n                                 }\n                             case FILE_OVERVIEW:\n                                 ExtractionInfo fileOverviewInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.TRIM);\n                                 String fileOverview \u003d fileOverviewInfo.string;\n                                 if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo !\u003d null) {\n                                     parser.addWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d fileOverviewInfo.token;\n                                 continue retry;\n                             case LICENSE:\n                             case PRESERVE:\n                                 ExtractionInfo preserveInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);\n                                 String preserve \u003d preserveInfo.string;\n                                 if (preserve.length() \u003e 0) {\n                                     if (fileLevelJsDocBuilder !\u003d null) {\n                                         fileLevelJsDocBuilder.append(preserve);\n                                     }\n                                 }\n                                 token \u003d preserveInfo.token;\n                                 continue retry;\n                             case ENUM:\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                 }\n                                 if (type \u003d\u003d null) {\n                                     type \u003d createJSTypeExpression(newStringNode(\"number\"));\n                                 }\n                                 if (!jsdocBuilder.recordEnumParameterType(type)) {\n                                     parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                 }\n                                 token \u003d eatTokensUntilEOL(token);\n                                 continue retry;\n                             case EXPORT:\n                                 if (!jsdocBuilder.recordExport()) {\n                                     parser.addWarning(\"msg.jsdoc.export\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case EXTERNS:\n                                 if (!jsdocBuilder.recordExterns()) {\n                                     parser.addWarning(\"msg.jsdoc.externs\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case JAVA_DISPATCH:\n                                 if (!jsdocBuilder.recordJavaDispatch()) {\n                                     parser.addWarning(\"msg.jsdoc.javadispatch\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case EXTENDS:\n                             case IMPLEMENTS:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 boolean matchingRc \u003d false;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     token \u003d next();\n                                     matchingRc \u003d true;\n                                 }\n                                 if (token \u003d\u003d JsDocToken.STRING) {\n                                     Node typeNode \u003d parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);\n                                     lineno \u003d stream.getLineno();\n                                     charno \u003d stream.getCharno();\n                                     typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                     if (typeNode !\u003d null \u0026\u0026 !matchingRc) {\n                                         typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                     }\n                                     type \u003d createJSTypeExpression(typeNode);\n                                     if (annotation \u003d\u003d Annotation.EXTENDS) {\n                                         if (!jsdocBuilder.recordBaseType(type)) {\n                                             parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                         }\n                                     } else {\n                                         Preconditions.checkState(annotation \u003d\u003d Annotation.IMPLEMENTS);\n                                         if (!jsdocBuilder.recordImplementedInterface(type)) {\n                                             parser.addWarning(\"msg.jsdoc.implements.duplicate\", lineno, charno);\n                                         }\n                                     }\n                                     token \u003d next();\n                                     if (matchingRc) {\n                                         if (token !\u003d JsDocToken.RC) {\n                                             parser.addWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                         }\n                                     } else if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOF \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                         parser.addWarning(\"msg.end.annotation.expected\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 } else {\n                                     parser.addWarning(\"msg.no.type.name\", lineno, charno);\n                                 }\n                                 token \u003d eatTokensUntilEOL(token);\n                                 continue retry;\n                             case HIDDEN:\n                                 if (!jsdocBuilder.recordHiddenness()) {\n                                     parser.addWarning(\"msg.jsdoc.hidden\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_ALIAS:\n                                 if (!jsdocBuilder.recordNoAlias()) {\n                                     parser.addWarning(\"msg.jsdoc.noalias\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n+                            case NO_COMPILE:\n+                                if (!jsdocBuilder.recordNoCompile()) {\n+                                    parser.addWarning(\"msg.jsdoc.nocompile\", stream.getLineno(), stream.getCharno());\n+                                }\n+                                token \u003d eatTokensUntilEOL();\n+                                continue retry;\n                             case NO_TYPE_CHECK:\n                                 if (!jsdocBuilder.recordNoTypeCheck()) {\n                                     parser.addWarning(\"msg.jsdoc.nocheck\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NOT_IMPLEMENTED:\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case INHERIT_DOC:\n                             case OVERRIDE:\n                                 if (!jsdocBuilder.recordOverride()) {\n                                     parser.addWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case THROWS:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                     if (type \u003d\u003d null) {\n                                         token \u003d eatTokensUntilEOL();\n                                         continue retry;\n                                     }\n                                 }\n                                 token \u003d current();\n                                 jsdocBuilder.recordThrowType(type);\n                                 ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                 String description \u003d descriptionInfo.string;\n                                 if (description.length() \u003e 0) {\n                                     jsdocBuilder.recordThrowDescription(type, description);\n                                 }\n                                 token \u003d descriptionInfo.token;\n                                 continue retry;\n                             case PARAM:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordParamTypeNode(token));\n                                     if (type \u003d\u003d null) {\n                                         token \u003d eatTokensUntilEOL();\n                                         continue retry;\n                                     }\n                                     skipEOLs();\n                                     token \u003d next();\n                                     lineno \u003d stream.getLineno();\n                                     charno \u003d stream.getCharno();\n                                 }\n                                 String name \u003d null;\n                                 boolean isBracketedParam \u003d JsDocToken.LB \u003d\u003d token;\n                                 if (isBracketedParam) {\n                                     token \u003d next();\n                                 }\n                                 if (JsDocToken.STRING !\u003d token) {\n                                     parser.addWarning(\"msg.missing.variable.name\", lineno, charno);\n                                 } else {\n                                     name \u003d stream.getString();\n                                     if (isBracketedParam) {\n                                         token \u003d next();\n                                         if (JsDocToken.EQUALS \u003d\u003d token) {\n                                             token \u003d next();\n                                             if (JsDocToken.STRING \u003d\u003d token) {\n                                                 token \u003d next();\n                                             }\n                                         }\n                                         if (JsDocToken.RB !\u003d token) {\n                                             reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                                         } else if (type !\u003d null) {\n                                             type \u003d JSTypeExpression.makeOptionalArg(type);\n                                         }\n                                     }\n                                     if (name.indexOf(\u0027.\u0027) \u003e -1) {\n                                         name \u003d null;\n                                     } else if (!jsdocBuilder.recordParameter(name, type)) {\n                                         if (jsdocBuilder.hasParameter(name)) {\n                                             parser.addWarning(\"msg.dup.variable.name\", name, lineno, charno);\n                                         } else {\n                                             parser.addWarning(\"msg.jsdoc.incompat.type\", name, lineno, charno);\n                                         }\n                                     }\n                                 }\n                                 if (name \u003d\u003d null) {\n                                     token \u003d eatTokensUntilEOL(token);\n                                     continue retry;\n                                 }\n                                 jsdocBuilder.markName(name, lineno, charno);\n                                 ExtractionInfo paramDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                 String paramDescription \u003d paramDescriptionInfo.string;\n                                 if (paramDescription.length() \u003e 0) {\n                                     jsdocBuilder.recordParameterDescription(name, paramDescription);\n                                 }\n                                 token \u003d paramDescriptionInfo.token;\n                                 continue retry;\n                             case PRESERVE_TRY:\n                                 if (!jsdocBuilder.recordPreserveTry()) {\n                                     parser.addWarning(\"msg.jsdoc.preservertry\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PRIVATE:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                                     parser.addWarning(\"msg.jsdoc.visibility.private\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PROTECTED:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                                     parser.addWarning(\"msg.jsdoc.visibility.protected\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PUBLIC:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                                     parser.addWarning(\"msg.jsdoc.visibility.public\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_SHADOW:\n                                 if (!jsdocBuilder.recordNoShadow()) {\n                                     parser.addWarning(\"msg.jsdoc.noshadow\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_SIDE_EFFECTS:\n                                 if (!jsdocBuilder.recordNoSideEffects()) {\n                                     parser.addWarning(\"msg.jsdoc.nosideeffects\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case IMPLICIT_CAST:\n                                 if (!jsdocBuilder.recordImplicitCast()) {\n                                     parser.addWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case SEE:\n                                 ExtractionInfo referenceInfo \u003d extractSingleLineBlock();\n                                 String reference \u003d referenceInfo.string;\n                                 if (reference.length() \u003d\u003d 0) {\n                                     parser.addWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno());\n                                 } else {\n                                     jsdocBuilder.addReference(reference);\n                                 }\n                                 token \u003d referenceInfo.token;\n                                 continue retry;\n                             case SUPPRESS:\n                                 token \u003d parseSuppressTag(next());\n                                 continue retry;\n                             case TEMPLATE:\n                                 ExtractionInfo templateInfo \u003d extractSingleLineBlock();\n                                 String templateTypeName \u003d templateInfo.string;\n                                 if (templateTypeName.length() \u003d\u003d 0) {\n                                     parser.addWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno());\n                                 } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {\n                                     parser.addWarning(\"msg.jsdoc.template.at.most.once\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d templateInfo.token;\n                                 continue retry;\n                             case VERSION:\n                                 ExtractionInfo versionInfo \u003d extractSingleLineBlock();\n                                 String version \u003d versionInfo.string;\n                                 if (version.length() \u003d\u003d 0) {\n                                     parser.addWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno());\n                                 } else {\n                                     if (!jsdocBuilder.recordVersion(version)) {\n                                         parser.addWarning(\"msg.jsdoc.extraversion\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d versionInfo.token;\n                                 continue retry;\n                             case DEFINE:\n                             case RETURN:\n                             case THIS:\n                             case TYPE:\n                             case TYPEDEF:\n                                 skipEOLs();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 token \u003d next();\n                                 Node typeNode \u003d parseAndRecordTypeNode(token, lineno, charno);\n                                 if (annotation \u003d\u003d Annotation.THIS) {\n                                     typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                     if (typeNode !\u003d null \u0026\u0026 token !\u003d JsDocToken.LC) {\n                                         typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                     }\n                                 }\n                                 type \u003d createJSTypeExpression(typeNode);\n                                 if (type \u003d\u003d null) {\n                                 } else {\n                                     switch(annotation) {\n                                         case DEFINE:\n                                             if (!jsdocBuilder.recordDefineType(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.define\", lineno, charno);\n                                             }\n                                             break;\n                                         case RETURN:\n                                             if (!jsdocBuilder.recordReturnType(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                                 break;\n                                             }\n                                             token \u003d current();\n                                             ExtractionInfo returnDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                             String returnDescription \u003d returnDescriptionInfo.string;\n                                             if (returnDescription.length() \u003e 0) {\n                                                 jsdocBuilder.recordReturnDescription(returnDescription);\n                                             }\n                                             token \u003d returnDescriptionInfo.token;\n                                             continue retry;\n                                         case THIS:\n                                             if (!jsdocBuilder.recordThisType(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                         case TYPE:\n                                             if (!jsdocBuilder.recordType(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                         case TYPEDEF:\n                                             if (!jsdocBuilder.recordTypedef(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                     }\n                                     token \u003d eatTokensUntilEOL();\n                                 }\n                                 continue retry;\n                         }\n                     }\n                 }\n                 break;\n             case EOC:\n                 if (hasParsedFileOverviewDocInfo()) {\n                     fileOverviewJSDocInfo \u003d retrieveAndResetParsedJSDocInfo();\n                 }\n                 return true;\n             case EOF:\n                 jsdocBuilder.build(null);\n                 parser.addWarning(\"msg.unexpected.eof\", stream.getLineno(), stream.getCharno());\n                 return false;\n             case EOL:\n                 if (state \u003d\u003d State.SEARCHING_NEWLINE) {\n                     state \u003d State.SEARCHING_ANNOTATION;\n                 }\n                 token \u003d next();\n                 continue retry;\n             default:\n                 if (token \u003d\u003d JsDocToken.STAR \u0026\u0026 state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                     token \u003d next();\n                     continue retry;\n                 } else {\n                     state \u003d State.SEARCHING_NEWLINE;\n                     token \u003d eatTokensUntilEOL();\n                     continue retry;\n                 }\n         }\n         token \u003d next();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c764a46abf211d4677fadc33f7d466e5b14fa088": {
      "type": "Ybodychange",
      "commitMessage": "\nChange on 2010/04/13 by john\n\n        Here is a crazy thought, let\u0027s not require the JSTypeRegistry during\n        parsing.\n\n        There are basically two changes here:\n        1) The IRFactory was looking for enums to seed the JSTypeRegistry, so\n        we do that when we setup for type interence.\n        2) The JSDocParser was checking the types of @defines objects, now do\n        that during ProcessDefines.\n\n        R\u003drobert,mark\n        DELTA\u003d207  (82 added, 89 deleted, 36 changed)\n\nChange on 2010/04/14 by nick\n\n        Add a debugging function for JSType hashcodes.\n        i found this useful, and thought others might too.\n\n        R\u003djohn\n        DELTA\u003d69  (69 added, 0 deleted, 0 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003dfqsoxx\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@183 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/14/10, 9:15 AM",
      "commitName": "c764a46abf211d4677fadc33f7d466e5b14fa088",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "4/9/10, 11:07 AM",
      "commitNameOld": "2dbbe0784ee3e549eb0cc4d679aeddaac1243145",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 4.92,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "boolean parse() {\n    int lineno;\n    int charno;\n    JSTypeExpression type;\n    state \u003d State.SEARCHING_ANNOTATION;\n    JsDocToken token \u003d next();\n    ExtractionInfo blockInfo \u003d extractBlockComment(token);\n    token \u003d blockInfo.token;\n    if (blockInfo.string.length() \u003e 0) {\n        jsdocBuilder.recordBlockDescription(blockInfo.string);\n    }\n    retry: for (; ; ) {\n        switch(token) {\n            case ANNOTATION:\n                if (state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                    state \u003d State.SEARCHING_NEWLINE;\n                    lineno \u003d stream.getLineno();\n                    charno \u003d stream.getCharno();\n                    String annotationName \u003d stream.getString();\n                    Annotation annotation \u003d annotationNames.get(annotationName);\n                    if (annotation \u003d\u003d null) {\n                        parser.addWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno());\n                    } else {\n                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n                        switch(annotation) {\n                            case AUTHOR:\n                                ExtractionInfo authorInfo \u003d extractSingleLineBlock();\n                                String author \u003d authorInfo.string;\n                                if (author.length() \u003d\u003d 0) {\n                                    parser.addWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno());\n                                } else {\n                                    jsdocBuilder.addAuthor(author);\n                                }\n                                token \u003d authorInfo.token;\n                                continue retry;\n                            case CONSTANT:\n                                if (!jsdocBuilder.recordConstancy()) {\n                                    parser.addWarning(\"msg.jsdoc.const\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case CONSTRUCTOR:\n                                if (!jsdocBuilder.recordConstructor()) {\n                                    if (jsdocBuilder.isInterfaceRecorded()) {\n                                        parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case DEPRECATED:\n                                if (!jsdocBuilder.recordDeprecated()) {\n                                    parser.addWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno());\n                                }\n                                ExtractionInfo reasonInfo \u003d extractMultilineTextualBlock(token);\n                                String reason \u003d reasonInfo.string;\n                                if (reason.length() \u003e 0) {\n                                    jsdocBuilder.recordDeprecationReason(reason);\n                                }\n                                token \u003d reasonInfo.token;\n                                continue retry;\n                            case INTERFACE:\n                                if (!jsdocBuilder.recordInterface()) {\n                                    if (jsdocBuilder.isConstructorRecorded()) {\n                                        parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case DESC:\n                                if (jsdocBuilder.isDescriptionRecorded()) {\n                                    parser.addWarning(\"msg.jsdoc.desc.extra\", stream.getLineno(), stream.getCharno());\n                                    token \u003d eatTokensUntilEOL();\n                                    continue retry;\n                                } else {\n                                    ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                    String description \u003d descriptionInfo.string;\n                                    jsdocBuilder.recordDescription(description);\n                                    token \u003d descriptionInfo.token;\n                                    continue retry;\n                                }\n                            case FILE_OVERVIEW:\n                                ExtractionInfo fileOverviewInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.TRIM);\n                                String fileOverview \u003d fileOverviewInfo.string;\n                                if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo !\u003d null) {\n                                    parser.addWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d fileOverviewInfo.token;\n                                continue retry;\n                            case LICENSE:\n                            case PRESERVE:\n                                ExtractionInfo preserveInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);\n                                String preserve \u003d preserveInfo.string;\n                                if (preserve.length() \u003e 0) {\n                                    if (fileLevelJsDocBuilder !\u003d null) {\n                                        fileLevelJsDocBuilder.append(preserve);\n                                    }\n                                }\n                                token \u003d preserveInfo.token;\n                                continue retry;\n                            case ENUM:\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                }\n                                if (type \u003d\u003d null) {\n                                    type \u003d createJSTypeExpression(newStringNode(\"number\"));\n                                }\n                                if (!jsdocBuilder.recordEnumParameterType(type)) {\n                                    parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                }\n                                token \u003d eatTokensUntilEOL(token);\n                                continue retry;\n                            case EXPORT:\n                                if (!jsdocBuilder.recordExport()) {\n                                    parser.addWarning(\"msg.jsdoc.export\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case EXTERNS:\n                                if (!jsdocBuilder.recordExterns()) {\n                                    parser.addWarning(\"msg.jsdoc.externs\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case JAVA_DISPATCH:\n                                if (!jsdocBuilder.recordJavaDispatch()) {\n                                    parser.addWarning(\"msg.jsdoc.javadispatch\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case EXTENDS:\n                            case IMPLEMENTS:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                boolean matchingRc \u003d false;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    token \u003d next();\n                                    matchingRc \u003d true;\n                                }\n                                if (token \u003d\u003d JsDocToken.STRING) {\n                                    Node typeNode \u003d parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);\n                                    lineno \u003d stream.getLineno();\n                                    charno \u003d stream.getCharno();\n                                    typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                    if (typeNode !\u003d null \u0026\u0026 !matchingRc) {\n                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                    }\n                                    type \u003d createJSTypeExpression(typeNode);\n                                    if (annotation \u003d\u003d Annotation.EXTENDS) {\n                                        if (!jsdocBuilder.recordBaseType(type)) {\n                                            parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                        }\n                                    } else {\n                                        Preconditions.checkState(annotation \u003d\u003d Annotation.IMPLEMENTS);\n                                        if (!jsdocBuilder.recordImplementedInterface(type)) {\n                                            parser.addWarning(\"msg.jsdoc.implements.duplicate\", lineno, charno);\n                                        }\n                                    }\n                                    token \u003d next();\n                                    if (matchingRc) {\n                                        if (token !\u003d JsDocToken.RC) {\n                                            parser.addWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                        }\n                                    } else if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOF \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                        parser.addWarning(\"msg.end.annotation.expected\", stream.getLineno(), stream.getCharno());\n                                    }\n                                } else {\n                                    parser.addWarning(\"msg.no.type.name\", lineno, charno);\n                                }\n                                token \u003d eatTokensUntilEOL(token);\n                                continue retry;\n                            case HIDDEN:\n                                if (!jsdocBuilder.recordHiddenness()) {\n                                    parser.addWarning(\"msg.jsdoc.hidden\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_ALIAS:\n                                if (!jsdocBuilder.recordNoAlias()) {\n                                    parser.addWarning(\"msg.jsdoc.noalias\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_TYPE_CHECK:\n                                if (!jsdocBuilder.recordNoTypeCheck()) {\n                                    parser.addWarning(\"msg.jsdoc.nocheck\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NOT_IMPLEMENTED:\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case INHERIT_DOC:\n                            case OVERRIDE:\n                                if (!jsdocBuilder.recordOverride()) {\n                                    parser.addWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case THROWS:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                    if (type \u003d\u003d null) {\n                                        token \u003d eatTokensUntilEOL();\n                                        continue retry;\n                                    }\n                                }\n                                token \u003d current();\n                                jsdocBuilder.recordThrowType(type);\n                                ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                String description \u003d descriptionInfo.string;\n                                if (description.length() \u003e 0) {\n                                    jsdocBuilder.recordThrowDescription(type, description);\n                                }\n                                token \u003d descriptionInfo.token;\n                                continue retry;\n                            case PARAM:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordParamTypeNode(token));\n                                    if (type \u003d\u003d null) {\n                                        token \u003d eatTokensUntilEOL();\n                                        continue retry;\n                                    }\n                                    skipEOLs();\n                                    token \u003d next();\n                                    lineno \u003d stream.getLineno();\n                                    charno \u003d stream.getCharno();\n                                }\n                                String name \u003d null;\n                                boolean isBracketedParam \u003d JsDocToken.LB \u003d\u003d token;\n                                if (isBracketedParam) {\n                                    token \u003d next();\n                                }\n                                if (JsDocToken.STRING !\u003d token) {\n                                    parser.addWarning(\"msg.missing.variable.name\", lineno, charno);\n                                } else {\n                                    name \u003d stream.getString();\n                                    if (isBracketedParam) {\n                                        token \u003d next();\n                                        if (JsDocToken.EQUALS \u003d\u003d token) {\n                                            token \u003d next();\n                                            if (JsDocToken.STRING \u003d\u003d token) {\n                                                token \u003d next();\n                                            }\n                                        }\n                                        if (JsDocToken.RB !\u003d token) {\n                                            reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                                        } else if (type !\u003d null) {\n                                            type \u003d JSTypeExpression.makeOptionalArg(type);\n                                        }\n                                    }\n                                    if (name.indexOf(\u0027.\u0027) \u003e -1) {\n                                        name \u003d null;\n                                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                                        if (jsdocBuilder.hasParameter(name)) {\n                                            parser.addWarning(\"msg.dup.variable.name\", name, lineno, charno);\n                                        } else {\n                                            parser.addWarning(\"msg.jsdoc.incompat.type\", name, lineno, charno);\n                                        }\n                                    }\n                                }\n                                if (name \u003d\u003d null) {\n                                    token \u003d eatTokensUntilEOL(token);\n                                    continue retry;\n                                }\n                                jsdocBuilder.markName(name, lineno, charno);\n                                ExtractionInfo paramDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                String paramDescription \u003d paramDescriptionInfo.string;\n                                if (paramDescription.length() \u003e 0) {\n                                    jsdocBuilder.recordParameterDescription(name, paramDescription);\n                                }\n                                token \u003d paramDescriptionInfo.token;\n                                continue retry;\n                            case PRESERVE_TRY:\n                                if (!jsdocBuilder.recordPreserveTry()) {\n                                    parser.addWarning(\"msg.jsdoc.preservertry\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PRIVATE:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                                    parser.addWarning(\"msg.jsdoc.visibility.private\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PROTECTED:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                                    parser.addWarning(\"msg.jsdoc.visibility.protected\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PUBLIC:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                                    parser.addWarning(\"msg.jsdoc.visibility.public\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_SHADOW:\n                                if (!jsdocBuilder.recordNoShadow()) {\n                                    parser.addWarning(\"msg.jsdoc.noshadow\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_SIDE_EFFECTS:\n                                if (!jsdocBuilder.recordNoSideEffects()) {\n                                    parser.addWarning(\"msg.jsdoc.nosideeffects\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case IMPLICIT_CAST:\n                                if (!jsdocBuilder.recordImplicitCast()) {\n                                    parser.addWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case SEE:\n                                ExtractionInfo referenceInfo \u003d extractSingleLineBlock();\n                                String reference \u003d referenceInfo.string;\n                                if (reference.length() \u003d\u003d 0) {\n                                    parser.addWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno());\n                                } else {\n                                    jsdocBuilder.addReference(reference);\n                                }\n                                token \u003d referenceInfo.token;\n                                continue retry;\n                            case SUPPRESS:\n                                token \u003d parseSuppressTag(next());\n                                continue retry;\n                            case TEMPLATE:\n                                ExtractionInfo templateInfo \u003d extractSingleLineBlock();\n                                String templateTypeName \u003d templateInfo.string;\n                                if (templateTypeName.length() \u003d\u003d 0) {\n                                    parser.addWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno());\n                                } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {\n                                    parser.addWarning(\"msg.jsdoc.template.at.most.once\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d templateInfo.token;\n                                continue retry;\n                            case VERSION:\n                                ExtractionInfo versionInfo \u003d extractSingleLineBlock();\n                                String version \u003d versionInfo.string;\n                                if (version.length() \u003d\u003d 0) {\n                                    parser.addWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno());\n                                } else {\n                                    if (!jsdocBuilder.recordVersion(version)) {\n                                        parser.addWarning(\"msg.jsdoc.extraversion\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d versionInfo.token;\n                                continue retry;\n                            case DEFINE:\n                            case RETURN:\n                            case THIS:\n                            case TYPE:\n                            case TYPEDEF:\n                                skipEOLs();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                token \u003d next();\n                                Node typeNode \u003d parseAndRecordTypeNode(token, lineno, charno);\n                                if (annotation \u003d\u003d Annotation.THIS) {\n                                    typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                    if (typeNode !\u003d null \u0026\u0026 token !\u003d JsDocToken.LC) {\n                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                    }\n                                }\n                                type \u003d createJSTypeExpression(typeNode);\n                                if (type \u003d\u003d null) {\n                                } else {\n                                    switch(annotation) {\n                                        case DEFINE:\n                                            if (!jsdocBuilder.recordDefineType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.define\", lineno, charno);\n                                            }\n                                            break;\n                                        case RETURN:\n                                            if (!jsdocBuilder.recordReturnType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                                break;\n                                            }\n                                            token \u003d current();\n                                            ExtractionInfo returnDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                            String returnDescription \u003d returnDescriptionInfo.string;\n                                            if (returnDescription.length() \u003e 0) {\n                                                jsdocBuilder.recordReturnDescription(returnDescription);\n                                            }\n                                            token \u003d returnDescriptionInfo.token;\n                                            continue retry;\n                                        case THIS:\n                                            if (!jsdocBuilder.recordThisType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                        case TYPE:\n                                            if (!jsdocBuilder.recordType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                        case TYPEDEF:\n                                            if (!jsdocBuilder.recordTypedef(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                    }\n                                    token \u003d eatTokensUntilEOL();\n                                }\n                                continue retry;\n                        }\n                    }\n                }\n                break;\n            case EOC:\n                if (hasParsedFileOverviewDocInfo()) {\n                    fileOverviewJSDocInfo \u003d retrieveAndResetParsedJSDocInfo();\n                }\n                return true;\n            case EOF:\n                jsdocBuilder.build(null);\n                parser.addWarning(\"msg.unexpected.eof\", stream.getLineno(), stream.getCharno());\n                return false;\n            case EOL:\n                if (state \u003d\u003d State.SEARCHING_NEWLINE) {\n                    state \u003d State.SEARCHING_ANNOTATION;\n                }\n                token \u003d next();\n                continue retry;\n            default:\n                if (token \u003d\u003d JsDocToken.STAR \u0026\u0026 state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                    token \u003d next();\n                    continue retry;\n                } else {\n                    state \u003d State.SEARCHING_NEWLINE;\n                    token \u003d eatTokensUntilEOL();\n                    continue retry;\n                }\n        }\n        token \u003d next();\n    }\n}",
      "path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
      "functionStartLine": 133,
      "functionName": "parse",
      "functionAnnotation": "",
      "functionDoc": "Parses a {@link JSDocInfo} object. This parsing method reads all tokens\nreturned by the {@link JsDocTokenStream#getJsDocToken()} method until the\n{@link JsDocToken#EOC} is returned.\n\n@return @code true} if JSDoc information was correctly parsed,\n    {@code false} otherwise\n",
      "diff": "@@ -1,460 +1,458 @@\n boolean parse() {\n     int lineno;\n     int charno;\n     JSTypeExpression type;\n     state \u003d State.SEARCHING_ANNOTATION;\n     JsDocToken token \u003d next();\n     ExtractionInfo blockInfo \u003d extractBlockComment(token);\n     token \u003d blockInfo.token;\n     if (blockInfo.string.length() \u003e 0) {\n         jsdocBuilder.recordBlockDescription(blockInfo.string);\n     }\n     retry: for (; ; ) {\n         switch(token) {\n             case ANNOTATION:\n                 if (state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                     state \u003d State.SEARCHING_NEWLINE;\n                     lineno \u003d stream.getLineno();\n                     charno \u003d stream.getCharno();\n                     String annotationName \u003d stream.getString();\n                     Annotation annotation \u003d annotationNames.get(annotationName);\n                     if (annotation \u003d\u003d null) {\n                         parser.addWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno());\n                     } else {\n                         jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n                         switch(annotation) {\n                             case AUTHOR:\n                                 ExtractionInfo authorInfo \u003d extractSingleLineBlock();\n                                 String author \u003d authorInfo.string;\n                                 if (author.length() \u003d\u003d 0) {\n                                     parser.addWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno());\n                                 } else {\n                                     jsdocBuilder.addAuthor(author);\n                                 }\n                                 token \u003d authorInfo.token;\n                                 continue retry;\n                             case CONSTANT:\n                                 if (!jsdocBuilder.recordConstancy()) {\n                                     parser.addWarning(\"msg.jsdoc.const\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case CONSTRUCTOR:\n                                 if (!jsdocBuilder.recordConstructor()) {\n                                     if (jsdocBuilder.isInterfaceRecorded()) {\n                                         parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                     } else {\n                                         parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case DEPRECATED:\n                                 if (!jsdocBuilder.recordDeprecated()) {\n                                     parser.addWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 ExtractionInfo reasonInfo \u003d extractMultilineTextualBlock(token);\n                                 String reason \u003d reasonInfo.string;\n                                 if (reason.length() \u003e 0) {\n                                     jsdocBuilder.recordDeprecationReason(reason);\n                                 }\n                                 token \u003d reasonInfo.token;\n                                 continue retry;\n                             case INTERFACE:\n                                 if (!jsdocBuilder.recordInterface()) {\n                                     if (jsdocBuilder.isConstructorRecorded()) {\n                                         parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                     } else {\n                                         parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case DESC:\n                                 if (jsdocBuilder.isDescriptionRecorded()) {\n                                     parser.addWarning(\"msg.jsdoc.desc.extra\", stream.getLineno(), stream.getCharno());\n                                     token \u003d eatTokensUntilEOL();\n                                     continue retry;\n                                 } else {\n                                     ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                     String description \u003d descriptionInfo.string;\n                                     jsdocBuilder.recordDescription(description);\n                                     token \u003d descriptionInfo.token;\n                                     continue retry;\n                                 }\n                             case FILE_OVERVIEW:\n                                 ExtractionInfo fileOverviewInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.TRIM);\n                                 String fileOverview \u003d fileOverviewInfo.string;\n                                 if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo !\u003d null) {\n                                     parser.addWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d fileOverviewInfo.token;\n                                 continue retry;\n                             case LICENSE:\n                             case PRESERVE:\n                                 ExtractionInfo preserveInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);\n                                 String preserve \u003d preserveInfo.string;\n                                 if (preserve.length() \u003e 0) {\n                                     if (fileLevelJsDocBuilder !\u003d null) {\n                                         fileLevelJsDocBuilder.append(preserve);\n                                     }\n                                 }\n                                 token \u003d preserveInfo.token;\n                                 continue retry;\n                             case ENUM:\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                 }\n                                 if (type \u003d\u003d null) {\n                                     type \u003d createJSTypeExpression(newStringNode(\"number\"));\n                                 }\n                                 if (!jsdocBuilder.recordEnumParameterType(type)) {\n                                     parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                 }\n                                 token \u003d eatTokensUntilEOL(token);\n                                 continue retry;\n                             case EXPORT:\n                                 if (!jsdocBuilder.recordExport()) {\n                                     parser.addWarning(\"msg.jsdoc.export\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case EXTERNS:\n                                 if (!jsdocBuilder.recordExterns()) {\n                                     parser.addWarning(\"msg.jsdoc.externs\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case JAVA_DISPATCH:\n                                 if (!jsdocBuilder.recordJavaDispatch()) {\n                                     parser.addWarning(\"msg.jsdoc.javadispatch\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case EXTENDS:\n                             case IMPLEMENTS:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 boolean matchingRc \u003d false;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     token \u003d next();\n                                     matchingRc \u003d true;\n                                 }\n                                 if (token \u003d\u003d JsDocToken.STRING) {\n                                     Node typeNode \u003d parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);\n                                     lineno \u003d stream.getLineno();\n                                     charno \u003d stream.getCharno();\n                                     typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                     if (typeNode !\u003d null \u0026\u0026 !matchingRc) {\n                                         typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                     }\n                                     type \u003d createJSTypeExpression(typeNode);\n                                     if (annotation \u003d\u003d Annotation.EXTENDS) {\n                                         if (!jsdocBuilder.recordBaseType(type)) {\n                                             parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                         }\n                                     } else {\n                                         Preconditions.checkState(annotation \u003d\u003d Annotation.IMPLEMENTS);\n                                         if (!jsdocBuilder.recordImplementedInterface(type)) {\n                                             parser.addWarning(\"msg.jsdoc.implements.duplicate\", lineno, charno);\n                                         }\n                                     }\n                                     token \u003d next();\n                                     if (matchingRc) {\n                                         if (token !\u003d JsDocToken.RC) {\n                                             parser.addWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                         }\n                                     } else if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOF \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                         parser.addWarning(\"msg.end.annotation.expected\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 } else {\n                                     parser.addWarning(\"msg.no.type.name\", lineno, charno);\n                                 }\n                                 token \u003d eatTokensUntilEOL(token);\n                                 continue retry;\n                             case HIDDEN:\n                                 if (!jsdocBuilder.recordHiddenness()) {\n                                     parser.addWarning(\"msg.jsdoc.hidden\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_ALIAS:\n                                 if (!jsdocBuilder.recordNoAlias()) {\n                                     parser.addWarning(\"msg.jsdoc.noalias\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_TYPE_CHECK:\n                                 if (!jsdocBuilder.recordNoTypeCheck()) {\n                                     parser.addWarning(\"msg.jsdoc.nocheck\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NOT_IMPLEMENTED:\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case INHERIT_DOC:\n                             case OVERRIDE:\n                                 if (!jsdocBuilder.recordOverride()) {\n                                     parser.addWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case THROWS:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                     if (type \u003d\u003d null) {\n                                         token \u003d eatTokensUntilEOL();\n                                         continue retry;\n                                     }\n                                 }\n                                 token \u003d current();\n                                 jsdocBuilder.recordThrowType(type);\n                                 ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                 String description \u003d descriptionInfo.string;\n                                 if (description.length() \u003e 0) {\n                                     jsdocBuilder.recordThrowDescription(type, description);\n                                 }\n                                 token \u003d descriptionInfo.token;\n                                 continue retry;\n                             case PARAM:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordParamTypeNode(token));\n                                     if (type \u003d\u003d null) {\n                                         token \u003d eatTokensUntilEOL();\n                                         continue retry;\n                                     }\n                                     skipEOLs();\n                                     token \u003d next();\n                                     lineno \u003d stream.getLineno();\n                                     charno \u003d stream.getCharno();\n                                 }\n                                 String name \u003d null;\n                                 boolean isBracketedParam \u003d JsDocToken.LB \u003d\u003d token;\n                                 if (isBracketedParam) {\n                                     token \u003d next();\n                                 }\n                                 if (JsDocToken.STRING !\u003d token) {\n                                     parser.addWarning(\"msg.missing.variable.name\", lineno, charno);\n                                 } else {\n                                     name \u003d stream.getString();\n                                     if (isBracketedParam) {\n                                         token \u003d next();\n                                         if (JsDocToken.EQUALS \u003d\u003d token) {\n                                             token \u003d next();\n                                             if (JsDocToken.STRING \u003d\u003d token) {\n                                                 token \u003d next();\n                                             }\n                                         }\n                                         if (JsDocToken.RB !\u003d token) {\n                                             reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                                         } else if (type !\u003d null) {\n                                             type \u003d JSTypeExpression.makeOptionalArg(type);\n                                         }\n                                     }\n                                     if (name.indexOf(\u0027.\u0027) \u003e -1) {\n                                         name \u003d null;\n                                     } else if (!jsdocBuilder.recordParameter(name, type)) {\n                                         if (jsdocBuilder.hasParameter(name)) {\n                                             parser.addWarning(\"msg.dup.variable.name\", name, lineno, charno);\n                                         } else {\n                                             parser.addWarning(\"msg.jsdoc.incompat.type\", name, lineno, charno);\n                                         }\n                                     }\n                                 }\n                                 if (name \u003d\u003d null) {\n                                     token \u003d eatTokensUntilEOL(token);\n                                     continue retry;\n                                 }\n                                 jsdocBuilder.markName(name, lineno, charno);\n                                 ExtractionInfo paramDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                 String paramDescription \u003d paramDescriptionInfo.string;\n                                 if (paramDescription.length() \u003e 0) {\n                                     jsdocBuilder.recordParameterDescription(name, paramDescription);\n                                 }\n                                 token \u003d paramDescriptionInfo.token;\n                                 continue retry;\n                             case PRESERVE_TRY:\n                                 if (!jsdocBuilder.recordPreserveTry()) {\n                                     parser.addWarning(\"msg.jsdoc.preservertry\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PRIVATE:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                                     parser.addWarning(\"msg.jsdoc.visibility.private\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PROTECTED:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                                     parser.addWarning(\"msg.jsdoc.visibility.protected\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PUBLIC:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                                     parser.addWarning(\"msg.jsdoc.visibility.public\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_SHADOW:\n                                 if (!jsdocBuilder.recordNoShadow()) {\n                                     parser.addWarning(\"msg.jsdoc.noshadow\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_SIDE_EFFECTS:\n                                 if (!jsdocBuilder.recordNoSideEffects()) {\n                                     parser.addWarning(\"msg.jsdoc.nosideeffects\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case IMPLICIT_CAST:\n                                 if (!jsdocBuilder.recordImplicitCast()) {\n                                     parser.addWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case SEE:\n                                 ExtractionInfo referenceInfo \u003d extractSingleLineBlock();\n                                 String reference \u003d referenceInfo.string;\n                                 if (reference.length() \u003d\u003d 0) {\n                                     parser.addWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno());\n                                 } else {\n                                     jsdocBuilder.addReference(reference);\n                                 }\n                                 token \u003d referenceInfo.token;\n                                 continue retry;\n                             case SUPPRESS:\n                                 token \u003d parseSuppressTag(next());\n                                 continue retry;\n                             case TEMPLATE:\n                                 ExtractionInfo templateInfo \u003d extractSingleLineBlock();\n                                 String templateTypeName \u003d templateInfo.string;\n                                 if (templateTypeName.length() \u003d\u003d 0) {\n                                     parser.addWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno());\n                                 } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {\n                                     parser.addWarning(\"msg.jsdoc.template.at.most.once\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d templateInfo.token;\n                                 continue retry;\n                             case VERSION:\n                                 ExtractionInfo versionInfo \u003d extractSingleLineBlock();\n                                 String version \u003d versionInfo.string;\n                                 if (version.length() \u003d\u003d 0) {\n                                     parser.addWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno());\n                                 } else {\n                                     if (!jsdocBuilder.recordVersion(version)) {\n                                         parser.addWarning(\"msg.jsdoc.extraversion\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d versionInfo.token;\n                                 continue retry;\n                             case DEFINE:\n                             case RETURN:\n                             case THIS:\n                             case TYPE:\n                             case TYPEDEF:\n                                 skipEOLs();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 token \u003d next();\n                                 Node typeNode \u003d parseAndRecordTypeNode(token, lineno, charno);\n                                 if (annotation \u003d\u003d Annotation.THIS) {\n                                     typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                     if (typeNode !\u003d null \u0026\u0026 token !\u003d JsDocToken.LC) {\n                                         typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                     }\n                                 }\n                                 type \u003d createJSTypeExpression(typeNode);\n                                 if (type \u003d\u003d null) {\n                                 } else {\n                                     switch(annotation) {\n                                         case DEFINE:\n-                                            if (!isValidDefineType(typeNode)) {\n-                                                parser.addWarning(\"msg.jsdoc.define.badtype\", lineno, charno);\n-                                            } else if (!jsdocBuilder.recordDefineType(type)) {\n+                                            if (!jsdocBuilder.recordDefineType(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.define\", lineno, charno);\n                                             }\n                                             break;\n                                         case RETURN:\n                                             if (!jsdocBuilder.recordReturnType(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                                 break;\n                                             }\n                                             token \u003d current();\n                                             ExtractionInfo returnDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                             String returnDescription \u003d returnDescriptionInfo.string;\n                                             if (returnDescription.length() \u003e 0) {\n                                                 jsdocBuilder.recordReturnDescription(returnDescription);\n                                             }\n                                             token \u003d returnDescriptionInfo.token;\n                                             continue retry;\n                                         case THIS:\n                                             if (!jsdocBuilder.recordThisType(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                         case TYPE:\n                                             if (!jsdocBuilder.recordType(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                         case TYPEDEF:\n                                             if (!jsdocBuilder.recordTypedef(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                     }\n                                     token \u003d eatTokensUntilEOL();\n                                 }\n                                 continue retry;\n                         }\n                     }\n                 }\n                 break;\n             case EOC:\n                 if (hasParsedFileOverviewDocInfo()) {\n                     fileOverviewJSDocInfo \u003d retrieveAndResetParsedJSDocInfo();\n                 }\n                 return true;\n             case EOF:\n                 jsdocBuilder.build(null);\n                 parser.addWarning(\"msg.unexpected.eof\", stream.getLineno(), stream.getCharno());\n                 return false;\n             case EOL:\n                 if (state \u003d\u003d State.SEARCHING_NEWLINE) {\n                     state \u003d State.SEARCHING_ANNOTATION;\n                 }\n                 token \u003d next();\n                 continue retry;\n             default:\n                 if (token \u003d\u003d JsDocToken.STAR \u0026\u0026 state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                     token \u003d next();\n                     continue retry;\n                 } else {\n                     state \u003d State.SEARCHING_NEWLINE;\n                     token \u003d eatTokensUntilEOL();\n                     continue retry;\n                 }\n         }\n         token \u003d next();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "52ecbc65e981b9f169466f8898155bc5f8bfad7a": {
      "type": "Ybodychange",
      "commitMessage": "Add some new externs files: webkit notifications, web storage, and file access.\n\nFix a minor bug in type checking \u0027in\u0027 operators.\n\nFix a bug in warnings filtering.\n\nAdd a @javadispatch annotation.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@81 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "1/28/10, 1:52 PM",
      "commitName": "52ecbc65e981b9f169466f8898155bc5f8bfad7a",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "1/19/10, 7:30 AM",
      "commitNameOld": "026c346555bbcc9d25fdeedbc85a6d68f0307775",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 9.27,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "actualSource": "boolean parse() {\n    int lineno;\n    int charno;\n    JSTypeExpression type;\n    state \u003d State.SEARCHING_ANNOTATION;\n    JsDocToken token \u003d next();\n    ExtractionInfo blockInfo \u003d extractBlockComment(token);\n    token \u003d blockInfo.token;\n    if (blockInfo.string.length() \u003e 0) {\n        jsdocBuilder.recordBlockDescription(blockInfo.string);\n    }\n    retry: for (; ; ) {\n        switch(token) {\n            case ANNOTATION:\n                if (state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                    state \u003d State.SEARCHING_NEWLINE;\n                    lineno \u003d stream.getLineno();\n                    charno \u003d stream.getCharno();\n                    String annotationName \u003d stream.getString();\n                    Annotation annotation \u003d annotationNames.get(annotationName);\n                    if (annotation \u003d\u003d null) {\n                        parser.addWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno());\n                    } else {\n                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n                        switch(annotation) {\n                            case AUTHOR:\n                                ExtractionInfo authorInfo \u003d extractSingleLineBlock();\n                                String author \u003d authorInfo.string;\n                                if (author.length() \u003d\u003d 0) {\n                                    parser.addWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno());\n                                } else {\n                                    jsdocBuilder.addAuthor(author);\n                                }\n                                token \u003d authorInfo.token;\n                                continue retry;\n                            case CONSTANT:\n                                if (!jsdocBuilder.recordConstancy()) {\n                                    parser.addWarning(\"msg.jsdoc.const\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case CONSTRUCTOR:\n                                if (!jsdocBuilder.recordConstructor()) {\n                                    if (jsdocBuilder.isInterfaceRecorded()) {\n                                        parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case DEPRECATED:\n                                if (!jsdocBuilder.recordDeprecated()) {\n                                    parser.addWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno());\n                                }\n                                ExtractionInfo reasonInfo \u003d extractMultilineTextualBlock(token);\n                                String reason \u003d reasonInfo.string;\n                                if (reason.length() \u003e 0) {\n                                    jsdocBuilder.recordDeprecationReason(reason);\n                                }\n                                token \u003d reasonInfo.token;\n                                continue retry;\n                            case INTERFACE:\n                                if (!jsdocBuilder.recordInterface()) {\n                                    if (jsdocBuilder.isConstructorRecorded()) {\n                                        parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case DESC:\n                                if (jsdocBuilder.isDescriptionRecorded()) {\n                                    parser.addWarning(\"msg.jsdoc.desc.extra\", stream.getLineno(), stream.getCharno());\n                                    token \u003d eatTokensUntilEOL();\n                                    continue retry;\n                                } else {\n                                    ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                    String description \u003d descriptionInfo.string;\n                                    jsdocBuilder.recordDescription(description);\n                                    token \u003d descriptionInfo.token;\n                                    continue retry;\n                                }\n                            case FILE_OVERVIEW:\n                                ExtractionInfo fileOverviewInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.TRIM);\n                                String fileOverview \u003d fileOverviewInfo.string;\n                                if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo !\u003d null) {\n                                    parser.addWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d fileOverviewInfo.token;\n                                continue retry;\n                            case LICENSE:\n                            case PRESERVE:\n                                ExtractionInfo preserveInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);\n                                String preserve \u003d preserveInfo.string;\n                                if (preserve.length() \u003e 0) {\n                                    if (fileLevelJsDocBuilder !\u003d null) {\n                                        fileLevelJsDocBuilder.append(preserve);\n                                    }\n                                }\n                                token \u003d preserveInfo.token;\n                                continue retry;\n                            case ENUM:\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                }\n                                if (type \u003d\u003d null) {\n                                    type \u003d createJSTypeExpression(newStringNode(\"number\"));\n                                }\n                                if (!jsdocBuilder.recordEnumParameterType(type)) {\n                                    parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                }\n                                token \u003d eatTokensUntilEOL(token);\n                                continue retry;\n                            case EXPORT:\n                                if (!jsdocBuilder.recordExport()) {\n                                    parser.addWarning(\"msg.jsdoc.export\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case EXTERNS:\n                                if (!jsdocBuilder.recordExterns()) {\n                                    parser.addWarning(\"msg.jsdoc.externs\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case JAVA_DISPATCH:\n                                if (!jsdocBuilder.recordJavaDispatch()) {\n                                    parser.addWarning(\"msg.jsdoc.javadispatch\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case EXTENDS:\n                            case IMPLEMENTS:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                boolean matchingRc \u003d false;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    token \u003d next();\n                                    matchingRc \u003d true;\n                                }\n                                if (token \u003d\u003d JsDocToken.STRING) {\n                                    Node typeNode \u003d parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);\n                                    lineno \u003d stream.getLineno();\n                                    charno \u003d stream.getCharno();\n                                    typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                    if (typeNode !\u003d null \u0026\u0026 !matchingRc) {\n                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                    }\n                                    type \u003d createJSTypeExpression(typeNode);\n                                    if (annotation \u003d\u003d Annotation.EXTENDS) {\n                                        if (!jsdocBuilder.recordBaseType(type)) {\n                                            parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                        }\n                                    } else {\n                                        Preconditions.checkState(annotation \u003d\u003d Annotation.IMPLEMENTS);\n                                        if (!jsdocBuilder.recordImplementedInterface(type)) {\n                                            parser.addWarning(\"msg.jsdoc.implements.duplicate\", lineno, charno);\n                                        }\n                                    }\n                                    token \u003d next();\n                                    if (matchingRc) {\n                                        if (token !\u003d JsDocToken.RC) {\n                                            parser.addWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                        }\n                                    } else if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOF \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                        parser.addWarning(\"msg.end.annotation.expected\", stream.getLineno(), stream.getCharno());\n                                    }\n                                } else {\n                                    parser.addWarning(\"msg.no.type.name\", lineno, charno);\n                                }\n                                token \u003d eatTokensUntilEOL(token);\n                                continue retry;\n                            case HIDDEN:\n                                if (!jsdocBuilder.recordHiddenness()) {\n                                    parser.addWarning(\"msg.jsdoc.hidden\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_ALIAS:\n                                if (!jsdocBuilder.recordNoAlias()) {\n                                    parser.addWarning(\"msg.jsdoc.noalias\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_TYPE_CHECK:\n                                if (!jsdocBuilder.recordNoTypeCheck()) {\n                                    parser.addWarning(\"msg.jsdoc.nocheck\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NOT_IMPLEMENTED:\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case INHERIT_DOC:\n                            case OVERRIDE:\n                                if (!jsdocBuilder.recordOverride()) {\n                                    parser.addWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case THROWS:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                    if (type \u003d\u003d null) {\n                                        token \u003d eatTokensUntilEOL();\n                                        continue retry;\n                                    }\n                                }\n                                token \u003d current();\n                                jsdocBuilder.recordThrowType(type);\n                                ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                String description \u003d descriptionInfo.string;\n                                if (description.length() \u003e 0) {\n                                    jsdocBuilder.recordThrowDescription(type, description);\n                                }\n                                token \u003d descriptionInfo.token;\n                                continue retry;\n                            case PARAM:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordParamTypeNode(token));\n                                    if (type \u003d\u003d null) {\n                                        token \u003d eatTokensUntilEOL();\n                                        continue retry;\n                                    }\n                                    skipEOLs();\n                                    token \u003d next();\n                                    lineno \u003d stream.getLineno();\n                                    charno \u003d stream.getCharno();\n                                }\n                                String name \u003d null;\n                                boolean isBracketedParam \u003d JsDocToken.LB \u003d\u003d token;\n                                if (isBracketedParam) {\n                                    token \u003d next();\n                                }\n                                if (JsDocToken.STRING !\u003d token) {\n                                    parser.addWarning(\"msg.missing.variable.name\", lineno, charno);\n                                } else {\n                                    name \u003d stream.getString();\n                                    if (isBracketedParam) {\n                                        token \u003d next();\n                                        if (JsDocToken.EQUALS \u003d\u003d token) {\n                                            token \u003d next();\n                                            if (JsDocToken.STRING \u003d\u003d token) {\n                                                token \u003d next();\n                                            }\n                                        }\n                                        if (JsDocToken.RB !\u003d token) {\n                                            reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                                        } else if (type !\u003d null) {\n                                            type \u003d JSTypeExpression.makeOptionalArg(type);\n                                        }\n                                    }\n                                    if (name.indexOf(\u0027.\u0027) \u003e -1) {\n                                        name \u003d null;\n                                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                                        if (jsdocBuilder.hasParameter(name)) {\n                                            parser.addWarning(\"msg.dup.variable.name\", name, lineno, charno);\n                                        } else {\n                                            parser.addWarning(\"msg.jsdoc.incompat.type\", name, lineno, charno);\n                                        }\n                                    }\n                                }\n                                if (name \u003d\u003d null) {\n                                    token \u003d eatTokensUntilEOL(token);\n                                    continue retry;\n                                }\n                                jsdocBuilder.markName(name, lineno, charno);\n                                ExtractionInfo paramDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                String paramDescription \u003d paramDescriptionInfo.string;\n                                if (paramDescription.length() \u003e 0) {\n                                    jsdocBuilder.recordParameterDescription(name, paramDescription);\n                                }\n                                token \u003d paramDescriptionInfo.token;\n                                continue retry;\n                            case PRESERVE_TRY:\n                                if (!jsdocBuilder.recordPreserveTry()) {\n                                    parser.addWarning(\"msg.jsdoc.preservertry\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PRIVATE:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                                    parser.addWarning(\"msg.jsdoc.visibility.private\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PROTECTED:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                                    parser.addWarning(\"msg.jsdoc.visibility.protected\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PUBLIC:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                                    parser.addWarning(\"msg.jsdoc.visibility.public\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_SHADOW:\n                                if (!jsdocBuilder.recordNoShadow()) {\n                                    parser.addWarning(\"msg.jsdoc.noshadow\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_SIDE_EFFECTS:\n                                if (!jsdocBuilder.recordNoSideEffects()) {\n                                    parser.addWarning(\"msg.jsdoc.nosideeffects\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case IMPLICIT_CAST:\n                                if (!jsdocBuilder.recordImplicitCast()) {\n                                    parser.addWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case SEE:\n                                ExtractionInfo referenceInfo \u003d extractSingleLineBlock();\n                                String reference \u003d referenceInfo.string;\n                                if (reference.length() \u003d\u003d 0) {\n                                    parser.addWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno());\n                                } else {\n                                    jsdocBuilder.addReference(reference);\n                                }\n                                token \u003d referenceInfo.token;\n                                continue retry;\n                            case SUPPRESS:\n                                token \u003d parseSuppressTag(next());\n                                continue retry;\n                            case TEMPLATE:\n                                ExtractionInfo templateInfo \u003d extractSingleLineBlock();\n                                String templateTypeName \u003d templateInfo.string;\n                                if (templateTypeName.length() \u003d\u003d 0) {\n                                    parser.addWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno());\n                                } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {\n                                    parser.addWarning(\"msg.jsdoc.template.at.most.once\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d templateInfo.token;\n                                continue retry;\n                            case VERSION:\n                                ExtractionInfo versionInfo \u003d extractSingleLineBlock();\n                                String version \u003d versionInfo.string;\n                                if (version.length() \u003d\u003d 0) {\n                                    parser.addWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno());\n                                } else {\n                                    if (!jsdocBuilder.recordVersion(version)) {\n                                        parser.addWarning(\"msg.jsdoc.extraversion\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d versionInfo.token;\n                                continue retry;\n                            case DEFINE:\n                            case RETURN:\n                            case THIS:\n                            case TYPE:\n                            case TYPEDEF:\n                                skipEOLs();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                token \u003d next();\n                                Node typeNode \u003d parseAndRecordTypeNode(token, lineno, charno);\n                                if (annotation \u003d\u003d Annotation.THIS) {\n                                    typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                    if (typeNode !\u003d null \u0026\u0026 token !\u003d JsDocToken.LC) {\n                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                    }\n                                }\n                                type \u003d createJSTypeExpression(typeNode);\n                                if (type \u003d\u003d null) {\n                                } else {\n                                    switch(annotation) {\n                                        case DEFINE:\n                                            if (!isValidDefineType(typeNode)) {\n                                                parser.addWarning(\"msg.jsdoc.define.badtype\", lineno, charno);\n                                            } else if (!jsdocBuilder.recordDefineType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.define\", lineno, charno);\n                                            }\n                                            break;\n                                        case RETURN:\n                                            if (!jsdocBuilder.recordReturnType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                                break;\n                                            }\n                                            token \u003d current();\n                                            ExtractionInfo returnDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                            String returnDescription \u003d returnDescriptionInfo.string;\n                                            if (returnDescription.length() \u003e 0) {\n                                                jsdocBuilder.recordReturnDescription(returnDescription);\n                                            }\n                                            token \u003d returnDescriptionInfo.token;\n                                            continue retry;\n                                        case THIS:\n                                            if (!jsdocBuilder.recordThisType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                        case TYPE:\n                                            if (!jsdocBuilder.recordType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                        case TYPEDEF:\n                                            if (!jsdocBuilder.recordTypedef(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                    }\n                                    token \u003d eatTokensUntilEOL();\n                                }\n                                continue retry;\n                        }\n                    }\n                }\n                break;\n            case EOC:\n                if (hasParsedFileOverviewDocInfo()) {\n                    fileOverviewJSDocInfo \u003d retrieveAndResetParsedJSDocInfo();\n                }\n                return true;\n            case EOF:\n                jsdocBuilder.build(null);\n                parser.addWarning(\"msg.unexpected.eof\", stream.getLineno(), stream.getCharno());\n                return false;\n            case EOL:\n                if (state \u003d\u003d State.SEARCHING_NEWLINE) {\n                    state \u003d State.SEARCHING_ANNOTATION;\n                }\n                token \u003d next();\n                continue retry;\n            default:\n                if (token \u003d\u003d JsDocToken.STAR \u0026\u0026 state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                    token \u003d next();\n                    continue retry;\n                } else {\n                    state \u003d State.SEARCHING_NEWLINE;\n                    token \u003d eatTokensUntilEOL();\n                    continue retry;\n                }\n        }\n        token \u003d next();\n    }\n}",
      "path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
      "functionStartLine": 242,
      "functionName": "parse",
      "functionAnnotation": "",
      "functionDoc": "Parses a {@link JSDocInfo} object. This parsing method reads all tokens\nreturned by the {@link JsDocTokenStream#getJsDocToken()} method until the\n{@link JsDocToken#EOC} is returned.\n\n@return @code true} if JSDoc information was correctly parsed,\n    {@code false} otherwise\n",
      "diff": "@@ -1,454 +1,460 @@\n boolean parse() {\n     int lineno;\n     int charno;\n     JSTypeExpression type;\n     state \u003d State.SEARCHING_ANNOTATION;\n     JsDocToken token \u003d next();\n     ExtractionInfo blockInfo \u003d extractBlockComment(token);\n     token \u003d blockInfo.token;\n     if (blockInfo.string.length() \u003e 0) {\n         jsdocBuilder.recordBlockDescription(blockInfo.string);\n     }\n     retry: for (; ; ) {\n         switch(token) {\n             case ANNOTATION:\n                 if (state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                     state \u003d State.SEARCHING_NEWLINE;\n                     lineno \u003d stream.getLineno();\n                     charno \u003d stream.getCharno();\n                     String annotationName \u003d stream.getString();\n                     Annotation annotation \u003d annotationNames.get(annotationName);\n                     if (annotation \u003d\u003d null) {\n                         parser.addWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno());\n                     } else {\n                         jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n                         switch(annotation) {\n                             case AUTHOR:\n                                 ExtractionInfo authorInfo \u003d extractSingleLineBlock();\n                                 String author \u003d authorInfo.string;\n                                 if (author.length() \u003d\u003d 0) {\n                                     parser.addWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno());\n                                 } else {\n                                     jsdocBuilder.addAuthor(author);\n                                 }\n                                 token \u003d authorInfo.token;\n                                 continue retry;\n                             case CONSTANT:\n                                 if (!jsdocBuilder.recordConstancy()) {\n                                     parser.addWarning(\"msg.jsdoc.const\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case CONSTRUCTOR:\n                                 if (!jsdocBuilder.recordConstructor()) {\n                                     if (jsdocBuilder.isInterfaceRecorded()) {\n                                         parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                     } else {\n                                         parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case DEPRECATED:\n                                 if (!jsdocBuilder.recordDeprecated()) {\n                                     parser.addWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 ExtractionInfo reasonInfo \u003d extractMultilineTextualBlock(token);\n                                 String reason \u003d reasonInfo.string;\n                                 if (reason.length() \u003e 0) {\n                                     jsdocBuilder.recordDeprecationReason(reason);\n                                 }\n                                 token \u003d reasonInfo.token;\n                                 continue retry;\n                             case INTERFACE:\n                                 if (!jsdocBuilder.recordInterface()) {\n                                     if (jsdocBuilder.isConstructorRecorded()) {\n                                         parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                     } else {\n                                         parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case DESC:\n                                 if (jsdocBuilder.isDescriptionRecorded()) {\n                                     parser.addWarning(\"msg.jsdoc.desc.extra\", stream.getLineno(), stream.getCharno());\n                                     token \u003d eatTokensUntilEOL();\n                                     continue retry;\n                                 } else {\n                                     ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                     String description \u003d descriptionInfo.string;\n                                     jsdocBuilder.recordDescription(description);\n                                     token \u003d descriptionInfo.token;\n                                     continue retry;\n                                 }\n                             case FILE_OVERVIEW:\n                                 ExtractionInfo fileOverviewInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.TRIM);\n                                 String fileOverview \u003d fileOverviewInfo.string;\n                                 if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo !\u003d null) {\n                                     parser.addWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d fileOverviewInfo.token;\n                                 continue retry;\n                             case LICENSE:\n                             case PRESERVE:\n                                 ExtractionInfo preserveInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);\n                                 String preserve \u003d preserveInfo.string;\n                                 if (preserve.length() \u003e 0) {\n                                     if (fileLevelJsDocBuilder !\u003d null) {\n                                         fileLevelJsDocBuilder.append(preserve);\n                                     }\n                                 }\n                                 token \u003d preserveInfo.token;\n                                 continue retry;\n                             case ENUM:\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                 }\n                                 if (type \u003d\u003d null) {\n                                     type \u003d createJSTypeExpression(newStringNode(\"number\"));\n                                 }\n                                 if (!jsdocBuilder.recordEnumParameterType(type)) {\n                                     parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                 }\n                                 token \u003d eatTokensUntilEOL(token);\n                                 continue retry;\n                             case EXPORT:\n                                 if (!jsdocBuilder.recordExport()) {\n                                     parser.addWarning(\"msg.jsdoc.export\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case EXTERNS:\n                                 if (!jsdocBuilder.recordExterns()) {\n                                     parser.addWarning(\"msg.jsdoc.externs\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n+                            case JAVA_DISPATCH:\n+                                if (!jsdocBuilder.recordJavaDispatch()) {\n+                                    parser.addWarning(\"msg.jsdoc.javadispatch\", stream.getLineno(), stream.getCharno());\n+                                }\n+                                token \u003d eatTokensUntilEOL();\n+                                continue retry;\n                             case EXTENDS:\n                             case IMPLEMENTS:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 boolean matchingRc \u003d false;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     token \u003d next();\n                                     matchingRc \u003d true;\n                                 }\n                                 if (token \u003d\u003d JsDocToken.STRING) {\n                                     Node typeNode \u003d parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);\n                                     lineno \u003d stream.getLineno();\n                                     charno \u003d stream.getCharno();\n                                     typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                     if (typeNode !\u003d null \u0026\u0026 !matchingRc) {\n                                         typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                     }\n                                     type \u003d createJSTypeExpression(typeNode);\n                                     if (annotation \u003d\u003d Annotation.EXTENDS) {\n                                         if (!jsdocBuilder.recordBaseType(type)) {\n                                             parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                         }\n                                     } else {\n                                         Preconditions.checkState(annotation \u003d\u003d Annotation.IMPLEMENTS);\n                                         if (!jsdocBuilder.recordImplementedInterface(type)) {\n                                             parser.addWarning(\"msg.jsdoc.implements.duplicate\", lineno, charno);\n                                         }\n                                     }\n                                     token \u003d next();\n                                     if (matchingRc) {\n                                         if (token !\u003d JsDocToken.RC) {\n                                             parser.addWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                         }\n                                     } else if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOF \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                         parser.addWarning(\"msg.end.annotation.expected\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 } else {\n                                     parser.addWarning(\"msg.no.type.name\", lineno, charno);\n                                 }\n                                 token \u003d eatTokensUntilEOL(token);\n                                 continue retry;\n                             case HIDDEN:\n                                 if (!jsdocBuilder.recordHiddenness()) {\n                                     parser.addWarning(\"msg.jsdoc.hidden\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_ALIAS:\n                                 if (!jsdocBuilder.recordNoAlias()) {\n                                     parser.addWarning(\"msg.jsdoc.noalias\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_TYPE_CHECK:\n                                 if (!jsdocBuilder.recordNoTypeCheck()) {\n                                     parser.addWarning(\"msg.jsdoc.nocheck\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NOT_IMPLEMENTED:\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case INHERIT_DOC:\n                             case OVERRIDE:\n                                 if (!jsdocBuilder.recordOverride()) {\n                                     parser.addWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case THROWS:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                     if (type \u003d\u003d null) {\n                                         token \u003d eatTokensUntilEOL();\n                                         continue retry;\n                                     }\n                                 }\n                                 token \u003d current();\n                                 jsdocBuilder.recordThrowType(type);\n                                 ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                 String description \u003d descriptionInfo.string;\n                                 if (description.length() \u003e 0) {\n                                     jsdocBuilder.recordThrowDescription(type, description);\n                                 }\n                                 token \u003d descriptionInfo.token;\n                                 continue retry;\n                             case PARAM:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordParamTypeNode(token));\n                                     if (type \u003d\u003d null) {\n                                         token \u003d eatTokensUntilEOL();\n                                         continue retry;\n                                     }\n                                     skipEOLs();\n                                     token \u003d next();\n                                     lineno \u003d stream.getLineno();\n                                     charno \u003d stream.getCharno();\n                                 }\n                                 String name \u003d null;\n                                 boolean isBracketedParam \u003d JsDocToken.LB \u003d\u003d token;\n                                 if (isBracketedParam) {\n                                     token \u003d next();\n                                 }\n                                 if (JsDocToken.STRING !\u003d token) {\n                                     parser.addWarning(\"msg.missing.variable.name\", lineno, charno);\n                                 } else {\n                                     name \u003d stream.getString();\n                                     if (isBracketedParam) {\n                                         token \u003d next();\n                                         if (JsDocToken.EQUALS \u003d\u003d token) {\n                                             token \u003d next();\n                                             if (JsDocToken.STRING \u003d\u003d token) {\n                                                 token \u003d next();\n                                             }\n                                         }\n                                         if (JsDocToken.RB !\u003d token) {\n                                             reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                                         } else if (type !\u003d null) {\n                                             type \u003d JSTypeExpression.makeOptionalArg(type);\n                                         }\n                                     }\n                                     if (name.indexOf(\u0027.\u0027) \u003e -1) {\n                                         name \u003d null;\n                                     } else if (!jsdocBuilder.recordParameter(name, type)) {\n                                         if (jsdocBuilder.hasParameter(name)) {\n                                             parser.addWarning(\"msg.dup.variable.name\", name, lineno, charno);\n                                         } else {\n                                             parser.addWarning(\"msg.jsdoc.incompat.type\", name, lineno, charno);\n                                         }\n                                     }\n                                 }\n                                 if (name \u003d\u003d null) {\n                                     token \u003d eatTokensUntilEOL(token);\n                                     continue retry;\n                                 }\n                                 jsdocBuilder.markName(name, lineno, charno);\n                                 ExtractionInfo paramDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                 String paramDescription \u003d paramDescriptionInfo.string;\n                                 if (paramDescription.length() \u003e 0) {\n                                     jsdocBuilder.recordParameterDescription(name, paramDescription);\n                                 }\n                                 token \u003d paramDescriptionInfo.token;\n                                 continue retry;\n                             case PRESERVE_TRY:\n                                 if (!jsdocBuilder.recordPreserveTry()) {\n                                     parser.addWarning(\"msg.jsdoc.preservertry\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PRIVATE:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                                     parser.addWarning(\"msg.jsdoc.visibility.private\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PROTECTED:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                                     parser.addWarning(\"msg.jsdoc.visibility.protected\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PUBLIC:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                                     parser.addWarning(\"msg.jsdoc.visibility.public\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_SHADOW:\n                                 if (!jsdocBuilder.recordNoShadow()) {\n                                     parser.addWarning(\"msg.jsdoc.noshadow\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_SIDE_EFFECTS:\n                                 if (!jsdocBuilder.recordNoSideEffects()) {\n                                     parser.addWarning(\"msg.jsdoc.nosideeffects\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case IMPLICIT_CAST:\n                                 if (!jsdocBuilder.recordImplicitCast()) {\n                                     parser.addWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case SEE:\n                                 ExtractionInfo referenceInfo \u003d extractSingleLineBlock();\n                                 String reference \u003d referenceInfo.string;\n                                 if (reference.length() \u003d\u003d 0) {\n                                     parser.addWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno());\n                                 } else {\n                                     jsdocBuilder.addReference(reference);\n                                 }\n                                 token \u003d referenceInfo.token;\n                                 continue retry;\n                             case SUPPRESS:\n                                 token \u003d parseSuppressTag(next());\n                                 continue retry;\n                             case TEMPLATE:\n                                 ExtractionInfo templateInfo \u003d extractSingleLineBlock();\n                                 String templateTypeName \u003d templateInfo.string;\n                                 if (templateTypeName.length() \u003d\u003d 0) {\n                                     parser.addWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno());\n                                 } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {\n                                     parser.addWarning(\"msg.jsdoc.template.at.most.once\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d templateInfo.token;\n                                 continue retry;\n                             case VERSION:\n                                 ExtractionInfo versionInfo \u003d extractSingleLineBlock();\n                                 String version \u003d versionInfo.string;\n                                 if (version.length() \u003d\u003d 0) {\n                                     parser.addWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno());\n                                 } else {\n                                     if (!jsdocBuilder.recordVersion(version)) {\n                                         parser.addWarning(\"msg.jsdoc.extraversion\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d versionInfo.token;\n                                 continue retry;\n                             case DEFINE:\n                             case RETURN:\n                             case THIS:\n                             case TYPE:\n                             case TYPEDEF:\n                                 skipEOLs();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 token \u003d next();\n                                 Node typeNode \u003d parseAndRecordTypeNode(token, lineno, charno);\n                                 if (annotation \u003d\u003d Annotation.THIS) {\n                                     typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                     if (typeNode !\u003d null \u0026\u0026 token !\u003d JsDocToken.LC) {\n                                         typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                     }\n                                 }\n                                 type \u003d createJSTypeExpression(typeNode);\n                                 if (type \u003d\u003d null) {\n                                 } else {\n                                     switch(annotation) {\n                                         case DEFINE:\n                                             if (!isValidDefineType(typeNode)) {\n                                                 parser.addWarning(\"msg.jsdoc.define.badtype\", lineno, charno);\n                                             } else if (!jsdocBuilder.recordDefineType(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.define\", lineno, charno);\n                                             }\n                                             break;\n                                         case RETURN:\n                                             if (!jsdocBuilder.recordReturnType(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                                 break;\n                                             }\n                                             token \u003d current();\n                                             ExtractionInfo returnDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                             String returnDescription \u003d returnDescriptionInfo.string;\n                                             if (returnDescription.length() \u003e 0) {\n                                                 jsdocBuilder.recordReturnDescription(returnDescription);\n                                             }\n                                             token \u003d returnDescriptionInfo.token;\n                                             continue retry;\n                                         case THIS:\n                                             if (!jsdocBuilder.recordThisType(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                         case TYPE:\n                                             if (!jsdocBuilder.recordType(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                         case TYPEDEF:\n                                             if (!jsdocBuilder.recordTypedef(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                     }\n                                     token \u003d eatTokensUntilEOL();\n                                 }\n                                 continue retry;\n                         }\n                     }\n                 }\n                 break;\n             case EOC:\n                 if (hasParsedFileOverviewDocInfo()) {\n                     fileOverviewJSDocInfo \u003d retrieveAndResetParsedJSDocInfo();\n                 }\n                 return true;\n             case EOF:\n                 jsdocBuilder.build(null);\n                 parser.addWarning(\"msg.unexpected.eof\", stream.getLineno(), stream.getCharno());\n                 return false;\n             case EOL:\n                 if (state \u003d\u003d State.SEARCHING_NEWLINE) {\n                     state \u003d State.SEARCHING_ANNOTATION;\n                 }\n                 token \u003d next();\n                 continue retry;\n             default:\n                 if (token \u003d\u003d JsDocToken.STAR \u0026\u0026 state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                     token \u003d next();\n                     continue retry;\n                 } else {\n                     state \u003d State.SEARCHING_NEWLINE;\n                     token \u003d eatTokensUntilEOL();\n                     continue retry;\n                 }\n         }\n         token \u003d next();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a478193982ce1fb9271e3f7ebcc1369913c9a859": {
      "type": "Ybodychange",
      "commitMessage": "Add a debugging option for variable renaming.\nBug fixes for direct calls on the arguments array.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@17 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "12/1/09, 8:28 AM",
      "commitName": "a478193982ce1fb9271e3f7ebcc1369913c9a859",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "commitDateOld": "11/19/09, 3:26 PM",
      "commitNameOld": "5af11d33f8b3f5403c9987104601f544cddb96c1",
      "commitAuthorOld": "nicholas.j.santos@gmail.com",
      "daysBetweenCommits": 11.71,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "boolean parse() {\n    int lineno;\n    int charno;\n    JSTypeExpression type;\n    state \u003d State.SEARCHING_ANNOTATION;\n    JsDocToken token \u003d next();\n    ExtractionInfo blockInfo \u003d extractBlockComment(token);\n    token \u003d blockInfo.token;\n    if (blockInfo.string.length() \u003e 0) {\n        jsdocBuilder.recordBlockDescription(blockInfo.string);\n    }\n    retry: for (; ; ) {\n        switch(token) {\n            case ANNOTATION:\n                if (state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                    state \u003d State.SEARCHING_NEWLINE;\n                    lineno \u003d stream.getLineno();\n                    charno \u003d stream.getCharno();\n                    String annotationName \u003d stream.getString();\n                    Annotation annotation \u003d annotationNames.get(annotationName);\n                    if (annotation \u003d\u003d null) {\n                        parser.addWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno());\n                    } else {\n                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n                        switch(annotation) {\n                            case AUTHOR:\n                                ExtractionInfo authorInfo \u003d extractSingleLineBlock();\n                                String author \u003d authorInfo.string;\n                                if (author.length() \u003d\u003d 0) {\n                                    parser.addWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno());\n                                } else {\n                                    jsdocBuilder.addAuthor(author);\n                                }\n                                token \u003d authorInfo.token;\n                                continue retry;\n                            case CONSTANT:\n                                if (!jsdocBuilder.recordConstancy()) {\n                                    parser.addWarning(\"msg.jsdoc.const\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case CONSTRUCTOR:\n                                if (!jsdocBuilder.recordConstructor()) {\n                                    if (jsdocBuilder.isInterfaceRecorded()) {\n                                        parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case DEPRECATED:\n                                if (!jsdocBuilder.recordDeprecated()) {\n                                    parser.addWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno());\n                                }\n                                ExtractionInfo reasonInfo \u003d extractMultilineTextualBlock(token);\n                                String reason \u003d reasonInfo.string;\n                                if (reason.length() \u003e 0) {\n                                    jsdocBuilder.recordDeprecationReason(reason);\n                                }\n                                token \u003d reasonInfo.token;\n                                continue retry;\n                            case INTERFACE:\n                                if (!jsdocBuilder.recordInterface()) {\n                                    if (jsdocBuilder.isConstructorRecorded()) {\n                                        parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case DESC:\n                                if (jsdocBuilder.isDescriptionRecorded()) {\n                                    parser.addWarning(\"msg.jsdoc.desc.extra\", stream.getLineno(), stream.getCharno());\n                                    token \u003d eatTokensUntilEOL();\n                                    continue retry;\n                                } else {\n                                    ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                    String description \u003d descriptionInfo.string;\n                                    jsdocBuilder.recordDescription(description);\n                                    token \u003d descriptionInfo.token;\n                                    continue retry;\n                                }\n                            case FILE_OVERVIEW:\n                                ExtractionInfo fileOverviewInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.TRIM);\n                                String fileOverview \u003d fileOverviewInfo.string;\n                                if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo !\u003d null) {\n                                    parser.addWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d fileOverviewInfo.token;\n                                continue retry;\n                            case LICENSE:\n                            case PRESERVE:\n                                ExtractionInfo preserveInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);\n                                String preserve \u003d preserveInfo.string;\n                                if (preserve.length() \u003e 0) {\n                                    if (fileLevelJsDocBuilder !\u003d null) {\n                                        fileLevelJsDocBuilder.append(preserve);\n                                    }\n                                }\n                                token \u003d preserveInfo.token;\n                                continue retry;\n                            case ENUM:\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                }\n                                if (type \u003d\u003d null) {\n                                    type \u003d createJSTypeExpression(newStringNode(\"number\"));\n                                }\n                                if (!jsdocBuilder.recordEnumParameterType(type)) {\n                                    parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                }\n                                token \u003d eatTokensUntilEOL(token);\n                                continue retry;\n                            case EXPORT:\n                                if (!jsdocBuilder.recordExport()) {\n                                    parser.addWarning(\"msg.jsdoc.export\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case EXTERNS:\n                                if (!jsdocBuilder.recordExterns()) {\n                                    parser.addWarning(\"msg.jsdoc.externs\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case EXTENDS:\n                            case IMPLEMENTS:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                boolean matchingRc \u003d false;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    token \u003d next();\n                                    matchingRc \u003d true;\n                                }\n                                if (token \u003d\u003d JsDocToken.STRING) {\n                                    Node typeNode \u003d parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);\n                                    lineno \u003d stream.getLineno();\n                                    charno \u003d stream.getCharno();\n                                    typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                    if (typeNode !\u003d null \u0026\u0026 !matchingRc) {\n                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                    }\n                                    type \u003d createJSTypeExpression(typeNode);\n                                    if (annotation \u003d\u003d Annotation.EXTENDS) {\n                                        if (!jsdocBuilder.recordBaseType(type)) {\n                                            parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                        }\n                                    } else {\n                                        Preconditions.checkState(annotation \u003d\u003d Annotation.IMPLEMENTS);\n                                        if (!jsdocBuilder.recordImplementedInterface(type)) {\n                                            parser.addWarning(\"msg.jsdoc.implements.duplicate\", lineno, charno);\n                                        }\n                                    }\n                                    token \u003d next();\n                                    if (matchingRc) {\n                                        if (token !\u003d JsDocToken.RC) {\n                                            parser.addWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                        }\n                                    } else if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOF \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                        parser.addWarning(\"msg.end.annotation.expected\", stream.getLineno(), stream.getCharno());\n                                    }\n                                } else {\n                                    parser.addWarning(\"msg.no.type.name\", lineno, charno);\n                                }\n                                token \u003d eatTokensUntilEOL(token);\n                                continue retry;\n                            case HIDDEN:\n                                if (!jsdocBuilder.recordHiddenness()) {\n                                    parser.addWarning(\"msg.jsdoc.hidden\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_ALIAS:\n                                if (!jsdocBuilder.recordNoAlias()) {\n                                    parser.addWarning(\"msg.jsdoc.noalias\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_TYPE_CHECK:\n                                if (!jsdocBuilder.recordNoTypeCheck()) {\n                                    parser.addWarning(\"msg.jsdoc.nocheck\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NOT_IMPLEMENTED:\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case INHERIT_DOC:\n                            case OVERRIDE:\n                                if (!jsdocBuilder.recordOverride()) {\n                                    parser.addWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case THROWS:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                    if (type \u003d\u003d null) {\n                                        token \u003d eatTokensUntilEOL();\n                                        continue retry;\n                                    }\n                                }\n                                token \u003d current();\n                                jsdocBuilder.recordThrowType(type);\n                                ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                String description \u003d descriptionInfo.string;\n                                if (description.length() \u003e 0) {\n                                    jsdocBuilder.recordThrowDescription(type, description);\n                                }\n                                token \u003d descriptionInfo.token;\n                                continue retry;\n                            case PARAM:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordParamTypeNode(token));\n                                    if (type \u003d\u003d null) {\n                                        token \u003d eatTokensUntilEOL();\n                                        continue retry;\n                                    }\n                                    skipEOLs();\n                                    token \u003d next();\n                                    lineno \u003d stream.getLineno();\n                                    charno \u003d stream.getCharno();\n                                }\n                                String name \u003d null;\n                                boolean isBracketedParam \u003d JsDocToken.LB \u003d\u003d token;\n                                if (isBracketedParam) {\n                                    token \u003d next();\n                                }\n                                if (JsDocToken.STRING !\u003d token) {\n                                    parser.addWarning(\"msg.missing.variable.name\", lineno, charno);\n                                } else {\n                                    name \u003d stream.getString();\n                                    if (isBracketedParam) {\n                                        token \u003d next();\n                                        if (JsDocToken.EQUALS \u003d\u003d token) {\n                                            token \u003d next();\n                                            if (JsDocToken.STRING \u003d\u003d token) {\n                                                token \u003d next();\n                                            }\n                                        }\n                                        if (JsDocToken.RB !\u003d token) {\n                                            reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                                        } else if (type !\u003d null) {\n                                            type \u003d JSTypeExpression.makeOptionalArg(type);\n                                        }\n                                    }\n                                    if (name.indexOf(\u0027.\u0027) \u003e -1) {\n                                        name \u003d null;\n                                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                                        if (jsdocBuilder.hasParameter(name)) {\n                                            parser.addWarning(\"msg.dup.variable.name\", name, lineno, charno);\n                                        } else {\n                                            parser.addWarning(\"msg.jsdoc.incompat.type\", name, lineno, charno);\n                                        }\n                                    }\n                                }\n                                if (name \u003d\u003d null) {\n                                    token \u003d eatTokensUntilEOL(token);\n                                    continue retry;\n                                }\n                                jsdocBuilder.markName(name, lineno, charno);\n                                ExtractionInfo paramDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                String paramDescription \u003d paramDescriptionInfo.string;\n                                if (paramDescription.length() \u003e 0) {\n                                    jsdocBuilder.recordParameterDescription(name, paramDescription);\n                                }\n                                token \u003d paramDescriptionInfo.token;\n                                continue retry;\n                            case PRESERVE_TRY:\n                                if (!jsdocBuilder.recordPreserveTry()) {\n                                    parser.addWarning(\"msg.jsdoc.preservertry\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PRIVATE:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                                    parser.addWarning(\"msg.jsdoc.visibility.private\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PROTECTED:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                                    parser.addWarning(\"msg.jsdoc.visibility.protected\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PUBLIC:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                                    parser.addWarning(\"msg.jsdoc.visibility.public\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_SHADOW:\n                                if (!jsdocBuilder.recordNoShadow()) {\n                                    parser.addWarning(\"msg.jsdoc.noshadow\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_SIDE_EFFECTS:\n                                if (!jsdocBuilder.recordNoSideEffects()) {\n                                    parser.addWarning(\"msg.jsdoc.nosideeffects\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case IMPLICIT_CAST:\n                                if (!jsdocBuilder.recordImplicitCast()) {\n                                    parser.addWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case SEE:\n                                ExtractionInfo referenceInfo \u003d extractSingleLineBlock();\n                                String reference \u003d referenceInfo.string;\n                                if (reference.length() \u003d\u003d 0) {\n                                    parser.addWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno());\n                                } else {\n                                    jsdocBuilder.addReference(reference);\n                                }\n                                token \u003d referenceInfo.token;\n                                continue retry;\n                            case SUPPRESS:\n                                token \u003d parseSuppressTag(next());\n                                continue retry;\n                            case TEMPLATE:\n                                ExtractionInfo templateInfo \u003d extractSingleLineBlock();\n                                String templateTypeName \u003d templateInfo.string;\n                                if (templateTypeName.length() \u003d\u003d 0) {\n                                    parser.addWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno());\n                                } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {\n                                    parser.addWarning(\"msg.jsdoc.template.at.most.once\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d templateInfo.token;\n                                continue retry;\n                            case VERSION:\n                                ExtractionInfo versionInfo \u003d extractSingleLineBlock();\n                                String version \u003d versionInfo.string;\n                                if (version.length() \u003d\u003d 0) {\n                                    parser.addWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno());\n                                } else {\n                                    if (!jsdocBuilder.recordVersion(version)) {\n                                        parser.addWarning(\"msg.jsdoc.extraversion\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d versionInfo.token;\n                                continue retry;\n                            case DEFINE:\n                            case RETURN:\n                            case THIS:\n                            case TYPE:\n                            case TYPEDEF:\n                                skipEOLs();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                token \u003d next();\n                                Node typeNode \u003d parseAndRecordTypeNode(token, lineno, charno);\n                                if (annotation \u003d\u003d Annotation.THIS) {\n                                    typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                    if (typeNode !\u003d null \u0026\u0026 token !\u003d JsDocToken.LC) {\n                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                    }\n                                }\n                                type \u003d createJSTypeExpression(typeNode);\n                                if (type \u003d\u003d null) {\n                                } else {\n                                    switch(annotation) {\n                                        case DEFINE:\n                                            if (!isValidDefineType(typeNode)) {\n                                                parser.addWarning(\"msg.jsdoc.define.badtype\", lineno, charno);\n                                            } else if (!jsdocBuilder.recordDefineType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.define\", lineno, charno);\n                                            }\n                                            break;\n                                        case RETURN:\n                                            if (!jsdocBuilder.recordReturnType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                                break;\n                                            }\n                                            token \u003d current();\n                                            ExtractionInfo returnDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                            String returnDescription \u003d returnDescriptionInfo.string;\n                                            if (returnDescription.length() \u003e 0) {\n                                                jsdocBuilder.recordReturnDescription(returnDescription);\n                                            }\n                                            token \u003d returnDescriptionInfo.token;\n                                            continue retry;\n                                        case THIS:\n                                            if (!jsdocBuilder.recordThisType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                        case TYPE:\n                                            if (!jsdocBuilder.recordType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                        case TYPEDEF:\n                                            if (!jsdocBuilder.recordTypedef(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                    }\n                                    token \u003d eatTokensUntilEOL();\n                                }\n                                continue retry;\n                        }\n                    }\n                }\n                break;\n            case EOC:\n                if (hasParsedFileOverviewDocInfo()) {\n                    fileOverviewJSDocInfo \u003d retrieveAndResetParsedJSDocInfo();\n                }\n                return true;\n            case EOF:\n                jsdocBuilder.build(null);\n                parser.addWarning(\"msg.unexpected.eof\", stream.getLineno(), stream.getCharno());\n                return false;\n            case EOL:\n                if (state \u003d\u003d State.SEARCHING_NEWLINE) {\n                    state \u003d State.SEARCHING_ANNOTATION;\n                }\n                token \u003d next();\n                continue retry;\n            default:\n                if (token \u003d\u003d JsDocToken.STAR \u0026\u0026 state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                    token \u003d next();\n                    continue retry;\n                } else {\n                    state \u003d State.SEARCHING_NEWLINE;\n                    token \u003d eatTokensUntilEOL();\n                    continue retry;\n                }\n        }\n        token \u003d next();\n    }\n}",
      "path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
      "functionStartLine": 239,
      "functionName": "parse",
      "functionAnnotation": "",
      "functionDoc": "Parses a {@link JSDocInfo} object. This parsing method reads all tokens\nreturned by the {@link JsDocTokenStream#getJsDocToken()} method until the\n{@link JsDocToken#EOC} is returned.\n\n@return @code true} if JSDoc information was correctly parsed,\n    {@code false} otherwise\n",
      "diff": "@@ -1,448 +1,454 @@\n boolean parse() {\n     int lineno;\n     int charno;\n     JSTypeExpression type;\n     state \u003d State.SEARCHING_ANNOTATION;\n     JsDocToken token \u003d next();\n     ExtractionInfo blockInfo \u003d extractBlockComment(token);\n     token \u003d blockInfo.token;\n     if (blockInfo.string.length() \u003e 0) {\n         jsdocBuilder.recordBlockDescription(blockInfo.string);\n     }\n     retry: for (; ; ) {\n         switch(token) {\n             case ANNOTATION:\n                 if (state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                     state \u003d State.SEARCHING_NEWLINE;\n                     lineno \u003d stream.getLineno();\n                     charno \u003d stream.getCharno();\n                     String annotationName \u003d stream.getString();\n                     Annotation annotation \u003d annotationNames.get(annotationName);\n                     if (annotation \u003d\u003d null) {\n                         parser.addWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno());\n                     } else {\n                         jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n                         switch(annotation) {\n                             case AUTHOR:\n                                 ExtractionInfo authorInfo \u003d extractSingleLineBlock();\n                                 String author \u003d authorInfo.string;\n                                 if (author.length() \u003d\u003d 0) {\n                                     parser.addWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno());\n                                 } else {\n                                     jsdocBuilder.addAuthor(author);\n                                 }\n                                 token \u003d authorInfo.token;\n                                 continue retry;\n                             case CONSTANT:\n                                 if (!jsdocBuilder.recordConstancy()) {\n                                     parser.addWarning(\"msg.jsdoc.const\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case CONSTRUCTOR:\n                                 if (!jsdocBuilder.recordConstructor()) {\n                                     if (jsdocBuilder.isInterfaceRecorded()) {\n                                         parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                     } else {\n                                         parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case DEPRECATED:\n                                 if (!jsdocBuilder.recordDeprecated()) {\n                                     parser.addWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 ExtractionInfo reasonInfo \u003d extractMultilineTextualBlock(token);\n                                 String reason \u003d reasonInfo.string;\n                                 if (reason.length() \u003e 0) {\n                                     jsdocBuilder.recordDeprecationReason(reason);\n                                 }\n                                 token \u003d reasonInfo.token;\n                                 continue retry;\n                             case INTERFACE:\n                                 if (!jsdocBuilder.recordInterface()) {\n                                     if (jsdocBuilder.isConstructorRecorded()) {\n                                         parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                     } else {\n                                         parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case DESC:\n                                 if (jsdocBuilder.isDescriptionRecorded()) {\n                                     parser.addWarning(\"msg.jsdoc.desc.extra\", stream.getLineno(), stream.getCharno());\n                                     token \u003d eatTokensUntilEOL();\n                                     continue retry;\n                                 } else {\n                                     ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                     String description \u003d descriptionInfo.string;\n                                     jsdocBuilder.recordDescription(description);\n                                     token \u003d descriptionInfo.token;\n                                     continue retry;\n                                 }\n                             case FILE_OVERVIEW:\n                                 ExtractionInfo fileOverviewInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.TRIM);\n                                 String fileOverview \u003d fileOverviewInfo.string;\n                                 if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo !\u003d null) {\n                                     parser.addWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d fileOverviewInfo.token;\n                                 continue retry;\n                             case LICENSE:\n                             case PRESERVE:\n                                 ExtractionInfo preserveInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);\n                                 String preserve \u003d preserveInfo.string;\n                                 if (preserve.length() \u003e 0) {\n                                     if (fileLevelJsDocBuilder !\u003d null) {\n                                         fileLevelJsDocBuilder.append(preserve);\n                                     }\n                                 }\n                                 token \u003d preserveInfo.token;\n                                 continue retry;\n                             case ENUM:\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                 }\n                                 if (type \u003d\u003d null) {\n                                     type \u003d createJSTypeExpression(newStringNode(\"number\"));\n                                 }\n                                 if (!jsdocBuilder.recordEnumParameterType(type)) {\n                                     parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                 }\n                                 token \u003d eatTokensUntilEOL(token);\n                                 continue retry;\n                             case EXPORT:\n                                 if (!jsdocBuilder.recordExport()) {\n                                     parser.addWarning(\"msg.jsdoc.export\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n+                            case EXTERNS:\n+                                if (!jsdocBuilder.recordExterns()) {\n+                                    parser.addWarning(\"msg.jsdoc.externs\", stream.getLineno(), stream.getCharno());\n+                                }\n+                                token \u003d eatTokensUntilEOL();\n+                                continue retry;\n                             case EXTENDS:\n                             case IMPLEMENTS:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 boolean matchingRc \u003d false;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     token \u003d next();\n                                     matchingRc \u003d true;\n                                 }\n                                 if (token \u003d\u003d JsDocToken.STRING) {\n                                     Node typeNode \u003d parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);\n                                     lineno \u003d stream.getLineno();\n                                     charno \u003d stream.getCharno();\n                                     typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                     if (typeNode !\u003d null \u0026\u0026 !matchingRc) {\n                                         typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                     }\n                                     type \u003d createJSTypeExpression(typeNode);\n                                     if (annotation \u003d\u003d Annotation.EXTENDS) {\n                                         if (!jsdocBuilder.recordBaseType(type)) {\n                                             parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                         }\n                                     } else {\n                                         Preconditions.checkState(annotation \u003d\u003d Annotation.IMPLEMENTS);\n                                         if (!jsdocBuilder.recordImplementedInterface(type)) {\n                                             parser.addWarning(\"msg.jsdoc.implements.duplicate\", lineno, charno);\n                                         }\n                                     }\n                                     token \u003d next();\n                                     if (matchingRc) {\n                                         if (token !\u003d JsDocToken.RC) {\n                                             parser.addWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                         }\n                                     } else if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOF \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                         parser.addWarning(\"msg.end.annotation.expected\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 } else {\n                                     parser.addWarning(\"msg.no.type.name\", lineno, charno);\n                                 }\n                                 token \u003d eatTokensUntilEOL(token);\n                                 continue retry;\n                             case HIDDEN:\n                                 if (!jsdocBuilder.recordHiddenness()) {\n                                     parser.addWarning(\"msg.jsdoc.hidden\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_ALIAS:\n                                 if (!jsdocBuilder.recordNoAlias()) {\n                                     parser.addWarning(\"msg.jsdoc.noalias\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_TYPE_CHECK:\n                                 if (!jsdocBuilder.recordNoTypeCheck()) {\n                                     parser.addWarning(\"msg.jsdoc.nocheck\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NOT_IMPLEMENTED:\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case INHERIT_DOC:\n                             case OVERRIDE:\n                                 if (!jsdocBuilder.recordOverride()) {\n                                     parser.addWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case THROWS:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                     if (type \u003d\u003d null) {\n                                         token \u003d eatTokensUntilEOL();\n                                         continue retry;\n                                     }\n                                 }\n                                 token \u003d current();\n                                 jsdocBuilder.recordThrowType(type);\n                                 ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                 String description \u003d descriptionInfo.string;\n                                 if (description.length() \u003e 0) {\n                                     jsdocBuilder.recordThrowDescription(type, description);\n                                 }\n                                 token \u003d descriptionInfo.token;\n                                 continue retry;\n                             case PARAM:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordParamTypeNode(token));\n                                     if (type \u003d\u003d null) {\n                                         token \u003d eatTokensUntilEOL();\n                                         continue retry;\n                                     }\n                                     skipEOLs();\n                                     token \u003d next();\n                                     lineno \u003d stream.getLineno();\n                                     charno \u003d stream.getCharno();\n                                 }\n                                 String name \u003d null;\n                                 boolean isBracketedParam \u003d JsDocToken.LB \u003d\u003d token;\n                                 if (isBracketedParam) {\n                                     token \u003d next();\n                                 }\n                                 if (JsDocToken.STRING !\u003d token) {\n                                     parser.addWarning(\"msg.missing.variable.name\", lineno, charno);\n                                 } else {\n                                     name \u003d stream.getString();\n                                     if (isBracketedParam) {\n                                         token \u003d next();\n                                         if (JsDocToken.EQUALS \u003d\u003d token) {\n                                             token \u003d next();\n                                             if (JsDocToken.STRING \u003d\u003d token) {\n                                                 token \u003d next();\n                                             }\n                                         }\n                                         if (JsDocToken.RB !\u003d token) {\n                                             reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                                         } else if (type !\u003d null) {\n                                             type \u003d JSTypeExpression.makeOptionalArg(type);\n                                         }\n                                     }\n                                     if (name.indexOf(\u0027.\u0027) \u003e -1) {\n                                         name \u003d null;\n                                     } else if (!jsdocBuilder.recordParameter(name, type)) {\n                                         if (jsdocBuilder.hasParameter(name)) {\n                                             parser.addWarning(\"msg.dup.variable.name\", name, lineno, charno);\n                                         } else {\n                                             parser.addWarning(\"msg.jsdoc.incompat.type\", name, lineno, charno);\n                                         }\n                                     }\n                                 }\n                                 if (name \u003d\u003d null) {\n                                     token \u003d eatTokensUntilEOL(token);\n                                     continue retry;\n                                 }\n                                 jsdocBuilder.markName(name, lineno, charno);\n                                 ExtractionInfo paramDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                 String paramDescription \u003d paramDescriptionInfo.string;\n                                 if (paramDescription.length() \u003e 0) {\n                                     jsdocBuilder.recordParameterDescription(name, paramDescription);\n                                 }\n                                 token \u003d paramDescriptionInfo.token;\n                                 continue retry;\n                             case PRESERVE_TRY:\n                                 if (!jsdocBuilder.recordPreserveTry()) {\n                                     parser.addWarning(\"msg.jsdoc.preservertry\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PRIVATE:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                                     parser.addWarning(\"msg.jsdoc.visibility.private\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PROTECTED:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                                     parser.addWarning(\"msg.jsdoc.visibility.protected\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PUBLIC:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                                     parser.addWarning(\"msg.jsdoc.visibility.public\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_SHADOW:\n                                 if (!jsdocBuilder.recordNoShadow()) {\n                                     parser.addWarning(\"msg.jsdoc.noshadow\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_SIDE_EFFECTS:\n                                 if (!jsdocBuilder.recordNoSideEffects()) {\n                                     parser.addWarning(\"msg.jsdoc.nosideeffects\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case IMPLICIT_CAST:\n                                 if (!jsdocBuilder.recordImplicitCast()) {\n                                     parser.addWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case SEE:\n                                 ExtractionInfo referenceInfo \u003d extractSingleLineBlock();\n                                 String reference \u003d referenceInfo.string;\n                                 if (reference.length() \u003d\u003d 0) {\n                                     parser.addWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno());\n                                 } else {\n                                     jsdocBuilder.addReference(reference);\n                                 }\n                                 token \u003d referenceInfo.token;\n                                 continue retry;\n                             case SUPPRESS:\n                                 token \u003d parseSuppressTag(next());\n                                 continue retry;\n                             case TEMPLATE:\n                                 ExtractionInfo templateInfo \u003d extractSingleLineBlock();\n                                 String templateTypeName \u003d templateInfo.string;\n                                 if (templateTypeName.length() \u003d\u003d 0) {\n                                     parser.addWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno());\n                                 } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {\n                                     parser.addWarning(\"msg.jsdoc.template.at.most.once\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d templateInfo.token;\n                                 continue retry;\n                             case VERSION:\n                                 ExtractionInfo versionInfo \u003d extractSingleLineBlock();\n                                 String version \u003d versionInfo.string;\n                                 if (version.length() \u003d\u003d 0) {\n                                     parser.addWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno());\n                                 } else {\n                                     if (!jsdocBuilder.recordVersion(version)) {\n                                         parser.addWarning(\"msg.jsdoc.extraversion\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d versionInfo.token;\n                                 continue retry;\n                             case DEFINE:\n                             case RETURN:\n                             case THIS:\n                             case TYPE:\n                             case TYPEDEF:\n                                 skipEOLs();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 token \u003d next();\n                                 Node typeNode \u003d parseAndRecordTypeNode(token, lineno, charno);\n                                 if (annotation \u003d\u003d Annotation.THIS) {\n                                     typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                     if (typeNode !\u003d null \u0026\u0026 token !\u003d JsDocToken.LC) {\n                                         typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                     }\n                                 }\n                                 type \u003d createJSTypeExpression(typeNode);\n                                 if (type \u003d\u003d null) {\n                                 } else {\n                                     switch(annotation) {\n                                         case DEFINE:\n                                             if (!isValidDefineType(typeNode)) {\n                                                 parser.addWarning(\"msg.jsdoc.define.badtype\", lineno, charno);\n                                             } else if (!jsdocBuilder.recordDefineType(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.define\", lineno, charno);\n                                             }\n                                             break;\n                                         case RETURN:\n                                             if (!jsdocBuilder.recordReturnType(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                                 break;\n                                             }\n                                             token \u003d current();\n                                             ExtractionInfo returnDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                             String returnDescription \u003d returnDescriptionInfo.string;\n                                             if (returnDescription.length() \u003e 0) {\n                                                 jsdocBuilder.recordReturnDescription(returnDescription);\n                                             }\n                                             token \u003d returnDescriptionInfo.token;\n                                             continue retry;\n                                         case THIS:\n                                             if (!jsdocBuilder.recordThisType(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                         case TYPE:\n                                             if (!jsdocBuilder.recordType(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                         case TYPEDEF:\n                                             if (!jsdocBuilder.recordTypedef(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                     }\n                                     token \u003d eatTokensUntilEOL();\n                                 }\n                                 continue retry;\n                         }\n                     }\n                 }\n                 break;\n             case EOC:\n                 if (hasParsedFileOverviewDocInfo()) {\n                     fileOverviewJSDocInfo \u003d retrieveAndResetParsedJSDocInfo();\n                 }\n                 return true;\n             case EOF:\n                 jsdocBuilder.build(null);\n                 parser.addWarning(\"msg.unexpected.eof\", stream.getLineno(), stream.getCharno());\n                 return false;\n             case EOL:\n                 if (state \u003d\u003d State.SEARCHING_NEWLINE) {\n                     state \u003d State.SEARCHING_ANNOTATION;\n                 }\n                 token \u003d next();\n                 continue retry;\n             default:\n                 if (token \u003d\u003d JsDocToken.STAR \u0026\u0026 state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                     token \u003d next();\n                     continue retry;\n                 } else {\n                     state \u003d State.SEARCHING_NEWLINE;\n                     token \u003d eatTokensUntilEOL();\n                     continue retry;\n                 }\n         }\n         token \u003d next();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5af11d33f8b3f5403c9987104601f544cddb96c1": {
      "type": "Ybodychange",
      "commitMessage": "Better support for jsdoc toolkit annotations.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@14 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/19/09, 3:26 PM",
      "commitName": "5af11d33f8b3f5403c9987104601f544cddb96c1",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "commitDateOld": "11/16/09, 4:04 PM",
      "commitNameOld": "2acd6c1986e36bfdbae85c09eb83ac1940b86c73",
      "commitAuthorOld": "nicholas.j.santos@gmail.com",
      "daysBetweenCommits": 2.97,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "boolean parse() {\n    int lineno;\n    int charno;\n    JSTypeExpression type;\n    state \u003d State.SEARCHING_ANNOTATION;\n    JsDocToken token \u003d next();\n    ExtractionInfo blockInfo \u003d extractBlockComment(token);\n    token \u003d blockInfo.token;\n    if (blockInfo.string.length() \u003e 0) {\n        jsdocBuilder.recordBlockDescription(blockInfo.string);\n    }\n    retry: for (; ; ) {\n        switch(token) {\n            case ANNOTATION:\n                if (state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                    state \u003d State.SEARCHING_NEWLINE;\n                    lineno \u003d stream.getLineno();\n                    charno \u003d stream.getCharno();\n                    String annotationName \u003d stream.getString();\n                    Annotation annotation \u003d annotationNames.get(annotationName);\n                    if (annotation \u003d\u003d null) {\n                        parser.addWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno());\n                    } else {\n                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n                        switch(annotation) {\n                            case AUTHOR:\n                                ExtractionInfo authorInfo \u003d extractSingleLineBlock();\n                                String author \u003d authorInfo.string;\n                                if (author.length() \u003d\u003d 0) {\n                                    parser.addWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno());\n                                } else {\n                                    jsdocBuilder.addAuthor(author);\n                                }\n                                token \u003d authorInfo.token;\n                                continue retry;\n                            case CONSTANT:\n                                if (!jsdocBuilder.recordConstancy()) {\n                                    parser.addWarning(\"msg.jsdoc.const\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case CONSTRUCTOR:\n                                if (!jsdocBuilder.recordConstructor()) {\n                                    if (jsdocBuilder.isInterfaceRecorded()) {\n                                        parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case DEPRECATED:\n                                if (!jsdocBuilder.recordDeprecated()) {\n                                    parser.addWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno());\n                                }\n                                ExtractionInfo reasonInfo \u003d extractMultilineTextualBlock(token);\n                                String reason \u003d reasonInfo.string;\n                                if (reason.length() \u003e 0) {\n                                    jsdocBuilder.recordDeprecationReason(reason);\n                                }\n                                token \u003d reasonInfo.token;\n                                continue retry;\n                            case INTERFACE:\n                                if (!jsdocBuilder.recordInterface()) {\n                                    if (jsdocBuilder.isConstructorRecorded()) {\n                                        parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case DESC:\n                                if (jsdocBuilder.isDescriptionRecorded()) {\n                                    parser.addWarning(\"msg.jsdoc.desc.extra\", stream.getLineno(), stream.getCharno());\n                                    token \u003d eatTokensUntilEOL();\n                                    continue retry;\n                                } else {\n                                    ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                    String description \u003d descriptionInfo.string;\n                                    jsdocBuilder.recordDescription(description);\n                                    token \u003d descriptionInfo.token;\n                                    continue retry;\n                                }\n                            case FILE_OVERVIEW:\n                                ExtractionInfo fileOverviewInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.TRIM);\n                                String fileOverview \u003d fileOverviewInfo.string;\n                                if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo !\u003d null) {\n                                    parser.addWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d fileOverviewInfo.token;\n                                continue retry;\n                            case LICENSE:\n                            case PRESERVE:\n                                ExtractionInfo preserveInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);\n                                String preserve \u003d preserveInfo.string;\n                                if (preserve.length() \u003e 0) {\n                                    if (fileLevelJsDocBuilder !\u003d null) {\n                                        fileLevelJsDocBuilder.append(preserve);\n                                    }\n                                }\n                                token \u003d preserveInfo.token;\n                                continue retry;\n                            case ENUM:\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                }\n                                if (type \u003d\u003d null) {\n                                    type \u003d createJSTypeExpression(newStringNode(\"number\"));\n                                }\n                                if (!jsdocBuilder.recordEnumParameterType(type)) {\n                                    parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                }\n                                token \u003d eatTokensUntilEOL(token);\n                                continue retry;\n                            case EXPORT:\n                                if (!jsdocBuilder.recordExport()) {\n                                    parser.addWarning(\"msg.jsdoc.export\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case EXTENDS:\n                            case IMPLEMENTS:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                boolean matchingRc \u003d false;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    token \u003d next();\n                                    matchingRc \u003d true;\n                                }\n                                if (token \u003d\u003d JsDocToken.STRING) {\n                                    Node typeNode \u003d parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);\n                                    lineno \u003d stream.getLineno();\n                                    charno \u003d stream.getCharno();\n                                    typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                    if (typeNode !\u003d null \u0026\u0026 !matchingRc) {\n                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                    }\n                                    type \u003d createJSTypeExpression(typeNode);\n                                    if (annotation \u003d\u003d Annotation.EXTENDS) {\n                                        if (!jsdocBuilder.recordBaseType(type)) {\n                                            parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                        }\n                                    } else {\n                                        Preconditions.checkState(annotation \u003d\u003d Annotation.IMPLEMENTS);\n                                        if (!jsdocBuilder.recordImplementedInterface(type)) {\n                                            parser.addWarning(\"msg.jsdoc.implements.duplicate\", lineno, charno);\n                                        }\n                                    }\n                                    token \u003d next();\n                                    if (matchingRc) {\n                                        if (token !\u003d JsDocToken.RC) {\n                                            parser.addWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                        }\n                                    } else if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOF \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                        parser.addWarning(\"msg.end.annotation.expected\", stream.getLineno(), stream.getCharno());\n                                    }\n                                } else {\n                                    parser.addWarning(\"msg.no.type.name\", lineno, charno);\n                                }\n                                token \u003d eatTokensUntilEOL(token);\n                                continue retry;\n                            case HIDDEN:\n                                if (!jsdocBuilder.recordHiddenness()) {\n                                    parser.addWarning(\"msg.jsdoc.hidden\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_ALIAS:\n                                if (!jsdocBuilder.recordNoAlias()) {\n                                    parser.addWarning(\"msg.jsdoc.noalias\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_TYPE_CHECK:\n                                if (!jsdocBuilder.recordNoTypeCheck()) {\n                                    parser.addWarning(\"msg.jsdoc.nocheck\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NOT_IMPLEMENTED:\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case INHERIT_DOC:\n                            case OVERRIDE:\n                                if (!jsdocBuilder.recordOverride()) {\n                                    parser.addWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case THROWS:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                    if (type \u003d\u003d null) {\n                                        token \u003d eatTokensUntilEOL();\n                                        continue retry;\n                                    }\n                                }\n                                token \u003d current();\n                                jsdocBuilder.recordThrowType(type);\n                                ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                String description \u003d descriptionInfo.string;\n                                if (description.length() \u003e 0) {\n                                    jsdocBuilder.recordThrowDescription(type, description);\n                                }\n                                token \u003d descriptionInfo.token;\n                                continue retry;\n                            case PARAM:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordParamTypeNode(token));\n                                    if (type \u003d\u003d null) {\n                                        token \u003d eatTokensUntilEOL();\n                                        continue retry;\n                                    }\n                                    skipEOLs();\n                                    token \u003d next();\n                                    lineno \u003d stream.getLineno();\n                                    charno \u003d stream.getCharno();\n                                }\n                                String name \u003d null;\n                                boolean isBracketedParam \u003d JsDocToken.LB \u003d\u003d token;\n                                if (isBracketedParam) {\n                                    token \u003d next();\n                                }\n                                if (JsDocToken.STRING !\u003d token) {\n                                    parser.addWarning(\"msg.missing.variable.name\", lineno, charno);\n                                } else {\n                                    name \u003d stream.getString();\n                                    if (isBracketedParam) {\n                                        token \u003d next();\n                                        if (JsDocToken.EQUALS \u003d\u003d token) {\n                                            token \u003d next();\n                                            if (JsDocToken.STRING \u003d\u003d token) {\n                                                token \u003d next();\n                                            }\n                                        }\n                                        if (JsDocToken.RB !\u003d token) {\n                                            reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                                        } else if (type !\u003d null) {\n                                            type \u003d JSTypeExpression.makeOptionalArg(type);\n                                        }\n                                    }\n                                    if (name.indexOf(\u0027.\u0027) \u003e -1) {\n                                        name \u003d null;\n                                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                                        if (jsdocBuilder.hasParameter(name)) {\n                                            parser.addWarning(\"msg.dup.variable.name\", name, lineno, charno);\n                                        } else {\n                                            parser.addWarning(\"msg.jsdoc.incompat.type\", name, lineno, charno);\n                                        }\n                                    }\n                                }\n                                if (name \u003d\u003d null) {\n                                    token \u003d eatTokensUntilEOL(token);\n                                    continue retry;\n                                }\n                                jsdocBuilder.markName(name, lineno, charno);\n                                ExtractionInfo paramDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                String paramDescription \u003d paramDescriptionInfo.string;\n                                if (paramDescription.length() \u003e 0) {\n                                    jsdocBuilder.recordParameterDescription(name, paramDescription);\n                                }\n                                token \u003d paramDescriptionInfo.token;\n                                continue retry;\n                            case PRESERVE_TRY:\n                                if (!jsdocBuilder.recordPreserveTry()) {\n                                    parser.addWarning(\"msg.jsdoc.preservertry\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PRIVATE:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                                    parser.addWarning(\"msg.jsdoc.visibility.private\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PROTECTED:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                                    parser.addWarning(\"msg.jsdoc.visibility.protected\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PUBLIC:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                                    parser.addWarning(\"msg.jsdoc.visibility.public\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_SHADOW:\n                                if (!jsdocBuilder.recordNoShadow()) {\n                                    parser.addWarning(\"msg.jsdoc.noshadow\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_SIDE_EFFECTS:\n                                if (!jsdocBuilder.recordNoSideEffects()) {\n                                    parser.addWarning(\"msg.jsdoc.nosideeffects\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case IMPLICIT_CAST:\n                                if (!jsdocBuilder.recordImplicitCast()) {\n                                    parser.addWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case SEE:\n                                ExtractionInfo referenceInfo \u003d extractSingleLineBlock();\n                                String reference \u003d referenceInfo.string;\n                                if (reference.length() \u003d\u003d 0) {\n                                    parser.addWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno());\n                                } else {\n                                    jsdocBuilder.addReference(reference);\n                                }\n                                token \u003d referenceInfo.token;\n                                continue retry;\n                            case SUPPRESS:\n                                token \u003d parseSuppressTag(next());\n                                continue retry;\n                            case TEMPLATE:\n                                ExtractionInfo templateInfo \u003d extractSingleLineBlock();\n                                String templateTypeName \u003d templateInfo.string;\n                                if (templateTypeName.length() \u003d\u003d 0) {\n                                    parser.addWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno());\n                                } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {\n                                    parser.addWarning(\"msg.jsdoc.template.at.most.once\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d templateInfo.token;\n                                continue retry;\n                            case VERSION:\n                                ExtractionInfo versionInfo \u003d extractSingleLineBlock();\n                                String version \u003d versionInfo.string;\n                                if (version.length() \u003d\u003d 0) {\n                                    parser.addWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno());\n                                } else {\n                                    if (!jsdocBuilder.recordVersion(version)) {\n                                        parser.addWarning(\"msg.jsdoc.extraversion\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d versionInfo.token;\n                                continue retry;\n                            case DEFINE:\n                            case RETURN:\n                            case THIS:\n                            case TYPE:\n                            case TYPEDEF:\n                                skipEOLs();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                token \u003d next();\n                                Node typeNode \u003d parseAndRecordTypeNode(token, lineno, charno);\n                                if (annotation \u003d\u003d Annotation.THIS) {\n                                    typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                    if (typeNode !\u003d null \u0026\u0026 token !\u003d JsDocToken.LC) {\n                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                    }\n                                }\n                                type \u003d createJSTypeExpression(typeNode);\n                                if (type \u003d\u003d null) {\n                                } else {\n                                    switch(annotation) {\n                                        case DEFINE:\n                                            if (!isValidDefineType(typeNode)) {\n                                                parser.addWarning(\"msg.jsdoc.define.badtype\", lineno, charno);\n                                            } else if (!jsdocBuilder.recordDefineType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.define\", lineno, charno);\n                                            }\n                                            break;\n                                        case RETURN:\n                                            if (!jsdocBuilder.recordReturnType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                                break;\n                                            }\n                                            token \u003d current();\n                                            ExtractionInfo returnDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                            String returnDescription \u003d returnDescriptionInfo.string;\n                                            if (returnDescription.length() \u003e 0) {\n                                                jsdocBuilder.recordReturnDescription(returnDescription);\n                                            }\n                                            token \u003d returnDescriptionInfo.token;\n                                            continue retry;\n                                        case THIS:\n                                            if (!jsdocBuilder.recordThisType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                        case TYPE:\n                                            if (!jsdocBuilder.recordType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                        case TYPEDEF:\n                                            if (!jsdocBuilder.recordTypedef(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                    }\n                                    token \u003d eatTokensUntilEOL();\n                                }\n                                continue retry;\n                        }\n                    }\n                }\n                break;\n            case EOC:\n                if (hasParsedFileOverviewDocInfo()) {\n                    fileOverviewJSDocInfo \u003d retrieveAndResetParsedJSDocInfo();\n                }\n                return true;\n            case EOF:\n                jsdocBuilder.build(null);\n                parser.addWarning(\"msg.unexpected.eof\", stream.getLineno(), stream.getCharno());\n                return false;\n            case EOL:\n                if (state \u003d\u003d State.SEARCHING_NEWLINE) {\n                    state \u003d State.SEARCHING_ANNOTATION;\n                }\n                token \u003d next();\n                continue retry;\n            default:\n                if (token \u003d\u003d JsDocToken.STAR \u0026\u0026 state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                    token \u003d next();\n                    continue retry;\n                } else {\n                    state \u003d State.SEARCHING_NEWLINE;\n                    token \u003d eatTokensUntilEOL();\n                    continue retry;\n                }\n        }\n        token \u003d next();\n    }\n}",
      "path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
      "functionStartLine": 237,
      "functionName": "parse",
      "functionAnnotation": "",
      "functionDoc": "Parses a {@link JSDocInfo} object. This parsing method reads all tokens\nreturned by the {@link JsDocTokenStream#getJsDocToken()} method until the\n{@link JsDocToken#EOC} is returned.\n\n@return @code true} if JSDoc information was correctly parsed,\n    {@code false} otherwise\n",
      "diff": "@@ -1,440 +1,448 @@\n boolean parse() {\n     int lineno;\n     int charno;\n     JSTypeExpression type;\n     state \u003d State.SEARCHING_ANNOTATION;\n     JsDocToken token \u003d next();\n     ExtractionInfo blockInfo \u003d extractBlockComment(token);\n     token \u003d blockInfo.token;\n     if (blockInfo.string.length() \u003e 0) {\n         jsdocBuilder.recordBlockDescription(blockInfo.string);\n     }\n     retry: for (; ; ) {\n         switch(token) {\n             case ANNOTATION:\n                 if (state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                     state \u003d State.SEARCHING_NEWLINE;\n                     lineno \u003d stream.getLineno();\n                     charno \u003d stream.getCharno();\n                     String annotationName \u003d stream.getString();\n                     Annotation annotation \u003d annotationNames.get(annotationName);\n                     if (annotation \u003d\u003d null) {\n                         parser.addWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno());\n                     } else {\n                         jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n                         switch(annotation) {\n                             case AUTHOR:\n                                 ExtractionInfo authorInfo \u003d extractSingleLineBlock();\n                                 String author \u003d authorInfo.string;\n                                 if (author.length() \u003d\u003d 0) {\n                                     parser.addWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno());\n                                 } else {\n                                     jsdocBuilder.addAuthor(author);\n                                 }\n                                 token \u003d authorInfo.token;\n                                 continue retry;\n                             case CONSTANT:\n                                 if (!jsdocBuilder.recordConstancy()) {\n                                     parser.addWarning(\"msg.jsdoc.const\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case CONSTRUCTOR:\n                                 if (!jsdocBuilder.recordConstructor()) {\n                                     if (jsdocBuilder.isInterfaceRecorded()) {\n                                         parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                     } else {\n                                         parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case DEPRECATED:\n                                 if (!jsdocBuilder.recordDeprecated()) {\n                                     parser.addWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 ExtractionInfo reasonInfo \u003d extractMultilineTextualBlock(token);\n                                 String reason \u003d reasonInfo.string;\n                                 if (reason.length() \u003e 0) {\n                                     jsdocBuilder.recordDeprecationReason(reason);\n                                 }\n                                 token \u003d reasonInfo.token;\n                                 continue retry;\n                             case INTERFACE:\n                                 if (!jsdocBuilder.recordInterface()) {\n                                     if (jsdocBuilder.isConstructorRecorded()) {\n                                         parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                     } else {\n                                         parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case DESC:\n                                 if (jsdocBuilder.isDescriptionRecorded()) {\n                                     parser.addWarning(\"msg.jsdoc.desc.extra\", stream.getLineno(), stream.getCharno());\n                                     token \u003d eatTokensUntilEOL();\n                                     continue retry;\n                                 } else {\n                                     ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                     String description \u003d descriptionInfo.string;\n                                     jsdocBuilder.recordDescription(description);\n                                     token \u003d descriptionInfo.token;\n                                     continue retry;\n                                 }\n                             case FILE_OVERVIEW:\n                                 ExtractionInfo fileOverviewInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.TRIM);\n                                 String fileOverview \u003d fileOverviewInfo.string;\n                                 if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo !\u003d null) {\n                                     parser.addWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d fileOverviewInfo.token;\n                                 continue retry;\n                             case LICENSE:\n                             case PRESERVE:\n                                 ExtractionInfo preserveInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);\n                                 String preserve \u003d preserveInfo.string;\n                                 if (preserve.length() \u003e 0) {\n                                     if (fileLevelJsDocBuilder !\u003d null) {\n                                         fileLevelJsDocBuilder.append(preserve);\n                                     }\n                                 }\n                                 token \u003d preserveInfo.token;\n                                 continue retry;\n                             case ENUM:\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                 }\n                                 if (type \u003d\u003d null) {\n                                     type \u003d createJSTypeExpression(newStringNode(\"number\"));\n                                 }\n                                 if (!jsdocBuilder.recordEnumParameterType(type)) {\n                                     parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                 }\n                                 token \u003d eatTokensUntilEOL(token);\n                                 continue retry;\n                             case EXPORT:\n                                 if (!jsdocBuilder.recordExport()) {\n                                     parser.addWarning(\"msg.jsdoc.export\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case EXTENDS:\n                             case IMPLEMENTS:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 boolean matchingRc \u003d false;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     token \u003d next();\n                                     matchingRc \u003d true;\n                                 }\n                                 if (token \u003d\u003d JsDocToken.STRING) {\n                                     Node typeNode \u003d parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);\n                                     lineno \u003d stream.getLineno();\n                                     charno \u003d stream.getCharno();\n                                     typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                     if (typeNode !\u003d null \u0026\u0026 !matchingRc) {\n                                         typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                     }\n                                     type \u003d createJSTypeExpression(typeNode);\n                                     if (annotation \u003d\u003d Annotation.EXTENDS) {\n                                         if (!jsdocBuilder.recordBaseType(type)) {\n                                             parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                         }\n                                     } else {\n                                         Preconditions.checkState(annotation \u003d\u003d Annotation.IMPLEMENTS);\n                                         if (!jsdocBuilder.recordImplementedInterface(type)) {\n                                             parser.addWarning(\"msg.jsdoc.implements.duplicate\", lineno, charno);\n                                         }\n                                     }\n                                     token \u003d next();\n                                     if (matchingRc) {\n                                         if (token !\u003d JsDocToken.RC) {\n                                             parser.addWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                         }\n                                     } else if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOF \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                         parser.addWarning(\"msg.end.annotation.expected\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 } else {\n                                     parser.addWarning(\"msg.no.type.name\", lineno, charno);\n                                 }\n                                 token \u003d eatTokensUntilEOL(token);\n                                 continue retry;\n                             case HIDDEN:\n                                 if (!jsdocBuilder.recordHiddenness()) {\n                                     parser.addWarning(\"msg.jsdoc.hidden\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_ALIAS:\n                                 if (!jsdocBuilder.recordNoAlias()) {\n                                     parser.addWarning(\"msg.jsdoc.noalias\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_TYPE_CHECK:\n                                 if (!jsdocBuilder.recordNoTypeCheck()) {\n                                     parser.addWarning(\"msg.jsdoc.nocheck\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NOT_IMPLEMENTED:\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case INHERIT_DOC:\n                             case OVERRIDE:\n                                 if (!jsdocBuilder.recordOverride()) {\n                                     parser.addWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case THROWS:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                     if (type \u003d\u003d null) {\n                                         token \u003d eatTokensUntilEOL();\n                                         continue retry;\n                                     }\n                                 }\n                                 token \u003d current();\n                                 jsdocBuilder.recordThrowType(type);\n                                 ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                 String description \u003d descriptionInfo.string;\n                                 if (description.length() \u003e 0) {\n                                     jsdocBuilder.recordThrowDescription(type, description);\n                                 }\n                                 token \u003d descriptionInfo.token;\n                                 continue retry;\n                             case PARAM:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordParamTypeNode(token));\n                                     if (type \u003d\u003d null) {\n                                         token \u003d eatTokensUntilEOL();\n                                         continue retry;\n                                     }\n                                     skipEOLs();\n                                     token \u003d next();\n                                     lineno \u003d stream.getLineno();\n                                     charno \u003d stream.getCharno();\n                                 }\n                                 String name \u003d null;\n                                 boolean isBracketedParam \u003d JsDocToken.LB \u003d\u003d token;\n                                 if (isBracketedParam) {\n                                     token \u003d next();\n                                 }\n                                 if (JsDocToken.STRING !\u003d token) {\n                                     parser.addWarning(\"msg.missing.variable.name\", lineno, charno);\n                                 } else {\n                                     name \u003d stream.getString();\n                                     if (isBracketedParam) {\n                                         token \u003d next();\n+                                        if (JsDocToken.EQUALS \u003d\u003d token) {\n+                                            token \u003d next();\n+                                            if (JsDocToken.STRING \u003d\u003d token) {\n+                                                token \u003d next();\n+                                            }\n+                                        }\n                                         if (JsDocToken.RB !\u003d token) {\n                                             reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                                         } else if (type !\u003d null) {\n                                             type \u003d JSTypeExpression.makeOptionalArg(type);\n                                         }\n                                     }\n-                                    if (!jsdocBuilder.recordParameter(name, type)) {\n+                                    if (name.indexOf(\u0027.\u0027) \u003e -1) {\n+                                        name \u003d null;\n+                                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                                         if (jsdocBuilder.hasParameter(name)) {\n                                             parser.addWarning(\"msg.dup.variable.name\", name, lineno, charno);\n                                         } else {\n                                             parser.addWarning(\"msg.jsdoc.incompat.type\", name, lineno, charno);\n                                         }\n                                     }\n                                 }\n                                 if (name \u003d\u003d null) {\n                                     token \u003d eatTokensUntilEOL(token);\n                                     continue retry;\n                                 }\n                                 jsdocBuilder.markName(name, lineno, charno);\n                                 ExtractionInfo paramDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                 String paramDescription \u003d paramDescriptionInfo.string;\n                                 if (paramDescription.length() \u003e 0) {\n                                     jsdocBuilder.recordParameterDescription(name, paramDescription);\n                                 }\n                                 token \u003d paramDescriptionInfo.token;\n                                 continue retry;\n                             case PRESERVE_TRY:\n                                 if (!jsdocBuilder.recordPreserveTry()) {\n                                     parser.addWarning(\"msg.jsdoc.preservertry\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PRIVATE:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                                     parser.addWarning(\"msg.jsdoc.visibility.private\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PROTECTED:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                                     parser.addWarning(\"msg.jsdoc.visibility.protected\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PUBLIC:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                                     parser.addWarning(\"msg.jsdoc.visibility.public\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_SHADOW:\n                                 if (!jsdocBuilder.recordNoShadow()) {\n                                     parser.addWarning(\"msg.jsdoc.noshadow\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_SIDE_EFFECTS:\n                                 if (!jsdocBuilder.recordNoSideEffects()) {\n                                     parser.addWarning(\"msg.jsdoc.nosideeffects\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case IMPLICIT_CAST:\n                                 if (!jsdocBuilder.recordImplicitCast()) {\n                                     parser.addWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case SEE:\n                                 ExtractionInfo referenceInfo \u003d extractSingleLineBlock();\n                                 String reference \u003d referenceInfo.string;\n                                 if (reference.length() \u003d\u003d 0) {\n                                     parser.addWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno());\n                                 } else {\n                                     jsdocBuilder.addReference(reference);\n                                 }\n                                 token \u003d referenceInfo.token;\n                                 continue retry;\n                             case SUPPRESS:\n                                 token \u003d parseSuppressTag(next());\n                                 continue retry;\n                             case TEMPLATE:\n                                 ExtractionInfo templateInfo \u003d extractSingleLineBlock();\n                                 String templateTypeName \u003d templateInfo.string;\n                                 if (templateTypeName.length() \u003d\u003d 0) {\n                                     parser.addWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno());\n                                 } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {\n                                     parser.addWarning(\"msg.jsdoc.template.at.most.once\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d templateInfo.token;\n                                 continue retry;\n                             case VERSION:\n                                 ExtractionInfo versionInfo \u003d extractSingleLineBlock();\n                                 String version \u003d versionInfo.string;\n                                 if (version.length() \u003d\u003d 0) {\n                                     parser.addWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno());\n                                 } else {\n                                     if (!jsdocBuilder.recordVersion(version)) {\n                                         parser.addWarning(\"msg.jsdoc.extraversion\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d versionInfo.token;\n                                 continue retry;\n                             case DEFINE:\n                             case RETURN:\n                             case THIS:\n                             case TYPE:\n                             case TYPEDEF:\n                                 skipEOLs();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 token \u003d next();\n                                 Node typeNode \u003d parseAndRecordTypeNode(token, lineno, charno);\n                                 if (annotation \u003d\u003d Annotation.THIS) {\n                                     typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                     if (typeNode !\u003d null \u0026\u0026 token !\u003d JsDocToken.LC) {\n                                         typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                     }\n                                 }\n                                 type \u003d createJSTypeExpression(typeNode);\n                                 if (type \u003d\u003d null) {\n                                 } else {\n                                     switch(annotation) {\n                                         case DEFINE:\n                                             if (!isValidDefineType(typeNode)) {\n                                                 parser.addWarning(\"msg.jsdoc.define.badtype\", lineno, charno);\n                                             } else if (!jsdocBuilder.recordDefineType(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.define\", lineno, charno);\n                                             }\n                                             break;\n                                         case RETURN:\n                                             if (!jsdocBuilder.recordReturnType(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                                 break;\n                                             }\n                                             token \u003d current();\n                                             ExtractionInfo returnDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                             String returnDescription \u003d returnDescriptionInfo.string;\n                                             if (returnDescription.length() \u003e 0) {\n                                                 jsdocBuilder.recordReturnDescription(returnDescription);\n                                             }\n                                             token \u003d returnDescriptionInfo.token;\n                                             continue retry;\n                                         case THIS:\n                                             if (!jsdocBuilder.recordThisType(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                         case TYPE:\n                                             if (!jsdocBuilder.recordType(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                         case TYPEDEF:\n                                             if (!jsdocBuilder.recordTypedef(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                     }\n                                     token \u003d eatTokensUntilEOL();\n                                 }\n                                 continue retry;\n                         }\n                     }\n                 }\n                 break;\n             case EOC:\n                 if (hasParsedFileOverviewDocInfo()) {\n                     fileOverviewJSDocInfo \u003d retrieveAndResetParsedJSDocInfo();\n                 }\n                 return true;\n             case EOF:\n                 jsdocBuilder.build(null);\n                 parser.addWarning(\"msg.unexpected.eof\", stream.getLineno(), stream.getCharno());\n                 return false;\n             case EOL:\n                 if (state \u003d\u003d State.SEARCHING_NEWLINE) {\n                     state \u003d State.SEARCHING_ANNOTATION;\n                 }\n                 token \u003d next();\n                 continue retry;\n             default:\n                 if (token \u003d\u003d JsDocToken.STAR \u0026\u0026 state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                     token \u003d next();\n                     continue retry;\n                 } else {\n                     state \u003d State.SEARCHING_NEWLINE;\n                     token \u003d eatTokensUntilEOL();\n                     continue retry;\n                 }\n         }\n         token \u003d next();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2acd6c1986e36bfdbae85c09eb83ac1940b86c73": {
      "type": "Ybodychange",
      "commitMessage": "Fix if-folding compiler crash (issue 43)\nFix property-collapsing compiler crash (issue 34)\nFix labeled VAR compiler crash (issue 41)\nMake [paramName] syntax denote optionality (issue #26)\nBetter function inlining.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@11 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/16/09, 4:04 PM",
      "commitName": "2acd6c1986e36bfdbae85c09eb83ac1940b86c73",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "commitDateOld": "11/13/09, 11:38 AM",
      "commitNameOld": "efd3c178e471df6a689c1a50fbd7c404e778bfaa",
      "commitAuthorOld": "nicholas.j.santos@gmail.com",
      "daysBetweenCommits": 3.18,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "boolean parse() {\n    int lineno;\n    int charno;\n    JSTypeExpression type;\n    state \u003d State.SEARCHING_ANNOTATION;\n    JsDocToken token \u003d next();\n    ExtractionInfo blockInfo \u003d extractBlockComment(token);\n    token \u003d blockInfo.token;\n    if (blockInfo.string.length() \u003e 0) {\n        jsdocBuilder.recordBlockDescription(blockInfo.string);\n    }\n    retry: for (; ; ) {\n        switch(token) {\n            case ANNOTATION:\n                if (state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                    state \u003d State.SEARCHING_NEWLINE;\n                    lineno \u003d stream.getLineno();\n                    charno \u003d stream.getCharno();\n                    String annotationName \u003d stream.getString();\n                    Annotation annotation \u003d annotationNames.get(annotationName);\n                    if (annotation \u003d\u003d null) {\n                        parser.addWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno());\n                    } else {\n                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n                        switch(annotation) {\n                            case AUTHOR:\n                                ExtractionInfo authorInfo \u003d extractSingleLineBlock();\n                                String author \u003d authorInfo.string;\n                                if (author.length() \u003d\u003d 0) {\n                                    parser.addWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno());\n                                } else {\n                                    jsdocBuilder.addAuthor(author);\n                                }\n                                token \u003d authorInfo.token;\n                                continue retry;\n                            case CONSTANT:\n                                if (!jsdocBuilder.recordConstancy()) {\n                                    parser.addWarning(\"msg.jsdoc.const\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case CONSTRUCTOR:\n                                if (!jsdocBuilder.recordConstructor()) {\n                                    if (jsdocBuilder.isInterfaceRecorded()) {\n                                        parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case DEPRECATED:\n                                if (!jsdocBuilder.recordDeprecated()) {\n                                    parser.addWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno());\n                                }\n                                ExtractionInfo reasonInfo \u003d extractMultilineTextualBlock(token);\n                                String reason \u003d reasonInfo.string;\n                                if (reason.length() \u003e 0) {\n                                    jsdocBuilder.recordDeprecationReason(reason);\n                                }\n                                token \u003d reasonInfo.token;\n                                continue retry;\n                            case INTERFACE:\n                                if (!jsdocBuilder.recordInterface()) {\n                                    if (jsdocBuilder.isConstructorRecorded()) {\n                                        parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case DESC:\n                                if (jsdocBuilder.isDescriptionRecorded()) {\n                                    parser.addWarning(\"msg.jsdoc.desc.extra\", stream.getLineno(), stream.getCharno());\n                                    token \u003d eatTokensUntilEOL();\n                                    continue retry;\n                                } else {\n                                    ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                    String description \u003d descriptionInfo.string;\n                                    jsdocBuilder.recordDescription(description);\n                                    token \u003d descriptionInfo.token;\n                                    continue retry;\n                                }\n                            case FILE_OVERVIEW:\n                                ExtractionInfo fileOverviewInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.TRIM);\n                                String fileOverview \u003d fileOverviewInfo.string;\n                                if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo !\u003d null) {\n                                    parser.addWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d fileOverviewInfo.token;\n                                continue retry;\n                            case LICENSE:\n                            case PRESERVE:\n                                ExtractionInfo preserveInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);\n                                String preserve \u003d preserveInfo.string;\n                                if (preserve.length() \u003e 0) {\n                                    if (fileLevelJsDocBuilder !\u003d null) {\n                                        fileLevelJsDocBuilder.append(preserve);\n                                    }\n                                }\n                                token \u003d preserveInfo.token;\n                                continue retry;\n                            case ENUM:\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                }\n                                if (type \u003d\u003d null) {\n                                    type \u003d createJSTypeExpression(newStringNode(\"number\"));\n                                }\n                                if (!jsdocBuilder.recordEnumParameterType(type)) {\n                                    parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                }\n                                token \u003d eatTokensUntilEOL(token);\n                                continue retry;\n                            case EXPORT:\n                                if (!jsdocBuilder.recordExport()) {\n                                    parser.addWarning(\"msg.jsdoc.export\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case EXTENDS:\n                            case IMPLEMENTS:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                boolean matchingRc \u003d false;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    token \u003d next();\n                                    matchingRc \u003d true;\n                                }\n                                if (token \u003d\u003d JsDocToken.STRING) {\n                                    Node typeNode \u003d parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);\n                                    lineno \u003d stream.getLineno();\n                                    charno \u003d stream.getCharno();\n                                    typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                    if (typeNode !\u003d null \u0026\u0026 !matchingRc) {\n                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                    }\n                                    type \u003d createJSTypeExpression(typeNode);\n                                    if (annotation \u003d\u003d Annotation.EXTENDS) {\n                                        if (!jsdocBuilder.recordBaseType(type)) {\n                                            parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                        }\n                                    } else {\n                                        Preconditions.checkState(annotation \u003d\u003d Annotation.IMPLEMENTS);\n                                        if (!jsdocBuilder.recordImplementedInterface(type)) {\n                                            parser.addWarning(\"msg.jsdoc.implements.duplicate\", lineno, charno);\n                                        }\n                                    }\n                                    token \u003d next();\n                                    if (matchingRc) {\n                                        if (token !\u003d JsDocToken.RC) {\n                                            parser.addWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                        }\n                                    } else if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOF \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                        parser.addWarning(\"msg.end.annotation.expected\", stream.getLineno(), stream.getCharno());\n                                    }\n                                } else {\n                                    parser.addWarning(\"msg.no.type.name\", lineno, charno);\n                                }\n                                token \u003d eatTokensUntilEOL(token);\n                                continue retry;\n                            case HIDDEN:\n                                if (!jsdocBuilder.recordHiddenness()) {\n                                    parser.addWarning(\"msg.jsdoc.hidden\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_ALIAS:\n                                if (!jsdocBuilder.recordNoAlias()) {\n                                    parser.addWarning(\"msg.jsdoc.noalias\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_TYPE_CHECK:\n                                if (!jsdocBuilder.recordNoTypeCheck()) {\n                                    parser.addWarning(\"msg.jsdoc.nocheck\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NOT_IMPLEMENTED:\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case INHERIT_DOC:\n                            case OVERRIDE:\n                                if (!jsdocBuilder.recordOverride()) {\n                                    parser.addWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case THROWS:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                    if (type \u003d\u003d null) {\n                                        token \u003d eatTokensUntilEOL();\n                                        continue retry;\n                                    }\n                                }\n                                token \u003d current();\n                                jsdocBuilder.recordThrowType(type);\n                                ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                String description \u003d descriptionInfo.string;\n                                if (description.length() \u003e 0) {\n                                    jsdocBuilder.recordThrowDescription(type, description);\n                                }\n                                token \u003d descriptionInfo.token;\n                                continue retry;\n                            case PARAM:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordParamTypeNode(token));\n                                    if (type \u003d\u003d null) {\n                                        token \u003d eatTokensUntilEOL();\n                                        continue retry;\n                                    }\n                                    skipEOLs();\n                                    token \u003d next();\n                                    lineno \u003d stream.getLineno();\n                                    charno \u003d stream.getCharno();\n                                }\n                                String name \u003d null;\n                                boolean isBracketedParam \u003d JsDocToken.LB \u003d\u003d token;\n                                if (isBracketedParam) {\n                                    token \u003d next();\n                                }\n                                if (JsDocToken.STRING !\u003d token) {\n                                    parser.addWarning(\"msg.missing.variable.name\", lineno, charno);\n                                } else {\n                                    name \u003d stream.getString();\n                                    if (isBracketedParam) {\n                                        token \u003d next();\n                                        if (JsDocToken.RB !\u003d token) {\n                                            reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                                        } else if (type !\u003d null) {\n                                            type \u003d JSTypeExpression.makeOptionalArg(type);\n                                        }\n                                    }\n                                    if (!jsdocBuilder.recordParameter(name, type)) {\n                                        if (jsdocBuilder.hasParameter(name)) {\n                                            parser.addWarning(\"msg.dup.variable.name\", name, lineno, charno);\n                                        } else {\n                                            parser.addWarning(\"msg.jsdoc.incompat.type\", name, lineno, charno);\n                                        }\n                                    }\n                                }\n                                if (name \u003d\u003d null) {\n                                    token \u003d eatTokensUntilEOL(token);\n                                    continue retry;\n                                }\n                                jsdocBuilder.markName(name, lineno, charno);\n                                ExtractionInfo paramDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                String paramDescription \u003d paramDescriptionInfo.string;\n                                if (paramDescription.length() \u003e 0) {\n                                    jsdocBuilder.recordParameterDescription(name, paramDescription);\n                                }\n                                token \u003d paramDescriptionInfo.token;\n                                continue retry;\n                            case PRESERVE_TRY:\n                                if (!jsdocBuilder.recordPreserveTry()) {\n                                    parser.addWarning(\"msg.jsdoc.preservertry\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PRIVATE:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                                    parser.addWarning(\"msg.jsdoc.visibility.private\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PROTECTED:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                                    parser.addWarning(\"msg.jsdoc.visibility.protected\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PUBLIC:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                                    parser.addWarning(\"msg.jsdoc.visibility.public\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_SHADOW:\n                                if (!jsdocBuilder.recordNoShadow()) {\n                                    parser.addWarning(\"msg.jsdoc.noshadow\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_SIDE_EFFECTS:\n                                if (!jsdocBuilder.recordNoSideEffects()) {\n                                    parser.addWarning(\"msg.jsdoc.nosideeffects\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case IMPLICIT_CAST:\n                                if (!jsdocBuilder.recordImplicitCast()) {\n                                    parser.addWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case SEE:\n                                ExtractionInfo referenceInfo \u003d extractSingleLineBlock();\n                                String reference \u003d referenceInfo.string;\n                                if (reference.length() \u003d\u003d 0) {\n                                    parser.addWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno());\n                                } else {\n                                    jsdocBuilder.addReference(reference);\n                                }\n                                token \u003d referenceInfo.token;\n                                continue retry;\n                            case SUPPRESS:\n                                token \u003d parseSuppressTag(next());\n                                continue retry;\n                            case TEMPLATE:\n                                ExtractionInfo templateInfo \u003d extractSingleLineBlock();\n                                String templateTypeName \u003d templateInfo.string;\n                                if (templateTypeName.length() \u003d\u003d 0) {\n                                    parser.addWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno());\n                                } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {\n                                    parser.addWarning(\"msg.jsdoc.template.at.most.once\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d templateInfo.token;\n                                continue retry;\n                            case VERSION:\n                                ExtractionInfo versionInfo \u003d extractSingleLineBlock();\n                                String version \u003d versionInfo.string;\n                                if (version.length() \u003d\u003d 0) {\n                                    parser.addWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno());\n                                } else {\n                                    if (!jsdocBuilder.recordVersion(version)) {\n                                        parser.addWarning(\"msg.jsdoc.extraversion\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d versionInfo.token;\n                                continue retry;\n                            case DEFINE:\n                            case RETURN:\n                            case THIS:\n                            case TYPE:\n                            case TYPEDEF:\n                                skipEOLs();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                token \u003d next();\n                                Node typeNode \u003d parseAndRecordTypeNode(token, lineno, charno);\n                                if (annotation \u003d\u003d Annotation.THIS) {\n                                    typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                    if (typeNode !\u003d null \u0026\u0026 token !\u003d JsDocToken.LC) {\n                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                    }\n                                }\n                                type \u003d createJSTypeExpression(typeNode);\n                                if (type \u003d\u003d null) {\n                                } else {\n                                    switch(annotation) {\n                                        case DEFINE:\n                                            if (!isValidDefineType(typeNode)) {\n                                                parser.addWarning(\"msg.jsdoc.define.badtype\", lineno, charno);\n                                            } else if (!jsdocBuilder.recordDefineType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.define\", lineno, charno);\n                                            }\n                                            break;\n                                        case RETURN:\n                                            if (!jsdocBuilder.recordReturnType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                                break;\n                                            }\n                                            token \u003d current();\n                                            ExtractionInfo returnDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                            String returnDescription \u003d returnDescriptionInfo.string;\n                                            if (returnDescription.length() \u003e 0) {\n                                                jsdocBuilder.recordReturnDescription(returnDescription);\n                                            }\n                                            token \u003d returnDescriptionInfo.token;\n                                            continue retry;\n                                        case THIS:\n                                            if (!jsdocBuilder.recordThisType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                        case TYPE:\n                                            if (!jsdocBuilder.recordType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                        case TYPEDEF:\n                                            if (!jsdocBuilder.recordTypedef(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                    }\n                                    token \u003d eatTokensUntilEOL();\n                                }\n                                continue retry;\n                        }\n                    }\n                }\n                break;\n            case EOC:\n                if (hasParsedFileOverviewDocInfo()) {\n                    fileOverviewJSDocInfo \u003d retrieveAndResetParsedJSDocInfo();\n                }\n                return true;\n            case EOF:\n                jsdocBuilder.build(null);\n                parser.addWarning(\"msg.unexpected.eof\", stream.getLineno(), stream.getCharno());\n                return false;\n            case EOL:\n                if (state \u003d\u003d State.SEARCHING_NEWLINE) {\n                    state \u003d State.SEARCHING_ANNOTATION;\n                }\n                token \u003d next();\n                continue retry;\n            default:\n                if (token \u003d\u003d JsDocToken.STAR \u0026\u0026 state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                    token \u003d next();\n                    continue retry;\n                } else {\n                    state \u003d State.SEARCHING_NEWLINE;\n                    token \u003d eatTokensUntilEOL();\n                    continue retry;\n                }\n        }\n        token \u003d next();\n    }\n}",
      "path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
      "functionStartLine": 237,
      "functionName": "parse",
      "functionAnnotation": "",
      "functionDoc": "Parses a {@link JSDocInfo} object. This parsing method reads all tokens\nreturned by the {@link JsDocTokenStream#getJsDocToken()} method until the\n{@link JsDocToken#EOC} is returned.\n\n@return @code true} if JSDoc information was correctly parsed,\n    {@code false} otherwise\n",
      "diff": "@@ -1,438 +1,440 @@\n boolean parse() {\n     int lineno;\n     int charno;\n     JSTypeExpression type;\n     state \u003d State.SEARCHING_ANNOTATION;\n     JsDocToken token \u003d next();\n     ExtractionInfo blockInfo \u003d extractBlockComment(token);\n     token \u003d blockInfo.token;\n     if (blockInfo.string.length() \u003e 0) {\n         jsdocBuilder.recordBlockDescription(blockInfo.string);\n     }\n     retry: for (; ; ) {\n         switch(token) {\n             case ANNOTATION:\n                 if (state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                     state \u003d State.SEARCHING_NEWLINE;\n                     lineno \u003d stream.getLineno();\n                     charno \u003d stream.getCharno();\n                     String annotationName \u003d stream.getString();\n                     Annotation annotation \u003d annotationNames.get(annotationName);\n                     if (annotation \u003d\u003d null) {\n                         parser.addWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno());\n                     } else {\n                         jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n                         switch(annotation) {\n                             case AUTHOR:\n                                 ExtractionInfo authorInfo \u003d extractSingleLineBlock();\n                                 String author \u003d authorInfo.string;\n                                 if (author.length() \u003d\u003d 0) {\n                                     parser.addWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno());\n                                 } else {\n                                     jsdocBuilder.addAuthor(author);\n                                 }\n                                 token \u003d authorInfo.token;\n                                 continue retry;\n                             case CONSTANT:\n                                 if (!jsdocBuilder.recordConstancy()) {\n                                     parser.addWarning(\"msg.jsdoc.const\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case CONSTRUCTOR:\n                                 if (!jsdocBuilder.recordConstructor()) {\n                                     if (jsdocBuilder.isInterfaceRecorded()) {\n                                         parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                     } else {\n                                         parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case DEPRECATED:\n                                 if (!jsdocBuilder.recordDeprecated()) {\n                                     parser.addWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 ExtractionInfo reasonInfo \u003d extractMultilineTextualBlock(token);\n                                 String reason \u003d reasonInfo.string;\n                                 if (reason.length() \u003e 0) {\n                                     jsdocBuilder.recordDeprecationReason(reason);\n                                 }\n                                 token \u003d reasonInfo.token;\n                                 continue retry;\n                             case INTERFACE:\n                                 if (!jsdocBuilder.recordInterface()) {\n                                     if (jsdocBuilder.isConstructorRecorded()) {\n                                         parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                     } else {\n                                         parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case DESC:\n                                 if (jsdocBuilder.isDescriptionRecorded()) {\n                                     parser.addWarning(\"msg.jsdoc.desc.extra\", stream.getLineno(), stream.getCharno());\n                                     token \u003d eatTokensUntilEOL();\n                                     continue retry;\n                                 } else {\n                                     ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                     String description \u003d descriptionInfo.string;\n                                     jsdocBuilder.recordDescription(description);\n                                     token \u003d descriptionInfo.token;\n                                     continue retry;\n                                 }\n                             case FILE_OVERVIEW:\n                                 ExtractionInfo fileOverviewInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.TRIM);\n                                 String fileOverview \u003d fileOverviewInfo.string;\n                                 if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo !\u003d null) {\n                                     parser.addWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d fileOverviewInfo.token;\n                                 continue retry;\n                             case LICENSE:\n                             case PRESERVE:\n                                 ExtractionInfo preserveInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);\n                                 String preserve \u003d preserveInfo.string;\n                                 if (preserve.length() \u003e 0) {\n                                     if (fileLevelJsDocBuilder !\u003d null) {\n                                         fileLevelJsDocBuilder.append(preserve);\n                                     }\n                                 }\n                                 token \u003d preserveInfo.token;\n                                 continue retry;\n                             case ENUM:\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                 }\n                                 if (type \u003d\u003d null) {\n                                     type \u003d createJSTypeExpression(newStringNode(\"number\"));\n                                 }\n                                 if (!jsdocBuilder.recordEnumParameterType(type)) {\n                                     parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                 }\n                                 token \u003d eatTokensUntilEOL(token);\n                                 continue retry;\n                             case EXPORT:\n                                 if (!jsdocBuilder.recordExport()) {\n                                     parser.addWarning(\"msg.jsdoc.export\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case EXTENDS:\n                             case IMPLEMENTS:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 boolean matchingRc \u003d false;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     token \u003d next();\n                                     matchingRc \u003d true;\n                                 }\n                                 if (token \u003d\u003d JsDocToken.STRING) {\n                                     Node typeNode \u003d parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);\n                                     lineno \u003d stream.getLineno();\n                                     charno \u003d stream.getCharno();\n                                     typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                     if (typeNode !\u003d null \u0026\u0026 !matchingRc) {\n                                         typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                     }\n                                     type \u003d createJSTypeExpression(typeNode);\n                                     if (annotation \u003d\u003d Annotation.EXTENDS) {\n                                         if (!jsdocBuilder.recordBaseType(type)) {\n                                             parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                         }\n                                     } else {\n                                         Preconditions.checkState(annotation \u003d\u003d Annotation.IMPLEMENTS);\n                                         if (!jsdocBuilder.recordImplementedInterface(type)) {\n                                             parser.addWarning(\"msg.jsdoc.implements.duplicate\", lineno, charno);\n                                         }\n                                     }\n                                     token \u003d next();\n                                     if (matchingRc) {\n                                         if (token !\u003d JsDocToken.RC) {\n                                             parser.addWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                         }\n                                     } else if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOF \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                         parser.addWarning(\"msg.end.annotation.expected\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 } else {\n                                     parser.addWarning(\"msg.no.type.name\", lineno, charno);\n                                 }\n                                 token \u003d eatTokensUntilEOL(token);\n                                 continue retry;\n                             case HIDDEN:\n                                 if (!jsdocBuilder.recordHiddenness()) {\n                                     parser.addWarning(\"msg.jsdoc.hidden\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_ALIAS:\n                                 if (!jsdocBuilder.recordNoAlias()) {\n                                     parser.addWarning(\"msg.jsdoc.noalias\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_TYPE_CHECK:\n                                 if (!jsdocBuilder.recordNoTypeCheck()) {\n                                     parser.addWarning(\"msg.jsdoc.nocheck\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NOT_IMPLEMENTED:\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case INHERIT_DOC:\n                             case OVERRIDE:\n                                 if (!jsdocBuilder.recordOverride()) {\n                                     parser.addWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case THROWS:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                     if (type \u003d\u003d null) {\n                                         token \u003d eatTokensUntilEOL();\n                                         continue retry;\n                                     }\n                                 }\n                                 token \u003d current();\n                                 jsdocBuilder.recordThrowType(type);\n                                 ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                 String description \u003d descriptionInfo.string;\n                                 if (description.length() \u003e 0) {\n                                     jsdocBuilder.recordThrowDescription(type, description);\n                                 }\n                                 token \u003d descriptionInfo.token;\n                                 continue retry;\n                             case PARAM:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordParamTypeNode(token));\n                                     if (type \u003d\u003d null) {\n                                         token \u003d eatTokensUntilEOL();\n                                         continue retry;\n                                     }\n                                     skipEOLs();\n                                     token \u003d next();\n                                     lineno \u003d stream.getLineno();\n                                     charno \u003d stream.getCharno();\n                                 }\n                                 String name \u003d null;\n                                 boolean isBracketedParam \u003d JsDocToken.LB \u003d\u003d token;\n                                 if (isBracketedParam) {\n                                     token \u003d next();\n                                 }\n                                 if (JsDocToken.STRING !\u003d token) {\n                                     parser.addWarning(\"msg.missing.variable.name\", lineno, charno);\n                                 } else {\n                                     name \u003d stream.getString();\n                                     if (isBracketedParam) {\n                                         token \u003d next();\n                                         if (JsDocToken.RB !\u003d token) {\n                                             reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n+                                        } else if (type !\u003d null) {\n+                                            type \u003d JSTypeExpression.makeOptionalArg(type);\n                                         }\n                                     }\n                                     if (!jsdocBuilder.recordParameter(name, type)) {\n                                         if (jsdocBuilder.hasParameter(name)) {\n                                             parser.addWarning(\"msg.dup.variable.name\", name, lineno, charno);\n                                         } else {\n                                             parser.addWarning(\"msg.jsdoc.incompat.type\", name, lineno, charno);\n                                         }\n                                     }\n                                 }\n                                 if (name \u003d\u003d null) {\n                                     token \u003d eatTokensUntilEOL(token);\n                                     continue retry;\n                                 }\n                                 jsdocBuilder.markName(name, lineno, charno);\n                                 ExtractionInfo paramDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                 String paramDescription \u003d paramDescriptionInfo.string;\n                                 if (paramDescription.length() \u003e 0) {\n                                     jsdocBuilder.recordParameterDescription(name, paramDescription);\n                                 }\n                                 token \u003d paramDescriptionInfo.token;\n                                 continue retry;\n                             case PRESERVE_TRY:\n                                 if (!jsdocBuilder.recordPreserveTry()) {\n                                     parser.addWarning(\"msg.jsdoc.preservertry\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PRIVATE:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                                     parser.addWarning(\"msg.jsdoc.visibility.private\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PROTECTED:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                                     parser.addWarning(\"msg.jsdoc.visibility.protected\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PUBLIC:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                                     parser.addWarning(\"msg.jsdoc.visibility.public\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_SHADOW:\n                                 if (!jsdocBuilder.recordNoShadow()) {\n                                     parser.addWarning(\"msg.jsdoc.noshadow\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_SIDE_EFFECTS:\n                                 if (!jsdocBuilder.recordNoSideEffects()) {\n                                     parser.addWarning(\"msg.jsdoc.nosideeffects\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case IMPLICIT_CAST:\n                                 if (!jsdocBuilder.recordImplicitCast()) {\n                                     parser.addWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case SEE:\n                                 ExtractionInfo referenceInfo \u003d extractSingleLineBlock();\n                                 String reference \u003d referenceInfo.string;\n                                 if (reference.length() \u003d\u003d 0) {\n                                     parser.addWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno());\n                                 } else {\n                                     jsdocBuilder.addReference(reference);\n                                 }\n                                 token \u003d referenceInfo.token;\n                                 continue retry;\n                             case SUPPRESS:\n                                 token \u003d parseSuppressTag(next());\n                                 continue retry;\n                             case TEMPLATE:\n                                 ExtractionInfo templateInfo \u003d extractSingleLineBlock();\n                                 String templateTypeName \u003d templateInfo.string;\n                                 if (templateTypeName.length() \u003d\u003d 0) {\n                                     parser.addWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno());\n                                 } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {\n                                     parser.addWarning(\"msg.jsdoc.template.at.most.once\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d templateInfo.token;\n                                 continue retry;\n                             case VERSION:\n                                 ExtractionInfo versionInfo \u003d extractSingleLineBlock();\n                                 String version \u003d versionInfo.string;\n                                 if (version.length() \u003d\u003d 0) {\n                                     parser.addWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno());\n                                 } else {\n                                     if (!jsdocBuilder.recordVersion(version)) {\n                                         parser.addWarning(\"msg.jsdoc.extraversion\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d versionInfo.token;\n                                 continue retry;\n                             case DEFINE:\n                             case RETURN:\n                             case THIS:\n                             case TYPE:\n                             case TYPEDEF:\n                                 skipEOLs();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 token \u003d next();\n                                 Node typeNode \u003d parseAndRecordTypeNode(token, lineno, charno);\n                                 if (annotation \u003d\u003d Annotation.THIS) {\n                                     typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                     if (typeNode !\u003d null \u0026\u0026 token !\u003d JsDocToken.LC) {\n                                         typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                     }\n                                 }\n                                 type \u003d createJSTypeExpression(typeNode);\n                                 if (type \u003d\u003d null) {\n                                 } else {\n                                     switch(annotation) {\n                                         case DEFINE:\n                                             if (!isValidDefineType(typeNode)) {\n                                                 parser.addWarning(\"msg.jsdoc.define.badtype\", lineno, charno);\n                                             } else if (!jsdocBuilder.recordDefineType(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.define\", lineno, charno);\n                                             }\n                                             break;\n                                         case RETURN:\n                                             if (!jsdocBuilder.recordReturnType(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                                 break;\n                                             }\n                                             token \u003d current();\n                                             ExtractionInfo returnDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                             String returnDescription \u003d returnDescriptionInfo.string;\n                                             if (returnDescription.length() \u003e 0) {\n                                                 jsdocBuilder.recordReturnDescription(returnDescription);\n                                             }\n                                             token \u003d returnDescriptionInfo.token;\n                                             continue retry;\n                                         case THIS:\n                                             if (!jsdocBuilder.recordThisType(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                         case TYPE:\n                                             if (!jsdocBuilder.recordType(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                         case TYPEDEF:\n                                             if (!jsdocBuilder.recordTypedef(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                     }\n                                     token \u003d eatTokensUntilEOL();\n                                 }\n                                 continue retry;\n                         }\n                     }\n                 }\n                 break;\n             case EOC:\n                 if (hasParsedFileOverviewDocInfo()) {\n                     fileOverviewJSDocInfo \u003d retrieveAndResetParsedJSDocInfo();\n                 }\n                 return true;\n             case EOF:\n                 jsdocBuilder.build(null);\n                 parser.addWarning(\"msg.unexpected.eof\", stream.getLineno(), stream.getCharno());\n                 return false;\n             case EOL:\n                 if (state \u003d\u003d State.SEARCHING_NEWLINE) {\n                     state \u003d State.SEARCHING_ANNOTATION;\n                 }\n                 token \u003d next();\n                 continue retry;\n             default:\n                 if (token \u003d\u003d JsDocToken.STAR \u0026\u0026 state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                     token \u003d next();\n                     continue retry;\n                 } else {\n                     state \u003d State.SEARCHING_NEWLINE;\n                     token \u003d eatTokensUntilEOL();\n                     continue retry;\n                 }\n         }\n         token \u003d next();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "efd3c178e471df6a689c1a50fbd7c404e778bfaa": {
      "type": "Ybodychange",
      "commitMessage": "Better number printing.\nAdd flags for fine-grained warning controls.\nBetter type-declaration finding.\nAdded some missing externs.\nMarked externs that don\u0027t have side effects.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@10 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/13/09, 11:38 AM",
      "commitName": "efd3c178e471df6a689c1a50fbd7c404e778bfaa",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "commitDateOld": "11/3/09, 3:51 PM",
      "commitNameOld": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthorOld": "nicholas.j.santos@gmail.com",
      "daysBetweenCommits": 9.82,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "boolean parse() {\n    int lineno;\n    int charno;\n    JSTypeExpression type;\n    state \u003d State.SEARCHING_ANNOTATION;\n    JsDocToken token \u003d next();\n    ExtractionInfo blockInfo \u003d extractBlockComment(token);\n    token \u003d blockInfo.token;\n    if (blockInfo.string.length() \u003e 0) {\n        jsdocBuilder.recordBlockDescription(blockInfo.string);\n    }\n    retry: for (; ; ) {\n        switch(token) {\n            case ANNOTATION:\n                if (state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                    state \u003d State.SEARCHING_NEWLINE;\n                    lineno \u003d stream.getLineno();\n                    charno \u003d stream.getCharno();\n                    String annotationName \u003d stream.getString();\n                    Annotation annotation \u003d annotationNames.get(annotationName);\n                    if (annotation \u003d\u003d null) {\n                        parser.addWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno());\n                    } else {\n                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n                        switch(annotation) {\n                            case AUTHOR:\n                                ExtractionInfo authorInfo \u003d extractSingleLineBlock();\n                                String author \u003d authorInfo.string;\n                                if (author.length() \u003d\u003d 0) {\n                                    parser.addWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno());\n                                } else {\n                                    jsdocBuilder.addAuthor(author);\n                                }\n                                token \u003d authorInfo.token;\n                                continue retry;\n                            case CONSTANT:\n                                if (!jsdocBuilder.recordConstancy()) {\n                                    parser.addWarning(\"msg.jsdoc.const\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case CONSTRUCTOR:\n                                if (!jsdocBuilder.recordConstructor()) {\n                                    if (jsdocBuilder.isInterfaceRecorded()) {\n                                        parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case DEPRECATED:\n                                if (!jsdocBuilder.recordDeprecated()) {\n                                    parser.addWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno());\n                                }\n                                ExtractionInfo reasonInfo \u003d extractMultilineTextualBlock(token);\n                                String reason \u003d reasonInfo.string;\n                                if (reason.length() \u003e 0) {\n                                    jsdocBuilder.recordDeprecationReason(reason);\n                                }\n                                token \u003d reasonInfo.token;\n                                continue retry;\n                            case INTERFACE:\n                                if (!jsdocBuilder.recordInterface()) {\n                                    if (jsdocBuilder.isConstructorRecorded()) {\n                                        parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case DESC:\n                                if (jsdocBuilder.isDescriptionRecorded()) {\n                                    parser.addWarning(\"msg.jsdoc.desc.extra\", stream.getLineno(), stream.getCharno());\n                                    token \u003d eatTokensUntilEOL();\n                                    continue retry;\n                                } else {\n                                    ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                    String description \u003d descriptionInfo.string;\n                                    jsdocBuilder.recordDescription(description);\n                                    token \u003d descriptionInfo.token;\n                                    continue retry;\n                                }\n                            case FILE_OVERVIEW:\n                                ExtractionInfo fileOverviewInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.TRIM);\n                                String fileOverview \u003d fileOverviewInfo.string;\n                                if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo !\u003d null) {\n                                    parser.addWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d fileOverviewInfo.token;\n                                continue retry;\n                            case LICENSE:\n                            case PRESERVE:\n                                ExtractionInfo preserveInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);\n                                String preserve \u003d preserveInfo.string;\n                                if (preserve.length() \u003e 0) {\n                                    if (fileLevelJsDocBuilder !\u003d null) {\n                                        fileLevelJsDocBuilder.append(preserve);\n                                    }\n                                }\n                                token \u003d preserveInfo.token;\n                                continue retry;\n                            case ENUM:\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                }\n                                if (type \u003d\u003d null) {\n                                    type \u003d createJSTypeExpression(newStringNode(\"number\"));\n                                }\n                                if (!jsdocBuilder.recordEnumParameterType(type)) {\n                                    parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                }\n                                token \u003d eatTokensUntilEOL(token);\n                                continue retry;\n                            case EXPORT:\n                                if (!jsdocBuilder.recordExport()) {\n                                    parser.addWarning(\"msg.jsdoc.export\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case EXTENDS:\n                            case IMPLEMENTS:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                boolean matchingRc \u003d false;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    token \u003d next();\n                                    matchingRc \u003d true;\n                                }\n                                if (token \u003d\u003d JsDocToken.STRING) {\n                                    Node typeNode \u003d parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);\n                                    lineno \u003d stream.getLineno();\n                                    charno \u003d stream.getCharno();\n                                    typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                    if (typeNode !\u003d null \u0026\u0026 !matchingRc) {\n                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                    }\n                                    type \u003d createJSTypeExpression(typeNode);\n                                    if (annotation \u003d\u003d Annotation.EXTENDS) {\n                                        if (!jsdocBuilder.recordBaseType(type)) {\n                                            parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                        }\n                                    } else {\n                                        Preconditions.checkState(annotation \u003d\u003d Annotation.IMPLEMENTS);\n                                        if (!jsdocBuilder.recordImplementedInterface(type)) {\n                                            parser.addWarning(\"msg.jsdoc.implements.duplicate\", lineno, charno);\n                                        }\n                                    }\n                                    token \u003d next();\n                                    if (matchingRc) {\n                                        if (token !\u003d JsDocToken.RC) {\n                                            parser.addWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                        }\n                                    } else if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOF \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                        parser.addWarning(\"msg.end.annotation.expected\", stream.getLineno(), stream.getCharno());\n                                    }\n                                } else {\n                                    parser.addWarning(\"msg.no.type.name\", lineno, charno);\n                                }\n                                token \u003d eatTokensUntilEOL(token);\n                                continue retry;\n                            case HIDDEN:\n                                if (!jsdocBuilder.recordHiddenness()) {\n                                    parser.addWarning(\"msg.jsdoc.hidden\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_ALIAS:\n                                if (!jsdocBuilder.recordNoAlias()) {\n                                    parser.addWarning(\"msg.jsdoc.noalias\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_TYPE_CHECK:\n                                if (!jsdocBuilder.recordNoTypeCheck()) {\n                                    parser.addWarning(\"msg.jsdoc.nocheck\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NOT_IMPLEMENTED:\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case INHERIT_DOC:\n                            case OVERRIDE:\n                                if (!jsdocBuilder.recordOverride()) {\n                                    parser.addWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case THROWS:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                    if (type \u003d\u003d null) {\n                                        token \u003d eatTokensUntilEOL();\n                                        continue retry;\n                                    }\n                                }\n                                token \u003d current();\n                                jsdocBuilder.recordThrowType(type);\n                                ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                String description \u003d descriptionInfo.string;\n                                if (description.length() \u003e 0) {\n                                    jsdocBuilder.recordThrowDescription(type, description);\n                                }\n                                token \u003d descriptionInfo.token;\n                                continue retry;\n                            case PARAM:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordParamTypeNode(token));\n                                    if (type \u003d\u003d null) {\n                                        token \u003d eatTokensUntilEOL();\n                                        continue retry;\n                                    }\n                                    skipEOLs();\n                                    token \u003d next();\n                                    lineno \u003d stream.getLineno();\n                                    charno \u003d stream.getCharno();\n                                }\n                                String name \u003d null;\n                                boolean isBracketedParam \u003d JsDocToken.LB \u003d\u003d token;\n                                if (isBracketedParam) {\n                                    token \u003d next();\n                                }\n                                if (JsDocToken.STRING !\u003d token) {\n                                    parser.addWarning(\"msg.missing.variable.name\", lineno, charno);\n                                } else {\n                                    name \u003d stream.getString();\n                                    if (isBracketedParam) {\n                                        token \u003d next();\n                                        if (JsDocToken.RB !\u003d token) {\n                                            reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                                        }\n                                    }\n                                    if (!jsdocBuilder.recordParameter(name, type)) {\n                                        if (jsdocBuilder.hasParameter(name)) {\n                                            parser.addWarning(\"msg.dup.variable.name\", name, lineno, charno);\n                                        } else {\n                                            parser.addWarning(\"msg.jsdoc.incompat.type\", name, lineno, charno);\n                                        }\n                                    }\n                                }\n                                if (name \u003d\u003d null) {\n                                    token \u003d eatTokensUntilEOL(token);\n                                    continue retry;\n                                }\n                                jsdocBuilder.markName(name, lineno, charno);\n                                ExtractionInfo paramDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                String paramDescription \u003d paramDescriptionInfo.string;\n                                if (paramDescription.length() \u003e 0) {\n                                    jsdocBuilder.recordParameterDescription(name, paramDescription);\n                                }\n                                token \u003d paramDescriptionInfo.token;\n                                continue retry;\n                            case PRESERVE_TRY:\n                                if (!jsdocBuilder.recordPreserveTry()) {\n                                    parser.addWarning(\"msg.jsdoc.preservertry\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PRIVATE:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                                    parser.addWarning(\"msg.jsdoc.visibility.private\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PROTECTED:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                                    parser.addWarning(\"msg.jsdoc.visibility.protected\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PUBLIC:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                                    parser.addWarning(\"msg.jsdoc.visibility.public\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_SHADOW:\n                                if (!jsdocBuilder.recordNoShadow()) {\n                                    parser.addWarning(\"msg.jsdoc.noshadow\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_SIDE_EFFECTS:\n                                if (!jsdocBuilder.recordNoSideEffects()) {\n                                    parser.addWarning(\"msg.jsdoc.nosideeffects\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case IMPLICIT_CAST:\n                                if (!jsdocBuilder.recordImplicitCast()) {\n                                    parser.addWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case SEE:\n                                ExtractionInfo referenceInfo \u003d extractSingleLineBlock();\n                                String reference \u003d referenceInfo.string;\n                                if (reference.length() \u003d\u003d 0) {\n                                    parser.addWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno());\n                                } else {\n                                    jsdocBuilder.addReference(reference);\n                                }\n                                token \u003d referenceInfo.token;\n                                continue retry;\n                            case SUPPRESS:\n                                token \u003d parseSuppressTag(next());\n                                continue retry;\n                            case TEMPLATE:\n                                ExtractionInfo templateInfo \u003d extractSingleLineBlock();\n                                String templateTypeName \u003d templateInfo.string;\n                                if (templateTypeName.length() \u003d\u003d 0) {\n                                    parser.addWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno());\n                                } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {\n                                    parser.addWarning(\"msg.jsdoc.template.at.most.once\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d templateInfo.token;\n                                continue retry;\n                            case VERSION:\n                                ExtractionInfo versionInfo \u003d extractSingleLineBlock();\n                                String version \u003d versionInfo.string;\n                                if (version.length() \u003d\u003d 0) {\n                                    parser.addWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno());\n                                } else {\n                                    if (!jsdocBuilder.recordVersion(version)) {\n                                        parser.addWarning(\"msg.jsdoc.extraversion\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d versionInfo.token;\n                                continue retry;\n                            case DEFINE:\n                            case RETURN:\n                            case THIS:\n                            case TYPE:\n                            case TYPEDEF:\n                                skipEOLs();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                token \u003d next();\n                                Node typeNode \u003d parseAndRecordTypeNode(token, lineno, charno);\n                                if (annotation \u003d\u003d Annotation.THIS) {\n                                    typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                    if (typeNode !\u003d null \u0026\u0026 token !\u003d JsDocToken.LC) {\n                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                    }\n                                }\n                                type \u003d createJSTypeExpression(typeNode);\n                                if (type \u003d\u003d null) {\n                                } else {\n                                    switch(annotation) {\n                                        case DEFINE:\n                                            if (!isValidDefineType(typeNode)) {\n                                                parser.addWarning(\"msg.jsdoc.define.badtype\", lineno, charno);\n                                            } else if (!jsdocBuilder.recordDefineType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.define\", lineno, charno);\n                                            }\n                                            break;\n                                        case RETURN:\n                                            if (!jsdocBuilder.recordReturnType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                                break;\n                                            }\n                                            token \u003d current();\n                                            ExtractionInfo returnDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                            String returnDescription \u003d returnDescriptionInfo.string;\n                                            if (returnDescription.length() \u003e 0) {\n                                                jsdocBuilder.recordReturnDescription(returnDescription);\n                                            }\n                                            token \u003d returnDescriptionInfo.token;\n                                            continue retry;\n                                        case THIS:\n                                            if (!jsdocBuilder.recordThisType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                        case TYPE:\n                                            if (!jsdocBuilder.recordType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                        case TYPEDEF:\n                                            if (!jsdocBuilder.recordTypedef(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                    }\n                                    token \u003d eatTokensUntilEOL();\n                                }\n                                continue retry;\n                        }\n                    }\n                }\n                break;\n            case EOC:\n                if (hasParsedFileOverviewDocInfo()) {\n                    fileOverviewJSDocInfo \u003d retrieveAndResetParsedJSDocInfo();\n                }\n                return true;\n            case EOF:\n                jsdocBuilder.build(null);\n                parser.addWarning(\"msg.unexpected.eof\", stream.getLineno(), stream.getCharno());\n                return false;\n            case EOL:\n                if (state \u003d\u003d State.SEARCHING_NEWLINE) {\n                    state \u003d State.SEARCHING_ANNOTATION;\n                }\n                token \u003d next();\n                continue retry;\n            default:\n                if (token \u003d\u003d JsDocToken.STAR \u0026\u0026 state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                    token \u003d next();\n                    continue retry;\n                } else {\n                    state \u003d State.SEARCHING_NEWLINE;\n                    token \u003d eatTokensUntilEOL();\n                    continue retry;\n                }\n        }\n        token \u003d next();\n    }\n}",
      "path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
      "functionStartLine": 237,
      "functionName": "parse",
      "functionAnnotation": "",
      "functionDoc": "Parses a {@link JSDocInfo} object. This parsing method reads all tokens\nreturned by the {@link JsDocTokenStream#getJsDocToken()} method until the\n{@link JsDocToken#EOC} is returned.\n\n@return @code true} if JSDoc information was correctly parsed,\n    {@code false} otherwise\n",
      "diff": "@@ -1,428 +1,438 @@\n boolean parse() {\n     int lineno;\n     int charno;\n     JSTypeExpression type;\n     state \u003d State.SEARCHING_ANNOTATION;\n     JsDocToken token \u003d next();\n     ExtractionInfo blockInfo \u003d extractBlockComment(token);\n     token \u003d blockInfo.token;\n     if (blockInfo.string.length() \u003e 0) {\n         jsdocBuilder.recordBlockDescription(blockInfo.string);\n     }\n     retry: for (; ; ) {\n         switch(token) {\n             case ANNOTATION:\n                 if (state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                     state \u003d State.SEARCHING_NEWLINE;\n                     lineno \u003d stream.getLineno();\n                     charno \u003d stream.getCharno();\n                     String annotationName \u003d stream.getString();\n                     Annotation annotation \u003d annotationNames.get(annotationName);\n                     if (annotation \u003d\u003d null) {\n                         parser.addWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno());\n                     } else {\n                         jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n                         switch(annotation) {\n                             case AUTHOR:\n                                 ExtractionInfo authorInfo \u003d extractSingleLineBlock();\n                                 String author \u003d authorInfo.string;\n                                 if (author.length() \u003d\u003d 0) {\n                                     parser.addWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno());\n                                 } else {\n                                     jsdocBuilder.addAuthor(author);\n                                 }\n                                 token \u003d authorInfo.token;\n                                 continue retry;\n                             case CONSTANT:\n                                 if (!jsdocBuilder.recordConstancy()) {\n                                     parser.addWarning(\"msg.jsdoc.const\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case CONSTRUCTOR:\n                                 if (!jsdocBuilder.recordConstructor()) {\n                                     if (jsdocBuilder.isInterfaceRecorded()) {\n                                         parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                     } else {\n                                         parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case DEPRECATED:\n                                 if (!jsdocBuilder.recordDeprecated()) {\n                                     parser.addWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 ExtractionInfo reasonInfo \u003d extractMultilineTextualBlock(token);\n                                 String reason \u003d reasonInfo.string;\n                                 if (reason.length() \u003e 0) {\n                                     jsdocBuilder.recordDeprecationReason(reason);\n                                 }\n                                 token \u003d reasonInfo.token;\n                                 continue retry;\n                             case INTERFACE:\n                                 if (!jsdocBuilder.recordInterface()) {\n                                     if (jsdocBuilder.isConstructorRecorded()) {\n                                         parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                     } else {\n                                         parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case DESC:\n                                 if (jsdocBuilder.isDescriptionRecorded()) {\n                                     parser.addWarning(\"msg.jsdoc.desc.extra\", stream.getLineno(), stream.getCharno());\n                                     token \u003d eatTokensUntilEOL();\n                                     continue retry;\n                                 } else {\n                                     ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                     String description \u003d descriptionInfo.string;\n                                     jsdocBuilder.recordDescription(description);\n                                     token \u003d descriptionInfo.token;\n                                     continue retry;\n                                 }\n                             case FILE_OVERVIEW:\n                                 ExtractionInfo fileOverviewInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.TRIM);\n                                 String fileOverview \u003d fileOverviewInfo.string;\n                                 if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo !\u003d null) {\n                                     parser.addWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d fileOverviewInfo.token;\n                                 continue retry;\n                             case LICENSE:\n                             case PRESERVE:\n                                 ExtractionInfo preserveInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);\n                                 String preserve \u003d preserveInfo.string;\n                                 if (preserve.length() \u003e 0) {\n                                     if (fileLevelJsDocBuilder !\u003d null) {\n                                         fileLevelJsDocBuilder.append(preserve);\n                                     }\n                                 }\n                                 token \u003d preserveInfo.token;\n                                 continue retry;\n                             case ENUM:\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                 }\n                                 if (type \u003d\u003d null) {\n                                     type \u003d createJSTypeExpression(newStringNode(\"number\"));\n                                 }\n                                 if (!jsdocBuilder.recordEnumParameterType(type)) {\n                                     parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                 }\n                                 token \u003d eatTokensUntilEOL(token);\n                                 continue retry;\n                             case EXPORT:\n                                 if (!jsdocBuilder.recordExport()) {\n                                     parser.addWarning(\"msg.jsdoc.export\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case EXTENDS:\n                             case IMPLEMENTS:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 boolean matchingRc \u003d false;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     token \u003d next();\n                                     matchingRc \u003d true;\n                                 }\n                                 if (token \u003d\u003d JsDocToken.STRING) {\n                                     Node typeNode \u003d parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);\n                                     lineno \u003d stream.getLineno();\n                                     charno \u003d stream.getCharno();\n                                     typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                     if (typeNode !\u003d null \u0026\u0026 !matchingRc) {\n                                         typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                     }\n                                     type \u003d createJSTypeExpression(typeNode);\n                                     if (annotation \u003d\u003d Annotation.EXTENDS) {\n                                         if (!jsdocBuilder.recordBaseType(type)) {\n                                             parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                         }\n                                     } else {\n                                         Preconditions.checkState(annotation \u003d\u003d Annotation.IMPLEMENTS);\n                                         if (!jsdocBuilder.recordImplementedInterface(type)) {\n                                             parser.addWarning(\"msg.jsdoc.implements.duplicate\", lineno, charno);\n                                         }\n                                     }\n                                     token \u003d next();\n                                     if (matchingRc) {\n                                         if (token !\u003d JsDocToken.RC) {\n                                             parser.addWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                         }\n                                     } else if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOF \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                         parser.addWarning(\"msg.end.annotation.expected\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 } else {\n                                     parser.addWarning(\"msg.no.type.name\", lineno, charno);\n                                 }\n                                 token \u003d eatTokensUntilEOL(token);\n                                 continue retry;\n                             case HIDDEN:\n                                 if (!jsdocBuilder.recordHiddenness()) {\n                                     parser.addWarning(\"msg.jsdoc.hidden\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_ALIAS:\n                                 if (!jsdocBuilder.recordNoAlias()) {\n                                     parser.addWarning(\"msg.jsdoc.noalias\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_TYPE_CHECK:\n                                 if (!jsdocBuilder.recordNoTypeCheck()) {\n                                     parser.addWarning(\"msg.jsdoc.nocheck\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NOT_IMPLEMENTED:\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case INHERIT_DOC:\n                             case OVERRIDE:\n                                 if (!jsdocBuilder.recordOverride()) {\n                                     parser.addWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case THROWS:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                     if (type \u003d\u003d null) {\n                                         token \u003d eatTokensUntilEOL();\n                                         continue retry;\n                                     }\n                                 }\n                                 token \u003d current();\n                                 jsdocBuilder.recordThrowType(type);\n                                 ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                 String description \u003d descriptionInfo.string;\n                                 if (description.length() \u003e 0) {\n                                     jsdocBuilder.recordThrowDescription(type, description);\n                                 }\n                                 token \u003d descriptionInfo.token;\n                                 continue retry;\n                             case PARAM:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordParamTypeNode(token));\n                                     if (type \u003d\u003d null) {\n                                         token \u003d eatTokensUntilEOL();\n                                         continue retry;\n                                     }\n                                     skipEOLs();\n                                     token \u003d next();\n                                     lineno \u003d stream.getLineno();\n                                     charno \u003d stream.getCharno();\n                                 }\n                                 String name \u003d null;\n+                                boolean isBracketedParam \u003d JsDocToken.LB \u003d\u003d token;\n+                                if (isBracketedParam) {\n+                                    token \u003d next();\n+                                }\n                                 if (JsDocToken.STRING !\u003d token) {\n                                     parser.addWarning(\"msg.missing.variable.name\", lineno, charno);\n                                 } else {\n                                     name \u003d stream.getString();\n+                                    if (isBracketedParam) {\n+                                        token \u003d next();\n+                                        if (JsDocToken.RB !\u003d token) {\n+                                            reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n+                                        }\n+                                    }\n                                     if (!jsdocBuilder.recordParameter(name, type)) {\n                                         if (jsdocBuilder.hasParameter(name)) {\n                                             parser.addWarning(\"msg.dup.variable.name\", name, lineno, charno);\n                                         } else {\n                                             parser.addWarning(\"msg.jsdoc.incompat.type\", name, lineno, charno);\n                                         }\n                                     }\n                                 }\n                                 if (name \u003d\u003d null) {\n                                     token \u003d eatTokensUntilEOL(token);\n                                     continue retry;\n                                 }\n                                 jsdocBuilder.markName(name, lineno, charno);\n                                 ExtractionInfo paramDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                 String paramDescription \u003d paramDescriptionInfo.string;\n                                 if (paramDescription.length() \u003e 0) {\n                                     jsdocBuilder.recordParameterDescription(name, paramDescription);\n                                 }\n                                 token \u003d paramDescriptionInfo.token;\n                                 continue retry;\n                             case PRESERVE_TRY:\n                                 if (!jsdocBuilder.recordPreserveTry()) {\n                                     parser.addWarning(\"msg.jsdoc.preservertry\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PRIVATE:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                                     parser.addWarning(\"msg.jsdoc.visibility.private\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PROTECTED:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                                     parser.addWarning(\"msg.jsdoc.visibility.protected\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PUBLIC:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                                     parser.addWarning(\"msg.jsdoc.visibility.public\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_SHADOW:\n                                 if (!jsdocBuilder.recordNoShadow()) {\n                                     parser.addWarning(\"msg.jsdoc.noshadow\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_SIDE_EFFECTS:\n                                 if (!jsdocBuilder.recordNoSideEffects()) {\n                                     parser.addWarning(\"msg.jsdoc.nosideeffects\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case IMPLICIT_CAST:\n                                 if (!jsdocBuilder.recordImplicitCast()) {\n                                     parser.addWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case SEE:\n                                 ExtractionInfo referenceInfo \u003d extractSingleLineBlock();\n                                 String reference \u003d referenceInfo.string;\n                                 if (reference.length() \u003d\u003d 0) {\n                                     parser.addWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno());\n                                 } else {\n                                     jsdocBuilder.addReference(reference);\n                                 }\n                                 token \u003d referenceInfo.token;\n                                 continue retry;\n                             case SUPPRESS:\n                                 token \u003d parseSuppressTag(next());\n                                 continue retry;\n                             case TEMPLATE:\n                                 ExtractionInfo templateInfo \u003d extractSingleLineBlock();\n                                 String templateTypeName \u003d templateInfo.string;\n                                 if (templateTypeName.length() \u003d\u003d 0) {\n                                     parser.addWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno());\n                                 } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {\n                                     parser.addWarning(\"msg.jsdoc.template.at.most.once\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d templateInfo.token;\n                                 continue retry;\n                             case VERSION:\n                                 ExtractionInfo versionInfo \u003d extractSingleLineBlock();\n                                 String version \u003d versionInfo.string;\n                                 if (version.length() \u003d\u003d 0) {\n                                     parser.addWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno());\n                                 } else {\n                                     if (!jsdocBuilder.recordVersion(version)) {\n                                         parser.addWarning(\"msg.jsdoc.extraversion\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d versionInfo.token;\n                                 continue retry;\n                             case DEFINE:\n                             case RETURN:\n                             case THIS:\n                             case TYPE:\n                             case TYPEDEF:\n                                 skipEOLs();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 token \u003d next();\n                                 Node typeNode \u003d parseAndRecordTypeNode(token, lineno, charno);\n                                 if (annotation \u003d\u003d Annotation.THIS) {\n                                     typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                     if (typeNode !\u003d null \u0026\u0026 token !\u003d JsDocToken.LC) {\n                                         typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                     }\n                                 }\n                                 type \u003d createJSTypeExpression(typeNode);\n                                 if (type \u003d\u003d null) {\n                                 } else {\n                                     switch(annotation) {\n                                         case DEFINE:\n                                             if (!isValidDefineType(typeNode)) {\n                                                 parser.addWarning(\"msg.jsdoc.define.badtype\", lineno, charno);\n                                             } else if (!jsdocBuilder.recordDefineType(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.define\", lineno, charno);\n                                             }\n                                             break;\n                                         case RETURN:\n                                             if (!jsdocBuilder.recordReturnType(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                                 break;\n                                             }\n                                             token \u003d current();\n                                             ExtractionInfo returnDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                             String returnDescription \u003d returnDescriptionInfo.string;\n                                             if (returnDescription.length() \u003e 0) {\n                                                 jsdocBuilder.recordReturnDescription(returnDescription);\n                                             }\n                                             token \u003d returnDescriptionInfo.token;\n                                             continue retry;\n                                         case THIS:\n                                             if (!jsdocBuilder.recordThisType(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                         case TYPE:\n                                             if (!jsdocBuilder.recordType(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                         case TYPEDEF:\n                                             if (!jsdocBuilder.recordTypedef(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                     }\n                                     token \u003d eatTokensUntilEOL();\n                                 }\n                                 continue retry;\n                         }\n                     }\n                 }\n                 break;\n             case EOC:\n                 if (hasParsedFileOverviewDocInfo()) {\n                     fileOverviewJSDocInfo \u003d retrieveAndResetParsedJSDocInfo();\n                 }\n                 return true;\n             case EOF:\n                 jsdocBuilder.build(null);\n                 parser.addWarning(\"msg.unexpected.eof\", stream.getLineno(), stream.getCharno());\n                 return false;\n             case EOL:\n                 if (state \u003d\u003d State.SEARCHING_NEWLINE) {\n                     state \u003d State.SEARCHING_ANNOTATION;\n                 }\n                 token \u003d next();\n                 continue retry;\n             default:\n                 if (token \u003d\u003d JsDocToken.STAR \u0026\u0026 state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                     token \u003d next();\n                     continue retry;\n                 } else {\n                     state \u003d State.SEARCHING_NEWLINE;\n                     token \u003d eatTokensUntilEOL();\n                     continue retry;\n                 }\n         }\n         token \u003d next();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": {
      "type": "Yintroduced",
      "commitMessage": "Initial commit.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/3/09, 3:51 PM",
      "commitName": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "diff": "@@ -0,0 +1,428 @@\n+boolean parse() {\n+    int lineno;\n+    int charno;\n+    JSTypeExpression type;\n+    state \u003d State.SEARCHING_ANNOTATION;\n+    JsDocToken token \u003d next();\n+    ExtractionInfo blockInfo \u003d extractBlockComment(token);\n+    token \u003d blockInfo.token;\n+    if (blockInfo.string.length() \u003e 0) {\n+        jsdocBuilder.recordBlockDescription(blockInfo.string);\n+    }\n+    retry: for (; ; ) {\n+        switch(token) {\n+            case ANNOTATION:\n+                if (state \u003d\u003d State.SEARCHING_ANNOTATION) {\n+                    state \u003d State.SEARCHING_NEWLINE;\n+                    lineno \u003d stream.getLineno();\n+                    charno \u003d stream.getCharno();\n+                    String annotationName \u003d stream.getString();\n+                    Annotation annotation \u003d annotationNames.get(annotationName);\n+                    if (annotation \u003d\u003d null) {\n+                        parser.addWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno());\n+                    } else {\n+                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n+                        switch(annotation) {\n+                            case AUTHOR:\n+                                ExtractionInfo authorInfo \u003d extractSingleLineBlock();\n+                                String author \u003d authorInfo.string;\n+                                if (author.length() \u003d\u003d 0) {\n+                                    parser.addWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno());\n+                                } else {\n+                                    jsdocBuilder.addAuthor(author);\n+                                }\n+                                token \u003d authorInfo.token;\n+                                continue retry;\n+                            case CONSTANT:\n+                                if (!jsdocBuilder.recordConstancy()) {\n+                                    parser.addWarning(\"msg.jsdoc.const\", stream.getLineno(), stream.getCharno());\n+                                }\n+                                token \u003d eatTokensUntilEOL();\n+                                continue retry;\n+                            case CONSTRUCTOR:\n+                                if (!jsdocBuilder.recordConstructor()) {\n+                                    if (jsdocBuilder.isInterfaceRecorded()) {\n+                                        parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n+                                    } else {\n+                                        parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n+                                    }\n+                                }\n+                                token \u003d eatTokensUntilEOL();\n+                                continue retry;\n+                            case DEPRECATED:\n+                                if (!jsdocBuilder.recordDeprecated()) {\n+                                    parser.addWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno());\n+                                }\n+                                ExtractionInfo reasonInfo \u003d extractMultilineTextualBlock(token);\n+                                String reason \u003d reasonInfo.string;\n+                                if (reason.length() \u003e 0) {\n+                                    jsdocBuilder.recordDeprecationReason(reason);\n+                                }\n+                                token \u003d reasonInfo.token;\n+                                continue retry;\n+                            case INTERFACE:\n+                                if (!jsdocBuilder.recordInterface()) {\n+                                    if (jsdocBuilder.isConstructorRecorded()) {\n+                                        parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n+                                    } else {\n+                                        parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n+                                    }\n+                                }\n+                                token \u003d eatTokensUntilEOL();\n+                                continue retry;\n+                            case DESC:\n+                                if (jsdocBuilder.isDescriptionRecorded()) {\n+                                    parser.addWarning(\"msg.jsdoc.desc.extra\", stream.getLineno(), stream.getCharno());\n+                                    token \u003d eatTokensUntilEOL();\n+                                    continue retry;\n+                                } else {\n+                                    ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n+                                    String description \u003d descriptionInfo.string;\n+                                    jsdocBuilder.recordDescription(description);\n+                                    token \u003d descriptionInfo.token;\n+                                    continue retry;\n+                                }\n+                            case FILE_OVERVIEW:\n+                                ExtractionInfo fileOverviewInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.TRIM);\n+                                String fileOverview \u003d fileOverviewInfo.string;\n+                                if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo !\u003d null) {\n+                                    parser.addWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno());\n+                                }\n+                                token \u003d fileOverviewInfo.token;\n+                                continue retry;\n+                            case LICENSE:\n+                            case PRESERVE:\n+                                ExtractionInfo preserveInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);\n+                                String preserve \u003d preserveInfo.string;\n+                                if (preserve.length() \u003e 0) {\n+                                    if (fileLevelJsDocBuilder !\u003d null) {\n+                                        fileLevelJsDocBuilder.append(preserve);\n+                                    }\n+                                }\n+                                token \u003d preserveInfo.token;\n+                                continue retry;\n+                            case ENUM:\n+                                token \u003d next();\n+                                lineno \u003d stream.getLineno();\n+                                charno \u003d stream.getCharno();\n+                                type \u003d null;\n+                                if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOC) {\n+                                    type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n+                                }\n+                                if (type \u003d\u003d null) {\n+                                    type \u003d createJSTypeExpression(newStringNode(\"number\"));\n+                                }\n+                                if (!jsdocBuilder.recordEnumParameterType(type)) {\n+                                    parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n+                                }\n+                                token \u003d eatTokensUntilEOL(token);\n+                                continue retry;\n+                            case EXPORT:\n+                                if (!jsdocBuilder.recordExport()) {\n+                                    parser.addWarning(\"msg.jsdoc.export\", stream.getLineno(), stream.getCharno());\n+                                }\n+                                token \u003d eatTokensUntilEOL();\n+                                continue retry;\n+                            case EXTENDS:\n+                            case IMPLEMENTS:\n+                                skipEOLs();\n+                                token \u003d next();\n+                                lineno \u003d stream.getLineno();\n+                                charno \u003d stream.getCharno();\n+                                boolean matchingRc \u003d false;\n+                                if (token \u003d\u003d JsDocToken.LC) {\n+                                    token \u003d next();\n+                                    matchingRc \u003d true;\n+                                }\n+                                if (token \u003d\u003d JsDocToken.STRING) {\n+                                    Node typeNode \u003d parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);\n+                                    lineno \u003d stream.getLineno();\n+                                    charno \u003d stream.getCharno();\n+                                    typeNode \u003d wrapNode(Token.BANG, typeNode);\n+                                    if (typeNode !\u003d null \u0026\u0026 !matchingRc) {\n+                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n+                                    }\n+                                    type \u003d createJSTypeExpression(typeNode);\n+                                    if (annotation \u003d\u003d Annotation.EXTENDS) {\n+                                        if (!jsdocBuilder.recordBaseType(type)) {\n+                                            parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n+                                        }\n+                                    } else {\n+                                        Preconditions.checkState(annotation \u003d\u003d Annotation.IMPLEMENTS);\n+                                        if (!jsdocBuilder.recordImplementedInterface(type)) {\n+                                            parser.addWarning(\"msg.jsdoc.implements.duplicate\", lineno, charno);\n+                                        }\n+                                    }\n+                                    token \u003d next();\n+                                    if (matchingRc) {\n+                                        if (token !\u003d JsDocToken.RC) {\n+                                            parser.addWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n+                                        }\n+                                    } else if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOF \u0026\u0026 token !\u003d JsDocToken.EOC) {\n+                                        parser.addWarning(\"msg.end.annotation.expected\", stream.getLineno(), stream.getCharno());\n+                                    }\n+                                } else {\n+                                    parser.addWarning(\"msg.no.type.name\", lineno, charno);\n+                                }\n+                                token \u003d eatTokensUntilEOL(token);\n+                                continue retry;\n+                            case HIDDEN:\n+                                if (!jsdocBuilder.recordHiddenness()) {\n+                                    parser.addWarning(\"msg.jsdoc.hidden\", stream.getLineno(), stream.getCharno());\n+                                }\n+                                token \u003d eatTokensUntilEOL();\n+                                continue retry;\n+                            case NO_ALIAS:\n+                                if (!jsdocBuilder.recordNoAlias()) {\n+                                    parser.addWarning(\"msg.jsdoc.noalias\", stream.getLineno(), stream.getCharno());\n+                                }\n+                                token \u003d eatTokensUntilEOL();\n+                                continue retry;\n+                            case NO_TYPE_CHECK:\n+                                if (!jsdocBuilder.recordNoTypeCheck()) {\n+                                    parser.addWarning(\"msg.jsdoc.nocheck\", stream.getLineno(), stream.getCharno());\n+                                }\n+                                token \u003d eatTokensUntilEOL();\n+                                continue retry;\n+                            case NOT_IMPLEMENTED:\n+                                token \u003d eatTokensUntilEOL();\n+                                continue retry;\n+                            case INHERIT_DOC:\n+                            case OVERRIDE:\n+                                if (!jsdocBuilder.recordOverride()) {\n+                                    parser.addWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno());\n+                                }\n+                                token \u003d eatTokensUntilEOL();\n+                                continue retry;\n+                            case THROWS:\n+                                skipEOLs();\n+                                token \u003d next();\n+                                lineno \u003d stream.getLineno();\n+                                charno \u003d stream.getCharno();\n+                                type \u003d null;\n+                                if (token \u003d\u003d JsDocToken.LC) {\n+                                    type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n+                                    if (type \u003d\u003d null) {\n+                                        token \u003d eatTokensUntilEOL();\n+                                        continue retry;\n+                                    }\n+                                }\n+                                token \u003d current();\n+                                jsdocBuilder.recordThrowType(type);\n+                                ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n+                                String description \u003d descriptionInfo.string;\n+                                if (description.length() \u003e 0) {\n+                                    jsdocBuilder.recordThrowDescription(type, description);\n+                                }\n+                                token \u003d descriptionInfo.token;\n+                                continue retry;\n+                            case PARAM:\n+                                skipEOLs();\n+                                token \u003d next();\n+                                lineno \u003d stream.getLineno();\n+                                charno \u003d stream.getCharno();\n+                                type \u003d null;\n+                                if (token \u003d\u003d JsDocToken.LC) {\n+                                    type \u003d createJSTypeExpression(parseAndRecordParamTypeNode(token));\n+                                    if (type \u003d\u003d null) {\n+                                        token \u003d eatTokensUntilEOL();\n+                                        continue retry;\n+                                    }\n+                                    skipEOLs();\n+                                    token \u003d next();\n+                                    lineno \u003d stream.getLineno();\n+                                    charno \u003d stream.getCharno();\n+                                }\n+                                String name \u003d null;\n+                                if (JsDocToken.STRING !\u003d token) {\n+                                    parser.addWarning(\"msg.missing.variable.name\", lineno, charno);\n+                                } else {\n+                                    name \u003d stream.getString();\n+                                    if (!jsdocBuilder.recordParameter(name, type)) {\n+                                        if (jsdocBuilder.hasParameter(name)) {\n+                                            parser.addWarning(\"msg.dup.variable.name\", name, lineno, charno);\n+                                        } else {\n+                                            parser.addWarning(\"msg.jsdoc.incompat.type\", name, lineno, charno);\n+                                        }\n+                                    }\n+                                }\n+                                if (name \u003d\u003d null) {\n+                                    token \u003d eatTokensUntilEOL(token);\n+                                    continue retry;\n+                                }\n+                                jsdocBuilder.markName(name, lineno, charno);\n+                                ExtractionInfo paramDescriptionInfo \u003d extractMultilineTextualBlock(token);\n+                                String paramDescription \u003d paramDescriptionInfo.string;\n+                                if (paramDescription.length() \u003e 0) {\n+                                    jsdocBuilder.recordParameterDescription(name, paramDescription);\n+                                }\n+                                token \u003d paramDescriptionInfo.token;\n+                                continue retry;\n+                            case PRESERVE_TRY:\n+                                if (!jsdocBuilder.recordPreserveTry()) {\n+                                    parser.addWarning(\"msg.jsdoc.preservertry\", stream.getLineno(), stream.getCharno());\n+                                }\n+                                token \u003d eatTokensUntilEOL();\n+                                continue retry;\n+                            case PRIVATE:\n+                                if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n+                                    parser.addWarning(\"msg.jsdoc.visibility.private\", stream.getLineno(), stream.getCharno());\n+                                }\n+                                token \u003d eatTokensUntilEOL();\n+                                continue retry;\n+                            case PROTECTED:\n+                                if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n+                                    parser.addWarning(\"msg.jsdoc.visibility.protected\", stream.getLineno(), stream.getCharno());\n+                                }\n+                                token \u003d eatTokensUntilEOL();\n+                                continue retry;\n+                            case PUBLIC:\n+                                if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n+                                    parser.addWarning(\"msg.jsdoc.visibility.public\", stream.getLineno(), stream.getCharno());\n+                                }\n+                                token \u003d eatTokensUntilEOL();\n+                                continue retry;\n+                            case NO_SHADOW:\n+                                if (!jsdocBuilder.recordNoShadow()) {\n+                                    parser.addWarning(\"msg.jsdoc.noshadow\", stream.getLineno(), stream.getCharno());\n+                                }\n+                                token \u003d eatTokensUntilEOL();\n+                                continue retry;\n+                            case NO_SIDE_EFFECTS:\n+                                if (!jsdocBuilder.recordNoSideEffects()) {\n+                                    parser.addWarning(\"msg.jsdoc.nosideeffects\", stream.getLineno(), stream.getCharno());\n+                                }\n+                                token \u003d eatTokensUntilEOL();\n+                                continue retry;\n+                            case IMPLICIT_CAST:\n+                                if (!jsdocBuilder.recordImplicitCast()) {\n+                                    parser.addWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno());\n+                                }\n+                                token \u003d eatTokensUntilEOL();\n+                                continue retry;\n+                            case SEE:\n+                                ExtractionInfo referenceInfo \u003d extractSingleLineBlock();\n+                                String reference \u003d referenceInfo.string;\n+                                if (reference.length() \u003d\u003d 0) {\n+                                    parser.addWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno());\n+                                } else {\n+                                    jsdocBuilder.addReference(reference);\n+                                }\n+                                token \u003d referenceInfo.token;\n+                                continue retry;\n+                            case SUPPRESS:\n+                                token \u003d parseSuppressTag(next());\n+                                continue retry;\n+                            case TEMPLATE:\n+                                ExtractionInfo templateInfo \u003d extractSingleLineBlock();\n+                                String templateTypeName \u003d templateInfo.string;\n+                                if (templateTypeName.length() \u003d\u003d 0) {\n+                                    parser.addWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno());\n+                                } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {\n+                                    parser.addWarning(\"msg.jsdoc.template.at.most.once\", stream.getLineno(), stream.getCharno());\n+                                }\n+                                token \u003d templateInfo.token;\n+                                continue retry;\n+                            case VERSION:\n+                                ExtractionInfo versionInfo \u003d extractSingleLineBlock();\n+                                String version \u003d versionInfo.string;\n+                                if (version.length() \u003d\u003d 0) {\n+                                    parser.addWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno());\n+                                } else {\n+                                    if (!jsdocBuilder.recordVersion(version)) {\n+                                        parser.addWarning(\"msg.jsdoc.extraversion\", stream.getLineno(), stream.getCharno());\n+                                    }\n+                                }\n+                                token \u003d versionInfo.token;\n+                                continue retry;\n+                            case DEFINE:\n+                            case RETURN:\n+                            case THIS:\n+                            case TYPE:\n+                            case TYPEDEF:\n+                                skipEOLs();\n+                                lineno \u003d stream.getLineno();\n+                                charno \u003d stream.getCharno();\n+                                token \u003d next();\n+                                Node typeNode \u003d parseAndRecordTypeNode(token, lineno, charno);\n+                                if (annotation \u003d\u003d Annotation.THIS) {\n+                                    typeNode \u003d wrapNode(Token.BANG, typeNode);\n+                                    if (typeNode !\u003d null \u0026\u0026 token !\u003d JsDocToken.LC) {\n+                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n+                                    }\n+                                }\n+                                type \u003d createJSTypeExpression(typeNode);\n+                                if (type \u003d\u003d null) {\n+                                } else {\n+                                    switch(annotation) {\n+                                        case DEFINE:\n+                                            if (!isValidDefineType(typeNode)) {\n+                                                parser.addWarning(\"msg.jsdoc.define.badtype\", lineno, charno);\n+                                            } else if (!jsdocBuilder.recordDefineType(type)) {\n+                                                parser.addWarning(\"msg.jsdoc.define\", lineno, charno);\n+                                            }\n+                                            break;\n+                                        case RETURN:\n+                                            if (!jsdocBuilder.recordReturnType(type)) {\n+                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n+                                                break;\n+                                            }\n+                                            token \u003d current();\n+                                            ExtractionInfo returnDescriptionInfo \u003d extractMultilineTextualBlock(token);\n+                                            String returnDescription \u003d returnDescriptionInfo.string;\n+                                            if (returnDescription.length() \u003e 0) {\n+                                                jsdocBuilder.recordReturnDescription(returnDescription);\n+                                            }\n+                                            token \u003d returnDescriptionInfo.token;\n+                                            continue retry;\n+                                        case THIS:\n+                                            if (!jsdocBuilder.recordThisType(type)) {\n+                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n+                                            }\n+                                            break;\n+                                        case TYPE:\n+                                            if (!jsdocBuilder.recordType(type)) {\n+                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n+                                            }\n+                                            break;\n+                                        case TYPEDEF:\n+                                            if (!jsdocBuilder.recordTypedef(type)) {\n+                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n+                                            }\n+                                            break;\n+                                    }\n+                                    token \u003d eatTokensUntilEOL();\n+                                }\n+                                continue retry;\n+                        }\n+                    }\n+                }\n+                break;\n+            case EOC:\n+                if (hasParsedFileOverviewDocInfo()) {\n+                    fileOverviewJSDocInfo \u003d retrieveAndResetParsedJSDocInfo();\n+                }\n+                return true;\n+            case EOF:\n+                jsdocBuilder.build(null);\n+                parser.addWarning(\"msg.unexpected.eof\", stream.getLineno(), stream.getCharno());\n+                return false;\n+            case EOL:\n+                if (state \u003d\u003d State.SEARCHING_NEWLINE) {\n+                    state \u003d State.SEARCHING_ANNOTATION;\n+                }\n+                token \u003d next();\n+                continue retry;\n+            default:\n+                if (token \u003d\u003d JsDocToken.STAR \u0026\u0026 state \u003d\u003d State.SEARCHING_ANNOTATION) {\n+                    token \u003d next();\n+                    continue retry;\n+                } else {\n+                    state \u003d State.SEARCHING_NEWLINE;\n+                    token \u003d eatTokensUntilEOL();\n+                    continue retry;\n+                }\n+        }\n+        token \u003d next();\n+    }\n+}\n\\ No newline at end of file\n",
      "actualSource": "boolean parse() {\n    int lineno;\n    int charno;\n    JSTypeExpression type;\n    state \u003d State.SEARCHING_ANNOTATION;\n    JsDocToken token \u003d next();\n    ExtractionInfo blockInfo \u003d extractBlockComment(token);\n    token \u003d blockInfo.token;\n    if (blockInfo.string.length() \u003e 0) {\n        jsdocBuilder.recordBlockDescription(blockInfo.string);\n    }\n    retry: for (; ; ) {\n        switch(token) {\n            case ANNOTATION:\n                if (state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                    state \u003d State.SEARCHING_NEWLINE;\n                    lineno \u003d stream.getLineno();\n                    charno \u003d stream.getCharno();\n                    String annotationName \u003d stream.getString();\n                    Annotation annotation \u003d annotationNames.get(annotationName);\n                    if (annotation \u003d\u003d null) {\n                        parser.addWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno());\n                    } else {\n                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n                        switch(annotation) {\n                            case AUTHOR:\n                                ExtractionInfo authorInfo \u003d extractSingleLineBlock();\n                                String author \u003d authorInfo.string;\n                                if (author.length() \u003d\u003d 0) {\n                                    parser.addWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno());\n                                } else {\n                                    jsdocBuilder.addAuthor(author);\n                                }\n                                token \u003d authorInfo.token;\n                                continue retry;\n                            case CONSTANT:\n                                if (!jsdocBuilder.recordConstancy()) {\n                                    parser.addWarning(\"msg.jsdoc.const\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case CONSTRUCTOR:\n                                if (!jsdocBuilder.recordConstructor()) {\n                                    if (jsdocBuilder.isInterfaceRecorded()) {\n                                        parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case DEPRECATED:\n                                if (!jsdocBuilder.recordDeprecated()) {\n                                    parser.addWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno());\n                                }\n                                ExtractionInfo reasonInfo \u003d extractMultilineTextualBlock(token);\n                                String reason \u003d reasonInfo.string;\n                                if (reason.length() \u003e 0) {\n                                    jsdocBuilder.recordDeprecationReason(reason);\n                                }\n                                token \u003d reasonInfo.token;\n                                continue retry;\n                            case INTERFACE:\n                                if (!jsdocBuilder.recordInterface()) {\n                                    if (jsdocBuilder.isConstructorRecorded()) {\n                                        parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case DESC:\n                                if (jsdocBuilder.isDescriptionRecorded()) {\n                                    parser.addWarning(\"msg.jsdoc.desc.extra\", stream.getLineno(), stream.getCharno());\n                                    token \u003d eatTokensUntilEOL();\n                                    continue retry;\n                                } else {\n                                    ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                    String description \u003d descriptionInfo.string;\n                                    jsdocBuilder.recordDescription(description);\n                                    token \u003d descriptionInfo.token;\n                                    continue retry;\n                                }\n                            case FILE_OVERVIEW:\n                                ExtractionInfo fileOverviewInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.TRIM);\n                                String fileOverview \u003d fileOverviewInfo.string;\n                                if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo !\u003d null) {\n                                    parser.addWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d fileOverviewInfo.token;\n                                continue retry;\n                            case LICENSE:\n                            case PRESERVE:\n                                ExtractionInfo preserveInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);\n                                String preserve \u003d preserveInfo.string;\n                                if (preserve.length() \u003e 0) {\n                                    if (fileLevelJsDocBuilder !\u003d null) {\n                                        fileLevelJsDocBuilder.append(preserve);\n                                    }\n                                }\n                                token \u003d preserveInfo.token;\n                                continue retry;\n                            case ENUM:\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                }\n                                if (type \u003d\u003d null) {\n                                    type \u003d createJSTypeExpression(newStringNode(\"number\"));\n                                }\n                                if (!jsdocBuilder.recordEnumParameterType(type)) {\n                                    parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                }\n                                token \u003d eatTokensUntilEOL(token);\n                                continue retry;\n                            case EXPORT:\n                                if (!jsdocBuilder.recordExport()) {\n                                    parser.addWarning(\"msg.jsdoc.export\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case EXTENDS:\n                            case IMPLEMENTS:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                boolean matchingRc \u003d false;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    token \u003d next();\n                                    matchingRc \u003d true;\n                                }\n                                if (token \u003d\u003d JsDocToken.STRING) {\n                                    Node typeNode \u003d parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);\n                                    lineno \u003d stream.getLineno();\n                                    charno \u003d stream.getCharno();\n                                    typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                    if (typeNode !\u003d null \u0026\u0026 !matchingRc) {\n                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                    }\n                                    type \u003d createJSTypeExpression(typeNode);\n                                    if (annotation \u003d\u003d Annotation.EXTENDS) {\n                                        if (!jsdocBuilder.recordBaseType(type)) {\n                                            parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                        }\n                                    } else {\n                                        Preconditions.checkState(annotation \u003d\u003d Annotation.IMPLEMENTS);\n                                        if (!jsdocBuilder.recordImplementedInterface(type)) {\n                                            parser.addWarning(\"msg.jsdoc.implements.duplicate\", lineno, charno);\n                                        }\n                                    }\n                                    token \u003d next();\n                                    if (matchingRc) {\n                                        if (token !\u003d JsDocToken.RC) {\n                                            parser.addWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                        }\n                                    } else if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOF \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                        parser.addWarning(\"msg.end.annotation.expected\", stream.getLineno(), stream.getCharno());\n                                    }\n                                } else {\n                                    parser.addWarning(\"msg.no.type.name\", lineno, charno);\n                                }\n                                token \u003d eatTokensUntilEOL(token);\n                                continue retry;\n                            case HIDDEN:\n                                if (!jsdocBuilder.recordHiddenness()) {\n                                    parser.addWarning(\"msg.jsdoc.hidden\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_ALIAS:\n                                if (!jsdocBuilder.recordNoAlias()) {\n                                    parser.addWarning(\"msg.jsdoc.noalias\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_TYPE_CHECK:\n                                if (!jsdocBuilder.recordNoTypeCheck()) {\n                                    parser.addWarning(\"msg.jsdoc.nocheck\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NOT_IMPLEMENTED:\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case INHERIT_DOC:\n                            case OVERRIDE:\n                                if (!jsdocBuilder.recordOverride()) {\n                                    parser.addWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case THROWS:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                    if (type \u003d\u003d null) {\n                                        token \u003d eatTokensUntilEOL();\n                                        continue retry;\n                                    }\n                                }\n                                token \u003d current();\n                                jsdocBuilder.recordThrowType(type);\n                                ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                String description \u003d descriptionInfo.string;\n                                if (description.length() \u003e 0) {\n                                    jsdocBuilder.recordThrowDescription(type, description);\n                                }\n                                token \u003d descriptionInfo.token;\n                                continue retry;\n                            case PARAM:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordParamTypeNode(token));\n                                    if (type \u003d\u003d null) {\n                                        token \u003d eatTokensUntilEOL();\n                                        continue retry;\n                                    }\n                                    skipEOLs();\n                                    token \u003d next();\n                                    lineno \u003d stream.getLineno();\n                                    charno \u003d stream.getCharno();\n                                }\n                                String name \u003d null;\n                                if (JsDocToken.STRING !\u003d token) {\n                                    parser.addWarning(\"msg.missing.variable.name\", lineno, charno);\n                                } else {\n                                    name \u003d stream.getString();\n                                    if (!jsdocBuilder.recordParameter(name, type)) {\n                                        if (jsdocBuilder.hasParameter(name)) {\n                                            parser.addWarning(\"msg.dup.variable.name\", name, lineno, charno);\n                                        } else {\n                                            parser.addWarning(\"msg.jsdoc.incompat.type\", name, lineno, charno);\n                                        }\n                                    }\n                                }\n                                if (name \u003d\u003d null) {\n                                    token \u003d eatTokensUntilEOL(token);\n                                    continue retry;\n                                }\n                                jsdocBuilder.markName(name, lineno, charno);\n                                ExtractionInfo paramDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                String paramDescription \u003d paramDescriptionInfo.string;\n                                if (paramDescription.length() \u003e 0) {\n                                    jsdocBuilder.recordParameterDescription(name, paramDescription);\n                                }\n                                token \u003d paramDescriptionInfo.token;\n                                continue retry;\n                            case PRESERVE_TRY:\n                                if (!jsdocBuilder.recordPreserveTry()) {\n                                    parser.addWarning(\"msg.jsdoc.preservertry\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PRIVATE:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                                    parser.addWarning(\"msg.jsdoc.visibility.private\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PROTECTED:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                                    parser.addWarning(\"msg.jsdoc.visibility.protected\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PUBLIC:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                                    parser.addWarning(\"msg.jsdoc.visibility.public\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_SHADOW:\n                                if (!jsdocBuilder.recordNoShadow()) {\n                                    parser.addWarning(\"msg.jsdoc.noshadow\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_SIDE_EFFECTS:\n                                if (!jsdocBuilder.recordNoSideEffects()) {\n                                    parser.addWarning(\"msg.jsdoc.nosideeffects\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case IMPLICIT_CAST:\n                                if (!jsdocBuilder.recordImplicitCast()) {\n                                    parser.addWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case SEE:\n                                ExtractionInfo referenceInfo \u003d extractSingleLineBlock();\n                                String reference \u003d referenceInfo.string;\n                                if (reference.length() \u003d\u003d 0) {\n                                    parser.addWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno());\n                                } else {\n                                    jsdocBuilder.addReference(reference);\n                                }\n                                token \u003d referenceInfo.token;\n                                continue retry;\n                            case SUPPRESS:\n                                token \u003d parseSuppressTag(next());\n                                continue retry;\n                            case TEMPLATE:\n                                ExtractionInfo templateInfo \u003d extractSingleLineBlock();\n                                String templateTypeName \u003d templateInfo.string;\n                                if (templateTypeName.length() \u003d\u003d 0) {\n                                    parser.addWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno());\n                                } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {\n                                    parser.addWarning(\"msg.jsdoc.template.at.most.once\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d templateInfo.token;\n                                continue retry;\n                            case VERSION:\n                                ExtractionInfo versionInfo \u003d extractSingleLineBlock();\n                                String version \u003d versionInfo.string;\n                                if (version.length() \u003d\u003d 0) {\n                                    parser.addWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno());\n                                } else {\n                                    if (!jsdocBuilder.recordVersion(version)) {\n                                        parser.addWarning(\"msg.jsdoc.extraversion\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d versionInfo.token;\n                                continue retry;\n                            case DEFINE:\n                            case RETURN:\n                            case THIS:\n                            case TYPE:\n                            case TYPEDEF:\n                                skipEOLs();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                token \u003d next();\n                                Node typeNode \u003d parseAndRecordTypeNode(token, lineno, charno);\n                                if (annotation \u003d\u003d Annotation.THIS) {\n                                    typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                    if (typeNode !\u003d null \u0026\u0026 token !\u003d JsDocToken.LC) {\n                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                    }\n                                }\n                                type \u003d createJSTypeExpression(typeNode);\n                                if (type \u003d\u003d null) {\n                                } else {\n                                    switch(annotation) {\n                                        case DEFINE:\n                                            if (!isValidDefineType(typeNode)) {\n                                                parser.addWarning(\"msg.jsdoc.define.badtype\", lineno, charno);\n                                            } else if (!jsdocBuilder.recordDefineType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.define\", lineno, charno);\n                                            }\n                                            break;\n                                        case RETURN:\n                                            if (!jsdocBuilder.recordReturnType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                                break;\n                                            }\n                                            token \u003d current();\n                                            ExtractionInfo returnDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                            String returnDescription \u003d returnDescriptionInfo.string;\n                                            if (returnDescription.length() \u003e 0) {\n                                                jsdocBuilder.recordReturnDescription(returnDescription);\n                                            }\n                                            token \u003d returnDescriptionInfo.token;\n                                            continue retry;\n                                        case THIS:\n                                            if (!jsdocBuilder.recordThisType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                        case TYPE:\n                                            if (!jsdocBuilder.recordType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                        case TYPEDEF:\n                                            if (!jsdocBuilder.recordTypedef(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                    }\n                                    token \u003d eatTokensUntilEOL();\n                                }\n                                continue retry;\n                        }\n                    }\n                }\n                break;\n            case EOC:\n                if (hasParsedFileOverviewDocInfo()) {\n                    fileOverviewJSDocInfo \u003d retrieveAndResetParsedJSDocInfo();\n                }\n                return true;\n            case EOF:\n                jsdocBuilder.build(null);\n                parser.addWarning(\"msg.unexpected.eof\", stream.getLineno(), stream.getCharno());\n                return false;\n            case EOL:\n                if (state \u003d\u003d State.SEARCHING_NEWLINE) {\n                    state \u003d State.SEARCHING_ANNOTATION;\n                }\n                token \u003d next();\n                continue retry;\n            default:\n                if (token \u003d\u003d JsDocToken.STAR \u0026\u0026 state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                    token \u003d next();\n                    continue retry;\n                } else {\n                    state \u003d State.SEARCHING_NEWLINE;\n                    token \u003d eatTokensUntilEOL();\n                    continue retry;\n                }\n        }\n        token \u003d next();\n    }\n}",
      "path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
      "functionStartLine": 237,
      "functionName": "parse",
      "functionAnnotation": "",
      "functionDoc": "Parses a {@link JSDocInfo} object. This parsing method reads all tokens\nreturned by the {@link JsDocTokenStream#getJsDocToken()} method until the\n{@link JsDocToken#EOC} is returned.\n\n@return @code true} if JSDoc information was correctly parsed,\n    {@code false} otherwise\n"
    }
  }
}