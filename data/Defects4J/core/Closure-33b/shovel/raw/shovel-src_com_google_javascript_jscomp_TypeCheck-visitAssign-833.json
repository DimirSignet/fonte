{
  "origin": "codeshovel",
  "repositoryName": "Closure-33b",
  "repositoryPath": "/tmp/Closure-33b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "TypeCheck.java",
  "functionName": "visitAssign",
  "functionId": "visitAssign___t-NodeTraversal__assign-Node",
  "sourceFilePath": "src/com/google/javascript/jscomp/TypeCheck.java",
  "functionAnnotation": "",
  "functionDoc": "Visits an assignment \u003ccode\u003elvalue \u003d rvalue\u003c/code\u003e. If the\n\u003ccode\u003elvalue\u003c/code\u003e is a prototype modification, we change the schema\nof the object type it is referring to.\n\n@param t the traversal\n@param assign the assign node\n(\u003ccode\u003eassign.isAssign()\u003c/code\u003e is an implicit invariant)\n",
  "functionStartLine": 833,
  "functionEndLine": 955,
  "numCommitsSeen": 71,
  "timeTaken": 6075,
  "changeHistory": [
    "f1be9f1d6bad1a138a4db2ca50036737a370095d",
    "b742849cc99956b4b2d89eda4d9bf2eac5429e95",
    "ec324a9bb23eb78c76f537f4c4170ba88d542f1c",
    "9614c7c0ffe2418359fe91be2a0e61400142237d",
    "bd9c7b620384fe5a98772729001ed56304459bc6",
    "01d1238a2a577d8988a72c29304a3283ca05a29a",
    "fc0798047ad3aac58a54ea65f9f1c8857745419f",
    "c764a46abf211d4677fadc33f7d466e5b14fa088",
    "a2d8936fae3eb0e3873c7f7c0233344c81436404",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3"
  ],
  "changeHistoryShort": {
    "f1be9f1d6bad1a138a4db2ca50036737a370095d": "Ybodychange",
    "b742849cc99956b4b2d89eda4d9bf2eac5429e95": "Ybodychange",
    "ec324a9bb23eb78c76f537f4c4170ba88d542f1c": "Ymultichange(Ybodychange,Ydocchange)",
    "9614c7c0ffe2418359fe91be2a0e61400142237d": "Ybodychange",
    "bd9c7b620384fe5a98772729001ed56304459bc6": "Ybodychange",
    "01d1238a2a577d8988a72c29304a3283ca05a29a": "Ybodychange",
    "fc0798047ad3aac58a54ea65f9f1c8857745419f": "Ybodychange",
    "c764a46abf211d4677fadc33f7d466e5b14fa088": "Ybodychange",
    "a2d8936fae3eb0e3873c7f7c0233344c81436404": "Ybodychange",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "f1be9f1d6bad1a138a4db2ca50036737a370095d": {
      "type": "Ybodychange",
      "commitMessage": "\nFix a nasty bug where properties on one prototype were leaking onto\nunrelated prototypes\n\nR\u003dacleung\nDELTA\u003d84  (65 added, 1 deleted, 18 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d4450\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1855 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "3/29/12, 7:42 PM",
      "commitName": "f1be9f1d6bad1a138a4db2ca50036737a370095d",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "3/12/12, 1:45 PM",
      "commitNameOld": "b742849cc99956b4b2d89eda4d9bf2eac5429e95",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 17.25,
      "commitsBetweenForRepo": 22,
      "commitsBetweenForFile": 1,
      "actualSource": "private void visitAssign(NodeTraversal t, Node assign) {\n    JSDocInfo info \u003d assign.getJSDocInfo();\n    Node lvalue \u003d assign.getFirstChild();\n    Node rvalue \u003d assign.getLastChild();\n    if (lvalue.isGetProp()) {\n        Node object \u003d lvalue.getFirstChild();\n        JSType objectJsType \u003d getJSType(object);\n        String property \u003d lvalue.getLastChild().getString();\n        if (object.isGetProp()) {\n            JSType jsType \u003d getJSType(object.getFirstChild());\n            if (jsType.isInterface() \u0026\u0026 object.getLastChild().getString().equals(\"prototype\")) {\n                visitInterfaceGetprop(t, assign, object, property, lvalue, rvalue);\n            }\n        }\n        checkEnumAlias(t, info, rvalue);\n        if (property.equals(\"prototype\")) {\n            if (objectJsType !\u003d null \u0026\u0026 objectJsType.isFunctionType()) {\n                FunctionType functionType \u003d objectJsType.toMaybeFunctionType();\n                if (functionType.isConstructor()) {\n                    JSType rvalueType \u003d rvalue.getJSType();\n                    validator.expectObject(t, rvalue, rvalueType, OVERRIDING_PROTOTYPE_WITH_NON_OBJECT);\n                    return;\n                }\n            }\n        }\n        if (object.isGetProp()) {\n            Node object2 \u003d object.getFirstChild();\n            String property2 \u003d NodeUtil.getStringValue(object.getLastChild());\n            if (\"prototype\".equals(property2)) {\n                JSType jsType \u003d getJSType(object2);\n                if (jsType.isFunctionType()) {\n                    FunctionType functionType \u003d jsType.toMaybeFunctionType();\n                    if (functionType.isConstructor() || functionType.isInterface()) {\n                        checkDeclaredPropertyInheritance(t, assign, functionType, property, info, getJSType(rvalue));\n                    }\n                }\n            }\n        }\n        ObjectType type \u003d ObjectType.cast(objectJsType.restrictByNotNullOrUndefined());\n        if (type !\u003d null) {\n            if (type.hasProperty(property) \u0026\u0026 !type.isPropertyTypeInferred(property) \u0026\u0026 !propertyIsImplicitCast(type, property)) {\n                JSType expectedType \u003d type.getPropertyType(property);\n                if (!expectedType.isUnknownType()) {\n                    validator.expectCanAssignToPropertyOf(t, assign, getJSType(rvalue), expectedType, object, property);\n                    return;\n                }\n            }\n        }\n    }\n    JSType leftType \u003d getJSType(lvalue);\n    if (lvalue.isQualifiedName()) {\n        JSType rvalueType \u003d getJSType(assign.getLastChild());\n        Var var \u003d t.getScope().getVar(lvalue.getQualifiedName());\n        if (var !\u003d null) {\n            if (var.isTypeInferred()) {\n                return;\n            }\n            if (NodeUtil.getRootOfQualifiedName(lvalue).isThis() \u0026\u0026 t.getScope() !\u003d var.getScope()) {\n                return;\n            }\n            if (var.getType() !\u003d null) {\n                leftType \u003d var.getType();\n            }\n        }\n    }\n    Node rightChild \u003d assign.getLastChild();\n    JSType rightType \u003d getJSType(rightChild);\n    if (validator.expectCanAssignTo(t, assign, rightType, leftType, \"assignment\")) {\n        ensureTyped(t, assign, rightType);\n    } else {\n        ensureTyped(t, assign);\n    }\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 833,
      "functionName": "visitAssign",
      "functionAnnotation": "",
      "functionDoc": "Visits an assignment \u003ccode\u003elvalue \u003d rvalue\u003c/code\u003e. If the\n\u003ccode\u003elvalue\u003c/code\u003e is a prototype modification, we change the schema\nof the object type it is referring to.\n\n@param t the traversal\n@param assign the assign node\n(\u003ccode\u003eassign.isAssign()\u003c/code\u003e is an implicit invariant)\n",
      "diff": "@@ -1,67 +1,73 @@\n private void visitAssign(NodeTraversal t, Node assign) {\n     JSDocInfo info \u003d assign.getJSDocInfo();\n     Node lvalue \u003d assign.getFirstChild();\n     Node rvalue \u003d assign.getLastChild();\n     if (lvalue.isGetProp()) {\n         Node object \u003d lvalue.getFirstChild();\n         JSType objectJsType \u003d getJSType(object);\n         String property \u003d lvalue.getLastChild().getString();\n         if (object.isGetProp()) {\n             JSType jsType \u003d getJSType(object.getFirstChild());\n             if (jsType.isInterface() \u0026\u0026 object.getLastChild().getString().equals(\"prototype\")) {\n                 visitInterfaceGetprop(t, assign, object, property, lvalue, rvalue);\n             }\n         }\n         checkEnumAlias(t, info, rvalue);\n         if (property.equals(\"prototype\")) {\n             if (objectJsType !\u003d null \u0026\u0026 objectJsType.isFunctionType()) {\n                 FunctionType functionType \u003d objectJsType.toMaybeFunctionType();\n                 if (functionType.isConstructor()) {\n                     JSType rvalueType \u003d rvalue.getJSType();\n                     validator.expectObject(t, rvalue, rvalueType, OVERRIDING_PROTOTYPE_WITH_NON_OBJECT);\n                     return;\n                 }\n             }\n         }\n         if (object.isGetProp()) {\n             Node object2 \u003d object.getFirstChild();\n             String property2 \u003d NodeUtil.getStringValue(object.getLastChild());\n             if (\"prototype\".equals(property2)) {\n                 JSType jsType \u003d getJSType(object2);\n                 if (jsType.isFunctionType()) {\n                     FunctionType functionType \u003d jsType.toMaybeFunctionType();\n                     if (functionType.isConstructor() || functionType.isInterface()) {\n                         checkDeclaredPropertyInheritance(t, assign, functionType, property, info, getJSType(rvalue));\n                     }\n                 }\n             }\n         }\n         ObjectType type \u003d ObjectType.cast(objectJsType.restrictByNotNullOrUndefined());\n         if (type !\u003d null) {\n             if (type.hasProperty(property) \u0026\u0026 !type.isPropertyTypeInferred(property) \u0026\u0026 !propertyIsImplicitCast(type, property)) {\n-                validator.expectCanAssignToPropertyOf(t, assign, getJSType(rvalue), type.getPropertyType(property), object, property);\n-                return;\n+                JSType expectedType \u003d type.getPropertyType(property);\n+                if (!expectedType.isUnknownType()) {\n+                    validator.expectCanAssignToPropertyOf(t, assign, getJSType(rvalue), expectedType, object, property);\n+                    return;\n+                }\n             }\n         }\n     }\n     JSType leftType \u003d getJSType(lvalue);\n     if (lvalue.isQualifiedName()) {\n         JSType rvalueType \u003d getJSType(assign.getLastChild());\n         Var var \u003d t.getScope().getVar(lvalue.getQualifiedName());\n         if (var !\u003d null) {\n             if (var.isTypeInferred()) {\n                 return;\n             }\n+            if (NodeUtil.getRootOfQualifiedName(lvalue).isThis() \u0026\u0026 t.getScope() !\u003d var.getScope()) {\n+                return;\n+            }\n             if (var.getType() !\u003d null) {\n                 leftType \u003d var.getType();\n             }\n         }\n     }\n     Node rightChild \u003d assign.getLastChild();\n     JSType rightType \u003d getJSType(rightChild);\n     if (validator.expectCanAssignTo(t, assign, rightType, leftType, \"assignment\")) {\n         ensureTyped(t, assign, rightType);\n     } else {\n         ensureTyped(t, assign);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b742849cc99956b4b2d89eda4d9bf2eac5429e95": {
      "type": "Ybodychange",
      "commitMessage": "\nSimplify property checks\n\n\nTested:\nyes\n\nR\u003djohnlenz\nDELTA\u003d424  (268 added, 55 deleted, 101 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d4352\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1829 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "3/12/12, 1:45 PM",
      "commitName": "b742849cc99956b4b2d89eda4d9bf2eac5429e95",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "2/14/12, 3:43 PM",
      "commitNameOld": "ae9d464f4f9dc9abcf16e946f3116df2d9ca66b2",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 26.88,
      "commitsBetweenForRepo": 42,
      "commitsBetweenForFile": 1,
      "actualSource": "private void visitAssign(NodeTraversal t, Node assign) {\n    JSDocInfo info \u003d assign.getJSDocInfo();\n    Node lvalue \u003d assign.getFirstChild();\n    Node rvalue \u003d assign.getLastChild();\n    if (lvalue.isGetProp()) {\n        Node object \u003d lvalue.getFirstChild();\n        JSType objectJsType \u003d getJSType(object);\n        String property \u003d lvalue.getLastChild().getString();\n        if (object.isGetProp()) {\n            JSType jsType \u003d getJSType(object.getFirstChild());\n            if (jsType.isInterface() \u0026\u0026 object.getLastChild().getString().equals(\"prototype\")) {\n                visitInterfaceGetprop(t, assign, object, property, lvalue, rvalue);\n            }\n        }\n        checkEnumAlias(t, info, rvalue);\n        if (property.equals(\"prototype\")) {\n            if (objectJsType !\u003d null \u0026\u0026 objectJsType.isFunctionType()) {\n                FunctionType functionType \u003d objectJsType.toMaybeFunctionType();\n                if (functionType.isConstructor()) {\n                    JSType rvalueType \u003d rvalue.getJSType();\n                    validator.expectObject(t, rvalue, rvalueType, OVERRIDING_PROTOTYPE_WITH_NON_OBJECT);\n                    return;\n                }\n            }\n        }\n        if (object.isGetProp()) {\n            Node object2 \u003d object.getFirstChild();\n            String property2 \u003d NodeUtil.getStringValue(object.getLastChild());\n            if (\"prototype\".equals(property2)) {\n                JSType jsType \u003d getJSType(object2);\n                if (jsType.isFunctionType()) {\n                    FunctionType functionType \u003d jsType.toMaybeFunctionType();\n                    if (functionType.isConstructor() || functionType.isInterface()) {\n                        checkDeclaredPropertyInheritance(t, assign, functionType, property, info, getJSType(rvalue));\n                    }\n                }\n            }\n        }\n        ObjectType type \u003d ObjectType.cast(objectJsType.restrictByNotNullOrUndefined());\n        if (type !\u003d null) {\n            if (type.hasProperty(property) \u0026\u0026 !type.isPropertyTypeInferred(property) \u0026\u0026 !propertyIsImplicitCast(type, property)) {\n                validator.expectCanAssignToPropertyOf(t, assign, getJSType(rvalue), type.getPropertyType(property), object, property);\n                return;\n            }\n        }\n    }\n    JSType leftType \u003d getJSType(lvalue);\n    if (lvalue.isQualifiedName()) {\n        JSType rvalueType \u003d getJSType(assign.getLastChild());\n        Var var \u003d t.getScope().getVar(lvalue.getQualifiedName());\n        if (var !\u003d null) {\n            if (var.isTypeInferred()) {\n                return;\n            }\n            if (var.getType() !\u003d null) {\n                leftType \u003d var.getType();\n            }\n        }\n    }\n    Node rightChild \u003d assign.getLastChild();\n    JSType rightType \u003d getJSType(rightChild);\n    if (validator.expectCanAssignTo(t, assign, rightType, leftType, \"assignment\")) {\n        ensureTyped(t, assign, rightType);\n    } else {\n        ensureTyped(t, assign);\n    }\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 833,
      "functionName": "visitAssign",
      "functionAnnotation": "",
      "functionDoc": "Visits an assignment \u003ccode\u003elvalue \u003d rvalue\u003c/code\u003e. If the\n\u003ccode\u003elvalue\u003c/code\u003e is a prototype modification, we change the schema\nof the object type it is referring to.\n\n@param t the traversal\n@param assign the assign node\n(\u003ccode\u003eassign.isAssign()\u003c/code\u003e is an implicit invariant)\n",
      "diff": "@@ -1,70 +1,67 @@\n private void visitAssign(NodeTraversal t, Node assign) {\n     JSDocInfo info \u003d assign.getJSDocInfo();\n     Node lvalue \u003d assign.getFirstChild();\n     Node rvalue \u003d assign.getLastChild();\n     if (lvalue.isGetProp()) {\n         Node object \u003d lvalue.getFirstChild();\n         JSType objectJsType \u003d getJSType(object);\n         String property \u003d lvalue.getLastChild().getString();\n         if (object.isGetProp()) {\n             JSType jsType \u003d getJSType(object.getFirstChild());\n             if (jsType.isInterface() \u0026\u0026 object.getLastChild().getString().equals(\"prototype\")) {\n                 visitInterfaceGetprop(t, assign, object, property, lvalue, rvalue);\n             }\n         }\n-        if (info !\u003d null \u0026\u0026 info.hasType()) {\n-            visitAnnotatedAssignGetprop(t, assign, info.getType().evaluate(t.getScope(), typeRegistry), object, property, rvalue);\n-            return;\n-        }\n         checkEnumAlias(t, info, rvalue);\n         if (property.equals(\"prototype\")) {\n             if (objectJsType !\u003d null \u0026\u0026 objectJsType.isFunctionType()) {\n                 FunctionType functionType \u003d objectJsType.toMaybeFunctionType();\n                 if (functionType.isConstructor()) {\n                     JSType rvalueType \u003d rvalue.getJSType();\n                     validator.expectObject(t, rvalue, rvalueType, OVERRIDING_PROTOTYPE_WITH_NON_OBJECT);\n+                    return;\n                 }\n-            } else {\n             }\n-            return;\n         }\n         if (object.isGetProp()) {\n             Node object2 \u003d object.getFirstChild();\n             String property2 \u003d NodeUtil.getStringValue(object.getLastChild());\n             if (\"prototype\".equals(property2)) {\n                 JSType jsType \u003d getJSType(object2);\n                 if (jsType.isFunctionType()) {\n                     FunctionType functionType \u003d jsType.toMaybeFunctionType();\n                     if (functionType.isConstructor() || functionType.isInterface()) {\n                         checkDeclaredPropertyInheritance(t, assign, functionType, property, info, getJSType(rvalue));\n                     }\n-                } else {\n                 }\n-                return;\n             }\n         }\n         ObjectType type \u003d ObjectType.cast(objectJsType.restrictByNotNullOrUndefined());\n         if (type !\u003d null) {\n             if (type.hasProperty(property) \u0026\u0026 !type.isPropertyTypeInferred(property) \u0026\u0026 !propertyIsImplicitCast(type, property)) {\n                 validator.expectCanAssignToPropertyOf(t, assign, getJSType(rvalue), type.getPropertyType(property), object, property);\n-            }\n-            return;\n-        }\n-    } else if (lvalue.isName()) {\n-        JSType rvalueType \u003d getJSType(assign.getLastChild());\n-        Var var \u003d t.getScope().getVar(lvalue.getString());\n-        if (var !\u003d null) {\n-            if (var.isTypeInferred()) {\n                 return;\n             }\n         }\n     }\n     JSType leftType \u003d getJSType(lvalue);\n+    if (lvalue.isQualifiedName()) {\n+        JSType rvalueType \u003d getJSType(assign.getLastChild());\n+        Var var \u003d t.getScope().getVar(lvalue.getQualifiedName());\n+        if (var !\u003d null) {\n+            if (var.isTypeInferred()) {\n+                return;\n+            }\n+            if (var.getType() !\u003d null) {\n+                leftType \u003d var.getType();\n+            }\n+        }\n+    }\n     Node rightChild \u003d assign.getLastChild();\n     JSType rightType \u003d getJSType(rightChild);\n     if (validator.expectCanAssignTo(t, assign, rightType, leftType, \"assignment\")) {\n         ensureTyped(t, assign, rightType);\n     } else {\n         ensureTyped(t, assign);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ec324a9bb23eb78c76f537f4c4170ba88d542f1c": {
      "type": "Ymultichange(Ybodychange,Ydocchange)",
      "commitMessage": "\nReplace the bulk of the Node.getType() \u003d\u003d Token.XXX calls with\nNode.isXXX calls.\n\nR\u003dnicksantos\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3677\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1582 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/10/11, 8:36 AM",
      "commitName": "ec324a9bb23eb78c76f537f4c4170ba88d542f1c",
      "commitAuthor": "johnlenz@google.com",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "\nReplace the bulk of the Node.getType() \u003d\u003d Token.XXX calls with\nNode.isXXX calls.\n\nR\u003dnicksantos\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3677\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1582 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "11/10/11, 8:36 AM",
          "commitName": "ec324a9bb23eb78c76f537f4c4170ba88d542f1c",
          "commitAuthor": "johnlenz@google.com",
          "commitDateOld": "11/8/11, 12:25 PM",
          "commitNameOld": "9d8201624c22636577d47a40aa03de44363b695b",
          "commitAuthorOld": "johnlenz@google.com",
          "daysBetweenCommits": 1.84,
          "commitsBetweenForRepo": 11,
          "commitsBetweenForFile": 1,
          "actualSource": "private void visitAssign(NodeTraversal t, Node assign) {\n    JSDocInfo info \u003d assign.getJSDocInfo();\n    Node lvalue \u003d assign.getFirstChild();\n    Node rvalue \u003d assign.getLastChild();\n    if (lvalue.isGetProp()) {\n        Node object \u003d lvalue.getFirstChild();\n        JSType objectJsType \u003d getJSType(object);\n        String property \u003d lvalue.getLastChild().getString();\n        if (object.isGetProp()) {\n            JSType jsType \u003d getJSType(object.getFirstChild());\n            if (jsType.isInterface() \u0026\u0026 object.getLastChild().getString().equals(\"prototype\")) {\n                visitInterfaceGetprop(t, assign, object, property, lvalue, rvalue);\n            }\n        }\n        if (info !\u003d null \u0026\u0026 info.hasType()) {\n            visitAnnotatedAssignGetprop(t, assign, info.getType().evaluate(t.getScope(), typeRegistry), object, property, rvalue);\n            return;\n        }\n        checkEnumAlias(t, info, rvalue);\n        if (property.equals(\"prototype\")) {\n            if (objectJsType !\u003d null \u0026\u0026 objectJsType.isFunctionType()) {\n                FunctionType functionType \u003d objectJsType.toMaybeFunctionType();\n                if (functionType.isConstructor()) {\n                    JSType rvalueType \u003d rvalue.getJSType();\n                    validator.expectObject(t, rvalue, rvalueType, OVERRIDING_PROTOTYPE_WITH_NON_OBJECT);\n                }\n            } else {\n            }\n            return;\n        }\n        if (object.isGetProp()) {\n            Node object2 \u003d object.getFirstChild();\n            String property2 \u003d NodeUtil.getStringValue(object.getLastChild());\n            if (\"prototype\".equals(property2)) {\n                JSType jsType \u003d getJSType(object2);\n                if (jsType.isFunctionType()) {\n                    FunctionType functionType \u003d jsType.toMaybeFunctionType();\n                    if (functionType.isConstructor() || functionType.isInterface()) {\n                        checkDeclaredPropertyInheritance(t, assign, functionType, property, info, getJSType(rvalue));\n                    }\n                } else {\n                }\n                return;\n            }\n        }\n        ObjectType type \u003d ObjectType.cast(objectJsType.restrictByNotNullOrUndefined());\n        if (type !\u003d null) {\n            if (type.hasProperty(property) \u0026\u0026 !type.isPropertyTypeInferred(property) \u0026\u0026 !propertyIsImplicitCast(type, property)) {\n                validator.expectCanAssignToPropertyOf(t, assign, getJSType(rvalue), type.getPropertyType(property), object, property);\n            }\n            return;\n        }\n    } else if (lvalue.isName()) {\n        JSType rvalueType \u003d getJSType(assign.getLastChild());\n        Var var \u003d t.getScope().getVar(lvalue.getString());\n        if (var !\u003d null) {\n            if (var.isTypeInferred()) {\n                return;\n            }\n        }\n    }\n    JSType leftType \u003d getJSType(lvalue);\n    Node rightChild \u003d assign.getLastChild();\n    JSType rightType \u003d getJSType(rightChild);\n    if (validator.expectCanAssignTo(t, assign, rightType, leftType, \"assignment\")) {\n        ensureTyped(t, assign, rightType);\n    } else {\n        ensureTyped(t, assign);\n    }\n}",
          "path": "src/com/google/javascript/jscomp/TypeCheck.java",
          "functionStartLine": 833,
          "functionName": "visitAssign",
          "functionAnnotation": "",
          "functionDoc": "Visits an assignment \u003ccode\u003elvalue \u003d rvalue\u003c/code\u003e. If the\n\u003ccode\u003elvalue\u003c/code\u003e is a prototype modification, we change the schema\nof the object type it is referring to.\n\n@param t the traversal\n@param assign the assign node\n(\u003ccode\u003eassign.isAssign()\u003c/code\u003e is an implicit invariant)\n",
          "diff": "@@ -1,70 +1,70 @@\n private void visitAssign(NodeTraversal t, Node assign) {\n     JSDocInfo info \u003d assign.getJSDocInfo();\n     Node lvalue \u003d assign.getFirstChild();\n     Node rvalue \u003d assign.getLastChild();\n-    if (lvalue.getType() \u003d\u003d Token.GETPROP) {\n+    if (lvalue.isGetProp()) {\n         Node object \u003d lvalue.getFirstChild();\n         JSType objectJsType \u003d getJSType(object);\n         String property \u003d lvalue.getLastChild().getString();\n-        if (object.getType() \u003d\u003d Token.GETPROP) {\n+        if (object.isGetProp()) {\n             JSType jsType \u003d getJSType(object.getFirstChild());\n             if (jsType.isInterface() \u0026\u0026 object.getLastChild().getString().equals(\"prototype\")) {\n                 visitInterfaceGetprop(t, assign, object, property, lvalue, rvalue);\n             }\n         }\n         if (info !\u003d null \u0026\u0026 info.hasType()) {\n             visitAnnotatedAssignGetprop(t, assign, info.getType().evaluate(t.getScope(), typeRegistry), object, property, rvalue);\n             return;\n         }\n         checkEnumAlias(t, info, rvalue);\n         if (property.equals(\"prototype\")) {\n             if (objectJsType !\u003d null \u0026\u0026 objectJsType.isFunctionType()) {\n                 FunctionType functionType \u003d objectJsType.toMaybeFunctionType();\n                 if (functionType.isConstructor()) {\n                     JSType rvalueType \u003d rvalue.getJSType();\n                     validator.expectObject(t, rvalue, rvalueType, OVERRIDING_PROTOTYPE_WITH_NON_OBJECT);\n                 }\n             } else {\n             }\n             return;\n         }\n-        if (object.getType() \u003d\u003d Token.GETPROP) {\n+        if (object.isGetProp()) {\n             Node object2 \u003d object.getFirstChild();\n             String property2 \u003d NodeUtil.getStringValue(object.getLastChild());\n             if (\"prototype\".equals(property2)) {\n                 JSType jsType \u003d getJSType(object2);\n                 if (jsType.isFunctionType()) {\n                     FunctionType functionType \u003d jsType.toMaybeFunctionType();\n                     if (functionType.isConstructor() || functionType.isInterface()) {\n                         checkDeclaredPropertyInheritance(t, assign, functionType, property, info, getJSType(rvalue));\n                     }\n                 } else {\n                 }\n                 return;\n             }\n         }\n         ObjectType type \u003d ObjectType.cast(objectJsType.restrictByNotNullOrUndefined());\n         if (type !\u003d null) {\n             if (type.hasProperty(property) \u0026\u0026 !type.isPropertyTypeInferred(property) \u0026\u0026 !propertyIsImplicitCast(type, property)) {\n                 validator.expectCanAssignToPropertyOf(t, assign, getJSType(rvalue), type.getPropertyType(property), object, property);\n             }\n             return;\n         }\n-    } else if (lvalue.getType() \u003d\u003d Token.NAME) {\n+    } else if (lvalue.isName()) {\n         JSType rvalueType \u003d getJSType(assign.getLastChild());\n         Var var \u003d t.getScope().getVar(lvalue.getString());\n         if (var !\u003d null) {\n             if (var.isTypeInferred()) {\n                 return;\n             }\n         }\n     }\n     JSType leftType \u003d getJSType(lvalue);\n     Node rightChild \u003d assign.getLastChild();\n     JSType rightType \u003d getJSType(rightChild);\n     if (validator.expectCanAssignTo(t, assign, rightType, leftType, \"assignment\")) {\n         ensureTyped(t, assign, rightType);\n     } else {\n         ensureTyped(t, assign);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "\nReplace the bulk of the Node.getType() \u003d\u003d Token.XXX calls with\nNode.isXXX calls.\n\nR\u003dnicksantos\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3677\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1582 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "11/10/11, 8:36 AM",
          "commitName": "ec324a9bb23eb78c76f537f4c4170ba88d542f1c",
          "commitAuthor": "johnlenz@google.com",
          "commitDateOld": "11/8/11, 12:25 PM",
          "commitNameOld": "9d8201624c22636577d47a40aa03de44363b695b",
          "commitAuthorOld": "johnlenz@google.com",
          "daysBetweenCommits": 1.84,
          "commitsBetweenForRepo": 11,
          "commitsBetweenForFile": 1,
          "actualSource": "private void visitAssign(NodeTraversal t, Node assign) {\n    JSDocInfo info \u003d assign.getJSDocInfo();\n    Node lvalue \u003d assign.getFirstChild();\n    Node rvalue \u003d assign.getLastChild();\n    if (lvalue.isGetProp()) {\n        Node object \u003d lvalue.getFirstChild();\n        JSType objectJsType \u003d getJSType(object);\n        String property \u003d lvalue.getLastChild().getString();\n        if (object.isGetProp()) {\n            JSType jsType \u003d getJSType(object.getFirstChild());\n            if (jsType.isInterface() \u0026\u0026 object.getLastChild().getString().equals(\"prototype\")) {\n                visitInterfaceGetprop(t, assign, object, property, lvalue, rvalue);\n            }\n        }\n        if (info !\u003d null \u0026\u0026 info.hasType()) {\n            visitAnnotatedAssignGetprop(t, assign, info.getType().evaluate(t.getScope(), typeRegistry), object, property, rvalue);\n            return;\n        }\n        checkEnumAlias(t, info, rvalue);\n        if (property.equals(\"prototype\")) {\n            if (objectJsType !\u003d null \u0026\u0026 objectJsType.isFunctionType()) {\n                FunctionType functionType \u003d objectJsType.toMaybeFunctionType();\n                if (functionType.isConstructor()) {\n                    JSType rvalueType \u003d rvalue.getJSType();\n                    validator.expectObject(t, rvalue, rvalueType, OVERRIDING_PROTOTYPE_WITH_NON_OBJECT);\n                }\n            } else {\n            }\n            return;\n        }\n        if (object.isGetProp()) {\n            Node object2 \u003d object.getFirstChild();\n            String property2 \u003d NodeUtil.getStringValue(object.getLastChild());\n            if (\"prototype\".equals(property2)) {\n                JSType jsType \u003d getJSType(object2);\n                if (jsType.isFunctionType()) {\n                    FunctionType functionType \u003d jsType.toMaybeFunctionType();\n                    if (functionType.isConstructor() || functionType.isInterface()) {\n                        checkDeclaredPropertyInheritance(t, assign, functionType, property, info, getJSType(rvalue));\n                    }\n                } else {\n                }\n                return;\n            }\n        }\n        ObjectType type \u003d ObjectType.cast(objectJsType.restrictByNotNullOrUndefined());\n        if (type !\u003d null) {\n            if (type.hasProperty(property) \u0026\u0026 !type.isPropertyTypeInferred(property) \u0026\u0026 !propertyIsImplicitCast(type, property)) {\n                validator.expectCanAssignToPropertyOf(t, assign, getJSType(rvalue), type.getPropertyType(property), object, property);\n            }\n            return;\n        }\n    } else if (lvalue.isName()) {\n        JSType rvalueType \u003d getJSType(assign.getLastChild());\n        Var var \u003d t.getScope().getVar(lvalue.getString());\n        if (var !\u003d null) {\n            if (var.isTypeInferred()) {\n                return;\n            }\n        }\n    }\n    JSType leftType \u003d getJSType(lvalue);\n    Node rightChild \u003d assign.getLastChild();\n    JSType rightType \u003d getJSType(rightChild);\n    if (validator.expectCanAssignTo(t, assign, rightType, leftType, \"assignment\")) {\n        ensureTyped(t, assign, rightType);\n    } else {\n        ensureTyped(t, assign);\n    }\n}",
          "path": "src/com/google/javascript/jscomp/TypeCheck.java",
          "functionStartLine": 833,
          "functionName": "visitAssign",
          "functionAnnotation": "",
          "functionDoc": "Visits an assignment \u003ccode\u003elvalue \u003d rvalue\u003c/code\u003e. If the\n\u003ccode\u003elvalue\u003c/code\u003e is a prototype modification, we change the schema\nof the object type it is referring to.\n\n@param t the traversal\n@param assign the assign node\n(\u003ccode\u003eassign.isAssign()\u003c/code\u003e is an implicit invariant)\n",
          "diff": "@@ -1,70 +1,70 @@\n private void visitAssign(NodeTraversal t, Node assign) {\n     JSDocInfo info \u003d assign.getJSDocInfo();\n     Node lvalue \u003d assign.getFirstChild();\n     Node rvalue \u003d assign.getLastChild();\n-    if (lvalue.getType() \u003d\u003d Token.GETPROP) {\n+    if (lvalue.isGetProp()) {\n         Node object \u003d lvalue.getFirstChild();\n         JSType objectJsType \u003d getJSType(object);\n         String property \u003d lvalue.getLastChild().getString();\n-        if (object.getType() \u003d\u003d Token.GETPROP) {\n+        if (object.isGetProp()) {\n             JSType jsType \u003d getJSType(object.getFirstChild());\n             if (jsType.isInterface() \u0026\u0026 object.getLastChild().getString().equals(\"prototype\")) {\n                 visitInterfaceGetprop(t, assign, object, property, lvalue, rvalue);\n             }\n         }\n         if (info !\u003d null \u0026\u0026 info.hasType()) {\n             visitAnnotatedAssignGetprop(t, assign, info.getType().evaluate(t.getScope(), typeRegistry), object, property, rvalue);\n             return;\n         }\n         checkEnumAlias(t, info, rvalue);\n         if (property.equals(\"prototype\")) {\n             if (objectJsType !\u003d null \u0026\u0026 objectJsType.isFunctionType()) {\n                 FunctionType functionType \u003d objectJsType.toMaybeFunctionType();\n                 if (functionType.isConstructor()) {\n                     JSType rvalueType \u003d rvalue.getJSType();\n                     validator.expectObject(t, rvalue, rvalueType, OVERRIDING_PROTOTYPE_WITH_NON_OBJECT);\n                 }\n             } else {\n             }\n             return;\n         }\n-        if (object.getType() \u003d\u003d Token.GETPROP) {\n+        if (object.isGetProp()) {\n             Node object2 \u003d object.getFirstChild();\n             String property2 \u003d NodeUtil.getStringValue(object.getLastChild());\n             if (\"prototype\".equals(property2)) {\n                 JSType jsType \u003d getJSType(object2);\n                 if (jsType.isFunctionType()) {\n                     FunctionType functionType \u003d jsType.toMaybeFunctionType();\n                     if (functionType.isConstructor() || functionType.isInterface()) {\n                         checkDeclaredPropertyInheritance(t, assign, functionType, property, info, getJSType(rvalue));\n                     }\n                 } else {\n                 }\n                 return;\n             }\n         }\n         ObjectType type \u003d ObjectType.cast(objectJsType.restrictByNotNullOrUndefined());\n         if (type !\u003d null) {\n             if (type.hasProperty(property) \u0026\u0026 !type.isPropertyTypeInferred(property) \u0026\u0026 !propertyIsImplicitCast(type, property)) {\n                 validator.expectCanAssignToPropertyOf(t, assign, getJSType(rvalue), type.getPropertyType(property), object, property);\n             }\n             return;\n         }\n-    } else if (lvalue.getType() \u003d\u003d Token.NAME) {\n+    } else if (lvalue.isName()) {\n         JSType rvalueType \u003d getJSType(assign.getLastChild());\n         Var var \u003d t.getScope().getVar(lvalue.getString());\n         if (var !\u003d null) {\n             if (var.isTypeInferred()) {\n                 return;\n             }\n         }\n     }\n     JSType leftType \u003d getJSType(lvalue);\n     Node rightChild \u003d assign.getLastChild();\n     JSType rightType \u003d getJSType(rightChild);\n     if (validator.expectCanAssignTo(t, assign, rightType, leftType, \"assignment\")) {\n         ensureTyped(t, assign, rightType);\n     } else {\n         ensureTyped(t, assign);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Visits an assignment \u003ccode\u003elvalue \u003d rvalue\u003c/code\u003e. If the\n\u003ccode\u003elvalue\u003c/code\u003e is a prototype modification, we change the schema\nof the object type it is referring to.\n\n@param t the traversal\n@param assign the assign node\n(\u003ccode\u003eassign.getType() \u003d\u003d Token.ASSIGN\u003c/code\u003e is an implicit invariant)\n",
            "newValue": "Visits an assignment \u003ccode\u003elvalue \u003d rvalue\u003c/code\u003e. If the\n\u003ccode\u003elvalue\u003c/code\u003e is a prototype modification, we change the schema\nof the object type it is referring to.\n\n@param t the traversal\n@param assign the assign node\n(\u003ccode\u003eassign.isAssign()\u003c/code\u003e is an implicit invariant)\n"
          }
        }
      ]
    },
    "9614c7c0ffe2418359fe91be2a0e61400142237d": {
      "type": "Ybodychange",
      "commitMessage": "\nremove some special-case code for enums\nnow that we handle object literals properly, we can just\nuse the normal checks\n\nR\u003dacleung\nDELTA\u003d137  (46 added, 26 deleted, 65 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3459\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1509 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "10/12/11, 8:07 PM",
      "commitName": "9614c7c0ffe2418359fe91be2a0e61400142237d",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "10/4/11, 4:04 PM",
      "commitNameOld": "febdacb341025491b3ae83ee8ffa9d22c69c295e",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 8.17,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "actualSource": "private void visitAssign(NodeTraversal t, Node assign) {\n    JSDocInfo info \u003d assign.getJSDocInfo();\n    Node lvalue \u003d assign.getFirstChild();\n    Node rvalue \u003d assign.getLastChild();\n    if (lvalue.getType() \u003d\u003d Token.GETPROP) {\n        Node object \u003d lvalue.getFirstChild();\n        JSType objectJsType \u003d getJSType(object);\n        String property \u003d lvalue.getLastChild().getString();\n        if (object.getType() \u003d\u003d Token.GETPROP) {\n            JSType jsType \u003d getJSType(object.getFirstChild());\n            if (jsType.isInterface() \u0026\u0026 object.getLastChild().getString().equals(\"prototype\")) {\n                visitInterfaceGetprop(t, assign, object, property, lvalue, rvalue);\n            }\n        }\n        if (info !\u003d null \u0026\u0026 info.hasType()) {\n            visitAnnotatedAssignGetprop(t, assign, info.getType().evaluate(t.getScope(), typeRegistry), object, property, rvalue);\n            return;\n        }\n        checkEnumAlias(t, info, rvalue);\n        if (property.equals(\"prototype\")) {\n            if (objectJsType !\u003d null \u0026\u0026 objectJsType.isFunctionType()) {\n                FunctionType functionType \u003d objectJsType.toMaybeFunctionType();\n                if (functionType.isConstructor()) {\n                    JSType rvalueType \u003d rvalue.getJSType();\n                    validator.expectObject(t, rvalue, rvalueType, OVERRIDING_PROTOTYPE_WITH_NON_OBJECT);\n                }\n            } else {\n            }\n            return;\n        }\n        if (object.getType() \u003d\u003d Token.GETPROP) {\n            Node object2 \u003d object.getFirstChild();\n            String property2 \u003d NodeUtil.getStringValue(object.getLastChild());\n            if (\"prototype\".equals(property2)) {\n                JSType jsType \u003d getJSType(object2);\n                if (jsType.isFunctionType()) {\n                    FunctionType functionType \u003d jsType.toMaybeFunctionType();\n                    if (functionType.isConstructor() || functionType.isInterface()) {\n                        checkDeclaredPropertyInheritance(t, assign, functionType, property, info, getJSType(rvalue));\n                    }\n                } else {\n                }\n                return;\n            }\n        }\n        ObjectType type \u003d ObjectType.cast(objectJsType.restrictByNotNullOrUndefined());\n        if (type !\u003d null) {\n            if (type.hasProperty(property) \u0026\u0026 !type.isPropertyTypeInferred(property) \u0026\u0026 !propertyIsImplicitCast(type, property)) {\n                validator.expectCanAssignToPropertyOf(t, assign, getJSType(rvalue), type.getPropertyType(property), object, property);\n            }\n            return;\n        }\n    } else if (lvalue.getType() \u003d\u003d Token.NAME) {\n        JSType rvalueType \u003d getJSType(assign.getLastChild());\n        Var var \u003d t.getScope().getVar(lvalue.getString());\n        if (var !\u003d null) {\n            if (var.isTypeInferred()) {\n                return;\n            }\n        }\n    }\n    JSType leftType \u003d getJSType(lvalue);\n    Node rightChild \u003d assign.getLastChild();\n    JSType rightType \u003d getJSType(rightChild);\n    if (validator.expectCanAssignTo(t, assign, rightType, leftType, \"assignment\")) {\n        ensureTyped(t, assign, rightType);\n    } else {\n        ensureTyped(t, assign);\n    }\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 841,
      "functionName": "visitAssign",
      "functionAnnotation": "",
      "functionDoc": "Visits an assignment \u003ccode\u003elvalue \u003d rvalue\u003c/code\u003e. If the\n\u003ccode\u003elvalue\u003c/code\u003e is a prototype modification, we change the schema\nof the object type it is referring to.\n\n@param t the traversal\n@param assign the assign node\n(\u003ccode\u003eassign.getType() \u003d\u003d Token.ASSIGN\u003c/code\u003e is an implicit invariant)\n",
      "diff": "@@ -1,73 +1,70 @@\n private void visitAssign(NodeTraversal t, Node assign) {\n     JSDocInfo info \u003d assign.getJSDocInfo();\n     Node lvalue \u003d assign.getFirstChild();\n     Node rvalue \u003d assign.getLastChild();\n     if (lvalue.getType() \u003d\u003d Token.GETPROP) {\n         Node object \u003d lvalue.getFirstChild();\n         JSType objectJsType \u003d getJSType(object);\n         String property \u003d lvalue.getLastChild().getString();\n         if (object.getType() \u003d\u003d Token.GETPROP) {\n             JSType jsType \u003d getJSType(object.getFirstChild());\n             if (jsType.isInterface() \u0026\u0026 object.getLastChild().getString().equals(\"prototype\")) {\n                 visitInterfaceGetprop(t, assign, object, property, lvalue, rvalue);\n             }\n         }\n         if (info !\u003d null \u0026\u0026 info.hasType()) {\n             visitAnnotatedAssignGetprop(t, assign, info.getType().evaluate(t.getScope(), typeRegistry), object, property, rvalue);\n             return;\n         }\n-        if (info !\u003d null \u0026\u0026 info.hasEnumParameterType()) {\n-            checkEnumInitializer(t, rvalue, info.getEnumParameterType().evaluate(t.getScope(), typeRegistry));\n-            return;\n-        }\n+        checkEnumAlias(t, info, rvalue);\n         if (property.equals(\"prototype\")) {\n             if (objectJsType !\u003d null \u0026\u0026 objectJsType.isFunctionType()) {\n                 FunctionType functionType \u003d objectJsType.toMaybeFunctionType();\n                 if (functionType.isConstructor()) {\n                     JSType rvalueType \u003d rvalue.getJSType();\n                     validator.expectObject(t, rvalue, rvalueType, OVERRIDING_PROTOTYPE_WITH_NON_OBJECT);\n                 }\n             } else {\n             }\n             return;\n         }\n         if (object.getType() \u003d\u003d Token.GETPROP) {\n             Node object2 \u003d object.getFirstChild();\n             String property2 \u003d NodeUtil.getStringValue(object.getLastChild());\n             if (\"prototype\".equals(property2)) {\n                 JSType jsType \u003d getJSType(object2);\n                 if (jsType.isFunctionType()) {\n                     FunctionType functionType \u003d jsType.toMaybeFunctionType();\n                     if (functionType.isConstructor() || functionType.isInterface()) {\n                         checkDeclaredPropertyInheritance(t, assign, functionType, property, info, getJSType(rvalue));\n                     }\n                 } else {\n                 }\n                 return;\n             }\n         }\n         ObjectType type \u003d ObjectType.cast(objectJsType.restrictByNotNullOrUndefined());\n         if (type !\u003d null) {\n             if (type.hasProperty(property) \u0026\u0026 !type.isPropertyTypeInferred(property) \u0026\u0026 !propertyIsImplicitCast(type, property)) {\n                 validator.expectCanAssignToPropertyOf(t, assign, getJSType(rvalue), type.getPropertyType(property), object, property);\n             }\n             return;\n         }\n     } else if (lvalue.getType() \u003d\u003d Token.NAME) {\n         JSType rvalueType \u003d getJSType(assign.getLastChild());\n         Var var \u003d t.getScope().getVar(lvalue.getString());\n         if (var !\u003d null) {\n             if (var.isTypeInferred()) {\n                 return;\n             }\n         }\n     }\n     JSType leftType \u003d getJSType(lvalue);\n     Node rightChild \u003d assign.getLastChild();\n     JSType rightType \u003d getJSType(rightChild);\n     if (validator.expectCanAssignTo(t, assign, rightType, leftType, \"assignment\")) {\n         ensureTyped(t, assign, rightType);\n     } else {\n         ensureTyped(t, assign);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "bd9c7b620384fe5a98772729001ed56304459bc6": {
      "type": "Ybodychange",
      "commitMessage": "\nAdd toMaybeFunctionType/toMaybeEnumElementType.\ntry #2. the bugs in jstestc were fixed. this cl is exactly\nthe same as the original\n\nR\u003djohnlenz\nDELTA\u003d317  (79 added, 47 deleted, 191 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3078\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1367 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "8/18/11, 3:46 PM",
      "commitName": "bd9c7b620384fe5a98772729001ed56304459bc6",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "8/18/11, 10:40 AM",
      "commitNameOld": "01d1238a2a577d8988a72c29304a3283ca05a29a",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 0.21,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "private void visitAssign(NodeTraversal t, Node assign) {\n    JSDocInfo info \u003d assign.getJSDocInfo();\n    Node lvalue \u003d assign.getFirstChild();\n    Node rvalue \u003d assign.getLastChild();\n    if (lvalue.getType() \u003d\u003d Token.GETPROP) {\n        Node object \u003d lvalue.getFirstChild();\n        JSType objectJsType \u003d getJSType(object);\n        String property \u003d lvalue.getLastChild().getString();\n        if (object.getType() \u003d\u003d Token.GETPROP) {\n            JSType jsType \u003d getJSType(object.getFirstChild());\n            if (jsType.isInterface() \u0026\u0026 object.getLastChild().getString().equals(\"prototype\")) {\n                visitInterfaceGetprop(t, assign, object, property, lvalue, rvalue);\n            }\n        }\n        if (info !\u003d null \u0026\u0026 info.hasType()) {\n            visitAnnotatedAssignGetprop(t, assign, info.getType().evaluate(t.getScope(), typeRegistry), object, property, rvalue);\n            return;\n        }\n        if (info !\u003d null \u0026\u0026 info.hasEnumParameterType()) {\n            checkEnumInitializer(t, rvalue, info.getEnumParameterType().evaluate(t.getScope(), typeRegistry));\n            return;\n        }\n        if (property.equals(\"prototype\")) {\n            if (objectJsType !\u003d null \u0026\u0026 objectJsType.isFunctionType()) {\n                FunctionType functionType \u003d objectJsType.toMaybeFunctionType();\n                if (functionType.isConstructor()) {\n                    JSType rvalueType \u003d rvalue.getJSType();\n                    validator.expectObject(t, rvalue, rvalueType, OVERRIDING_PROTOTYPE_WITH_NON_OBJECT);\n                }\n            } else {\n            }\n            return;\n        }\n        if (object.getType() \u003d\u003d Token.GETPROP) {\n            Node object2 \u003d object.getFirstChild();\n            String property2 \u003d NodeUtil.getStringValue(object.getLastChild());\n            if (\"prototype\".equals(property2)) {\n                JSType jsType \u003d getJSType(object2);\n                if (jsType.isFunctionType()) {\n                    FunctionType functionType \u003d jsType.toMaybeFunctionType();\n                    if (functionType.isConstructor() || functionType.isInterface()) {\n                        checkDeclaredPropertyInheritance(t, assign, functionType, property, info, getJSType(rvalue));\n                    }\n                } else {\n                }\n                return;\n            }\n        }\n        ObjectType type \u003d ObjectType.cast(objectJsType.restrictByNotNullOrUndefined());\n        if (type !\u003d null) {\n            if (type.hasProperty(property) \u0026\u0026 !type.isPropertyTypeInferred(property) \u0026\u0026 !propertyIsImplicitCast(type, property)) {\n                validator.expectCanAssignToPropertyOf(t, assign, getJSType(rvalue), type.getPropertyType(property), object, property);\n            }\n            return;\n        }\n    } else if (lvalue.getType() \u003d\u003d Token.NAME) {\n        JSType rvalueType \u003d getJSType(assign.getLastChild());\n        Var var \u003d t.getScope().getVar(lvalue.getString());\n        if (var !\u003d null) {\n            if (var.isTypeInferred()) {\n                return;\n            }\n        }\n    }\n    JSType leftType \u003d getJSType(lvalue);\n    Node rightChild \u003d assign.getLastChild();\n    JSType rightType \u003d getJSType(rightChild);\n    if (validator.expectCanAssignTo(t, assign, rightType, leftType, \"assignment\")) {\n        ensureTyped(t, assign, rightType);\n    } else {\n        ensureTyped(t, assign);\n    }\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 841,
      "functionName": "visitAssign",
      "functionAnnotation": "",
      "functionDoc": "Visits an assignment \u003ccode\u003elvalue \u003d rvalue\u003c/code\u003e. If the\n\u003ccode\u003elvalue\u003c/code\u003e is a prototype modification, we change the schema\nof the object type it is referring to.\n\n@param t the traversal\n@param assign the assign node\n(\u003ccode\u003eassign.getType() \u003d\u003d Token.ASSIGN\u003c/code\u003e is an implicit invariant)\n",
      "diff": "@@ -1,73 +1,73 @@\n private void visitAssign(NodeTraversal t, Node assign) {\n     JSDocInfo info \u003d assign.getJSDocInfo();\n     Node lvalue \u003d assign.getFirstChild();\n     Node rvalue \u003d assign.getLastChild();\n     if (lvalue.getType() \u003d\u003d Token.GETPROP) {\n         Node object \u003d lvalue.getFirstChild();\n         JSType objectJsType \u003d getJSType(object);\n         String property \u003d lvalue.getLastChild().getString();\n         if (object.getType() \u003d\u003d Token.GETPROP) {\n             JSType jsType \u003d getJSType(object.getFirstChild());\n             if (jsType.isInterface() \u0026\u0026 object.getLastChild().getString().equals(\"prototype\")) {\n                 visitInterfaceGetprop(t, assign, object, property, lvalue, rvalue);\n             }\n         }\n         if (info !\u003d null \u0026\u0026 info.hasType()) {\n             visitAnnotatedAssignGetprop(t, assign, info.getType().evaluate(t.getScope(), typeRegistry), object, property, rvalue);\n             return;\n         }\n         if (info !\u003d null \u0026\u0026 info.hasEnumParameterType()) {\n             checkEnumInitializer(t, rvalue, info.getEnumParameterType().evaluate(t.getScope(), typeRegistry));\n             return;\n         }\n         if (property.equals(\"prototype\")) {\n-            if (objectJsType instanceof FunctionType) {\n-                FunctionType functionType \u003d (FunctionType) objectJsType;\n+            if (objectJsType !\u003d null \u0026\u0026 objectJsType.isFunctionType()) {\n+                FunctionType functionType \u003d objectJsType.toMaybeFunctionType();\n                 if (functionType.isConstructor()) {\n                     JSType rvalueType \u003d rvalue.getJSType();\n                     validator.expectObject(t, rvalue, rvalueType, OVERRIDING_PROTOTYPE_WITH_NON_OBJECT);\n                 }\n             } else {\n             }\n             return;\n         }\n         if (object.getType() \u003d\u003d Token.GETPROP) {\n             Node object2 \u003d object.getFirstChild();\n             String property2 \u003d NodeUtil.getStringValue(object.getLastChild());\n             if (\"prototype\".equals(property2)) {\n-                JSType jsType \u003d object2.getJSType();\n-                if (jsType instanceof FunctionType) {\n-                    FunctionType functionType \u003d (FunctionType) jsType;\n+                JSType jsType \u003d getJSType(object2);\n+                if (jsType.isFunctionType()) {\n+                    FunctionType functionType \u003d jsType.toMaybeFunctionType();\n                     if (functionType.isConstructor() || functionType.isInterface()) {\n                         checkDeclaredPropertyInheritance(t, assign, functionType, property, info, getJSType(rvalue));\n                     }\n                 } else {\n                 }\n                 return;\n             }\n         }\n         ObjectType type \u003d ObjectType.cast(objectJsType.restrictByNotNullOrUndefined());\n         if (type !\u003d null) {\n             if (type.hasProperty(property) \u0026\u0026 !type.isPropertyTypeInferred(property) \u0026\u0026 !propertyIsImplicitCast(type, property)) {\n                 validator.expectCanAssignToPropertyOf(t, assign, getJSType(rvalue), type.getPropertyType(property), object, property);\n             }\n             return;\n         }\n     } else if (lvalue.getType() \u003d\u003d Token.NAME) {\n         JSType rvalueType \u003d getJSType(assign.getLastChild());\n         Var var \u003d t.getScope().getVar(lvalue.getString());\n         if (var !\u003d null) {\n             if (var.isTypeInferred()) {\n                 return;\n             }\n         }\n     }\n     JSType leftType \u003d getJSType(lvalue);\n     Node rightChild \u003d assign.getLastChild();\n     JSType rightType \u003d getJSType(rightChild);\n     if (validator.expectCanAssignTo(t, assign, rightType, leftType, \"assignment\")) {\n         ensureTyped(t, assign, rightType);\n     } else {\n         ensureTyped(t, assign);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "01d1238a2a577d8988a72c29304a3283ca05a29a": {
      "type": "Ybodychange",
      "commitMessage": "\nAutomated g4 rollback.\n\n*** Reason for rollback ***\n\nbroke some tests\n\n*** Original change description ***\n\nAdd toMaybeFunctionType/toMaybeEnumElementType.\nwow, nullability is annoying!\n\nDELTA\u003d318  (48 added, 79 deleted, 191 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3075\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1364 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "8/18/11, 10:40 AM",
      "commitName": "01d1238a2a577d8988a72c29304a3283ca05a29a",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "8/18/11, 9:38 AM",
      "commitNameOld": "fc0798047ad3aac58a54ea65f9f1c8857745419f",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private void visitAssign(NodeTraversal t, Node assign) {\n    JSDocInfo info \u003d assign.getJSDocInfo();\n    Node lvalue \u003d assign.getFirstChild();\n    Node rvalue \u003d assign.getLastChild();\n    if (lvalue.getType() \u003d\u003d Token.GETPROP) {\n        Node object \u003d lvalue.getFirstChild();\n        JSType objectJsType \u003d getJSType(object);\n        String property \u003d lvalue.getLastChild().getString();\n        if (object.getType() \u003d\u003d Token.GETPROP) {\n            JSType jsType \u003d getJSType(object.getFirstChild());\n            if (jsType.isInterface() \u0026\u0026 object.getLastChild().getString().equals(\"prototype\")) {\n                visitInterfaceGetprop(t, assign, object, property, lvalue, rvalue);\n            }\n        }\n        if (info !\u003d null \u0026\u0026 info.hasType()) {\n            visitAnnotatedAssignGetprop(t, assign, info.getType().evaluate(t.getScope(), typeRegistry), object, property, rvalue);\n            return;\n        }\n        if (info !\u003d null \u0026\u0026 info.hasEnumParameterType()) {\n            checkEnumInitializer(t, rvalue, info.getEnumParameterType().evaluate(t.getScope(), typeRegistry));\n            return;\n        }\n        if (property.equals(\"prototype\")) {\n            if (objectJsType instanceof FunctionType) {\n                FunctionType functionType \u003d (FunctionType) objectJsType;\n                if (functionType.isConstructor()) {\n                    JSType rvalueType \u003d rvalue.getJSType();\n                    validator.expectObject(t, rvalue, rvalueType, OVERRIDING_PROTOTYPE_WITH_NON_OBJECT);\n                }\n            } else {\n            }\n            return;\n        }\n        if (object.getType() \u003d\u003d Token.GETPROP) {\n            Node object2 \u003d object.getFirstChild();\n            String property2 \u003d NodeUtil.getStringValue(object.getLastChild());\n            if (\"prototype\".equals(property2)) {\n                JSType jsType \u003d object2.getJSType();\n                if (jsType instanceof FunctionType) {\n                    FunctionType functionType \u003d (FunctionType) jsType;\n                    if (functionType.isConstructor() || functionType.isInterface()) {\n                        checkDeclaredPropertyInheritance(t, assign, functionType, property, info, getJSType(rvalue));\n                    }\n                } else {\n                }\n                return;\n            }\n        }\n        ObjectType type \u003d ObjectType.cast(objectJsType.restrictByNotNullOrUndefined());\n        if (type !\u003d null) {\n            if (type.hasProperty(property) \u0026\u0026 !type.isPropertyTypeInferred(property) \u0026\u0026 !propertyIsImplicitCast(type, property)) {\n                validator.expectCanAssignToPropertyOf(t, assign, getJSType(rvalue), type.getPropertyType(property), object, property);\n            }\n            return;\n        }\n    } else if (lvalue.getType() \u003d\u003d Token.NAME) {\n        JSType rvalueType \u003d getJSType(assign.getLastChild());\n        Var var \u003d t.getScope().getVar(lvalue.getString());\n        if (var !\u003d null) {\n            if (var.isTypeInferred()) {\n                return;\n            }\n        }\n    }\n    JSType leftType \u003d getJSType(lvalue);\n    Node rightChild \u003d assign.getLastChild();\n    JSType rightType \u003d getJSType(rightChild);\n    if (validator.expectCanAssignTo(t, assign, rightType, leftType, \"assignment\")) {\n        ensureTyped(t, assign, rightType);\n    } else {\n        ensureTyped(t, assign);\n    }\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 844,
      "functionName": "visitAssign",
      "functionAnnotation": "",
      "functionDoc": "Visits an assignment \u003ccode\u003elvalue \u003d rvalue\u003c/code\u003e. If the\n\u003ccode\u003elvalue\u003c/code\u003e is a prototype modification, we change the schema\nof the object type it is referring to.\n\n@param t the traversal\n@param assign the assign node\n(\u003ccode\u003eassign.getType() \u003d\u003d Token.ASSIGN\u003c/code\u003e is an implicit invariant)\n",
      "diff": "@@ -1,73 +1,73 @@\n private void visitAssign(NodeTraversal t, Node assign) {\n     JSDocInfo info \u003d assign.getJSDocInfo();\n     Node lvalue \u003d assign.getFirstChild();\n     Node rvalue \u003d assign.getLastChild();\n     if (lvalue.getType() \u003d\u003d Token.GETPROP) {\n         Node object \u003d lvalue.getFirstChild();\n         JSType objectJsType \u003d getJSType(object);\n         String property \u003d lvalue.getLastChild().getString();\n         if (object.getType() \u003d\u003d Token.GETPROP) {\n             JSType jsType \u003d getJSType(object.getFirstChild());\n             if (jsType.isInterface() \u0026\u0026 object.getLastChild().getString().equals(\"prototype\")) {\n                 visitInterfaceGetprop(t, assign, object, property, lvalue, rvalue);\n             }\n         }\n         if (info !\u003d null \u0026\u0026 info.hasType()) {\n             visitAnnotatedAssignGetprop(t, assign, info.getType().evaluate(t.getScope(), typeRegistry), object, property, rvalue);\n             return;\n         }\n         if (info !\u003d null \u0026\u0026 info.hasEnumParameterType()) {\n             checkEnumInitializer(t, rvalue, info.getEnumParameterType().evaluate(t.getScope(), typeRegistry));\n             return;\n         }\n         if (property.equals(\"prototype\")) {\n-            if (objectJsType !\u003d null \u0026\u0026 objectJsType.isFunctionType()) {\n-                FunctionType functionType \u003d objectJsType.toMaybeFunctionType();\n+            if (objectJsType instanceof FunctionType) {\n+                FunctionType functionType \u003d (FunctionType) objectJsType;\n                 if (functionType.isConstructor()) {\n                     JSType rvalueType \u003d rvalue.getJSType();\n                     validator.expectObject(t, rvalue, rvalueType, OVERRIDING_PROTOTYPE_WITH_NON_OBJECT);\n                 }\n             } else {\n             }\n             return;\n         }\n         if (object.getType() \u003d\u003d Token.GETPROP) {\n             Node object2 \u003d object.getFirstChild();\n             String property2 \u003d NodeUtil.getStringValue(object.getLastChild());\n             if (\"prototype\".equals(property2)) {\n-                JSType jsType \u003d getJSType(object2);\n-                if (jsType.isFunctionType()) {\n-                    FunctionType functionType \u003d jsType.toMaybeFunctionType();\n+                JSType jsType \u003d object2.getJSType();\n+                if (jsType instanceof FunctionType) {\n+                    FunctionType functionType \u003d (FunctionType) jsType;\n                     if (functionType.isConstructor() || functionType.isInterface()) {\n                         checkDeclaredPropertyInheritance(t, assign, functionType, property, info, getJSType(rvalue));\n                     }\n                 } else {\n                 }\n                 return;\n             }\n         }\n         ObjectType type \u003d ObjectType.cast(objectJsType.restrictByNotNullOrUndefined());\n         if (type !\u003d null) {\n             if (type.hasProperty(property) \u0026\u0026 !type.isPropertyTypeInferred(property) \u0026\u0026 !propertyIsImplicitCast(type, property)) {\n                 validator.expectCanAssignToPropertyOf(t, assign, getJSType(rvalue), type.getPropertyType(property), object, property);\n             }\n             return;\n         }\n     } else if (lvalue.getType() \u003d\u003d Token.NAME) {\n         JSType rvalueType \u003d getJSType(assign.getLastChild());\n         Var var \u003d t.getScope().getVar(lvalue.getString());\n         if (var !\u003d null) {\n             if (var.isTypeInferred()) {\n                 return;\n             }\n         }\n     }\n     JSType leftType \u003d getJSType(lvalue);\n     Node rightChild \u003d assign.getLastChild();\n     JSType rightType \u003d getJSType(rightChild);\n     if (validator.expectCanAssignTo(t, assign, rightType, leftType, \"assignment\")) {\n         ensureTyped(t, assign, rightType);\n     } else {\n         ensureTyped(t, assign);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fc0798047ad3aac58a54ea65f9f1c8857745419f": {
      "type": "Ybodychange",
      "commitMessage": "\nAdd toMaybeFunctionType/toMaybeEnumElementType.\nwow, nullability is annoying!\n\nR\u003djohnlenz\nDELTA\u003d318  (79 added, 48 deleted, 191 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3074\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1363 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "8/18/11, 9:38 AM",
      "commitName": "fc0798047ad3aac58a54ea65f9f1c8857745419f",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "8/4/11, 9:23 AM",
      "commitNameOld": "0af94b21ceb7f8f0891b85e5713ff93c230e1bb6",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 14.01,
      "commitsBetweenForRepo": 28,
      "commitsBetweenForFile": 1,
      "actualSource": "private void visitAssign(NodeTraversal t, Node assign) {\n    JSDocInfo info \u003d assign.getJSDocInfo();\n    Node lvalue \u003d assign.getFirstChild();\n    Node rvalue \u003d assign.getLastChild();\n    if (lvalue.getType() \u003d\u003d Token.GETPROP) {\n        Node object \u003d lvalue.getFirstChild();\n        JSType objectJsType \u003d getJSType(object);\n        String property \u003d lvalue.getLastChild().getString();\n        if (object.getType() \u003d\u003d Token.GETPROP) {\n            JSType jsType \u003d getJSType(object.getFirstChild());\n            if (jsType.isInterface() \u0026\u0026 object.getLastChild().getString().equals(\"prototype\")) {\n                visitInterfaceGetprop(t, assign, object, property, lvalue, rvalue);\n            }\n        }\n        if (info !\u003d null \u0026\u0026 info.hasType()) {\n            visitAnnotatedAssignGetprop(t, assign, info.getType().evaluate(t.getScope(), typeRegistry), object, property, rvalue);\n            return;\n        }\n        if (info !\u003d null \u0026\u0026 info.hasEnumParameterType()) {\n            checkEnumInitializer(t, rvalue, info.getEnumParameterType().evaluate(t.getScope(), typeRegistry));\n            return;\n        }\n        if (property.equals(\"prototype\")) {\n            if (objectJsType !\u003d null \u0026\u0026 objectJsType.isFunctionType()) {\n                FunctionType functionType \u003d objectJsType.toMaybeFunctionType();\n                if (functionType.isConstructor()) {\n                    JSType rvalueType \u003d rvalue.getJSType();\n                    validator.expectObject(t, rvalue, rvalueType, OVERRIDING_PROTOTYPE_WITH_NON_OBJECT);\n                }\n            } else {\n            }\n            return;\n        }\n        if (object.getType() \u003d\u003d Token.GETPROP) {\n            Node object2 \u003d object.getFirstChild();\n            String property2 \u003d NodeUtil.getStringValue(object.getLastChild());\n            if (\"prototype\".equals(property2)) {\n                JSType jsType \u003d getJSType(object2);\n                if (jsType.isFunctionType()) {\n                    FunctionType functionType \u003d jsType.toMaybeFunctionType();\n                    if (functionType.isConstructor() || functionType.isInterface()) {\n                        checkDeclaredPropertyInheritance(t, assign, functionType, property, info, getJSType(rvalue));\n                    }\n                } else {\n                }\n                return;\n            }\n        }\n        ObjectType type \u003d ObjectType.cast(objectJsType.restrictByNotNullOrUndefined());\n        if (type !\u003d null) {\n            if (type.hasProperty(property) \u0026\u0026 !type.isPropertyTypeInferred(property) \u0026\u0026 !propertyIsImplicitCast(type, property)) {\n                validator.expectCanAssignToPropertyOf(t, assign, getJSType(rvalue), type.getPropertyType(property), object, property);\n            }\n            return;\n        }\n    } else if (lvalue.getType() \u003d\u003d Token.NAME) {\n        JSType rvalueType \u003d getJSType(assign.getLastChild());\n        Var var \u003d t.getScope().getVar(lvalue.getString());\n        if (var !\u003d null) {\n            if (var.isTypeInferred()) {\n                return;\n            }\n        }\n    }\n    JSType leftType \u003d getJSType(lvalue);\n    Node rightChild \u003d assign.getLastChild();\n    JSType rightType \u003d getJSType(rightChild);\n    if (validator.expectCanAssignTo(t, assign, rightType, leftType, \"assignment\")) {\n        ensureTyped(t, assign, rightType);\n    } else {\n        ensureTyped(t, assign);\n    }\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 841,
      "functionName": "visitAssign",
      "functionAnnotation": "",
      "functionDoc": "Visits an assignment \u003ccode\u003elvalue \u003d rvalue\u003c/code\u003e. If the\n\u003ccode\u003elvalue\u003c/code\u003e is a prototype modification, we change the schema\nof the object type it is referring to.\n\n@param t the traversal\n@param assign the assign node\n(\u003ccode\u003eassign.getType() \u003d\u003d Token.ASSIGN\u003c/code\u003e is an implicit invariant)\n",
      "diff": "@@ -1,73 +1,73 @@\n private void visitAssign(NodeTraversal t, Node assign) {\n     JSDocInfo info \u003d assign.getJSDocInfo();\n     Node lvalue \u003d assign.getFirstChild();\n     Node rvalue \u003d assign.getLastChild();\n     if (lvalue.getType() \u003d\u003d Token.GETPROP) {\n         Node object \u003d lvalue.getFirstChild();\n         JSType objectJsType \u003d getJSType(object);\n         String property \u003d lvalue.getLastChild().getString();\n         if (object.getType() \u003d\u003d Token.GETPROP) {\n             JSType jsType \u003d getJSType(object.getFirstChild());\n             if (jsType.isInterface() \u0026\u0026 object.getLastChild().getString().equals(\"prototype\")) {\n                 visitInterfaceGetprop(t, assign, object, property, lvalue, rvalue);\n             }\n         }\n         if (info !\u003d null \u0026\u0026 info.hasType()) {\n             visitAnnotatedAssignGetprop(t, assign, info.getType().evaluate(t.getScope(), typeRegistry), object, property, rvalue);\n             return;\n         }\n         if (info !\u003d null \u0026\u0026 info.hasEnumParameterType()) {\n             checkEnumInitializer(t, rvalue, info.getEnumParameterType().evaluate(t.getScope(), typeRegistry));\n             return;\n         }\n         if (property.equals(\"prototype\")) {\n-            if (objectJsType instanceof FunctionType) {\n-                FunctionType functionType \u003d (FunctionType) objectJsType;\n+            if (objectJsType !\u003d null \u0026\u0026 objectJsType.isFunctionType()) {\n+                FunctionType functionType \u003d objectJsType.toMaybeFunctionType();\n                 if (functionType.isConstructor()) {\n                     JSType rvalueType \u003d rvalue.getJSType();\n                     validator.expectObject(t, rvalue, rvalueType, OVERRIDING_PROTOTYPE_WITH_NON_OBJECT);\n                 }\n             } else {\n             }\n             return;\n         }\n         if (object.getType() \u003d\u003d Token.GETPROP) {\n             Node object2 \u003d object.getFirstChild();\n             String property2 \u003d NodeUtil.getStringValue(object.getLastChild());\n             if (\"prototype\".equals(property2)) {\n-                JSType jsType \u003d object2.getJSType();\n-                if (jsType instanceof FunctionType) {\n-                    FunctionType functionType \u003d (FunctionType) jsType;\n+                JSType jsType \u003d getJSType(object2);\n+                if (jsType.isFunctionType()) {\n+                    FunctionType functionType \u003d jsType.toMaybeFunctionType();\n                     if (functionType.isConstructor() || functionType.isInterface()) {\n                         checkDeclaredPropertyInheritance(t, assign, functionType, property, info, getJSType(rvalue));\n                     }\n                 } else {\n                 }\n                 return;\n             }\n         }\n         ObjectType type \u003d ObjectType.cast(objectJsType.restrictByNotNullOrUndefined());\n         if (type !\u003d null) {\n             if (type.hasProperty(property) \u0026\u0026 !type.isPropertyTypeInferred(property) \u0026\u0026 !propertyIsImplicitCast(type, property)) {\n                 validator.expectCanAssignToPropertyOf(t, assign, getJSType(rvalue), type.getPropertyType(property), object, property);\n             }\n             return;\n         }\n     } else if (lvalue.getType() \u003d\u003d Token.NAME) {\n         JSType rvalueType \u003d getJSType(assign.getLastChild());\n         Var var \u003d t.getScope().getVar(lvalue.getString());\n         if (var !\u003d null) {\n             if (var.isTypeInferred()) {\n                 return;\n             }\n         }\n     }\n     JSType leftType \u003d getJSType(lvalue);\n     Node rightChild \u003d assign.getLastChild();\n     JSType rightType \u003d getJSType(rightChild);\n     if (validator.expectCanAssignTo(t, assign, rightType, leftType, \"assignment\")) {\n         ensureTyped(t, assign, rightType);\n     } else {\n         ensureTyped(t, assign);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c764a46abf211d4677fadc33f7d466e5b14fa088": {
      "type": "Ybodychange",
      "commitMessage": "\nChange on 2010/04/13 by john\n\n        Here is a crazy thought, let\u0027s not require the JSTypeRegistry during\n        parsing.\n\n        There are basically two changes here:\n        1) The IRFactory was looking for enums to seed the JSTypeRegistry, so\n        we do that when we setup for type interence.\n        2) The JSDocParser was checking the types of @defines objects, now do\n        that during ProcessDefines.\n\n        R\u003drobert,mark\n        DELTA\u003d207  (82 added, 89 deleted, 36 changed)\n\nChange on 2010/04/14 by nick\n\n        Add a debugging function for JSType hashcodes.\n        i found this useful, and thought others might too.\n\n        R\u003djohn\n        DELTA\u003d69  (69 added, 0 deleted, 0 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003dfqsoxx\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@183 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/14/10, 9:15 AM",
      "commitName": "c764a46abf211d4677fadc33f7d466e5b14fa088",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "4/5/10, 12:30 PM",
      "commitNameOld": "222eafd303155b3eac5cd244584b2cb3c4c11975",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 8.86,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "actualSource": "private void visitAssign(NodeTraversal t, Node assign) {\n    JSDocInfo info \u003d assign.getJSDocInfo();\n    Node lvalue \u003d assign.getFirstChild();\n    Node rvalue \u003d assign.getLastChild();\n    if (lvalue.getType() \u003d\u003d Token.GETPROP) {\n        Node object \u003d lvalue.getFirstChild();\n        JSType objectJsType \u003d getJSType(object);\n        String property \u003d lvalue.getLastChild().getString();\n        if (object.getType() \u003d\u003d Token.GETPROP) {\n            JSType jsType \u003d getJSType(object.getFirstChild());\n            if (jsType.isInterface() \u0026\u0026 object.getLastChild().getString().equals(\"prototype\")) {\n                visitInterfaceGetprop(t, assign, object, property, lvalue, rvalue);\n            }\n        }\n        if (info !\u003d null \u0026\u0026 info.hasType()) {\n            visitAnnotatedAssignGetprop(t, assign, info.getType().evaluate(t.getScope(), typeRegistry), object, property, rvalue);\n            return;\n        }\n        if (info !\u003d null \u0026\u0026 info.hasEnumParameterType()) {\n            checkEnumInitializer(t, rvalue, info.getEnumParameterType().evaluate(t.getScope(), typeRegistry));\n            return;\n        }\n        if (property.equals(\"prototype\")) {\n            if (objectJsType instanceof FunctionType) {\n                FunctionType functionType \u003d (FunctionType) objectJsType;\n                if (functionType.isConstructor()) {\n                    JSType rvalueType \u003d rvalue.getJSType();\n                    validator.expectObject(t, rvalue, rvalueType, OVERRIDING_PROTOTYPE_WITH_NON_OBJECT);\n                }\n            } else {\n            }\n            return;\n        }\n        if (object.getType() \u003d\u003d Token.GETPROP) {\n            Node object2 \u003d object.getFirstChild();\n            String property2 \u003d NodeUtil.getStringValue(object.getLastChild());\n            if (\"prototype\".equals(property2)) {\n                JSType jsType \u003d object2.getJSType();\n                if (jsType instanceof FunctionType) {\n                    FunctionType functionType \u003d (FunctionType) jsType;\n                    if (functionType.isConstructor() || functionType.isInterface()) {\n                        checkDeclaredPropertyInheritance(t, assign, functionType, property, info, getJSType(rvalue));\n                    }\n                } else {\n                }\n                return;\n            }\n        }\n        ObjectType type \u003d ObjectType.cast(objectJsType.restrictByNotNullOrUndefined());\n        if (type !\u003d null) {\n            if (type.hasProperty(property) \u0026\u0026 !type.isPropertyTypeInferred(property) \u0026\u0026 !propertyIsImplicitCast(type, property)) {\n                validator.expectCanAssignToPropertyOf(t, assign, getJSType(rvalue), type.getPropertyType(property), object, property);\n            }\n            return;\n        }\n    } else if (lvalue.getType() \u003d\u003d Token.NAME) {\n        JSType rvalueType \u003d getJSType(assign.getLastChild());\n        Var var \u003d t.getScope().getVar(lvalue.getString());\n        if (var !\u003d null) {\n            if (var.isTypeInferred()) {\n                return;\n            }\n        }\n    }\n    JSType leftType \u003d getJSType(lvalue);\n    Node rightChild \u003d assign.getLastChild();\n    JSType rightType \u003d getJSType(rightChild);\n    if (validator.expectCanAssignTo(t, assign, rightType, leftType, \"assignment\")) {\n        ensureTyped(t, assign, rightType);\n    } else {\n        ensureTyped(t, assign);\n    }\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 840,
      "functionName": "visitAssign",
      "functionAnnotation": "",
      "functionDoc": "Visits an assignment \u003ccode\u003elvalue \u003d rvalue\u003c/code\u003e. If the\n\u003ccode\u003elvalue\u003c/code\u003e is a prototype modification, we change the schema\nof the object type it is referring to.\n\n@param t the traversal\n@param assign the assign node\n(\u003ccode\u003eassign.getType() \u003d\u003d Token.ASSIGN\u003c/code\u003e is an implicit invariant)\n",
      "diff": "@@ -1,73 +1,73 @@\n private void visitAssign(NodeTraversal t, Node assign) {\n     JSDocInfo info \u003d assign.getJSDocInfo();\n     Node lvalue \u003d assign.getFirstChild();\n     Node rvalue \u003d assign.getLastChild();\n     if (lvalue.getType() \u003d\u003d Token.GETPROP) {\n         Node object \u003d lvalue.getFirstChild();\n         JSType objectJsType \u003d getJSType(object);\n         String property \u003d lvalue.getLastChild().getString();\n         if (object.getType() \u003d\u003d Token.GETPROP) {\n             JSType jsType \u003d getJSType(object.getFirstChild());\n             if (jsType.isInterface() \u0026\u0026 object.getLastChild().getString().equals(\"prototype\")) {\n                 visitInterfaceGetprop(t, assign, object, property, lvalue, rvalue);\n             }\n         }\n         if (info !\u003d null \u0026\u0026 info.hasType()) {\n-            visitAnnotatedAssignGetprop(t, assign, info.getType().evaluate(t.getScope()), object, property, rvalue);\n+            visitAnnotatedAssignGetprop(t, assign, info.getType().evaluate(t.getScope(), typeRegistry), object, property, rvalue);\n             return;\n         }\n         if (info !\u003d null \u0026\u0026 info.hasEnumParameterType()) {\n-            checkEnumInitializer(t, rvalue, info.getEnumParameterType().evaluate(t.getScope()));\n+            checkEnumInitializer(t, rvalue, info.getEnumParameterType().evaluate(t.getScope(), typeRegistry));\n             return;\n         }\n         if (property.equals(\"prototype\")) {\n             if (objectJsType instanceof FunctionType) {\n                 FunctionType functionType \u003d (FunctionType) objectJsType;\n                 if (functionType.isConstructor()) {\n                     JSType rvalueType \u003d rvalue.getJSType();\n                     validator.expectObject(t, rvalue, rvalueType, OVERRIDING_PROTOTYPE_WITH_NON_OBJECT);\n                 }\n             } else {\n             }\n             return;\n         }\n         if (object.getType() \u003d\u003d Token.GETPROP) {\n             Node object2 \u003d object.getFirstChild();\n             String property2 \u003d NodeUtil.getStringValue(object.getLastChild());\n             if (\"prototype\".equals(property2)) {\n                 JSType jsType \u003d object2.getJSType();\n                 if (jsType instanceof FunctionType) {\n                     FunctionType functionType \u003d (FunctionType) jsType;\n                     if (functionType.isConstructor() || functionType.isInterface()) {\n                         checkDeclaredPropertyInheritance(t, assign, functionType, property, info, getJSType(rvalue));\n                     }\n                 } else {\n                 }\n                 return;\n             }\n         }\n         ObjectType type \u003d ObjectType.cast(objectJsType.restrictByNotNullOrUndefined());\n         if (type !\u003d null) {\n             if (type.hasProperty(property) \u0026\u0026 !type.isPropertyTypeInferred(property) \u0026\u0026 !propertyIsImplicitCast(type, property)) {\n                 validator.expectCanAssignToPropertyOf(t, assign, getJSType(rvalue), type.getPropertyType(property), object, property);\n             }\n             return;\n         }\n     } else if (lvalue.getType() \u003d\u003d Token.NAME) {\n         JSType rvalueType \u003d getJSType(assign.getLastChild());\n         Var var \u003d t.getScope().getVar(lvalue.getString());\n         if (var !\u003d null) {\n             if (var.isTypeInferred()) {\n                 return;\n             }\n         }\n     }\n     JSType leftType \u003d getJSType(lvalue);\n     Node rightChild \u003d assign.getLastChild();\n     JSType rightType \u003d getJSType(rightChild);\n     if (validator.expectCanAssignTo(t, assign, rightType, leftType, \"assignment\")) {\n         ensureTyped(t, assign, rightType);\n     } else {\n         ensureTyped(t, assign);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a2d8936fae3eb0e3873c7f7c0233344c81436404": {
      "type": "Ybodychange",
      "commitMessage": "Add warnings for functions that are ambiguously defined on different\nbrowsers.\n\nAdd better support for Caja.\n\nRollback the change to CoalesceVariableNames, because it had problems.\n\nInternal type system refactoring.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@33 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "12/15/09, 1:52 PM",
      "commitName": "a2d8936fae3eb0e3873c7f7c0233344c81436404",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "commitDateOld": "11/25/09, 6:53 AM",
      "commitNameOld": "3bee5d740c96572faea4b9fb8b632e0e07b13cbb",
      "commitAuthorOld": "nicholas.j.santos@gmail.com",
      "daysBetweenCommits": 20.29,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "actualSource": "private void visitAssign(NodeTraversal t, Node assign) {\n    JSDocInfo info \u003d assign.getJSDocInfo();\n    Node lvalue \u003d assign.getFirstChild();\n    Node rvalue \u003d assign.getLastChild();\n    if (lvalue.getType() \u003d\u003d Token.GETPROP) {\n        Node object \u003d lvalue.getFirstChild();\n        JSType objectJsType \u003d getJSType(object);\n        String property \u003d lvalue.getLastChild().getString();\n        if (object.getType() \u003d\u003d Token.GETPROP) {\n            JSType jsType \u003d getJSType(object.getFirstChild());\n            if (jsType.isInterface() \u0026\u0026 object.getLastChild().getString().equals(\"prototype\")) {\n                visitInterfaceGetprop(t, assign, object, property, lvalue, rvalue);\n            }\n        }\n        if (info !\u003d null \u0026\u0026 info.hasType()) {\n            visitAnnotatedAssignGetprop(t, assign, info.getType().evaluate(t.getScope()), object, property, rvalue);\n            return;\n        }\n        if (info !\u003d null \u0026\u0026 info.hasEnumParameterType()) {\n            checkEnumInitializer(t, rvalue, info.getEnumParameterType().evaluate(t.getScope()));\n            return;\n        }\n        if (property.equals(\"prototype\")) {\n            if (objectJsType instanceof FunctionType) {\n                FunctionType functionType \u003d (FunctionType) objectJsType;\n                if (functionType.isConstructor()) {\n                    JSType rvalueType \u003d rvalue.getJSType();\n                    validator.expectObject(t, rvalue, rvalueType, OVERRIDING_PROTOTYPE_WITH_NON_OBJECT);\n                }\n            } else {\n            }\n            return;\n        }\n        if (object.getType() \u003d\u003d Token.GETPROP) {\n            Node object2 \u003d object.getFirstChild();\n            String property2 \u003d NodeUtil.getStringValue(object.getLastChild());\n            if (\"prototype\".equals(property2)) {\n                JSType jsType \u003d object2.getJSType();\n                if (jsType instanceof FunctionType) {\n                    FunctionType functionType \u003d (FunctionType) jsType;\n                    if (functionType.isConstructor() || functionType.isInterface()) {\n                        checkDeclaredPropertyInheritance(t, assign, functionType, property, info, getJSType(rvalue));\n                    }\n                } else {\n                }\n                return;\n            }\n        }\n        ObjectType type \u003d ObjectType.cast(objectJsType.restrictByNotNullOrUndefined());\n        if (type !\u003d null) {\n            if (type.hasProperty(property) \u0026\u0026 !type.isPropertyTypeInferred(property) \u0026\u0026 !propertyIsImplicitCast(type, property)) {\n                validator.expectCanAssignToPropertyOf(t, assign, getJSType(rvalue), type.getPropertyType(property), object, property);\n            }\n            return;\n        }\n    } else if (lvalue.getType() \u003d\u003d Token.NAME) {\n        JSType rvalueType \u003d getJSType(assign.getLastChild());\n        Var var \u003d t.getScope().getVar(lvalue.getString());\n        if (var !\u003d null) {\n            if (var.isTypeInferred()) {\n                return;\n            }\n        }\n    }\n    JSType leftType \u003d getJSType(lvalue);\n    Node rightChild \u003d assign.getLastChild();\n    JSType rightType \u003d getJSType(rightChild);\n    if (validator.expectCanAssignTo(t, assign, rightType, leftType, \"assignment\")) {\n        ensureTyped(t, assign, rightType);\n    } else {\n        ensureTyped(t, assign);\n    }\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 810,
      "functionName": "visitAssign",
      "functionAnnotation": "",
      "functionDoc": "Visits an assignment \u003ccode\u003elvalue \u003d rvalue\u003c/code\u003e. If the\n\u003ccode\u003elvalue\u003c/code\u003e is a prototype modification, we change the schema\nof the object type it is referring to.\n\n@param t the traversal\n@param assign the assign node\n(\u003ccode\u003eassign.getType() \u003d\u003d Token.ASSIGN\u003c/code\u003e is an implicit invariant)\n",
      "diff": "@@ -1,76 +1,73 @@\n private void visitAssign(NodeTraversal t, Node assign) {\n     JSDocInfo info \u003d assign.getJSDocInfo();\n     Node lvalue \u003d assign.getFirstChild();\n     Node rvalue \u003d assign.getLastChild();\n     if (lvalue.getType() \u003d\u003d Token.GETPROP) {\n         Node object \u003d lvalue.getFirstChild();\n         JSType objectJsType \u003d getJSType(object);\n         String property \u003d lvalue.getLastChild().getString();\n         if (object.getType() \u003d\u003d Token.GETPROP) {\n             JSType jsType \u003d getJSType(object.getFirstChild());\n             if (jsType.isInterface() \u0026\u0026 object.getLastChild().getString().equals(\"prototype\")) {\n                 visitInterfaceGetprop(t, assign, object, property, lvalue, rvalue);\n             }\n         }\n         if (info !\u003d null \u0026\u0026 info.hasType()) {\n             visitAnnotatedAssignGetprop(t, assign, info.getType().evaluate(t.getScope()), object, property, rvalue);\n             return;\n         }\n         if (info !\u003d null \u0026\u0026 info.hasEnumParameterType()) {\n             checkEnumInitializer(t, rvalue, info.getEnumParameterType().evaluate(t.getScope()));\n             return;\n         }\n         if (property.equals(\"prototype\")) {\n             if (objectJsType instanceof FunctionType) {\n                 FunctionType functionType \u003d (FunctionType) objectJsType;\n                 if (functionType.isConstructor()) {\n                     JSType rvalueType \u003d rvalue.getJSType();\n                     validator.expectObject(t, rvalue, rvalueType, OVERRIDING_PROTOTYPE_WITH_NON_OBJECT);\n                 }\n             } else {\n             }\n             return;\n         }\n         if (object.getType() \u003d\u003d Token.GETPROP) {\n             Node object2 \u003d object.getFirstChild();\n             String property2 \u003d NodeUtil.getStringValue(object.getLastChild());\n             if (\"prototype\".equals(property2)) {\n                 JSType jsType \u003d object2.getJSType();\n                 if (jsType instanceof FunctionType) {\n                     FunctionType functionType \u003d (FunctionType) jsType;\n                     if (functionType.isConstructor() || functionType.isInterface()) {\n                         checkDeclaredPropertyInheritance(t, assign, functionType, property, info, getJSType(rvalue));\n                     }\n                 } else {\n                 }\n                 return;\n             }\n         }\n-        JSType type \u003d objectJsType.restrictByNotNullOrUndefined();\n-        if (type instanceof ObjectType) {\n-            ObjectType objectType \u003d (ObjectType) type;\n-            if (objectType.hasProperty(property)) {\n-                if (!objectType.isPropertyTypeInferred(property) \u0026\u0026 !propertyIsImplicitCast(objectType, property)) {\n-                    validator.expectCanAssignToPropertyOf(t, assign, getJSType(rvalue), objectType.getPropertyType(property), object, property);\n-                }\n+        ObjectType type \u003d ObjectType.cast(objectJsType.restrictByNotNullOrUndefined());\n+        if (type !\u003d null) {\n+            if (type.hasProperty(property) \u0026\u0026 !type.isPropertyTypeInferred(property) \u0026\u0026 !propertyIsImplicitCast(type, property)) {\n+                validator.expectCanAssignToPropertyOf(t, assign, getJSType(rvalue), type.getPropertyType(property), object, property);\n             }\n             return;\n         }\n     } else if (lvalue.getType() \u003d\u003d Token.NAME) {\n         JSType rvalueType \u003d getJSType(assign.getLastChild());\n         Var var \u003d t.getScope().getVar(lvalue.getString());\n         if (var !\u003d null) {\n             if (var.isTypeInferred()) {\n                 return;\n             }\n         }\n     }\n     JSType leftType \u003d getJSType(lvalue);\n     Node rightChild \u003d assign.getLastChild();\n     JSType rightType \u003d getJSType(rightChild);\n     if (validator.expectCanAssignTo(t, assign, rightType, leftType, \"assignment\")) {\n         ensureTyped(t, assign, rightType);\n     } else {\n         ensureTyped(t, assign);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": {
      "type": "Yintroduced",
      "commitMessage": "Initial commit.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/3/09, 3:51 PM",
      "commitName": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "diff": "@@ -0,0 +1,76 @@\n+private void visitAssign(NodeTraversal t, Node assign) {\n+    JSDocInfo info \u003d assign.getJSDocInfo();\n+    Node lvalue \u003d assign.getFirstChild();\n+    Node rvalue \u003d assign.getLastChild();\n+    if (lvalue.getType() \u003d\u003d Token.GETPROP) {\n+        Node object \u003d lvalue.getFirstChild();\n+        JSType objectJsType \u003d getJSType(object);\n+        String property \u003d lvalue.getLastChild().getString();\n+        if (object.getType() \u003d\u003d Token.GETPROP) {\n+            JSType jsType \u003d getJSType(object.getFirstChild());\n+            if (jsType.isInterface() \u0026\u0026 object.getLastChild().getString().equals(\"prototype\")) {\n+                visitInterfaceGetprop(t, assign, object, property, lvalue, rvalue);\n+            }\n+        }\n+        if (info !\u003d null \u0026\u0026 info.hasType()) {\n+            visitAnnotatedAssignGetprop(t, assign, info.getType().evaluate(t.getScope()), object, property, rvalue);\n+            return;\n+        }\n+        if (info !\u003d null \u0026\u0026 info.hasEnumParameterType()) {\n+            checkEnumInitializer(t, rvalue, info.getEnumParameterType().evaluate(t.getScope()));\n+            return;\n+        }\n+        if (property.equals(\"prototype\")) {\n+            if (objectJsType instanceof FunctionType) {\n+                FunctionType functionType \u003d (FunctionType) objectJsType;\n+                if (functionType.isConstructor()) {\n+                    JSType rvalueType \u003d rvalue.getJSType();\n+                    validator.expectObject(t, rvalue, rvalueType, OVERRIDING_PROTOTYPE_WITH_NON_OBJECT);\n+                }\n+            } else {\n+            }\n+            return;\n+        }\n+        if (object.getType() \u003d\u003d Token.GETPROP) {\n+            Node object2 \u003d object.getFirstChild();\n+            String property2 \u003d NodeUtil.getStringValue(object.getLastChild());\n+            if (\"prototype\".equals(property2)) {\n+                JSType jsType \u003d object2.getJSType();\n+                if (jsType instanceof FunctionType) {\n+                    FunctionType functionType \u003d (FunctionType) jsType;\n+                    if (functionType.isConstructor() || functionType.isInterface()) {\n+                        checkDeclaredPropertyInheritance(t, assign, functionType, property, info, getJSType(rvalue));\n+                    }\n+                } else {\n+                }\n+                return;\n+            }\n+        }\n+        JSType type \u003d objectJsType.restrictByNotNullOrUndefined();\n+        if (type instanceof ObjectType) {\n+            ObjectType objectType \u003d (ObjectType) type;\n+            if (objectType.hasProperty(property)) {\n+                if (!objectType.isPropertyTypeInferred(property) \u0026\u0026 !propertyIsImplicitCast(objectType, property)) {\n+                    validator.expectCanAssignToPropertyOf(t, assign, getJSType(rvalue), objectType.getPropertyType(property), object, property);\n+                }\n+            }\n+            return;\n+        }\n+    } else if (lvalue.getType() \u003d\u003d Token.NAME) {\n+        JSType rvalueType \u003d getJSType(assign.getLastChild());\n+        Var var \u003d t.getScope().getVar(lvalue.getString());\n+        if (var !\u003d null) {\n+            if (var.isTypeInferred()) {\n+                return;\n+            }\n+        }\n+    }\n+    JSType leftType \u003d getJSType(lvalue);\n+    Node rightChild \u003d assign.getLastChild();\n+    JSType rightType \u003d getJSType(rightChild);\n+    if (validator.expectCanAssignTo(t, assign, rightType, leftType, \"assignment\")) {\n+        ensureTyped(t, assign, rightType);\n+    } else {\n+        ensureTyped(t, assign);\n+    }\n+}\n\\ No newline at end of file\n",
      "actualSource": "private void visitAssign(NodeTraversal t, Node assign) {\n    JSDocInfo info \u003d assign.getJSDocInfo();\n    Node lvalue \u003d assign.getFirstChild();\n    Node rvalue \u003d assign.getLastChild();\n    if (lvalue.getType() \u003d\u003d Token.GETPROP) {\n        Node object \u003d lvalue.getFirstChild();\n        JSType objectJsType \u003d getJSType(object);\n        String property \u003d lvalue.getLastChild().getString();\n        if (object.getType() \u003d\u003d Token.GETPROP) {\n            JSType jsType \u003d getJSType(object.getFirstChild());\n            if (jsType.isInterface() \u0026\u0026 object.getLastChild().getString().equals(\"prototype\")) {\n                visitInterfaceGetprop(t, assign, object, property, lvalue, rvalue);\n            }\n        }\n        if (info !\u003d null \u0026\u0026 info.hasType()) {\n            visitAnnotatedAssignGetprop(t, assign, info.getType().evaluate(t.getScope()), object, property, rvalue);\n            return;\n        }\n        if (info !\u003d null \u0026\u0026 info.hasEnumParameterType()) {\n            checkEnumInitializer(t, rvalue, info.getEnumParameterType().evaluate(t.getScope()));\n            return;\n        }\n        if (property.equals(\"prototype\")) {\n            if (objectJsType instanceof FunctionType) {\n                FunctionType functionType \u003d (FunctionType) objectJsType;\n                if (functionType.isConstructor()) {\n                    JSType rvalueType \u003d rvalue.getJSType();\n                    validator.expectObject(t, rvalue, rvalueType, OVERRIDING_PROTOTYPE_WITH_NON_OBJECT);\n                }\n            } else {\n            }\n            return;\n        }\n        if (object.getType() \u003d\u003d Token.GETPROP) {\n            Node object2 \u003d object.getFirstChild();\n            String property2 \u003d NodeUtil.getStringValue(object.getLastChild());\n            if (\"prototype\".equals(property2)) {\n                JSType jsType \u003d object2.getJSType();\n                if (jsType instanceof FunctionType) {\n                    FunctionType functionType \u003d (FunctionType) jsType;\n                    if (functionType.isConstructor() || functionType.isInterface()) {\n                        checkDeclaredPropertyInheritance(t, assign, functionType, property, info, getJSType(rvalue));\n                    }\n                } else {\n                }\n                return;\n            }\n        }\n        JSType type \u003d objectJsType.restrictByNotNullOrUndefined();\n        if (type instanceof ObjectType) {\n            ObjectType objectType \u003d (ObjectType) type;\n            if (objectType.hasProperty(property)) {\n                if (!objectType.isPropertyTypeInferred(property) \u0026\u0026 !propertyIsImplicitCast(objectType, property)) {\n                    validator.expectCanAssignToPropertyOf(t, assign, getJSType(rvalue), objectType.getPropertyType(property), object, property);\n                }\n            }\n            return;\n        }\n    } else if (lvalue.getType() \u003d\u003d Token.NAME) {\n        JSType rvalueType \u003d getJSType(assign.getLastChild());\n        Var var \u003d t.getScope().getVar(lvalue.getString());\n        if (var !\u003d null) {\n            if (var.isTypeInferred()) {\n                return;\n            }\n        }\n    }\n    JSType leftType \u003d getJSType(lvalue);\n    Node rightChild \u003d assign.getLastChild();\n    JSType rightType \u003d getJSType(rightChild);\n    if (validator.expectCanAssignTo(t, assign, rightType, leftType, \"assignment\")) {\n        ensureTyped(t, assign, rightType);\n    } else {\n        ensureTyped(t, assign);\n    }\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 810,
      "functionName": "visitAssign",
      "functionAnnotation": "",
      "functionDoc": "Visits an assignment \u003ccode\u003elvalue \u003d rvalue\u003c/code\u003e. If the\n\u003ccode\u003elvalue\u003c/code\u003e is a prototype modification, we change the schema\nof the object type it is referring to.\n\n@param t the traversal\n@param assign the assign node\n(\u003ccode\u003eassign.getType() \u003d\u003d Token.ASSIGN\u003c/code\u003e is an implicit invariant)\n"
    }
  }
}