{
  "origin": "codeshovel",
  "repositoryName": "Closure-33b",
  "repositoryPath": "/tmp/Closure-33b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "TypeInference.java",
  "functionName": "tightenTypesAfterAssertions",
  "functionId": "tightenTypesAfterAssertions___scope-FlowScope__callNode-Node",
  "sourceFilePath": "src/com/google/javascript/jscomp/TypeInference.java",
  "functionAnnotation": "",
  "functionDoc": "",
  "functionStartLine": 799,
  "functionEndLine": 841,
  "numCommitsSeen": 69,
  "timeTaken": 4663,
  "changeHistory": [
    "ec324a9bb23eb78c76f537f4c4170ba88d542f1c",
    "de684ba3efacbeb36f741eb8ed1598cf34df7783",
    "96844d11db95fd7a948dd1cc3d2ef7cb4e03e710",
    "660e7b525f76cd64d10ccc8724a1b0e0c501d1d9",
    "279196b617c5de1ade21110979b6b13d8eda6342"
  ],
  "changeHistoryShort": {
    "ec324a9bb23eb78c76f537f4c4170ba88d542f1c": "Ybodychange",
    "de684ba3efacbeb36f741eb8ed1598cf34df7783": "Ybodychange",
    "96844d11db95fd7a948dd1cc3d2ef7cb4e03e710": "Ybodychange",
    "660e7b525f76cd64d10ccc8724a1b0e0c501d1d9": "Ybodychange",
    "279196b617c5de1ade21110979b6b13d8eda6342": "Yintroduced"
  },
  "changeHistoryDetails": {
    "ec324a9bb23eb78c76f537f4c4170ba88d542f1c": {
      "type": "Ybodychange",
      "commitMessage": "\nReplace the bulk of the Node.getType() \u003d\u003d Token.XXX calls with\nNode.isXXX calls.\n\nR\u003dnicksantos\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3677\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1582 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/10/11, 8:36 AM",
      "commitName": "ec324a9bb23eb78c76f537f4c4170ba88d542f1c",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "11/7/11, 2:21 PM",
      "commitNameOld": "6641663fa9970c4d7bcdd96a6f31b83b18c3ee3d",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 2.76,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "actualSource": "private FlowScope tightenTypesAfterAssertions(FlowScope scope, Node callNode) {\n    Node left \u003d callNode.getFirstChild();\n    Node firstParam \u003d left.getNext();\n    AssertionFunctionSpec assertionFunctionSpec \u003d assertionFunctionsMap.get(left.getQualifiedName());\n    if (assertionFunctionSpec \u003d\u003d null || firstParam \u003d\u003d null) {\n        return scope;\n    }\n    Node assertedNode \u003d assertionFunctionSpec.getAssertedParam(firstParam);\n    if (assertedNode \u003d\u003d null) {\n        return scope;\n    }\n    JSTypeNative assertedType \u003d assertionFunctionSpec.getAssertedType();\n    String assertedNodeName \u003d assertedNode.getQualifiedName();\n    if (assertedType \u003d\u003d null) {\n        if (assertedNodeName !\u003d null) {\n            JSType type \u003d getJSType(assertedNode);\n            JSType narrowed \u003d type.restrictByNotNullOrUndefined();\n            if (type !\u003d narrowed) {\n                scope \u003d narrowScope(scope, assertedNode, narrowed);\n                callNode.setJSType(narrowed);\n            }\n        } else if (assertedNode.isAnd() || assertedNode.isOr()) {\n            BooleanOutcomePair conditionOutcomes \u003d traverseWithinShortCircuitingBinOp(assertedNode, scope);\n            scope \u003d reverseInterpreter.getPreciserScopeKnowingConditionOutcome(assertedNode, conditionOutcomes.getOutcomeFlowScope(assertedNode.getType(), true), true);\n        }\n    } else if (assertedNodeName !\u003d null) {\n        JSType type \u003d getJSType(assertedNode);\n        JSType narrowed \u003d type.getGreatestSubtype(getNativeType(assertedType));\n        if (type !\u003d narrowed) {\n            scope \u003d narrowScope(scope, assertedNode, narrowed);\n            callNode.setJSType(narrowed);\n        }\n    }\n    return scope;\n}",
      "path": "src/com/google/javascript/jscomp/TypeInference.java",
      "functionStartLine": 760,
      "functionName": "tightenTypesAfterAssertions",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,35 +1,35 @@\n private FlowScope tightenTypesAfterAssertions(FlowScope scope, Node callNode) {\n     Node left \u003d callNode.getFirstChild();\n     Node firstParam \u003d left.getNext();\n     AssertionFunctionSpec assertionFunctionSpec \u003d assertionFunctionsMap.get(left.getQualifiedName());\n     if (assertionFunctionSpec \u003d\u003d null || firstParam \u003d\u003d null) {\n         return scope;\n     }\n     Node assertedNode \u003d assertionFunctionSpec.getAssertedParam(firstParam);\n     if (assertedNode \u003d\u003d null) {\n         return scope;\n     }\n     JSTypeNative assertedType \u003d assertionFunctionSpec.getAssertedType();\n     String assertedNodeName \u003d assertedNode.getQualifiedName();\n     if (assertedType \u003d\u003d null) {\n         if (assertedNodeName !\u003d null) {\n             JSType type \u003d getJSType(assertedNode);\n             JSType narrowed \u003d type.restrictByNotNullOrUndefined();\n             if (type !\u003d narrowed) {\n                 scope \u003d narrowScope(scope, assertedNode, narrowed);\n                 callNode.setJSType(narrowed);\n             }\n-        } else if (assertedNode.getType() \u003d\u003d Token.AND || assertedNode.getType() \u003d\u003d Token.OR) {\n+        } else if (assertedNode.isAnd() || assertedNode.isOr()) {\n             BooleanOutcomePair conditionOutcomes \u003d traverseWithinShortCircuitingBinOp(assertedNode, scope);\n             scope \u003d reverseInterpreter.getPreciserScopeKnowingConditionOutcome(assertedNode, conditionOutcomes.getOutcomeFlowScope(assertedNode.getType(), true), true);\n         }\n     } else if (assertedNodeName !\u003d null) {\n         JSType type \u003d getJSType(assertedNode);\n         JSType narrowed \u003d type.getGreatestSubtype(getNativeType(assertedType));\n         if (type !\u003d narrowed) {\n             scope \u003d narrowScope(scope, assertedNode, narrowed);\n             callNode.setJSType(narrowed);\n         }\n     }\n     return scope;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "de684ba3efacbeb36f741eb8ed1598cf34df7783": {
      "type": "Ybodychange",
      "commitMessage": "\ndereference all qualified names, not just simple ones\nFixes issue 483\n\nR\u003dacleung\nDELTA\u003d41  (30 added, 3 deleted, 8 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d2680\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1273 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "7/19/11, 4:09 PM",
      "commitName": "de684ba3efacbeb36f741eb8ed1598cf34df7783",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "7/1/11, 2:00 PM",
      "commitNameOld": "03ce555bcedcf98d99de1b4f8a6238ba75ee6850",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 18.09,
      "commitsBetweenForRepo": 27,
      "commitsBetweenForFile": 1,
      "actualSource": "private FlowScope tightenTypesAfterAssertions(FlowScope scope, Node callNode) {\n    Node left \u003d callNode.getFirstChild();\n    Node firstParam \u003d left.getNext();\n    AssertionFunctionSpec assertionFunctionSpec \u003d assertionFunctionsMap.get(left.getQualifiedName());\n    if (assertionFunctionSpec \u003d\u003d null || firstParam \u003d\u003d null) {\n        return scope;\n    }\n    Node assertedNode \u003d assertionFunctionSpec.getAssertedParam(firstParam);\n    if (assertedNode \u003d\u003d null) {\n        return scope;\n    }\n    JSTypeNative assertedType \u003d assertionFunctionSpec.getAssertedType();\n    String assertedNodeName \u003d assertedNode.getQualifiedName();\n    if (assertedType \u003d\u003d null) {\n        if (assertedNodeName !\u003d null) {\n            JSType type \u003d getJSType(assertedNode);\n            JSType narrowed \u003d type.restrictByNotNullOrUndefined();\n            if (type !\u003d narrowed) {\n                scope \u003d narrowScope(scope, assertedNode, narrowed);\n                callNode.setJSType(narrowed);\n            }\n        } else if (assertedNode.getType() \u003d\u003d Token.AND || assertedNode.getType() \u003d\u003d Token.OR) {\n            BooleanOutcomePair conditionOutcomes \u003d traverseWithinShortCircuitingBinOp(assertedNode, scope);\n            scope \u003d reverseInterpreter.getPreciserScopeKnowingConditionOutcome(assertedNode, conditionOutcomes.getOutcomeFlowScope(assertedNode.getType(), true), true);\n        }\n    } else if (assertedNodeName !\u003d null) {\n        JSType type \u003d getJSType(assertedNode);\n        JSType narrowed \u003d type.getGreatestSubtype(getNativeType(assertedType));\n        if (type !\u003d narrowed) {\n            scope \u003d narrowScope(scope, assertedNode, narrowed);\n            callNode.setJSType(narrowed);\n        }\n    }\n    return scope;\n}",
      "path": "src/com/google/javascript/jscomp/TypeInference.java",
      "functionStartLine": 817,
      "functionName": "tightenTypesAfterAssertions",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,37 +1,35 @@\n private FlowScope tightenTypesAfterAssertions(FlowScope scope, Node callNode) {\n     Node left \u003d callNode.getFirstChild();\n     Node firstParam \u003d left.getNext();\n     AssertionFunctionSpec assertionFunctionSpec \u003d assertionFunctionsMap.get(left.getQualifiedName());\n     if (assertionFunctionSpec \u003d\u003d null || firstParam \u003d\u003d null) {\n         return scope;\n     }\n     Node assertedNode \u003d assertionFunctionSpec.getAssertedParam(firstParam);\n     if (assertedNode \u003d\u003d null) {\n         return scope;\n     }\n     JSTypeNative assertedType \u003d assertionFunctionSpec.getAssertedType();\n     String assertedNodeName \u003d assertedNode.getQualifiedName();\n     if (assertedType \u003d\u003d null) {\n         if (assertedNodeName !\u003d null) {\n             JSType type \u003d getJSType(assertedNode);\n             JSType narrowed \u003d type.restrictByNotNullOrUndefined();\n             if (type !\u003d narrowed) {\n-                scope \u003d scope.createChildFlowScope();\n-                redeclare(scope, assertedNodeName, narrowed);\n+                scope \u003d narrowScope(scope, assertedNode, narrowed);\n                 callNode.setJSType(narrowed);\n             }\n         } else if (assertedNode.getType() \u003d\u003d Token.AND || assertedNode.getType() \u003d\u003d Token.OR) {\n             BooleanOutcomePair conditionOutcomes \u003d traverseWithinShortCircuitingBinOp(assertedNode, scope);\n             scope \u003d reverseInterpreter.getPreciserScopeKnowingConditionOutcome(assertedNode, conditionOutcomes.getOutcomeFlowScope(assertedNode.getType(), true), true);\n         }\n     } else if (assertedNodeName !\u003d null) {\n         JSType type \u003d getJSType(assertedNode);\n         JSType narrowed \u003d type.getGreatestSubtype(getNativeType(assertedType));\n         if (type !\u003d narrowed) {\n-            scope \u003d scope.createChildFlowScope();\n-            redeclare(scope, assertedNodeName, narrowed);\n+            scope \u003d narrowScope(scope, assertedNode, narrowed);\n             callNode.setJSType(narrowed);\n         }\n     }\n     return scope;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "96844d11db95fd7a948dd1cc3d2ef7cb4e03e710": {
      "type": "Ybodychange",
      "commitMessage": "\nAdd return types to goog.asserts functions.\n\nR\u003dagrieve\nDELTA\u003d31  (31 added, 0 deleted, 0 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d66001\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@310 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "7/26/10, 4:02 PM",
      "commitName": "96844d11db95fd7a948dd1cc3d2ef7cb4e03e710",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "7/14/10, 3:50 PM",
      "commitNameOld": "6bf3a6410d71c3da0ea29c8ca425962d284f361c",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 12.01,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "actualSource": "private FlowScope tightenTypesAfterAssertions(FlowScope scope, Node callNode) {\n    Node left \u003d callNode.getFirstChild();\n    Node firstParam \u003d left.getNext();\n    AssertionFunctionSpec assertionFunctionSpec \u003d assertionFunctionsMap.get(left.getQualifiedName());\n    if (assertionFunctionSpec \u003d\u003d null || firstParam \u003d\u003d null) {\n        return scope;\n    }\n    Node assertedNode \u003d assertionFunctionSpec.getAssertedParam(firstParam);\n    if (assertedNode \u003d\u003d null) {\n        return scope;\n    }\n    JSTypeNative assertedType \u003d assertionFunctionSpec.getAssertedType();\n    String assertedNodeName \u003d assertedNode.getQualifiedName();\n    if (assertedType \u003d\u003d null) {\n        if (assertedNodeName !\u003d null) {\n            JSType type \u003d getJSType(assertedNode);\n            JSType narrowed \u003d type.restrictByNotNullOrUndefined();\n            if (type !\u003d narrowed) {\n                scope \u003d scope.createChildFlowScope();\n                redeclare(scope, assertedNodeName, narrowed);\n                callNode.setJSType(narrowed);\n            }\n        } else if (assertedNode.getType() \u003d\u003d Token.AND || assertedNode.getType() \u003d\u003d Token.OR) {\n            BooleanOutcomePair conditionOutcomes \u003d traverseWithinShortCircuitingBinOp(assertedNode, scope);\n            scope \u003d reverseInterpreter.getPreciserScopeKnowingConditionOutcome(assertedNode, conditionOutcomes.getOutcomeFlowScope(assertedNode.getType(), true), true);\n        }\n    } else if (assertedNodeName !\u003d null) {\n        JSType type \u003d getJSType(assertedNode);\n        JSType narrowed \u003d type.getGreatestSubtype(getNativeType(assertedType));\n        if (type !\u003d narrowed) {\n            scope \u003d scope.createChildFlowScope();\n            redeclare(scope, assertedNodeName, narrowed);\n            callNode.setJSType(narrowed);\n        }\n    }\n    return scope;\n}",
      "path": "src/com/google/javascript/jscomp/TypeInference.java",
      "functionStartLine": 800,
      "functionName": "tightenTypesAfterAssertions",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,35 +1,37 @@\n private FlowScope tightenTypesAfterAssertions(FlowScope scope, Node callNode) {\n     Node left \u003d callNode.getFirstChild();\n     Node firstParam \u003d left.getNext();\n     AssertionFunctionSpec assertionFunctionSpec \u003d assertionFunctionsMap.get(left.getQualifiedName());\n     if (assertionFunctionSpec \u003d\u003d null || firstParam \u003d\u003d null) {\n         return scope;\n     }\n     Node assertedNode \u003d assertionFunctionSpec.getAssertedParam(firstParam);\n     if (assertedNode \u003d\u003d null) {\n         return scope;\n     }\n     JSTypeNative assertedType \u003d assertionFunctionSpec.getAssertedType();\n     String assertedNodeName \u003d assertedNode.getQualifiedName();\n     if (assertedType \u003d\u003d null) {\n         if (assertedNodeName !\u003d null) {\n             JSType type \u003d getJSType(assertedNode);\n             JSType narrowed \u003d type.restrictByNotNullOrUndefined();\n             if (type !\u003d narrowed) {\n                 scope \u003d scope.createChildFlowScope();\n                 redeclare(scope, assertedNodeName, narrowed);\n+                callNode.setJSType(narrowed);\n             }\n         } else if (assertedNode.getType() \u003d\u003d Token.AND || assertedNode.getType() \u003d\u003d Token.OR) {\n             BooleanOutcomePair conditionOutcomes \u003d traverseWithinShortCircuitingBinOp(assertedNode, scope);\n             scope \u003d reverseInterpreter.getPreciserScopeKnowingConditionOutcome(assertedNode, conditionOutcomes.getOutcomeFlowScope(assertedNode.getType(), true), true);\n         }\n     } else if (assertedNodeName !\u003d null) {\n         JSType type \u003d getJSType(assertedNode);\n         JSType narrowed \u003d type.getGreatestSubtype(getNativeType(assertedType));\n         if (type !\u003d narrowed) {\n             scope \u003d scope.createChildFlowScope();\n             redeclare(scope, assertedNodeName, narrowed);\n+            callNode.setJSType(narrowed);\n         }\n     }\n     return scope;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "660e7b525f76cd64d10ccc8724a1b0e0c501d1d9": {
      "type": "Ybodychange",
      "commitMessage": "\nChange on 2010/07/13 09:58:55 by johnlenz\n\n        Change source map generation so that runs in O(n) time. Source map\n        generation is now roughly the time it takes to write the bytes to disk.\n\n        R\u003dacleung\n        DELTA\u003d820  (508 added, 270 deleted, 42 changed)\n\nChange on 2010/07/13 11:14:56 by acleung\n\n        Google Analytics Externs Contribution\n\n        R\u003dbkuhn,nicksantos\n        DELTA\u003d438  (438 added, 0 deleted, 0 changed)\n\nChange on 2010/07/13 11:37:57 by nicksantos\n\n        Fix goog.scope processing so that it works even if an alias\n        shadows a global variable.\n\n        R\u003drobbyw\n        DELTA\u003d28  (16 added, 3 deleted, 9 changed)\n\nChange on 2010/07/13 12:45:31 by nicksantos\n\n        fix a silly bug where an assignment of a name is interpreted\n        as an assignment to a name.\n\n        R\u003drobbyw\n        DELTA\u003d7  (6 added, 0 deleted, 1 changed)\n\nChange on 2010/07/13 14:02:13 by nicksantos\n\n        Make the goog.asserts functions work better for qualified names\n        (like x.y).\n\n        R\u003dagrieve\n        DELTA\u003d37  (17 added, 3 deleted, 17 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d50006\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@274 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "7/13/10, 3:28 PM",
      "commitName": "660e7b525f76cd64d10ccc8724a1b0e0c501d1d9",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "5/5/10, 4:36 PM",
      "commitNameOld": "279196b617c5de1ade21110979b6b13d8eda6342",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 68.95,
      "commitsBetweenForRepo": 59,
      "commitsBetweenForFile": 1,
      "actualSource": "private FlowScope tightenTypesAfterAssertions(FlowScope scope, Node callNode) {\n    Node left \u003d callNode.getFirstChild();\n    Node firstParam \u003d left.getNext();\n    AssertionFunctionSpec assertionFunctionSpec \u003d assertionFunctionsMap.get(left.getQualifiedName());\n    if (assertionFunctionSpec \u003d\u003d null || firstParam \u003d\u003d null) {\n        return scope;\n    }\n    Node assertedNode \u003d assertionFunctionSpec.getAssertedParam(firstParam);\n    if (assertedNode \u003d\u003d null) {\n        return scope;\n    }\n    JSTypeNative assertedType \u003d assertionFunctionSpec.getAssertedType();\n    String assertedNodeName \u003d assertedNode.getQualifiedName();\n    if (assertedType \u003d\u003d null) {\n        if (assertedNodeName !\u003d null) {\n            JSType type \u003d getJSType(assertedNode);\n            JSType narrowed \u003d type.restrictByNotNullOrUndefined();\n            if (type !\u003d narrowed) {\n                scope \u003d scope.createChildFlowScope();\n                redeclare(scope, assertedNodeName, narrowed);\n            }\n        } else if (assertedNode.getType() \u003d\u003d Token.AND || assertedNode.getType() \u003d\u003d Token.OR) {\n            BooleanOutcomePair conditionOutcomes \u003d traverseWithinShortCircuitingBinOp(assertedNode, scope);\n            scope \u003d reverseInterpreter.getPreciserScopeKnowingConditionOutcome(assertedNode, conditionOutcomes.getOutcomeFlowScope(assertedNode.getType(), true), true);\n        }\n    } else if (assertedNodeName !\u003d null) {\n        JSType type \u003d getJSType(assertedNode);\n        JSType narrowed \u003d type.getGreatestSubtype(getNativeType(assertedType));\n        if (type !\u003d narrowed) {\n            scope \u003d scope.createChildFlowScope();\n            redeclare(scope, assertedNodeName, narrowed);\n        }\n    }\n    return scope;\n}",
      "path": "src/com/google/javascript/jscomp/TypeInference.java",
      "functionStartLine": 797,
      "functionName": "tightenTypesAfterAssertions",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,38 +1,35 @@\n private FlowScope tightenTypesAfterAssertions(FlowScope scope, Node callNode) {\n     Node left \u003d callNode.getFirstChild();\n     Node firstParam \u003d left.getNext();\n     AssertionFunctionSpec assertionFunctionSpec \u003d assertionFunctionsMap.get(left.getQualifiedName());\n     if (assertionFunctionSpec \u003d\u003d null || firstParam \u003d\u003d null) {\n         return scope;\n     }\n     Node assertedNode \u003d assertionFunctionSpec.getAssertedParam(firstParam);\n     if (assertedNode \u003d\u003d null) {\n         return scope;\n     }\n     JSTypeNative assertedType \u003d assertionFunctionSpec.getAssertedType();\n+    String assertedNodeName \u003d assertedNode.getQualifiedName();\n     if (assertedType \u003d\u003d null) {\n-        switch(assertedNode.getType()) {\n-            case Token.NAME:\n-                JSType type \u003d getJSType(assertedNode);\n-                JSType narrowed \u003d type.restrictByNotNullOrUndefined();\n-                if (type !\u003d narrowed) {\n-                    scope \u003d scope.createChildFlowScope();\n-                    redeclare(scope, assertedNode.getString(), narrowed);\n-                }\n-                break;\n-            case Token.AND:\n-            case Token.OR:\n-                BooleanOutcomePair conditionOutcomes \u003d traverseWithinShortCircuitingBinOp(assertedNode, scope);\n-                scope \u003d reverseInterpreter.getPreciserScopeKnowingConditionOutcome(assertedNode, conditionOutcomes.getOutcomeFlowScope(assertedNode.getType(), true), true);\n-                break;\n+        if (assertedNodeName !\u003d null) {\n+            JSType type \u003d getJSType(assertedNode);\n+            JSType narrowed \u003d type.restrictByNotNullOrUndefined();\n+            if (type !\u003d narrowed) {\n+                scope \u003d scope.createChildFlowScope();\n+                redeclare(scope, assertedNodeName, narrowed);\n+            }\n+        } else if (assertedNode.getType() \u003d\u003d Token.AND || assertedNode.getType() \u003d\u003d Token.OR) {\n+            BooleanOutcomePair conditionOutcomes \u003d traverseWithinShortCircuitingBinOp(assertedNode, scope);\n+            scope \u003d reverseInterpreter.getPreciserScopeKnowingConditionOutcome(assertedNode, conditionOutcomes.getOutcomeFlowScope(assertedNode.getType(), true), true);\n         }\n-    } else if (assertedNode.getType() \u003d\u003d Token.NAME) {\n+    } else if (assertedNodeName !\u003d null) {\n         JSType type \u003d getJSType(assertedNode);\n         JSType narrowed \u003d type.getGreatestSubtype(getNativeType(assertedType));\n         if (type !\u003d narrowed) {\n             scope \u003d scope.createChildFlowScope();\n-            redeclare(scope, assertedNode.getString(), narrowed);\n+            redeclare(scope, assertedNodeName, narrowed);\n         }\n     }\n     return scope;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "279196b617c5de1ade21110979b6b13d8eda6342": {
      "type": "Yintroduced",
      "commitMessage": "\nChange on 2010/05/04 by nick\n\n        Pipe everything through the module code path.\n        This teases out a bunch of edge-case bugs that worked in the non-module\n        code path, but not the module code path (and vice-versa)\n\n        R\u003dalan\n        DELTA\u003d136  (67 added, 19 deleted, 50 changed)\n\nChange on 2010/05/04 by nick\n\n        fiddle with the check_global_this_level decision tree\n        This should be off by default if collapse_properties is off,\n        and on by default if collapse_properties is on.\n\n        R\u003dalan\n        DELTA\u003d47  (32 added, 4 deleted, 11 changed)\n\nChange on 2010/05/04 by andrew\n\n        -Infer that arguments to goog.asserts.assert() are non-nullable after the\n        call.\n        -Infer the types of arguments to goog.asserts.assert{String,Number,...} after\n        the call.\n\n        Tested:\n          -Added new unit tests.\n\n        R\u003dnick\n        DELTA\u003d277  (266 added, 4 deleted, 7 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003dqdhuno\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@203 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "5/5/10, 4:36 PM",
      "commitName": "279196b617c5de1ade21110979b6b13d8eda6342",
      "commitAuthor": "Nicholas.J.Santos",
      "diff": "@@ -0,0 +1,38 @@\n+private FlowScope tightenTypesAfterAssertions(FlowScope scope, Node callNode) {\n+    Node left \u003d callNode.getFirstChild();\n+    Node firstParam \u003d left.getNext();\n+    AssertionFunctionSpec assertionFunctionSpec \u003d assertionFunctionsMap.get(left.getQualifiedName());\n+    if (assertionFunctionSpec \u003d\u003d null || firstParam \u003d\u003d null) {\n+        return scope;\n+    }\n+    Node assertedNode \u003d assertionFunctionSpec.getAssertedParam(firstParam);\n+    if (assertedNode \u003d\u003d null) {\n+        return scope;\n+    }\n+    JSTypeNative assertedType \u003d assertionFunctionSpec.getAssertedType();\n+    if (assertedType \u003d\u003d null) {\n+        switch(assertedNode.getType()) {\n+            case Token.NAME:\n+                JSType type \u003d getJSType(assertedNode);\n+                JSType narrowed \u003d type.restrictByNotNullOrUndefined();\n+                if (type !\u003d narrowed) {\n+                    scope \u003d scope.createChildFlowScope();\n+                    redeclare(scope, assertedNode.getString(), narrowed);\n+                }\n+                break;\n+            case Token.AND:\n+            case Token.OR:\n+                BooleanOutcomePair conditionOutcomes \u003d traverseWithinShortCircuitingBinOp(assertedNode, scope);\n+                scope \u003d reverseInterpreter.getPreciserScopeKnowingConditionOutcome(assertedNode, conditionOutcomes.getOutcomeFlowScope(assertedNode.getType(), true), true);\n+                break;\n+        }\n+    } else if (assertedNode.getType() \u003d\u003d Token.NAME) {\n+        JSType type \u003d getJSType(assertedNode);\n+        JSType narrowed \u003d type.getGreatestSubtype(getNativeType(assertedType));\n+        if (type !\u003d narrowed) {\n+            scope \u003d scope.createChildFlowScope();\n+            redeclare(scope, assertedNode.getString(), narrowed);\n+        }\n+    }\n+    return scope;\n+}\n\\ No newline at end of file\n",
      "actualSource": "private FlowScope tightenTypesAfterAssertions(FlowScope scope, Node callNode) {\n    Node left \u003d callNode.getFirstChild();\n    Node firstParam \u003d left.getNext();\n    AssertionFunctionSpec assertionFunctionSpec \u003d assertionFunctionsMap.get(left.getQualifiedName());\n    if (assertionFunctionSpec \u003d\u003d null || firstParam \u003d\u003d null) {\n        return scope;\n    }\n    Node assertedNode \u003d assertionFunctionSpec.getAssertedParam(firstParam);\n    if (assertedNode \u003d\u003d null) {\n        return scope;\n    }\n    JSTypeNative assertedType \u003d assertionFunctionSpec.getAssertedType();\n    if (assertedType \u003d\u003d null) {\n        switch(assertedNode.getType()) {\n            case Token.NAME:\n                JSType type \u003d getJSType(assertedNode);\n                JSType narrowed \u003d type.restrictByNotNullOrUndefined();\n                if (type !\u003d narrowed) {\n                    scope \u003d scope.createChildFlowScope();\n                    redeclare(scope, assertedNode.getString(), narrowed);\n                }\n                break;\n            case Token.AND:\n            case Token.OR:\n                BooleanOutcomePair conditionOutcomes \u003d traverseWithinShortCircuitingBinOp(assertedNode, scope);\n                scope \u003d reverseInterpreter.getPreciserScopeKnowingConditionOutcome(assertedNode, conditionOutcomes.getOutcomeFlowScope(assertedNode.getType(), true), true);\n                break;\n        }\n    } else if (assertedNode.getType() \u003d\u003d Token.NAME) {\n        JSType type \u003d getJSType(assertedNode);\n        JSType narrowed \u003d type.getGreatestSubtype(getNativeType(assertedType));\n        if (type !\u003d narrowed) {\n            scope \u003d scope.createChildFlowScope();\n            redeclare(scope, assertedNode.getString(), narrowed);\n        }\n    }\n    return scope;\n}",
      "path": "src/com/google/javascript/jscomp/TypeInference.java",
      "functionStartLine": 797,
      "functionName": "tightenTypesAfterAssertions",
      "functionAnnotation": "",
      "functionDoc": ""
    }
  }
}