{
  "origin": "codeshovel",
  "repositoryName": "Closure-33b",
  "repositoryPath": "/tmp/Closure-33b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "TypeValidator.java",
  "functionName": "getReadableJSTypeName",
  "functionId": "getReadableJSTypeName___n-Node__dereference-boolean",
  "sourceFilePath": "src/com/google/javascript/jscomp/TypeValidator.java",
  "functionAnnotation": "",
  "functionDoc": "Given a node, get a human-readable name for the type of that node so\nthat will be easy for the programmer to find the original declaration.\n\nFor example, if SubFoo\u0027s property \"bar\" might have the human-readable\nname \"Foo.prototype.bar\".\n\n@param n The node.\n@param dereference If true, the type of the node will be dereferenced\n    to an Object type, if possible.\n",
  "functionStartLine": 706,
  "functionEndLine": 756,
  "numCommitsSeen": 34,
  "timeTaken": 1994,
  "changeHistory": [
    "ec324a9bb23eb78c76f537f4c4170ba88d542f1c",
    "bd9c7b620384fe5a98772729001ed56304459bc6",
    "01d1238a2a577d8988a72c29304a3283ca05a29a",
    "fc0798047ad3aac58a54ea65f9f1c8857745419f",
    "c438dfd06013f82daa648d23b864842ff1881695",
    "2851a41947bed8b8e100c7dac7d1edbc1c909d24",
    "a36a61a9027c5bca5752b0ecca7c609c07e568bb",
    "d964d232de65db2370c06ce04de9865a3b2c8c9f",
    "a2d8936fae3eb0e3873c7f7c0233344c81436404",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3"
  ],
  "changeHistoryShort": {
    "ec324a9bb23eb78c76f537f4c4170ba88d542f1c": "Ybodychange",
    "bd9c7b620384fe5a98772729001ed56304459bc6": "Ybodychange",
    "01d1238a2a577d8988a72c29304a3283ca05a29a": "Ybodychange",
    "fc0798047ad3aac58a54ea65f9f1c8857745419f": "Ybodychange",
    "c438dfd06013f82daa648d23b864842ff1881695": "Ybodychange",
    "2851a41947bed8b8e100c7dac7d1edbc1c909d24": "Ybodychange",
    "a36a61a9027c5bca5752b0ecca7c609c07e568bb": "Ybodychange",
    "d964d232de65db2370c06ce04de9865a3b2c8c9f": "Ybodychange",
    "a2d8936fae3eb0e3873c7f7c0233344c81436404": "Ybodychange",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "ec324a9bb23eb78c76f537f4c4170ba88d542f1c": {
      "type": "Ybodychange",
      "commitMessage": "\nReplace the bulk of the Node.getType() \u003d\u003d Token.XXX calls with\nNode.isXXX calls.\n\nR\u003dnicksantos\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3677\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1582 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/10/11, 8:36 AM",
      "commitName": "ec324a9bb23eb78c76f537f4c4170ba88d542f1c",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "9/6/11, 11:52 AM",
      "commitNameOld": "6a2b233cac8fad95318405149b01d2c073509f62",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 64.91,
      "commitsBetweenForRepo": 157,
      "commitsBetweenForFile": 1,
      "actualSource": "String getReadableJSTypeName(Node n, boolean dereference) {\n    if (n.isGetProp()) {\n        ObjectType objectType \u003d getJSType(n.getFirstChild()).dereference();\n        if (objectType !\u003d null) {\n            String propName \u003d n.getLastChild().getString();\n            if (objectType.getConstructor() !\u003d null \u0026\u0026 objectType.getConstructor().isInterface()) {\n                objectType \u003d FunctionType.getTopDefiningInterface(objectType, propName);\n            } else {\n                while (objectType !\u003d null \u0026\u0026 !objectType.hasOwnProperty(propName)) {\n                    objectType \u003d objectType.getImplicitPrototype();\n                }\n            }\n            if (objectType !\u003d null \u0026\u0026 (objectType.getConstructor() !\u003d null || objectType.isFunctionPrototypeType())) {\n                return objectType.toString() + \".\" + propName;\n            }\n        }\n    }\n    JSType type \u003d getJSType(n);\n    if (dereference) {\n        ObjectType dereferenced \u003d type.dereference();\n        if (dereferenced !\u003d null) {\n            type \u003d dereferenced;\n        }\n    }\n    String qualifiedName \u003d n.getQualifiedName();\n    if (type.isFunctionPrototypeType() || (type.toObjectType() !\u003d null \u0026\u0026 type.toObjectType().getConstructor() !\u003d null)) {\n        return type.toString();\n    } else if (qualifiedName !\u003d null) {\n        return qualifiedName;\n    } else if (type.isFunctionType()) {\n        return \"function\";\n    } else {\n        return type.toString();\n    }\n}",
      "path": "src/com/google/javascript/jscomp/TypeValidator.java",
      "functionStartLine": 679,
      "functionName": "getReadableJSTypeName",
      "functionAnnotation": "",
      "functionDoc": "Given a node, get a human-readable name for the type of that node so\nthat will be easy for the programmer to find the original declaration.\n\nFor example, if SubFoo\u0027s property \"bar\" might have the human-readable\nname \"Foo.prototype.bar\".\n\n@param n The node.\n@param dereference If true, the type of the node will be dereferenced\n    to an Object type, if possible.\n",
      "diff": "@@ -1,35 +1,35 @@\n String getReadableJSTypeName(Node n, boolean dereference) {\n-    if (n.getType() \u003d\u003d Token.GETPROP) {\n+    if (n.isGetProp()) {\n         ObjectType objectType \u003d getJSType(n.getFirstChild()).dereference();\n         if (objectType !\u003d null) {\n             String propName \u003d n.getLastChild().getString();\n             if (objectType.getConstructor() !\u003d null \u0026\u0026 objectType.getConstructor().isInterface()) {\n                 objectType \u003d FunctionType.getTopDefiningInterface(objectType, propName);\n             } else {\n                 while (objectType !\u003d null \u0026\u0026 !objectType.hasOwnProperty(propName)) {\n                     objectType \u003d objectType.getImplicitPrototype();\n                 }\n             }\n             if (objectType !\u003d null \u0026\u0026 (objectType.getConstructor() !\u003d null || objectType.isFunctionPrototypeType())) {\n                 return objectType.toString() + \".\" + propName;\n             }\n         }\n     }\n     JSType type \u003d getJSType(n);\n     if (dereference) {\n         ObjectType dereferenced \u003d type.dereference();\n         if (dereferenced !\u003d null) {\n             type \u003d dereferenced;\n         }\n     }\n     String qualifiedName \u003d n.getQualifiedName();\n     if (type.isFunctionPrototypeType() || (type.toObjectType() !\u003d null \u0026\u0026 type.toObjectType().getConstructor() !\u003d null)) {\n         return type.toString();\n     } else if (qualifiedName !\u003d null) {\n         return qualifiedName;\n     } else if (type.isFunctionType()) {\n         return \"function\";\n     } else {\n         return type.toString();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "bd9c7b620384fe5a98772729001ed56304459bc6": {
      "type": "Ybodychange",
      "commitMessage": "\nAdd toMaybeFunctionType/toMaybeEnumElementType.\ntry #2. the bugs in jstestc were fixed. this cl is exactly\nthe same as the original\n\nR\u003djohnlenz\nDELTA\u003d317  (79 added, 47 deleted, 191 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3078\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1367 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "8/18/11, 3:46 PM",
      "commitName": "bd9c7b620384fe5a98772729001ed56304459bc6",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "8/18/11, 10:40 AM",
      "commitNameOld": "01d1238a2a577d8988a72c29304a3283ca05a29a",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 0.21,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "String getReadableJSTypeName(Node n, boolean dereference) {\n    if (n.getType() \u003d\u003d Token.GETPROP) {\n        ObjectType objectType \u003d getJSType(n.getFirstChild()).dereference();\n        if (objectType !\u003d null) {\n            String propName \u003d n.getLastChild().getString();\n            if (objectType.getConstructor() !\u003d null \u0026\u0026 objectType.getConstructor().isInterface()) {\n                objectType \u003d FunctionType.getTopDefiningInterface(objectType, propName);\n            } else {\n                while (objectType !\u003d null \u0026\u0026 !objectType.hasOwnProperty(propName)) {\n                    objectType \u003d objectType.getImplicitPrototype();\n                }\n            }\n            if (objectType !\u003d null \u0026\u0026 (objectType.getConstructor() !\u003d null || objectType.isFunctionPrototypeType())) {\n                return objectType.toString() + \".\" + propName;\n            }\n        }\n    }\n    JSType type \u003d getJSType(n);\n    if (dereference) {\n        ObjectType dereferenced \u003d type.dereference();\n        if (dereferenced !\u003d null) {\n            type \u003d dereferenced;\n        }\n    }\n    String qualifiedName \u003d n.getQualifiedName();\n    if (type.isFunctionPrototypeType() || (type.toObjectType() !\u003d null \u0026\u0026 type.toObjectType().getConstructor() !\u003d null)) {\n        return type.toString();\n    } else if (qualifiedName !\u003d null) {\n        return qualifiedName;\n    } else if (type.isFunctionType()) {\n        return \"function\";\n    } else {\n        return type.toString();\n    }\n}",
      "path": "src/com/google/javascript/jscomp/TypeValidator.java",
      "functionStartLine": 680,
      "functionName": "getReadableJSTypeName",
      "functionAnnotation": "",
      "functionDoc": "Given a node, get a human-readable name for the type of that node so\nthat will be easy for the programmer to find the original declaration.\n\nFor example, if SubFoo\u0027s property \"bar\" might have the human-readable\nname \"Foo.prototype.bar\".\n\n@param n The node.\n@param dereference If true, the type of the node will be dereferenced\n    to an Object type, if possible.\n",
      "diff": "@@ -1,35 +1,35 @@\n String getReadableJSTypeName(Node n, boolean dereference) {\n     if (n.getType() \u003d\u003d Token.GETPROP) {\n         ObjectType objectType \u003d getJSType(n.getFirstChild()).dereference();\n         if (objectType !\u003d null) {\n             String propName \u003d n.getLastChild().getString();\n             if (objectType.getConstructor() !\u003d null \u0026\u0026 objectType.getConstructor().isInterface()) {\n                 objectType \u003d FunctionType.getTopDefiningInterface(objectType, propName);\n             } else {\n                 while (objectType !\u003d null \u0026\u0026 !objectType.hasOwnProperty(propName)) {\n                     objectType \u003d objectType.getImplicitPrototype();\n                 }\n             }\n             if (objectType !\u003d null \u0026\u0026 (objectType.getConstructor() !\u003d null || objectType.isFunctionPrototypeType())) {\n                 return objectType.toString() + \".\" + propName;\n             }\n         }\n     }\n     JSType type \u003d getJSType(n);\n     if (dereference) {\n         ObjectType dereferenced \u003d type.dereference();\n         if (dereferenced !\u003d null) {\n             type \u003d dereferenced;\n         }\n     }\n     String qualifiedName \u003d n.getQualifiedName();\n     if (type.isFunctionPrototypeType() || (type.toObjectType() !\u003d null \u0026\u0026 type.toObjectType().getConstructor() !\u003d null)) {\n         return type.toString();\n     } else if (qualifiedName !\u003d null) {\n         return qualifiedName;\n-    } else if (type instanceof FunctionType) {\n+    } else if (type.isFunctionType()) {\n         return \"function\";\n     } else {\n         return type.toString();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "01d1238a2a577d8988a72c29304a3283ca05a29a": {
      "type": "Ybodychange",
      "commitMessage": "\nAutomated g4 rollback.\n\n*** Reason for rollback ***\n\nbroke some tests\n\n*** Original change description ***\n\nAdd toMaybeFunctionType/toMaybeEnumElementType.\nwow, nullability is annoying!\n\nDELTA\u003d318  (48 added, 79 deleted, 191 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3075\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1364 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "8/18/11, 10:40 AM",
      "commitName": "01d1238a2a577d8988a72c29304a3283ca05a29a",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "8/18/11, 9:38 AM",
      "commitNameOld": "fc0798047ad3aac58a54ea65f9f1c8857745419f",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "String getReadableJSTypeName(Node n, boolean dereference) {\n    if (n.getType() \u003d\u003d Token.GETPROP) {\n        ObjectType objectType \u003d getJSType(n.getFirstChild()).dereference();\n        if (objectType !\u003d null) {\n            String propName \u003d n.getLastChild().getString();\n            if (objectType.getConstructor() !\u003d null \u0026\u0026 objectType.getConstructor().isInterface()) {\n                objectType \u003d FunctionType.getTopDefiningInterface(objectType, propName);\n            } else {\n                while (objectType !\u003d null \u0026\u0026 !objectType.hasOwnProperty(propName)) {\n                    objectType \u003d objectType.getImplicitPrototype();\n                }\n            }\n            if (objectType !\u003d null \u0026\u0026 (objectType.getConstructor() !\u003d null || objectType.isFunctionPrototypeType())) {\n                return objectType.toString() + \".\" + propName;\n            }\n        }\n    }\n    JSType type \u003d getJSType(n);\n    if (dereference) {\n        ObjectType dereferenced \u003d type.dereference();\n        if (dereferenced !\u003d null) {\n            type \u003d dereferenced;\n        }\n    }\n    String qualifiedName \u003d n.getQualifiedName();\n    if (type.isFunctionPrototypeType() || (type.toObjectType() !\u003d null \u0026\u0026 type.toObjectType().getConstructor() !\u003d null)) {\n        return type.toString();\n    } else if (qualifiedName !\u003d null) {\n        return qualifiedName;\n    } else if (type instanceof FunctionType) {\n        return \"function\";\n    } else {\n        return type.toString();\n    }\n}",
      "path": "src/com/google/javascript/jscomp/TypeValidator.java",
      "functionStartLine": 680,
      "functionName": "getReadableJSTypeName",
      "functionAnnotation": "",
      "functionDoc": "Given a node, get a human-readable name for the type of that node so\nthat will be easy for the programmer to find the original declaration.\n\nFor example, if SubFoo\u0027s property \"bar\" might have the human-readable\nname \"Foo.prototype.bar\".\n\n@param n The node.\n@param dereference If true, the type of the node will be dereferenced\n    to an Object type, if possible.\n",
      "diff": "@@ -1,35 +1,35 @@\n String getReadableJSTypeName(Node n, boolean dereference) {\n     if (n.getType() \u003d\u003d Token.GETPROP) {\n         ObjectType objectType \u003d getJSType(n.getFirstChild()).dereference();\n         if (objectType !\u003d null) {\n             String propName \u003d n.getLastChild().getString();\n             if (objectType.getConstructor() !\u003d null \u0026\u0026 objectType.getConstructor().isInterface()) {\n                 objectType \u003d FunctionType.getTopDefiningInterface(objectType, propName);\n             } else {\n                 while (objectType !\u003d null \u0026\u0026 !objectType.hasOwnProperty(propName)) {\n                     objectType \u003d objectType.getImplicitPrototype();\n                 }\n             }\n             if (objectType !\u003d null \u0026\u0026 (objectType.getConstructor() !\u003d null || objectType.isFunctionPrototypeType())) {\n                 return objectType.toString() + \".\" + propName;\n             }\n         }\n     }\n     JSType type \u003d getJSType(n);\n     if (dereference) {\n         ObjectType dereferenced \u003d type.dereference();\n         if (dereferenced !\u003d null) {\n             type \u003d dereferenced;\n         }\n     }\n     String qualifiedName \u003d n.getQualifiedName();\n     if (type.isFunctionPrototypeType() || (type.toObjectType() !\u003d null \u0026\u0026 type.toObjectType().getConstructor() !\u003d null)) {\n         return type.toString();\n     } else if (qualifiedName !\u003d null) {\n         return qualifiedName;\n-    } else if (type.isFunctionType()) {\n+    } else if (type instanceof FunctionType) {\n         return \"function\";\n     } else {\n         return type.toString();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fc0798047ad3aac58a54ea65f9f1c8857745419f": {
      "type": "Ybodychange",
      "commitMessage": "\nAdd toMaybeFunctionType/toMaybeEnumElementType.\nwow, nullability is annoying!\n\nR\u003djohnlenz\nDELTA\u003d318  (79 added, 48 deleted, 191 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3074\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1363 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "8/18/11, 9:38 AM",
      "commitName": "fc0798047ad3aac58a54ea65f9f1c8857745419f",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "8/17/11, 11:43 AM",
      "commitNameOld": "5ac633a4e4471847da5aa22bb1fcf28727eb7fe9",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 0.91,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "String getReadableJSTypeName(Node n, boolean dereference) {\n    if (n.getType() \u003d\u003d Token.GETPROP) {\n        ObjectType objectType \u003d getJSType(n.getFirstChild()).dereference();\n        if (objectType !\u003d null) {\n            String propName \u003d n.getLastChild().getString();\n            if (objectType.getConstructor() !\u003d null \u0026\u0026 objectType.getConstructor().isInterface()) {\n                objectType \u003d FunctionType.getTopDefiningInterface(objectType, propName);\n            } else {\n                while (objectType !\u003d null \u0026\u0026 !objectType.hasOwnProperty(propName)) {\n                    objectType \u003d objectType.getImplicitPrototype();\n                }\n            }\n            if (objectType !\u003d null \u0026\u0026 (objectType.getConstructor() !\u003d null || objectType.isFunctionPrototypeType())) {\n                return objectType.toString() + \".\" + propName;\n            }\n        }\n    }\n    JSType type \u003d getJSType(n);\n    if (dereference) {\n        ObjectType dereferenced \u003d type.dereference();\n        if (dereferenced !\u003d null) {\n            type \u003d dereferenced;\n        }\n    }\n    String qualifiedName \u003d n.getQualifiedName();\n    if (type.isFunctionPrototypeType() || (type.toObjectType() !\u003d null \u0026\u0026 type.toObjectType().getConstructor() !\u003d null)) {\n        return type.toString();\n    } else if (qualifiedName !\u003d null) {\n        return qualifiedName;\n    } else if (type.isFunctionType()) {\n        return \"function\";\n    } else {\n        return type.toString();\n    }\n}",
      "path": "src/com/google/javascript/jscomp/TypeValidator.java",
      "functionStartLine": 680,
      "functionName": "getReadableJSTypeName",
      "functionAnnotation": "",
      "functionDoc": "Given a node, get a human-readable name for the type of that node so\nthat will be easy for the programmer to find the original declaration.\n\nFor example, if SubFoo\u0027s property \"bar\" might have the human-readable\nname \"Foo.prototype.bar\".\n\n@param n The node.\n@param dereference If true, the type of the node will be dereferenced\n    to an Object type, if possible.\n",
      "diff": "@@ -1,35 +1,35 @@\n String getReadableJSTypeName(Node n, boolean dereference) {\n     if (n.getType() \u003d\u003d Token.GETPROP) {\n         ObjectType objectType \u003d getJSType(n.getFirstChild()).dereference();\n         if (objectType !\u003d null) {\n             String propName \u003d n.getLastChild().getString();\n             if (objectType.getConstructor() !\u003d null \u0026\u0026 objectType.getConstructor().isInterface()) {\n                 objectType \u003d FunctionType.getTopDefiningInterface(objectType, propName);\n             } else {\n                 while (objectType !\u003d null \u0026\u0026 !objectType.hasOwnProperty(propName)) {\n                     objectType \u003d objectType.getImplicitPrototype();\n                 }\n             }\n             if (objectType !\u003d null \u0026\u0026 (objectType.getConstructor() !\u003d null || objectType.isFunctionPrototypeType())) {\n                 return objectType.toString() + \".\" + propName;\n             }\n         }\n     }\n     JSType type \u003d getJSType(n);\n     if (dereference) {\n         ObjectType dereferenced \u003d type.dereference();\n         if (dereferenced !\u003d null) {\n             type \u003d dereferenced;\n         }\n     }\n     String qualifiedName \u003d n.getQualifiedName();\n     if (type.isFunctionPrototypeType() || (type.toObjectType() !\u003d null \u0026\u0026 type.toObjectType().getConstructor() !\u003d null)) {\n         return type.toString();\n     } else if (qualifiedName !\u003d null) {\n         return qualifiedName;\n-    } else if (type instanceof FunctionType) {\n+    } else if (type.isFunctionType()) {\n         return \"function\";\n     } else {\n         return type.toString();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c438dfd06013f82daa648d23b864842ff1881695": {
      "type": "Ybodychange",
      "commitMessage": "\nImplement multiple extends for interfaces\n\nR\u003dnicksantos\nDELTA\u003d711  (635 added, 41 deleted, 35 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d1917\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1105 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "5/16/11, 12:57 PM",
      "commitName": "c438dfd06013f82daa648d23b864842ff1881695",
      "commitAuthor": "zhuyi@google.com",
      "commitDateOld": "5/10/11, 2:34 PM",
      "commitNameOld": "2851a41947bed8b8e100c7dac7d1edbc1c909d24",
      "commitAuthorOld": "zhuyi@google.com",
      "daysBetweenCommits": 5.93,
      "commitsBetweenForRepo": 25,
      "commitsBetweenForFile": 1,
      "actualSource": "String getReadableJSTypeName(Node n, boolean dereference) {\n    if (n.getType() \u003d\u003d Token.GETPROP) {\n        ObjectType objectType \u003d getJSType(n.getFirstChild()).dereference();\n        if (objectType !\u003d null) {\n            String propName \u003d n.getLastChild().getString();\n            if (objectType.getConstructor() !\u003d null \u0026\u0026 objectType.getConstructor().isInterface()) {\n                objectType \u003d FunctionType.getTopDefiningInterface(objectType, propName);\n            } else {\n                while (objectType !\u003d null \u0026\u0026 !objectType.hasOwnProperty(propName)) {\n                    objectType \u003d objectType.getImplicitPrototype();\n                }\n            }\n            if (objectType !\u003d null \u0026\u0026 (objectType.getConstructor() !\u003d null || objectType.isFunctionPrototypeType())) {\n                return objectType.toString() + \".\" + propName;\n            }\n        }\n    }\n    JSType type \u003d getJSType(n);\n    if (dereference) {\n        ObjectType dereferenced \u003d type.dereference();\n        if (dereferenced !\u003d null) {\n            type \u003d dereferenced;\n        }\n    }\n    String qualifiedName \u003d n.getQualifiedName();\n    if (type.isFunctionPrototypeType() || (type.toObjectType() !\u003d null \u0026\u0026 type.toObjectType().getConstructor() !\u003d null)) {\n        return type.toString();\n    } else if (qualifiedName !\u003d null) {\n        return qualifiedName;\n    } else if (type instanceof FunctionType) {\n        return \"function\";\n    } else {\n        return type.toString();\n    }\n}",
      "path": "src/com/google/javascript/jscomp/TypeValidator.java",
      "functionStartLine": 692,
      "functionName": "getReadableJSTypeName",
      "functionAnnotation": "",
      "functionDoc": "Given a node, get a human-readable name for the type of that node so\nthat will be easy for the programmer to find the original declaration.\n\nFor example, if SubFoo\u0027s property \"bar\" might have the human-readable\nname \"Foo.prototype.bar\".\n\n@param n The node.\n@param dereference If true, the type of the node will be dereferenced\n    to an Object type, if possible.\n",
      "diff": "@@ -1,31 +1,35 @@\n String getReadableJSTypeName(Node n, boolean dereference) {\n     if (n.getType() \u003d\u003d Token.GETPROP) {\n         ObjectType objectType \u003d getJSType(n.getFirstChild()).dereference();\n         if (objectType !\u003d null) {\n             String propName \u003d n.getLastChild().getString();\n-            while (objectType !\u003d null \u0026\u0026 !objectType.hasOwnProperty(propName)) {\n-                objectType \u003d objectType.getImplicitPrototype();\n+            if (objectType.getConstructor() !\u003d null \u0026\u0026 objectType.getConstructor().isInterface()) {\n+                objectType \u003d FunctionType.getTopDefiningInterface(objectType, propName);\n+            } else {\n+                while (objectType !\u003d null \u0026\u0026 !objectType.hasOwnProperty(propName)) {\n+                    objectType \u003d objectType.getImplicitPrototype();\n+                }\n             }\n             if (objectType !\u003d null \u0026\u0026 (objectType.getConstructor() !\u003d null || objectType.isFunctionPrototypeType())) {\n                 return objectType.toString() + \".\" + propName;\n             }\n         }\n     }\n     JSType type \u003d getJSType(n);\n     if (dereference) {\n         ObjectType dereferenced \u003d type.dereference();\n         if (dereferenced !\u003d null) {\n             type \u003d dereferenced;\n         }\n     }\n     String qualifiedName \u003d n.getQualifiedName();\n     if (type.isFunctionPrototypeType() || (type.toObjectType() !\u003d null \u0026\u0026 type.toObjectType().getConstructor() !\u003d null)) {\n         return type.toString();\n     } else if (qualifiedName !\u003d null) {\n         return qualifiedName;\n     } else if (type instanceof FunctionType) {\n         return \"function\";\n     } else {\n         return type.toString();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2851a41947bed8b8e100c7dac7d1edbc1c909d24": {
      "type": "Ybodychange",
      "commitMessage": "\nAutomated g4 rollback.\n\n*** Reason for rollback ***\n\nGot multiple cases broken from different teams.\n\n*** Original change description ***\n\nImplement multi extends for interfaces\n\nR\u003dnicksantos\nDELTA\u003d635  (41 added, 560 deleted, 34 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d1813\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1077 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "5/10/11, 2:34 PM",
      "commitName": "2851a41947bed8b8e100c7dac7d1edbc1c909d24",
      "commitAuthor": "zhuyi@google.com",
      "commitDateOld": "5/10/11, 1:26 PM",
      "commitNameOld": "a36a61a9027c5bca5752b0ecca7c609c07e568bb",
      "commitAuthorOld": "zhuyi@google.com",
      "daysBetweenCommits": 0.05,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "String getReadableJSTypeName(Node n, boolean dereference) {\n    if (n.getType() \u003d\u003d Token.GETPROP) {\n        ObjectType objectType \u003d getJSType(n.getFirstChild()).dereference();\n        if (objectType !\u003d null) {\n            String propName \u003d n.getLastChild().getString();\n            while (objectType !\u003d null \u0026\u0026 !objectType.hasOwnProperty(propName)) {\n                objectType \u003d objectType.getImplicitPrototype();\n            }\n            if (objectType !\u003d null \u0026\u0026 (objectType.getConstructor() !\u003d null || objectType.isFunctionPrototypeType())) {\n                return objectType.toString() + \".\" + propName;\n            }\n        }\n    }\n    JSType type \u003d getJSType(n);\n    if (dereference) {\n        ObjectType dereferenced \u003d type.dereference();\n        if (dereferenced !\u003d null) {\n            type \u003d dereferenced;\n        }\n    }\n    String qualifiedName \u003d n.getQualifiedName();\n    if (type.isFunctionPrototypeType() || (type.toObjectType() !\u003d null \u0026\u0026 type.toObjectType().getConstructor() !\u003d null)) {\n        return type.toString();\n    } else if (qualifiedName !\u003d null) {\n        return qualifiedName;\n    } else if (type instanceof FunctionType) {\n        return \"function\";\n    } else {\n        return type.toString();\n    }\n}",
      "path": "src/com/google/javascript/jscomp/TypeValidator.java",
      "functionStartLine": 692,
      "functionName": "getReadableJSTypeName",
      "functionAnnotation": "",
      "functionDoc": "Given a node, get a human-readable name for the type of that node so\nthat will be easy for the programmer to find the original declaration.\n\nFor example, if SubFoo\u0027s property \"bar\" might have the human-readable\nname \"Foo.prototype.bar\".\n\n@param n The node.\n@param dereference If true, the type of the node will be dereferenced\n    to an Object type, if possible.\n",
      "diff": "@@ -1,38 +1,31 @@\n String getReadableJSTypeName(Node n, boolean dereference) {\n     if (n.getType() \u003d\u003d Token.GETPROP) {\n         ObjectType objectType \u003d getJSType(n.getFirstChild()).dereference();\n         if (objectType !\u003d null) {\n             String propName \u003d n.getLastChild().getString();\n-            if (objectType.getConstructor() !\u003d null \u0026\u0026 objectType.getConstructor().isInterface()) {\n-                ObjectType topInterface \u003d FunctionType.getTopDefiningInterface(objectType, propName);\n-                if (topInterface !\u003d null \u0026\u0026 topInterface.getConstructor() !\u003d null) {\n-                    objectType \u003d topInterface.getConstructor().getPrototype();\n-                }\n-            } else {\n-                while (objectType !\u003d null \u0026\u0026 !objectType.hasOwnProperty(propName)) {\n-                    objectType \u003d objectType.getImplicitPrototype();\n-                }\n+            while (objectType !\u003d null \u0026\u0026 !objectType.hasOwnProperty(propName)) {\n+                objectType \u003d objectType.getImplicitPrototype();\n             }\n             if (objectType !\u003d null \u0026\u0026 (objectType.getConstructor() !\u003d null || objectType.isFunctionPrototypeType())) {\n                 return objectType.toString() + \".\" + propName;\n             }\n         }\n     }\n     JSType type \u003d getJSType(n);\n     if (dereference) {\n         ObjectType dereferenced \u003d type.dereference();\n         if (dereferenced !\u003d null) {\n             type \u003d dereferenced;\n         }\n     }\n     String qualifiedName \u003d n.getQualifiedName();\n     if (type.isFunctionPrototypeType() || (type.toObjectType() !\u003d null \u0026\u0026 type.toObjectType().getConstructor() !\u003d null)) {\n         return type.toString();\n     } else if (qualifiedName !\u003d null) {\n         return qualifiedName;\n     } else if (type instanceof FunctionType) {\n         return \"function\";\n     } else {\n         return type.toString();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a36a61a9027c5bca5752b0ecca7c609c07e568bb": {
      "type": "Ybodychange",
      "commitMessage": "\nImplement multi extends for interfaces\n\nR\u003dnicksantos\nDELTA\u003d635  (560 added, 41 deleted, 34 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d1810\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1074 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "5/10/11, 1:26 PM",
      "commitName": "a36a61a9027c5bca5752b0ecca7c609c07e568bb",
      "commitAuthor": "zhuyi@google.com",
      "commitDateOld": "4/12/11, 12:15 PM",
      "commitNameOld": "f322be0e576d5e2114cb59c0a6537197997b9c59",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 28.05,
      "commitsBetweenForRepo": 74,
      "commitsBetweenForFile": 1,
      "actualSource": "String getReadableJSTypeName(Node n, boolean dereference) {\n    if (n.getType() \u003d\u003d Token.GETPROP) {\n        ObjectType objectType \u003d getJSType(n.getFirstChild()).dereference();\n        if (objectType !\u003d null) {\n            String propName \u003d n.getLastChild().getString();\n            if (objectType.getConstructor() !\u003d null \u0026\u0026 objectType.getConstructor().isInterface()) {\n                ObjectType topInterface \u003d FunctionType.getTopDefiningInterface(objectType, propName);\n                if (topInterface !\u003d null \u0026\u0026 topInterface.getConstructor() !\u003d null) {\n                    objectType \u003d topInterface.getConstructor().getPrototype();\n                }\n            } else {\n                while (objectType !\u003d null \u0026\u0026 !objectType.hasOwnProperty(propName)) {\n                    objectType \u003d objectType.getImplicitPrototype();\n                }\n            }\n            if (objectType !\u003d null \u0026\u0026 (objectType.getConstructor() !\u003d null || objectType.isFunctionPrototypeType())) {\n                return objectType.toString() + \".\" + propName;\n            }\n        }\n    }\n    JSType type \u003d getJSType(n);\n    if (dereference) {\n        ObjectType dereferenced \u003d type.dereference();\n        if (dereferenced !\u003d null) {\n            type \u003d dereferenced;\n        }\n    }\n    String qualifiedName \u003d n.getQualifiedName();\n    if (type.isFunctionPrototypeType() || (type.toObjectType() !\u003d null \u0026\u0026 type.toObjectType().getConstructor() !\u003d null)) {\n        return type.toString();\n    } else if (qualifiedName !\u003d null) {\n        return qualifiedName;\n    } else if (type instanceof FunctionType) {\n        return \"function\";\n    } else {\n        return type.toString();\n    }\n}",
      "path": "src/com/google/javascript/jscomp/TypeValidator.java",
      "functionStartLine": 692,
      "functionName": "getReadableJSTypeName",
      "functionAnnotation": "",
      "functionDoc": "Given a node, get a human-readable name for the type of that node so\nthat will be easy for the programmer to find the original declaration.\n\nFor example, if SubFoo\u0027s property \"bar\" might have the human-readable\nname \"Foo.prototype.bar\".\n\n@param n The node.\n@param dereference If true, the type of the node will be dereferenced\n    to an Object type, if possible.\n",
      "diff": "@@ -1,31 +1,38 @@\n String getReadableJSTypeName(Node n, boolean dereference) {\n     if (n.getType() \u003d\u003d Token.GETPROP) {\n         ObjectType objectType \u003d getJSType(n.getFirstChild()).dereference();\n         if (objectType !\u003d null) {\n             String propName \u003d n.getLastChild().getString();\n-            while (objectType !\u003d null \u0026\u0026 !objectType.hasOwnProperty(propName)) {\n-                objectType \u003d objectType.getImplicitPrototype();\n+            if (objectType.getConstructor() !\u003d null \u0026\u0026 objectType.getConstructor().isInterface()) {\n+                ObjectType topInterface \u003d FunctionType.getTopDefiningInterface(objectType, propName);\n+                if (topInterface !\u003d null \u0026\u0026 topInterface.getConstructor() !\u003d null) {\n+                    objectType \u003d topInterface.getConstructor().getPrototype();\n+                }\n+            } else {\n+                while (objectType !\u003d null \u0026\u0026 !objectType.hasOwnProperty(propName)) {\n+                    objectType \u003d objectType.getImplicitPrototype();\n+                }\n             }\n             if (objectType !\u003d null \u0026\u0026 (objectType.getConstructor() !\u003d null || objectType.isFunctionPrototypeType())) {\n                 return objectType.toString() + \".\" + propName;\n             }\n         }\n     }\n     JSType type \u003d getJSType(n);\n     if (dereference) {\n         ObjectType dereferenced \u003d type.dereference();\n         if (dereferenced !\u003d null) {\n             type \u003d dereferenced;\n         }\n     }\n     String qualifiedName \u003d n.getQualifiedName();\n     if (type.isFunctionPrototypeType() || (type.toObjectType() !\u003d null \u0026\u0026 type.toObjectType().getConstructor() !\u003d null)) {\n         return type.toString();\n     } else if (qualifiedName !\u003d null) {\n         return qualifiedName;\n     } else if (type instanceof FunctionType) {\n         return \"function\";\n     } else {\n         return type.toString();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d964d232de65db2370c06ce04de9865a3b2c8c9f": {
      "type": "Ybodychange",
      "commitMessage": "Minor code removal improvement \"({}).prop \u003d 3;\" has no side effects.\n\nImprovements to test infrastructure.\n\nFix an edge case compiler crash in TypeValidator.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@43 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "12/21/09, 10:13 AM",
      "commitName": "d964d232de65db2370c06ce04de9865a3b2c8c9f",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "commitDateOld": "12/15/09, 1:52 PM",
      "commitNameOld": "a2d8936fae3eb0e3873c7f7c0233344c81436404",
      "commitAuthorOld": "nicholas.j.santos@gmail.com",
      "daysBetweenCommits": 5.85,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "String getReadableJSTypeName(Node n, boolean dereference) {\n    if (n.getType() \u003d\u003d Token.GETPROP) {\n        ObjectType objectType \u003d getJSType(n.getFirstChild()).dereference();\n        if (objectType !\u003d null) {\n            String propName \u003d n.getLastChild().getString();\n            while (objectType !\u003d null \u0026\u0026 !objectType.hasOwnProperty(propName)) {\n                objectType \u003d objectType.getImplicitPrototype();\n            }\n            if (objectType !\u003d null \u0026\u0026 (objectType.getConstructor() !\u003d null || objectType.isFunctionPrototypeType())) {\n                return objectType.toString() + \".\" + propName;\n            }\n        }\n    }\n    JSType type \u003d getJSType(n);\n    if (dereference) {\n        ObjectType dereferenced \u003d type.dereference();\n        if (dereferenced !\u003d null) {\n            type \u003d dereferenced;\n        }\n    }\n    String qualifiedName \u003d n.getQualifiedName();\n    if (type.isFunctionPrototypeType() || (type.toObjectType() !\u003d null \u0026\u0026 type.toObjectType().getConstructor() !\u003d null)) {\n        return type.toString();\n    } else if (qualifiedName !\u003d null) {\n        return qualifiedName;\n    } else if (type instanceof FunctionType) {\n        return \"function\";\n    } else {\n        return type.toString();\n    }\n}",
      "path": "src/com/google/javascript/jscomp/TypeValidator.java",
      "functionStartLine": 598,
      "functionName": "getReadableJSTypeName",
      "functionAnnotation": "",
      "functionDoc": "Given a node, get a human-readable name for the type of that node so\nthat will be easy for the programmer to find the original declaration.\n\nFor example, if SubFoo\u0027s property \"bar\" might have the human-readable\nname \"Foo.prototype.bar\".\n\n@param n The node.\n@param dereference If true, the type of the node will be dereferenced\n    to an Object type, if possible.\n",
      "diff": "@@ -1,28 +1,31 @@\n String getReadableJSTypeName(Node n, boolean dereference) {\n     if (n.getType() \u003d\u003d Token.GETPROP) {\n         ObjectType objectType \u003d getJSType(n.getFirstChild()).dereference();\n         if (objectType !\u003d null) {\n             String propName \u003d n.getLastChild().getString();\n             while (objectType !\u003d null \u0026\u0026 !objectType.hasOwnProperty(propName)) {\n                 objectType \u003d objectType.getImplicitPrototype();\n             }\n             if (objectType !\u003d null \u0026\u0026 (objectType.getConstructor() !\u003d null || objectType.isFunctionPrototypeType())) {\n                 return objectType.toString() + \".\" + propName;\n             }\n         }\n     }\n     JSType type \u003d getJSType(n);\n     if (dereference) {\n-        type \u003d type.dereference();\n+        ObjectType dereferenced \u003d type.dereference();\n+        if (dereferenced !\u003d null) {\n+            type \u003d dereferenced;\n+        }\n     }\n     String qualifiedName \u003d n.getQualifiedName();\n     if (type.isFunctionPrototypeType() || (type.toObjectType() !\u003d null \u0026\u0026 type.toObjectType().getConstructor() !\u003d null)) {\n         return type.toString();\n     } else if (qualifiedName !\u003d null) {\n         return qualifiedName;\n     } else if (type instanceof FunctionType) {\n         return \"function\";\n     } else {\n         return type.toString();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a2d8936fae3eb0e3873c7f7c0233344c81436404": {
      "type": "Ybodychange",
      "commitMessage": "Add warnings for functions that are ambiguously defined on different\nbrowsers.\n\nAdd better support for Caja.\n\nRollback the change to CoalesceVariableNames, because it had problems.\n\nInternal type system refactoring.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@33 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "12/15/09, 1:52 PM",
      "commitName": "a2d8936fae3eb0e3873c7f7c0233344c81436404",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "commitDateOld": "11/3/09, 3:51 PM",
      "commitNameOld": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthorOld": "nicholas.j.santos@gmail.com",
      "daysBetweenCommits": 41.92,
      "commitsBetweenForRepo": 23,
      "commitsBetweenForFile": 1,
      "actualSource": "String getReadableJSTypeName(Node n, boolean dereference) {\n    if (n.getType() \u003d\u003d Token.GETPROP) {\n        ObjectType objectType \u003d getJSType(n.getFirstChild()).dereference();\n        if (objectType !\u003d null) {\n            String propName \u003d n.getLastChild().getString();\n            while (objectType !\u003d null \u0026\u0026 !objectType.hasOwnProperty(propName)) {\n                objectType \u003d objectType.getImplicitPrototype();\n            }\n            if (objectType !\u003d null \u0026\u0026 (objectType.getConstructor() !\u003d null || objectType.isFunctionPrototypeType())) {\n                return objectType.toString() + \".\" + propName;\n            }\n        }\n    }\n    JSType type \u003d getJSType(n);\n    if (dereference) {\n        type \u003d type.dereference();\n    }\n    String qualifiedName \u003d n.getQualifiedName();\n    if (type.isFunctionPrototypeType() || (type.toObjectType() !\u003d null \u0026\u0026 type.toObjectType().getConstructor() !\u003d null)) {\n        return type.toString();\n    } else if (qualifiedName !\u003d null) {\n        return qualifiedName;\n    } else if (type instanceof FunctionType) {\n        return \"function\";\n    } else {\n        return type.toString();\n    }\n}",
      "path": "src/com/google/javascript/jscomp/TypeValidator.java",
      "functionStartLine": 598,
      "functionName": "getReadableJSTypeName",
      "functionAnnotation": "",
      "functionDoc": "Given a node, get a human-readable name for the type of that node so\nthat will be easy for the programmer to find the original declaration.\n\nFor example, if SubFoo\u0027s property \"bar\" might have the human-readable\nname \"Foo.prototype.bar\".\n\n@param n The node.\n@param dereference If true, the type of the node will be dereferenced\n    to an Object type, if possible.\n",
      "diff": "@@ -1,28 +1,28 @@\n String getReadableJSTypeName(Node n, boolean dereference) {\n     if (n.getType() \u003d\u003d Token.GETPROP) {\n         ObjectType objectType \u003d getJSType(n.getFirstChild()).dereference();\n         if (objectType !\u003d null) {\n             String propName \u003d n.getLastChild().getString();\n             while (objectType !\u003d null \u0026\u0026 !objectType.hasOwnProperty(propName)) {\n                 objectType \u003d objectType.getImplicitPrototype();\n             }\n             if (objectType !\u003d null \u0026\u0026 (objectType.getConstructor() !\u003d null || objectType.isFunctionPrototypeType())) {\n                 return objectType.toString() + \".\" + propName;\n             }\n         }\n     }\n     JSType type \u003d getJSType(n);\n     if (dereference) {\n         type \u003d type.dereference();\n     }\n     String qualifiedName \u003d n.getQualifiedName();\n-    if (type.isFunctionPrototypeType() || (type instanceof ObjectType \u0026\u0026 ((ObjectType) type).getConstructor() !\u003d null)) {\n+    if (type.isFunctionPrototypeType() || (type.toObjectType() !\u003d null \u0026\u0026 type.toObjectType().getConstructor() !\u003d null)) {\n         return type.toString();\n     } else if (qualifiedName !\u003d null) {\n         return qualifiedName;\n     } else if (type instanceof FunctionType) {\n         return \"function\";\n     } else {\n         return type.toString();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": {
      "type": "Yintroduced",
      "commitMessage": "Initial commit.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/3/09, 3:51 PM",
      "commitName": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "diff": "@@ -0,0 +1,28 @@\n+String getReadableJSTypeName(Node n, boolean dereference) {\n+    if (n.getType() \u003d\u003d Token.GETPROP) {\n+        ObjectType objectType \u003d getJSType(n.getFirstChild()).dereference();\n+        if (objectType !\u003d null) {\n+            String propName \u003d n.getLastChild().getString();\n+            while (objectType !\u003d null \u0026\u0026 !objectType.hasOwnProperty(propName)) {\n+                objectType \u003d objectType.getImplicitPrototype();\n+            }\n+            if (objectType !\u003d null \u0026\u0026 (objectType.getConstructor() !\u003d null || objectType.isFunctionPrototypeType())) {\n+                return objectType.toString() + \".\" + propName;\n+            }\n+        }\n+    }\n+    JSType type \u003d getJSType(n);\n+    if (dereference) {\n+        type \u003d type.dereference();\n+    }\n+    String qualifiedName \u003d n.getQualifiedName();\n+    if (type.isFunctionPrototypeType() || (type instanceof ObjectType \u0026\u0026 ((ObjectType) type).getConstructor() !\u003d null)) {\n+        return type.toString();\n+    } else if (qualifiedName !\u003d null) {\n+        return qualifiedName;\n+    } else if (type instanceof FunctionType) {\n+        return \"function\";\n+    } else {\n+        return type.toString();\n+    }\n+}\n\\ No newline at end of file\n",
      "actualSource": "String getReadableJSTypeName(Node n, boolean dereference) {\n    if (n.getType() \u003d\u003d Token.GETPROP) {\n        ObjectType objectType \u003d getJSType(n.getFirstChild()).dereference();\n        if (objectType !\u003d null) {\n            String propName \u003d n.getLastChild().getString();\n            while (objectType !\u003d null \u0026\u0026 !objectType.hasOwnProperty(propName)) {\n                objectType \u003d objectType.getImplicitPrototype();\n            }\n            if (objectType !\u003d null \u0026\u0026 (objectType.getConstructor() !\u003d null || objectType.isFunctionPrototypeType())) {\n                return objectType.toString() + \".\" + propName;\n            }\n        }\n    }\n    JSType type \u003d getJSType(n);\n    if (dereference) {\n        type \u003d type.dereference();\n    }\n    String qualifiedName \u003d n.getQualifiedName();\n    if (type.isFunctionPrototypeType() || (type instanceof ObjectType \u0026\u0026 ((ObjectType) type).getConstructor() !\u003d null)) {\n        return type.toString();\n    } else if (qualifiedName !\u003d null) {\n        return qualifiedName;\n    } else if (type instanceof FunctionType) {\n        return \"function\";\n    } else {\n        return type.toString();\n    }\n}",
      "path": "src/com/google/javascript/jscomp/TypeValidator.java",
      "functionStartLine": 598,
      "functionName": "getReadableJSTypeName",
      "functionAnnotation": "",
      "functionDoc": "Given a node, get a human-readable name for the type of that node so\nthat will be easy for the programmer to find the original declaration.\n\nFor example, if SubFoo\u0027s property \"bar\" might have the human-readable\nname \"Foo.prototype.bar\".\n\n@param n The node.\n@param dereference If true, the type of the node will be dereferenced\n    to an Object type, if possible.\n"
    }
  }
}