{
  "origin": "codeshovel",
  "repositoryName": "Closure-64b",
  "repositoryPath": "/tmp/Closure-64b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "RemoveUnusedVars.java",
  "functionName": "interpretAssigns",
  "functionId": "interpretAssigns",
  "sourceFilePath": "src/com/google/javascript/jscomp/RemoveUnusedVars.java",
  "functionAnnotation": "",
  "functionDoc": "Look at all the property assigns to all variables.\nThese may or may not count as references. For example,\n\n\u003ccode\u003e\nvar x \u003d {};\nx.foo \u003d 3; // not a reference.\nvar y \u003d foo();\ny.foo \u003d 3; // is a reference.\n\u003c/code\u003e\n\nInterpreting assigments could mark a variable as referenced that\nwasn\u0027t referenced before, in order to keep it alive. Because we find\nreferences by lazily traversing subtrees, marking a variable as\nreferenced could trigger new traversals of new subtrees, which could\nfind new references.\n\nTherefore, this interpretation needs to be run to a fixed point.\n",
  "functionStartLine": 703,
  "functionEndLine": 748,
  "numCommitsSeen": 49,
  "timeTaken": 1734,
  "changeHistory": [
    "4726b80a80f5172dc5dcb71ca3932dfbe7b4322e",
    "747f2504d98e2d37c933ead6e40a0a1a1e36d6af",
    "f0362b1ab1ae1339e017b1d04f016980e3fa6cb6",
    "833cd72a268c1161194038faf0d98ec6b1f203eb"
  ],
  "changeHistoryShort": {
    "4726b80a80f5172dc5dcb71ca3932dfbe7b4322e": "Ybodychange",
    "747f2504d98e2d37c933ead6e40a0a1a1e36d6af": "Ymultichange(Yparameterchange,Ybodychange,Ydocchange)",
    "f0362b1ab1ae1339e017b1d04f016980e3fa6cb6": "Ybodychange",
    "833cd72a268c1161194038faf0d98ec6b1f203eb": "Yintroduced"
  },
  "changeHistoryDetails": {
    "4726b80a80f5172dc5dcb71ca3932dfbe7b4322e": {
      "type": "Ybodychange",
      "commitMessage": "\nFix the for...in edge case in RemoveUnusedVars.\n\nR\u003djohnlenz\nDELTA\u003d12  (10 added, 0 deleted, 2 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d173010\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@371 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "8/19/10, 8:58 AM",
      "commitName": "4726b80a80f5172dc5dcb71ca3932dfbe7b4322e",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "8/12/10, 6:02 PM",
      "commitNameOld": "15acafb00636f99295b394145b9b60a5e624ddfa",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 6.62,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "actualSource": "private void interpretAssigns() {\n    boolean changes \u003d false;\n    do {\n        changes \u003d false;\n        for (int current \u003d 0; current \u003c maybeUnreferenced.size(); current++) {\n            Var var \u003d maybeUnreferenced.get(current);\n            if (referenced.contains(var)) {\n                maybeUnreferenced.remove(current);\n                current--;\n            } else {\n                boolean assignedToUnknownValue \u003d false;\n                boolean hasPropertyAssign \u003d false;\n                if (var.getParentNode().getType() \u003d\u003d Token.VAR \u0026\u0026 !NodeUtil.isForIn(var.getParentNode().getParent())) {\n                    Node value \u003d var.getInitialValue();\n                    assignedToUnknownValue \u003d value !\u003d null \u0026\u0026 !NodeUtil.isLiteralValue(value, true);\n                } else {\n                    assignedToUnknownValue \u003d true;\n                }\n                for (Assign assign : assignsByVar.get(var)) {\n                    if (assign.isPropertyAssign) {\n                        hasPropertyAssign \u003d true;\n                    } else if (!NodeUtil.isLiteralValue(assign.assignNode.getLastChild(), true)) {\n                        assignedToUnknownValue \u003d true;\n                    }\n                }\n                if (assignedToUnknownValue \u0026\u0026 hasPropertyAssign) {\n                    changes \u003d markReferencedVar(var) || changes;\n                    maybeUnreferenced.remove(current);\n                    current--;\n                }\n            }\n        }\n    } while (changes);\n}",
      "path": "src/com/google/javascript/jscomp/RemoveUnusedVars.java",
      "functionStartLine": 336,
      "functionName": "interpretAssigns",
      "functionAnnotation": "",
      "functionDoc": "Look at all the property assigns to all variables.\nThese may or may not count as references. For example,\n\n\u003ccode\u003e\nvar x \u003d {};\nx.foo \u003d 3; // not a reference.\nvar y \u003d foo();\ny.foo \u003d 3; // is a reference.\n\u003c/code\u003e\n\nInterpreting assigments could mark a variable as referenced that\nwasn\u0027t referenced before, in order to keep it alive. Because we find\nreferences by lazily traversing subtrees, marking a variable as\nreferenced could trigger new traversals of new subtrees, which could\nfind new references.\n\nTherefore, this interpretation needs to be run to a fixed point.\n",
      "diff": "@@ -1,34 +1,34 @@\n private void interpretAssigns() {\n     boolean changes \u003d false;\n     do {\n         changes \u003d false;\n         for (int current \u003d 0; current \u003c maybeUnreferenced.size(); current++) {\n             Var var \u003d maybeUnreferenced.get(current);\n             if (referenced.contains(var)) {\n                 maybeUnreferenced.remove(current);\n                 current--;\n             } else {\n                 boolean assignedToUnknownValue \u003d false;\n                 boolean hasPropertyAssign \u003d false;\n-                if (var.getParentNode().getType() \u003d\u003d Token.VAR) {\n+                if (var.getParentNode().getType() \u003d\u003d Token.VAR \u0026\u0026 !NodeUtil.isForIn(var.getParentNode().getParent())) {\n                     Node value \u003d var.getInitialValue();\n                     assignedToUnknownValue \u003d value !\u003d null \u0026\u0026 !NodeUtil.isLiteralValue(value, true);\n                 } else {\n                     assignedToUnknownValue \u003d true;\n                 }\n                 for (Assign assign : assignsByVar.get(var)) {\n                     if (assign.isPropertyAssign) {\n                         hasPropertyAssign \u003d true;\n                     } else if (!NodeUtil.isLiteralValue(assign.assignNode.getLastChild(), true)) {\n                         assignedToUnknownValue \u003d true;\n                     }\n                 }\n                 if (assignedToUnknownValue \u0026\u0026 hasPropertyAssign) {\n                     changes \u003d markReferencedVar(var) || changes;\n                     maybeUnreferenced.remove(current);\n                     current--;\n                 }\n             }\n         }\n     } while (changes);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "747f2504d98e2d37c933ead6e40a0a1a1e36d6af": {
      "type": "Ymultichange(Yparameterchange,Ybodychange,Ydocchange)",
      "commitMessage": "\nChange on 2010/08/04 13:06:31 by nicksantos\n\n\tA new var-collection mechanism for RemoveUnusedVars.  In the\n\tnew mechanism, we only traverse a subtree for references if it\n\tmight have side-effects, or if its return value is used.  If\n\tits return value is stored in a variable, then we store a\n\tcontinuation, and execute the continuation iff that variable\n\tis referenced.\n\n\tThis is a more general formulation of RemoveUnusedVars\u0027s current\n\tstrategy (\"traverse a function iff it\u0027s referenced\").\n\n\tR\u003dacleung\n\tDELTA\u003d560  (326 added, 63 deleted, 171 changed)\n\nChange on 2010/08/04 13:09:34 by rjfioravanti\n\n\tCreating externs for CSSMatrix and WebKitCSSMatrix.\n\n\tBased on documentation from the following locations:\n\thttp://www.w3.org/TR/css3-3d-transforms/#cssmatrix-interface\n\thttp://developer.apple.com/safari/library/documentation/AudioVideo/Reference/WebKitCSSMatrixClassReference/WebKitCSSMatrix/WebKitCSSMatrix.html#//apple_ref/javascript/instm/WebKitCSSMatrix/setMatrixValue\n\n\tR\u003dnicksantos\n\tDELTA\u003d193  (193 added, 0 deleted, 0 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d90012\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@335 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "8/4/10, 5:48 PM",
      "commitName": "747f2504d98e2d37c933ead6e40a0a1a1e36d6af",
      "commitAuthor": "Nicholas.J.Santos",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "\nChange on 2010/08/04 13:06:31 by nicksantos\n\n\tA new var-collection mechanism for RemoveUnusedVars.  In the\n\tnew mechanism, we only traverse a subtree for references if it\n\tmight have side-effects, or if its return value is used.  If\n\tits return value is stored in a variable, then we store a\n\tcontinuation, and execute the continuation iff that variable\n\tis referenced.\n\n\tThis is a more general formulation of RemoveUnusedVars\u0027s current\n\tstrategy (\"traverse a function iff it\u0027s referenced\").\n\n\tR\u003dacleung\n\tDELTA\u003d560  (326 added, 63 deleted, 171 changed)\n\nChange on 2010/08/04 13:09:34 by rjfioravanti\n\n\tCreating externs for CSSMatrix and WebKitCSSMatrix.\n\n\tBased on documentation from the following locations:\n\thttp://www.w3.org/TR/css3-3d-transforms/#cssmatrix-interface\n\thttp://developer.apple.com/safari/library/documentation/AudioVideo/Reference/WebKitCSSMatrixClassReference/WebKitCSSMatrix/WebKitCSSMatrix.html#//apple_ref/javascript/instm/WebKitCSSMatrix/setMatrixValue\n\n\tR\u003dnicksantos\n\tDELTA\u003d193  (193 added, 0 deleted, 0 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d90012\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@335 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "8/4/10, 5:48 PM",
          "commitName": "747f2504d98e2d37c933ead6e40a0a1a1e36d6af",
          "commitAuthor": "Nicholas.J.Santos",
          "commitDateOld": "7/23/10, 2:49 PM",
          "commitNameOld": "f0362b1ab1ae1339e017b1d04f016980e3fa6cb6",
          "commitAuthorOld": "nicksantos@google.com",
          "daysBetweenCommits": 12.12,
          "commitsBetweenForRepo": 26,
          "commitsBetweenForFile": 1,
          "actualSource": "private void interpretAssigns() {\n    boolean changes \u003d false;\n    do {\n        changes \u003d false;\n        for (int current \u003d 0; current \u003c maybeUnreferenced.size(); current++) {\n            Var var \u003d maybeUnreferenced.get(current);\n            if (referenced.contains(var)) {\n                maybeUnreferenced.remove(current);\n                current--;\n            } else {\n                boolean assignedToUnknownValue \u003d false;\n                boolean hasPropertyAssign \u003d false;\n                if (var.getParentNode().getType() \u003d\u003d Token.VAR) {\n                    Node value \u003d var.getInitialValue();\n                    assignedToUnknownValue \u003d value !\u003d null \u0026\u0026 !NodeUtil.isLiteralValue(value, true);\n                } else {\n                    assignedToUnknownValue \u003d true;\n                }\n                for (Assign assign : assignsByVar.get(var)) {\n                    if (assign.isPropertyAssign) {\n                        hasPropertyAssign \u003d true;\n                    } else if (!NodeUtil.isLiteralValue(assign.assignNode.getLastChild(), true)) {\n                        assignedToUnknownValue \u003d true;\n                    }\n                }\n                if (assignedToUnknownValue \u0026\u0026 hasPropertyAssign) {\n                    changes \u003d markReferencedVar(var) || changes;\n                    maybeUnreferenced.remove(current);\n                    current--;\n                }\n            }\n        }\n    } while (changes);\n}",
          "path": "src/com/google/javascript/jscomp/RemoveUnusedVars.java",
          "functionStartLine": 336,
          "functionName": "interpretAssigns",
          "functionAnnotation": "",
          "functionDoc": "Look at all the property assigns to all variables.\nThese may or may not count as references. For example,\n\n\u003ccode\u003e\nvar x \u003d {};\nx.foo \u003d 3; // not a reference.\nvar y \u003d foo();\ny.foo \u003d 3; // is a reference.\n\u003c/code\u003e\n\nInterpreting assigments could mark a variable as referenced that\nwasn\u0027t referenced before, in order to keep it alive. Because we find\nreferences by lazily traversing subtrees, marking a variable as\nreferenced could trigger new traversals of new subtrees, which could\nfind new references.\n\nTherefore, this interpretation needs to be run to a fixed point.\n",
          "diff": "@@ -1,25 +1,34 @@\n-private void interpretAssigns(Scope scope) {\n-    for (Iterator\u003cVar\u003e it \u003d scope.getVars(); it.hasNext(); ) {\n-        Var var \u003d it.next();\n-        if (!referenced.contains(var)) {\n-            boolean assignedToUnknownValue \u003d false;\n-            boolean hasPropertyAssign \u003d false;\n-            if (var.getParentNode().getType() \u003d\u003d Token.VAR) {\n-                Node value \u003d var.getInitialValue();\n-                assignedToUnknownValue \u003d value !\u003d null \u0026\u0026 !NodeUtil.isLiteralValue(value, true);\n+private void interpretAssigns() {\n+    boolean changes \u003d false;\n+    do {\n+        changes \u003d false;\n+        for (int current \u003d 0; current \u003c maybeUnreferenced.size(); current++) {\n+            Var var \u003d maybeUnreferenced.get(current);\n+            if (referenced.contains(var)) {\n+                maybeUnreferenced.remove(current);\n+                current--;\n             } else {\n-                assignedToUnknownValue \u003d true;\n-            }\n-            for (Assign assign : assigns.get(var)) {\n-                if (assign.isPropertyAssign) {\n-                    hasPropertyAssign \u003d true;\n-                } else if (!NodeUtil.isLiteralValue(assign.assignNode.getLastChild(), true)) {\n+                boolean assignedToUnknownValue \u003d false;\n+                boolean hasPropertyAssign \u003d false;\n+                if (var.getParentNode().getType() \u003d\u003d Token.VAR) {\n+                    Node value \u003d var.getInitialValue();\n+                    assignedToUnknownValue \u003d value !\u003d null \u0026\u0026 !NodeUtil.isLiteralValue(value, true);\n+                } else {\n                     assignedToUnknownValue \u003d true;\n                 }\n-            }\n-            if (assignedToUnknownValue \u0026\u0026 hasPropertyAssign) {\n-                markReferencedVar(var);\n+                for (Assign assign : assignsByVar.get(var)) {\n+                    if (assign.isPropertyAssign) {\n+                        hasPropertyAssign \u003d true;\n+                    } else if (!NodeUtil.isLiteralValue(assign.assignNode.getLastChild(), true)) {\n+                        assignedToUnknownValue \u003d true;\n+                    }\n+                }\n+                if (assignedToUnknownValue \u0026\u0026 hasPropertyAssign) {\n+                    changes \u003d markReferencedVar(var) || changes;\n+                    maybeUnreferenced.remove(current);\n+                    current--;\n+                }\n             }\n         }\n-    }\n+    } while (changes);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[scope-Scope]",
            "newValue": "[]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "\nChange on 2010/08/04 13:06:31 by nicksantos\n\n\tA new var-collection mechanism for RemoveUnusedVars.  In the\n\tnew mechanism, we only traverse a subtree for references if it\n\tmight have side-effects, or if its return value is used.  If\n\tits return value is stored in a variable, then we store a\n\tcontinuation, and execute the continuation iff that variable\n\tis referenced.\n\n\tThis is a more general formulation of RemoveUnusedVars\u0027s current\n\tstrategy (\"traverse a function iff it\u0027s referenced\").\n\n\tR\u003dacleung\n\tDELTA\u003d560  (326 added, 63 deleted, 171 changed)\n\nChange on 2010/08/04 13:09:34 by rjfioravanti\n\n\tCreating externs for CSSMatrix and WebKitCSSMatrix.\n\n\tBased on documentation from the following locations:\n\thttp://www.w3.org/TR/css3-3d-transforms/#cssmatrix-interface\n\thttp://developer.apple.com/safari/library/documentation/AudioVideo/Reference/WebKitCSSMatrixClassReference/WebKitCSSMatrix/WebKitCSSMatrix.html#//apple_ref/javascript/instm/WebKitCSSMatrix/setMatrixValue\n\n\tR\u003dnicksantos\n\tDELTA\u003d193  (193 added, 0 deleted, 0 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d90012\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@335 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "8/4/10, 5:48 PM",
          "commitName": "747f2504d98e2d37c933ead6e40a0a1a1e36d6af",
          "commitAuthor": "Nicholas.J.Santos",
          "commitDateOld": "7/23/10, 2:49 PM",
          "commitNameOld": "f0362b1ab1ae1339e017b1d04f016980e3fa6cb6",
          "commitAuthorOld": "nicksantos@google.com",
          "daysBetweenCommits": 12.12,
          "commitsBetweenForRepo": 26,
          "commitsBetweenForFile": 1,
          "actualSource": "private void interpretAssigns() {\n    boolean changes \u003d false;\n    do {\n        changes \u003d false;\n        for (int current \u003d 0; current \u003c maybeUnreferenced.size(); current++) {\n            Var var \u003d maybeUnreferenced.get(current);\n            if (referenced.contains(var)) {\n                maybeUnreferenced.remove(current);\n                current--;\n            } else {\n                boolean assignedToUnknownValue \u003d false;\n                boolean hasPropertyAssign \u003d false;\n                if (var.getParentNode().getType() \u003d\u003d Token.VAR) {\n                    Node value \u003d var.getInitialValue();\n                    assignedToUnknownValue \u003d value !\u003d null \u0026\u0026 !NodeUtil.isLiteralValue(value, true);\n                } else {\n                    assignedToUnknownValue \u003d true;\n                }\n                for (Assign assign : assignsByVar.get(var)) {\n                    if (assign.isPropertyAssign) {\n                        hasPropertyAssign \u003d true;\n                    } else if (!NodeUtil.isLiteralValue(assign.assignNode.getLastChild(), true)) {\n                        assignedToUnknownValue \u003d true;\n                    }\n                }\n                if (assignedToUnknownValue \u0026\u0026 hasPropertyAssign) {\n                    changes \u003d markReferencedVar(var) || changes;\n                    maybeUnreferenced.remove(current);\n                    current--;\n                }\n            }\n        }\n    } while (changes);\n}",
          "path": "src/com/google/javascript/jscomp/RemoveUnusedVars.java",
          "functionStartLine": 336,
          "functionName": "interpretAssigns",
          "functionAnnotation": "",
          "functionDoc": "Look at all the property assigns to all variables.\nThese may or may not count as references. For example,\n\n\u003ccode\u003e\nvar x \u003d {};\nx.foo \u003d 3; // not a reference.\nvar y \u003d foo();\ny.foo \u003d 3; // is a reference.\n\u003c/code\u003e\n\nInterpreting assigments could mark a variable as referenced that\nwasn\u0027t referenced before, in order to keep it alive. Because we find\nreferences by lazily traversing subtrees, marking a variable as\nreferenced could trigger new traversals of new subtrees, which could\nfind new references.\n\nTherefore, this interpretation needs to be run to a fixed point.\n",
          "diff": "@@ -1,25 +1,34 @@\n-private void interpretAssigns(Scope scope) {\n-    for (Iterator\u003cVar\u003e it \u003d scope.getVars(); it.hasNext(); ) {\n-        Var var \u003d it.next();\n-        if (!referenced.contains(var)) {\n-            boolean assignedToUnknownValue \u003d false;\n-            boolean hasPropertyAssign \u003d false;\n-            if (var.getParentNode().getType() \u003d\u003d Token.VAR) {\n-                Node value \u003d var.getInitialValue();\n-                assignedToUnknownValue \u003d value !\u003d null \u0026\u0026 !NodeUtil.isLiteralValue(value, true);\n+private void interpretAssigns() {\n+    boolean changes \u003d false;\n+    do {\n+        changes \u003d false;\n+        for (int current \u003d 0; current \u003c maybeUnreferenced.size(); current++) {\n+            Var var \u003d maybeUnreferenced.get(current);\n+            if (referenced.contains(var)) {\n+                maybeUnreferenced.remove(current);\n+                current--;\n             } else {\n-                assignedToUnknownValue \u003d true;\n-            }\n-            for (Assign assign : assigns.get(var)) {\n-                if (assign.isPropertyAssign) {\n-                    hasPropertyAssign \u003d true;\n-                } else if (!NodeUtil.isLiteralValue(assign.assignNode.getLastChild(), true)) {\n+                boolean assignedToUnknownValue \u003d false;\n+                boolean hasPropertyAssign \u003d false;\n+                if (var.getParentNode().getType() \u003d\u003d Token.VAR) {\n+                    Node value \u003d var.getInitialValue();\n+                    assignedToUnknownValue \u003d value !\u003d null \u0026\u0026 !NodeUtil.isLiteralValue(value, true);\n+                } else {\n                     assignedToUnknownValue \u003d true;\n                 }\n-            }\n-            if (assignedToUnknownValue \u0026\u0026 hasPropertyAssign) {\n-                markReferencedVar(var);\n+                for (Assign assign : assignsByVar.get(var)) {\n+                    if (assign.isPropertyAssign) {\n+                        hasPropertyAssign \u003d true;\n+                    } else if (!NodeUtil.isLiteralValue(assign.assignNode.getLastChild(), true)) {\n+                        assignedToUnknownValue \u003d true;\n+                    }\n+                }\n+                if (assignedToUnknownValue \u0026\u0026 hasPropertyAssign) {\n+                    changes \u003d markReferencedVar(var) || changes;\n+                    maybeUnreferenced.remove(current);\n+                    current--;\n+                }\n             }\n         }\n-    }\n+    } while (changes);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "\nChange on 2010/08/04 13:06:31 by nicksantos\n\n\tA new var-collection mechanism for RemoveUnusedVars.  In the\n\tnew mechanism, we only traverse a subtree for references if it\n\tmight have side-effects, or if its return value is used.  If\n\tits return value is stored in a variable, then we store a\n\tcontinuation, and execute the continuation iff that variable\n\tis referenced.\n\n\tThis is a more general formulation of RemoveUnusedVars\u0027s current\n\tstrategy (\"traverse a function iff it\u0027s referenced\").\n\n\tR\u003dacleung\n\tDELTA\u003d560  (326 added, 63 deleted, 171 changed)\n\nChange on 2010/08/04 13:09:34 by rjfioravanti\n\n\tCreating externs for CSSMatrix and WebKitCSSMatrix.\n\n\tBased on documentation from the following locations:\n\thttp://www.w3.org/TR/css3-3d-transforms/#cssmatrix-interface\n\thttp://developer.apple.com/safari/library/documentation/AudioVideo/Reference/WebKitCSSMatrixClassReference/WebKitCSSMatrix/WebKitCSSMatrix.html#//apple_ref/javascript/instm/WebKitCSSMatrix/setMatrixValue\n\n\tR\u003dnicksantos\n\tDELTA\u003d193  (193 added, 0 deleted, 0 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d90012\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@335 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "8/4/10, 5:48 PM",
          "commitName": "747f2504d98e2d37c933ead6e40a0a1a1e36d6af",
          "commitAuthor": "Nicholas.J.Santos",
          "commitDateOld": "7/23/10, 2:49 PM",
          "commitNameOld": "f0362b1ab1ae1339e017b1d04f016980e3fa6cb6",
          "commitAuthorOld": "nicksantos@google.com",
          "daysBetweenCommits": 12.12,
          "commitsBetweenForRepo": 26,
          "commitsBetweenForFile": 1,
          "actualSource": "private void interpretAssigns() {\n    boolean changes \u003d false;\n    do {\n        changes \u003d false;\n        for (int current \u003d 0; current \u003c maybeUnreferenced.size(); current++) {\n            Var var \u003d maybeUnreferenced.get(current);\n            if (referenced.contains(var)) {\n                maybeUnreferenced.remove(current);\n                current--;\n            } else {\n                boolean assignedToUnknownValue \u003d false;\n                boolean hasPropertyAssign \u003d false;\n                if (var.getParentNode().getType() \u003d\u003d Token.VAR) {\n                    Node value \u003d var.getInitialValue();\n                    assignedToUnknownValue \u003d value !\u003d null \u0026\u0026 !NodeUtil.isLiteralValue(value, true);\n                } else {\n                    assignedToUnknownValue \u003d true;\n                }\n                for (Assign assign : assignsByVar.get(var)) {\n                    if (assign.isPropertyAssign) {\n                        hasPropertyAssign \u003d true;\n                    } else if (!NodeUtil.isLiteralValue(assign.assignNode.getLastChild(), true)) {\n                        assignedToUnknownValue \u003d true;\n                    }\n                }\n                if (assignedToUnknownValue \u0026\u0026 hasPropertyAssign) {\n                    changes \u003d markReferencedVar(var) || changes;\n                    maybeUnreferenced.remove(current);\n                    current--;\n                }\n            }\n        }\n    } while (changes);\n}",
          "path": "src/com/google/javascript/jscomp/RemoveUnusedVars.java",
          "functionStartLine": 336,
          "functionName": "interpretAssigns",
          "functionAnnotation": "",
          "functionDoc": "Look at all the property assigns to all variables.\nThese may or may not count as references. For example,\n\n\u003ccode\u003e\nvar x \u003d {};\nx.foo \u003d 3; // not a reference.\nvar y \u003d foo();\ny.foo \u003d 3; // is a reference.\n\u003c/code\u003e\n\nInterpreting assigments could mark a variable as referenced that\nwasn\u0027t referenced before, in order to keep it alive. Because we find\nreferences by lazily traversing subtrees, marking a variable as\nreferenced could trigger new traversals of new subtrees, which could\nfind new references.\n\nTherefore, this interpretation needs to be run to a fixed point.\n",
          "diff": "@@ -1,25 +1,34 @@\n-private void interpretAssigns(Scope scope) {\n-    for (Iterator\u003cVar\u003e it \u003d scope.getVars(); it.hasNext(); ) {\n-        Var var \u003d it.next();\n-        if (!referenced.contains(var)) {\n-            boolean assignedToUnknownValue \u003d false;\n-            boolean hasPropertyAssign \u003d false;\n-            if (var.getParentNode().getType() \u003d\u003d Token.VAR) {\n-                Node value \u003d var.getInitialValue();\n-                assignedToUnknownValue \u003d value !\u003d null \u0026\u0026 !NodeUtil.isLiteralValue(value, true);\n+private void interpretAssigns() {\n+    boolean changes \u003d false;\n+    do {\n+        changes \u003d false;\n+        for (int current \u003d 0; current \u003c maybeUnreferenced.size(); current++) {\n+            Var var \u003d maybeUnreferenced.get(current);\n+            if (referenced.contains(var)) {\n+                maybeUnreferenced.remove(current);\n+                current--;\n             } else {\n-                assignedToUnknownValue \u003d true;\n-            }\n-            for (Assign assign : assigns.get(var)) {\n-                if (assign.isPropertyAssign) {\n-                    hasPropertyAssign \u003d true;\n-                } else if (!NodeUtil.isLiteralValue(assign.assignNode.getLastChild(), true)) {\n+                boolean assignedToUnknownValue \u003d false;\n+                boolean hasPropertyAssign \u003d false;\n+                if (var.getParentNode().getType() \u003d\u003d Token.VAR) {\n+                    Node value \u003d var.getInitialValue();\n+                    assignedToUnknownValue \u003d value !\u003d null \u0026\u0026 !NodeUtil.isLiteralValue(value, true);\n+                } else {\n                     assignedToUnknownValue \u003d true;\n                 }\n-            }\n-            if (assignedToUnknownValue \u0026\u0026 hasPropertyAssign) {\n-                markReferencedVar(var);\n+                for (Assign assign : assignsByVar.get(var)) {\n+                    if (assign.isPropertyAssign) {\n+                        hasPropertyAssign \u003d true;\n+                    } else if (!NodeUtil.isLiteralValue(assign.assignNode.getLastChild(), true)) {\n+                        assignedToUnknownValue \u003d true;\n+                    }\n+                }\n+                if (assignedToUnknownValue \u0026\u0026 hasPropertyAssign) {\n+                    changes \u003d markReferencedVar(var) || changes;\n+                    maybeUnreferenced.remove(current);\n+                    current--;\n+                }\n             }\n         }\n-    }\n+    } while (changes);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Look at all the property assigns to all variables in the given\nscope. These may or may not count as references. For example,\n\n\u003ccode\u003e\nvar x \u003d {};\nx.foo \u003d 3; // not a reference.\nvar y \u003d foo();\ny.foo \u003d 3; // is a reference.\n\u003c/code\u003e\n",
            "newValue": "Look at all the property assigns to all variables.\nThese may or may not count as references. For example,\n\n\u003ccode\u003e\nvar x \u003d {};\nx.foo \u003d 3; // not a reference.\nvar y \u003d foo();\ny.foo \u003d 3; // is a reference.\n\u003c/code\u003e\n\nInterpreting assigments could mark a variable as referenced that\nwasn\u0027t referenced before, in order to keep it alive. Because we find\nreferences by lazily traversing subtrees, marking a variable as\nreferenced could trigger new traversals of new subtrees, which could\nfind new references.\n\nTherefore, this interpretation needs to be run to a fixed point.\n"
          }
        }
      ]
    },
    "f0362b1ab1ae1339e017b1d04f016980e3fa6cb6": {
      "type": "Ybodychange",
      "commitMessage": "\nfix a bug where NodeUtil was reporting function literals\nas immutable. functions are mutable.\nMake isLiteralValue a bit more flexible, so that it can\nidentify function literals.\ndo some additional folding on function literals.\n\nR\u003dacleung\nDELTA\u003d68  (35 added, 1 deleted, 32 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d64001\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@308 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "7/23/10, 2:49 PM",
      "commitName": "f0362b1ab1ae1339e017b1d04f016980e3fa6cb6",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "7/15/10, 2:02 PM",
      "commitNameOld": "833cd72a268c1161194038faf0d98ec6b1f203eb",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 8.03,
      "commitsBetweenForRepo": 27,
      "commitsBetweenForFile": 1,
      "actualSource": "private void interpretAssigns(Scope scope) {\n    for (Iterator\u003cVar\u003e it \u003d scope.getVars(); it.hasNext(); ) {\n        Var var \u003d it.next();\n        if (!referenced.contains(var)) {\n            boolean assignedToUnknownValue \u003d false;\n            boolean hasPropertyAssign \u003d false;\n            if (var.getParentNode().getType() \u003d\u003d Token.VAR) {\n                Node value \u003d var.getInitialValue();\n                assignedToUnknownValue \u003d value !\u003d null \u0026\u0026 !NodeUtil.isLiteralValue(value, true);\n            } else {\n                assignedToUnknownValue \u003d true;\n            }\n            for (Assign assign : assigns.get(var)) {\n                if (assign.isPropertyAssign) {\n                    hasPropertyAssign \u003d true;\n                } else if (!NodeUtil.isLiteralValue(assign.assignNode.getLastChild(), true)) {\n                    assignedToUnknownValue \u003d true;\n                }\n            }\n            if (assignedToUnknownValue \u0026\u0026 hasPropertyAssign) {\n                markReferencedVar(var);\n            }\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/RemoveUnusedVars.java",
      "functionStartLine": 229,
      "functionName": "interpretAssigns",
      "functionAnnotation": "",
      "functionDoc": "Look at all the property assigns to all variables in the given\nscope. These may or may not count as references. For example,\n\n\u003ccode\u003e\nvar x \u003d {};\nx.foo \u003d 3; // not a reference.\nvar y \u003d foo();\ny.foo \u003d 3; // is a reference.\n\u003c/code\u003e\n",
      "diff": "@@ -1,25 +1,25 @@\n private void interpretAssigns(Scope scope) {\n     for (Iterator\u003cVar\u003e it \u003d scope.getVars(); it.hasNext(); ) {\n         Var var \u003d it.next();\n         if (!referenced.contains(var)) {\n             boolean assignedToUnknownValue \u003d false;\n             boolean hasPropertyAssign \u003d false;\n             if (var.getParentNode().getType() \u003d\u003d Token.VAR) {\n                 Node value \u003d var.getInitialValue();\n-                assignedToUnknownValue \u003d value !\u003d null \u0026\u0026 !NodeUtil.isLiteralValue(value);\n+                assignedToUnknownValue \u003d value !\u003d null \u0026\u0026 !NodeUtil.isLiteralValue(value, true);\n             } else {\n                 assignedToUnknownValue \u003d true;\n             }\n             for (Assign assign : assigns.get(var)) {\n                 if (assign.isPropertyAssign) {\n                     hasPropertyAssign \u003d true;\n-                } else if (!NodeUtil.isLiteralValue(assign.assignNode.getLastChild())) {\n+                } else if (!NodeUtil.isLiteralValue(assign.assignNode.getLastChild(), true)) {\n                     assignedToUnknownValue \u003d true;\n                 }\n             }\n             if (assignedToUnknownValue \u0026\u0026 hasPropertyAssign) {\n                 markReferencedVar(var);\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "833cd72a268c1161194038faf0d98ec6b1f203eb": {
      "type": "Yintroduced",
      "commitMessage": "\nMake RemoveUnusedVars a lot smarter about dead assigns.\nGranted, it\u0027s still nowhere near as smart as the real dead-assignment\npass, so maybe it\u0027d be better to say that this makes the pass\nless dumb.\n\nR\u003dacleung\nDELTA\u003d251  (222 added, 15 deleted, 14 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d52002\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@281 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "7/15/10, 2:02 PM",
      "commitName": "833cd72a268c1161194038faf0d98ec6b1f203eb",
      "commitAuthor": "nicksantos@google.com",
      "diff": "@@ -0,0 +1,25 @@\n+private void interpretAssigns(Scope scope) {\n+    for (Iterator\u003cVar\u003e it \u003d scope.getVars(); it.hasNext(); ) {\n+        Var var \u003d it.next();\n+        if (!referenced.contains(var)) {\n+            boolean assignedToUnknownValue \u003d false;\n+            boolean hasPropertyAssign \u003d false;\n+            if (var.getParentNode().getType() \u003d\u003d Token.VAR) {\n+                Node value \u003d var.getInitialValue();\n+                assignedToUnknownValue \u003d value !\u003d null \u0026\u0026 !NodeUtil.isLiteralValue(value);\n+            } else {\n+                assignedToUnknownValue \u003d true;\n+            }\n+            for (Assign assign : assigns.get(var)) {\n+                if (assign.isPropertyAssign) {\n+                    hasPropertyAssign \u003d true;\n+                } else if (!NodeUtil.isLiteralValue(assign.assignNode.getLastChild())) {\n+                    assignedToUnknownValue \u003d true;\n+                }\n+            }\n+            if (assignedToUnknownValue \u0026\u0026 hasPropertyAssign) {\n+                markReferencedVar(var);\n+            }\n+        }\n+    }\n+}\n\\ No newline at end of file\n",
      "actualSource": "private void interpretAssigns(Scope scope) {\n    for (Iterator\u003cVar\u003e it \u003d scope.getVars(); it.hasNext(); ) {\n        Var var \u003d it.next();\n        if (!referenced.contains(var)) {\n            boolean assignedToUnknownValue \u003d false;\n            boolean hasPropertyAssign \u003d false;\n            if (var.getParentNode().getType() \u003d\u003d Token.VAR) {\n                Node value \u003d var.getInitialValue();\n                assignedToUnknownValue \u003d value !\u003d null \u0026\u0026 !NodeUtil.isLiteralValue(value);\n            } else {\n                assignedToUnknownValue \u003d true;\n            }\n            for (Assign assign : assigns.get(var)) {\n                if (assign.isPropertyAssign) {\n                    hasPropertyAssign \u003d true;\n                } else if (!NodeUtil.isLiteralValue(assign.assignNode.getLastChild())) {\n                    assignedToUnknownValue \u003d true;\n                }\n            }\n            if (assignedToUnknownValue \u0026\u0026 hasPropertyAssign) {\n                markReferencedVar(var);\n            }\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/RemoveUnusedVars.java",
      "functionStartLine": 229,
      "functionName": "interpretAssigns",
      "functionAnnotation": "",
      "functionDoc": "Look at all the property assigns to all variables in the given\nscope. These may or may not count as references. For example,\n\n\u003ccode\u003e\nvar x \u003d {};\nx.foo \u003d 3; // not a reference.\nvar y \u003d foo();\ny.foo \u003d 3; // is a reference.\n\u003c/code\u003e\n"
    }
  }
}