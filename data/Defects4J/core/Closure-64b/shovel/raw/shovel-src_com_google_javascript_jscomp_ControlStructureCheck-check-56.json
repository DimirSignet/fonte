{
  "origin": "codeshovel",
  "repositoryName": "Closure-64b",
  "repositoryPath": "/tmp/Closure-64b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ControlStructureCheck.java",
  "functionName": "check",
  "functionId": "check___node-Node",
  "sourceFilePath": "src/com/google/javascript/jscomp/ControlStructureCheck.java",
  "functionAnnotation": "",
  "functionDoc": "Reports errors for any invalid use of control structures.\n\n@param node Current node to check.\n",
  "functionStartLine": 56,
  "functionEndLine": 78,
  "numCommitsSeen": 13,
  "timeTaken": 469,
  "changeHistory": [
    "845f5ff65858fd0d1829f3d2f16f758725e8028f",
    "3924ff1e4a236d68a0b5448d185537d90ca04419",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3"
  ],
  "changeHistoryShort": {
    "845f5ff65858fd0d1829f3d2f16f758725e8028f": "Ymultichange(Yparameterchange,Ybodychange,Ydocchange)",
    "3924ff1e4a236d68a0b5448d185537d90ca04419": "Ybodychange",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "845f5ff65858fd0d1829f3d2f16f758725e8028f": {
      "type": "Ymultichange(Yparameterchange,Ybodychange,Ydocchange)",
      "commitMessage": "Add buttloads of tests.\n\nRewrite JSDoc inference to be more redundant, which should help it\nto be more robust.\n\nAssorted other fixes.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@20 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "12/7/09, 1:53 PM",
      "commitName": "845f5ff65858fd0d1829f3d2f16f758725e8028f",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Add buttloads of tests.\n\nRewrite JSDoc inference to be more redundant, which should help it\nto be more robust.\n\nAssorted other fixes.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@20 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "12/7/09, 1:53 PM",
          "commitName": "845f5ff65858fd0d1829f3d2f16f758725e8028f",
          "commitAuthor": "nicholas.j.santos@gmail.com",
          "commitDateOld": "12/2/09, 5:12 PM",
          "commitNameOld": "3924ff1e4a236d68a0b5448d185537d90ca04419",
          "commitAuthorOld": "nicholas.j.santos@gmail.com",
          "daysBetweenCommits": 4.86,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "private void check(Node node) {\n    switch(node.getType()) {\n        case Token.WITH:\n            JSDocInfo info \u003d node.getJSDocInfo();\n            boolean allowWith \u003d info !\u003d null \u0026\u0026 info.getSuppressions().contains(\"with\");\n            if (!allowWith) {\n                report(node, USE_OF_WITH);\n            }\n            break;\n        case Token.SCRIPT:\n            sourceName \u003d (String) node.getProp(Node.SOURCENAME_PROP);\n            break;\n    }\n    for (Node bChild \u003d node.getFirstChild(); bChild !\u003d null; ) {\n        Node next \u003d bChild.getNext();\n        check(bChild);\n        bChild \u003d next;\n    }\n}",
          "path": "src/com/google/javascript/jscomp/ControlStructureCheck.java",
          "functionStartLine": 52,
          "functionName": "check",
          "functionAnnotation": "",
          "functionDoc": "Reports errors for any invalid use of control structures.\n\n@param node Current node to check.\n",
          "diff": "@@ -1,87 +1,19 @@\n-private void check(Node node, boolean inLoop, boolean inSwitch) {\n+private void check(Node node) {\n     switch(node.getType()) {\n         case Token.WITH:\n             JSDocInfo info \u003d node.getJSDocInfo();\n             boolean allowWith \u003d info !\u003d null \u0026\u0026 info.getSuppressions().contains(\"with\");\n             if (!allowWith) {\n                 report(node, USE_OF_WITH);\n             }\n             break;\n-        case Token.FUNCTION:\n-            Deque\u003cString\u003e oldSwitchLabels \u003d switchLabels;\n-            switchLabels \u003d new ArrayDeque\u003cString\u003e();\n-            Node body \u003d node.getFirstChild().getNext().getNext();\n-            check(body, false, false);\n-            switchLabels \u003d oldSwitchLabels;\n-            break;\n-        case Token.FOR:\n-            Node child \u003d node.getFirstChild();\n-            check(child, inLoop, inSwitch);\n-            child \u003d child.getNext();\n-            check(child, inLoop, inSwitch);\n-            child \u003d child.getNext();\n-            if (child.getNext() \u003d\u003d null) {\n-                check(child, true, inSwitch);\n-            } else {\n-                check(child, inLoop, inSwitch);\n-                check(child.getNext(), true, inSwitch);\n-            }\n-            break;\n-        case Token.WHILE:\n-            check(node.getFirstChild(), inLoop, inSwitch);\n-            check(node.getFirstChild().getNext(), true, inSwitch);\n-            break;\n-        case Token.DO:\n-            check(node.getFirstChild(), true, inSwitch);\n-            break;\n-        case Token.SWITCH:\n-            check(node.getFirstChild(), inLoop, inSwitch);\n-            for (Node cChild \u003d node.getFirstChild().getNext(); cChild !\u003d null; ) {\n-                Node next \u003d cChild.getNext();\n-                check(cChild, inLoop, true);\n-                cChild \u003d next;\n-            }\n-            break;\n         case Token.SCRIPT:\n             sourceName \u003d (String) node.getProp(Node.SOURCENAME_PROP);\n-            for (Node sChild \u003d node.getFirstChild(); sChild !\u003d null; ) {\n-                Node next \u003d sChild.getNext();\n-                check(sChild, false, false);\n-                sChild \u003d next;\n-            }\n             break;\n-        case Token.LABEL:\n-            Node switchNode \u003d node.getLastChild();\n-            if (switchNode.getType() \u003d\u003d Token.SWITCH) {\n-                String label \u003d node.getFirstChild().getString();\n-                switchLabels.addFirst(label);\n-                check(node.getFirstChild().getNext(), inLoop, inSwitch);\n-                switchLabels.removeFirst();\n-            } else {\n-                check(node.getFirstChild().getNext(), inLoop, inSwitch);\n-            }\n-            break;\n-        case Token.BREAK:\n-            if (!node.hasChildren() \u0026\u0026 !inLoop \u0026\u0026 !inSwitch) {\n-                report(node, INVALID_BREAK);\n-            }\n-            break;\n-        case Token.CONTINUE:\n-            if (!inLoop) {\n-                report(node, INVALID_CONTINUE);\n-            }\n-            if (node.hasChildren()) {\n-                Node label \u003d node.getFirstChild();\n-                if (switchLabels.contains(label.getString())) {\n-                    report(node, INVALID_LABEL_CONTINUE);\n-                }\n-            }\n-            break;\n-        default:\n-            for (Node bChild \u003d node.getFirstChild(); bChild !\u003d null; ) {\n-                Node next \u003d bChild.getNext();\n-                check(bChild, inLoop, inSwitch);\n-                bChild \u003d next;\n-            }\n+    }\n+    for (Node bChild \u003d node.getFirstChild(); bChild !\u003d null; ) {\n+        Node next \u003d bChild.getNext();\n+        check(bChild);\n+        bChild \u003d next;\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[node-Node, inLoop-boolean, inSwitch-boolean]",
            "newValue": "[node-Node]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Add buttloads of tests.\n\nRewrite JSDoc inference to be more redundant, which should help it\nto be more robust.\n\nAssorted other fixes.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@20 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "12/7/09, 1:53 PM",
          "commitName": "845f5ff65858fd0d1829f3d2f16f758725e8028f",
          "commitAuthor": "nicholas.j.santos@gmail.com",
          "commitDateOld": "12/2/09, 5:12 PM",
          "commitNameOld": "3924ff1e4a236d68a0b5448d185537d90ca04419",
          "commitAuthorOld": "nicholas.j.santos@gmail.com",
          "daysBetweenCommits": 4.86,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "private void check(Node node) {\n    switch(node.getType()) {\n        case Token.WITH:\n            JSDocInfo info \u003d node.getJSDocInfo();\n            boolean allowWith \u003d info !\u003d null \u0026\u0026 info.getSuppressions().contains(\"with\");\n            if (!allowWith) {\n                report(node, USE_OF_WITH);\n            }\n            break;\n        case Token.SCRIPT:\n            sourceName \u003d (String) node.getProp(Node.SOURCENAME_PROP);\n            break;\n    }\n    for (Node bChild \u003d node.getFirstChild(); bChild !\u003d null; ) {\n        Node next \u003d bChild.getNext();\n        check(bChild);\n        bChild \u003d next;\n    }\n}",
          "path": "src/com/google/javascript/jscomp/ControlStructureCheck.java",
          "functionStartLine": 52,
          "functionName": "check",
          "functionAnnotation": "",
          "functionDoc": "Reports errors for any invalid use of control structures.\n\n@param node Current node to check.\n",
          "diff": "@@ -1,87 +1,19 @@\n-private void check(Node node, boolean inLoop, boolean inSwitch) {\n+private void check(Node node) {\n     switch(node.getType()) {\n         case Token.WITH:\n             JSDocInfo info \u003d node.getJSDocInfo();\n             boolean allowWith \u003d info !\u003d null \u0026\u0026 info.getSuppressions().contains(\"with\");\n             if (!allowWith) {\n                 report(node, USE_OF_WITH);\n             }\n             break;\n-        case Token.FUNCTION:\n-            Deque\u003cString\u003e oldSwitchLabels \u003d switchLabels;\n-            switchLabels \u003d new ArrayDeque\u003cString\u003e();\n-            Node body \u003d node.getFirstChild().getNext().getNext();\n-            check(body, false, false);\n-            switchLabels \u003d oldSwitchLabels;\n-            break;\n-        case Token.FOR:\n-            Node child \u003d node.getFirstChild();\n-            check(child, inLoop, inSwitch);\n-            child \u003d child.getNext();\n-            check(child, inLoop, inSwitch);\n-            child \u003d child.getNext();\n-            if (child.getNext() \u003d\u003d null) {\n-                check(child, true, inSwitch);\n-            } else {\n-                check(child, inLoop, inSwitch);\n-                check(child.getNext(), true, inSwitch);\n-            }\n-            break;\n-        case Token.WHILE:\n-            check(node.getFirstChild(), inLoop, inSwitch);\n-            check(node.getFirstChild().getNext(), true, inSwitch);\n-            break;\n-        case Token.DO:\n-            check(node.getFirstChild(), true, inSwitch);\n-            break;\n-        case Token.SWITCH:\n-            check(node.getFirstChild(), inLoop, inSwitch);\n-            for (Node cChild \u003d node.getFirstChild().getNext(); cChild !\u003d null; ) {\n-                Node next \u003d cChild.getNext();\n-                check(cChild, inLoop, true);\n-                cChild \u003d next;\n-            }\n-            break;\n         case Token.SCRIPT:\n             sourceName \u003d (String) node.getProp(Node.SOURCENAME_PROP);\n-            for (Node sChild \u003d node.getFirstChild(); sChild !\u003d null; ) {\n-                Node next \u003d sChild.getNext();\n-                check(sChild, false, false);\n-                sChild \u003d next;\n-            }\n             break;\n-        case Token.LABEL:\n-            Node switchNode \u003d node.getLastChild();\n-            if (switchNode.getType() \u003d\u003d Token.SWITCH) {\n-                String label \u003d node.getFirstChild().getString();\n-                switchLabels.addFirst(label);\n-                check(node.getFirstChild().getNext(), inLoop, inSwitch);\n-                switchLabels.removeFirst();\n-            } else {\n-                check(node.getFirstChild().getNext(), inLoop, inSwitch);\n-            }\n-            break;\n-        case Token.BREAK:\n-            if (!node.hasChildren() \u0026\u0026 !inLoop \u0026\u0026 !inSwitch) {\n-                report(node, INVALID_BREAK);\n-            }\n-            break;\n-        case Token.CONTINUE:\n-            if (!inLoop) {\n-                report(node, INVALID_CONTINUE);\n-            }\n-            if (node.hasChildren()) {\n-                Node label \u003d node.getFirstChild();\n-                if (switchLabels.contains(label.getString())) {\n-                    report(node, INVALID_LABEL_CONTINUE);\n-                }\n-            }\n-            break;\n-        default:\n-            for (Node bChild \u003d node.getFirstChild(); bChild !\u003d null; ) {\n-                Node next \u003d bChild.getNext();\n-                check(bChild, inLoop, inSwitch);\n-                bChild \u003d next;\n-            }\n+    }\n+    for (Node bChild \u003d node.getFirstChild(); bChild !\u003d null; ) {\n+        Node next \u003d bChild.getNext();\n+        check(bChild);\n+        bChild \u003d next;\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Add buttloads of tests.\n\nRewrite JSDoc inference to be more redundant, which should help it\nto be more robust.\n\nAssorted other fixes.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@20 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "12/7/09, 1:53 PM",
          "commitName": "845f5ff65858fd0d1829f3d2f16f758725e8028f",
          "commitAuthor": "nicholas.j.santos@gmail.com",
          "commitDateOld": "12/2/09, 5:12 PM",
          "commitNameOld": "3924ff1e4a236d68a0b5448d185537d90ca04419",
          "commitAuthorOld": "nicholas.j.santos@gmail.com",
          "daysBetweenCommits": 4.86,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "private void check(Node node) {\n    switch(node.getType()) {\n        case Token.WITH:\n            JSDocInfo info \u003d node.getJSDocInfo();\n            boolean allowWith \u003d info !\u003d null \u0026\u0026 info.getSuppressions().contains(\"with\");\n            if (!allowWith) {\n                report(node, USE_OF_WITH);\n            }\n            break;\n        case Token.SCRIPT:\n            sourceName \u003d (String) node.getProp(Node.SOURCENAME_PROP);\n            break;\n    }\n    for (Node bChild \u003d node.getFirstChild(); bChild !\u003d null; ) {\n        Node next \u003d bChild.getNext();\n        check(bChild);\n        bChild \u003d next;\n    }\n}",
          "path": "src/com/google/javascript/jscomp/ControlStructureCheck.java",
          "functionStartLine": 52,
          "functionName": "check",
          "functionAnnotation": "",
          "functionDoc": "Reports errors for any invalid use of control structures.\n\n@param node Current node to check.\n",
          "diff": "@@ -1,87 +1,19 @@\n-private void check(Node node, boolean inLoop, boolean inSwitch) {\n+private void check(Node node) {\n     switch(node.getType()) {\n         case Token.WITH:\n             JSDocInfo info \u003d node.getJSDocInfo();\n             boolean allowWith \u003d info !\u003d null \u0026\u0026 info.getSuppressions().contains(\"with\");\n             if (!allowWith) {\n                 report(node, USE_OF_WITH);\n             }\n             break;\n-        case Token.FUNCTION:\n-            Deque\u003cString\u003e oldSwitchLabels \u003d switchLabels;\n-            switchLabels \u003d new ArrayDeque\u003cString\u003e();\n-            Node body \u003d node.getFirstChild().getNext().getNext();\n-            check(body, false, false);\n-            switchLabels \u003d oldSwitchLabels;\n-            break;\n-        case Token.FOR:\n-            Node child \u003d node.getFirstChild();\n-            check(child, inLoop, inSwitch);\n-            child \u003d child.getNext();\n-            check(child, inLoop, inSwitch);\n-            child \u003d child.getNext();\n-            if (child.getNext() \u003d\u003d null) {\n-                check(child, true, inSwitch);\n-            } else {\n-                check(child, inLoop, inSwitch);\n-                check(child.getNext(), true, inSwitch);\n-            }\n-            break;\n-        case Token.WHILE:\n-            check(node.getFirstChild(), inLoop, inSwitch);\n-            check(node.getFirstChild().getNext(), true, inSwitch);\n-            break;\n-        case Token.DO:\n-            check(node.getFirstChild(), true, inSwitch);\n-            break;\n-        case Token.SWITCH:\n-            check(node.getFirstChild(), inLoop, inSwitch);\n-            for (Node cChild \u003d node.getFirstChild().getNext(); cChild !\u003d null; ) {\n-                Node next \u003d cChild.getNext();\n-                check(cChild, inLoop, true);\n-                cChild \u003d next;\n-            }\n-            break;\n         case Token.SCRIPT:\n             sourceName \u003d (String) node.getProp(Node.SOURCENAME_PROP);\n-            for (Node sChild \u003d node.getFirstChild(); sChild !\u003d null; ) {\n-                Node next \u003d sChild.getNext();\n-                check(sChild, false, false);\n-                sChild \u003d next;\n-            }\n             break;\n-        case Token.LABEL:\n-            Node switchNode \u003d node.getLastChild();\n-            if (switchNode.getType() \u003d\u003d Token.SWITCH) {\n-                String label \u003d node.getFirstChild().getString();\n-                switchLabels.addFirst(label);\n-                check(node.getFirstChild().getNext(), inLoop, inSwitch);\n-                switchLabels.removeFirst();\n-            } else {\n-                check(node.getFirstChild().getNext(), inLoop, inSwitch);\n-            }\n-            break;\n-        case Token.BREAK:\n-            if (!node.hasChildren() \u0026\u0026 !inLoop \u0026\u0026 !inSwitch) {\n-                report(node, INVALID_BREAK);\n-            }\n-            break;\n-        case Token.CONTINUE:\n-            if (!inLoop) {\n-                report(node, INVALID_CONTINUE);\n-            }\n-            if (node.hasChildren()) {\n-                Node label \u003d node.getFirstChild();\n-                if (switchLabels.contains(label.getString())) {\n-                    report(node, INVALID_LABEL_CONTINUE);\n-                }\n-            }\n-            break;\n-        default:\n-            for (Node bChild \u003d node.getFirstChild(); bChild !\u003d null; ) {\n-                Node next \u003d bChild.getNext();\n-                check(bChild, inLoop, inSwitch);\n-                bChild \u003d next;\n-            }\n+    }\n+    for (Node bChild \u003d node.getFirstChild(); bChild !\u003d null; ) {\n+        Node next \u003d bChild.getNext();\n+        check(bChild);\n+        bChild \u003d next;\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Reports errors for any invalid breaks and continues in an AST. This method\nuses recursion to perform a pre-order traversal. It keeps track the\niteration-statement nest depth and switch-statement nest depth. If there is\na break or continue in the AST but there is no corresponding nesting of\niteration-statement or switch-statement, the function will report an error.\nAlso, it keeps track of the labels for switch-statements. If a labeled\ncontinue-statement points to a switch-statement, it will also report an\nerror.\n\u003cp\u003e\nThere is no need to verify that a label has actually been defined because\nthe parser has already done so.\n\u003cp\u003e\nTODO(user): Use a light version of NodeTraversal for this and other\nsimilar passes.\n\n@param node Current node to check.\n@param inLoop Is there a loop above this node.\n@param inSwitch Is there a switch above this node.\n",
            "newValue": "Reports errors for any invalid use of control structures.\n\n@param node Current node to check.\n"
          }
        }
      ]
    },
    "3924ff1e4a236d68a0b5448d185537d90ca04419": {
      "type": "Ybodychange",
      "commitMessage": "Warn about all with statements, unless there\u0027s an explicit\n/** @suppress {with} */ tag\n\nRefactor a bunch of stuff into PassConfigs\n\nAdd a bunch of parser tests.\n\nUp-integrate John and Norris\u0027 latest changes to Rhino at trunk\n\nMinor type-tightening bug fixes.\n\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@18 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "12/2/09, 5:12 PM",
      "commitName": "3924ff1e4a236d68a0b5448d185537d90ca04419",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "commitDateOld": "11/3/09, 3:51 PM",
      "commitNameOld": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthorOld": "nicholas.j.santos@gmail.com",
      "daysBetweenCommits": 29.06,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "actualSource": "private void check(Node node, boolean inLoop, boolean inSwitch) {\n    switch(node.getType()) {\n        case Token.WITH:\n            JSDocInfo info \u003d node.getJSDocInfo();\n            boolean allowWith \u003d info !\u003d null \u0026\u0026 info.getSuppressions().contains(\"with\");\n            if (!allowWith) {\n                report(node, USE_OF_WITH);\n            }\n            break;\n        case Token.FUNCTION:\n            Deque\u003cString\u003e oldSwitchLabels \u003d switchLabels;\n            switchLabels \u003d new ArrayDeque\u003cString\u003e();\n            Node body \u003d node.getFirstChild().getNext().getNext();\n            check(body, false, false);\n            switchLabels \u003d oldSwitchLabels;\n            break;\n        case Token.FOR:\n            Node child \u003d node.getFirstChild();\n            check(child, inLoop, inSwitch);\n            child \u003d child.getNext();\n            check(child, inLoop, inSwitch);\n            child \u003d child.getNext();\n            if (child.getNext() \u003d\u003d null) {\n                check(child, true, inSwitch);\n            } else {\n                check(child, inLoop, inSwitch);\n                check(child.getNext(), true, inSwitch);\n            }\n            break;\n        case Token.WHILE:\n            check(node.getFirstChild(), inLoop, inSwitch);\n            check(node.getFirstChild().getNext(), true, inSwitch);\n            break;\n        case Token.DO:\n            check(node.getFirstChild(), true, inSwitch);\n            break;\n        case Token.SWITCH:\n            check(node.getFirstChild(), inLoop, inSwitch);\n            for (Node cChild \u003d node.getFirstChild().getNext(); cChild !\u003d null; ) {\n                Node next \u003d cChild.getNext();\n                check(cChild, inLoop, true);\n                cChild \u003d next;\n            }\n            break;\n        case Token.SCRIPT:\n            sourceName \u003d (String) node.getProp(Node.SOURCENAME_PROP);\n            for (Node sChild \u003d node.getFirstChild(); sChild !\u003d null; ) {\n                Node next \u003d sChild.getNext();\n                check(sChild, false, false);\n                sChild \u003d next;\n            }\n            break;\n        case Token.LABEL:\n            Node switchNode \u003d node.getLastChild();\n            if (switchNode.getType() \u003d\u003d Token.SWITCH) {\n                String label \u003d node.getFirstChild().getString();\n                switchLabels.addFirst(label);\n                check(node.getFirstChild().getNext(), inLoop, inSwitch);\n                switchLabels.removeFirst();\n            } else {\n                check(node.getFirstChild().getNext(), inLoop, inSwitch);\n            }\n            break;\n        case Token.BREAK:\n            if (!node.hasChildren() \u0026\u0026 !inLoop \u0026\u0026 !inSwitch) {\n                report(node, INVALID_BREAK);\n            }\n            break;\n        case Token.CONTINUE:\n            if (!inLoop) {\n                report(node, INVALID_CONTINUE);\n            }\n            if (node.hasChildren()) {\n                Node label \u003d node.getFirstChild();\n                if (switchLabels.contains(label.getString())) {\n                    report(node, INVALID_LABEL_CONTINUE);\n                }\n            }\n            break;\n        default:\n            for (Node bChild \u003d node.getFirstChild(); bChild !\u003d null; ) {\n                Node next \u003d bChild.getNext();\n                check(bChild, inLoop, inSwitch);\n                bChild \u003d next;\n            }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/ControlStructureCheck.java",
      "functionStartLine": 85,
      "functionName": "check",
      "functionAnnotation": "",
      "functionDoc": "Reports errors for any invalid breaks and continues in an AST. This method\nuses recursion to perform a pre-order traversal. It keeps track the\niteration-statement nest depth and switch-statement nest depth. If there is\na break or continue in the AST but there is no corresponding nesting of\niteration-statement or switch-statement, the function will report an error.\nAlso, it keeps track of the labels for switch-statements. If a labeled\ncontinue-statement points to a switch-statement, it will also report an\nerror.\n\u003cp\u003e\nThere is no need to verify that a label has actually been defined because\nthe parser has already done so.\n\u003cp\u003e\nTODO(user): Use a light version of NodeTraversal for this and other\nsimilar passes.\n\n@param node Current node to check.\n@param inLoop Is there a loop above this node.\n@param inSwitch Is there a switch above this node.\n",
      "diff": "@@ -1,80 +1,87 @@\n private void check(Node node, boolean inLoop, boolean inSwitch) {\n     switch(node.getType()) {\n+        case Token.WITH:\n+            JSDocInfo info \u003d node.getJSDocInfo();\n+            boolean allowWith \u003d info !\u003d null \u0026\u0026 info.getSuppressions().contains(\"with\");\n+            if (!allowWith) {\n+                report(node, USE_OF_WITH);\n+            }\n+            break;\n         case Token.FUNCTION:\n             Deque\u003cString\u003e oldSwitchLabels \u003d switchLabels;\n             switchLabels \u003d new ArrayDeque\u003cString\u003e();\n             Node body \u003d node.getFirstChild().getNext().getNext();\n             check(body, false, false);\n             switchLabels \u003d oldSwitchLabels;\n             break;\n         case Token.FOR:\n             Node child \u003d node.getFirstChild();\n             check(child, inLoop, inSwitch);\n             child \u003d child.getNext();\n             check(child, inLoop, inSwitch);\n             child \u003d child.getNext();\n             if (child.getNext() \u003d\u003d null) {\n                 check(child, true, inSwitch);\n             } else {\n                 check(child, inLoop, inSwitch);\n                 check(child.getNext(), true, inSwitch);\n             }\n             break;\n         case Token.WHILE:\n             check(node.getFirstChild(), inLoop, inSwitch);\n             check(node.getFirstChild().getNext(), true, inSwitch);\n             break;\n         case Token.DO:\n             check(node.getFirstChild(), true, inSwitch);\n             break;\n         case Token.SWITCH:\n             check(node.getFirstChild(), inLoop, inSwitch);\n             for (Node cChild \u003d node.getFirstChild().getNext(); cChild !\u003d null; ) {\n                 Node next \u003d cChild.getNext();\n                 check(cChild, inLoop, true);\n                 cChild \u003d next;\n             }\n             break;\n         case Token.SCRIPT:\n             sourceName \u003d (String) node.getProp(Node.SOURCENAME_PROP);\n             for (Node sChild \u003d node.getFirstChild(); sChild !\u003d null; ) {\n                 Node next \u003d sChild.getNext();\n                 check(sChild, false, false);\n                 sChild \u003d next;\n             }\n             break;\n         case Token.LABEL:\n             Node switchNode \u003d node.getLastChild();\n             if (switchNode.getType() \u003d\u003d Token.SWITCH) {\n                 String label \u003d node.getFirstChild().getString();\n                 switchLabels.addFirst(label);\n                 check(node.getFirstChild().getNext(), inLoop, inSwitch);\n                 switchLabels.removeFirst();\n             } else {\n                 check(node.getFirstChild().getNext(), inLoop, inSwitch);\n             }\n             break;\n         case Token.BREAK:\n             if (!node.hasChildren() \u0026\u0026 !inLoop \u0026\u0026 !inSwitch) {\n                 report(node, INVALID_BREAK);\n             }\n             break;\n         case Token.CONTINUE:\n             if (!inLoop) {\n                 report(node, INVALID_CONTINUE);\n             }\n             if (node.hasChildren()) {\n                 Node label \u003d node.getFirstChild();\n                 if (switchLabels.contains(label.getString())) {\n                     report(node, INVALID_LABEL_CONTINUE);\n                 }\n             }\n             break;\n         default:\n             for (Node bChild \u003d node.getFirstChild(); bChild !\u003d null; ) {\n                 Node next \u003d bChild.getNext();\n                 check(bChild, inLoop, inSwitch);\n                 bChild \u003d next;\n             }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": {
      "type": "Yintroduced",
      "commitMessage": "Initial commit.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/3/09, 3:51 PM",
      "commitName": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "diff": "@@ -0,0 +1,80 @@\n+private void check(Node node, boolean inLoop, boolean inSwitch) {\n+    switch(node.getType()) {\n+        case Token.FUNCTION:\n+            Deque\u003cString\u003e oldSwitchLabels \u003d switchLabels;\n+            switchLabels \u003d new ArrayDeque\u003cString\u003e();\n+            Node body \u003d node.getFirstChild().getNext().getNext();\n+            check(body, false, false);\n+            switchLabels \u003d oldSwitchLabels;\n+            break;\n+        case Token.FOR:\n+            Node child \u003d node.getFirstChild();\n+            check(child, inLoop, inSwitch);\n+            child \u003d child.getNext();\n+            check(child, inLoop, inSwitch);\n+            child \u003d child.getNext();\n+            if (child.getNext() \u003d\u003d null) {\n+                check(child, true, inSwitch);\n+            } else {\n+                check(child, inLoop, inSwitch);\n+                check(child.getNext(), true, inSwitch);\n+            }\n+            break;\n+        case Token.WHILE:\n+            check(node.getFirstChild(), inLoop, inSwitch);\n+            check(node.getFirstChild().getNext(), true, inSwitch);\n+            break;\n+        case Token.DO:\n+            check(node.getFirstChild(), true, inSwitch);\n+            break;\n+        case Token.SWITCH:\n+            check(node.getFirstChild(), inLoop, inSwitch);\n+            for (Node cChild \u003d node.getFirstChild().getNext(); cChild !\u003d null; ) {\n+                Node next \u003d cChild.getNext();\n+                check(cChild, inLoop, true);\n+                cChild \u003d next;\n+            }\n+            break;\n+        case Token.SCRIPT:\n+            sourceName \u003d (String) node.getProp(Node.SOURCENAME_PROP);\n+            for (Node sChild \u003d node.getFirstChild(); sChild !\u003d null; ) {\n+                Node next \u003d sChild.getNext();\n+                check(sChild, false, false);\n+                sChild \u003d next;\n+            }\n+            break;\n+        case Token.LABEL:\n+            Node switchNode \u003d node.getLastChild();\n+            if (switchNode.getType() \u003d\u003d Token.SWITCH) {\n+                String label \u003d node.getFirstChild().getString();\n+                switchLabels.addFirst(label);\n+                check(node.getFirstChild().getNext(), inLoop, inSwitch);\n+                switchLabels.removeFirst();\n+            } else {\n+                check(node.getFirstChild().getNext(), inLoop, inSwitch);\n+            }\n+            break;\n+        case Token.BREAK:\n+            if (!node.hasChildren() \u0026\u0026 !inLoop \u0026\u0026 !inSwitch) {\n+                report(node, INVALID_BREAK);\n+            }\n+            break;\n+        case Token.CONTINUE:\n+            if (!inLoop) {\n+                report(node, INVALID_CONTINUE);\n+            }\n+            if (node.hasChildren()) {\n+                Node label \u003d node.getFirstChild();\n+                if (switchLabels.contains(label.getString())) {\n+                    report(node, INVALID_LABEL_CONTINUE);\n+                }\n+            }\n+            break;\n+        default:\n+            for (Node bChild \u003d node.getFirstChild(); bChild !\u003d null; ) {\n+                Node next \u003d bChild.getNext();\n+                check(bChild, inLoop, inSwitch);\n+                bChild \u003d next;\n+            }\n+    }\n+}\n\\ No newline at end of file\n",
      "actualSource": "private void check(Node node, boolean inLoop, boolean inSwitch) {\n    switch(node.getType()) {\n        case Token.FUNCTION:\n            Deque\u003cString\u003e oldSwitchLabels \u003d switchLabels;\n            switchLabels \u003d new ArrayDeque\u003cString\u003e();\n            Node body \u003d node.getFirstChild().getNext().getNext();\n            check(body, false, false);\n            switchLabels \u003d oldSwitchLabels;\n            break;\n        case Token.FOR:\n            Node child \u003d node.getFirstChild();\n            check(child, inLoop, inSwitch);\n            child \u003d child.getNext();\n            check(child, inLoop, inSwitch);\n            child \u003d child.getNext();\n            if (child.getNext() \u003d\u003d null) {\n                check(child, true, inSwitch);\n            } else {\n                check(child, inLoop, inSwitch);\n                check(child.getNext(), true, inSwitch);\n            }\n            break;\n        case Token.WHILE:\n            check(node.getFirstChild(), inLoop, inSwitch);\n            check(node.getFirstChild().getNext(), true, inSwitch);\n            break;\n        case Token.DO:\n            check(node.getFirstChild(), true, inSwitch);\n            break;\n        case Token.SWITCH:\n            check(node.getFirstChild(), inLoop, inSwitch);\n            for (Node cChild \u003d node.getFirstChild().getNext(); cChild !\u003d null; ) {\n                Node next \u003d cChild.getNext();\n                check(cChild, inLoop, true);\n                cChild \u003d next;\n            }\n            break;\n        case Token.SCRIPT:\n            sourceName \u003d (String) node.getProp(Node.SOURCENAME_PROP);\n            for (Node sChild \u003d node.getFirstChild(); sChild !\u003d null; ) {\n                Node next \u003d sChild.getNext();\n                check(sChild, false, false);\n                sChild \u003d next;\n            }\n            break;\n        case Token.LABEL:\n            Node switchNode \u003d node.getLastChild();\n            if (switchNode.getType() \u003d\u003d Token.SWITCH) {\n                String label \u003d node.getFirstChild().getString();\n                switchLabels.addFirst(label);\n                check(node.getFirstChild().getNext(), inLoop, inSwitch);\n                switchLabels.removeFirst();\n            } else {\n                check(node.getFirstChild().getNext(), inLoop, inSwitch);\n            }\n            break;\n        case Token.BREAK:\n            if (!node.hasChildren() \u0026\u0026 !inLoop \u0026\u0026 !inSwitch) {\n                report(node, INVALID_BREAK);\n            }\n            break;\n        case Token.CONTINUE:\n            if (!inLoop) {\n                report(node, INVALID_CONTINUE);\n            }\n            if (node.hasChildren()) {\n                Node label \u003d node.getFirstChild();\n                if (switchLabels.contains(label.getString())) {\n                    report(node, INVALID_LABEL_CONTINUE);\n                }\n            }\n            break;\n        default:\n            for (Node bChild \u003d node.getFirstChild(); bChild !\u003d null; ) {\n                Node next \u003d bChild.getNext();\n                check(bChild, inLoop, inSwitch);\n                bChild \u003d next;\n            }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/ControlStructureCheck.java",
      "functionStartLine": 80,
      "functionName": "check",
      "functionAnnotation": "",
      "functionDoc": "Reports errors for any invalid breaks and continues in an AST. This method\nuses recursion to perform a pre-order traversal. It keeps track the\niteration-statement nest depth and switch-statement nest depth. If there is\na break or continue in the AST but there is no corresponding nesting of\niteration-statement or switch-statement, the function will report an error.\nAlso, it keeps track of the labels for switch-statements. If a labeled\ncontinue-statement points to a switch-statement, it will also report an\nerror.\n\u003cp\u003e\nThere is no need to verify that a label has actually been defined because\nthe parser has already done so.\n\u003cp\u003e\nTODO(user): Use a light version of NodeTraversal for this and other\nsimilar passes.\n\n@param node Current node to check.\n@param inLoop Is there a loop above this node.\n@param inSwitch Is there a switch above this node.\n"
    }
  }
}