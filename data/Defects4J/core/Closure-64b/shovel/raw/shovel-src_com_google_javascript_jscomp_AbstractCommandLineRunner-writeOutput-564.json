{
  "origin": "codeshovel",
  "repositoryName": "Closure-64b",
  "repositoryPath": "/tmp/Closure-64b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "AbstractCommandLineRunner.java",
  "functionName": "writeOutput",
  "functionId": "writeOutput___out-Appendable__compiler-Compiler__code-String__wrapper-String__codePlaceholder-String",
  "sourceFilePath": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
  "functionAnnotation": "",
  "functionDoc": "Writes code to an output stream, optionally wrapping it in an arbitrary\nwrapper that contains a placeholder where the code should be inserted.\n",
  "functionStartLine": 564,
  "functionEndLine": 595,
  "numCommitsSeen": 81,
  "timeTaken": 3382,
  "changeHistory": [
    "82a9956c6337d2f5d4a94ebe624d64faa54d9182",
    "848ace840362a1f5558bec065cb40548ff66587a",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3"
  ],
  "changeHistoryShort": {
    "82a9956c6337d2f5d4a94ebe624d64faa54d9182": "Ymultichange(Yparameterchange,Yexceptionschange,Ybodychange)",
    "848ace840362a1f5558bec065cb40548ff66587a": "Yfilerename",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "82a9956c6337d2f5d4a94ebe624d64faa54d9182": {
      "type": "Ymultichange(Yparameterchange,Yexceptionschange,Ybodychange)",
      "commitMessage": "\nChange on 2010/07/09 08:36:29 by nicksantos\n\n        when injecting param checks, do not inject them before any function\n        declarations, because that will break normalization constraints.\n\n        R\u003djohnlenz\n        DELTA\u003d22  (18 added, 0 deleted, 4 changed)\n\nChange on 2010/07/09 09:36:54 by johnlenz\n\n        Prefer FileWriter to PrintStream when charset translation isn\u0027t needed.\n\n        R\u003dacleung\n        DELTA\u003d68  (13 added, 2 deleted, 53 changed)\n\nChange on 2010/07/09 10:54:42 by nicksantos\n\n        our mechanism for injecting boilerplate does not work\n        for code that uses @const externs. So just don\u0027t use\n        any @const externs.\n\n        R\u003djohnlenz\n        DELTA\u003d3  (1 added, 0 deleted, 2 changed)\n\nChange on 2010/07/09 11:30:29 by nicksantos\n\n        Scan functional properties of object literals for invalid use\n        of \"this\".\n        Fixes issue 182.\n\n        R\u003dacleung\n        DELTA\u003d21  (19 added, 0 deleted, 2 changed)\n\nChange on 2010/07/09 12:40:16 by dcc\n\n        Separate pass instance for peephole preprocessing.\n        Now that I\u0027m writing instructions for how people can add their own\n        peephole passes, I want to make sure that the preprocessing\n        peephole optimizations that relies on don\u0027t get disturbed.\n\n        R\u003djohnlenz\n        DELTA\u003d18  (15 added, 0 deleted, 3 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d49008\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@270 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "7/9/10, 4:02 PM",
      "commitName": "82a9956c6337d2f5d4a94ebe624d64faa54d9182",
      "commitAuthor": "Nicholas.J.Santos",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "\nChange on 2010/07/09 08:36:29 by nicksantos\n\n        when injecting param checks, do not inject them before any function\n        declarations, because that will break normalization constraints.\n\n        R\u003djohnlenz\n        DELTA\u003d22  (18 added, 0 deleted, 4 changed)\n\nChange on 2010/07/09 09:36:54 by johnlenz\n\n        Prefer FileWriter to PrintStream when charset translation isn\u0027t needed.\n\n        R\u003dacleung\n        DELTA\u003d68  (13 added, 2 deleted, 53 changed)\n\nChange on 2010/07/09 10:54:42 by nicksantos\n\n        our mechanism for injecting boilerplate does not work\n        for code that uses @const externs. So just don\u0027t use\n        any @const externs.\n\n        R\u003djohnlenz\n        DELTA\u003d3  (1 added, 0 deleted, 2 changed)\n\nChange on 2010/07/09 11:30:29 by nicksantos\n\n        Scan functional properties of object literals for invalid use\n        of \"this\".\n        Fixes issue 182.\n\n        R\u003dacleung\n        DELTA\u003d21  (19 added, 0 deleted, 2 changed)\n\nChange on 2010/07/09 12:40:16 by dcc\n\n        Separate pass instance for peephole preprocessing.\n        Now that I\u0027m writing instructions for how people can add their own\n        peephole passes, I want to make sure that the preprocessing\n        peephole optimizations that relies on don\u0027t get disturbed.\n\n        R\u003djohnlenz\n        DELTA\u003d18  (15 added, 0 deleted, 3 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d49008\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@270 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "7/9/10, 4:02 PM",
          "commitName": "82a9956c6337d2f5d4a94ebe624d64faa54d9182",
          "commitAuthor": "Nicholas.J.Santos",
          "commitDateOld": "7/8/10, 5:15 PM",
          "commitNameOld": "0c8a0c53b2124d05b017a63bdbc720a57c89ead2",
          "commitAuthorOld": "Nicholas.J.Santos",
          "daysBetweenCommits": 0.95,
          "commitsBetweenForRepo": 3,
          "commitsBetweenForFile": 1,
          "actualSource": "static void writeOutput(Appendable out, Compiler compiler, String code, String wrapper, String codePlaceholder) throws IOException {\n    int pos \u003d wrapper.indexOf(codePlaceholder);\n    if (pos !\u003d -1) {\n        String prefix \u003d \"\";\n        if (pos \u003e 0) {\n            prefix \u003d wrapper.substring(0, pos);\n            out.append(prefix);\n        }\n        out.append(code);\n        int suffixStart \u003d pos + codePlaceholder.length();\n        if (suffixStart !\u003d wrapper.length()) {\n            out.append(wrapper.substring(suffixStart));\n        }\n        out.append(\u0027\\n\u0027);\n        if (compiler !\u003d null \u0026\u0026 compiler.getSourceMap() !\u003d null) {\n            compiler.getSourceMap().setWrapperPrefix(prefix);\n        }\n    } else {\n        out.append(code);\n        out.append(\u0027\\n\u0027);\n    }\n}",
          "path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
          "functionStartLine": 426,
          "functionName": "writeOutput",
          "functionAnnotation": "",
          "functionDoc": "Writes code to an output stream, optionally wrapping it in an arbitrary\nwrapper that contains a placeholder where the code should be inserted.\n",
          "diff": "@@ -1,22 +1,22 @@\n-static void writeOutput(PrintStream out, Compiler compiler, String code, String wrapper, String codePlaceholder) {\n+static void writeOutput(Appendable out, Compiler compiler, String code, String wrapper, String codePlaceholder) throws IOException {\n     int pos \u003d wrapper.indexOf(codePlaceholder);\n     if (pos !\u003d -1) {\n         String prefix \u003d \"\";\n         if (pos \u003e 0) {\n             prefix \u003d wrapper.substring(0, pos);\n-            out.print(prefix);\n+            out.append(prefix);\n         }\n-        out.print(code);\n+        out.append(code);\n         int suffixStart \u003d pos + codePlaceholder.length();\n-        if (suffixStart \u003d\u003d wrapper.length()) {\n-            out.println();\n-        } else {\n-            out.println(wrapper.substring(suffixStart));\n+        if (suffixStart !\u003d wrapper.length()) {\n+            out.append(wrapper.substring(suffixStart));\n         }\n+        out.append(\u0027\\n\u0027);\n         if (compiler !\u003d null \u0026\u0026 compiler.getSourceMap() !\u003d null) {\n             compiler.getSourceMap().setWrapperPrefix(prefix);\n         }\n     } else {\n-        out.println(code);\n+        out.append(code);\n+        out.append(\u0027\\n\u0027);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[out-PrintStream, compiler-Compiler, code-String, wrapper-String, codePlaceholder-String]",
            "newValue": "[out-Appendable, compiler-Compiler, code-String, wrapper-String, codePlaceholder-String]"
          }
        },
        {
          "type": "Yexceptionschange",
          "commitMessage": "\nChange on 2010/07/09 08:36:29 by nicksantos\n\n        when injecting param checks, do not inject them before any function\n        declarations, because that will break normalization constraints.\n\n        R\u003djohnlenz\n        DELTA\u003d22  (18 added, 0 deleted, 4 changed)\n\nChange on 2010/07/09 09:36:54 by johnlenz\n\n        Prefer FileWriter to PrintStream when charset translation isn\u0027t needed.\n\n        R\u003dacleung\n        DELTA\u003d68  (13 added, 2 deleted, 53 changed)\n\nChange on 2010/07/09 10:54:42 by nicksantos\n\n        our mechanism for injecting boilerplate does not work\n        for code that uses @const externs. So just don\u0027t use\n        any @const externs.\n\n        R\u003djohnlenz\n        DELTA\u003d3  (1 added, 0 deleted, 2 changed)\n\nChange on 2010/07/09 11:30:29 by nicksantos\n\n        Scan functional properties of object literals for invalid use\n        of \"this\".\n        Fixes issue 182.\n\n        R\u003dacleung\n        DELTA\u003d21  (19 added, 0 deleted, 2 changed)\n\nChange on 2010/07/09 12:40:16 by dcc\n\n        Separate pass instance for peephole preprocessing.\n        Now that I\u0027m writing instructions for how people can add their own\n        peephole passes, I want to make sure that the preprocessing\n        peephole optimizations that relies on don\u0027t get disturbed.\n\n        R\u003djohnlenz\n        DELTA\u003d18  (15 added, 0 deleted, 3 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d49008\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@270 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "7/9/10, 4:02 PM",
          "commitName": "82a9956c6337d2f5d4a94ebe624d64faa54d9182",
          "commitAuthor": "Nicholas.J.Santos",
          "commitDateOld": "7/8/10, 5:15 PM",
          "commitNameOld": "0c8a0c53b2124d05b017a63bdbc720a57c89ead2",
          "commitAuthorOld": "Nicholas.J.Santos",
          "daysBetweenCommits": 0.95,
          "commitsBetweenForRepo": 3,
          "commitsBetweenForFile": 1,
          "actualSource": "static void writeOutput(Appendable out, Compiler compiler, String code, String wrapper, String codePlaceholder) throws IOException {\n    int pos \u003d wrapper.indexOf(codePlaceholder);\n    if (pos !\u003d -1) {\n        String prefix \u003d \"\";\n        if (pos \u003e 0) {\n            prefix \u003d wrapper.substring(0, pos);\n            out.append(prefix);\n        }\n        out.append(code);\n        int suffixStart \u003d pos + codePlaceholder.length();\n        if (suffixStart !\u003d wrapper.length()) {\n            out.append(wrapper.substring(suffixStart));\n        }\n        out.append(\u0027\\n\u0027);\n        if (compiler !\u003d null \u0026\u0026 compiler.getSourceMap() !\u003d null) {\n            compiler.getSourceMap().setWrapperPrefix(prefix);\n        }\n    } else {\n        out.append(code);\n        out.append(\u0027\\n\u0027);\n    }\n}",
          "path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
          "functionStartLine": 426,
          "functionName": "writeOutput",
          "functionAnnotation": "",
          "functionDoc": "Writes code to an output stream, optionally wrapping it in an arbitrary\nwrapper that contains a placeholder where the code should be inserted.\n",
          "diff": "@@ -1,22 +1,22 @@\n-static void writeOutput(PrintStream out, Compiler compiler, String code, String wrapper, String codePlaceholder) {\n+static void writeOutput(Appendable out, Compiler compiler, String code, String wrapper, String codePlaceholder) throws IOException {\n     int pos \u003d wrapper.indexOf(codePlaceholder);\n     if (pos !\u003d -1) {\n         String prefix \u003d \"\";\n         if (pos \u003e 0) {\n             prefix \u003d wrapper.substring(0, pos);\n-            out.print(prefix);\n+            out.append(prefix);\n         }\n-        out.print(code);\n+        out.append(code);\n         int suffixStart \u003d pos + codePlaceholder.length();\n-        if (suffixStart \u003d\u003d wrapper.length()) {\n-            out.println();\n-        } else {\n-            out.println(wrapper.substring(suffixStart));\n+        if (suffixStart !\u003d wrapper.length()) {\n+            out.append(wrapper.substring(suffixStart));\n         }\n+        out.append(\u0027\\n\u0027);\n         if (compiler !\u003d null \u0026\u0026 compiler.getSourceMap() !\u003d null) {\n             compiler.getSourceMap().setWrapperPrefix(prefix);\n         }\n     } else {\n-        out.println(code);\n+        out.append(code);\n+        out.append(\u0027\\n\u0027);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[IOException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "\nChange on 2010/07/09 08:36:29 by nicksantos\n\n        when injecting param checks, do not inject them before any function\n        declarations, because that will break normalization constraints.\n\n        R\u003djohnlenz\n        DELTA\u003d22  (18 added, 0 deleted, 4 changed)\n\nChange on 2010/07/09 09:36:54 by johnlenz\n\n        Prefer FileWriter to PrintStream when charset translation isn\u0027t needed.\n\n        R\u003dacleung\n        DELTA\u003d68  (13 added, 2 deleted, 53 changed)\n\nChange on 2010/07/09 10:54:42 by nicksantos\n\n        our mechanism for injecting boilerplate does not work\n        for code that uses @const externs. So just don\u0027t use\n        any @const externs.\n\n        R\u003djohnlenz\n        DELTA\u003d3  (1 added, 0 deleted, 2 changed)\n\nChange on 2010/07/09 11:30:29 by nicksantos\n\n        Scan functional properties of object literals for invalid use\n        of \"this\".\n        Fixes issue 182.\n\n        R\u003dacleung\n        DELTA\u003d21  (19 added, 0 deleted, 2 changed)\n\nChange on 2010/07/09 12:40:16 by dcc\n\n        Separate pass instance for peephole preprocessing.\n        Now that I\u0027m writing instructions for how people can add their own\n        peephole passes, I want to make sure that the preprocessing\n        peephole optimizations that relies on don\u0027t get disturbed.\n\n        R\u003djohnlenz\n        DELTA\u003d18  (15 added, 0 deleted, 3 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d49008\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@270 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "7/9/10, 4:02 PM",
          "commitName": "82a9956c6337d2f5d4a94ebe624d64faa54d9182",
          "commitAuthor": "Nicholas.J.Santos",
          "commitDateOld": "7/8/10, 5:15 PM",
          "commitNameOld": "0c8a0c53b2124d05b017a63bdbc720a57c89ead2",
          "commitAuthorOld": "Nicholas.J.Santos",
          "daysBetweenCommits": 0.95,
          "commitsBetweenForRepo": 3,
          "commitsBetweenForFile": 1,
          "actualSource": "static void writeOutput(Appendable out, Compiler compiler, String code, String wrapper, String codePlaceholder) throws IOException {\n    int pos \u003d wrapper.indexOf(codePlaceholder);\n    if (pos !\u003d -1) {\n        String prefix \u003d \"\";\n        if (pos \u003e 0) {\n            prefix \u003d wrapper.substring(0, pos);\n            out.append(prefix);\n        }\n        out.append(code);\n        int suffixStart \u003d pos + codePlaceholder.length();\n        if (suffixStart !\u003d wrapper.length()) {\n            out.append(wrapper.substring(suffixStart));\n        }\n        out.append(\u0027\\n\u0027);\n        if (compiler !\u003d null \u0026\u0026 compiler.getSourceMap() !\u003d null) {\n            compiler.getSourceMap().setWrapperPrefix(prefix);\n        }\n    } else {\n        out.append(code);\n        out.append(\u0027\\n\u0027);\n    }\n}",
          "path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
          "functionStartLine": 426,
          "functionName": "writeOutput",
          "functionAnnotation": "",
          "functionDoc": "Writes code to an output stream, optionally wrapping it in an arbitrary\nwrapper that contains a placeholder where the code should be inserted.\n",
          "diff": "@@ -1,22 +1,22 @@\n-static void writeOutput(PrintStream out, Compiler compiler, String code, String wrapper, String codePlaceholder) {\n+static void writeOutput(Appendable out, Compiler compiler, String code, String wrapper, String codePlaceholder) throws IOException {\n     int pos \u003d wrapper.indexOf(codePlaceholder);\n     if (pos !\u003d -1) {\n         String prefix \u003d \"\";\n         if (pos \u003e 0) {\n             prefix \u003d wrapper.substring(0, pos);\n-            out.print(prefix);\n+            out.append(prefix);\n         }\n-        out.print(code);\n+        out.append(code);\n         int suffixStart \u003d pos + codePlaceholder.length();\n-        if (suffixStart \u003d\u003d wrapper.length()) {\n-            out.println();\n-        } else {\n-            out.println(wrapper.substring(suffixStart));\n+        if (suffixStart !\u003d wrapper.length()) {\n+            out.append(wrapper.substring(suffixStart));\n         }\n+        out.append(\u0027\\n\u0027);\n         if (compiler !\u003d null \u0026\u0026 compiler.getSourceMap() !\u003d null) {\n             compiler.getSourceMap().setWrapperPrefix(prefix);\n         }\n     } else {\n-        out.println(code);\n+        out.append(code);\n+        out.append(\u0027\\n\u0027);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "848ace840362a1f5558bec065cb40548ff66587a": {
      "type": "Yfilerename",
      "commitMessage": "Rename CompilerRunner -\u003e CommandLineRunner.\nI\u0027ll also do this for JSCompilerRunner, but it will be a much\nbigger change. (Nick)\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@119 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "2/26/10, 6:04 PM",
      "commitName": "848ace840362a1f5558bec065cb40548ff66587a",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "2/26/10, 3:45 PM",
      "commitNameOld": "50c1b3d39ff5b17c956a2235f97f7b5da05ab6f0",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "static void writeOutput(PrintStream out, Compiler compiler, String code, String wrapper, String codePlaceholder) {\n    int pos \u003d wrapper.indexOf(codePlaceholder);\n    if (pos !\u003d -1) {\n        String prefix \u003d \"\";\n        if (pos \u003e 0) {\n            prefix \u003d wrapper.substring(0, pos);\n            out.print(prefix);\n        }\n        out.print(code);\n        int suffixStart \u003d pos + codePlaceholder.length();\n        if (suffixStart \u003d\u003d wrapper.length()) {\n            out.println();\n        } else {\n            out.println(wrapper.substring(suffixStart));\n        }\n        if (compiler !\u003d null \u0026\u0026 compiler.getSourceMap() !\u003d null) {\n            compiler.getSourceMap().setWrapperPrefix(prefix);\n        }\n    } else {\n        out.println(code);\n    }\n}",
      "path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
      "functionStartLine": 571,
      "functionName": "writeOutput",
      "functionAnnotation": "",
      "functionDoc": "Writes code to an output stream, optionally wrapping it in an arbitrary\nwrapper that contains a placeholder where the code should be inserted.\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/com/google/javascript/jscomp/AbstractCompilerRunner.java",
        "newPath": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java"
      }
    },
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": {
      "type": "Yintroduced",
      "commitMessage": "Initial commit.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/3/09, 3:51 PM",
      "commitName": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "diff": "@@ -0,0 +1,22 @@\n+static void writeOutput(PrintStream out, Compiler compiler, String code, String wrapper, String codePlaceholder) {\n+    int pos \u003d wrapper.indexOf(codePlaceholder);\n+    if (pos !\u003d -1) {\n+        String prefix \u003d \"\";\n+        if (pos \u003e 0) {\n+            prefix \u003d wrapper.substring(0, pos);\n+            out.print(prefix);\n+        }\n+        out.print(code);\n+        int suffixStart \u003d pos + codePlaceholder.length();\n+        if (suffixStart \u003d\u003d wrapper.length()) {\n+            out.println();\n+        } else {\n+            out.println(wrapper.substring(suffixStart));\n+        }\n+        if (compiler !\u003d null \u0026\u0026 compiler.getSourceMap() !\u003d null) {\n+            compiler.getSourceMap().setWrapperPrefix(prefix);\n+        }\n+    } else {\n+        out.println(code);\n+    }\n+}\n\\ No newline at end of file\n",
      "actualSource": "static void writeOutput(PrintStream out, Compiler compiler, String code, String wrapper, String codePlaceholder) {\n    int pos \u003d wrapper.indexOf(codePlaceholder);\n    if (pos !\u003d -1) {\n        String prefix \u003d \"\";\n        if (pos \u003e 0) {\n            prefix \u003d wrapper.substring(0, pos);\n            out.print(prefix);\n        }\n        out.print(code);\n        int suffixStart \u003d pos + codePlaceholder.length();\n        if (suffixStart \u003d\u003d wrapper.length()) {\n            out.println();\n        } else {\n            out.println(wrapper.substring(suffixStart));\n        }\n        if (compiler !\u003d null \u0026\u0026 compiler.getSourceMap() !\u003d null) {\n            compiler.getSourceMap().setWrapperPrefix(prefix);\n        }\n    } else {\n        out.println(code);\n    }\n}",
      "path": "src/com/google/javascript/jscomp/AbstractCompilerRunner.java",
      "functionStartLine": 454,
      "functionName": "writeOutput",
      "functionAnnotation": "",
      "functionDoc": "Writes code to an output stream, optionally wrapping it in an arbitrary\nwrapper that contains a placeholder where the code should be inserted.\n"
    }
  }
}