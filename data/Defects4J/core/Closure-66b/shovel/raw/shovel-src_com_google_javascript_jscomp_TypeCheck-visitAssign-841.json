{
  "origin": "codeshovel",
  "repositoryName": "Closure-66b",
  "repositoryPath": "/tmp/Closure-66b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "TypeCheck.java",
  "functionName": "visitAssign",
  "functionId": "visitAssign___t-NodeTraversal__assign-Node",
  "sourceFilePath": "src/com/google/javascript/jscomp/TypeCheck.java",
  "functionAnnotation": "",
  "functionDoc": "Visits an assignment \u003ccode\u003elvalue \u003d rvalue\u003c/code\u003e. If the\n\u003ccode\u003elvalue\u003c/code\u003e is a prototype modification, we change the schema\nof the object type it is referring to.\n\n@param t the traversal\n@param assign the assign node\n(\u003ccode\u003eassign.getType() \u003d\u003d Token.ASSIGN\u003c/code\u003e is an implicit invariant)\n",
  "functionStartLine": 841,
  "functionEndLine": 946,
  "numCommitsSeen": 46,
  "timeTaken": 3560,
  "changeHistory": [
    "c764a46abf211d4677fadc33f7d466e5b14fa088",
    "a2d8936fae3eb0e3873c7f7c0233344c81436404",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3"
  ],
  "changeHistoryShort": {
    "c764a46abf211d4677fadc33f7d466e5b14fa088": "Ybodychange",
    "a2d8936fae3eb0e3873c7f7c0233344c81436404": "Ybodychange",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "c764a46abf211d4677fadc33f7d466e5b14fa088": {
      "type": "Ybodychange",
      "commitMessage": "\nChange on 2010/04/13 by john\n\n        Here is a crazy thought, let\u0027s not require the JSTypeRegistry during\n        parsing.\n\n        There are basically two changes here:\n        1) The IRFactory was looking for enums to seed the JSTypeRegistry, so\n        we do that when we setup for type interence.\n        2) The JSDocParser was checking the types of @defines objects, now do\n        that during ProcessDefines.\n\n        R\u003drobert,mark\n        DELTA\u003d207  (82 added, 89 deleted, 36 changed)\n\nChange on 2010/04/14 by nick\n\n        Add a debugging function for JSType hashcodes.\n        i found this useful, and thought others might too.\n\n        R\u003djohn\n        DELTA\u003d69  (69 added, 0 deleted, 0 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003dfqsoxx\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@183 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/14/10, 9:15 AM",
      "commitName": "c764a46abf211d4677fadc33f7d466e5b14fa088",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "4/5/10, 12:30 PM",
      "commitNameOld": "222eafd303155b3eac5cd244584b2cb3c4c11975",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 8.86,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "actualSource": "private void visitAssign(NodeTraversal t, Node assign) {\n    JSDocInfo info \u003d assign.getJSDocInfo();\n    Node lvalue \u003d assign.getFirstChild();\n    Node rvalue \u003d assign.getLastChild();\n    if (lvalue.getType() \u003d\u003d Token.GETPROP) {\n        Node object \u003d lvalue.getFirstChild();\n        JSType objectJsType \u003d getJSType(object);\n        String property \u003d lvalue.getLastChild().getString();\n        if (object.getType() \u003d\u003d Token.GETPROP) {\n            JSType jsType \u003d getJSType(object.getFirstChild());\n            if (jsType.isInterface() \u0026\u0026 object.getLastChild().getString().equals(\"prototype\")) {\n                visitInterfaceGetprop(t, assign, object, property, lvalue, rvalue);\n            }\n        }\n        if (info !\u003d null \u0026\u0026 info.hasType()) {\n            visitAnnotatedAssignGetprop(t, assign, info.getType().evaluate(t.getScope(), typeRegistry), object, property, rvalue);\n            return;\n        }\n        if (info !\u003d null \u0026\u0026 info.hasEnumParameterType()) {\n            checkEnumInitializer(t, rvalue, info.getEnumParameterType().evaluate(t.getScope(), typeRegistry));\n            return;\n        }\n        if (property.equals(\"prototype\")) {\n            if (objectJsType instanceof FunctionType) {\n                FunctionType functionType \u003d (FunctionType) objectJsType;\n                if (functionType.isConstructor()) {\n                    JSType rvalueType \u003d rvalue.getJSType();\n                    validator.expectObject(t, rvalue, rvalueType, OVERRIDING_PROTOTYPE_WITH_NON_OBJECT);\n                }\n            } else {\n            }\n            return;\n        }\n        if (object.getType() \u003d\u003d Token.GETPROP) {\n            Node object2 \u003d object.getFirstChild();\n            String property2 \u003d NodeUtil.getStringValue(object.getLastChild());\n            if (\"prototype\".equals(property2)) {\n                JSType jsType \u003d object2.getJSType();\n                if (jsType instanceof FunctionType) {\n                    FunctionType functionType \u003d (FunctionType) jsType;\n                    if (functionType.isConstructor() || functionType.isInterface()) {\n                        checkDeclaredPropertyInheritance(t, assign, functionType, property, info, getJSType(rvalue));\n                    }\n                } else {\n                }\n                return;\n            }\n        }\n        ObjectType type \u003d ObjectType.cast(objectJsType.restrictByNotNullOrUndefined());\n        if (type !\u003d null) {\n            if (type.hasProperty(property) \u0026\u0026 !type.isPropertyTypeInferred(property) \u0026\u0026 !propertyIsImplicitCast(type, property)) {\n                validator.expectCanAssignToPropertyOf(t, assign, getJSType(rvalue), type.getPropertyType(property), object, property);\n            }\n            return;\n        }\n    } else if (lvalue.getType() \u003d\u003d Token.NAME) {\n        JSType rvalueType \u003d getJSType(assign.getLastChild());\n        Var var \u003d t.getScope().getVar(lvalue.getString());\n        if (var !\u003d null) {\n            if (var.isTypeInferred()) {\n                return;\n            }\n        }\n    }\n    JSType leftType \u003d getJSType(lvalue);\n    Node rightChild \u003d assign.getLastChild();\n    JSType rightType \u003d getJSType(rightChild);\n    if (validator.expectCanAssignTo(t, assign, rightType, leftType, \"assignment\")) {\n        ensureTyped(t, assign, rightType);\n    } else {\n        ensureTyped(t, assign);\n    }\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 840,
      "functionName": "visitAssign",
      "functionAnnotation": "",
      "functionDoc": "Visits an assignment \u003ccode\u003elvalue \u003d rvalue\u003c/code\u003e. If the\n\u003ccode\u003elvalue\u003c/code\u003e is a prototype modification, we change the schema\nof the object type it is referring to.\n\n@param t the traversal\n@param assign the assign node\n(\u003ccode\u003eassign.getType() \u003d\u003d Token.ASSIGN\u003c/code\u003e is an implicit invariant)\n",
      "diff": "@@ -1,73 +1,73 @@\n private void visitAssign(NodeTraversal t, Node assign) {\n     JSDocInfo info \u003d assign.getJSDocInfo();\n     Node lvalue \u003d assign.getFirstChild();\n     Node rvalue \u003d assign.getLastChild();\n     if (lvalue.getType() \u003d\u003d Token.GETPROP) {\n         Node object \u003d lvalue.getFirstChild();\n         JSType objectJsType \u003d getJSType(object);\n         String property \u003d lvalue.getLastChild().getString();\n         if (object.getType() \u003d\u003d Token.GETPROP) {\n             JSType jsType \u003d getJSType(object.getFirstChild());\n             if (jsType.isInterface() \u0026\u0026 object.getLastChild().getString().equals(\"prototype\")) {\n                 visitInterfaceGetprop(t, assign, object, property, lvalue, rvalue);\n             }\n         }\n         if (info !\u003d null \u0026\u0026 info.hasType()) {\n-            visitAnnotatedAssignGetprop(t, assign, info.getType().evaluate(t.getScope()), object, property, rvalue);\n+            visitAnnotatedAssignGetprop(t, assign, info.getType().evaluate(t.getScope(), typeRegistry), object, property, rvalue);\n             return;\n         }\n         if (info !\u003d null \u0026\u0026 info.hasEnumParameterType()) {\n-            checkEnumInitializer(t, rvalue, info.getEnumParameterType().evaluate(t.getScope()));\n+            checkEnumInitializer(t, rvalue, info.getEnumParameterType().evaluate(t.getScope(), typeRegistry));\n             return;\n         }\n         if (property.equals(\"prototype\")) {\n             if (objectJsType instanceof FunctionType) {\n                 FunctionType functionType \u003d (FunctionType) objectJsType;\n                 if (functionType.isConstructor()) {\n                     JSType rvalueType \u003d rvalue.getJSType();\n                     validator.expectObject(t, rvalue, rvalueType, OVERRIDING_PROTOTYPE_WITH_NON_OBJECT);\n                 }\n             } else {\n             }\n             return;\n         }\n         if (object.getType() \u003d\u003d Token.GETPROP) {\n             Node object2 \u003d object.getFirstChild();\n             String property2 \u003d NodeUtil.getStringValue(object.getLastChild());\n             if (\"prototype\".equals(property2)) {\n                 JSType jsType \u003d object2.getJSType();\n                 if (jsType instanceof FunctionType) {\n                     FunctionType functionType \u003d (FunctionType) jsType;\n                     if (functionType.isConstructor() || functionType.isInterface()) {\n                         checkDeclaredPropertyInheritance(t, assign, functionType, property, info, getJSType(rvalue));\n                     }\n                 } else {\n                 }\n                 return;\n             }\n         }\n         ObjectType type \u003d ObjectType.cast(objectJsType.restrictByNotNullOrUndefined());\n         if (type !\u003d null) {\n             if (type.hasProperty(property) \u0026\u0026 !type.isPropertyTypeInferred(property) \u0026\u0026 !propertyIsImplicitCast(type, property)) {\n                 validator.expectCanAssignToPropertyOf(t, assign, getJSType(rvalue), type.getPropertyType(property), object, property);\n             }\n             return;\n         }\n     } else if (lvalue.getType() \u003d\u003d Token.NAME) {\n         JSType rvalueType \u003d getJSType(assign.getLastChild());\n         Var var \u003d t.getScope().getVar(lvalue.getString());\n         if (var !\u003d null) {\n             if (var.isTypeInferred()) {\n                 return;\n             }\n         }\n     }\n     JSType leftType \u003d getJSType(lvalue);\n     Node rightChild \u003d assign.getLastChild();\n     JSType rightType \u003d getJSType(rightChild);\n     if (validator.expectCanAssignTo(t, assign, rightType, leftType, \"assignment\")) {\n         ensureTyped(t, assign, rightType);\n     } else {\n         ensureTyped(t, assign);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a2d8936fae3eb0e3873c7f7c0233344c81436404": {
      "type": "Ybodychange",
      "commitMessage": "Add warnings for functions that are ambiguously defined on different\nbrowsers.\n\nAdd better support for Caja.\n\nRollback the change to CoalesceVariableNames, because it had problems.\n\nInternal type system refactoring.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@33 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "12/15/09, 1:52 PM",
      "commitName": "a2d8936fae3eb0e3873c7f7c0233344c81436404",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "commitDateOld": "11/25/09, 6:53 AM",
      "commitNameOld": "3bee5d740c96572faea4b9fb8b632e0e07b13cbb",
      "commitAuthorOld": "nicholas.j.santos@gmail.com",
      "daysBetweenCommits": 20.29,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "actualSource": "private void visitAssign(NodeTraversal t, Node assign) {\n    JSDocInfo info \u003d assign.getJSDocInfo();\n    Node lvalue \u003d assign.getFirstChild();\n    Node rvalue \u003d assign.getLastChild();\n    if (lvalue.getType() \u003d\u003d Token.GETPROP) {\n        Node object \u003d lvalue.getFirstChild();\n        JSType objectJsType \u003d getJSType(object);\n        String property \u003d lvalue.getLastChild().getString();\n        if (object.getType() \u003d\u003d Token.GETPROP) {\n            JSType jsType \u003d getJSType(object.getFirstChild());\n            if (jsType.isInterface() \u0026\u0026 object.getLastChild().getString().equals(\"prototype\")) {\n                visitInterfaceGetprop(t, assign, object, property, lvalue, rvalue);\n            }\n        }\n        if (info !\u003d null \u0026\u0026 info.hasType()) {\n            visitAnnotatedAssignGetprop(t, assign, info.getType().evaluate(t.getScope()), object, property, rvalue);\n            return;\n        }\n        if (info !\u003d null \u0026\u0026 info.hasEnumParameterType()) {\n            checkEnumInitializer(t, rvalue, info.getEnumParameterType().evaluate(t.getScope()));\n            return;\n        }\n        if (property.equals(\"prototype\")) {\n            if (objectJsType instanceof FunctionType) {\n                FunctionType functionType \u003d (FunctionType) objectJsType;\n                if (functionType.isConstructor()) {\n                    JSType rvalueType \u003d rvalue.getJSType();\n                    validator.expectObject(t, rvalue, rvalueType, OVERRIDING_PROTOTYPE_WITH_NON_OBJECT);\n                }\n            } else {\n            }\n            return;\n        }\n        if (object.getType() \u003d\u003d Token.GETPROP) {\n            Node object2 \u003d object.getFirstChild();\n            String property2 \u003d NodeUtil.getStringValue(object.getLastChild());\n            if (\"prototype\".equals(property2)) {\n                JSType jsType \u003d object2.getJSType();\n                if (jsType instanceof FunctionType) {\n                    FunctionType functionType \u003d (FunctionType) jsType;\n                    if (functionType.isConstructor() || functionType.isInterface()) {\n                        checkDeclaredPropertyInheritance(t, assign, functionType, property, info, getJSType(rvalue));\n                    }\n                } else {\n                }\n                return;\n            }\n        }\n        ObjectType type \u003d ObjectType.cast(objectJsType.restrictByNotNullOrUndefined());\n        if (type !\u003d null) {\n            if (type.hasProperty(property) \u0026\u0026 !type.isPropertyTypeInferred(property) \u0026\u0026 !propertyIsImplicitCast(type, property)) {\n                validator.expectCanAssignToPropertyOf(t, assign, getJSType(rvalue), type.getPropertyType(property), object, property);\n            }\n            return;\n        }\n    } else if (lvalue.getType() \u003d\u003d Token.NAME) {\n        JSType rvalueType \u003d getJSType(assign.getLastChild());\n        Var var \u003d t.getScope().getVar(lvalue.getString());\n        if (var !\u003d null) {\n            if (var.isTypeInferred()) {\n                return;\n            }\n        }\n    }\n    JSType leftType \u003d getJSType(lvalue);\n    Node rightChild \u003d assign.getLastChild();\n    JSType rightType \u003d getJSType(rightChild);\n    if (validator.expectCanAssignTo(t, assign, rightType, leftType, \"assignment\")) {\n        ensureTyped(t, assign, rightType);\n    } else {\n        ensureTyped(t, assign);\n    }\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 810,
      "functionName": "visitAssign",
      "functionAnnotation": "",
      "functionDoc": "Visits an assignment \u003ccode\u003elvalue \u003d rvalue\u003c/code\u003e. If the\n\u003ccode\u003elvalue\u003c/code\u003e is a prototype modification, we change the schema\nof the object type it is referring to.\n\n@param t the traversal\n@param assign the assign node\n(\u003ccode\u003eassign.getType() \u003d\u003d Token.ASSIGN\u003c/code\u003e is an implicit invariant)\n",
      "diff": "@@ -1,76 +1,73 @@\n private void visitAssign(NodeTraversal t, Node assign) {\n     JSDocInfo info \u003d assign.getJSDocInfo();\n     Node lvalue \u003d assign.getFirstChild();\n     Node rvalue \u003d assign.getLastChild();\n     if (lvalue.getType() \u003d\u003d Token.GETPROP) {\n         Node object \u003d lvalue.getFirstChild();\n         JSType objectJsType \u003d getJSType(object);\n         String property \u003d lvalue.getLastChild().getString();\n         if (object.getType() \u003d\u003d Token.GETPROP) {\n             JSType jsType \u003d getJSType(object.getFirstChild());\n             if (jsType.isInterface() \u0026\u0026 object.getLastChild().getString().equals(\"prototype\")) {\n                 visitInterfaceGetprop(t, assign, object, property, lvalue, rvalue);\n             }\n         }\n         if (info !\u003d null \u0026\u0026 info.hasType()) {\n             visitAnnotatedAssignGetprop(t, assign, info.getType().evaluate(t.getScope()), object, property, rvalue);\n             return;\n         }\n         if (info !\u003d null \u0026\u0026 info.hasEnumParameterType()) {\n             checkEnumInitializer(t, rvalue, info.getEnumParameterType().evaluate(t.getScope()));\n             return;\n         }\n         if (property.equals(\"prototype\")) {\n             if (objectJsType instanceof FunctionType) {\n                 FunctionType functionType \u003d (FunctionType) objectJsType;\n                 if (functionType.isConstructor()) {\n                     JSType rvalueType \u003d rvalue.getJSType();\n                     validator.expectObject(t, rvalue, rvalueType, OVERRIDING_PROTOTYPE_WITH_NON_OBJECT);\n                 }\n             } else {\n             }\n             return;\n         }\n         if (object.getType() \u003d\u003d Token.GETPROP) {\n             Node object2 \u003d object.getFirstChild();\n             String property2 \u003d NodeUtil.getStringValue(object.getLastChild());\n             if (\"prototype\".equals(property2)) {\n                 JSType jsType \u003d object2.getJSType();\n                 if (jsType instanceof FunctionType) {\n                     FunctionType functionType \u003d (FunctionType) jsType;\n                     if (functionType.isConstructor() || functionType.isInterface()) {\n                         checkDeclaredPropertyInheritance(t, assign, functionType, property, info, getJSType(rvalue));\n                     }\n                 } else {\n                 }\n                 return;\n             }\n         }\n-        JSType type \u003d objectJsType.restrictByNotNullOrUndefined();\n-        if (type instanceof ObjectType) {\n-            ObjectType objectType \u003d (ObjectType) type;\n-            if (objectType.hasProperty(property)) {\n-                if (!objectType.isPropertyTypeInferred(property) \u0026\u0026 !propertyIsImplicitCast(objectType, property)) {\n-                    validator.expectCanAssignToPropertyOf(t, assign, getJSType(rvalue), objectType.getPropertyType(property), object, property);\n-                }\n+        ObjectType type \u003d ObjectType.cast(objectJsType.restrictByNotNullOrUndefined());\n+        if (type !\u003d null) {\n+            if (type.hasProperty(property) \u0026\u0026 !type.isPropertyTypeInferred(property) \u0026\u0026 !propertyIsImplicitCast(type, property)) {\n+                validator.expectCanAssignToPropertyOf(t, assign, getJSType(rvalue), type.getPropertyType(property), object, property);\n             }\n             return;\n         }\n     } else if (lvalue.getType() \u003d\u003d Token.NAME) {\n         JSType rvalueType \u003d getJSType(assign.getLastChild());\n         Var var \u003d t.getScope().getVar(lvalue.getString());\n         if (var !\u003d null) {\n             if (var.isTypeInferred()) {\n                 return;\n             }\n         }\n     }\n     JSType leftType \u003d getJSType(lvalue);\n     Node rightChild \u003d assign.getLastChild();\n     JSType rightType \u003d getJSType(rightChild);\n     if (validator.expectCanAssignTo(t, assign, rightType, leftType, \"assignment\")) {\n         ensureTyped(t, assign, rightType);\n     } else {\n         ensureTyped(t, assign);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": {
      "type": "Yintroduced",
      "commitMessage": "Initial commit.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/3/09, 3:51 PM",
      "commitName": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "diff": "@@ -0,0 +1,76 @@\n+private void visitAssign(NodeTraversal t, Node assign) {\n+    JSDocInfo info \u003d assign.getJSDocInfo();\n+    Node lvalue \u003d assign.getFirstChild();\n+    Node rvalue \u003d assign.getLastChild();\n+    if (lvalue.getType() \u003d\u003d Token.GETPROP) {\n+        Node object \u003d lvalue.getFirstChild();\n+        JSType objectJsType \u003d getJSType(object);\n+        String property \u003d lvalue.getLastChild().getString();\n+        if (object.getType() \u003d\u003d Token.GETPROP) {\n+            JSType jsType \u003d getJSType(object.getFirstChild());\n+            if (jsType.isInterface() \u0026\u0026 object.getLastChild().getString().equals(\"prototype\")) {\n+                visitInterfaceGetprop(t, assign, object, property, lvalue, rvalue);\n+            }\n+        }\n+        if (info !\u003d null \u0026\u0026 info.hasType()) {\n+            visitAnnotatedAssignGetprop(t, assign, info.getType().evaluate(t.getScope()), object, property, rvalue);\n+            return;\n+        }\n+        if (info !\u003d null \u0026\u0026 info.hasEnumParameterType()) {\n+            checkEnumInitializer(t, rvalue, info.getEnumParameterType().evaluate(t.getScope()));\n+            return;\n+        }\n+        if (property.equals(\"prototype\")) {\n+            if (objectJsType instanceof FunctionType) {\n+                FunctionType functionType \u003d (FunctionType) objectJsType;\n+                if (functionType.isConstructor()) {\n+                    JSType rvalueType \u003d rvalue.getJSType();\n+                    validator.expectObject(t, rvalue, rvalueType, OVERRIDING_PROTOTYPE_WITH_NON_OBJECT);\n+                }\n+            } else {\n+            }\n+            return;\n+        }\n+        if (object.getType() \u003d\u003d Token.GETPROP) {\n+            Node object2 \u003d object.getFirstChild();\n+            String property2 \u003d NodeUtil.getStringValue(object.getLastChild());\n+            if (\"prototype\".equals(property2)) {\n+                JSType jsType \u003d object2.getJSType();\n+                if (jsType instanceof FunctionType) {\n+                    FunctionType functionType \u003d (FunctionType) jsType;\n+                    if (functionType.isConstructor() || functionType.isInterface()) {\n+                        checkDeclaredPropertyInheritance(t, assign, functionType, property, info, getJSType(rvalue));\n+                    }\n+                } else {\n+                }\n+                return;\n+            }\n+        }\n+        JSType type \u003d objectJsType.restrictByNotNullOrUndefined();\n+        if (type instanceof ObjectType) {\n+            ObjectType objectType \u003d (ObjectType) type;\n+            if (objectType.hasProperty(property)) {\n+                if (!objectType.isPropertyTypeInferred(property) \u0026\u0026 !propertyIsImplicitCast(objectType, property)) {\n+                    validator.expectCanAssignToPropertyOf(t, assign, getJSType(rvalue), objectType.getPropertyType(property), object, property);\n+                }\n+            }\n+            return;\n+        }\n+    } else if (lvalue.getType() \u003d\u003d Token.NAME) {\n+        JSType rvalueType \u003d getJSType(assign.getLastChild());\n+        Var var \u003d t.getScope().getVar(lvalue.getString());\n+        if (var !\u003d null) {\n+            if (var.isTypeInferred()) {\n+                return;\n+            }\n+        }\n+    }\n+    JSType leftType \u003d getJSType(lvalue);\n+    Node rightChild \u003d assign.getLastChild();\n+    JSType rightType \u003d getJSType(rightChild);\n+    if (validator.expectCanAssignTo(t, assign, rightType, leftType, \"assignment\")) {\n+        ensureTyped(t, assign, rightType);\n+    } else {\n+        ensureTyped(t, assign);\n+    }\n+}\n\\ No newline at end of file\n",
      "actualSource": "private void visitAssign(NodeTraversal t, Node assign) {\n    JSDocInfo info \u003d assign.getJSDocInfo();\n    Node lvalue \u003d assign.getFirstChild();\n    Node rvalue \u003d assign.getLastChild();\n    if (lvalue.getType() \u003d\u003d Token.GETPROP) {\n        Node object \u003d lvalue.getFirstChild();\n        JSType objectJsType \u003d getJSType(object);\n        String property \u003d lvalue.getLastChild().getString();\n        if (object.getType() \u003d\u003d Token.GETPROP) {\n            JSType jsType \u003d getJSType(object.getFirstChild());\n            if (jsType.isInterface() \u0026\u0026 object.getLastChild().getString().equals(\"prototype\")) {\n                visitInterfaceGetprop(t, assign, object, property, lvalue, rvalue);\n            }\n        }\n        if (info !\u003d null \u0026\u0026 info.hasType()) {\n            visitAnnotatedAssignGetprop(t, assign, info.getType().evaluate(t.getScope()), object, property, rvalue);\n            return;\n        }\n        if (info !\u003d null \u0026\u0026 info.hasEnumParameterType()) {\n            checkEnumInitializer(t, rvalue, info.getEnumParameterType().evaluate(t.getScope()));\n            return;\n        }\n        if (property.equals(\"prototype\")) {\n            if (objectJsType instanceof FunctionType) {\n                FunctionType functionType \u003d (FunctionType) objectJsType;\n                if (functionType.isConstructor()) {\n                    JSType rvalueType \u003d rvalue.getJSType();\n                    validator.expectObject(t, rvalue, rvalueType, OVERRIDING_PROTOTYPE_WITH_NON_OBJECT);\n                }\n            } else {\n            }\n            return;\n        }\n        if (object.getType() \u003d\u003d Token.GETPROP) {\n            Node object2 \u003d object.getFirstChild();\n            String property2 \u003d NodeUtil.getStringValue(object.getLastChild());\n            if (\"prototype\".equals(property2)) {\n                JSType jsType \u003d object2.getJSType();\n                if (jsType instanceof FunctionType) {\n                    FunctionType functionType \u003d (FunctionType) jsType;\n                    if (functionType.isConstructor() || functionType.isInterface()) {\n                        checkDeclaredPropertyInheritance(t, assign, functionType, property, info, getJSType(rvalue));\n                    }\n                } else {\n                }\n                return;\n            }\n        }\n        JSType type \u003d objectJsType.restrictByNotNullOrUndefined();\n        if (type instanceof ObjectType) {\n            ObjectType objectType \u003d (ObjectType) type;\n            if (objectType.hasProperty(property)) {\n                if (!objectType.isPropertyTypeInferred(property) \u0026\u0026 !propertyIsImplicitCast(objectType, property)) {\n                    validator.expectCanAssignToPropertyOf(t, assign, getJSType(rvalue), objectType.getPropertyType(property), object, property);\n                }\n            }\n            return;\n        }\n    } else if (lvalue.getType() \u003d\u003d Token.NAME) {\n        JSType rvalueType \u003d getJSType(assign.getLastChild());\n        Var var \u003d t.getScope().getVar(lvalue.getString());\n        if (var !\u003d null) {\n            if (var.isTypeInferred()) {\n                return;\n            }\n        }\n    }\n    JSType leftType \u003d getJSType(lvalue);\n    Node rightChild \u003d assign.getLastChild();\n    JSType rightType \u003d getJSType(rightChild);\n    if (validator.expectCanAssignTo(t, assign, rightType, leftType, \"assignment\")) {\n        ensureTyped(t, assign, rightType);\n    } else {\n        ensureTyped(t, assign);\n    }\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 810,
      "functionName": "visitAssign",
      "functionAnnotation": "",
      "functionDoc": "Visits an assignment \u003ccode\u003elvalue \u003d rvalue\u003c/code\u003e. If the\n\u003ccode\u003elvalue\u003c/code\u003e is a prototype modification, we change the schema\nof the object type it is referring to.\n\n@param t the traversal\n@param assign the assign node\n(\u003ccode\u003eassign.getType() \u003d\u003d Token.ASSIGN\u003c/code\u003e is an implicit invariant)\n"
    }
  }
}