{
  "origin": "codeshovel",
  "repositoryName": "Closure-66b",
  "repositoryPath": "/tmp/Closure-66b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "TypedScopeCreator.java",
  "functionName": "createEnumTypeFromNodes",
  "functionId": "$createEnumTypeFromNodes___rValue-Node__name-String__info-JSDocInfo__lValueNode-Node",
  "sourceFilePath": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
  "functionAnnotation": "",
  "functionDoc": "Creates a new enum type, based on the given nodes.\n\nThis handles two cases that are semantically very different, but\nare not mutually exclusive:\n- An object literal that needs an enum type attached to it.\n- An assignment expression with an enum tag in the jsdoc.\n\nThis function will always create an enum type, so only call it if\nyou\u0027re sure that\u0027s what you want.\n\n@param rValue The node of the enum.\n@param name The enum\u0027s name\n@param info The {@link JSDocInfo} attached to the enum definition.\n@param lValueNode The node where this function is being\n    assigned.\n",
  "functionStartLine": 944,
  "functionEndLine": 990,
  "numCommitsSeen": 97,
  "timeTaken": 4520,
  "changeHistory": [
    "e2da3b80158f6df8377e95ba54da85eb286e63d4",
    "2ea78e73e6ace693e18d535560606dfd49c3f9bc",
    "70f817ae4f80ac11dd2dfe97babf5896c690fb48",
    "6bbac115c9a7928a7053b2da3a78df9569df8570",
    "34fd5f8275ae69fc772c2283a3c5fd13b93a7c42",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3"
  ],
  "changeHistoryShort": {
    "e2da3b80158f6df8377e95ba54da85eb286e63d4": "Ydocchange",
    "2ea78e73e6ace693e18d535560606dfd49c3f9bc": "Ymultichange(Yrename,Yparameterchange,Ybodychange,Ydocchange)",
    "70f817ae4f80ac11dd2dfe97babf5896c690fb48": "Ybodychange",
    "6bbac115c9a7928a7053b2da3a78df9569df8570": "Ybodychange",
    "34fd5f8275ae69fc772c2283a3c5fd13b93a7c42": "Ybodychange",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "e2da3b80158f6df8377e95ba54da85eb286e63d4": {
      "type": "Ydocchange",
      "commitMessage": "\nMaking global typed scope regeneration, hot-swappable.\n\nR\u003dnicksantos\nDELTA\u003d163  (130 added, 16 deleted, 17 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d2142\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1154 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "6/2/11, 9:10 AM",
      "commitName": "e2da3b80158f6df8377e95ba54da85eb286e63d4",
      "commitAuthor": "bashir@google.com",
      "commitDateOld": "6/1/11, 1:41 PM",
      "commitNameOld": "32c0f8b8b23713431c3866ab5769e735abe3a429",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 0.81,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private EnumType createEnumTypeFromNodes(Node rValue, String name, JSDocInfo info, Node lValueNode) {\n    Preconditions.checkNotNull(info);\n    Preconditions.checkState(info.hasEnumParameterType());\n    EnumType enumType \u003d null;\n    if (rValue !\u003d null \u0026\u0026 rValue.isQualifiedName()) {\n        Var var \u003d scope.getVar(rValue.getQualifiedName());\n        if (var !\u003d null \u0026\u0026 var.getType() instanceof EnumType) {\n            enumType \u003d (EnumType) var.getType();\n        }\n    }\n    if (enumType \u003d\u003d null) {\n        JSType elementsType \u003d info.getEnumParameterType().evaluate(scope, typeRegistry);\n        enumType \u003d typeRegistry.createEnumType(name, elementsType);\n        if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.OBJECTLIT) {\n            Node key \u003d rValue.getFirstChild();\n            while (key !\u003d null) {\n                String keyName \u003d NodeUtil.getStringValue(key);\n                if (keyName \u003d\u003d null) {\n                    compiler.report(JSError.make(sourceName, key, ENUM_NOT_CONSTANT, keyName));\n                } else if (enumType.hasOwnProperty(keyName)) {\n                    compiler.report(JSError.make(sourceName, key, ENUM_DUP, keyName));\n                } else if (!codingConvention.isValidEnumKey(keyName)) {\n                    compiler.report(JSError.make(sourceName, key, ENUM_NOT_CONSTANT, keyName));\n                } else {\n                    enumType.defineElement(keyName, key);\n                }\n                key \u003d key.getNext();\n            }\n        }\n    }\n    if (name !\u003d null \u0026\u0026 scope.isGlobal()) {\n        typeRegistry.declareType(name, enumType.getElementsType());\n    }\n    return enumType;\n}",
      "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
      "functionStartLine": 944,
      "functionName": "createEnumTypeFromNodes",
      "functionAnnotation": "",
      "functionDoc": "Creates a new enum type, based on the given nodes.\n\nThis handles two cases that are semantically very different, but\nare not mutually exclusive:\n- An object literal that needs an enum type attached to it.\n- An assignment expression with an enum tag in the jsdoc.\n\nThis function will always create an enum type, so only call it if\nyou\u0027re sure that\u0027s what you want.\n\n@param rValue The node of the enum.\n@param name The enum\u0027s name\n@param info The {@link JSDocInfo} attached to the enum definition.\n@param lValueNode The node where this function is being\n    assigned.\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "Creates a new enum type, based on the given nodes.\n\nThis handles two cases that are semantically very different, but\nare not mutually exclusive:\n- An object literal that needs an enum type attached to it.\n- An assignment expression with an enum tag in the jsdoc.\n\nThis function will always create an enum type, so only call it if\nyou\u0027re sure that\u0027s what you want.\n\n@param rValue The node of the enum.\n@param name The enum\u0027s name\n@param info The {@link JSDocInfo} attached to the enum definition.\n@param lvalueNode The node where this function is being\n    assigned.\n",
        "newValue": "Creates a new enum type, based on the given nodes.\n\nThis handles two cases that are semantically very different, but\nare not mutually exclusive:\n- An object literal that needs an enum type attached to it.\n- An assignment expression with an enum tag in the jsdoc.\n\nThis function will always create an enum type, so only call it if\nyou\u0027re sure that\u0027s what you want.\n\n@param rValue The node of the enum.\n@param name The enum\u0027s name\n@param info The {@link JSDocInfo} attached to the enum definition.\n@param lValueNode The node where this function is being\n    assigned.\n"
      }
    },
    "2ea78e73e6ace693e18d535560606dfd49c3f9bc": {
      "type": "Ymultichange(Yrename,Yparameterchange,Ybodychange,Ydocchange)",
      "commitMessage": "\nClean up type discovery by refactoring to the following algorithm.\n1) When we see a function literal, create the authoritative\ntype for it.\n2) When we see an object literal, create the authoritative\ntype for it.\n3) When we declare a symbol, check to see if it\u0027s assigned to\nan object or function literal, and use that type if it\nmake sense to do so. Otherwise, fall back on the JSDoc info.\nThis should make it a lot easier to give accurate types to object\nliteral properties.\nI didn\u0027t intend to create any functional changes in this CL,\nbut some minor ones were inevitable.\n\nR\u003djohnlenz\nDELTA\u003d618  (320 added, 249 deleted, 49 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d392\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@739 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "1/31/11, 8:08 AM",
      "commitName": "2ea78e73e6ace693e18d535560606dfd49c3f9bc",
      "commitAuthor": "nicksantos@google.com",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "\nClean up type discovery by refactoring to the following algorithm.\n1) When we see a function literal, create the authoritative\ntype for it.\n2) When we see an object literal, create the authoritative\ntype for it.\n3) When we declare a symbol, check to see if it\u0027s assigned to\nan object or function literal, and use that type if it\nmake sense to do so. Otherwise, fall back on the JSDoc info.\nThis should make it a lot easier to give accurate types to object\nliteral properties.\nI didn\u0027t intend to create any functional changes in this CL,\nbut some minor ones were inevitable.\n\nR\u003djohnlenz\nDELTA\u003d618  (320 added, 249 deleted, 49 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d392\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@739 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "1/31/11, 8:08 AM",
          "commitName": "2ea78e73e6ace693e18d535560606dfd49c3f9bc",
          "commitAuthor": "nicksantos@google.com",
          "commitDateOld": "1/27/11, 10:33 AM",
          "commitNameOld": "70f817ae4f80ac11dd2dfe97babf5896c690fb48",
          "commitAuthorOld": "johnlenz@google.com",
          "daysBetweenCommits": 3.9,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "actualSource": "private EnumType createEnumTypeFromNodes(Node rValue, String name, JSDocInfo info, Node lValueNode) {\n    Preconditions.checkNotNull(info);\n    Preconditions.checkState(info.hasEnumParameterType());\n    EnumType enumType \u003d null;\n    if (rValue !\u003d null \u0026\u0026 rValue.isQualifiedName()) {\n        Var var \u003d scope.getVar(rValue.getQualifiedName());\n        if (var !\u003d null \u0026\u0026 var.getType() instanceof EnumType) {\n            enumType \u003d (EnumType) var.getType();\n        }\n    }\n    if (enumType \u003d\u003d null) {\n        JSType elementsType \u003d info.getEnumParameterType().evaluate(scope, typeRegistry);\n        enumType \u003d typeRegistry.createEnumType(name, elementsType);\n        if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.OBJECTLIT) {\n            Node key \u003d rValue.getFirstChild();\n            while (key !\u003d null) {\n                String keyName \u003d NodeUtil.getStringValue(key);\n                if (keyName \u003d\u003d null) {\n                    compiler.report(JSError.make(sourceName, key, ENUM_NOT_CONSTANT, keyName));\n                } else if (enumType.hasOwnProperty(keyName)) {\n                    compiler.report(JSError.make(sourceName, key, ENUM_DUP, keyName));\n                } else if (!codingConvention.isValidEnumKey(keyName)) {\n                    compiler.report(JSError.make(sourceName, key, ENUM_NOT_CONSTANT, keyName));\n                } else {\n                    enumType.defineElement(keyName, key);\n                }\n                key \u003d key.getNext();\n            }\n        }\n    }\n    if (name !\u003d null \u0026\u0026 scope.isGlobal()) {\n        typeRegistry.declareType(name, enumType.getElementsType());\n    }\n    return enumType;\n}",
          "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
          "functionStartLine": 903,
          "functionName": "createEnumTypeFromNodes",
          "functionAnnotation": "",
          "functionDoc": "Creates a new enum type, based on the given nodes.\n\nThis handles two cases that are semantically very different, but\nare not mutually exclusive:\n- An object literal that needs an enum type attached to it.\n- An assignment expression with an enum tag in the jsdoc.\n\nThis function will always create an enum type, so only call it if\nyou\u0027re sure that\u0027s what you want.\n\n@param rValue The node of the enum.\n@param name The enum\u0027s name\n@param info The {@link JSDocInfo} attached to the enum definition.\n@param lvalueNode The node where this function is being\n    assigned.\n",
          "diff": "@@ -1,35 +1,35 @@\n-private EnumType getEnumType(String name, Node parent, Node value, JSType elementsType) {\n+private EnumType createEnumTypeFromNodes(Node rValue, String name, JSDocInfo info, Node lValueNode) {\n+    Preconditions.checkNotNull(info);\n+    Preconditions.checkState(info.hasEnumParameterType());\n     EnumType enumType \u003d null;\n-    if (value !\u003d null) {\n-        if (value.getType() \u003d\u003d Token.OBJECTLIT) {\n-            enumType \u003d typeRegistry.createEnumType(name, elementsType);\n-            Node key \u003d value.getFirstChild();\n+    if (rValue !\u003d null \u0026\u0026 rValue.isQualifiedName()) {\n+        Var var \u003d scope.getVar(rValue.getQualifiedName());\n+        if (var !\u003d null \u0026\u0026 var.getType() instanceof EnumType) {\n+            enumType \u003d (EnumType) var.getType();\n+        }\n+    }\n+    if (enumType \u003d\u003d null) {\n+        JSType elementsType \u003d info.getEnumParameterType().evaluate(scope, typeRegistry);\n+        enumType \u003d typeRegistry.createEnumType(name, elementsType);\n+        if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.OBJECTLIT) {\n+            Node key \u003d rValue.getFirstChild();\n             while (key !\u003d null) {\n                 String keyName \u003d NodeUtil.getStringValue(key);\n                 if (keyName \u003d\u003d null) {\n                     compiler.report(JSError.make(sourceName, key, ENUM_NOT_CONSTANT, keyName));\n                 } else if (enumType.hasOwnProperty(keyName)) {\n                     compiler.report(JSError.make(sourceName, key, ENUM_DUP, keyName));\n                 } else if (!codingConvention.isValidEnumKey(keyName)) {\n                     compiler.report(JSError.make(sourceName, key, ENUM_NOT_CONSTANT, keyName));\n                 } else {\n                     enumType.defineElement(keyName, key);\n                 }\n                 key \u003d key.getNext();\n             }\n-        } else if (value.isQualifiedName()) {\n-            Var var \u003d scope.getVar(value.getQualifiedName());\n-            if (var !\u003d null \u0026\u0026 var.getType() instanceof EnumType) {\n-                enumType \u003d (EnumType) var.getType();\n-            }\n         }\n     }\n-    if (enumType \u003d\u003d null) {\n-        compiler.report(JSError.make(sourceName, parent, ENUM_INITIALIZER));\n-    } else if (scope.isGlobal()) {\n-        if (name !\u003d null \u0026\u0026 !name.isEmpty()) {\n-            typeRegistry.declareType(name, enumType.getElementsType());\n-        }\n+    if (name !\u003d null \u0026\u0026 scope.isGlobal()) {\n+        typeRegistry.declareType(name, enumType.getElementsType());\n     }\n     return enumType;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "getEnumType",
            "newValue": "createEnumTypeFromNodes"
          }
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "\nClean up type discovery by refactoring to the following algorithm.\n1) When we see a function literal, create the authoritative\ntype for it.\n2) When we see an object literal, create the authoritative\ntype for it.\n3) When we declare a symbol, check to see if it\u0027s assigned to\nan object or function literal, and use that type if it\nmake sense to do so. Otherwise, fall back on the JSDoc info.\nThis should make it a lot easier to give accurate types to object\nliteral properties.\nI didn\u0027t intend to create any functional changes in this CL,\nbut some minor ones were inevitable.\n\nR\u003djohnlenz\nDELTA\u003d618  (320 added, 249 deleted, 49 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d392\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@739 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "1/31/11, 8:08 AM",
          "commitName": "2ea78e73e6ace693e18d535560606dfd49c3f9bc",
          "commitAuthor": "nicksantos@google.com",
          "commitDateOld": "1/27/11, 10:33 AM",
          "commitNameOld": "70f817ae4f80ac11dd2dfe97babf5896c690fb48",
          "commitAuthorOld": "johnlenz@google.com",
          "daysBetweenCommits": 3.9,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "actualSource": "private EnumType createEnumTypeFromNodes(Node rValue, String name, JSDocInfo info, Node lValueNode) {\n    Preconditions.checkNotNull(info);\n    Preconditions.checkState(info.hasEnumParameterType());\n    EnumType enumType \u003d null;\n    if (rValue !\u003d null \u0026\u0026 rValue.isQualifiedName()) {\n        Var var \u003d scope.getVar(rValue.getQualifiedName());\n        if (var !\u003d null \u0026\u0026 var.getType() instanceof EnumType) {\n            enumType \u003d (EnumType) var.getType();\n        }\n    }\n    if (enumType \u003d\u003d null) {\n        JSType elementsType \u003d info.getEnumParameterType().evaluate(scope, typeRegistry);\n        enumType \u003d typeRegistry.createEnumType(name, elementsType);\n        if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.OBJECTLIT) {\n            Node key \u003d rValue.getFirstChild();\n            while (key !\u003d null) {\n                String keyName \u003d NodeUtil.getStringValue(key);\n                if (keyName \u003d\u003d null) {\n                    compiler.report(JSError.make(sourceName, key, ENUM_NOT_CONSTANT, keyName));\n                } else if (enumType.hasOwnProperty(keyName)) {\n                    compiler.report(JSError.make(sourceName, key, ENUM_DUP, keyName));\n                } else if (!codingConvention.isValidEnumKey(keyName)) {\n                    compiler.report(JSError.make(sourceName, key, ENUM_NOT_CONSTANT, keyName));\n                } else {\n                    enumType.defineElement(keyName, key);\n                }\n                key \u003d key.getNext();\n            }\n        }\n    }\n    if (name !\u003d null \u0026\u0026 scope.isGlobal()) {\n        typeRegistry.declareType(name, enumType.getElementsType());\n    }\n    return enumType;\n}",
          "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
          "functionStartLine": 903,
          "functionName": "createEnumTypeFromNodes",
          "functionAnnotation": "",
          "functionDoc": "Creates a new enum type, based on the given nodes.\n\nThis handles two cases that are semantically very different, but\nare not mutually exclusive:\n- An object literal that needs an enum type attached to it.\n- An assignment expression with an enum tag in the jsdoc.\n\nThis function will always create an enum type, so only call it if\nyou\u0027re sure that\u0027s what you want.\n\n@param rValue The node of the enum.\n@param name The enum\u0027s name\n@param info The {@link JSDocInfo} attached to the enum definition.\n@param lvalueNode The node where this function is being\n    assigned.\n",
          "diff": "@@ -1,35 +1,35 @@\n-private EnumType getEnumType(String name, Node parent, Node value, JSType elementsType) {\n+private EnumType createEnumTypeFromNodes(Node rValue, String name, JSDocInfo info, Node lValueNode) {\n+    Preconditions.checkNotNull(info);\n+    Preconditions.checkState(info.hasEnumParameterType());\n     EnumType enumType \u003d null;\n-    if (value !\u003d null) {\n-        if (value.getType() \u003d\u003d Token.OBJECTLIT) {\n-            enumType \u003d typeRegistry.createEnumType(name, elementsType);\n-            Node key \u003d value.getFirstChild();\n+    if (rValue !\u003d null \u0026\u0026 rValue.isQualifiedName()) {\n+        Var var \u003d scope.getVar(rValue.getQualifiedName());\n+        if (var !\u003d null \u0026\u0026 var.getType() instanceof EnumType) {\n+            enumType \u003d (EnumType) var.getType();\n+        }\n+    }\n+    if (enumType \u003d\u003d null) {\n+        JSType elementsType \u003d info.getEnumParameterType().evaluate(scope, typeRegistry);\n+        enumType \u003d typeRegistry.createEnumType(name, elementsType);\n+        if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.OBJECTLIT) {\n+            Node key \u003d rValue.getFirstChild();\n             while (key !\u003d null) {\n                 String keyName \u003d NodeUtil.getStringValue(key);\n                 if (keyName \u003d\u003d null) {\n                     compiler.report(JSError.make(sourceName, key, ENUM_NOT_CONSTANT, keyName));\n                 } else if (enumType.hasOwnProperty(keyName)) {\n                     compiler.report(JSError.make(sourceName, key, ENUM_DUP, keyName));\n                 } else if (!codingConvention.isValidEnumKey(keyName)) {\n                     compiler.report(JSError.make(sourceName, key, ENUM_NOT_CONSTANT, keyName));\n                 } else {\n                     enumType.defineElement(keyName, key);\n                 }\n                 key \u003d key.getNext();\n             }\n-        } else if (value.isQualifiedName()) {\n-            Var var \u003d scope.getVar(value.getQualifiedName());\n-            if (var !\u003d null \u0026\u0026 var.getType() instanceof EnumType) {\n-                enumType \u003d (EnumType) var.getType();\n-            }\n         }\n     }\n-    if (enumType \u003d\u003d null) {\n-        compiler.report(JSError.make(sourceName, parent, ENUM_INITIALIZER));\n-    } else if (scope.isGlobal()) {\n-        if (name !\u003d null \u0026\u0026 !name.isEmpty()) {\n-            typeRegistry.declareType(name, enumType.getElementsType());\n-        }\n+    if (name !\u003d null \u0026\u0026 scope.isGlobal()) {\n+        typeRegistry.declareType(name, enumType.getElementsType());\n     }\n     return enumType;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[name-String, parent-Node, value-Node, elementsType-JSType]",
            "newValue": "[rValue-Node, name-String, info-JSDocInfo, lValueNode-Node]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "\nClean up type discovery by refactoring to the following algorithm.\n1) When we see a function literal, create the authoritative\ntype for it.\n2) When we see an object literal, create the authoritative\ntype for it.\n3) When we declare a symbol, check to see if it\u0027s assigned to\nan object or function literal, and use that type if it\nmake sense to do so. Otherwise, fall back on the JSDoc info.\nThis should make it a lot easier to give accurate types to object\nliteral properties.\nI didn\u0027t intend to create any functional changes in this CL,\nbut some minor ones were inevitable.\n\nR\u003djohnlenz\nDELTA\u003d618  (320 added, 249 deleted, 49 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d392\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@739 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "1/31/11, 8:08 AM",
          "commitName": "2ea78e73e6ace693e18d535560606dfd49c3f9bc",
          "commitAuthor": "nicksantos@google.com",
          "commitDateOld": "1/27/11, 10:33 AM",
          "commitNameOld": "70f817ae4f80ac11dd2dfe97babf5896c690fb48",
          "commitAuthorOld": "johnlenz@google.com",
          "daysBetweenCommits": 3.9,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "actualSource": "private EnumType createEnumTypeFromNodes(Node rValue, String name, JSDocInfo info, Node lValueNode) {\n    Preconditions.checkNotNull(info);\n    Preconditions.checkState(info.hasEnumParameterType());\n    EnumType enumType \u003d null;\n    if (rValue !\u003d null \u0026\u0026 rValue.isQualifiedName()) {\n        Var var \u003d scope.getVar(rValue.getQualifiedName());\n        if (var !\u003d null \u0026\u0026 var.getType() instanceof EnumType) {\n            enumType \u003d (EnumType) var.getType();\n        }\n    }\n    if (enumType \u003d\u003d null) {\n        JSType elementsType \u003d info.getEnumParameterType().evaluate(scope, typeRegistry);\n        enumType \u003d typeRegistry.createEnumType(name, elementsType);\n        if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.OBJECTLIT) {\n            Node key \u003d rValue.getFirstChild();\n            while (key !\u003d null) {\n                String keyName \u003d NodeUtil.getStringValue(key);\n                if (keyName \u003d\u003d null) {\n                    compiler.report(JSError.make(sourceName, key, ENUM_NOT_CONSTANT, keyName));\n                } else if (enumType.hasOwnProperty(keyName)) {\n                    compiler.report(JSError.make(sourceName, key, ENUM_DUP, keyName));\n                } else if (!codingConvention.isValidEnumKey(keyName)) {\n                    compiler.report(JSError.make(sourceName, key, ENUM_NOT_CONSTANT, keyName));\n                } else {\n                    enumType.defineElement(keyName, key);\n                }\n                key \u003d key.getNext();\n            }\n        }\n    }\n    if (name !\u003d null \u0026\u0026 scope.isGlobal()) {\n        typeRegistry.declareType(name, enumType.getElementsType());\n    }\n    return enumType;\n}",
          "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
          "functionStartLine": 903,
          "functionName": "createEnumTypeFromNodes",
          "functionAnnotation": "",
          "functionDoc": "Creates a new enum type, based on the given nodes.\n\nThis handles two cases that are semantically very different, but\nare not mutually exclusive:\n- An object literal that needs an enum type attached to it.\n- An assignment expression with an enum tag in the jsdoc.\n\nThis function will always create an enum type, so only call it if\nyou\u0027re sure that\u0027s what you want.\n\n@param rValue The node of the enum.\n@param name The enum\u0027s name\n@param info The {@link JSDocInfo} attached to the enum definition.\n@param lvalueNode The node where this function is being\n    assigned.\n",
          "diff": "@@ -1,35 +1,35 @@\n-private EnumType getEnumType(String name, Node parent, Node value, JSType elementsType) {\n+private EnumType createEnumTypeFromNodes(Node rValue, String name, JSDocInfo info, Node lValueNode) {\n+    Preconditions.checkNotNull(info);\n+    Preconditions.checkState(info.hasEnumParameterType());\n     EnumType enumType \u003d null;\n-    if (value !\u003d null) {\n-        if (value.getType() \u003d\u003d Token.OBJECTLIT) {\n-            enumType \u003d typeRegistry.createEnumType(name, elementsType);\n-            Node key \u003d value.getFirstChild();\n+    if (rValue !\u003d null \u0026\u0026 rValue.isQualifiedName()) {\n+        Var var \u003d scope.getVar(rValue.getQualifiedName());\n+        if (var !\u003d null \u0026\u0026 var.getType() instanceof EnumType) {\n+            enumType \u003d (EnumType) var.getType();\n+        }\n+    }\n+    if (enumType \u003d\u003d null) {\n+        JSType elementsType \u003d info.getEnumParameterType().evaluate(scope, typeRegistry);\n+        enumType \u003d typeRegistry.createEnumType(name, elementsType);\n+        if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.OBJECTLIT) {\n+            Node key \u003d rValue.getFirstChild();\n             while (key !\u003d null) {\n                 String keyName \u003d NodeUtil.getStringValue(key);\n                 if (keyName \u003d\u003d null) {\n                     compiler.report(JSError.make(sourceName, key, ENUM_NOT_CONSTANT, keyName));\n                 } else if (enumType.hasOwnProperty(keyName)) {\n                     compiler.report(JSError.make(sourceName, key, ENUM_DUP, keyName));\n                 } else if (!codingConvention.isValidEnumKey(keyName)) {\n                     compiler.report(JSError.make(sourceName, key, ENUM_NOT_CONSTANT, keyName));\n                 } else {\n                     enumType.defineElement(keyName, key);\n                 }\n                 key \u003d key.getNext();\n             }\n-        } else if (value.isQualifiedName()) {\n-            Var var \u003d scope.getVar(value.getQualifiedName());\n-            if (var !\u003d null \u0026\u0026 var.getType() instanceof EnumType) {\n-                enumType \u003d (EnumType) var.getType();\n-            }\n         }\n     }\n-    if (enumType \u003d\u003d null) {\n-        compiler.report(JSError.make(sourceName, parent, ENUM_INITIALIZER));\n-    } else if (scope.isGlobal()) {\n-        if (name !\u003d null \u0026\u0026 !name.isEmpty()) {\n-            typeRegistry.declareType(name, enumType.getElementsType());\n-        }\n+    if (name !\u003d null \u0026\u0026 scope.isGlobal()) {\n+        typeRegistry.declareType(name, enumType.getElementsType());\n     }\n     return enumType;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "\nClean up type discovery by refactoring to the following algorithm.\n1) When we see a function literal, create the authoritative\ntype for it.\n2) When we see an object literal, create the authoritative\ntype for it.\n3) When we declare a symbol, check to see if it\u0027s assigned to\nan object or function literal, and use that type if it\nmake sense to do so. Otherwise, fall back on the JSDoc info.\nThis should make it a lot easier to give accurate types to object\nliteral properties.\nI didn\u0027t intend to create any functional changes in this CL,\nbut some minor ones were inevitable.\n\nR\u003djohnlenz\nDELTA\u003d618  (320 added, 249 deleted, 49 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d392\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@739 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "1/31/11, 8:08 AM",
          "commitName": "2ea78e73e6ace693e18d535560606dfd49c3f9bc",
          "commitAuthor": "nicksantos@google.com",
          "commitDateOld": "1/27/11, 10:33 AM",
          "commitNameOld": "70f817ae4f80ac11dd2dfe97babf5896c690fb48",
          "commitAuthorOld": "johnlenz@google.com",
          "daysBetweenCommits": 3.9,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "actualSource": "private EnumType createEnumTypeFromNodes(Node rValue, String name, JSDocInfo info, Node lValueNode) {\n    Preconditions.checkNotNull(info);\n    Preconditions.checkState(info.hasEnumParameterType());\n    EnumType enumType \u003d null;\n    if (rValue !\u003d null \u0026\u0026 rValue.isQualifiedName()) {\n        Var var \u003d scope.getVar(rValue.getQualifiedName());\n        if (var !\u003d null \u0026\u0026 var.getType() instanceof EnumType) {\n            enumType \u003d (EnumType) var.getType();\n        }\n    }\n    if (enumType \u003d\u003d null) {\n        JSType elementsType \u003d info.getEnumParameterType().evaluate(scope, typeRegistry);\n        enumType \u003d typeRegistry.createEnumType(name, elementsType);\n        if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.OBJECTLIT) {\n            Node key \u003d rValue.getFirstChild();\n            while (key !\u003d null) {\n                String keyName \u003d NodeUtil.getStringValue(key);\n                if (keyName \u003d\u003d null) {\n                    compiler.report(JSError.make(sourceName, key, ENUM_NOT_CONSTANT, keyName));\n                } else if (enumType.hasOwnProperty(keyName)) {\n                    compiler.report(JSError.make(sourceName, key, ENUM_DUP, keyName));\n                } else if (!codingConvention.isValidEnumKey(keyName)) {\n                    compiler.report(JSError.make(sourceName, key, ENUM_NOT_CONSTANT, keyName));\n                } else {\n                    enumType.defineElement(keyName, key);\n                }\n                key \u003d key.getNext();\n            }\n        }\n    }\n    if (name !\u003d null \u0026\u0026 scope.isGlobal()) {\n        typeRegistry.declareType(name, enumType.getElementsType());\n    }\n    return enumType;\n}",
          "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
          "functionStartLine": 903,
          "functionName": "createEnumTypeFromNodes",
          "functionAnnotation": "",
          "functionDoc": "Creates a new enum type, based on the given nodes.\n\nThis handles two cases that are semantically very different, but\nare not mutually exclusive:\n- An object literal that needs an enum type attached to it.\n- An assignment expression with an enum tag in the jsdoc.\n\nThis function will always create an enum type, so only call it if\nyou\u0027re sure that\u0027s what you want.\n\n@param rValue The node of the enum.\n@param name The enum\u0027s name\n@param info The {@link JSDocInfo} attached to the enum definition.\n@param lvalueNode The node where this function is being\n    assigned.\n",
          "diff": "@@ -1,35 +1,35 @@\n-private EnumType getEnumType(String name, Node parent, Node value, JSType elementsType) {\n+private EnumType createEnumTypeFromNodes(Node rValue, String name, JSDocInfo info, Node lValueNode) {\n+    Preconditions.checkNotNull(info);\n+    Preconditions.checkState(info.hasEnumParameterType());\n     EnumType enumType \u003d null;\n-    if (value !\u003d null) {\n-        if (value.getType() \u003d\u003d Token.OBJECTLIT) {\n-            enumType \u003d typeRegistry.createEnumType(name, elementsType);\n-            Node key \u003d value.getFirstChild();\n+    if (rValue !\u003d null \u0026\u0026 rValue.isQualifiedName()) {\n+        Var var \u003d scope.getVar(rValue.getQualifiedName());\n+        if (var !\u003d null \u0026\u0026 var.getType() instanceof EnumType) {\n+            enumType \u003d (EnumType) var.getType();\n+        }\n+    }\n+    if (enumType \u003d\u003d null) {\n+        JSType elementsType \u003d info.getEnumParameterType().evaluate(scope, typeRegistry);\n+        enumType \u003d typeRegistry.createEnumType(name, elementsType);\n+        if (rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.OBJECTLIT) {\n+            Node key \u003d rValue.getFirstChild();\n             while (key !\u003d null) {\n                 String keyName \u003d NodeUtil.getStringValue(key);\n                 if (keyName \u003d\u003d null) {\n                     compiler.report(JSError.make(sourceName, key, ENUM_NOT_CONSTANT, keyName));\n                 } else if (enumType.hasOwnProperty(keyName)) {\n                     compiler.report(JSError.make(sourceName, key, ENUM_DUP, keyName));\n                 } else if (!codingConvention.isValidEnumKey(keyName)) {\n                     compiler.report(JSError.make(sourceName, key, ENUM_NOT_CONSTANT, keyName));\n                 } else {\n                     enumType.defineElement(keyName, key);\n                 }\n                 key \u003d key.getNext();\n             }\n-        } else if (value.isQualifiedName()) {\n-            Var var \u003d scope.getVar(value.getQualifiedName());\n-            if (var !\u003d null \u0026\u0026 var.getType() instanceof EnumType) {\n-                enumType \u003d (EnumType) var.getType();\n-            }\n         }\n     }\n-    if (enumType \u003d\u003d null) {\n-        compiler.report(JSError.make(sourceName, parent, ENUM_INITIALIZER));\n-    } else if (scope.isGlobal()) {\n-        if (name !\u003d null \u0026\u0026 !name.isEmpty()) {\n-            typeRegistry.declareType(name, enumType.getElementsType());\n-        }\n+    if (name !\u003d null \u0026\u0026 scope.isGlobal()) {\n+        typeRegistry.declareType(name, enumType.getElementsType());\n     }\n     return enumType;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Gets an enum type. If the definition is correct, the object literal used\nto define the enum is traversed to gather the elements name, and this\nmethod checks for duplicates. This method also enforces that all\nelements\u0027 name be syntactic constants according to the\n{@link CodingConvention} used.\n\n@param name the enum\u0027s name such as {@code HELLO} or {@code goog.foo.BAR}\n@param value the enum\u0027s original value. This value may be {@code null}.\n@param parent the value\u0027s parent\n@param elementsType the type of the elements of this enum\n@return the enum type\n",
            "newValue": "Creates a new enum type, based on the given nodes.\n\nThis handles two cases that are semantically very different, but\nare not mutually exclusive:\n- An object literal that needs an enum type attached to it.\n- An assignment expression with an enum tag in the jsdoc.\n\nThis function will always create an enum type, so only call it if\nyou\u0027re sure that\u0027s what you want.\n\n@param rValue The node of the enum.\n@param name The enum\u0027s name\n@param info The {@link JSDocInfo} attached to the enum definition.\n@param lvalueNode The node where this function is being\n    assigned.\n"
          }
        }
      ]
    },
    "70f817ae4f80ac11dd2dfe97babf5896c690fb48": {
      "type": "Ybodychange",
      "commitMessage": "\nAdd basic getters and setters support to TypeInference.\n\nR\u003dnicksantos\nDELTA\u003d573  (533 added, 15 deleted, 25 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d366\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@735 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "1/27/11, 10:33 AM",
      "commitName": "70f817ae4f80ac11dd2dfe97babf5896c690fb48",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "1/21/11, 10:57 AM",
      "commitNameOld": "f3d83b7eb7b1e4afbb24ae57e1a57adadbcead42",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 5.98,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "actualSource": "private EnumType getEnumType(String name, Node parent, Node value, JSType elementsType) {\n    EnumType enumType \u003d null;\n    if (value !\u003d null) {\n        if (value.getType() \u003d\u003d Token.OBJECTLIT) {\n            enumType \u003d typeRegistry.createEnumType(name, elementsType);\n            Node key \u003d value.getFirstChild();\n            while (key !\u003d null) {\n                String keyName \u003d NodeUtil.getStringValue(key);\n                if (keyName \u003d\u003d null) {\n                    compiler.report(JSError.make(sourceName, key, ENUM_NOT_CONSTANT, keyName));\n                } else if (enumType.hasOwnProperty(keyName)) {\n                    compiler.report(JSError.make(sourceName, key, ENUM_DUP, keyName));\n                } else if (!codingConvention.isValidEnumKey(keyName)) {\n                    compiler.report(JSError.make(sourceName, key, ENUM_NOT_CONSTANT, keyName));\n                } else {\n                    enumType.defineElement(keyName, key);\n                }\n                key \u003d key.getNext();\n            }\n        } else if (value.isQualifiedName()) {\n            Var var \u003d scope.getVar(value.getQualifiedName());\n            if (var !\u003d null \u0026\u0026 var.getType() instanceof EnumType) {\n                enumType \u003d (EnumType) var.getType();\n            }\n        }\n    }\n    if (enumType \u003d\u003d null) {\n        compiler.report(JSError.make(sourceName, parent, ENUM_INITIALIZER));\n    } else if (scope.isGlobal()) {\n        if (name !\u003d null \u0026\u0026 !name.isEmpty()) {\n            typeRegistry.declareType(name, enumType.getElementsType());\n        }\n    }\n    return enumType;\n}",
      "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
      "functionStartLine": 913,
      "functionName": "getEnumType",
      "functionAnnotation": "",
      "functionDoc": "Gets an enum type. If the definition is correct, the object literal used\nto define the enum is traversed to gather the elements name, and this\nmethod checks for duplicates. This method also enforces that all\nelements\u0027 name be syntactic constants according to the\n{@link CodingConvention} used.\n\n@param name the enum\u0027s name such as {@code HELLO} or {@code goog.foo.BAR}\n@param value the enum\u0027s original value. This value may be {@code null}.\n@param parent the value\u0027s parent\n@param elementsType the type of the elements of this enum\n@return the enum type\n",
      "diff": "@@ -1,33 +1,35 @@\n private EnumType getEnumType(String name, Node parent, Node value, JSType elementsType) {\n     EnumType enumType \u003d null;\n     if (value !\u003d null) {\n         if (value.getType() \u003d\u003d Token.OBJECTLIT) {\n             enumType \u003d typeRegistry.createEnumType(name, elementsType);\n             Node key \u003d value.getFirstChild();\n             while (key !\u003d null) {\n                 String keyName \u003d NodeUtil.getStringValue(key);\n-                if (enumType.hasOwnProperty(keyName)) {\n+                if (keyName \u003d\u003d null) {\n+                    compiler.report(JSError.make(sourceName, key, ENUM_NOT_CONSTANT, keyName));\n+                } else if (enumType.hasOwnProperty(keyName)) {\n                     compiler.report(JSError.make(sourceName, key, ENUM_DUP, keyName));\n                 } else if (!codingConvention.isValidEnumKey(keyName)) {\n                     compiler.report(JSError.make(sourceName, key, ENUM_NOT_CONSTANT, keyName));\n                 } else {\n                     enumType.defineElement(keyName, key);\n                 }\n                 key \u003d key.getNext();\n             }\n         } else if (value.isQualifiedName()) {\n             Var var \u003d scope.getVar(value.getQualifiedName());\n             if (var !\u003d null \u0026\u0026 var.getType() instanceof EnumType) {\n                 enumType \u003d (EnumType) var.getType();\n             }\n         }\n     }\n     if (enumType \u003d\u003d null) {\n         compiler.report(JSError.make(sourceName, parent, ENUM_INITIALIZER));\n     } else if (scope.isGlobal()) {\n         if (name !\u003d null \u0026\u0026 !name.isEmpty()) {\n             typeRegistry.declareType(name, enumType.getElementsType());\n         }\n     }\n     return enumType;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6bbac115c9a7928a7053b2da3a78df9569df8570": {
      "type": "Ybodychange",
      "commitMessage": "\nAdding getPropertyNode functionality to ObjectType. This needs\nassociating nodes to properties in defineProperty.\n\nR\u003dnicksantos\nDELTA\u003d307  (127 added, 0 deleted, 180 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d223\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@674 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "1/7/11, 9:19 AM",
      "commitName": "6bbac115c9a7928a7053b2da3a78df9569df8570",
      "commitAuthor": "bashir@google.com",
      "commitDateOld": "12/14/10, 1:49 PM",
      "commitNameOld": "e9f7e6114414f68deb90f4116861d7a054365404",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 23.81,
      "commitsBetweenForRepo": 43,
      "commitsBetweenForFile": 1,
      "actualSource": "private EnumType getEnumType(String name, Node parent, Node value, JSType elementsType) {\n    EnumType enumType \u003d null;\n    if (value !\u003d null) {\n        if (value.getType() \u003d\u003d Token.OBJECTLIT) {\n            enumType \u003d typeRegistry.createEnumType(name, elementsType);\n            Node key \u003d value.getFirstChild();\n            while (key !\u003d null) {\n                String keyName \u003d NodeUtil.getStringValue(key);\n                if (enumType.hasOwnProperty(keyName)) {\n                    compiler.report(JSError.make(sourceName, key, ENUM_DUP, keyName));\n                } else if (!codingConvention.isValidEnumKey(keyName)) {\n                    compiler.report(JSError.make(sourceName, key, ENUM_NOT_CONSTANT, keyName));\n                } else {\n                    enumType.defineElement(keyName, key);\n                }\n                key \u003d key.getNext();\n            }\n        } else if (value.isQualifiedName()) {\n            Var var \u003d scope.getVar(value.getQualifiedName());\n            if (var !\u003d null \u0026\u0026 var.getType() instanceof EnumType) {\n                enumType \u003d (EnumType) var.getType();\n            }\n        }\n    }\n    if (enumType \u003d\u003d null) {\n        compiler.report(JSError.make(sourceName, parent, ENUM_INITIALIZER));\n    } else if (scope.isGlobal()) {\n        if (name !\u003d null \u0026\u0026 !name.isEmpty()) {\n            typeRegistry.declareType(name, enumType.getElementsType());\n        }\n    }\n    return enumType;\n}",
      "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
      "functionStartLine": 873,
      "functionName": "getEnumType",
      "functionAnnotation": "",
      "functionDoc": "Gets an enum type. If the definition is correct, the object literal used\nto define the enum is traversed to gather the elements name, and this\nmethod checks for duplicates. This method also enforces that all\nelements\u0027 name be syntactic constants according to the\n{@link CodingConvention} used.\n\n@param name the enum\u0027s name such as {@code HELLO} or {@code goog.foo.BAR}\n@param value the enum\u0027s original value. This value may be {@code null}.\n@param parent the value\u0027s parent\n@param elementsType the type of the elements of this enum\n@return the enum type\n",
      "diff": "@@ -1,33 +1,33 @@\n private EnumType getEnumType(String name, Node parent, Node value, JSType elementsType) {\n     EnumType enumType \u003d null;\n     if (value !\u003d null) {\n         if (value.getType() \u003d\u003d Token.OBJECTLIT) {\n             enumType \u003d typeRegistry.createEnumType(name, elementsType);\n             Node key \u003d value.getFirstChild();\n             while (key !\u003d null) {\n                 String keyName \u003d NodeUtil.getStringValue(key);\n                 if (enumType.hasOwnProperty(keyName)) {\n                     compiler.report(JSError.make(sourceName, key, ENUM_DUP, keyName));\n                 } else if (!codingConvention.isValidEnumKey(keyName)) {\n                     compiler.report(JSError.make(sourceName, key, ENUM_NOT_CONSTANT, keyName));\n                 } else {\n-                    enumType.defineElement(keyName);\n+                    enumType.defineElement(keyName, key);\n                 }\n                 key \u003d key.getNext();\n             }\n         } else if (value.isQualifiedName()) {\n             Var var \u003d scope.getVar(value.getQualifiedName());\n             if (var !\u003d null \u0026\u0026 var.getType() instanceof EnumType) {\n                 enumType \u003d (EnumType) var.getType();\n             }\n         }\n     }\n     if (enumType \u003d\u003d null) {\n         compiler.report(JSError.make(sourceName, parent, ENUM_INITIALIZER));\n     } else if (scope.isGlobal()) {\n         if (name !\u003d null \u0026\u0026 !name.isEmpty()) {\n             typeRegistry.declareType(name, enumType.getElementsType());\n         }\n     }\n     return enumType;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "34fd5f8275ae69fc772c2283a3c5fd13b93a7c42": {
      "type": "Ybodychange",
      "commitMessage": "\nChange the OBJECTLIT AST structure from:\n\nOBJECTLIT\n  KEY1\n  VALUE1\n\nto\n\nOBJECTLIT\n  KEY1\n    VALUE1\n\nFixes issue 241\n\nR\u003dacleung,johnlenz,stevey\nDELTA\u003d268  (101 added, 51 deleted, 116 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d356416\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@494 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "10/18/10, 2:55 PM",
      "commitName": "34fd5f8275ae69fc772c2283a3c5fd13b93a7c42",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "10/14/10, 6:00 PM",
      "commitNameOld": "39dde4ca5df6263d7058029e081a710d7fa13de9",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 3.87,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "private EnumType getEnumType(String name, Node parent, Node value, JSType elementsType) {\n    EnumType enumType \u003d null;\n    if (value !\u003d null) {\n        if (value.getType() \u003d\u003d Token.OBJECTLIT) {\n            enumType \u003d typeRegistry.createEnumType(name, elementsType);\n            Node key \u003d value.getFirstChild();\n            while (key !\u003d null) {\n                String keyName \u003d NodeUtil.getStringValue(key);\n                if (enumType.hasOwnProperty(keyName)) {\n                    compiler.report(JSError.make(sourceName, key, ENUM_DUP, keyName));\n                } else if (!codingConvention.isValidEnumKey(keyName)) {\n                    compiler.report(JSError.make(sourceName, key, ENUM_NOT_CONSTANT, keyName));\n                } else {\n                    enumType.defineElement(keyName);\n                }\n                key \u003d key.getNext();\n            }\n        } else if (value.isQualifiedName()) {\n            Var var \u003d scope.getVar(value.getQualifiedName());\n            if (var !\u003d null \u0026\u0026 var.getType() instanceof EnumType) {\n                enumType \u003d (EnumType) var.getType();\n            }\n        }\n    }\n    if (enumType \u003d\u003d null) {\n        compiler.report(JSError.make(sourceName, parent, ENUM_INITIALIZER));\n    } else if (scope.isGlobal()) {\n        if (name !\u003d null \u0026\u0026 !name.isEmpty()) {\n            typeRegistry.declareType(name, enumType.getElementsType());\n        }\n    }\n    return enumType;\n}",
      "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
      "functionStartLine": 804,
      "functionName": "getEnumType",
      "functionAnnotation": "",
      "functionDoc": "Gets an enum type. If the definition is correct, the object literal used\nto define the enum is traversed to gather the elements name, and this\nmethod checks for duplicates. This method also enforces that all\nelements\u0027 name be syntactic constants according to the\n{@link CodingConvention} used.\n\n@param name the enum\u0027s name such as {@code HELLO} or {@code goog.foo.BAR}\n@param value the enum\u0027s original value. This value may be {@code null}.\n@param parent the value\u0027s parent\n@param elementsType the type of the elements of this enum\n@return the enum type\n",
      "diff": "@@ -1,34 +1,33 @@\n private EnumType getEnumType(String name, Node parent, Node value, JSType elementsType) {\n     EnumType enumType \u003d null;\n     if (value !\u003d null) {\n         if (value.getType() \u003d\u003d Token.OBJECTLIT) {\n             enumType \u003d typeRegistry.createEnumType(name, elementsType);\n             Node key \u003d value.getFirstChild();\n             while (key !\u003d null) {\n                 String keyName \u003d NodeUtil.getStringValue(key);\n                 if (enumType.hasOwnProperty(keyName)) {\n                     compiler.report(JSError.make(sourceName, key, ENUM_DUP, keyName));\n                 } else if (!codingConvention.isValidEnumKey(keyName)) {\n                     compiler.report(JSError.make(sourceName, key, ENUM_NOT_CONSTANT, keyName));\n                 } else {\n                     enumType.defineElement(keyName);\n                 }\n                 key \u003d key.getNext();\n-                key \u003d (key \u003d\u003d null) ? null : key.getNext();\n             }\n         } else if (value.isQualifiedName()) {\n             Var var \u003d scope.getVar(value.getQualifiedName());\n             if (var !\u003d null \u0026\u0026 var.getType() instanceof EnumType) {\n                 enumType \u003d (EnumType) var.getType();\n             }\n         }\n     }\n     if (enumType \u003d\u003d null) {\n         compiler.report(JSError.make(sourceName, parent, ENUM_INITIALIZER));\n     } else if (scope.isGlobal()) {\n         if (name !\u003d null \u0026\u0026 !name.isEmpty()) {\n             typeRegistry.declareType(name, enumType.getElementsType());\n         }\n     }\n     return enumType;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": {
      "type": "Yintroduced",
      "commitMessage": "Initial commit.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/3/09, 3:51 PM",
      "commitName": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "diff": "@@ -0,0 +1,34 @@\n+private EnumType getEnumType(String name, Node parent, Node value, JSType elementsType) {\n+    EnumType enumType \u003d null;\n+    if (value !\u003d null) {\n+        if (value.getType() \u003d\u003d Token.OBJECTLIT) {\n+            enumType \u003d typeRegistry.createEnumType(name, elementsType);\n+            Node key \u003d value.getFirstChild();\n+            while (key !\u003d null) {\n+                String keyName \u003d NodeUtil.getStringValue(key);\n+                if (enumType.hasOwnProperty(keyName)) {\n+                    compiler.report(JSError.make(sourceName, key, ENUM_DUP, keyName));\n+                } else if (!codingConvention.isValidEnumKey(keyName)) {\n+                    compiler.report(JSError.make(sourceName, key, ENUM_NOT_CONSTANT, keyName));\n+                } else {\n+                    enumType.defineElement(keyName);\n+                }\n+                key \u003d key.getNext();\n+                key \u003d (key \u003d\u003d null) ? null : key.getNext();\n+            }\n+        } else if (value.isQualifiedName()) {\n+            Var var \u003d scope.getVar(value.getQualifiedName());\n+            if (var !\u003d null \u0026\u0026 var.getType() instanceof EnumType) {\n+                enumType \u003d (EnumType) var.getType();\n+            }\n+        }\n+    }\n+    if (enumType \u003d\u003d null) {\n+        compiler.report(JSError.make(sourceName, parent, ENUM_INITIALIZER));\n+    } else if (scope.isGlobal()) {\n+        if (name !\u003d null \u0026\u0026 !name.isEmpty()) {\n+            typeRegistry.declareType(name, enumType.getElementsType());\n+        }\n+    }\n+    return enumType;\n+}\n\\ No newline at end of file\n",
      "actualSource": "private EnumType getEnumType(String name, Node parent, Node value, JSType elementsType) {\n    EnumType enumType \u003d null;\n    if (value !\u003d null) {\n        if (value.getType() \u003d\u003d Token.OBJECTLIT) {\n            enumType \u003d typeRegistry.createEnumType(name, elementsType);\n            Node key \u003d value.getFirstChild();\n            while (key !\u003d null) {\n                String keyName \u003d NodeUtil.getStringValue(key);\n                if (enumType.hasOwnProperty(keyName)) {\n                    compiler.report(JSError.make(sourceName, key, ENUM_DUP, keyName));\n                } else if (!codingConvention.isValidEnumKey(keyName)) {\n                    compiler.report(JSError.make(sourceName, key, ENUM_NOT_CONSTANT, keyName));\n                } else {\n                    enumType.defineElement(keyName);\n                }\n                key \u003d key.getNext();\n                key \u003d (key \u003d\u003d null) ? null : key.getNext();\n            }\n        } else if (value.isQualifiedName()) {\n            Var var \u003d scope.getVar(value.getQualifiedName());\n            if (var !\u003d null \u0026\u0026 var.getType() instanceof EnumType) {\n                enumType \u003d (EnumType) var.getType();\n            }\n        }\n    }\n    if (enumType \u003d\u003d null) {\n        compiler.report(JSError.make(sourceName, parent, ENUM_INITIALIZER));\n    } else if (scope.isGlobal()) {\n        if (name !\u003d null \u0026\u0026 !name.isEmpty()) {\n            typeRegistry.declareType(name, enumType.getElementsType());\n        }\n    }\n    return enumType;\n}",
      "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
      "functionStartLine": 561,
      "functionName": "getEnumType",
      "functionAnnotation": "",
      "functionDoc": "Gets an enum type. If the definition is correct, the object literal used\nto define the enum is traversed to gather the elements name, and this\nmethod checks for duplicates. This method also enforces that all\nelements\u0027 name be syntactic constants according to the\n{@link CodingConvention} used.\n\n@param name the enum\u0027s name such as {@code HELLO} or {@code goog.foo.BAR}\n@param value the enum\u0027s original value. This value may be {@code null}.\n@param parent the value\u0027s parent\n@param elementsType the type of the elements of this enum\n@return the enum type\n"
    }
  }
}