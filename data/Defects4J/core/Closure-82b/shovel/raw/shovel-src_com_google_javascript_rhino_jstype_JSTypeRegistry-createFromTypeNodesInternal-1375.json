{
  "origin": "codeshovel",
  "repositoryName": "Closure-82b",
  "repositoryPath": "/tmp/Closure-82b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "JSTypeRegistry.java",
  "functionName": "createFromTypeNodesInternal",
  "functionId": "createFromTypeNodesInternal___n-Node__sourceName-String__scope-StaticScope__JSType____forgiving-boolean",
  "sourceFilePath": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
  "functionAnnotation": "",
  "functionDoc": "\n@see #createFromTypeNodes(Node, String, StaticScope, boolean)\n",
  "functionStartLine": 1375,
  "functionEndLine": 1532,
  "numCommitsSeen": 33,
  "timeTaken": 2012,
  "changeHistory": [
    "e9f7e6114414f68deb90f4116861d7a054365404",
    "3698fee71e3671171c587f932795a8ab8e852cd8",
    "58c3e4ce1d17ec619bcc4964bdeebc676f93567d"
  ],
  "changeHistoryShort": {
    "e9f7e6114414f68deb90f4116861d7a054365404": "Ybodychange",
    "3698fee71e3671171c587f932795a8ab8e852cd8": "Ybodychange",
    "58c3e4ce1d17ec619bcc4964bdeebc676f93567d": "Yintroduced"
  },
  "changeHistoryDetails": {
    "e9f7e6114414f68deb90f4116861d7a054365404": {
      "type": "Ybodychange",
      "commitMessage": "\nAdd a syntax for constructors\n{function(new:Type)}\nfixes issue 281\n\nR\u003djschorr\nDELTA\u003d199  (73 added, 4 deleted, 122 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d133\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@630 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "12/14/10, 1:49 PM",
      "commitName": "e9f7e6114414f68deb90f4116861d7a054365404",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "12/13/10, 8:10 AM",
      "commitNameOld": "1c75a5484b515bd593295fbf0c8491e2dd1f1c45",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 1.24,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "actualSource": "private JSType createFromTypeNodesInternal(Node n, String sourceName, StaticScope\u003cJSType\u003e scope, boolean forgiving) {\n    switch(n.getType()) {\n        case Token.LC:\n            return createRecordTypeFromNodes(n.getFirstChild(), sourceName, scope);\n        case Token.BANG:\n            return createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope, forgiving).restrictByNotNullOrUndefined();\n        case Token.QMARK:\n            Node firstChild \u003d n.getFirstChild();\n            if (firstChild \u003d\u003d null) {\n                return getNativeType(UNKNOWN_TYPE);\n            }\n            return createDefaultObjectUnion(createFromTypeNodesInternal(firstChild, sourceName, scope, forgiving));\n        case Token.EQUALS:\n            return createOptionalType(createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope, false));\n        case Token.ELLIPSIS:\n            return createOptionalType(createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope, false));\n        case Token.STAR:\n            return getNativeType(ALL_TYPE);\n        case Token.LB:\n            return getNativeType(ARRAY_TYPE);\n        case Token.PIPE:\n            UnionTypeBuilder builder \u003d new UnionTypeBuilder(this);\n            for (Node child \u003d n.getFirstChild(); child !\u003d null; child \u003d child.getNext()) {\n                builder.addAlternate(createFromTypeNodesInternal(child, sourceName, scope, false));\n            }\n            return builder.build();\n        case Token.EMPTY:\n            return getNativeType(UNKNOWN_TYPE);\n        case Token.VOID:\n            return getNativeType(VOID_TYPE);\n        case Token.STRING:\n            JSType namedType \u003d getType(scope, n.getString(), sourceName, n.getLineno(), n.getCharno());\n            if (forgiving) {\n                namedType.forgiveUnknownNames();\n            }\n            if (resolveMode !\u003d ResolveMode.LAZY_NAMES) {\n                namedType \u003d namedType.resolveInternal(reporter, scope);\n            }\n            if ((namedType instanceof ObjectType) \u0026\u0026 !(nonNullableTypeNames.contains(n.getString()))) {\n                Node typeList \u003d n.getFirstChild();\n                if (typeList !\u003d null \u0026\u0026 (\"Array\".equals(n.getString()) || \"Object\".equals(n.getString()))) {\n                    JSType parameterType \u003d createFromTypeNodesInternal(typeList.getLastChild(), sourceName, scope, false);\n                    namedType \u003d new ParameterizedType(this, (ObjectType) namedType, parameterType);\n                    if (typeList.hasMoreThanOneChild()) {\n                        JSType indexType \u003d createFromTypeNodesInternal(typeList.getFirstChild(), sourceName, scope, false);\n                        namedType \u003d new IndexedType(this, (ObjectType) namedType, indexType);\n                    }\n                }\n                return createDefaultObjectUnion(namedType);\n            } else {\n                return namedType;\n            }\n        case Token.FUNCTION:\n            ObjectType thisType \u003d null;\n            boolean isConstructor \u003d false;\n            Node current \u003d n.getFirstChild();\n            if (current.getType() \u003d\u003d Token.THIS || current.getType() \u003d\u003d Token.NEW) {\n                Node contextNode \u003d current.getFirstChild();\n                thisType \u003d ObjectType.cast(createFromTypeNodesInternal(contextNode, sourceName, scope, false).restrictByNotNullOrUndefined());\n                if (thisType \u003d\u003d null) {\n                    reporter.warning(ScriptRuntime.getMessage0(current.getType() \u003d\u003d Token.THIS ? \"msg.jsdoc.function.thisnotobject\" : \"msg.jsdoc.function.newnotobject\"), sourceName, contextNode.getLineno(), \"\", contextNode.getCharno());\n                }\n                isConstructor \u003d current.getType() \u003d\u003d Token.NEW;\n                current \u003d current.getNext();\n            }\n            FunctionParamBuilder paramBuilder \u003d new FunctionParamBuilder(this);\n            if (current.getType() \u003d\u003d Token.LP) {\n                Node args \u003d current.getFirstChild();\n                for (Node arg \u003d current.getFirstChild(); arg !\u003d null; arg \u003d arg.getNext()) {\n                    if (arg.getType() \u003d\u003d Token.ELLIPSIS) {\n                        if (arg.getChildCount() \u003d\u003d 0) {\n                            paramBuilder.addVarArgs(getNativeType(UNKNOWN_TYPE));\n                        } else {\n                            paramBuilder.addVarArgs(createFromTypeNodesInternal(arg.getFirstChild(), sourceName, scope, false));\n                        }\n                    } else {\n                        JSType type \u003d createFromTypeNodesInternal(arg, sourceName, scope, false);\n                        if (arg.getType() \u003d\u003d Token.EQUALS) {\n                            boolean addSuccess \u003d paramBuilder.addOptionalParams(type);\n                            if (!addSuccess) {\n                                reporter.warning(ScriptRuntime.getMessage0(\"msg.jsdoc.function.varargs\"), sourceName, arg.getLineno(), \"\", arg.getCharno());\n                            }\n                        } else {\n                            paramBuilder.addRequiredParams(type);\n                        }\n                    }\n                }\n                current \u003d current.getNext();\n            }\n            JSType returnType \u003d createFromTypeNodesInternal(current, sourceName, scope, false);\n            return new FunctionBuilder(this).withParams(paramBuilder).withReturnType(returnType).withTypeOfThis(thisType).setIsConstructor(isConstructor).build();\n    }\n    throw new IllegalStateException(\"Unexpected node in type expression: \" + n.toString());\n}",
      "path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
      "functionStartLine": 1371,
      "functionName": "createFromTypeNodesInternal",
      "functionAnnotation": "",
      "functionDoc": "\n@see #createFromTypeNodes(Node, String, StaticScope, boolean)\n",
      "diff": "@@ -1,92 +1,94 @@\n private JSType createFromTypeNodesInternal(Node n, String sourceName, StaticScope\u003cJSType\u003e scope, boolean forgiving) {\n     switch(n.getType()) {\n         case Token.LC:\n             return createRecordTypeFromNodes(n.getFirstChild(), sourceName, scope);\n         case Token.BANG:\n             return createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope, forgiving).restrictByNotNullOrUndefined();\n         case Token.QMARK:\n             Node firstChild \u003d n.getFirstChild();\n             if (firstChild \u003d\u003d null) {\n                 return getNativeType(UNKNOWN_TYPE);\n             }\n             return createDefaultObjectUnion(createFromTypeNodesInternal(firstChild, sourceName, scope, forgiving));\n         case Token.EQUALS:\n             return createOptionalType(createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope, false));\n         case Token.ELLIPSIS:\n             return createOptionalType(createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope, false));\n         case Token.STAR:\n             return getNativeType(ALL_TYPE);\n         case Token.LB:\n             return getNativeType(ARRAY_TYPE);\n         case Token.PIPE:\n             UnionTypeBuilder builder \u003d new UnionTypeBuilder(this);\n             for (Node child \u003d n.getFirstChild(); child !\u003d null; child \u003d child.getNext()) {\n                 builder.addAlternate(createFromTypeNodesInternal(child, sourceName, scope, false));\n             }\n             return builder.build();\n         case Token.EMPTY:\n             return getNativeType(UNKNOWN_TYPE);\n         case Token.VOID:\n             return getNativeType(VOID_TYPE);\n         case Token.STRING:\n             JSType namedType \u003d getType(scope, n.getString(), sourceName, n.getLineno(), n.getCharno());\n             if (forgiving) {\n                 namedType.forgiveUnknownNames();\n             }\n             if (resolveMode !\u003d ResolveMode.LAZY_NAMES) {\n                 namedType \u003d namedType.resolveInternal(reporter, scope);\n             }\n             if ((namedType instanceof ObjectType) \u0026\u0026 !(nonNullableTypeNames.contains(n.getString()))) {\n                 Node typeList \u003d n.getFirstChild();\n                 if (typeList !\u003d null \u0026\u0026 (\"Array\".equals(n.getString()) || \"Object\".equals(n.getString()))) {\n                     JSType parameterType \u003d createFromTypeNodesInternal(typeList.getLastChild(), sourceName, scope, false);\n                     namedType \u003d new ParameterizedType(this, (ObjectType) namedType, parameterType);\n                     if (typeList.hasMoreThanOneChild()) {\n                         JSType indexType \u003d createFromTypeNodesInternal(typeList.getFirstChild(), sourceName, scope, false);\n                         namedType \u003d new IndexedType(this, (ObjectType) namedType, indexType);\n                     }\n                 }\n                 return createDefaultObjectUnion(namedType);\n             } else {\n                 return namedType;\n             }\n         case Token.FUNCTION:\n             ObjectType thisType \u003d null;\n+            boolean isConstructor \u003d false;\n             Node current \u003d n.getFirstChild();\n-            if (current.getType() \u003d\u003d Token.THIS) {\n-                Node thisNode \u003d current.getFirstChild();\n-                thisType \u003d ObjectType.cast(createFromTypeNodesInternal(thisNode, sourceName, scope, false).restrictByNotNullOrUndefined());\n+            if (current.getType() \u003d\u003d Token.THIS || current.getType() \u003d\u003d Token.NEW) {\n+                Node contextNode \u003d current.getFirstChild();\n+                thisType \u003d ObjectType.cast(createFromTypeNodesInternal(contextNode, sourceName, scope, false).restrictByNotNullOrUndefined());\n                 if (thisType \u003d\u003d null) {\n-                    reporter.warning(ScriptRuntime.getMessage0(\"msg.jsdoc.function.thisnotobject\"), sourceName, thisNode.getLineno(), \"\", thisNode.getCharno());\n+                    reporter.warning(ScriptRuntime.getMessage0(current.getType() \u003d\u003d Token.THIS ? \"msg.jsdoc.function.thisnotobject\" : \"msg.jsdoc.function.newnotobject\"), sourceName, contextNode.getLineno(), \"\", contextNode.getCharno());\n                 }\n+                isConstructor \u003d current.getType() \u003d\u003d Token.NEW;\n                 current \u003d current.getNext();\n             }\n             FunctionParamBuilder paramBuilder \u003d new FunctionParamBuilder(this);\n             if (current.getType() \u003d\u003d Token.LP) {\n                 Node args \u003d current.getFirstChild();\n                 for (Node arg \u003d current.getFirstChild(); arg !\u003d null; arg \u003d arg.getNext()) {\n                     if (arg.getType() \u003d\u003d Token.ELLIPSIS) {\n                         if (arg.getChildCount() \u003d\u003d 0) {\n                             paramBuilder.addVarArgs(getNativeType(UNKNOWN_TYPE));\n                         } else {\n                             paramBuilder.addVarArgs(createFromTypeNodesInternal(arg.getFirstChild(), sourceName, scope, false));\n                         }\n                     } else {\n                         JSType type \u003d createFromTypeNodesInternal(arg, sourceName, scope, false);\n                         if (arg.getType() \u003d\u003d Token.EQUALS) {\n                             boolean addSuccess \u003d paramBuilder.addOptionalParams(type);\n                             if (!addSuccess) {\n                                 reporter.warning(ScriptRuntime.getMessage0(\"msg.jsdoc.function.varargs\"), sourceName, arg.getLineno(), \"\", arg.getCharno());\n                             }\n                         } else {\n                             paramBuilder.addRequiredParams(type);\n                         }\n                     }\n                 }\n                 current \u003d current.getNext();\n             }\n             JSType returnType \u003d createFromTypeNodesInternal(current, sourceName, scope, false);\n-            return new FunctionBuilder(this).withParams(paramBuilder).withReturnType(returnType).withTypeOfThis(thisType).build();\n+            return new FunctionBuilder(this).withParams(paramBuilder).withReturnType(returnType).withTypeOfThis(thisType).setIsConstructor(isConstructor).build();\n     }\n     throw new IllegalStateException(\"Unexpected node in type expression: \" + n.toString());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3698fee71e3671171c587f932795a8ab8e852cd8": {
      "type": "Ybodychange",
      "commitMessage": "\nwhen deciding whether named types are nullable, let enums and\ntypedefs share the same hacky logic.\n\nR\u003djohnlenz\nDELTA\u003d83  (57 added, 0 deleted, 26 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d804008\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@520 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "10/28/10, 8:31 AM",
      "commitName": "3698fee71e3671171c587f932795a8ab8e852cd8",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "10/27/10, 9:43 AM",
      "commitNameOld": "3faef1d4959a55ebd86a09cd5395afb54ab5ec25",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 0.95,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "private JSType createFromTypeNodesInternal(Node n, String sourceName, StaticScope\u003cJSType\u003e scope, boolean forgiving) {\n    switch(n.getType()) {\n        case Token.LC:\n            return createRecordTypeFromNodes(n.getFirstChild(), sourceName, scope);\n        case Token.BANG:\n            return createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope, forgiving).restrictByNotNullOrUndefined();\n        case Token.QMARK:\n            Node firstChild \u003d n.getFirstChild();\n            if (firstChild \u003d\u003d null) {\n                return getNativeType(UNKNOWN_TYPE);\n            }\n            return createDefaultObjectUnion(createFromTypeNodesInternal(firstChild, sourceName, scope, forgiving));\n        case Token.EQUALS:\n            return createOptionalType(createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope, false));\n        case Token.ELLIPSIS:\n            return createOptionalType(createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope, false));\n        case Token.STAR:\n            return getNativeType(ALL_TYPE);\n        case Token.LB:\n            return getNativeType(ARRAY_TYPE);\n        case Token.PIPE:\n            UnionTypeBuilder builder \u003d new UnionTypeBuilder(this);\n            for (Node child \u003d n.getFirstChild(); child !\u003d null; child \u003d child.getNext()) {\n                builder.addAlternate(createFromTypeNodesInternal(child, sourceName, scope, false));\n            }\n            return builder.build();\n        case Token.EMPTY:\n            return getNativeType(UNKNOWN_TYPE);\n        case Token.VOID:\n            return getNativeType(VOID_TYPE);\n        case Token.STRING:\n            JSType namedType \u003d getType(scope, n.getString(), sourceName, n.getLineno(), n.getCharno());\n            if (forgiving) {\n                namedType.forgiveUnknownNames();\n            }\n            if (resolveMode !\u003d ResolveMode.LAZY_NAMES) {\n                namedType \u003d namedType.resolveInternal(reporter, scope);\n            }\n            if ((namedType instanceof ObjectType) \u0026\u0026 !(nonNullableTypeNames.contains(n.getString()))) {\n                Node typeList \u003d n.getFirstChild();\n                if (typeList !\u003d null \u0026\u0026 (\"Array\".equals(n.getString()) || \"Object\".equals(n.getString()))) {\n                    JSType parameterType \u003d createFromTypeNodesInternal(typeList.getLastChild(), sourceName, scope, false);\n                    namedType \u003d new ParameterizedType(this, (ObjectType) namedType, parameterType);\n                    if (typeList.hasMoreThanOneChild()) {\n                        JSType indexType \u003d createFromTypeNodesInternal(typeList.getFirstChild(), sourceName, scope, false);\n                        namedType \u003d new IndexedType(this, (ObjectType) namedType, indexType);\n                    }\n                }\n                return createDefaultObjectUnion(namedType);\n            } else {\n                return namedType;\n            }\n        case Token.FUNCTION:\n            ObjectType thisType \u003d null;\n            Node current \u003d n.getFirstChild();\n            if (current.getType() \u003d\u003d Token.THIS) {\n                Node thisNode \u003d current.getFirstChild();\n                thisType \u003d ObjectType.cast(createFromTypeNodesInternal(thisNode, sourceName, scope, false).restrictByNotNullOrUndefined());\n                if (thisType \u003d\u003d null) {\n                    reporter.warning(ScriptRuntime.getMessage0(\"msg.jsdoc.function.thisnotobject\"), sourceName, thisNode.getLineno(), \"\", thisNode.getCharno());\n                }\n                current \u003d current.getNext();\n            }\n            FunctionParamBuilder paramBuilder \u003d new FunctionParamBuilder(this);\n            if (current.getType() \u003d\u003d Token.LP) {\n                Node args \u003d current.getFirstChild();\n                for (Node arg \u003d current.getFirstChild(); arg !\u003d null; arg \u003d arg.getNext()) {\n                    if (arg.getType() \u003d\u003d Token.ELLIPSIS) {\n                        if (arg.getChildCount() \u003d\u003d 0) {\n                            paramBuilder.addVarArgs(getNativeType(UNKNOWN_TYPE));\n                        } else {\n                            paramBuilder.addVarArgs(createFromTypeNodesInternal(arg.getFirstChild(), sourceName, scope, false));\n                        }\n                    } else {\n                        JSType type \u003d createFromTypeNodesInternal(arg, sourceName, scope, false);\n                        if (arg.getType() \u003d\u003d Token.EQUALS) {\n                            boolean addSuccess \u003d paramBuilder.addOptionalParams(type);\n                            if (!addSuccess) {\n                                reporter.warning(ScriptRuntime.getMessage0(\"msg.jsdoc.function.varargs\"), sourceName, arg.getLineno(), \"\", arg.getCharno());\n                            }\n                        } else {\n                            paramBuilder.addRequiredParams(type);\n                        }\n                    }\n                }\n                current \u003d current.getNext();\n            }\n            JSType returnType \u003d createFromTypeNodesInternal(current, sourceName, scope, false);\n            return new FunctionBuilder(this).withParams(paramBuilder).withReturnType(returnType).withTypeOfThis(thisType).build();\n    }\n    throw new IllegalStateException(\"Unexpected node in type expression: \" + n.toString());\n}",
      "path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
      "functionStartLine": 1336,
      "functionName": "createFromTypeNodesInternal",
      "functionAnnotation": "",
      "functionDoc": "\n@see #createFromTypeNodes(Node, String, StaticScope, boolean)\n",
      "diff": "@@ -1,92 +1,92 @@\n private JSType createFromTypeNodesInternal(Node n, String sourceName, StaticScope\u003cJSType\u003e scope, boolean forgiving) {\n     switch(n.getType()) {\n         case Token.LC:\n             return createRecordTypeFromNodes(n.getFirstChild(), sourceName, scope);\n         case Token.BANG:\n             return createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope, forgiving).restrictByNotNullOrUndefined();\n         case Token.QMARK:\n             Node firstChild \u003d n.getFirstChild();\n             if (firstChild \u003d\u003d null) {\n                 return getNativeType(UNKNOWN_TYPE);\n             }\n             return createDefaultObjectUnion(createFromTypeNodesInternal(firstChild, sourceName, scope, forgiving));\n         case Token.EQUALS:\n             return createOptionalType(createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope, false));\n         case Token.ELLIPSIS:\n             return createOptionalType(createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope, false));\n         case Token.STAR:\n             return getNativeType(ALL_TYPE);\n         case Token.LB:\n             return getNativeType(ARRAY_TYPE);\n         case Token.PIPE:\n             UnionTypeBuilder builder \u003d new UnionTypeBuilder(this);\n             for (Node child \u003d n.getFirstChild(); child !\u003d null; child \u003d child.getNext()) {\n                 builder.addAlternate(createFromTypeNodesInternal(child, sourceName, scope, false));\n             }\n             return builder.build();\n         case Token.EMPTY:\n             return getNativeType(UNKNOWN_TYPE);\n         case Token.VOID:\n             return getNativeType(VOID_TYPE);\n         case Token.STRING:\n             JSType namedType \u003d getType(scope, n.getString(), sourceName, n.getLineno(), n.getCharno());\n             if (forgiving) {\n                 namedType.forgiveUnknownNames();\n             }\n             if (resolveMode !\u003d ResolveMode.LAZY_NAMES) {\n                 namedType \u003d namedType.resolveInternal(reporter, scope);\n             }\n-            if ((namedType instanceof ObjectType) \u0026\u0026 !(enumTypeNames.contains(n.getString()))) {\n+            if ((namedType instanceof ObjectType) \u0026\u0026 !(nonNullableTypeNames.contains(n.getString()))) {\n                 Node typeList \u003d n.getFirstChild();\n                 if (typeList !\u003d null \u0026\u0026 (\"Array\".equals(n.getString()) || \"Object\".equals(n.getString()))) {\n                     JSType parameterType \u003d createFromTypeNodesInternal(typeList.getLastChild(), sourceName, scope, false);\n                     namedType \u003d new ParameterizedType(this, (ObjectType) namedType, parameterType);\n                     if (typeList.hasMoreThanOneChild()) {\n                         JSType indexType \u003d createFromTypeNodesInternal(typeList.getFirstChild(), sourceName, scope, false);\n                         namedType \u003d new IndexedType(this, (ObjectType) namedType, indexType);\n                     }\n                 }\n                 return createDefaultObjectUnion(namedType);\n             } else {\n                 return namedType;\n             }\n         case Token.FUNCTION:\n             ObjectType thisType \u003d null;\n             Node current \u003d n.getFirstChild();\n             if (current.getType() \u003d\u003d Token.THIS) {\n                 Node thisNode \u003d current.getFirstChild();\n                 thisType \u003d ObjectType.cast(createFromTypeNodesInternal(thisNode, sourceName, scope, false).restrictByNotNullOrUndefined());\n                 if (thisType \u003d\u003d null) {\n                     reporter.warning(ScriptRuntime.getMessage0(\"msg.jsdoc.function.thisnotobject\"), sourceName, thisNode.getLineno(), \"\", thisNode.getCharno());\n                 }\n                 current \u003d current.getNext();\n             }\n             FunctionParamBuilder paramBuilder \u003d new FunctionParamBuilder(this);\n             if (current.getType() \u003d\u003d Token.LP) {\n                 Node args \u003d current.getFirstChild();\n                 for (Node arg \u003d current.getFirstChild(); arg !\u003d null; arg \u003d arg.getNext()) {\n                     if (arg.getType() \u003d\u003d Token.ELLIPSIS) {\n                         if (arg.getChildCount() \u003d\u003d 0) {\n                             paramBuilder.addVarArgs(getNativeType(UNKNOWN_TYPE));\n                         } else {\n                             paramBuilder.addVarArgs(createFromTypeNodesInternal(arg.getFirstChild(), sourceName, scope, false));\n                         }\n                     } else {\n                         JSType type \u003d createFromTypeNodesInternal(arg, sourceName, scope, false);\n                         if (arg.getType() \u003d\u003d Token.EQUALS) {\n                             boolean addSuccess \u003d paramBuilder.addOptionalParams(type);\n                             if (!addSuccess) {\n                                 reporter.warning(ScriptRuntime.getMessage0(\"msg.jsdoc.function.varargs\"), sourceName, arg.getLineno(), \"\", arg.getCharno());\n                             }\n                         } else {\n                             paramBuilder.addRequiredParams(type);\n                         }\n                     }\n                 }\n                 current \u003d current.getNext();\n             }\n             JSType returnType \u003d createFromTypeNodesInternal(current, sourceName, scope, false);\n             return new FunctionBuilder(this).withParams(paramBuilder).withReturnType(returnType).withTypeOfThis(thisType).build();\n     }\n     throw new IllegalStateException(\"Unexpected node in type expression: \" + n.toString());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "58c3e4ce1d17ec619bcc4964bdeebc676f93567d": {
      "type": "Yintroduced",
      "commitMessage": "\n\nChange on 2010/05/03 by robby\n\n        Preliminary: goog.scope support for closure-compiler\n\n        R\u003dnick,john\n        DELTA\u003d318  (318 added, 0 deleted, 0 changed)\n\nChange on 2010/05/03 by nick\n\n        Add a bit more smarts to type resolution. Also, give it a\n        \"forceResolve\" method so that it will try to resolve type names,\n        even if the registry is in a lazy mode.\n\n        R\u003drobert\n        DELTA\u003d205  (133 added, 54 deleted, 18 changed)\n\nChange on 2010/05/03 by alan\n\n        Enable Flow Sensitive Inlining by default. Passes GMail automation test.\n\n        R\u003dnick\n        DELTA\u003d1  (0 added, 0 deleted, 1 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003dcmvhwl\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@202 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "5/4/10, 7:39 AM",
      "commitName": "58c3e4ce1d17ec619bcc4964bdeebc676f93567d",
      "commitAuthor": "Nicholas.J.Santos",
      "diff": "@@ -0,0 +1,92 @@\n+private JSType createFromTypeNodesInternal(Node n, String sourceName, StaticScope\u003cJSType\u003e scope, boolean forgiving) {\n+    switch(n.getType()) {\n+        case Token.LC:\n+            return createRecordTypeFromNodes(n.getFirstChild(), sourceName, scope);\n+        case Token.BANG:\n+            return createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope, forgiving).restrictByNotNullOrUndefined();\n+        case Token.QMARK:\n+            Node firstChild \u003d n.getFirstChild();\n+            if (firstChild \u003d\u003d null) {\n+                return getNativeType(UNKNOWN_TYPE);\n+            }\n+            return createDefaultObjectUnion(createFromTypeNodesInternal(firstChild, sourceName, scope, forgiving));\n+        case Token.EQUALS:\n+            return createOptionalType(createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope, false));\n+        case Token.ELLIPSIS:\n+            return createOptionalType(createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope, false));\n+        case Token.STAR:\n+            return getNativeType(ALL_TYPE);\n+        case Token.LB:\n+            return getNativeType(ARRAY_TYPE);\n+        case Token.PIPE:\n+            UnionTypeBuilder builder \u003d new UnionTypeBuilder(this);\n+            for (Node child \u003d n.getFirstChild(); child !\u003d null; child \u003d child.getNext()) {\n+                builder.addAlternate(createFromTypeNodesInternal(child, sourceName, scope, false));\n+            }\n+            return builder.build();\n+        case Token.EMPTY:\n+            return getNativeType(UNKNOWN_TYPE);\n+        case Token.VOID:\n+            return getNativeType(VOID_TYPE);\n+        case Token.STRING:\n+            JSType namedType \u003d getType(scope, n.getString(), sourceName, n.getLineno(), n.getCharno());\n+            if (forgiving) {\n+                namedType.forgiveUnknownNames();\n+            }\n+            if (resolveMode !\u003d ResolveMode.LAZY_NAMES) {\n+                namedType \u003d namedType.resolveInternal(reporter, scope);\n+            }\n+            if ((namedType instanceof ObjectType) \u0026\u0026 !(enumTypeNames.contains(n.getString()))) {\n+                Node typeList \u003d n.getFirstChild();\n+                if (typeList !\u003d null \u0026\u0026 (\"Array\".equals(n.getString()) || \"Object\".equals(n.getString()))) {\n+                    JSType parameterType \u003d createFromTypeNodesInternal(typeList.getLastChild(), sourceName, scope, false);\n+                    namedType \u003d new ParameterizedType(this, (ObjectType) namedType, parameterType);\n+                    if (typeList.hasMoreThanOneChild()) {\n+                        JSType indexType \u003d createFromTypeNodesInternal(typeList.getFirstChild(), sourceName, scope, false);\n+                        namedType \u003d new IndexedType(this, (ObjectType) namedType, indexType);\n+                    }\n+                }\n+                return createDefaultObjectUnion(namedType);\n+            } else {\n+                return namedType;\n+            }\n+        case Token.FUNCTION:\n+            ObjectType thisType \u003d null;\n+            Node current \u003d n.getFirstChild();\n+            if (current.getType() \u003d\u003d Token.THIS) {\n+                Node thisNode \u003d current.getFirstChild();\n+                thisType \u003d ObjectType.cast(createFromTypeNodesInternal(thisNode, sourceName, scope, false).restrictByNotNullOrUndefined());\n+                if (thisType \u003d\u003d null) {\n+                    reporter.warning(ScriptRuntime.getMessage0(\"msg.jsdoc.function.thisnotobject\"), sourceName, thisNode.getLineno(), \"\", thisNode.getCharno());\n+                }\n+                current \u003d current.getNext();\n+            }\n+            FunctionParamBuilder paramBuilder \u003d new FunctionParamBuilder(this);\n+            if (current.getType() \u003d\u003d Token.LP) {\n+                Node args \u003d current.getFirstChild();\n+                for (Node arg \u003d current.getFirstChild(); arg !\u003d null; arg \u003d arg.getNext()) {\n+                    if (arg.getType() \u003d\u003d Token.ELLIPSIS) {\n+                        if (arg.getChildCount() \u003d\u003d 0) {\n+                            paramBuilder.addVarArgs(getNativeType(UNKNOWN_TYPE));\n+                        } else {\n+                            paramBuilder.addVarArgs(createFromTypeNodesInternal(arg.getFirstChild(), sourceName, scope, false));\n+                        }\n+                    } else {\n+                        JSType type \u003d createFromTypeNodesInternal(arg, sourceName, scope, false);\n+                        if (arg.getType() \u003d\u003d Token.EQUALS) {\n+                            boolean addSuccess \u003d paramBuilder.addOptionalParams(type);\n+                            if (!addSuccess) {\n+                                reporter.warning(ScriptRuntime.getMessage0(\"msg.jsdoc.function.varargs\"), sourceName, arg.getLineno(), \"\", arg.getCharno());\n+                            }\n+                        } else {\n+                            paramBuilder.addRequiredParams(type);\n+                        }\n+                    }\n+                }\n+                current \u003d current.getNext();\n+            }\n+            JSType returnType \u003d createFromTypeNodesInternal(current, sourceName, scope, false);\n+            return new FunctionBuilder(this).withParams(paramBuilder).withReturnType(returnType).withTypeOfThis(thisType).build();\n+    }\n+    throw new IllegalStateException(\"Unexpected node in type expression: \" + n.toString());\n+}\n\\ No newline at end of file\n",
      "actualSource": "private JSType createFromTypeNodesInternal(Node n, String sourceName, StaticScope\u003cJSType\u003e scope, boolean forgiving) {\n    switch(n.getType()) {\n        case Token.LC:\n            return createRecordTypeFromNodes(n.getFirstChild(), sourceName, scope);\n        case Token.BANG:\n            return createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope, forgiving).restrictByNotNullOrUndefined();\n        case Token.QMARK:\n            Node firstChild \u003d n.getFirstChild();\n            if (firstChild \u003d\u003d null) {\n                return getNativeType(UNKNOWN_TYPE);\n            }\n            return createDefaultObjectUnion(createFromTypeNodesInternal(firstChild, sourceName, scope, forgiving));\n        case Token.EQUALS:\n            return createOptionalType(createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope, false));\n        case Token.ELLIPSIS:\n            return createOptionalType(createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope, false));\n        case Token.STAR:\n            return getNativeType(ALL_TYPE);\n        case Token.LB:\n            return getNativeType(ARRAY_TYPE);\n        case Token.PIPE:\n            UnionTypeBuilder builder \u003d new UnionTypeBuilder(this);\n            for (Node child \u003d n.getFirstChild(); child !\u003d null; child \u003d child.getNext()) {\n                builder.addAlternate(createFromTypeNodesInternal(child, sourceName, scope, false));\n            }\n            return builder.build();\n        case Token.EMPTY:\n            return getNativeType(UNKNOWN_TYPE);\n        case Token.VOID:\n            return getNativeType(VOID_TYPE);\n        case Token.STRING:\n            JSType namedType \u003d getType(scope, n.getString(), sourceName, n.getLineno(), n.getCharno());\n            if (forgiving) {\n                namedType.forgiveUnknownNames();\n            }\n            if (resolveMode !\u003d ResolveMode.LAZY_NAMES) {\n                namedType \u003d namedType.resolveInternal(reporter, scope);\n            }\n            if ((namedType instanceof ObjectType) \u0026\u0026 !(enumTypeNames.contains(n.getString()))) {\n                Node typeList \u003d n.getFirstChild();\n                if (typeList !\u003d null \u0026\u0026 (\"Array\".equals(n.getString()) || \"Object\".equals(n.getString()))) {\n                    JSType parameterType \u003d createFromTypeNodesInternal(typeList.getLastChild(), sourceName, scope, false);\n                    namedType \u003d new ParameterizedType(this, (ObjectType) namedType, parameterType);\n                    if (typeList.hasMoreThanOneChild()) {\n                        JSType indexType \u003d createFromTypeNodesInternal(typeList.getFirstChild(), sourceName, scope, false);\n                        namedType \u003d new IndexedType(this, (ObjectType) namedType, indexType);\n                    }\n                }\n                return createDefaultObjectUnion(namedType);\n            } else {\n                return namedType;\n            }\n        case Token.FUNCTION:\n            ObjectType thisType \u003d null;\n            Node current \u003d n.getFirstChild();\n            if (current.getType() \u003d\u003d Token.THIS) {\n                Node thisNode \u003d current.getFirstChild();\n                thisType \u003d ObjectType.cast(createFromTypeNodesInternal(thisNode, sourceName, scope, false).restrictByNotNullOrUndefined());\n                if (thisType \u003d\u003d null) {\n                    reporter.warning(ScriptRuntime.getMessage0(\"msg.jsdoc.function.thisnotobject\"), sourceName, thisNode.getLineno(), \"\", thisNode.getCharno());\n                }\n                current \u003d current.getNext();\n            }\n            FunctionParamBuilder paramBuilder \u003d new FunctionParamBuilder(this);\n            if (current.getType() \u003d\u003d Token.LP) {\n                Node args \u003d current.getFirstChild();\n                for (Node arg \u003d current.getFirstChild(); arg !\u003d null; arg \u003d arg.getNext()) {\n                    if (arg.getType() \u003d\u003d Token.ELLIPSIS) {\n                        if (arg.getChildCount() \u003d\u003d 0) {\n                            paramBuilder.addVarArgs(getNativeType(UNKNOWN_TYPE));\n                        } else {\n                            paramBuilder.addVarArgs(createFromTypeNodesInternal(arg.getFirstChild(), sourceName, scope, false));\n                        }\n                    } else {\n                        JSType type \u003d createFromTypeNodesInternal(arg, sourceName, scope, false);\n                        if (arg.getType() \u003d\u003d Token.EQUALS) {\n                            boolean addSuccess \u003d paramBuilder.addOptionalParams(type);\n                            if (!addSuccess) {\n                                reporter.warning(ScriptRuntime.getMessage0(\"msg.jsdoc.function.varargs\"), sourceName, arg.getLineno(), \"\", arg.getCharno());\n                            }\n                        } else {\n                            paramBuilder.addRequiredParams(type);\n                        }\n                    }\n                }\n                current \u003d current.getNext();\n            }\n            JSType returnType \u003d createFromTypeNodesInternal(current, sourceName, scope, false);\n            return new FunctionBuilder(this).withParams(paramBuilder).withReturnType(returnType).withTypeOfThis(thisType).build();\n    }\n    throw new IllegalStateException(\"Unexpected node in type expression: \" + n.toString());\n}",
      "path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
      "functionStartLine": 1293,
      "functionName": "createFromTypeNodesInternal",
      "functionAnnotation": "",
      "functionDoc": "\n@see #createFromTypeNodes(Node, String, StaticScope, boolean)\n"
    }
  }
}