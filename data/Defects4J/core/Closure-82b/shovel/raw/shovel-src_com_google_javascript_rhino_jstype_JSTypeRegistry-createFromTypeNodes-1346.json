{
  "origin": "codeshovel",
  "repositoryName": "Closure-82b",
  "repositoryPath": "/tmp/Closure-82b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "JSTypeRegistry.java",
  "functionName": "createFromTypeNodes",
  "functionId": "createFromTypeNodes___n-Node__sourceName-String__scope-StaticScope__JSType____forgiving-boolean",
  "sourceFilePath": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
  "functionAnnotation": "",
  "functionDoc": "Creates a JSType from the nodes representing a type.\n\n@param n The node with type info.\n@param sourceName The source file name.\n@param scope A scope for doing type name lookups.\n@param forgiving Whether we should be forgiving about type names\n    that we can\u0027t find.\n",
  "functionStartLine": 1346,
  "functionEndLine": 1357,
  "numCommitsSeen": 33,
  "timeTaken": 2547,
  "changeHistory": [
    "58c3e4ce1d17ec619bcc4964bdeebc676f93567d",
    "eb5eae4438f49ffddd3c8be1413eeb9e7ecfb311"
  ],
  "changeHistoryShort": {
    "58c3e4ce1d17ec619bcc4964bdeebc676f93567d": "Ybodychange",
    "eb5eae4438f49ffddd3c8be1413eeb9e7ecfb311": "Yintroduced"
  },
  "changeHistoryDetails": {
    "58c3e4ce1d17ec619bcc4964bdeebc676f93567d": {
      "type": "Ybodychange",
      "commitMessage": "\n\nChange on 2010/05/03 by robby\n\n        Preliminary: goog.scope support for closure-compiler\n\n        R\u003dnick,john\n        DELTA\u003d318  (318 added, 0 deleted, 0 changed)\n\nChange on 2010/05/03 by nick\n\n        Add a bit more smarts to type resolution. Also, give it a\n        \"forceResolve\" method so that it will try to resolve type names,\n        even if the registry is in a lazy mode.\n\n        R\u003drobert\n        DELTA\u003d205  (133 added, 54 deleted, 18 changed)\n\nChange on 2010/05/03 by alan\n\n        Enable Flow Sensitive Inlining by default. Passes GMail automation test.\n\n        R\u003dnick\n        DELTA\u003d1  (0 added, 0 deleted, 1 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003dcmvhwl\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@202 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "5/4/10, 7:39 AM",
      "commitName": "58c3e4ce1d17ec619bcc4964bdeebc676f93567d",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "4/27/10, 12:02 PM",
      "commitNameOld": "eb5eae4438f49ffddd3c8be1413eeb9e7ecfb311",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 6.82,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "public JSType createFromTypeNodes(Node n, String sourceName, StaticScope\u003cJSType\u003e scope, boolean forgiving) {\n    if (resolveMode \u003d\u003d ResolveMode.LAZY_EXPRESSIONS) {\n        boolean hasNames \u003d hasTypeName(n);\n        if (hasNames) {\n            return new UnresolvedTypeExpression(this, n, sourceName, forgiving);\n        }\n    }\n    return createFromTypeNodesInternal(n, sourceName, scope, forgiving);\n}",
      "path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
      "functionStartLine": 1264,
      "functionName": "createFromTypeNodes",
      "functionAnnotation": "",
      "functionDoc": "Creates a JSType from the nodes representing a type.\n\n@param n The node with type info.\n@param sourceName The source file name.\n@param scope A scope for doing type name lookups.\n@param forgiving Whether we should be forgiving about type names\n    that we can\u0027t find.\n",
      "diff": "@@ -1,95 +1,9 @@\n public JSType createFromTypeNodes(Node n, String sourceName, StaticScope\u003cJSType\u003e scope, boolean forgiving) {\n     if (resolveMode \u003d\u003d ResolveMode.LAZY_EXPRESSIONS) {\n-        return new UnresolvedTypeExpression(this, n, sourceName, forgiving);\n+        boolean hasNames \u003d hasTypeName(n);\n+        if (hasNames) {\n+            return new UnresolvedTypeExpression(this, n, sourceName, forgiving);\n+        }\n     }\n-    switch(n.getType()) {\n-        case Token.LC:\n-            return createRecordTypeFromNodes(n.getFirstChild(), sourceName, scope);\n-        case Token.BANG:\n-            return createFromTypeNodes(n.getFirstChild(), sourceName, scope, forgiving).restrictByNotNullOrUndefined();\n-        case Token.QMARK:\n-            Node firstChild \u003d n.getFirstChild();\n-            if (firstChild \u003d\u003d null) {\n-                return getNativeType(UNKNOWN_TYPE);\n-            }\n-            return createDefaultObjectUnion(createFromTypeNodes(firstChild, sourceName, scope, forgiving));\n-        case Token.EQUALS:\n-            return createOptionalType(createFromTypeNodes(n.getFirstChild(), sourceName, scope));\n-        case Token.ELLIPSIS:\n-            return createOptionalType(createFromTypeNodes(n.getFirstChild(), sourceName, scope));\n-        case Token.STAR:\n-            return getNativeType(ALL_TYPE);\n-        case Token.LB:\n-            return getNativeType(ARRAY_TYPE);\n-        case Token.PIPE:\n-            UnionTypeBuilder builder \u003d new UnionTypeBuilder(this);\n-            for (Node child \u003d n.getFirstChild(); child !\u003d null; child \u003d child.getNext()) {\n-                builder.addAlternate(createFromTypeNodes(child, sourceName, scope));\n-            }\n-            return builder.build();\n-        case Token.EMPTY:\n-            return getNativeType(UNKNOWN_TYPE);\n-        case Token.VOID:\n-            return getNativeType(VOID_TYPE);\n-        case Token.STRING:\n-            JSType namedType \u003d getType(scope, n.getString(), sourceName, n.getLineno(), n.getCharno());\n-            if (forgiving) {\n-                namedType.forgiveUnknownNames();\n-            }\n-            if (resolveMode !\u003d ResolveMode.LAZY_NAMES) {\n-                namedType \u003d namedType.resolveInternal(reporter, scope);\n-            }\n-            if ((namedType instanceof ObjectType) \u0026\u0026 !(enumTypeNames.contains(n.getString()))) {\n-                Node typeList \u003d n.getFirstChild();\n-                if (typeList !\u003d null \u0026\u0026 (\"Array\".equals(n.getString()) || \"Object\".equals(n.getString()))) {\n-                    JSType parameterType \u003d createFromTypeNodes(typeList.getLastChild(), sourceName, scope);\n-                    namedType \u003d new ParameterizedType(this, (ObjectType) namedType, parameterType);\n-                    if (typeList.hasMoreThanOneChild()) {\n-                        JSType indexType \u003d createFromTypeNodes(typeList.getFirstChild(), sourceName, scope);\n-                        namedType \u003d new IndexedType(this, (ObjectType) namedType, indexType);\n-                    }\n-                }\n-                return createDefaultObjectUnion(namedType);\n-            } else {\n-                return namedType;\n-            }\n-        case Token.FUNCTION:\n-            ObjectType thisType \u003d null;\n-            Node current \u003d n.getFirstChild();\n-            if (current.getType() \u003d\u003d Token.THIS) {\n-                Node thisNode \u003d current.getFirstChild();\n-                thisType \u003d ObjectType.cast(createFromTypeNodes(thisNode, sourceName, scope).restrictByNotNullOrUndefined());\n-                if (thisType \u003d\u003d null) {\n-                    reporter.warning(ScriptRuntime.getMessage0(\"msg.jsdoc.function.thisnotobject\"), sourceName, thisNode.getLineno(), \"\", thisNode.getCharno());\n-                }\n-                current \u003d current.getNext();\n-            }\n-            FunctionParamBuilder paramBuilder \u003d new FunctionParamBuilder(this);\n-            if (current.getType() \u003d\u003d Token.LP) {\n-                Node args \u003d current.getFirstChild();\n-                for (Node arg \u003d current.getFirstChild(); arg !\u003d null; arg \u003d arg.getNext()) {\n-                    if (arg.getType() \u003d\u003d Token.ELLIPSIS) {\n-                        if (arg.getChildCount() \u003d\u003d 0) {\n-                            paramBuilder.addVarArgs(getNativeType(UNKNOWN_TYPE));\n-                        } else {\n-                            paramBuilder.addVarArgs(createFromTypeNodes(arg.getFirstChild(), sourceName, scope));\n-                        }\n-                    } else {\n-                        JSType type \u003d createFromTypeNodes(arg, sourceName, scope);\n-                        if (arg.getType() \u003d\u003d Token.EQUALS) {\n-                            boolean addSuccess \u003d paramBuilder.addOptionalParams(type);\n-                            if (!addSuccess) {\n-                                reporter.warning(ScriptRuntime.getMessage0(\"msg.jsdoc.function.varargs\"), sourceName, arg.getLineno(), \"\", arg.getCharno());\n-                            }\n-                        } else {\n-                            paramBuilder.addRequiredParams(type);\n-                        }\n-                    }\n-                }\n-                current \u003d current.getNext();\n-            }\n-            JSType returnType \u003d createFromTypeNodes(current, sourceName, scope);\n-            return new FunctionBuilder(this).withParams(paramBuilder).withReturnType(returnType).withTypeOfThis(thisType).build();\n-    }\n-    throw new IllegalStateException(\"Unexpected node in type expression: \" + n.toString());\n+    return createFromTypeNodesInternal(n, sourceName, scope, forgiving);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "eb5eae4438f49ffddd3c8be1413eeb9e7ecfb311": {
      "type": "Yintroduced",
      "commitMessage": "Change on 2010/04/26 by nick\n\n        forbid getters and setters. fixes closure-compiler issue 154.\n\n        R\u003drobert\n        DELTA\u003d57  (55 added, 0 deleted, 2 changed)\n\nChange on 2010/04/26 by nick\n\n        create a helper method for getting the transitive closure of a\n        number of roots.\n\n        R\u003dalan\n        DELTA\u003d172  (168 added, 2 deleted, 2 changed)\n\nChange on 2010/04/26 by nick\n\n        create a new mechanism for type name resolution.\n\n        R\u003djohn\n        DELTA\u003d222  (210 added, 5 deleted, 7 changed)\n\nChange on 2010/04/27 by john\n\n        Remove unused variables in uncalled global functions when not removing\n        unused global names. Fixes issue 155.\n\n        R\u003dnick\n        DELTA\u003d42  (34 added, 3 deleted, 5 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003daepekd\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@199 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/27/10, 12:02 PM",
      "commitName": "eb5eae4438f49ffddd3c8be1413eeb9e7ecfb311",
      "commitAuthor": "Nicholas.J.Santos",
      "diff": "@@ -0,0 +1,95 @@\n+public JSType createFromTypeNodes(Node n, String sourceName, StaticScope\u003cJSType\u003e scope, boolean forgiving) {\n+    if (resolveMode \u003d\u003d ResolveMode.LAZY_EXPRESSIONS) {\n+        return new UnresolvedTypeExpression(this, n, sourceName, forgiving);\n+    }\n+    switch(n.getType()) {\n+        case Token.LC:\n+            return createRecordTypeFromNodes(n.getFirstChild(), sourceName, scope);\n+        case Token.BANG:\n+            return createFromTypeNodes(n.getFirstChild(), sourceName, scope, forgiving).restrictByNotNullOrUndefined();\n+        case Token.QMARK:\n+            Node firstChild \u003d n.getFirstChild();\n+            if (firstChild \u003d\u003d null) {\n+                return getNativeType(UNKNOWN_TYPE);\n+            }\n+            return createDefaultObjectUnion(createFromTypeNodes(firstChild, sourceName, scope, forgiving));\n+        case Token.EQUALS:\n+            return createOptionalType(createFromTypeNodes(n.getFirstChild(), sourceName, scope));\n+        case Token.ELLIPSIS:\n+            return createOptionalType(createFromTypeNodes(n.getFirstChild(), sourceName, scope));\n+        case Token.STAR:\n+            return getNativeType(ALL_TYPE);\n+        case Token.LB:\n+            return getNativeType(ARRAY_TYPE);\n+        case Token.PIPE:\n+            UnionTypeBuilder builder \u003d new UnionTypeBuilder(this);\n+            for (Node child \u003d n.getFirstChild(); child !\u003d null; child \u003d child.getNext()) {\n+                builder.addAlternate(createFromTypeNodes(child, sourceName, scope));\n+            }\n+            return builder.build();\n+        case Token.EMPTY:\n+            return getNativeType(UNKNOWN_TYPE);\n+        case Token.VOID:\n+            return getNativeType(VOID_TYPE);\n+        case Token.STRING:\n+            JSType namedType \u003d getType(scope, n.getString(), sourceName, n.getLineno(), n.getCharno());\n+            if (forgiving) {\n+                namedType.forgiveUnknownNames();\n+            }\n+            if (resolveMode !\u003d ResolveMode.LAZY_NAMES) {\n+                namedType \u003d namedType.resolveInternal(reporter, scope);\n+            }\n+            if ((namedType instanceof ObjectType) \u0026\u0026 !(enumTypeNames.contains(n.getString()))) {\n+                Node typeList \u003d n.getFirstChild();\n+                if (typeList !\u003d null \u0026\u0026 (\"Array\".equals(n.getString()) || \"Object\".equals(n.getString()))) {\n+                    JSType parameterType \u003d createFromTypeNodes(typeList.getLastChild(), sourceName, scope);\n+                    namedType \u003d new ParameterizedType(this, (ObjectType) namedType, parameterType);\n+                    if (typeList.hasMoreThanOneChild()) {\n+                        JSType indexType \u003d createFromTypeNodes(typeList.getFirstChild(), sourceName, scope);\n+                        namedType \u003d new IndexedType(this, (ObjectType) namedType, indexType);\n+                    }\n+                }\n+                return createDefaultObjectUnion(namedType);\n+            } else {\n+                return namedType;\n+            }\n+        case Token.FUNCTION:\n+            ObjectType thisType \u003d null;\n+            Node current \u003d n.getFirstChild();\n+            if (current.getType() \u003d\u003d Token.THIS) {\n+                Node thisNode \u003d current.getFirstChild();\n+                thisType \u003d ObjectType.cast(createFromTypeNodes(thisNode, sourceName, scope).restrictByNotNullOrUndefined());\n+                if (thisType \u003d\u003d null) {\n+                    reporter.warning(ScriptRuntime.getMessage0(\"msg.jsdoc.function.thisnotobject\"), sourceName, thisNode.getLineno(), \"\", thisNode.getCharno());\n+                }\n+                current \u003d current.getNext();\n+            }\n+            FunctionParamBuilder paramBuilder \u003d new FunctionParamBuilder(this);\n+            if (current.getType() \u003d\u003d Token.LP) {\n+                Node args \u003d current.getFirstChild();\n+                for (Node arg \u003d current.getFirstChild(); arg !\u003d null; arg \u003d arg.getNext()) {\n+                    if (arg.getType() \u003d\u003d Token.ELLIPSIS) {\n+                        if (arg.getChildCount() \u003d\u003d 0) {\n+                            paramBuilder.addVarArgs(getNativeType(UNKNOWN_TYPE));\n+                        } else {\n+                            paramBuilder.addVarArgs(createFromTypeNodes(arg.getFirstChild(), sourceName, scope));\n+                        }\n+                    } else {\n+                        JSType type \u003d createFromTypeNodes(arg, sourceName, scope);\n+                        if (arg.getType() \u003d\u003d Token.EQUALS) {\n+                            boolean addSuccess \u003d paramBuilder.addOptionalParams(type);\n+                            if (!addSuccess) {\n+                                reporter.warning(ScriptRuntime.getMessage0(\"msg.jsdoc.function.varargs\"), sourceName, arg.getLineno(), \"\", arg.getCharno());\n+                            }\n+                        } else {\n+                            paramBuilder.addRequiredParams(type);\n+                        }\n+                    }\n+                }\n+                current \u003d current.getNext();\n+            }\n+            JSType returnType \u003d createFromTypeNodes(current, sourceName, scope);\n+            return new FunctionBuilder(this).withParams(paramBuilder).withReturnType(returnType).withTypeOfThis(thisType).build();\n+    }\n+    throw new IllegalStateException(\"Unexpected node in type expression: \" + n.toString());\n+}\n\\ No newline at end of file\n",
      "actualSource": "public JSType createFromTypeNodes(Node n, String sourceName, StaticScope\u003cJSType\u003e scope, boolean forgiving) {\n    if (resolveMode \u003d\u003d ResolveMode.LAZY_EXPRESSIONS) {\n        return new UnresolvedTypeExpression(this, n, sourceName, forgiving);\n    }\n    switch(n.getType()) {\n        case Token.LC:\n            return createRecordTypeFromNodes(n.getFirstChild(), sourceName, scope);\n        case Token.BANG:\n            return createFromTypeNodes(n.getFirstChild(), sourceName, scope, forgiving).restrictByNotNullOrUndefined();\n        case Token.QMARK:\n            Node firstChild \u003d n.getFirstChild();\n            if (firstChild \u003d\u003d null) {\n                return getNativeType(UNKNOWN_TYPE);\n            }\n            return createDefaultObjectUnion(createFromTypeNodes(firstChild, sourceName, scope, forgiving));\n        case Token.EQUALS:\n            return createOptionalType(createFromTypeNodes(n.getFirstChild(), sourceName, scope));\n        case Token.ELLIPSIS:\n            return createOptionalType(createFromTypeNodes(n.getFirstChild(), sourceName, scope));\n        case Token.STAR:\n            return getNativeType(ALL_TYPE);\n        case Token.LB:\n            return getNativeType(ARRAY_TYPE);\n        case Token.PIPE:\n            UnionTypeBuilder builder \u003d new UnionTypeBuilder(this);\n            for (Node child \u003d n.getFirstChild(); child !\u003d null; child \u003d child.getNext()) {\n                builder.addAlternate(createFromTypeNodes(child, sourceName, scope));\n            }\n            return builder.build();\n        case Token.EMPTY:\n            return getNativeType(UNKNOWN_TYPE);\n        case Token.VOID:\n            return getNativeType(VOID_TYPE);\n        case Token.STRING:\n            JSType namedType \u003d getType(scope, n.getString(), sourceName, n.getLineno(), n.getCharno());\n            if (forgiving) {\n                namedType.forgiveUnknownNames();\n            }\n            if (resolveMode !\u003d ResolveMode.LAZY_NAMES) {\n                namedType \u003d namedType.resolveInternal(reporter, scope);\n            }\n            if ((namedType instanceof ObjectType) \u0026\u0026 !(enumTypeNames.contains(n.getString()))) {\n                Node typeList \u003d n.getFirstChild();\n                if (typeList !\u003d null \u0026\u0026 (\"Array\".equals(n.getString()) || \"Object\".equals(n.getString()))) {\n                    JSType parameterType \u003d createFromTypeNodes(typeList.getLastChild(), sourceName, scope);\n                    namedType \u003d new ParameterizedType(this, (ObjectType) namedType, parameterType);\n                    if (typeList.hasMoreThanOneChild()) {\n                        JSType indexType \u003d createFromTypeNodes(typeList.getFirstChild(), sourceName, scope);\n                        namedType \u003d new IndexedType(this, (ObjectType) namedType, indexType);\n                    }\n                }\n                return createDefaultObjectUnion(namedType);\n            } else {\n                return namedType;\n            }\n        case Token.FUNCTION:\n            ObjectType thisType \u003d null;\n            Node current \u003d n.getFirstChild();\n            if (current.getType() \u003d\u003d Token.THIS) {\n                Node thisNode \u003d current.getFirstChild();\n                thisType \u003d ObjectType.cast(createFromTypeNodes(thisNode, sourceName, scope).restrictByNotNullOrUndefined());\n                if (thisType \u003d\u003d null) {\n                    reporter.warning(ScriptRuntime.getMessage0(\"msg.jsdoc.function.thisnotobject\"), sourceName, thisNode.getLineno(), \"\", thisNode.getCharno());\n                }\n                current \u003d current.getNext();\n            }\n            FunctionParamBuilder paramBuilder \u003d new FunctionParamBuilder(this);\n            if (current.getType() \u003d\u003d Token.LP) {\n                Node args \u003d current.getFirstChild();\n                for (Node arg \u003d current.getFirstChild(); arg !\u003d null; arg \u003d arg.getNext()) {\n                    if (arg.getType() \u003d\u003d Token.ELLIPSIS) {\n                        if (arg.getChildCount() \u003d\u003d 0) {\n                            paramBuilder.addVarArgs(getNativeType(UNKNOWN_TYPE));\n                        } else {\n                            paramBuilder.addVarArgs(createFromTypeNodes(arg.getFirstChild(), sourceName, scope));\n                        }\n                    } else {\n                        JSType type \u003d createFromTypeNodes(arg, sourceName, scope);\n                        if (arg.getType() \u003d\u003d Token.EQUALS) {\n                            boolean addSuccess \u003d paramBuilder.addOptionalParams(type);\n                            if (!addSuccess) {\n                                reporter.warning(ScriptRuntime.getMessage0(\"msg.jsdoc.function.varargs\"), sourceName, arg.getLineno(), \"\", arg.getCharno());\n                            }\n                        } else {\n                            paramBuilder.addRequiredParams(type);\n                        }\n                    }\n                }\n                current \u003d current.getNext();\n            }\n            JSType returnType \u003d createFromTypeNodes(current, sourceName, scope);\n            return new FunctionBuilder(this).withParams(paramBuilder).withReturnType(returnType).withTypeOfThis(thisType).build();\n    }\n    throw new IllegalStateException(\"Unexpected node in type expression: \" + n.toString());\n}",
      "path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
      "functionStartLine": 1314,
      "functionName": "createFromTypeNodes",
      "functionAnnotation": "",
      "functionDoc": "Creates a JSType from the nodes representing a type.\n\n@param n The node with type info.\n@param sourceName The source file name.\n@param scope A scope for doing type name lookups.\n@param forgiving Whether we should be forgiving about type names\n    that we can\u0027t find.\n"
    }
  }
}