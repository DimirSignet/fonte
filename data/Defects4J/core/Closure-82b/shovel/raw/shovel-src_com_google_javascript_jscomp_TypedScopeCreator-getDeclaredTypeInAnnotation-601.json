{
  "origin": "codeshovel",
  "repositoryName": "Closure-82b",
  "repositoryPath": "/tmp/Closure-82b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "TypedScopeCreator.java",
  "functionName": "getDeclaredTypeInAnnotation",
  "functionId": "$getDeclaredTypeInAnnotation___sourceName-String__node-Node__info-JSDocInfo",
  "sourceFilePath": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
  "functionAnnotation": "",
  "functionDoc": "",
  "functionStartLine": 601,
  "functionEndLine": 618,
  "numCommitsSeen": 42,
  "timeTaken": 3091,
  "changeHistory": [
    "7675b68dbd7cfc37b1359fd40be9fdf0b618bc95",
    "2ea78e73e6ace693e18d535560606dfd49c3f9bc",
    "f3d83b7eb7b1e4afbb24ae57e1a57adadbcead42",
    "c764a46abf211d4677fadc33f7d466e5b14fa088",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3"
  ],
  "changeHistoryShort": {
    "7675b68dbd7cfc37b1359fd40be9fdf0b618bc95": "Ymodifierchange",
    "2ea78e73e6ace693e18d535560606dfd49c3f9bc": "Ybodychange",
    "f3d83b7eb7b1e4afbb24ae57e1a57adadbcead42": "Ybodychange",
    "c764a46abf211d4677fadc33f7d466e5b14fa088": "Ybodychange",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "7675b68dbd7cfc37b1359fd40be9fdf0b618bc95": {
      "type": "Ymodifierchange",
      "commitMessage": "\nfix a todo that\u0027s really easy now\n\nR\u003djohnlenz\nDELTA\u003d67  (28 added, 12 deleted, 27 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d417\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@743 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "2/1/11, 11:22 AM",
      "commitName": "7675b68dbd7cfc37b1359fd40be9fdf0b618bc95",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "1/31/11, 8:08 AM",
      "commitNameOld": "2ea78e73e6ace693e18d535560606dfd49c3f9bc",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 1.13,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "private JSType getDeclaredTypeInAnnotation(String sourceName, Node node, JSDocInfo info) {\n    JSType jsType \u003d null;\n    Node objNode \u003d node.getType() \u003d\u003d Token.GETPROP ? node.getFirstChild() : NodeUtil.isObjectLitKey(node, node.getParent()) ? node.getParent() : null;\n    if (info !\u003d null) {\n        if (info.hasType()) {\n            jsType \u003d info.getType().evaluate(scope, typeRegistry);\n        } else if (FunctionTypeBuilder.isFunctionTypeDeclaration(info)) {\n            String fnName \u003d node.getQualifiedName();\n            jsType \u003d createFunctionTypeFromNodes(null, fnName, info, node);\n        }\n    }\n    return jsType;\n}",
      "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
      "functionStartLine": 601,
      "functionName": "getDeclaredTypeInAnnotation",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,13 +1,13 @@\n-JSType getDeclaredTypeInAnnotation(String sourceName, Node node, JSDocInfo info) {\n+private JSType getDeclaredTypeInAnnotation(String sourceName, Node node, JSDocInfo info) {\n     JSType jsType \u003d null;\n     Node objNode \u003d node.getType() \u003d\u003d Token.GETPROP ? node.getFirstChild() : NodeUtil.isObjectLitKey(node, node.getParent()) ? node.getParent() : null;\n     if (info !\u003d null) {\n         if (info.hasType()) {\n             jsType \u003d info.getType().evaluate(scope, typeRegistry);\n         } else if (FunctionTypeBuilder.isFunctionTypeDeclaration(info)) {\n             String fnName \u003d node.getQualifiedName();\n             jsType \u003d createFunctionTypeFromNodes(null, fnName, info, node);\n         }\n     }\n     return jsType;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[]",
        "newValue": "[private]"
      }
    },
    "2ea78e73e6ace693e18d535560606dfd49c3f9bc": {
      "type": "Ybodychange",
      "commitMessage": "\nClean up type discovery by refactoring to the following algorithm.\n1) When we see a function literal, create the authoritative\ntype for it.\n2) When we see an object literal, create the authoritative\ntype for it.\n3) When we declare a symbol, check to see if it\u0027s assigned to\nan object or function literal, and use that type if it\nmake sense to do so. Otherwise, fall back on the JSDoc info.\nThis should make it a lot easier to give accurate types to object\nliteral properties.\nI didn\u0027t intend to create any functional changes in this CL,\nbut some minor ones were inevitable.\n\nR\u003djohnlenz\nDELTA\u003d618  (320 added, 249 deleted, 49 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d392\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@739 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "1/31/11, 8:08 AM",
      "commitName": "2ea78e73e6ace693e18d535560606dfd49c3f9bc",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "1/27/11, 10:33 AM",
      "commitNameOld": "70f817ae4f80ac11dd2dfe97babf5896c690fb48",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 3.9,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "JSType getDeclaredTypeInAnnotation(String sourceName, Node node, JSDocInfo info) {\n    JSType jsType \u003d null;\n    Node objNode \u003d node.getType() \u003d\u003d Token.GETPROP ? node.getFirstChild() : NodeUtil.isObjectLitKey(node, node.getParent()) ? node.getParent() : null;\n    if (info !\u003d null) {\n        if (info.hasType()) {\n            jsType \u003d info.getType().evaluate(scope, typeRegistry);\n        } else if (FunctionTypeBuilder.isFunctionTypeDeclaration(info)) {\n            String fnName \u003d node.getQualifiedName();\n            jsType \u003d createFunctionTypeFromNodes(null, fnName, info, node);\n        }\n    }\n    return jsType;\n}",
      "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
      "functionStartLine": 601,
      "functionName": "getDeclaredTypeInAnnotation",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,30 +1,13 @@\n JSType getDeclaredTypeInAnnotation(String sourceName, Node node, JSDocInfo info) {\n     JSType jsType \u003d null;\n     Node objNode \u003d node.getType() \u003d\u003d Token.GETPROP ? node.getFirstChild() : NodeUtil.isObjectLitKey(node, node.getParent()) ? node.getParent() : null;\n     if (info !\u003d null) {\n         if (info.hasType()) {\n             jsType \u003d info.getType().evaluate(scope, typeRegistry);\n         } else if (FunctionTypeBuilder.isFunctionTypeDeclaration(info)) {\n             String fnName \u003d node.getQualifiedName();\n-            if (info.isConstructor() \u0026\u0026 typeRegistry.getType(fnName) !\u003d null) {\n-                return null;\n-            }\n-            FunctionTypeBuilder builder \u003d new FunctionTypeBuilder(fnName, compiler, node, sourceName, scope).inferTemplateTypeName(info).inferReturnType(info).inferParameterTypes(info).inferInheritance(info);\n-            boolean searchedForThisType \u003d false;\n-            if (objNode !\u003d null) {\n-                if (objNode.getType() \u003d\u003d Token.GETPROP \u0026\u0026 objNode.getLastChild().getString().equals(\"prototype\")) {\n-                    builder.inferThisType(info, objNode.getFirstChild());\n-                    searchedForThisType \u003d true;\n-                } else if (objNode.getType() \u003d\u003d Token.THIS) {\n-                    builder.inferThisType(info, objNode.getJSType());\n-                    searchedForThisType \u003d true;\n-                }\n-            }\n-            if (!searchedForThisType) {\n-                builder.inferThisType(info, (Node) null);\n-            }\n-            jsType \u003d builder.buildAndRegister();\n+            jsType \u003d createFunctionTypeFromNodes(null, fnName, info, node);\n         }\n     }\n     return jsType;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f3d83b7eb7b1e4afbb24ae57e1a57adadbcead42": {
      "type": "Ybodychange",
      "commitMessage": "\nRudimentary handling of declared properties of object literals.\n\nR\u003djohnlenz\nDELTA\u003d101  (95 added, 0 deleted, 6 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d331\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@725 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "1/21/11, 10:57 AM",
      "commitName": "f3d83b7eb7b1e4afbb24ae57e1a57adadbcead42",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "1/7/11, 9:19 AM",
      "commitNameOld": "6bbac115c9a7928a7053b2da3a78df9569df8570",
      "commitAuthorOld": "bashir@google.com",
      "daysBetweenCommits": 14.07,
      "commitsBetweenForRepo": 45,
      "commitsBetweenForFile": 1,
      "actualSource": "JSType getDeclaredTypeInAnnotation(String sourceName, Node node, JSDocInfo info) {\n    JSType jsType \u003d null;\n    Node objNode \u003d node.getType() \u003d\u003d Token.GETPROP ? node.getFirstChild() : NodeUtil.isObjectLitKey(node, node.getParent()) ? node.getParent() : null;\n    if (info !\u003d null) {\n        if (info.hasType()) {\n            jsType \u003d info.getType().evaluate(scope, typeRegistry);\n        } else if (FunctionTypeBuilder.isFunctionTypeDeclaration(info)) {\n            String fnName \u003d node.getQualifiedName();\n            if (info.isConstructor() \u0026\u0026 typeRegistry.getType(fnName) !\u003d null) {\n                return null;\n            }\n            FunctionTypeBuilder builder \u003d new FunctionTypeBuilder(fnName, compiler, node, sourceName, scope).inferTemplateTypeName(info).inferReturnType(info).inferParameterTypes(info).inferInheritance(info);\n            boolean searchedForThisType \u003d false;\n            if (objNode !\u003d null) {\n                if (objNode.getType() \u003d\u003d Token.GETPROP \u0026\u0026 objNode.getLastChild().getString().equals(\"prototype\")) {\n                    builder.inferThisType(info, objNode.getFirstChild());\n                    searchedForThisType \u003d true;\n                } else if (objNode.getType() \u003d\u003d Token.THIS) {\n                    builder.inferThisType(info, objNode.getJSType());\n                    searchedForThisType \u003d true;\n                }\n            }\n            if (!searchedForThisType) {\n                builder.inferThisType(info, (Node) null);\n            }\n            jsType \u003d builder.buildAndRegister();\n        }\n    }\n    return jsType;\n}",
      "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
      "functionStartLine": 591,
      "functionName": "getDeclaredTypeInAnnotation",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,30 +1,30 @@\n JSType getDeclaredTypeInAnnotation(String sourceName, Node node, JSDocInfo info) {\n     JSType jsType \u003d null;\n-    Node objNode \u003d node.getType() \u003d\u003d Token.GETPROP ? node.getFirstChild() : null;\n+    Node objNode \u003d node.getType() \u003d\u003d Token.GETPROP ? node.getFirstChild() : NodeUtil.isObjectLitKey(node, node.getParent()) ? node.getParent() : null;\n     if (info !\u003d null) {\n         if (info.hasType()) {\n             jsType \u003d info.getType().evaluate(scope, typeRegistry);\n         } else if (FunctionTypeBuilder.isFunctionTypeDeclaration(info)) {\n             String fnName \u003d node.getQualifiedName();\n             if (info.isConstructor() \u0026\u0026 typeRegistry.getType(fnName) !\u003d null) {\n                 return null;\n             }\n             FunctionTypeBuilder builder \u003d new FunctionTypeBuilder(fnName, compiler, node, sourceName, scope).inferTemplateTypeName(info).inferReturnType(info).inferParameterTypes(info).inferInheritance(info);\n             boolean searchedForThisType \u003d false;\n             if (objNode !\u003d null) {\n                 if (objNode.getType() \u003d\u003d Token.GETPROP \u0026\u0026 objNode.getLastChild().getString().equals(\"prototype\")) {\n                     builder.inferThisType(info, objNode.getFirstChild());\n                     searchedForThisType \u003d true;\n                 } else if (objNode.getType() \u003d\u003d Token.THIS) {\n                     builder.inferThisType(info, objNode.getJSType());\n                     searchedForThisType \u003d true;\n                 }\n             }\n             if (!searchedForThisType) {\n                 builder.inferThisType(info, (Node) null);\n             }\n             jsType \u003d builder.buildAndRegister();\n         }\n     }\n     return jsType;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c764a46abf211d4677fadc33f7d466e5b14fa088": {
      "type": "Ybodychange",
      "commitMessage": "\nChange on 2010/04/13 by john\n\n        Here is a crazy thought, let\u0027s not require the JSTypeRegistry during\n        parsing.\n\n        There are basically two changes here:\n        1) The IRFactory was looking for enums to seed the JSTypeRegistry, so\n        we do that when we setup for type interence.\n        2) The JSDocParser was checking the types of @defines objects, now do\n        that during ProcessDefines.\n\n        R\u003drobert,mark\n        DELTA\u003d207  (82 added, 89 deleted, 36 changed)\n\nChange on 2010/04/14 by nick\n\n        Add a debugging function for JSType hashcodes.\n        i found this useful, and thought others might too.\n\n        R\u003djohn\n        DELTA\u003d69  (69 added, 0 deleted, 0 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003dfqsoxx\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@183 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/14/10, 9:15 AM",
      "commitName": "c764a46abf211d4677fadc33f7d466e5b14fa088",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "4/13/10, 2:39 PM",
      "commitNameOld": "de13c3313c05f4449c50c560324389d6905a214d",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 0.78,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "JSType getDeclaredTypeInAnnotation(String sourceName, Node node, JSDocInfo info) {\n    JSType jsType \u003d null;\n    Node objNode \u003d node.getType() \u003d\u003d Token.GETPROP ? node.getFirstChild() : null;\n    if (info !\u003d null) {\n        if (info.hasType()) {\n            jsType \u003d info.getType().evaluate(scope, typeRegistry);\n        } else if (FunctionTypeBuilder.isFunctionTypeDeclaration(info)) {\n            String fnName \u003d node.getQualifiedName();\n            if (info.isConstructor() \u0026\u0026 typeRegistry.getType(fnName) !\u003d null) {\n                return null;\n            }\n            FunctionTypeBuilder builder \u003d new FunctionTypeBuilder(fnName, compiler, node, sourceName, scope).inferTemplateTypeName(info).inferReturnType(info).inferParameterTypes(info).inferInheritance(info);\n            boolean searchedForThisType \u003d false;\n            if (objNode !\u003d null) {\n                if (objNode.getType() \u003d\u003d Token.GETPROP \u0026\u0026 objNode.getLastChild().getString().equals(\"prototype\")) {\n                    builder.inferThisType(info, objNode.getFirstChild());\n                    searchedForThisType \u003d true;\n                } else if (objNode.getType() \u003d\u003d Token.THIS) {\n                    builder.inferThisType(info, objNode.getJSType());\n                    searchedForThisType \u003d true;\n                }\n            }\n            if (!searchedForThisType) {\n                builder.inferThisType(info, (Node) null);\n            }\n            jsType \u003d builder.buildAndRegister();\n        }\n    }\n    return jsType;\n}",
      "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
      "functionStartLine": 312,
      "functionName": "getDeclaredTypeInAnnotation",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,30 +1,30 @@\n JSType getDeclaredTypeInAnnotation(String sourceName, Node node, JSDocInfo info) {\n     JSType jsType \u003d null;\n     Node objNode \u003d node.getType() \u003d\u003d Token.GETPROP ? node.getFirstChild() : null;\n     if (info !\u003d null) {\n         if (info.hasType()) {\n-            jsType \u003d info.getType().evaluate(scope);\n+            jsType \u003d info.getType().evaluate(scope, typeRegistry);\n         } else if (FunctionTypeBuilder.isFunctionTypeDeclaration(info)) {\n             String fnName \u003d node.getQualifiedName();\n             if (info.isConstructor() \u0026\u0026 typeRegistry.getType(fnName) !\u003d null) {\n                 return null;\n             }\n             FunctionTypeBuilder builder \u003d new FunctionTypeBuilder(fnName, compiler, node, sourceName, scope).inferTemplateTypeName(info).inferReturnType(info).inferParameterTypes(info).inferInheritance(info);\n             boolean searchedForThisType \u003d false;\n             if (objNode !\u003d null) {\n                 if (objNode.getType() \u003d\u003d Token.GETPROP \u0026\u0026 objNode.getLastChild().getString().equals(\"prototype\")) {\n                     builder.inferThisType(info, objNode.getFirstChild());\n                     searchedForThisType \u003d true;\n                 } else if (objNode.getType() \u003d\u003d Token.THIS) {\n                     builder.inferThisType(info, objNode.getJSType());\n                     searchedForThisType \u003d true;\n                 }\n             }\n             if (!searchedForThisType) {\n                 builder.inferThisType(info, (Node) null);\n             }\n             jsType \u003d builder.buildAndRegister();\n         }\n     }\n     return jsType;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": {
      "type": "Yintroduced",
      "commitMessage": "Initial commit.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/3/09, 3:51 PM",
      "commitName": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "diff": "@@ -0,0 +1,30 @@\n+JSType getDeclaredTypeInAnnotation(String sourceName, Node node, JSDocInfo info) {\n+    JSType jsType \u003d null;\n+    Node objNode \u003d node.getType() \u003d\u003d Token.GETPROP ? node.getFirstChild() : null;\n+    if (info !\u003d null) {\n+        if (info.hasType()) {\n+            jsType \u003d info.getType().evaluate(scope);\n+        } else if (FunctionTypeBuilder.isFunctionTypeDeclaration(info)) {\n+            String fnName \u003d node.getQualifiedName();\n+            if (info.isConstructor() \u0026\u0026 typeRegistry.getType(fnName) !\u003d null) {\n+                return null;\n+            }\n+            FunctionTypeBuilder builder \u003d new FunctionTypeBuilder(fnName, compiler, node, sourceName, scope).inferTemplateTypeName(info).inferReturnType(info).inferParameterTypes(info).inferInheritance(info);\n+            boolean searchedForThisType \u003d false;\n+            if (objNode !\u003d null) {\n+                if (objNode.getType() \u003d\u003d Token.GETPROP \u0026\u0026 objNode.getLastChild().getString().equals(\"prototype\")) {\n+                    builder.inferThisType(info, objNode.getFirstChild());\n+                    searchedForThisType \u003d true;\n+                } else if (objNode.getType() \u003d\u003d Token.THIS) {\n+                    builder.inferThisType(info, objNode.getJSType());\n+                    searchedForThisType \u003d true;\n+                }\n+            }\n+            if (!searchedForThisType) {\n+                builder.inferThisType(info, (Node) null);\n+            }\n+            jsType \u003d builder.buildAndRegister();\n+        }\n+    }\n+    return jsType;\n+}\n\\ No newline at end of file\n",
      "actualSource": "JSType getDeclaredTypeInAnnotation(String sourceName, Node node, JSDocInfo info) {\n    JSType jsType \u003d null;\n    Node objNode \u003d node.getType() \u003d\u003d Token.GETPROP ? node.getFirstChild() : null;\n    if (info !\u003d null) {\n        if (info.hasType()) {\n            jsType \u003d info.getType().evaluate(scope);\n        } else if (FunctionTypeBuilder.isFunctionTypeDeclaration(info)) {\n            String fnName \u003d node.getQualifiedName();\n            if (info.isConstructor() \u0026\u0026 typeRegistry.getType(fnName) !\u003d null) {\n                return null;\n            }\n            FunctionTypeBuilder builder \u003d new FunctionTypeBuilder(fnName, compiler, node, sourceName, scope).inferTemplateTypeName(info).inferReturnType(info).inferParameterTypes(info).inferInheritance(info);\n            boolean searchedForThisType \u003d false;\n            if (objNode !\u003d null) {\n                if (objNode.getType() \u003d\u003d Token.GETPROP \u0026\u0026 objNode.getLastChild().getString().equals(\"prototype\")) {\n                    builder.inferThisType(info, objNode.getFirstChild());\n                    searchedForThisType \u003d true;\n                } else if (objNode.getType() \u003d\u003d Token.THIS) {\n                    builder.inferThisType(info, objNode.getJSType());\n                    searchedForThisType \u003d true;\n                }\n            }\n            if (!searchedForThisType) {\n                builder.inferThisType(info, (Node) null);\n            }\n            jsType \u003d builder.buildAndRegister();\n        }\n    }\n    return jsType;\n}",
      "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
      "functionStartLine": 274,
      "functionName": "getDeclaredTypeInAnnotation",
      "functionAnnotation": "",
      "functionDoc": ""
    }
  }
}