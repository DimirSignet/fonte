{
  "origin": "codeshovel",
  "repositoryName": "Closure-82b",
  "repositoryPath": "/tmp/Closure-82b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "TypeInference.java",
  "functionName": "branchedFlowThrough",
  "functionId": "branchedFlowThrough___source-Node__input-FlowScope",
  "sourceFilePath": "src/com/google/javascript/jscomp/TypeInference.java",
  "functionAnnotation": "@Override,@SuppressWarnings(\"fallthrough\")",
  "functionDoc": "",
  "functionStartLine": 194,
  "functionEndLine": 304,
  "numCommitsSeen": 42,
  "timeTaken": 2755,
  "changeHistory": [
    "f1a08e4f38ace8c387085a7e7e2f52adaa9d88ca",
    "9afca869d4236594514b8461d771af9999c8a989",
    "3bee5d740c96572faea4b9fb8b632e0e07b13cbb",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3"
  ],
  "changeHistoryShort": {
    "f1a08e4f38ace8c387085a7e7e2f52adaa9d88ca": "Ybodychange",
    "9afca869d4236594514b8461d771af9999c8a989": "Ybodychange",
    "3bee5d740c96572faea4b9fb8b632e0e07b13cbb": "Ybodychange",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "f1a08e4f38ace8c387085a7e7e2f52adaa9d88ca": {
      "type": "Ybodychange",
      "commitMessage": "\ntype inference on the object part of a for..in\n\nR\u003djohnlenz\nDELTA\u003d80  (76 added, 0 deleted, 4 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d147\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@639 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "12/15/10, 2:37 PM",
      "commitName": "f1a08e4f38ace8c387085a7e7e2f52adaa9d88ca",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "12/6/10, 2:55 PM",
      "commitNameOld": "b02b646a75d6dd26f41fe6d987841ed01c8ec161",
      "commitAuthorOld": "mgoodman@google.com",
      "daysBetweenCommits": 8.99,
      "commitsBetweenForRepo": 37,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\n@SuppressWarnings(\"fallthrough\")\nList\u003cFlowScope\u003e branchedFlowThrough(Node source, FlowScope input) {\n    FlowScope output \u003d flowThrough(source, input);\n    Node condition \u003d null;\n    FlowScope conditionFlowScope \u003d null;\n    BooleanOutcomePair conditionOutcomes \u003d null;\n    List\u003cDiGraphEdge\u003cNode, Branch\u003e\u003e branchEdges \u003d getCfg().getOutEdges(source);\n    List\u003cFlowScope\u003e result \u003d Lists.newArrayListWithCapacity(branchEdges.size());\n    for (DiGraphEdge\u003cNode, Branch\u003e branchEdge : branchEdges) {\n        Branch branch \u003d branchEdge.getValue();\n        FlowScope newScope \u003d output;\n        switch(branch) {\n            case ON_TRUE:\n                if (NodeUtil.isForIn(source)) {\n                    Node item \u003d source.getFirstChild();\n                    Node obj \u003d item.getNext();\n                    FlowScope informed \u003d traverse(obj, output.createChildFlowScope());\n                    if (item.getType() \u003d\u003d Token.VAR) {\n                        item \u003d item.getFirstChild();\n                    }\n                    if (item.getType() \u003d\u003d Token.NAME) {\n                        JSType iterKeyType \u003d getNativeType(STRING_TYPE);\n                        ObjectType objType \u003d getJSType(obj).dereference();\n                        JSType objIndexType \u003d objType \u003d\u003d null ? null : objType.getIndexType();\n                        if (objIndexType !\u003d null \u0026\u0026 !objIndexType.isUnknownType()) {\n                            JSType narrowedKeyType \u003d iterKeyType.getGreatestSubtype(objIndexType);\n                            if (!narrowedKeyType.isEmptyType()) {\n                                iterKeyType \u003d narrowedKeyType;\n                            }\n                        }\n                        redeclare(informed, item.getString(), iterKeyType);\n                    }\n                    newScope \u003d informed;\n                    break;\n                }\n            case ON_FALSE:\n                if (condition \u003d\u003d null) {\n                    condition \u003d NodeUtil.getConditionExpression(source);\n                    if (condition \u003d\u003d null \u0026\u0026 source.getType() \u003d\u003d Token.CASE) {\n                        condition \u003d source;\n                        if (conditionFlowScope \u003d\u003d null) {\n                            conditionFlowScope \u003d traverse(condition.getFirstChild(), output.createChildFlowScope());\n                        }\n                    }\n                }\n                if (condition !\u003d null) {\n                    if (condition.getType() \u003d\u003d Token.AND || condition.getType() \u003d\u003d Token.OR) {\n                        if (conditionOutcomes \u003d\u003d null) {\n                            conditionOutcomes \u003d condition.getType() \u003d\u003d Token.AND ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());\n                        }\n                        newScope \u003d reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch \u003d\u003d Branch.ON_TRUE), branch \u003d\u003d Branch.ON_TRUE);\n                    } else {\n                        if (conditionFlowScope \u003d\u003d null) {\n                            conditionFlowScope \u003d traverse(condition, output.createChildFlowScope());\n                        }\n                        newScope \u003d reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch \u003d\u003d Branch.ON_TRUE);\n                    }\n                }\n                break;\n        }\n        result.add(newScope.optimize());\n    }\n    return result;\n}",
      "path": "src/com/google/javascript/jscomp/TypeInference.java",
      "functionStartLine": 194,
      "functionName": "branchedFlowThrough",
      "functionAnnotation": "@Override,@SuppressWarnings(\"fallthrough\")",
      "functionDoc": "",
      "diff": "@@ -1,55 +1,65 @@\n @Override\n @SuppressWarnings(\"fallthrough\")\n List\u003cFlowScope\u003e branchedFlowThrough(Node source, FlowScope input) {\n     FlowScope output \u003d flowThrough(source, input);\n     Node condition \u003d null;\n     FlowScope conditionFlowScope \u003d null;\n     BooleanOutcomePair conditionOutcomes \u003d null;\n     List\u003cDiGraphEdge\u003cNode, Branch\u003e\u003e branchEdges \u003d getCfg().getOutEdges(source);\n     List\u003cFlowScope\u003e result \u003d Lists.newArrayListWithCapacity(branchEdges.size());\n     for (DiGraphEdge\u003cNode, Branch\u003e branchEdge : branchEdges) {\n         Branch branch \u003d branchEdge.getValue();\n         FlowScope newScope \u003d output;\n         switch(branch) {\n             case ON_TRUE:\n                 if (NodeUtil.isForIn(source)) {\n                     Node item \u003d source.getFirstChild();\n+                    Node obj \u003d item.getNext();\n+                    FlowScope informed \u003d traverse(obj, output.createChildFlowScope());\n                     if (item.getType() \u003d\u003d Token.VAR) {\n                         item \u003d item.getFirstChild();\n                     }\n                     if (item.getType() \u003d\u003d Token.NAME) {\n-                        FlowScope informed \u003d output.createChildFlowScope();\n-                        redeclare(informed, item.getString(), getNativeType(STRING_TYPE));\n-                        newScope \u003d informed;\n+                        JSType iterKeyType \u003d getNativeType(STRING_TYPE);\n+                        ObjectType objType \u003d getJSType(obj).dereference();\n+                        JSType objIndexType \u003d objType \u003d\u003d null ? null : objType.getIndexType();\n+                        if (objIndexType !\u003d null \u0026\u0026 !objIndexType.isUnknownType()) {\n+                            JSType narrowedKeyType \u003d iterKeyType.getGreatestSubtype(objIndexType);\n+                            if (!narrowedKeyType.isEmptyType()) {\n+                                iterKeyType \u003d narrowedKeyType;\n+                            }\n+                        }\n+                        redeclare(informed, item.getString(), iterKeyType);\n                     }\n+                    newScope \u003d informed;\n                     break;\n                 }\n             case ON_FALSE:\n                 if (condition \u003d\u003d null) {\n                     condition \u003d NodeUtil.getConditionExpression(source);\n                     if (condition \u003d\u003d null \u0026\u0026 source.getType() \u003d\u003d Token.CASE) {\n                         condition \u003d source;\n                         if (conditionFlowScope \u003d\u003d null) {\n                             conditionFlowScope \u003d traverse(condition.getFirstChild(), output.createChildFlowScope());\n                         }\n                     }\n                 }\n                 if (condition !\u003d null) {\n                     if (condition.getType() \u003d\u003d Token.AND || condition.getType() \u003d\u003d Token.OR) {\n                         if (conditionOutcomes \u003d\u003d null) {\n                             conditionOutcomes \u003d condition.getType() \u003d\u003d Token.AND ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());\n                         }\n                         newScope \u003d reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch \u003d\u003d Branch.ON_TRUE), branch \u003d\u003d Branch.ON_TRUE);\n                     } else {\n                         if (conditionFlowScope \u003d\u003d null) {\n                             conditionFlowScope \u003d traverse(condition, output.createChildFlowScope());\n                         }\n                         newScope \u003d reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch \u003d\u003d Branch.ON_TRUE);\n                     }\n                 }\n                 break;\n         }\n         result.add(newScope.optimize());\n     }\n     return result;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9afca869d4236594514b8461d771af9999c8a989": {
      "type": "Ybodychange",
      "commitMessage": "Better type checking for switch/case conditions.\n\nCustomizable input delimiters.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@75 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "1/22/10, 12:29 PM",
      "commitName": "9afca869d4236594514b8461d771af9999c8a989",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "1/4/10, 12:18 PM",
      "commitNameOld": "77b7c78d4aeeb6471f2f668a06c0f61a68f95ccd",
      "commitAuthorOld": "nicholas.j.santos@gmail.com",
      "daysBetweenCommits": 18.01,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\n@SuppressWarnings(\"fallthrough\")\nList\u003cFlowScope\u003e branchedFlowThrough(Node source, FlowScope input) {\n    FlowScope output \u003d flowThrough(source, input);\n    Node condition \u003d null;\n    FlowScope conditionFlowScope \u003d null;\n    BooleanOutcomePair conditionOutcomes \u003d null;\n    List\u003cDiGraphEdge\u003cNode, Branch\u003e\u003e branchEdges \u003d getCfg().getOutEdges(source);\n    List\u003cFlowScope\u003e result \u003d Lists.newArrayListWithCapacity(branchEdges.size());\n    for (DiGraphEdge\u003cNode, Branch\u003e branchEdge : branchEdges) {\n        Branch branch \u003d branchEdge.getValue();\n        FlowScope newScope \u003d output;\n        switch(branch) {\n            case ON_TRUE:\n                if (NodeUtil.isForIn(source)) {\n                    Node item \u003d source.getFirstChild();\n                    if (item.getType() \u003d\u003d Token.VAR) {\n                        item \u003d item.getFirstChild();\n                    }\n                    if (item.getType() \u003d\u003d Token.NAME) {\n                        FlowScope informed \u003d output.createChildFlowScope();\n                        redeclare(informed, item.getString(), getNativeType(STRING_TYPE));\n                        newScope \u003d informed;\n                    }\n                    break;\n                }\n            case ON_FALSE:\n                if (condition \u003d\u003d null) {\n                    condition \u003d NodeUtil.getConditionExpression(source);\n                    if (condition \u003d\u003d null \u0026\u0026 source.getType() \u003d\u003d Token.CASE) {\n                        condition \u003d source;\n                        if (conditionFlowScope \u003d\u003d null) {\n                            conditionFlowScope \u003d traverse(condition.getFirstChild(), output.createChildFlowScope());\n                        }\n                    }\n                }\n                if (condition !\u003d null) {\n                    if (condition.getType() \u003d\u003d Token.AND || condition.getType() \u003d\u003d Token.OR) {\n                        if (conditionOutcomes \u003d\u003d null) {\n                            conditionOutcomes \u003d condition.getType() \u003d\u003d Token.AND ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());\n                        }\n                        newScope \u003d reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch \u003d\u003d Branch.ON_TRUE), branch \u003d\u003d Branch.ON_TRUE);\n                    } else {\n                        if (conditionFlowScope \u003d\u003d null) {\n                            conditionFlowScope \u003d traverse(condition, output.createChildFlowScope());\n                        }\n                        newScope \u003d reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch \u003d\u003d Branch.ON_TRUE);\n                    }\n                }\n                break;\n        }\n        result.add(newScope.optimize());\n    }\n    return result;\n}",
      "path": "src/com/google/javascript/jscomp/TypeInference.java",
      "functionStartLine": 133,
      "functionName": "branchedFlowThrough",
      "functionAnnotation": "@Override,@SuppressWarnings(\"fallthrough\")",
      "functionDoc": "",
      "diff": "@@ -1,52 +1,55 @@\n @Override\n @SuppressWarnings(\"fallthrough\")\n List\u003cFlowScope\u003e branchedFlowThrough(Node source, FlowScope input) {\n     FlowScope output \u003d flowThrough(source, input);\n     Node condition \u003d null;\n     FlowScope conditionFlowScope \u003d null;\n     BooleanOutcomePair conditionOutcomes \u003d null;\n     List\u003cDiGraphEdge\u003cNode, Branch\u003e\u003e branchEdges \u003d getCfg().getOutEdges(source);\n     List\u003cFlowScope\u003e result \u003d Lists.newArrayListWithCapacity(branchEdges.size());\n     for (DiGraphEdge\u003cNode, Branch\u003e branchEdge : branchEdges) {\n         Branch branch \u003d branchEdge.getValue();\n         FlowScope newScope \u003d output;\n         switch(branch) {\n             case ON_TRUE:\n                 if (NodeUtil.isForIn(source)) {\n                     Node item \u003d source.getFirstChild();\n                     if (item.getType() \u003d\u003d Token.VAR) {\n                         item \u003d item.getFirstChild();\n                     }\n                     if (item.getType() \u003d\u003d Token.NAME) {\n                         FlowScope informed \u003d output.createChildFlowScope();\n                         redeclare(informed, item.getString(), getNativeType(STRING_TYPE));\n                         newScope \u003d informed;\n                     }\n                     break;\n                 }\n             case ON_FALSE:\n                 if (condition \u003d\u003d null) {\n                     condition \u003d NodeUtil.getConditionExpression(source);\n                     if (condition \u003d\u003d null \u0026\u0026 source.getType() \u003d\u003d Token.CASE) {\n-                        condition \u003d createSwitchCaseConditionExpression(source);\n+                        condition \u003d source;\n+                        if (conditionFlowScope \u003d\u003d null) {\n+                            conditionFlowScope \u003d traverse(condition.getFirstChild(), output.createChildFlowScope());\n+                        }\n                     }\n                 }\n                 if (condition !\u003d null) {\n                     if (condition.getType() \u003d\u003d Token.AND || condition.getType() \u003d\u003d Token.OR) {\n                         if (conditionOutcomes \u003d\u003d null) {\n                             conditionOutcomes \u003d condition.getType() \u003d\u003d Token.AND ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());\n                         }\n                         newScope \u003d reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch \u003d\u003d Branch.ON_TRUE), branch \u003d\u003d Branch.ON_TRUE);\n                     } else {\n                         if (conditionFlowScope \u003d\u003d null) {\n                             conditionFlowScope \u003d traverse(condition, output.createChildFlowScope());\n                         }\n                         newScope \u003d reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch \u003d\u003d Branch.ON_TRUE);\n                     }\n                 }\n                 break;\n         }\n         result.add(newScope.optimize());\n     }\n     return result;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3bee5d740c96572faea4b9fb8b632e0e07b13cbb": {
      "type": "Ybodychange",
      "commitMessage": "Add a mechanism for inlining local vars, and turn it on by default.\nWarnings for \"ambiguous\" function definitions.\nRefactoring and renaming of some method names.\nUse \"\u003d\" optionality annotation in externs.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@15 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/25/09, 6:53 AM",
      "commitName": "3bee5d740c96572faea4b9fb8b632e0e07b13cbb",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "commitDateOld": "11/3/09, 3:51 PM",
      "commitNameOld": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthorOld": "nicholas.j.santos@gmail.com",
      "daysBetweenCommits": 21.63,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\n@SuppressWarnings(\"fallthrough\")\nList\u003cFlowScope\u003e branchedFlowThrough(Node source, FlowScope input) {\n    FlowScope output \u003d flowThrough(source, input);\n    Node condition \u003d null;\n    FlowScope conditionFlowScope \u003d null;\n    BooleanOutcomePair conditionOutcomes \u003d null;\n    List\u003cDiGraphEdge\u003cNode, Branch\u003e\u003e branchEdges \u003d getCfg().getOutEdges(source);\n    List\u003cFlowScope\u003e result \u003d Lists.newArrayListWithCapacity(branchEdges.size());\n    for (DiGraphEdge\u003cNode, Branch\u003e branchEdge : branchEdges) {\n        Branch branch \u003d branchEdge.getValue();\n        FlowScope newScope \u003d output;\n        switch(branch) {\n            case ON_TRUE:\n                if (NodeUtil.isForIn(source)) {\n                    Node item \u003d source.getFirstChild();\n                    if (item.getType() \u003d\u003d Token.VAR) {\n                        item \u003d item.getFirstChild();\n                    }\n                    if (item.getType() \u003d\u003d Token.NAME) {\n                        FlowScope informed \u003d output.createChildFlowScope();\n                        redeclare(informed, item.getString(), getNativeType(STRING_TYPE));\n                        newScope \u003d informed;\n                    }\n                    break;\n                }\n            case ON_FALSE:\n                if (condition \u003d\u003d null) {\n                    condition \u003d NodeUtil.getConditionExpression(source);\n                    if (condition \u003d\u003d null \u0026\u0026 source.getType() \u003d\u003d Token.CASE) {\n                        condition \u003d createSwitchCaseConditionExpression(source);\n                    }\n                }\n                if (condition !\u003d null) {\n                    if (condition.getType() \u003d\u003d Token.AND || condition.getType() \u003d\u003d Token.OR) {\n                        if (conditionOutcomes \u003d\u003d null) {\n                            conditionOutcomes \u003d condition.getType() \u003d\u003d Token.AND ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());\n                        }\n                        newScope \u003d reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch \u003d\u003d Branch.ON_TRUE), branch \u003d\u003d Branch.ON_TRUE);\n                    } else {\n                        if (conditionFlowScope \u003d\u003d null) {\n                            conditionFlowScope \u003d traverse(condition, output.createChildFlowScope());\n                        }\n                        newScope \u003d reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch \u003d\u003d Branch.ON_TRUE);\n                    }\n                }\n                break;\n        }\n        result.add(newScope.optimize());\n    }\n    return result;\n}",
      "path": "src/com/google/javascript/jscomp/TypeInference.java",
      "functionStartLine": 133,
      "functionName": "branchedFlowThrough",
      "functionAnnotation": "@Override,@SuppressWarnings(\"fallthrough\")",
      "functionDoc": "",
      "diff": "@@ -1,52 +1,52 @@\n @Override\n @SuppressWarnings(\"fallthrough\")\n List\u003cFlowScope\u003e branchedFlowThrough(Node source, FlowScope input) {\n     FlowScope output \u003d flowThrough(source, input);\n     Node condition \u003d null;\n     FlowScope conditionFlowScope \u003d null;\n     BooleanOutcomePair conditionOutcomes \u003d null;\n     List\u003cDiGraphEdge\u003cNode, Branch\u003e\u003e branchEdges \u003d getCfg().getOutEdges(source);\n     List\u003cFlowScope\u003e result \u003d Lists.newArrayListWithCapacity(branchEdges.size());\n     for (DiGraphEdge\u003cNode, Branch\u003e branchEdge : branchEdges) {\n         Branch branch \u003d branchEdge.getValue();\n         FlowScope newScope \u003d output;\n         switch(branch) {\n             case ON_TRUE:\n-                if (source.getType() \u003d\u003d Token.FOR \u0026\u0026 source.getChildCount() \u003d\u003d 3) {\n+                if (NodeUtil.isForIn(source)) {\n                     Node item \u003d source.getFirstChild();\n                     if (item.getType() \u003d\u003d Token.VAR) {\n                         item \u003d item.getFirstChild();\n                     }\n                     if (item.getType() \u003d\u003d Token.NAME) {\n                         FlowScope informed \u003d output.createChildFlowScope();\n                         redeclare(informed, item.getString(), getNativeType(STRING_TYPE));\n                         newScope \u003d informed;\n                     }\n                     break;\n                 }\n             case ON_FALSE:\n                 if (condition \u003d\u003d null) {\n                     condition \u003d NodeUtil.getConditionExpression(source);\n                     if (condition \u003d\u003d null \u0026\u0026 source.getType() \u003d\u003d Token.CASE) {\n                         condition \u003d createSwitchCaseConditionExpression(source);\n                     }\n                 }\n                 if (condition !\u003d null) {\n                     if (condition.getType() \u003d\u003d Token.AND || condition.getType() \u003d\u003d Token.OR) {\n                         if (conditionOutcomes \u003d\u003d null) {\n                             conditionOutcomes \u003d condition.getType() \u003d\u003d Token.AND ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());\n                         }\n                         newScope \u003d reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch \u003d\u003d Branch.ON_TRUE), branch \u003d\u003d Branch.ON_TRUE);\n                     } else {\n                         if (conditionFlowScope \u003d\u003d null) {\n                             conditionFlowScope \u003d traverse(condition, output.createChildFlowScope());\n                         }\n                         newScope \u003d reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch \u003d\u003d Branch.ON_TRUE);\n                     }\n                 }\n                 break;\n         }\n         result.add(newScope.optimize());\n     }\n     return result;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": {
      "type": "Yintroduced",
      "commitMessage": "Initial commit.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/3/09, 3:51 PM",
      "commitName": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "diff": "@@ -0,0 +1,52 @@\n+@Override\n+@SuppressWarnings(\"fallthrough\")\n+List\u003cFlowScope\u003e branchedFlowThrough(Node source, FlowScope input) {\n+    FlowScope output \u003d flowThrough(source, input);\n+    Node condition \u003d null;\n+    FlowScope conditionFlowScope \u003d null;\n+    BooleanOutcomePair conditionOutcomes \u003d null;\n+    List\u003cDiGraphEdge\u003cNode, Branch\u003e\u003e branchEdges \u003d getCfg().getOutEdges(source);\n+    List\u003cFlowScope\u003e result \u003d Lists.newArrayListWithCapacity(branchEdges.size());\n+    for (DiGraphEdge\u003cNode, Branch\u003e branchEdge : branchEdges) {\n+        Branch branch \u003d branchEdge.getValue();\n+        FlowScope newScope \u003d output;\n+        switch(branch) {\n+            case ON_TRUE:\n+                if (source.getType() \u003d\u003d Token.FOR \u0026\u0026 source.getChildCount() \u003d\u003d 3) {\n+                    Node item \u003d source.getFirstChild();\n+                    if (item.getType() \u003d\u003d Token.VAR) {\n+                        item \u003d item.getFirstChild();\n+                    }\n+                    if (item.getType() \u003d\u003d Token.NAME) {\n+                        FlowScope informed \u003d output.createChildFlowScope();\n+                        redeclare(informed, item.getString(), getNativeType(STRING_TYPE));\n+                        newScope \u003d informed;\n+                    }\n+                    break;\n+                }\n+            case ON_FALSE:\n+                if (condition \u003d\u003d null) {\n+                    condition \u003d NodeUtil.getConditionExpression(source);\n+                    if (condition \u003d\u003d null \u0026\u0026 source.getType() \u003d\u003d Token.CASE) {\n+                        condition \u003d createSwitchCaseConditionExpression(source);\n+                    }\n+                }\n+                if (condition !\u003d null) {\n+                    if (condition.getType() \u003d\u003d Token.AND || condition.getType() \u003d\u003d Token.OR) {\n+                        if (conditionOutcomes \u003d\u003d null) {\n+                            conditionOutcomes \u003d condition.getType() \u003d\u003d Token.AND ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());\n+                        }\n+                        newScope \u003d reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch \u003d\u003d Branch.ON_TRUE), branch \u003d\u003d Branch.ON_TRUE);\n+                    } else {\n+                        if (conditionFlowScope \u003d\u003d null) {\n+                            conditionFlowScope \u003d traverse(condition, output.createChildFlowScope());\n+                        }\n+                        newScope \u003d reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch \u003d\u003d Branch.ON_TRUE);\n+                    }\n+                }\n+                break;\n+        }\n+        result.add(newScope.optimize());\n+    }\n+    return result;\n+}\n\\ No newline at end of file\n",
      "actualSource": "@Override\n@SuppressWarnings(\"fallthrough\")\nList\u003cFlowScope\u003e branchedFlowThrough(Node source, FlowScope input) {\n    FlowScope output \u003d flowThrough(source, input);\n    Node condition \u003d null;\n    FlowScope conditionFlowScope \u003d null;\n    BooleanOutcomePair conditionOutcomes \u003d null;\n    List\u003cDiGraphEdge\u003cNode, Branch\u003e\u003e branchEdges \u003d getCfg().getOutEdges(source);\n    List\u003cFlowScope\u003e result \u003d Lists.newArrayListWithCapacity(branchEdges.size());\n    for (DiGraphEdge\u003cNode, Branch\u003e branchEdge : branchEdges) {\n        Branch branch \u003d branchEdge.getValue();\n        FlowScope newScope \u003d output;\n        switch(branch) {\n            case ON_TRUE:\n                if (source.getType() \u003d\u003d Token.FOR \u0026\u0026 source.getChildCount() \u003d\u003d 3) {\n                    Node item \u003d source.getFirstChild();\n                    if (item.getType() \u003d\u003d Token.VAR) {\n                        item \u003d item.getFirstChild();\n                    }\n                    if (item.getType() \u003d\u003d Token.NAME) {\n                        FlowScope informed \u003d output.createChildFlowScope();\n                        redeclare(informed, item.getString(), getNativeType(STRING_TYPE));\n                        newScope \u003d informed;\n                    }\n                    break;\n                }\n            case ON_FALSE:\n                if (condition \u003d\u003d null) {\n                    condition \u003d NodeUtil.getConditionExpression(source);\n                    if (condition \u003d\u003d null \u0026\u0026 source.getType() \u003d\u003d Token.CASE) {\n                        condition \u003d createSwitchCaseConditionExpression(source);\n                    }\n                }\n                if (condition !\u003d null) {\n                    if (condition.getType() \u003d\u003d Token.AND || condition.getType() \u003d\u003d Token.OR) {\n                        if (conditionOutcomes \u003d\u003d null) {\n                            conditionOutcomes \u003d condition.getType() \u003d\u003d Token.AND ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());\n                        }\n                        newScope \u003d reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch \u003d\u003d Branch.ON_TRUE), branch \u003d\u003d Branch.ON_TRUE);\n                    } else {\n                        if (conditionFlowScope \u003d\u003d null) {\n                            conditionFlowScope \u003d traverse(condition, output.createChildFlowScope());\n                        }\n                        newScope \u003d reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch \u003d\u003d Branch.ON_TRUE);\n                    }\n                }\n                break;\n        }\n        result.add(newScope.optimize());\n    }\n    return result;\n}",
      "path": "src/com/google/javascript/jscomp/TypeInference.java",
      "functionStartLine": 133,
      "functionName": "branchedFlowThrough",
      "functionAnnotation": "@Override,@SuppressWarnings(\"fallthrough\")",
      "functionDoc": ""
    }
  }
}