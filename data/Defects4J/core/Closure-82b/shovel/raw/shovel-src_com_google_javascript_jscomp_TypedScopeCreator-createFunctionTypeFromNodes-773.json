{
  "origin": "codeshovel",
  "repositoryName": "Closure-82b",
  "repositoryPath": "/tmp/Closure-82b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "TypedScopeCreator.java",
  "functionName": "createFunctionTypeFromNodes",
  "functionId": "$createFunctionTypeFromNodes___rValue-Node(annotations-@Nullable)__name-String(annotations-@Nullable)__info-JSDocInfo(annotations-@Nullable)__lvalueNode-Node(annotations-@Nullable)",
  "sourceFilePath": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
  "functionAnnotation": "",
  "functionDoc": "Creates a new function type, based on the given nodes.\n\nThis handles two cases that are semantically very different, but\nare not mutually exclusive:\n- A function literal that needs a type attached to it.\n- An assignment expression with function-type info in the jsdoc.\n\nAll parameters are optional, and we will do the best we can to create\na function type.\n\nThis function will always create a function type, so only call it if\nyou\u0027re sure that\u0027s what you want.\n\n@param rValue The function node.\n@param name the function\u0027s name\n@param info the {@link JSDocInfo} attached to the function definition\n@param lvalueNode The node where this function is being\n    assigned. For example, {@code A.prototype.foo \u003d ...} would be used to\n    determine that this function is a method of A.prototype. May be\n    null to indicate that this is not being assigned to a qualified name.\n",
  "functionStartLine": 773,
  "functionEndLine": 871,
  "numCommitsSeen": 42,
  "timeTaken": 1867,
  "changeHistory": [
    "2ea78e73e6ace693e18d535560606dfd49c3f9bc"
  ],
  "changeHistoryShort": {
    "2ea78e73e6ace693e18d535560606dfd49c3f9bc": "Yintroduced"
  },
  "changeHistoryDetails": {
    "2ea78e73e6ace693e18d535560606dfd49c3f9bc": {
      "type": "Yintroduced",
      "commitMessage": "\nClean up type discovery by refactoring to the following algorithm.\n1) When we see a function literal, create the authoritative\ntype for it.\n2) When we see an object literal, create the authoritative\ntype for it.\n3) When we declare a symbol, check to see if it\u0027s assigned to\nan object or function literal, and use that type if it\nmake sense to do so. Otherwise, fall back on the JSDoc info.\nThis should make it a lot easier to give accurate types to object\nliteral properties.\nI didn\u0027t intend to create any functional changes in this CL,\nbut some minor ones were inevitable.\n\nR\u003djohnlenz\nDELTA\u003d618  (320 added, 249 deleted, 49 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d392\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@739 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "1/31/11, 8:08 AM",
      "commitName": "2ea78e73e6ace693e18d535560606dfd49c3f9bc",
      "commitAuthor": "nicksantos@google.com",
      "diff": "@@ -0,0 +1,60 @@\n+private FunctionType createFunctionTypeFromNodes(@Nullable Node rValue, @Nullable String name, @Nullable JSDocInfo info, @Nullable Node lvalueNode) {\n+    FunctionType functionType \u003d null;\n+    if (rValue !\u003d null \u0026\u0026 rValue.isQualifiedName() \u0026\u0026 scope.isGlobal()) {\n+        Var var \u003d scope.getVar(rValue.getQualifiedName());\n+        if (var !\u003d null \u0026\u0026 var.getType() instanceof FunctionType) {\n+            FunctionType aliasedType \u003d (FunctionType) var.getType();\n+            if ((aliasedType.isConstructor() || aliasedType.isInterface()) \u0026\u0026 !aliasedType.isNativeObjectType()) {\n+                functionType \u003d aliasedType;\n+                if (name !\u003d null \u0026\u0026 scope.isGlobal()) {\n+                    typeRegistry.declareType(name, functionType.getInstanceType());\n+                }\n+            }\n+        }\n+    }\n+    if (functionType \u003d\u003d null) {\n+        Node errorRoot \u003d rValue \u003d\u003d null ? lvalueNode : rValue;\n+        boolean isFnLiteral \u003d rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.FUNCTION;\n+        Node fnRoot \u003d isFnLiteral ? rValue : null;\n+        Node parametersNode \u003d isFnLiteral ? rValue.getFirstChild().getNext() : null;\n+        Node fnBlock \u003d isFnLiteral ? parametersNode.getNext() : null;\n+        if (info !\u003d null \u0026\u0026 info.hasType()) {\n+            JSType type \u003d info.getType().evaluate(scope, typeRegistry);\n+            type \u003d type.restrictByNotNullOrUndefined();\n+            if (type.isFunctionType()) {\n+                functionType \u003d (FunctionType) type;\n+                functionType.setJSDocInfo(info);\n+            }\n+        }\n+        if (functionType \u003d\u003d null) {\n+            FunctionType overriddenPropType \u003d null;\n+            if (lvalueNode !\u003d null \u0026\u0026 lvalueNode.getType() \u003d\u003d Token.GETPROP \u0026\u0026 lvalueNode.isQualifiedName()) {\n+                Var var \u003d scope.getVar(lvalueNode.getFirstChild().getQualifiedName());\n+                if (var !\u003d null) {\n+                    ObjectType ownerType \u003d ObjectType.cast(var.getType());\n+                    if (ownerType !\u003d null) {\n+                        String propName \u003d lvalueNode.getLastChild().getString();\n+                        overriddenPropType \u003d findOverriddenFunction(ownerType, propName);\n+                    }\n+                }\n+            }\n+            FunctionTypeBuilder builder \u003d new FunctionTypeBuilder(name, compiler, errorRoot, sourceName, scope).setSourceNode(fnRoot).inferFromOverriddenFunction(overriddenPropType, parametersNode).inferTemplateTypeName(info).inferReturnType(info).inferInheritance(info);\n+            boolean searchedForThisType \u003d false;\n+            if (lvalueNode !\u003d null \u0026\u0026 lvalueNode.getType() \u003d\u003d Token.GETPROP) {\n+                Node objNode \u003d lvalueNode.getFirstChild();\n+                if (objNode.getType() \u003d\u003d Token.GETPROP \u0026\u0026 objNode.getLastChild().getString().equals(\"prototype\")) {\n+                    builder.inferThisType(info, objNode.getFirstChild());\n+                    searchedForThisType \u003d true;\n+                } else if (objNode.getType() \u003d\u003d Token.THIS) {\n+                    builder.inferThisType(info, objNode.getJSType());\n+                    searchedForThisType \u003d true;\n+                }\n+            }\n+            if (!searchedForThisType) {\n+                builder.inferThisType(info, (Node) null);\n+            }\n+            functionType \u003d builder.inferParameterTypes(parametersNode, info).inferReturnStatementsAsLastResort(fnBlock).buildAndRegister();\n+        }\n+    }\n+    return functionType;\n+}\n\\ No newline at end of file\n",
      "actualSource": "private FunctionType createFunctionTypeFromNodes(@Nullable Node rValue, @Nullable String name, @Nullable JSDocInfo info, @Nullable Node lvalueNode) {\n    FunctionType functionType \u003d null;\n    if (rValue !\u003d null \u0026\u0026 rValue.isQualifiedName() \u0026\u0026 scope.isGlobal()) {\n        Var var \u003d scope.getVar(rValue.getQualifiedName());\n        if (var !\u003d null \u0026\u0026 var.getType() instanceof FunctionType) {\n            FunctionType aliasedType \u003d (FunctionType) var.getType();\n            if ((aliasedType.isConstructor() || aliasedType.isInterface()) \u0026\u0026 !aliasedType.isNativeObjectType()) {\n                functionType \u003d aliasedType;\n                if (name !\u003d null \u0026\u0026 scope.isGlobal()) {\n                    typeRegistry.declareType(name, functionType.getInstanceType());\n                }\n            }\n        }\n    }\n    if (functionType \u003d\u003d null) {\n        Node errorRoot \u003d rValue \u003d\u003d null ? lvalueNode : rValue;\n        boolean isFnLiteral \u003d rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.FUNCTION;\n        Node fnRoot \u003d isFnLiteral ? rValue : null;\n        Node parametersNode \u003d isFnLiteral ? rValue.getFirstChild().getNext() : null;\n        Node fnBlock \u003d isFnLiteral ? parametersNode.getNext() : null;\n        if (info !\u003d null \u0026\u0026 info.hasType()) {\n            JSType type \u003d info.getType().evaluate(scope, typeRegistry);\n            type \u003d type.restrictByNotNullOrUndefined();\n            if (type.isFunctionType()) {\n                functionType \u003d (FunctionType) type;\n                functionType.setJSDocInfo(info);\n            }\n        }\n        if (functionType \u003d\u003d null) {\n            FunctionType overriddenPropType \u003d null;\n            if (lvalueNode !\u003d null \u0026\u0026 lvalueNode.getType() \u003d\u003d Token.GETPROP \u0026\u0026 lvalueNode.isQualifiedName()) {\n                Var var \u003d scope.getVar(lvalueNode.getFirstChild().getQualifiedName());\n                if (var !\u003d null) {\n                    ObjectType ownerType \u003d ObjectType.cast(var.getType());\n                    if (ownerType !\u003d null) {\n                        String propName \u003d lvalueNode.getLastChild().getString();\n                        overriddenPropType \u003d findOverriddenFunction(ownerType, propName);\n                    }\n                }\n            }\n            FunctionTypeBuilder builder \u003d new FunctionTypeBuilder(name, compiler, errorRoot, sourceName, scope).setSourceNode(fnRoot).inferFromOverriddenFunction(overriddenPropType, parametersNode).inferTemplateTypeName(info).inferReturnType(info).inferInheritance(info);\n            boolean searchedForThisType \u003d false;\n            if (lvalueNode !\u003d null \u0026\u0026 lvalueNode.getType() \u003d\u003d Token.GETPROP) {\n                Node objNode \u003d lvalueNode.getFirstChild();\n                if (objNode.getType() \u003d\u003d Token.GETPROP \u0026\u0026 objNode.getLastChild().getString().equals(\"prototype\")) {\n                    builder.inferThisType(info, objNode.getFirstChild());\n                    searchedForThisType \u003d true;\n                } else if (objNode.getType() \u003d\u003d Token.THIS) {\n                    builder.inferThisType(info, objNode.getJSType());\n                    searchedForThisType \u003d true;\n                }\n            }\n            if (!searchedForThisType) {\n                builder.inferThisType(info, (Node) null);\n            }\n            functionType \u003d builder.inferParameterTypes(parametersNode, info).inferReturnStatementsAsLastResort(fnBlock).buildAndRegister();\n        }\n    }\n    return functionType;\n}",
      "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
      "functionStartLine": 761,
      "functionName": "createFunctionTypeFromNodes",
      "functionAnnotation": "",
      "functionDoc": "Creates a new function type, based on the given nodes.\n\nThis handles two cases that are semantically very different, but\nare not mutually exclusive:\n- A function literal that needs a type attached to it.\n- An assignment expression with function-type info in the jsdoc.\n\nAll parameters are optional, and we will do the best we can to create\na function type.\n\nThis function will always create a function type, so only call it if\nyou\u0027re sure that\u0027s what you want.\n\n@param rValue The function node.\n@param name the function\u0027s name\n@param info the {@link JSDocInfo} attached to the function definition\n@param lvalueNode The node where this function is being\n    assigned. For example, {@code A.prototype.foo \u003d ...} would be used to\n    determine that this function is a method of A.prototype. May be\n    null to indicate that this is not being assigned to a qualified name.\n"
    }
  }
}