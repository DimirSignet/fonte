{
  "origin": "codeshovel",
  "repositoryName": "Closure-82b",
  "repositoryPath": "/tmp/Closure-82b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "TypeCheck.java",
  "functionName": "ensureTyped",
  "functionId": "ensureTyped___t-NodeTraversal__n-Node__type-JSType",
  "sourceFilePath": "src/com/google/javascript/jscomp/TypeCheck.java",
  "functionAnnotation": "",
  "functionDoc": "Enforces type casts, and ensures the node is typed.\n\nA cast in the way that we use it in JSDoc annotations never\nalters the generated code and therefore never can induce any runtime\noperation. What this means is that a \u0027cast\u0027 is really just a compile\ntime constraint on the underlying value. In the future, we may add\nsupport for run-time casts for compiled tests.\n\nTo ensure some shred of sanity, we enforce the notion that the\ntype you are casting to may only meaningfully be a narrower type\nthan the underlying declared type. We also invalidate optimizations\non bad type casts.\n\n@param t The traversal object needed to report errors.\n@param n The node getting a type assigned to it.\n@param type The type to be assigned.\n",
  "functionStartLine": 1770,
  "functionEndLine": 1794,
  "numCommitsSeen": 32,
  "timeTaken": 2708,
  "changeHistory": [
    "c764a46abf211d4677fadc33f7d466e5b14fa088",
    "3cc8b3a5889f8b88ef7a2bd0b8ccea8cb0d916c4",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3"
  ],
  "changeHistoryShort": {
    "c764a46abf211d4677fadc33f7d466e5b14fa088": "Ybodychange",
    "3cc8b3a5889f8b88ef7a2bd0b8ccea8cb0d916c4": "Ybodychange",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "c764a46abf211d4677fadc33f7d466e5b14fa088": {
      "type": "Ybodychange",
      "commitMessage": "\nChange on 2010/04/13 by john\n\n        Here is a crazy thought, let\u0027s not require the JSTypeRegistry during\n        parsing.\n\n        There are basically two changes here:\n        1) The IRFactory was looking for enums to seed the JSTypeRegistry, so\n        we do that when we setup for type interence.\n        2) The JSDocParser was checking the types of @defines objects, now do\n        that during ProcessDefines.\n\n        R\u003drobert,mark\n        DELTA\u003d207  (82 added, 89 deleted, 36 changed)\n\nChange on 2010/04/14 by nick\n\n        Add a debugging function for JSType hashcodes.\n        i found this useful, and thought others might too.\n\n        R\u003djohn\n        DELTA\u003d69  (69 added, 0 deleted, 0 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003dfqsoxx\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@183 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/14/10, 9:15 AM",
      "commitName": "c764a46abf211d4677fadc33f7d466e5b14fa088",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "4/5/10, 12:30 PM",
      "commitNameOld": "222eafd303155b3eac5cd244584b2cb3c4c11975",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 8.86,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "actualSource": "private void ensureTyped(NodeTraversal t, Node n, JSType type) {\n    Preconditions.checkState(n.getType() !\u003d Token.FUNCTION || type instanceof FunctionType || type.isUnknownType());\n    JSDocInfo info \u003d n.getJSDocInfo();\n    if (info !\u003d null) {\n        if (info.hasType()) {\n            JSType infoType \u003d info.getType().evaluate(t.getScope(), typeRegistry);\n            validator.expectCanCast(t, n, infoType, type);\n            type \u003d infoType;\n        }\n        if (info.isImplicitCast() \u0026\u0026 !inExterns) {\n            String propName \u003d n.getType() \u003d\u003d Token.GETPROP ? n.getLastChild().getString() : \"(missing)\";\n            compiler.report(t.makeError(n, ILLEGAL_IMPLICIT_CAST, propName));\n        }\n    }\n    if (n.getJSType() \u003d\u003d null) {\n        n.setJSType(type);\n    }\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 1679,
      "functionName": "ensureTyped",
      "functionAnnotation": "",
      "functionDoc": "Enforces type casts, and ensures the node is typed.\n\nA cast in the way that we use it in JSDoc annotations never\nalters the generated code and therefore never can induce any runtime\noperation. What this means is that a \u0027cast\u0027 is really just a compile\ntime constraint on the underlying value. In the future, we may add\nsupport for run-time casts for compiled tests.\n\nTo ensure some shred of sanity, we enforce the notion that the\ntype you are casting to may only meaningfully be a narrower type\nthan the underlying declared type. We also invalidate optimizations\non bad type casts.\n\n@param t The traversal object needed to report errors.\n@param n The node getting a type assigned to it.\n@param type The type to be assigned.\n",
      "diff": "@@ -1,18 +1,18 @@\n private void ensureTyped(NodeTraversal t, Node n, JSType type) {\n     Preconditions.checkState(n.getType() !\u003d Token.FUNCTION || type instanceof FunctionType || type.isUnknownType());\n     JSDocInfo info \u003d n.getJSDocInfo();\n     if (info !\u003d null) {\n         if (info.hasType()) {\n-            JSType infoType \u003d info.getType().evaluate(t.getScope());\n+            JSType infoType \u003d info.getType().evaluate(t.getScope(), typeRegistry);\n             validator.expectCanCast(t, n, infoType, type);\n             type \u003d infoType;\n         }\n         if (info.isImplicitCast() \u0026\u0026 !inExterns) {\n             String propName \u003d n.getType() \u003d\u003d Token.GETPROP ? n.getLastChild().getString() : \"(missing)\";\n             compiler.report(t.makeError(n, ILLEGAL_IMPLICIT_CAST, propName));\n         }\n     }\n     if (n.getJSType() \u003d\u003d null) {\n         n.setJSType(type);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3cc8b3a5889f8b88ef7a2bd0b8ccea8cb0d916c4": {
      "type": "Ybodychange",
      "commitMessage": "Remove circular dependency between error-reporting and the rest\nof the compiler. (Nick)\nR\u003dalan\nDELTA\u003d152  (27 added, 28 deleted, 97 changed)\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@159 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "3/29/10, 7:04 AM",
      "commitName": "3cc8b3a5889f8b88ef7a2bd0b8ccea8cb0d916c4",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "3/11/10, 9:31 PM",
      "commitNameOld": "7bfdbd9164601af44d17edd51be829fde2cc51aa",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 17.36,
      "commitsBetweenForRepo": 25,
      "commitsBetweenForFile": 1,
      "actualSource": "private void ensureTyped(NodeTraversal t, Node n, JSType type) {\n    Preconditions.checkState(n.getType() !\u003d Token.FUNCTION || type instanceof FunctionType || type.isUnknownType());\n    JSDocInfo info \u003d n.getJSDocInfo();\n    if (info !\u003d null) {\n        if (info.hasType()) {\n            JSType infoType \u003d info.getType().evaluate(t.getScope());\n            validator.expectCanCast(t, n, infoType, type);\n            type \u003d infoType;\n        }\n        if (info.isImplicitCast() \u0026\u0026 !inExterns) {\n            String propName \u003d n.getType() \u003d\u003d Token.GETPROP ? n.getLastChild().getString() : \"(missing)\";\n            compiler.report(t.makeError(n, ILLEGAL_IMPLICIT_CAST, propName));\n        }\n    }\n    if (n.getJSType() \u003d\u003d null) {\n        n.setJSType(type);\n    }\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 1676,
      "functionName": "ensureTyped",
      "functionAnnotation": "",
      "functionDoc": "Enforces type casts, and ensures the node is typed.\n\nA cast in the way that we use it in JSDoc annotations never\nalters the generated code and therefore never can induce any runtime\noperation. What this means is that a \u0027cast\u0027 is really just a compile\ntime constraint on the underlying value. In the future, we may add\nsupport for run-time casts for compiled tests.\n\nTo ensure some shred of sanity, we enforce the notion that the\ntype you are casting to may only meaningfully be a narrower type\nthan the underlying declared type. We also invalidate optimizations\non bad type casts.\n\n@param t The traversal object needed to report errors.\n@param n The node getting a type assigned to it.\n@param type The type to be assigned.\n",
      "diff": "@@ -1,18 +1,18 @@\n private void ensureTyped(NodeTraversal t, Node n, JSType type) {\n     Preconditions.checkState(n.getType() !\u003d Token.FUNCTION || type instanceof FunctionType || type.isUnknownType());\n     JSDocInfo info \u003d n.getJSDocInfo();\n     if (info !\u003d null) {\n         if (info.hasType()) {\n             JSType infoType \u003d info.getType().evaluate(t.getScope());\n             validator.expectCanCast(t, n, infoType, type);\n             type \u003d infoType;\n         }\n         if (info.isImplicitCast() \u0026\u0026 !inExterns) {\n             String propName \u003d n.getType() \u003d\u003d Token.GETPROP ? n.getLastChild().getString() : \"(missing)\";\n-            compiler.report(JSError.make(t, n, ILLEGAL_IMPLICIT_CAST, propName));\n+            compiler.report(t.makeError(n, ILLEGAL_IMPLICIT_CAST, propName));\n         }\n     }\n     if (n.getJSType() \u003d\u003d null) {\n         n.setJSType(type);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": {
      "type": "Yintroduced",
      "commitMessage": "Initial commit.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/3/09, 3:51 PM",
      "commitName": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "diff": "@@ -0,0 +1,18 @@\n+private void ensureTyped(NodeTraversal t, Node n, JSType type) {\n+    Preconditions.checkState(n.getType() !\u003d Token.FUNCTION || type instanceof FunctionType || type.isUnknownType());\n+    JSDocInfo info \u003d n.getJSDocInfo();\n+    if (info !\u003d null) {\n+        if (info.hasType()) {\n+            JSType infoType \u003d info.getType().evaluate(t.getScope());\n+            validator.expectCanCast(t, n, infoType, type);\n+            type \u003d infoType;\n+        }\n+        if (info.isImplicitCast() \u0026\u0026 !inExterns) {\n+            String propName \u003d n.getType() \u003d\u003d Token.GETPROP ? n.getLastChild().getString() : \"(missing)\";\n+            compiler.report(JSError.make(t, n, ILLEGAL_IMPLICIT_CAST, propName));\n+        }\n+    }\n+    if (n.getJSType() \u003d\u003d null) {\n+        n.setJSType(type);\n+    }\n+}\n\\ No newline at end of file\n",
      "actualSource": "private void ensureTyped(NodeTraversal t, Node n, JSType type) {\n    Preconditions.checkState(n.getType() !\u003d Token.FUNCTION || type instanceof FunctionType || type.isUnknownType());\n    JSDocInfo info \u003d n.getJSDocInfo();\n    if (info !\u003d null) {\n        if (info.hasType()) {\n            JSType infoType \u003d info.getType().evaluate(t.getScope());\n            validator.expectCanCast(t, n, infoType, type);\n            type \u003d infoType;\n        }\n        if (info.isImplicitCast() \u0026\u0026 !inExterns) {\n            String propName \u003d n.getType() \u003d\u003d Token.GETPROP ? n.getLastChild().getString() : \"(missing)\";\n            compiler.report(JSError.make(t, n, ILLEGAL_IMPLICIT_CAST, propName));\n        }\n    }\n    if (n.getJSType() \u003d\u003d null) {\n        n.setJSType(type);\n    }\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 1645,
      "functionName": "ensureTyped",
      "functionAnnotation": "",
      "functionDoc": "Enforces type casts, and ensures the node is typed.\n\nA cast in the way that we use it in JSDoc annotations never\nalters the generated code and therefore never can induce any runtime\noperation. What this means is that a \u0027cast\u0027 is really just a compile\ntime constraint on the underlying value. In the future, we may add\nsupport for run-time casts for compiled tests.\n\nTo ensure some shred of sanity, we enforce the notion that the\ntype you are casting to may only meaningfully be a narrower type\nthan the underlying declared type. We also invalidate optimizations\non bad type casts.\n\n@param t The traversal object needed to report errors.\n@param n The node getting a type assigned to it.\n@param type The type to be assigned.\n"
    }
  }
}