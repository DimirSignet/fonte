{
  "origin": "codeshovel",
  "repositoryName": "Closure-113b",
  "repositoryPath": "/tmp/Closure-113b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ProcessClosurePrimitives.java",
  "functionName": "visit",
  "functionId": "visit___t-NodeTraversal__n-Node__parent-Node",
  "sourceFilePath": "src/com/google/javascript/jscomp/ProcessClosurePrimitives.java",
  "functionAnnotation": "@Override",
  "functionDoc": "",
  "functionStartLine": 202,
  "functionEndLine": 290,
  "numCommitsSeen": 62,
  "timeTaken": 4500,
  "changeHistory": [
    "cf8d2a915893d370e3f883c185dec7ef3b3015e8",
    "f0ff2971eca336e950929b3ee0d80155338bb1dd",
    "f9fbad23b8fb59464e395c164197750abb5db296",
    "70a5626922ea7e8c98747e22b6986638ba38fadc",
    "9dfbc803407e714f9744555a1c9e7c4230f1816d",
    "39f629a8cfaab37da55288010640d7e516000b1f",
    "ec324a9bb23eb78c76f537f4c4170ba88d542f1c",
    "97ccd2e190cffc9a656e2ae58bf03372f644f6df",
    "2b8ec0e5d81f5e765020faa3a74712eed54db311",
    "f136b358d247b27f2cb1b266d65c72f7c5af7bad",
    "ebb59a97610015bc41bda7f458dd1428a3a3e335",
    "5da32cba7b68d69acfc535f57f21d652475d256f",
    "3cc8b3a5889f8b88ef7a2bd0b8ccea8cb0d916c4",
    "45f2bdf91ad3c2f2ac901c72efe9e26148b08d2b",
    "1046b0c09e2371f8924f72331d42db5b554c4a32",
    "6a6ea480bae01f40f9795218ac911bb7de18d34a",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3"
  ],
  "changeHistoryShort": {
    "cf8d2a915893d370e3f883c185dec7ef3b3015e8": "Ybodychange",
    "f0ff2971eca336e950929b3ee0d80155338bb1dd": "Ybodychange",
    "f9fbad23b8fb59464e395c164197750abb5db296": "Ybodychange",
    "70a5626922ea7e8c98747e22b6986638ba38fadc": "Ybodychange",
    "9dfbc803407e714f9744555a1c9e7c4230f1816d": "Ybodychange",
    "39f629a8cfaab37da55288010640d7e516000b1f": "Ybodychange",
    "ec324a9bb23eb78c76f537f4c4170ba88d542f1c": "Ybodychange",
    "97ccd2e190cffc9a656e2ae58bf03372f644f6df": "Ybodychange",
    "2b8ec0e5d81f5e765020faa3a74712eed54db311": "Ybodychange",
    "f136b358d247b27f2cb1b266d65c72f7c5af7bad": "Ybodychange",
    "ebb59a97610015bc41bda7f458dd1428a3a3e335": "Ybodychange",
    "5da32cba7b68d69acfc535f57f21d652475d256f": "Ymultichange(Yannotationchange,Ydocchange)",
    "3cc8b3a5889f8b88ef7a2bd0b8ccea8cb0d916c4": "Ybodychange",
    "45f2bdf91ad3c2f2ac901c72efe9e26148b08d2b": "Ybodychange",
    "1046b0c09e2371f8924f72331d42db5b554c4a32": "Ybodychange",
    "6a6ea480bae01f40f9795218ac911bb7de18d34a": "Ybodychange",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "cf8d2a915893d370e3f883c185dec7ef3b3015e8": {
      "type": "Ybodychange",
      "commitMessage": "Add compiler support for goog.define\n-------------\nCreated by MOE: http://code.google.com/p/moe-java\nMOE_MIGRATED_REVID\u003d43915701\n",
      "commitDate": "3/14/13, 1:18 PM",
      "commitName": "cf8d2a915893d370e3f883c185dec7ef3b3015e8",
      "commitAuthor": "Ben Lickly",
      "commitDateOld": "2/12/13, 1:04 PM",
      "commitNameOld": "e24d72c26b2e2f1c9bbe8cd3e1d641a3cce46543",
      "commitAuthorOld": "Nick Santos",
      "daysBetweenCommits": 29.97,
      "commitsBetweenForRepo": 77,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.CALL:\n            boolean isExpr \u003d parent.isExprResult();\n            Node left \u003d n.getFirstChild();\n            if (left.isGetProp()) {\n                Node name \u003d left.getFirstChild();\n                if (name.isName() \u0026\u0026 GOOG.equals(name.getString())) {\n                    String methodName \u003d name.getNext().getString();\n                    if (\"base\".equals(methodName)) {\n                        processBaseClassCall(t, n);\n                    } else if (!isExpr) {\n                        break;\n                    } else if (\"define\".equals(methodName)) {\n                        processDefineCall(t, n, parent);\n                    } else if (\"require\".equals(methodName)) {\n                        processRequireCall(t, n, parent);\n                    } else if (\"provide\".equals(methodName)) {\n                        processProvideCall(t, n, parent);\n                    } else if (\"exportSymbol\".equals(methodName)) {\n                        Node arg \u003d left.getNext();\n                        if (arg.isString()) {\n                            int dot \u003d arg.getString().indexOf(\u0027.\u0027);\n                            if (dot \u003d\u003d -1) {\n                                exportedVariables.add(arg.getString());\n                            } else {\n                                exportedVariables.add(arg.getString().substring(0, dot));\n                            }\n                        }\n                    } else if (\"addDependency\".equals(methodName)) {\n                        CodingConvention convention \u003d compiler.getCodingConvention();\n                        List\u003cString\u003e typeDecls \u003d convention.identifyTypeDeclarationCall(n);\n                        if (typeDecls !\u003d null) {\n                            for (String typeDecl : typeDecls) {\n                                compiler.getTypeRegistry().forwardDeclareType(typeDecl);\n                            }\n                        }\n                        parent.replaceChild(n, IR.number(0));\n                        compiler.reportCodeChange();\n                    } else if (\"setCssNameMapping\".equals(methodName)) {\n                        processSetCssNameMapping(t, n, parent);\n                    }\n                }\n            }\n            break;\n        case Token.ASSIGN:\n        case Token.NAME:\n            handleCandidateProvideDefinition(t, n, parent);\n            break;\n        case Token.EXPR_RESULT:\n            handleTypedefDefinition(t, n);\n            break;\n        case Token.FUNCTION:\n            if (t.inGlobalScope() \u0026\u0026 !NodeUtil.isFunctionExpression(n)) {\n                String name \u003d n.getFirstChild().getString();\n                ProvidedName pn \u003d providedNames.get(name);\n                if (pn !\u003d null) {\n                    compiler.report(t.makeError(n, FUNCTION_NAMESPACE_ERROR, name));\n                }\n            }\n            break;\n        case Token.GETPROP:\n            if (n.getFirstChild().isName() \u0026\u0026 !parent.isCall() \u0026\u0026 !parent.isAssign() \u0026\u0026 \"goog.base\".equals(n.getQualifiedName())) {\n                reportBadBaseClassUse(t, n, \"May only be called directly.\");\n            }\n            break;\n    }\n}",
      "path": "src/com/google/javascript/jscomp/ProcessClosurePrimitives.java",
      "functionStartLine": 202,
      "functionName": "visit",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,67 +1,69 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n     switch(n.getType()) {\n         case Token.CALL:\n             boolean isExpr \u003d parent.isExprResult();\n             Node left \u003d n.getFirstChild();\n             if (left.isGetProp()) {\n                 Node name \u003d left.getFirstChild();\n                 if (name.isName() \u0026\u0026 GOOG.equals(name.getString())) {\n                     String methodName \u003d name.getNext().getString();\n                     if (\"base\".equals(methodName)) {\n                         processBaseClassCall(t, n);\n                     } else if (!isExpr) {\n                         break;\n+                    } else if (\"define\".equals(methodName)) {\n+                        processDefineCall(t, n, parent);\n                     } else if (\"require\".equals(methodName)) {\n                         processRequireCall(t, n, parent);\n                     } else if (\"provide\".equals(methodName)) {\n                         processProvideCall(t, n, parent);\n                     } else if (\"exportSymbol\".equals(methodName)) {\n                         Node arg \u003d left.getNext();\n                         if (arg.isString()) {\n                             int dot \u003d arg.getString().indexOf(\u0027.\u0027);\n                             if (dot \u003d\u003d -1) {\n                                 exportedVariables.add(arg.getString());\n                             } else {\n                                 exportedVariables.add(arg.getString().substring(0, dot));\n                             }\n                         }\n                     } else if (\"addDependency\".equals(methodName)) {\n                         CodingConvention convention \u003d compiler.getCodingConvention();\n                         List\u003cString\u003e typeDecls \u003d convention.identifyTypeDeclarationCall(n);\n                         if (typeDecls !\u003d null) {\n                             for (String typeDecl : typeDecls) {\n                                 compiler.getTypeRegistry().forwardDeclareType(typeDecl);\n                             }\n                         }\n                         parent.replaceChild(n, IR.number(0));\n                         compiler.reportCodeChange();\n                     } else if (\"setCssNameMapping\".equals(methodName)) {\n                         processSetCssNameMapping(t, n, parent);\n                     }\n                 }\n             }\n             break;\n         case Token.ASSIGN:\n         case Token.NAME:\n             handleCandidateProvideDefinition(t, n, parent);\n             break;\n         case Token.EXPR_RESULT:\n             handleTypedefDefinition(t, n);\n             break;\n         case Token.FUNCTION:\n             if (t.inGlobalScope() \u0026\u0026 !NodeUtil.isFunctionExpression(n)) {\n                 String name \u003d n.getFirstChild().getString();\n                 ProvidedName pn \u003d providedNames.get(name);\n                 if (pn !\u003d null) {\n                     compiler.report(t.makeError(n, FUNCTION_NAMESPACE_ERROR, name));\n                 }\n             }\n             break;\n         case Token.GETPROP:\n             if (n.getFirstChild().isName() \u0026\u0026 !parent.isCall() \u0026\u0026 !parent.isAssign() \u0026\u0026 \"goog.base\".equals(n.getQualifiedName())) {\n                 reportBadBaseClassUse(t, n, \"May only be called directly.\");\n             }\n             break;\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f0ff2971eca336e950929b3ee0d80155338bb1dd": {
      "type": "Ybodychange",
      "commitMessage": "\nCruft removal: remove some unused locals and parameters.\n\nR\u003ddimvar\nDELTA\u003d336 (6 added, 108 deleted, 222 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d6092\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2447 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "1/8/13, 12:15 PM",
      "commitName": "f0ff2971eca336e950929b3ee0d80155338bb1dd",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "10/23/12, 9:55 AM",
      "commitNameOld": "2540311c64a343d4a9b41ae0244a8edb45339232",
      "commitAuthorOld": "dimvar@google.com",
      "daysBetweenCommits": 77.14,
      "commitsBetweenForRepo": 156,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.CALL:\n            boolean isExpr \u003d parent.isExprResult();\n            Node left \u003d n.getFirstChild();\n            if (left.isGetProp()) {\n                Node name \u003d left.getFirstChild();\n                if (name.isName() \u0026\u0026 GOOG.equals(name.getString())) {\n                    String methodName \u003d name.getNext().getString();\n                    if (\"base\".equals(methodName)) {\n                        processBaseClassCall(t, n);\n                    } else if (!isExpr) {\n                        break;\n                    } else if (\"require\".equals(methodName)) {\n                        processRequireCall(t, n, parent);\n                    } else if (\"provide\".equals(methodName)) {\n                        processProvideCall(t, n, parent);\n                    } else if (\"exportSymbol\".equals(methodName)) {\n                        Node arg \u003d left.getNext();\n                        if (arg.isString()) {\n                            int dot \u003d arg.getString().indexOf(\u0027.\u0027);\n                            if (dot \u003d\u003d -1) {\n                                exportedVariables.add(arg.getString());\n                            } else {\n                                exportedVariables.add(arg.getString().substring(0, dot));\n                            }\n                        }\n                    } else if (\"addDependency\".equals(methodName)) {\n                        CodingConvention convention \u003d compiler.getCodingConvention();\n                        List\u003cString\u003e typeDecls \u003d convention.identifyTypeDeclarationCall(n);\n                        if (typeDecls !\u003d null) {\n                            for (String typeDecl : typeDecls) {\n                                compiler.getTypeRegistry().forwardDeclareType(typeDecl);\n                            }\n                        }\n                        parent.replaceChild(n, IR.number(0));\n                        compiler.reportCodeChange();\n                    } else if (\"setCssNameMapping\".equals(methodName)) {\n                        processSetCssNameMapping(t, n, parent);\n                    }\n                }\n            }\n            break;\n        case Token.ASSIGN:\n        case Token.NAME:\n            handleCandidateProvideDefinition(t, n, parent);\n            break;\n        case Token.EXPR_RESULT:\n            handleTypedefDefinition(t, n);\n            break;\n        case Token.FUNCTION:\n            if (t.inGlobalScope() \u0026\u0026 !NodeUtil.isFunctionExpression(n)) {\n                String name \u003d n.getFirstChild().getString();\n                ProvidedName pn \u003d providedNames.get(name);\n                if (pn !\u003d null) {\n                    compiler.report(t.makeError(n, FUNCTION_NAMESPACE_ERROR, name));\n                }\n            }\n            break;\n        case Token.GETPROP:\n            if (n.getFirstChild().isName() \u0026\u0026 !parent.isCall() \u0026\u0026 !parent.isAssign() \u0026\u0026 \"goog.base\".equals(n.getQualifiedName())) {\n                reportBadBaseClassUse(t, n, \"May only be called directly.\");\n            }\n            break;\n    }\n}",
      "path": "src/com/google/javascript/jscomp/ProcessClosurePrimitives.java",
      "functionStartLine": 173,
      "functionName": "visit",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,67 +1,67 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n     switch(n.getType()) {\n         case Token.CALL:\n             boolean isExpr \u003d parent.isExprResult();\n             Node left \u003d n.getFirstChild();\n             if (left.isGetProp()) {\n                 Node name \u003d left.getFirstChild();\n                 if (name.isName() \u0026\u0026 GOOG.equals(name.getString())) {\n                     String methodName \u003d name.getNext().getString();\n                     if (\"base\".equals(methodName)) {\n                         processBaseClassCall(t, n);\n                     } else if (!isExpr) {\n                         break;\n                     } else if (\"require\".equals(methodName)) {\n                         processRequireCall(t, n, parent);\n                     } else if (\"provide\".equals(methodName)) {\n                         processProvideCall(t, n, parent);\n                     } else if (\"exportSymbol\".equals(methodName)) {\n                         Node arg \u003d left.getNext();\n                         if (arg.isString()) {\n                             int dot \u003d arg.getString().indexOf(\u0027.\u0027);\n                             if (dot \u003d\u003d -1) {\n                                 exportedVariables.add(arg.getString());\n                             } else {\n                                 exportedVariables.add(arg.getString().substring(0, dot));\n                             }\n                         }\n                     } else if (\"addDependency\".equals(methodName)) {\n                         CodingConvention convention \u003d compiler.getCodingConvention();\n                         List\u003cString\u003e typeDecls \u003d convention.identifyTypeDeclarationCall(n);\n                         if (typeDecls !\u003d null) {\n                             for (String typeDecl : typeDecls) {\n                                 compiler.getTypeRegistry().forwardDeclareType(typeDecl);\n                             }\n                         }\n                         parent.replaceChild(n, IR.number(0));\n                         compiler.reportCodeChange();\n                     } else if (\"setCssNameMapping\".equals(methodName)) {\n                         processSetCssNameMapping(t, n, parent);\n                     }\n                 }\n             }\n             break;\n         case Token.ASSIGN:\n         case Token.NAME:\n             handleCandidateProvideDefinition(t, n, parent);\n             break;\n         case Token.EXPR_RESULT:\n-            handleTypedefDefinition(t, n, parent);\n+            handleTypedefDefinition(t, n);\n             break;\n         case Token.FUNCTION:\n             if (t.inGlobalScope() \u0026\u0026 !NodeUtil.isFunctionExpression(n)) {\n                 String name \u003d n.getFirstChild().getString();\n                 ProvidedName pn \u003d providedNames.get(name);\n                 if (pn !\u003d null) {\n                     compiler.report(t.makeError(n, FUNCTION_NAMESPACE_ERROR, name));\n                 }\n             }\n             break;\n         case Token.GETPROP:\n             if (n.getFirstChild().isName() \u0026\u0026 !parent.isCall() \u0026\u0026 !parent.isAssign() \u0026\u0026 \"goog.base\".equals(n.getQualifiedName())) {\n                 reportBadBaseClassUse(t, n, \"May only be called directly.\");\n             }\n             break;\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f9fbad23b8fb59464e395c164197750abb5db296": {
      "type": "Ybodychange",
      "commitMessage": "\nGet rid of the goog.now optimization.\nThis is a weird micro-optimization that will break if\nwe change to implementation of goog.now to use high-resolution timers.\n\nR\u003dchrishenry\nDELTA\u003d61  (1 added, 50 deleted, 10 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d5132\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2078 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "7/9/12, 2:24 PM",
      "commitName": "f9fbad23b8fb59464e395c164197750abb5db296",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "5/18/12, 11:09 AM",
      "commitNameOld": "70a5626922ea7e8c98747e22b6986638ba38fadc",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 52.14,
      "commitsBetweenForRepo": 98,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.CALL:\n            boolean isExpr \u003d parent.isExprResult();\n            Node left \u003d n.getFirstChild();\n            if (left.isGetProp()) {\n                Node name \u003d left.getFirstChild();\n                if (name.isName() \u0026\u0026 GOOG.equals(name.getString())) {\n                    String methodName \u003d name.getNext().getString();\n                    if (\"base\".equals(methodName)) {\n                        processBaseClassCall(t, n);\n                    } else if (!isExpr) {\n                        break;\n                    } else if (\"require\".equals(methodName)) {\n                        processRequireCall(t, n, parent);\n                    } else if (\"provide\".equals(methodName)) {\n                        processProvideCall(t, n, parent);\n                    } else if (\"exportSymbol\".equals(methodName)) {\n                        Node arg \u003d left.getNext();\n                        if (arg.isString()) {\n                            int dot \u003d arg.getString().indexOf(\u0027.\u0027);\n                            if (dot \u003d\u003d -1) {\n                                exportedVariables.add(arg.getString());\n                            } else {\n                                exportedVariables.add(arg.getString().substring(0, dot));\n                            }\n                        }\n                    } else if (\"addDependency\".equals(methodName)) {\n                        CodingConvention convention \u003d compiler.getCodingConvention();\n                        List\u003cString\u003e typeDecls \u003d convention.identifyTypeDeclarationCall(n);\n                        if (typeDecls !\u003d null) {\n                            for (String typeDecl : typeDecls) {\n                                compiler.getTypeRegistry().forwardDeclareType(typeDecl);\n                            }\n                        }\n                        parent.replaceChild(n, IR.number(0));\n                        compiler.reportCodeChange();\n                    } else if (\"setCssNameMapping\".equals(methodName)) {\n                        processSetCssNameMapping(t, n, parent);\n                    }\n                }\n            }\n            break;\n        case Token.ASSIGN:\n        case Token.NAME:\n            handleCandidateProvideDefinition(t, n, parent);\n            break;\n        case Token.EXPR_RESULT:\n            handleTypedefDefinition(t, n, parent);\n            break;\n        case Token.FUNCTION:\n            if (t.inGlobalScope() \u0026\u0026 !NodeUtil.isFunctionExpression(n)) {\n                String name \u003d n.getFirstChild().getString();\n                ProvidedName pn \u003d providedNames.get(name);\n                if (pn !\u003d null) {\n                    compiler.report(t.makeError(n, FUNCTION_NAMESPACE_ERROR, name));\n                }\n            }\n            break;\n        case Token.GETPROP:\n            if (n.getFirstChild().isName() \u0026\u0026 !parent.isCall() \u0026\u0026 !parent.isAssign() \u0026\u0026 \"goog.base\".equals(n.getQualifiedName())) {\n                reportBadBaseClassUse(t, n, \"May only be called directly.\");\n            }\n            break;\n    }\n}",
      "path": "src/com/google/javascript/jscomp/ProcessClosurePrimitives.java",
      "functionStartLine": 173,
      "functionName": "visit",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,70 +1,67 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n     switch(n.getType()) {\n         case Token.CALL:\n             boolean isExpr \u003d parent.isExprResult();\n             Node left \u003d n.getFirstChild();\n             if (left.isGetProp()) {\n                 Node name \u003d left.getFirstChild();\n                 if (name.isName() \u0026\u0026 GOOG.equals(name.getString())) {\n                     String methodName \u003d name.getNext().getString();\n                     if (\"base\".equals(methodName)) {\n                         processBaseClassCall(t, n);\n                     } else if (!isExpr) {\n                         break;\n                     } else if (\"require\".equals(methodName)) {\n                         processRequireCall(t, n, parent);\n                     } else if (\"provide\".equals(methodName)) {\n                         processProvideCall(t, n, parent);\n                     } else if (\"exportSymbol\".equals(methodName)) {\n                         Node arg \u003d left.getNext();\n                         if (arg.isString()) {\n                             int dot \u003d arg.getString().indexOf(\u0027.\u0027);\n                             if (dot \u003d\u003d -1) {\n                                 exportedVariables.add(arg.getString());\n                             } else {\n                                 exportedVariables.add(arg.getString().substring(0, dot));\n                             }\n                         }\n                     } else if (\"addDependency\".equals(methodName)) {\n                         CodingConvention convention \u003d compiler.getCodingConvention();\n                         List\u003cString\u003e typeDecls \u003d convention.identifyTypeDeclarationCall(n);\n                         if (typeDecls !\u003d null) {\n                             for (String typeDecl : typeDecls) {\n                                 compiler.getTypeRegistry().forwardDeclareType(typeDecl);\n                             }\n                         }\n                         parent.replaceChild(n, IR.number(0));\n                         compiler.reportCodeChange();\n                     } else if (\"setCssNameMapping\".equals(methodName)) {\n                         processSetCssNameMapping(t, n, parent);\n                     }\n                 }\n             }\n             break;\n         case Token.ASSIGN:\n         case Token.NAME:\n             handleCandidateProvideDefinition(t, n, parent);\n             break;\n         case Token.EXPR_RESULT:\n             handleTypedefDefinition(t, n, parent);\n             break;\n         case Token.FUNCTION:\n             if (t.inGlobalScope() \u0026\u0026 !NodeUtil.isFunctionExpression(n)) {\n                 String name \u003d n.getFirstChild().getString();\n                 ProvidedName pn \u003d providedNames.get(name);\n                 if (pn !\u003d null) {\n                     compiler.report(t.makeError(n, FUNCTION_NAMESPACE_ERROR, name));\n                 }\n             }\n             break;\n-        case Token.NEW:\n-            trySimplifyNewDate(t, n, parent);\n-            break;\n         case Token.GETPROP:\n             if (n.getFirstChild().isName() \u0026\u0026 !parent.isCall() \u0026\u0026 !parent.isAssign() \u0026\u0026 \"goog.base\".equals(n.getQualifiedName())) {\n                 reportBadBaseClassUse(t, n, \"May only be called directly.\");\n             }\n             break;\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "70a5626922ea7e8c98747e22b6986638ba38fadc": {
      "type": "Ybodychange",
      "commitMessage": "\nFix various typos, spelling and grammar errors.\nFixes issue 734. \nContributed by Robert Gust Bardon\n\nR\u003dnicksantos\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d4827\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1979 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "5/18/12, 11:09 AM",
      "commitName": "70a5626922ea7e8c98747e22b6986638ba38fadc",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "4/25/12, 1:34 PM",
      "commitNameOld": "f412f0c0efd54842b30207c845d65cb826217fd6",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 22.9,
      "commitsBetweenForRepo": 51,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.CALL:\n            boolean isExpr \u003d parent.isExprResult();\n            Node left \u003d n.getFirstChild();\n            if (left.isGetProp()) {\n                Node name \u003d left.getFirstChild();\n                if (name.isName() \u0026\u0026 GOOG.equals(name.getString())) {\n                    String methodName \u003d name.getNext().getString();\n                    if (\"base\".equals(methodName)) {\n                        processBaseClassCall(t, n);\n                    } else if (!isExpr) {\n                        break;\n                    } else if (\"require\".equals(methodName)) {\n                        processRequireCall(t, n, parent);\n                    } else if (\"provide\".equals(methodName)) {\n                        processProvideCall(t, n, parent);\n                    } else if (\"exportSymbol\".equals(methodName)) {\n                        Node arg \u003d left.getNext();\n                        if (arg.isString()) {\n                            int dot \u003d arg.getString().indexOf(\u0027.\u0027);\n                            if (dot \u003d\u003d -1) {\n                                exportedVariables.add(arg.getString());\n                            } else {\n                                exportedVariables.add(arg.getString().substring(0, dot));\n                            }\n                        }\n                    } else if (\"addDependency\".equals(methodName)) {\n                        CodingConvention convention \u003d compiler.getCodingConvention();\n                        List\u003cString\u003e typeDecls \u003d convention.identifyTypeDeclarationCall(n);\n                        if (typeDecls !\u003d null) {\n                            for (String typeDecl : typeDecls) {\n                                compiler.getTypeRegistry().forwardDeclareType(typeDecl);\n                            }\n                        }\n                        parent.replaceChild(n, IR.number(0));\n                        compiler.reportCodeChange();\n                    } else if (\"setCssNameMapping\".equals(methodName)) {\n                        processSetCssNameMapping(t, n, parent);\n                    }\n                }\n            }\n            break;\n        case Token.ASSIGN:\n        case Token.NAME:\n            handleCandidateProvideDefinition(t, n, parent);\n            break;\n        case Token.EXPR_RESULT:\n            handleTypedefDefinition(t, n, parent);\n            break;\n        case Token.FUNCTION:\n            if (t.inGlobalScope() \u0026\u0026 !NodeUtil.isFunctionExpression(n)) {\n                String name \u003d n.getFirstChild().getString();\n                ProvidedName pn \u003d providedNames.get(name);\n                if (pn !\u003d null) {\n                    compiler.report(t.makeError(n, FUNCTION_NAMESPACE_ERROR, name));\n                }\n            }\n            break;\n        case Token.NEW:\n            trySimplifyNewDate(t, n, parent);\n            break;\n        case Token.GETPROP:\n            if (n.getFirstChild().isName() \u0026\u0026 !parent.isCall() \u0026\u0026 !parent.isAssign() \u0026\u0026 \"goog.base\".equals(n.getQualifiedName())) {\n                reportBadBaseClassUse(t, n, \"May only be called directly.\");\n            }\n            break;\n    }\n}",
      "path": "src/com/google/javascript/jscomp/ProcessClosurePrimitives.java",
      "functionStartLine": 176,
      "functionName": "visit",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {}
    },
    "9dfbc803407e714f9744555a1c9e7c4230f1816d": {
      "type": "Ybodychange",
      "commitMessage": "\nUse the new IR interface where possible.\n\nR\u003dnicksantos\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3799\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1641 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/22/11, 2:28 PM",
      "commitName": "9dfbc803407e714f9744555a1c9e7c4230f1816d",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "11/14/11, 6:13 PM",
      "commitNameOld": "39f629a8cfaab37da55288010640d7e516000b1f",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 7.84,
      "commitsBetweenForRepo": 31,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.CALL:\n            boolean isExpr \u003d parent.isExprResult();\n            Node left \u003d n.getFirstChild();\n            if (left.isGetProp()) {\n                Node name \u003d left.getFirstChild();\n                if (name.isName() \u0026\u0026 GOOG.equals(name.getString())) {\n                    String methodName \u003d name.getNext().getString();\n                    if (\"base\".equals(methodName)) {\n                        processBaseClassCall(t, n);\n                    } else if (!isExpr) {\n                        break;\n                    } else if (\"require\".equals(methodName)) {\n                        processRequireCall(t, n, parent);\n                    } else if (\"provide\".equals(methodName)) {\n                        processProvideCall(t, n, parent);\n                    } else if (\"exportSymbol\".equals(methodName)) {\n                        Node arg \u003d left.getNext();\n                        if (arg.isString()) {\n                            int dot \u003d arg.getString().indexOf(\u0027.\u0027);\n                            if (dot \u003d\u003d -1) {\n                                exportedVariables.add(arg.getString());\n                            } else {\n                                exportedVariables.add(arg.getString().substring(0, dot));\n                            }\n                        }\n                    } else if (\"addDependency\".equals(methodName)) {\n                        CodingConvention convention \u003d compiler.getCodingConvention();\n                        List\u003cString\u003e typeDecls \u003d convention.identifyTypeDeclarationCall(n);\n                        if (typeDecls !\u003d null) {\n                            for (String typeDecl : typeDecls) {\n                                compiler.getTypeRegistry().forwardDeclareType(typeDecl);\n                            }\n                        }\n                        parent.replaceChild(n, IR.number(0));\n                        compiler.reportCodeChange();\n                    } else if (\"setCssNameMapping\".equals(methodName)) {\n                        processSetCssNameMapping(t, n, parent);\n                    }\n                }\n            }\n            break;\n        case Token.ASSIGN:\n        case Token.NAME:\n            handleCandidateProvideDefinition(t, n, parent);\n            break;\n        case Token.EXPR_RESULT:\n            handleTypedefDefinition(t, n, parent);\n            break;\n        case Token.FUNCTION:\n            if (t.inGlobalScope() \u0026\u0026 !NodeUtil.isFunctionExpression(n)) {\n                String name \u003d n.getFirstChild().getString();\n                ProvidedName pn \u003d providedNames.get(name);\n                if (pn !\u003d null) {\n                    compiler.report(t.makeError(n, FUNCTION_NAMESPACE_ERROR, name));\n                }\n            }\n            break;\n        case Token.NEW:\n            trySimplifyNewDate(t, n, parent);\n            break;\n        case Token.GETPROP:\n            if (n.getFirstChild().isName() \u0026\u0026 !parent.isCall() \u0026\u0026 !parent.isAssign() \u0026\u0026 \"goog.base\".equals(n.getQualifiedName())) {\n                reportBadBaseClassUse(t, n, \"May only be called directly.\");\n            }\n            break;\n    }\n}",
      "path": "src/com/google/javascript/jscomp/ProcessClosurePrimitives.java",
      "functionStartLine": 176,
      "functionName": "visit",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,70 +1,70 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n     switch(n.getType()) {\n         case Token.CALL:\n             boolean isExpr \u003d parent.isExprResult();\n             Node left \u003d n.getFirstChild();\n             if (left.isGetProp()) {\n                 Node name \u003d left.getFirstChild();\n                 if (name.isName() \u0026\u0026 GOOG.equals(name.getString())) {\n                     String methodName \u003d name.getNext().getString();\n                     if (\"base\".equals(methodName)) {\n                         processBaseClassCall(t, n);\n                     } else if (!isExpr) {\n                         break;\n                     } else if (\"require\".equals(methodName)) {\n                         processRequireCall(t, n, parent);\n                     } else if (\"provide\".equals(methodName)) {\n                         processProvideCall(t, n, parent);\n                     } else if (\"exportSymbol\".equals(methodName)) {\n                         Node arg \u003d left.getNext();\n                         if (arg.isString()) {\n                             int dot \u003d arg.getString().indexOf(\u0027.\u0027);\n                             if (dot \u003d\u003d -1) {\n                                 exportedVariables.add(arg.getString());\n                             } else {\n                                 exportedVariables.add(arg.getString().substring(0, dot));\n                             }\n                         }\n                     } else if (\"addDependency\".equals(methodName)) {\n                         CodingConvention convention \u003d compiler.getCodingConvention();\n                         List\u003cString\u003e typeDecls \u003d convention.identifyTypeDeclarationCall(n);\n                         if (typeDecls !\u003d null) {\n                             for (String typeDecl : typeDecls) {\n                                 compiler.getTypeRegistry().forwardDeclareType(typeDecl);\n                             }\n                         }\n-                        parent.replaceChild(n, Node.newNumber(0));\n+                        parent.replaceChild(n, IR.number(0));\n                         compiler.reportCodeChange();\n                     } else if (\"setCssNameMapping\".equals(methodName)) {\n                         processSetCssNameMapping(t, n, parent);\n                     }\n                 }\n             }\n             break;\n         case Token.ASSIGN:\n         case Token.NAME:\n             handleCandidateProvideDefinition(t, n, parent);\n             break;\n         case Token.EXPR_RESULT:\n             handleTypedefDefinition(t, n, parent);\n             break;\n         case Token.FUNCTION:\n             if (t.inGlobalScope() \u0026\u0026 !NodeUtil.isFunctionExpression(n)) {\n                 String name \u003d n.getFirstChild().getString();\n                 ProvidedName pn \u003d providedNames.get(name);\n                 if (pn !\u003d null) {\n                     compiler.report(t.makeError(n, FUNCTION_NAMESPACE_ERROR, name));\n                 }\n             }\n             break;\n         case Token.NEW:\n             trySimplifyNewDate(t, n, parent);\n             break;\n         case Token.GETPROP:\n             if (n.getFirstChild().isName() \u0026\u0026 !parent.isCall() \u0026\u0026 !parent.isAssign() \u0026\u0026 \"goog.base\".equals(n.getQualifiedName())) {\n                 reportBadBaseClassUse(t, n, \"May only be called directly.\");\n             }\n             break;\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "39f629a8cfaab37da55288010640d7e516000b1f": {
      "type": "Ybodychange",
      "commitMessage": "\nReplace calls of the form \"Node.getType() !\u003d Token.XX\" with\n\"!Node.isXX()\" calls.\n\nR\u003dnicksantos\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3706\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1598 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/14/11, 6:13 PM",
      "commitName": "39f629a8cfaab37da55288010640d7e516000b1f",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "11/14/11, 5:13 PM",
      "commitNameOld": "c559972fbc64b616050017adeffb079d0b8801c0",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.CALL:\n            boolean isExpr \u003d parent.isExprResult();\n            Node left \u003d n.getFirstChild();\n            if (left.isGetProp()) {\n                Node name \u003d left.getFirstChild();\n                if (name.isName() \u0026\u0026 GOOG.equals(name.getString())) {\n                    String methodName \u003d name.getNext().getString();\n                    if (\"base\".equals(methodName)) {\n                        processBaseClassCall(t, n);\n                    } else if (!isExpr) {\n                        break;\n                    } else if (\"require\".equals(methodName)) {\n                        processRequireCall(t, n, parent);\n                    } else if (\"provide\".equals(methodName)) {\n                        processProvideCall(t, n, parent);\n                    } else if (\"exportSymbol\".equals(methodName)) {\n                        Node arg \u003d left.getNext();\n                        if (arg.isString()) {\n                            int dot \u003d arg.getString().indexOf(\u0027.\u0027);\n                            if (dot \u003d\u003d -1) {\n                                exportedVariables.add(arg.getString());\n                            } else {\n                                exportedVariables.add(arg.getString().substring(0, dot));\n                            }\n                        }\n                    } else if (\"addDependency\".equals(methodName)) {\n                        CodingConvention convention \u003d compiler.getCodingConvention();\n                        List\u003cString\u003e typeDecls \u003d convention.identifyTypeDeclarationCall(n);\n                        if (typeDecls !\u003d null) {\n                            for (String typeDecl : typeDecls) {\n                                compiler.getTypeRegistry().forwardDeclareType(typeDecl);\n                            }\n                        }\n                        parent.replaceChild(n, Node.newNumber(0));\n                        compiler.reportCodeChange();\n                    } else if (\"setCssNameMapping\".equals(methodName)) {\n                        processSetCssNameMapping(t, n, parent);\n                    }\n                }\n            }\n            break;\n        case Token.ASSIGN:\n        case Token.NAME:\n            handleCandidateProvideDefinition(t, n, parent);\n            break;\n        case Token.EXPR_RESULT:\n            handleTypedefDefinition(t, n, parent);\n            break;\n        case Token.FUNCTION:\n            if (t.inGlobalScope() \u0026\u0026 !NodeUtil.isFunctionExpression(n)) {\n                String name \u003d n.getFirstChild().getString();\n                ProvidedName pn \u003d providedNames.get(name);\n                if (pn !\u003d null) {\n                    compiler.report(t.makeError(n, FUNCTION_NAMESPACE_ERROR, name));\n                }\n            }\n            break;\n        case Token.NEW:\n            trySimplifyNewDate(t, n, parent);\n            break;\n        case Token.GETPROP:\n            if (n.getFirstChild().isName() \u0026\u0026 !parent.isCall() \u0026\u0026 !parent.isAssign() \u0026\u0026 \"goog.base\".equals(n.getQualifiedName())) {\n                reportBadBaseClassUse(t, n, \"May only be called directly.\");\n            }\n            break;\n    }\n}",
      "path": "src/com/google/javascript/jscomp/ProcessClosurePrimitives.java",
      "functionStartLine": 175,
      "functionName": "visit",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,70 +1,70 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n     switch(n.getType()) {\n         case Token.CALL:\n             boolean isExpr \u003d parent.isExprResult();\n             Node left \u003d n.getFirstChild();\n             if (left.isGetProp()) {\n                 Node name \u003d left.getFirstChild();\n                 if (name.isName() \u0026\u0026 GOOG.equals(name.getString())) {\n                     String methodName \u003d name.getNext().getString();\n                     if (\"base\".equals(methodName)) {\n                         processBaseClassCall(t, n);\n                     } else if (!isExpr) {\n                         break;\n                     } else if (\"require\".equals(methodName)) {\n                         processRequireCall(t, n, parent);\n                     } else if (\"provide\".equals(methodName)) {\n                         processProvideCall(t, n, parent);\n                     } else if (\"exportSymbol\".equals(methodName)) {\n                         Node arg \u003d left.getNext();\n                         if (arg.isString()) {\n                             int dot \u003d arg.getString().indexOf(\u0027.\u0027);\n                             if (dot \u003d\u003d -1) {\n                                 exportedVariables.add(arg.getString());\n                             } else {\n                                 exportedVariables.add(arg.getString().substring(0, dot));\n                             }\n                         }\n                     } else if (\"addDependency\".equals(methodName)) {\n                         CodingConvention convention \u003d compiler.getCodingConvention();\n                         List\u003cString\u003e typeDecls \u003d convention.identifyTypeDeclarationCall(n);\n                         if (typeDecls !\u003d null) {\n                             for (String typeDecl : typeDecls) {\n                                 compiler.getTypeRegistry().forwardDeclareType(typeDecl);\n                             }\n                         }\n                         parent.replaceChild(n, Node.newNumber(0));\n                         compiler.reportCodeChange();\n                     } else if (\"setCssNameMapping\".equals(methodName)) {\n                         processSetCssNameMapping(t, n, parent);\n                     }\n                 }\n             }\n             break;\n         case Token.ASSIGN:\n         case Token.NAME:\n             handleCandidateProvideDefinition(t, n, parent);\n             break;\n         case Token.EXPR_RESULT:\n             handleTypedefDefinition(t, n, parent);\n             break;\n         case Token.FUNCTION:\n             if (t.inGlobalScope() \u0026\u0026 !NodeUtil.isFunctionExpression(n)) {\n                 String name \u003d n.getFirstChild().getString();\n                 ProvidedName pn \u003d providedNames.get(name);\n                 if (pn !\u003d null) {\n                     compiler.report(t.makeError(n, FUNCTION_NAMESPACE_ERROR, name));\n                 }\n             }\n             break;\n         case Token.NEW:\n             trySimplifyNewDate(t, n, parent);\n             break;\n         case Token.GETPROP:\n-            if (n.getFirstChild().isName() \u0026\u0026 parent.getType() !\u003d Token.CALL \u0026\u0026 parent.getType() !\u003d Token.ASSIGN \u0026\u0026 \"goog.base\".equals(n.getQualifiedName())) {\n+            if (n.getFirstChild().isName() \u0026\u0026 !parent.isCall() \u0026\u0026 !parent.isAssign() \u0026\u0026 \"goog.base\".equals(n.getQualifiedName())) {\n                 reportBadBaseClassUse(t, n, \"May only be called directly.\");\n             }\n             break;\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ec324a9bb23eb78c76f537f4c4170ba88d542f1c": {
      "type": "Ybodychange",
      "commitMessage": "\nReplace the bulk of the Node.getType() \u003d\u003d Token.XXX calls with\nNode.isXXX calls.\n\nR\u003dnicksantos\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3677\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1582 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/10/11, 8:36 AM",
      "commitName": "ec324a9bb23eb78c76f537f4c4170ba88d542f1c",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "11/9/11, 1:51 PM",
      "commitNameOld": "3d80e1ed8fffbcb5f41b63f64726d9a4c76f209f",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 0.78,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.CALL:\n            boolean isExpr \u003d parent.isExprResult();\n            Node left \u003d n.getFirstChild();\n            if (left.isGetProp()) {\n                Node name \u003d left.getFirstChild();\n                if (name.isName() \u0026\u0026 GOOG.equals(name.getString())) {\n                    String methodName \u003d name.getNext().getString();\n                    if (\"base\".equals(methodName)) {\n                        processBaseClassCall(t, n);\n                    } else if (!isExpr) {\n                        break;\n                    } else if (\"require\".equals(methodName)) {\n                        processRequireCall(t, n, parent);\n                    } else if (\"provide\".equals(methodName)) {\n                        processProvideCall(t, n, parent);\n                    } else if (\"exportSymbol\".equals(methodName)) {\n                        Node arg \u003d left.getNext();\n                        if (arg.isString()) {\n                            int dot \u003d arg.getString().indexOf(\u0027.\u0027);\n                            if (dot \u003d\u003d -1) {\n                                exportedVariables.add(arg.getString());\n                            } else {\n                                exportedVariables.add(arg.getString().substring(0, dot));\n                            }\n                        }\n                    } else if (\"addDependency\".equals(methodName)) {\n                        CodingConvention convention \u003d compiler.getCodingConvention();\n                        List\u003cString\u003e typeDecls \u003d convention.identifyTypeDeclarationCall(n);\n                        if (typeDecls !\u003d null) {\n                            for (String typeDecl : typeDecls) {\n                                compiler.getTypeRegistry().forwardDeclareType(typeDecl);\n                            }\n                        }\n                        parent.replaceChild(n, Node.newNumber(0));\n                        compiler.reportCodeChange();\n                    } else if (\"setCssNameMapping\".equals(methodName)) {\n                        processSetCssNameMapping(t, n, parent);\n                    }\n                }\n            }\n            break;\n        case Token.ASSIGN:\n        case Token.NAME:\n            handleCandidateProvideDefinition(t, n, parent);\n            break;\n        case Token.EXPR_RESULT:\n            handleTypedefDefinition(t, n, parent);\n            break;\n        case Token.FUNCTION:\n            if (t.inGlobalScope() \u0026\u0026 !NodeUtil.isFunctionExpression(n)) {\n                String name \u003d n.getFirstChild().getString();\n                ProvidedName pn \u003d providedNames.get(name);\n                if (pn !\u003d null) {\n                    compiler.report(t.makeError(n, FUNCTION_NAMESPACE_ERROR, name));\n                }\n            }\n            break;\n        case Token.NEW:\n            trySimplifyNewDate(t, n, parent);\n            break;\n        case Token.GETPROP:\n            if (n.getFirstChild().isName() \u0026\u0026 parent.getType() !\u003d Token.CALL \u0026\u0026 parent.getType() !\u003d Token.ASSIGN \u0026\u0026 \"goog.base\".equals(n.getQualifiedName())) {\n                reportBadBaseClassUse(t, n, \"May only be called directly.\");\n            }\n            break;\n    }\n}",
      "path": "src/com/google/javascript/jscomp/ProcessClosurePrimitives.java",
      "functionStartLine": 175,
      "functionName": "visit",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,70 +1,70 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n     switch(n.getType()) {\n         case Token.CALL:\n-            boolean isExpr \u003d parent.getType() \u003d\u003d Token.EXPR_RESULT;\n+            boolean isExpr \u003d parent.isExprResult();\n             Node left \u003d n.getFirstChild();\n-            if (left.getType() \u003d\u003d Token.GETPROP) {\n+            if (left.isGetProp()) {\n                 Node name \u003d left.getFirstChild();\n-                if (name.getType() \u003d\u003d Token.NAME \u0026\u0026 GOOG.equals(name.getString())) {\n+                if (name.isName() \u0026\u0026 GOOG.equals(name.getString())) {\n                     String methodName \u003d name.getNext().getString();\n                     if (\"base\".equals(methodName)) {\n                         processBaseClassCall(t, n);\n                     } else if (!isExpr) {\n                         break;\n                     } else if (\"require\".equals(methodName)) {\n                         processRequireCall(t, n, parent);\n                     } else if (\"provide\".equals(methodName)) {\n                         processProvideCall(t, n, parent);\n                     } else if (\"exportSymbol\".equals(methodName)) {\n                         Node arg \u003d left.getNext();\n-                        if (arg.getType() \u003d\u003d Token.STRING) {\n+                        if (arg.isString()) {\n                             int dot \u003d arg.getString().indexOf(\u0027.\u0027);\n                             if (dot \u003d\u003d -1) {\n                                 exportedVariables.add(arg.getString());\n                             } else {\n                                 exportedVariables.add(arg.getString().substring(0, dot));\n                             }\n                         }\n                     } else if (\"addDependency\".equals(methodName)) {\n                         CodingConvention convention \u003d compiler.getCodingConvention();\n                         List\u003cString\u003e typeDecls \u003d convention.identifyTypeDeclarationCall(n);\n                         if (typeDecls !\u003d null) {\n                             for (String typeDecl : typeDecls) {\n                                 compiler.getTypeRegistry().forwardDeclareType(typeDecl);\n                             }\n                         }\n                         parent.replaceChild(n, Node.newNumber(0));\n                         compiler.reportCodeChange();\n                     } else if (\"setCssNameMapping\".equals(methodName)) {\n                         processSetCssNameMapping(t, n, parent);\n                     }\n                 }\n             }\n             break;\n         case Token.ASSIGN:\n         case Token.NAME:\n             handleCandidateProvideDefinition(t, n, parent);\n             break;\n         case Token.EXPR_RESULT:\n             handleTypedefDefinition(t, n, parent);\n             break;\n         case Token.FUNCTION:\n             if (t.inGlobalScope() \u0026\u0026 !NodeUtil.isFunctionExpression(n)) {\n                 String name \u003d n.getFirstChild().getString();\n                 ProvidedName pn \u003d providedNames.get(name);\n                 if (pn !\u003d null) {\n                     compiler.report(t.makeError(n, FUNCTION_NAMESPACE_ERROR, name));\n                 }\n             }\n             break;\n         case Token.NEW:\n             trySimplifyNewDate(t, n, parent);\n             break;\n         case Token.GETPROP:\n-            if (n.getFirstChild().getType() \u003d\u003d Token.NAME \u0026\u0026 parent.getType() !\u003d Token.CALL \u0026\u0026 parent.getType() !\u003d Token.ASSIGN \u0026\u0026 \"goog.base\".equals(n.getQualifiedName())) {\n+            if (n.getFirstChild().isName() \u0026\u0026 parent.getType() !\u003d Token.CALL \u0026\u0026 parent.getType() !\u003d Token.ASSIGN \u0026\u0026 \"goog.base\".equals(n.getQualifiedName())) {\n                 reportBadBaseClassUse(t, n, \"May only be called directly.\");\n             }\n             break;\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "97ccd2e190cffc9a656e2ae58bf03372f644f6df": {
      "type": "Ybodychange",
      "commitMessage": "\ndo not create objects for goog.provide\u0027d typedefs, try #2\nnow with an integration test for what broke people.\n\nR\u003djohnlenz\nDELTA\u003d64  (63 added, 0 deleted, 1 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d1708\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1055 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "5/3/11, 11:00 AM",
      "commitName": "97ccd2e190cffc9a656e2ae58bf03372f644f6df",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "4/13/11, 5:19 PM",
      "commitNameOld": "2b8ec0e5d81f5e765020faa3a74712eed54db311",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 19.74,
      "commitsBetweenForRepo": 47,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.CALL:\n            boolean isExpr \u003d parent.getType() \u003d\u003d Token.EXPR_RESULT;\n            Node left \u003d n.getFirstChild();\n            if (left.getType() \u003d\u003d Token.GETPROP) {\n                Node name \u003d left.getFirstChild();\n                if (name.getType() \u003d\u003d Token.NAME \u0026\u0026 GOOG.equals(name.getString())) {\n                    String methodName \u003d name.getNext().getString();\n                    if (\"base\".equals(methodName)) {\n                        processBaseClassCall(t, n);\n                    } else if (!isExpr) {\n                        break;\n                    } else if (\"require\".equals(methodName)) {\n                        processRequireCall(t, n, parent);\n                    } else if (\"provide\".equals(methodName)) {\n                        processProvideCall(t, n, parent);\n                    } else if (\"exportSymbol\".equals(methodName)) {\n                        Node arg \u003d left.getNext();\n                        if (arg.getType() \u003d\u003d Token.STRING) {\n                            int dot \u003d arg.getString().indexOf(\u0027.\u0027);\n                            if (dot \u003d\u003d -1) {\n                                exportedVariables.add(arg.getString());\n                            } else {\n                                exportedVariables.add(arg.getString().substring(0, dot));\n                            }\n                        }\n                    } else if (\"addDependency\".equals(methodName)) {\n                        CodingConvention convention \u003d compiler.getCodingConvention();\n                        List\u003cString\u003e typeDecls \u003d convention.identifyTypeDeclarationCall(n);\n                        if (typeDecls !\u003d null) {\n                            for (String typeDecl : typeDecls) {\n                                compiler.getTypeRegistry().forwardDeclareType(typeDecl);\n                            }\n                        }\n                        parent.replaceChild(n, Node.newNumber(0));\n                        compiler.reportCodeChange();\n                    } else if (\"setCssNameMapping\".equals(methodName)) {\n                        processSetCssNameMapping(t, n, parent);\n                    }\n                }\n            }\n            break;\n        case Token.ASSIGN:\n        case Token.NAME:\n            handleCandidateProvideDefinition(t, n, parent);\n            break;\n        case Token.EXPR_RESULT:\n            handleTypedefDefinition(t, n, parent);\n            break;\n        case Token.FUNCTION:\n            if (t.inGlobalScope() \u0026\u0026 !NodeUtil.isFunctionExpression(n)) {\n                String name \u003d n.getFirstChild().getString();\n                ProvidedName pn \u003d providedNames.get(name);\n                if (pn !\u003d null) {\n                    compiler.report(t.makeError(n, FUNCTION_NAMESPACE_ERROR, name));\n                }\n            }\n            break;\n        case Token.NEW:\n            trySimplifyNewDate(t, n, parent);\n            break;\n        case Token.GETPROP:\n            if (n.getFirstChild().getType() \u003d\u003d Token.NAME \u0026\u0026 parent.getType() !\u003d Token.CALL \u0026\u0026 parent.getType() !\u003d Token.ASSIGN \u0026\u0026 \"goog.base\".equals(n.getQualifiedName())) {\n                reportBadBaseClassUse(t, n, \"May only be called directly.\");\n            }\n            break;\n    }\n}",
      "path": "src/com/google/javascript/jscomp/ProcessClosurePrimitives.java",
      "functionStartLine": 162,
      "functionName": "visit",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,67 +1,70 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n     switch(n.getType()) {\n         case Token.CALL:\n             boolean isExpr \u003d parent.getType() \u003d\u003d Token.EXPR_RESULT;\n             Node left \u003d n.getFirstChild();\n             if (left.getType() \u003d\u003d Token.GETPROP) {\n                 Node name \u003d left.getFirstChild();\n                 if (name.getType() \u003d\u003d Token.NAME \u0026\u0026 GOOG.equals(name.getString())) {\n                     String methodName \u003d name.getNext().getString();\n                     if (\"base\".equals(methodName)) {\n                         processBaseClassCall(t, n);\n                     } else if (!isExpr) {\n                         break;\n                     } else if (\"require\".equals(methodName)) {\n                         processRequireCall(t, n, parent);\n                     } else if (\"provide\".equals(methodName)) {\n                         processProvideCall(t, n, parent);\n                     } else if (\"exportSymbol\".equals(methodName)) {\n                         Node arg \u003d left.getNext();\n                         if (arg.getType() \u003d\u003d Token.STRING) {\n                             int dot \u003d arg.getString().indexOf(\u0027.\u0027);\n                             if (dot \u003d\u003d -1) {\n                                 exportedVariables.add(arg.getString());\n                             } else {\n                                 exportedVariables.add(arg.getString().substring(0, dot));\n                             }\n                         }\n                     } else if (\"addDependency\".equals(methodName)) {\n                         CodingConvention convention \u003d compiler.getCodingConvention();\n                         List\u003cString\u003e typeDecls \u003d convention.identifyTypeDeclarationCall(n);\n                         if (typeDecls !\u003d null) {\n                             for (String typeDecl : typeDecls) {\n                                 compiler.getTypeRegistry().forwardDeclareType(typeDecl);\n                             }\n                         }\n                         parent.replaceChild(n, Node.newNumber(0));\n                         compiler.reportCodeChange();\n                     } else if (\"setCssNameMapping\".equals(methodName)) {\n                         processSetCssNameMapping(t, n, parent);\n                     }\n                 }\n             }\n             break;\n         case Token.ASSIGN:\n         case Token.NAME:\n             handleCandidateProvideDefinition(t, n, parent);\n             break;\n+        case Token.EXPR_RESULT:\n+            handleTypedefDefinition(t, n, parent);\n+            break;\n         case Token.FUNCTION:\n             if (t.inGlobalScope() \u0026\u0026 !NodeUtil.isFunctionExpression(n)) {\n                 String name \u003d n.getFirstChild().getString();\n                 ProvidedName pn \u003d providedNames.get(name);\n                 if (pn !\u003d null) {\n                     compiler.report(t.makeError(n, FUNCTION_NAMESPACE_ERROR, name));\n                 }\n             }\n             break;\n         case Token.NEW:\n             trySimplifyNewDate(t, n, parent);\n             break;\n         case Token.GETPROP:\n             if (n.getFirstChild().getType() \u003d\u003d Token.NAME \u0026\u0026 parent.getType() !\u003d Token.CALL \u0026\u0026 parent.getType() !\u003d Token.ASSIGN \u0026\u0026 \"goog.base\".equals(n.getQualifiedName())) {\n                 reportBadBaseClassUse(t, n, \"May only be called directly.\");\n             }\n             break;\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2b8ec0e5d81f5e765020faa3a74712eed54db311": {
      "type": "Ybodychange",
      "commitMessage": "\nAutomated g4 rollback.\n\n*** Reason for rollback ***\n\nbreaking things for unknown reasons\n\n*** Original change description ***\n\ndo not create objects for goog.provide\u0027d typedefs\n\nDELTA\u003d41  (0 added, 40 deleted, 1 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d1459\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1008 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/13/11, 5:19 PM",
      "commitName": "2b8ec0e5d81f5e765020faa3a74712eed54db311",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "4/13/11, 3:33 PM",
      "commitNameOld": "f136b358d247b27f2cb1b266d65c72f7c5af7bad",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 0.07,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.CALL:\n            boolean isExpr \u003d parent.getType() \u003d\u003d Token.EXPR_RESULT;\n            Node left \u003d n.getFirstChild();\n            if (left.getType() \u003d\u003d Token.GETPROP) {\n                Node name \u003d left.getFirstChild();\n                if (name.getType() \u003d\u003d Token.NAME \u0026\u0026 GOOG.equals(name.getString())) {\n                    String methodName \u003d name.getNext().getString();\n                    if (\"base\".equals(methodName)) {\n                        processBaseClassCall(t, n);\n                    } else if (!isExpr) {\n                        break;\n                    } else if (\"require\".equals(methodName)) {\n                        processRequireCall(t, n, parent);\n                    } else if (\"provide\".equals(methodName)) {\n                        processProvideCall(t, n, parent);\n                    } else if (\"exportSymbol\".equals(methodName)) {\n                        Node arg \u003d left.getNext();\n                        if (arg.getType() \u003d\u003d Token.STRING) {\n                            int dot \u003d arg.getString().indexOf(\u0027.\u0027);\n                            if (dot \u003d\u003d -1) {\n                                exportedVariables.add(arg.getString());\n                            } else {\n                                exportedVariables.add(arg.getString().substring(0, dot));\n                            }\n                        }\n                    } else if (\"addDependency\".equals(methodName)) {\n                        CodingConvention convention \u003d compiler.getCodingConvention();\n                        List\u003cString\u003e typeDecls \u003d convention.identifyTypeDeclarationCall(n);\n                        if (typeDecls !\u003d null) {\n                            for (String typeDecl : typeDecls) {\n                                compiler.getTypeRegistry().forwardDeclareType(typeDecl);\n                            }\n                        }\n                        parent.replaceChild(n, Node.newNumber(0));\n                        compiler.reportCodeChange();\n                    } else if (\"setCssNameMapping\".equals(methodName)) {\n                        processSetCssNameMapping(t, n, parent);\n                    }\n                }\n            }\n            break;\n        case Token.ASSIGN:\n        case Token.NAME:\n            handleCandidateProvideDefinition(t, n, parent);\n            break;\n        case Token.FUNCTION:\n            if (t.inGlobalScope() \u0026\u0026 !NodeUtil.isFunctionExpression(n)) {\n                String name \u003d n.getFirstChild().getString();\n                ProvidedName pn \u003d providedNames.get(name);\n                if (pn !\u003d null) {\n                    compiler.report(t.makeError(n, FUNCTION_NAMESPACE_ERROR, name));\n                }\n            }\n            break;\n        case Token.NEW:\n            trySimplifyNewDate(t, n, parent);\n            break;\n        case Token.GETPROP:\n            if (n.getFirstChild().getType() \u003d\u003d Token.NAME \u0026\u0026 parent.getType() !\u003d Token.CALL \u0026\u0026 parent.getType() !\u003d Token.ASSIGN \u0026\u0026 \"goog.base\".equals(n.getQualifiedName())) {\n                reportBadBaseClassUse(t, n, \"May only be called directly.\");\n            }\n            break;\n    }\n}",
      "path": "src/com/google/javascript/jscomp/ProcessClosurePrimitives.java",
      "functionStartLine": 161,
      "functionName": "visit",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,70 +1,67 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n     switch(n.getType()) {\n         case Token.CALL:\n             boolean isExpr \u003d parent.getType() \u003d\u003d Token.EXPR_RESULT;\n             Node left \u003d n.getFirstChild();\n             if (left.getType() \u003d\u003d Token.GETPROP) {\n                 Node name \u003d left.getFirstChild();\n                 if (name.getType() \u003d\u003d Token.NAME \u0026\u0026 GOOG.equals(name.getString())) {\n                     String methodName \u003d name.getNext().getString();\n                     if (\"base\".equals(methodName)) {\n                         processBaseClassCall(t, n);\n                     } else if (!isExpr) {\n                         break;\n                     } else if (\"require\".equals(methodName)) {\n                         processRequireCall(t, n, parent);\n                     } else if (\"provide\".equals(methodName)) {\n                         processProvideCall(t, n, parent);\n                     } else if (\"exportSymbol\".equals(methodName)) {\n                         Node arg \u003d left.getNext();\n                         if (arg.getType() \u003d\u003d Token.STRING) {\n                             int dot \u003d arg.getString().indexOf(\u0027.\u0027);\n                             if (dot \u003d\u003d -1) {\n                                 exportedVariables.add(arg.getString());\n                             } else {\n                                 exportedVariables.add(arg.getString().substring(0, dot));\n                             }\n                         }\n                     } else if (\"addDependency\".equals(methodName)) {\n                         CodingConvention convention \u003d compiler.getCodingConvention();\n                         List\u003cString\u003e typeDecls \u003d convention.identifyTypeDeclarationCall(n);\n                         if (typeDecls !\u003d null) {\n                             for (String typeDecl : typeDecls) {\n                                 compiler.getTypeRegistry().forwardDeclareType(typeDecl);\n                             }\n                         }\n                         parent.replaceChild(n, Node.newNumber(0));\n                         compiler.reportCodeChange();\n                     } else if (\"setCssNameMapping\".equals(methodName)) {\n                         processSetCssNameMapping(t, n, parent);\n                     }\n                 }\n             }\n             break;\n         case Token.ASSIGN:\n         case Token.NAME:\n             handleCandidateProvideDefinition(t, n, parent);\n             break;\n-        case Token.EXPR_RESULT:\n-            handleTypedefDefinition(t, n, parent);\n-            break;\n         case Token.FUNCTION:\n             if (t.inGlobalScope() \u0026\u0026 !NodeUtil.isFunctionExpression(n)) {\n                 String name \u003d n.getFirstChild().getString();\n                 ProvidedName pn \u003d providedNames.get(name);\n                 if (pn !\u003d null) {\n                     compiler.report(t.makeError(n, FUNCTION_NAMESPACE_ERROR, name));\n                 }\n             }\n             break;\n         case Token.NEW:\n             trySimplifyNewDate(t, n, parent);\n             break;\n         case Token.GETPROP:\n             if (n.getFirstChild().getType() \u003d\u003d Token.NAME \u0026\u0026 parent.getType() !\u003d Token.CALL \u0026\u0026 parent.getType() !\u003d Token.ASSIGN \u0026\u0026 \"goog.base\".equals(n.getQualifiedName())) {\n                 reportBadBaseClassUse(t, n, \"May only be called directly.\");\n             }\n             break;\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f136b358d247b27f2cb1b266d65c72f7c5af7bad": {
      "type": "Ybodychange",
      "commitMessage": "\ndo not create objects for goog.provide\u0027d typedefs\n\nR\u003djohnlenz\nDELTA\u003d41  (40 added, 0 deleted, 1 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d1451\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1005 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/13/11, 3:33 PM",
      "commitName": "f136b358d247b27f2cb1b266d65c72f7c5af7bad",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "4/12/11, 12:15 PM",
      "commitNameOld": "f322be0e576d5e2114cb59c0a6537197997b9c59",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 1.14,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.CALL:\n            boolean isExpr \u003d parent.getType() \u003d\u003d Token.EXPR_RESULT;\n            Node left \u003d n.getFirstChild();\n            if (left.getType() \u003d\u003d Token.GETPROP) {\n                Node name \u003d left.getFirstChild();\n                if (name.getType() \u003d\u003d Token.NAME \u0026\u0026 GOOG.equals(name.getString())) {\n                    String methodName \u003d name.getNext().getString();\n                    if (\"base\".equals(methodName)) {\n                        processBaseClassCall(t, n);\n                    } else if (!isExpr) {\n                        break;\n                    } else if (\"require\".equals(methodName)) {\n                        processRequireCall(t, n, parent);\n                    } else if (\"provide\".equals(methodName)) {\n                        processProvideCall(t, n, parent);\n                    } else if (\"exportSymbol\".equals(methodName)) {\n                        Node arg \u003d left.getNext();\n                        if (arg.getType() \u003d\u003d Token.STRING) {\n                            int dot \u003d arg.getString().indexOf(\u0027.\u0027);\n                            if (dot \u003d\u003d -1) {\n                                exportedVariables.add(arg.getString());\n                            } else {\n                                exportedVariables.add(arg.getString().substring(0, dot));\n                            }\n                        }\n                    } else if (\"addDependency\".equals(methodName)) {\n                        CodingConvention convention \u003d compiler.getCodingConvention();\n                        List\u003cString\u003e typeDecls \u003d convention.identifyTypeDeclarationCall(n);\n                        if (typeDecls !\u003d null) {\n                            for (String typeDecl : typeDecls) {\n                                compiler.getTypeRegistry().forwardDeclareType(typeDecl);\n                            }\n                        }\n                        parent.replaceChild(n, Node.newNumber(0));\n                        compiler.reportCodeChange();\n                    } else if (\"setCssNameMapping\".equals(methodName)) {\n                        processSetCssNameMapping(t, n, parent);\n                    }\n                }\n            }\n            break;\n        case Token.ASSIGN:\n        case Token.NAME:\n            handleCandidateProvideDefinition(t, n, parent);\n            break;\n        case Token.EXPR_RESULT:\n            handleTypedefDefinition(t, n, parent);\n            break;\n        case Token.FUNCTION:\n            if (t.inGlobalScope() \u0026\u0026 !NodeUtil.isFunctionExpression(n)) {\n                String name \u003d n.getFirstChild().getString();\n                ProvidedName pn \u003d providedNames.get(name);\n                if (pn !\u003d null) {\n                    compiler.report(t.makeError(n, FUNCTION_NAMESPACE_ERROR, name));\n                }\n            }\n            break;\n        case Token.NEW:\n            trySimplifyNewDate(t, n, parent);\n            break;\n        case Token.GETPROP:\n            if (n.getFirstChild().getType() \u003d\u003d Token.NAME \u0026\u0026 parent.getType() !\u003d Token.CALL \u0026\u0026 parent.getType() !\u003d Token.ASSIGN \u0026\u0026 \"goog.base\".equals(n.getQualifiedName())) {\n                reportBadBaseClassUse(t, n, \"May only be called directly.\");\n            }\n            break;\n    }\n}",
      "path": "src/com/google/javascript/jscomp/ProcessClosurePrimitives.java",
      "functionStartLine": 162,
      "functionName": "visit",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,67 +1,70 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n     switch(n.getType()) {\n         case Token.CALL:\n             boolean isExpr \u003d parent.getType() \u003d\u003d Token.EXPR_RESULT;\n             Node left \u003d n.getFirstChild();\n             if (left.getType() \u003d\u003d Token.GETPROP) {\n                 Node name \u003d left.getFirstChild();\n                 if (name.getType() \u003d\u003d Token.NAME \u0026\u0026 GOOG.equals(name.getString())) {\n                     String methodName \u003d name.getNext().getString();\n                     if (\"base\".equals(methodName)) {\n                         processBaseClassCall(t, n);\n                     } else if (!isExpr) {\n                         break;\n                     } else if (\"require\".equals(methodName)) {\n                         processRequireCall(t, n, parent);\n                     } else if (\"provide\".equals(methodName)) {\n                         processProvideCall(t, n, parent);\n                     } else if (\"exportSymbol\".equals(methodName)) {\n                         Node arg \u003d left.getNext();\n                         if (arg.getType() \u003d\u003d Token.STRING) {\n                             int dot \u003d arg.getString().indexOf(\u0027.\u0027);\n                             if (dot \u003d\u003d -1) {\n                                 exportedVariables.add(arg.getString());\n                             } else {\n                                 exportedVariables.add(arg.getString().substring(0, dot));\n                             }\n                         }\n                     } else if (\"addDependency\".equals(methodName)) {\n                         CodingConvention convention \u003d compiler.getCodingConvention();\n                         List\u003cString\u003e typeDecls \u003d convention.identifyTypeDeclarationCall(n);\n                         if (typeDecls !\u003d null) {\n                             for (String typeDecl : typeDecls) {\n                                 compiler.getTypeRegistry().forwardDeclareType(typeDecl);\n                             }\n                         }\n                         parent.replaceChild(n, Node.newNumber(0));\n                         compiler.reportCodeChange();\n                     } else if (\"setCssNameMapping\".equals(methodName)) {\n                         processSetCssNameMapping(t, n, parent);\n                     }\n                 }\n             }\n             break;\n         case Token.ASSIGN:\n         case Token.NAME:\n             handleCandidateProvideDefinition(t, n, parent);\n             break;\n+        case Token.EXPR_RESULT:\n+            handleTypedefDefinition(t, n, parent);\n+            break;\n         case Token.FUNCTION:\n             if (t.inGlobalScope() \u0026\u0026 !NodeUtil.isFunctionExpression(n)) {\n                 String name \u003d n.getFirstChild().getString();\n                 ProvidedName pn \u003d providedNames.get(name);\n                 if (pn !\u003d null) {\n                     compiler.report(t.makeError(n, FUNCTION_NAMESPACE_ERROR, name));\n                 }\n             }\n             break;\n         case Token.NEW:\n             trySimplifyNewDate(t, n, parent);\n             break;\n         case Token.GETPROP:\n             if (n.getFirstChild().getType() \u003d\u003d Token.NAME \u0026\u0026 parent.getType() !\u003d Token.CALL \u0026\u0026 parent.getType() !\u003d Token.ASSIGN \u0026\u0026 \"goog.base\".equals(n.getQualifiedName())) {\n                 reportBadBaseClassUse(t, n, \"May only be called directly.\");\n             }\n             break;\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ebb59a97610015bc41bda7f458dd1428a3a3e335": {
      "type": "Ybodychange",
      "commitMessage": "\nChange on 2010/04/22 by nick\n\n        fix the extern definition of Window.prototype.stop\n\n        R\u003dsiggy\n        DELTA\u003d1  (0 added, 0 deleted, 1 changed)\n\nChange on 2010/04/22 by john\n\n        \"Anonymous function\" is a confusing term for functions with names.\n        Properly we are usually distinguishing between functions statements\n        (function declarations) and function expressions.\n\n        R\u003dalan\n        DELTA\u003d172  (7 added, 14 deleted, 151 changed)\n\nChange on 2010/04/22 by john\n\n        Standardize the definition of setTimeout/setInterval.\n        Fix for Issue 137\n\n        R\u003dnick\n        DELTA\u003d6  (2 added, 2 deleted, 2 changed)\n\nChange on 2010/04/22 by mark\n\n        Various delegate fixes.\n\n        Give the delegate proxy a name unique from the delegate base so that\n        InstanceObjectType#equals distinguishes them. This is necessary for\n        AmbiguateProperties to work.\n\n        Fix the prototype of the delegate proxy. This makes\n        DisambiguateProperties continue to work.\n\n        Add superclass methods of the delegate base to the delegate proxy.\n\n\n        R\u003dandrew,nada\n        DELTA\u003d526  (383 added, 104 deleted, 39 changed)\n\nChange on 2010/04/23 by john\n\n        Allow variable inlining of function statements. For simplicity  limited to functions defined before first use.\n\n        R\u003dnick\n        DELTA\u003d79  (49 added, 3 deleted, 27 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003dhakjvx\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@197 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/23/10, 11:31 AM",
      "commitName": "ebb59a97610015bc41bda7f458dd1428a3a3e335",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "4/19/10, 4:28 PM",
      "commitNameOld": "5da32cba7b68d69acfc535f57f21d652475d256f",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 3.79,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.CALL:\n            boolean isExpr \u003d parent.getType() \u003d\u003d Token.EXPR_RESULT;\n            Node left \u003d n.getFirstChild();\n            if (left.getType() \u003d\u003d Token.GETPROP) {\n                Node name \u003d left.getFirstChild();\n                if (name.getType() \u003d\u003d Token.NAME \u0026\u0026 GOOG.equals(name.getString())) {\n                    String methodName \u003d name.getNext().getString();\n                    if (\"base\".equals(methodName)) {\n                        processBaseClassCall(t, n);\n                    } else if (!isExpr) {\n                        break;\n                    } else if (\"require\".equals(methodName)) {\n                        processRequireCall(t, n, parent);\n                    } else if (\"provide\".equals(methodName)) {\n                        processProvideCall(t, n, parent);\n                    } else if (\"exportSymbol\".equals(methodName)) {\n                        Node arg \u003d left.getNext();\n                        if (arg.getType() \u003d\u003d Token.STRING) {\n                            int dot \u003d arg.getString().indexOf(\u0027.\u0027);\n                            if (dot \u003d\u003d -1) {\n                                exportedVariables.add(arg.getString());\n                            } else {\n                                exportedVariables.add(arg.getString().substring(0, dot));\n                            }\n                        }\n                    } else if (\"addDependency\".equals(methodName)) {\n                        CodingConvention convention \u003d compiler.getCodingConvention();\n                        List\u003cString\u003e typeDecls \u003d convention.identifyTypeDeclarationCall(n);\n                        if (typeDecls !\u003d null) {\n                            for (String typeDecl : typeDecls) {\n                                compiler.getTypeRegistry().forwardDeclareType(typeDecl);\n                            }\n                        }\n                        parent.replaceChild(n, Node.newNumber(0));\n                        compiler.reportCodeChange();\n                    } else if (\"setCssNameMapping\".equals(methodName)) {\n                        processSetCssNameMapping(t, n, parent);\n                    }\n                }\n            }\n            break;\n        case Token.ASSIGN:\n        case Token.NAME:\n            handleCandidateProvideDefinition(t, n, parent);\n            break;\n        case Token.FUNCTION:\n            if (t.inGlobalScope() \u0026\u0026 !NodeUtil.isFunctionExpression(n)) {\n                String name \u003d n.getFirstChild().getString();\n                ProvidedName pn \u003d providedNames.get(name);\n                if (pn !\u003d null) {\n                    compiler.report(t.makeError(n, FUNCTION_NAMESPACE_ERROR, name));\n                }\n            }\n            break;\n        case Token.NEW:\n            trySimplifyNewDate(t, n, parent);\n            break;\n        case Token.GETPROP:\n            if (n.getFirstChild().getType() \u003d\u003d Token.NAME \u0026\u0026 parent.getType() !\u003d Token.CALL \u0026\u0026 parent.getType() !\u003d Token.ASSIGN \u0026\u0026 \"goog.base\".equals(n.getQualifiedName())) {\n                reportBadBaseClassUse(t, n, \"May only be called directly.\");\n            }\n            break;\n    }\n}",
      "path": "src/com/google/javascript/jscomp/ProcessClosurePrimitives.java",
      "functionStartLine": 148,
      "functionName": "visit",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,67 +1,67 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n     switch(n.getType()) {\n         case Token.CALL:\n             boolean isExpr \u003d parent.getType() \u003d\u003d Token.EXPR_RESULT;\n             Node left \u003d n.getFirstChild();\n             if (left.getType() \u003d\u003d Token.GETPROP) {\n                 Node name \u003d left.getFirstChild();\n                 if (name.getType() \u003d\u003d Token.NAME \u0026\u0026 GOOG.equals(name.getString())) {\n                     String methodName \u003d name.getNext().getString();\n                     if (\"base\".equals(methodName)) {\n                         processBaseClassCall(t, n);\n                     } else if (!isExpr) {\n                         break;\n                     } else if (\"require\".equals(methodName)) {\n                         processRequireCall(t, n, parent);\n                     } else if (\"provide\".equals(methodName)) {\n                         processProvideCall(t, n, parent);\n                     } else if (\"exportSymbol\".equals(methodName)) {\n                         Node arg \u003d left.getNext();\n                         if (arg.getType() \u003d\u003d Token.STRING) {\n                             int dot \u003d arg.getString().indexOf(\u0027.\u0027);\n                             if (dot \u003d\u003d -1) {\n                                 exportedVariables.add(arg.getString());\n                             } else {\n                                 exportedVariables.add(arg.getString().substring(0, dot));\n                             }\n                         }\n                     } else if (\"addDependency\".equals(methodName)) {\n                         CodingConvention convention \u003d compiler.getCodingConvention();\n                         List\u003cString\u003e typeDecls \u003d convention.identifyTypeDeclarationCall(n);\n                         if (typeDecls !\u003d null) {\n                             for (String typeDecl : typeDecls) {\n                                 compiler.getTypeRegistry().forwardDeclareType(typeDecl);\n                             }\n                         }\n                         parent.replaceChild(n, Node.newNumber(0));\n                         compiler.reportCodeChange();\n                     } else if (\"setCssNameMapping\".equals(methodName)) {\n                         processSetCssNameMapping(t, n, parent);\n                     }\n                 }\n             }\n             break;\n         case Token.ASSIGN:\n         case Token.NAME:\n             handleCandidateProvideDefinition(t, n, parent);\n             break;\n         case Token.FUNCTION:\n-            if (t.inGlobalScope() \u0026\u0026 !NodeUtil.isFunctionAnonymous(n)) {\n+            if (t.inGlobalScope() \u0026\u0026 !NodeUtil.isFunctionExpression(n)) {\n                 String name \u003d n.getFirstChild().getString();\n                 ProvidedName pn \u003d providedNames.get(name);\n                 if (pn !\u003d null) {\n                     compiler.report(t.makeError(n, FUNCTION_NAMESPACE_ERROR, name));\n                 }\n             }\n             break;\n         case Token.NEW:\n             trySimplifyNewDate(t, n, parent);\n             break;\n         case Token.GETPROP:\n             if (n.getFirstChild().getType() \u003d\u003d Token.NAME \u0026\u0026 parent.getType() !\u003d Token.CALL \u0026\u0026 parent.getType() !\u003d Token.ASSIGN \u0026\u0026 \"goog.base\".equals(n.getQualifiedName())) {\n                 reportBadBaseClassUse(t, n, \"May only be called directly.\");\n             }\n             break;\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5da32cba7b68d69acfc535f57f21d652475d256f": {
      "type": "Ymultichange(Yannotationchange,Ydocchange)",
      "commitMessage": "\nChange on 2010/04/19 by anatol\n\n        Replace {@inheritDoc} javadoc annotation with @Override.\n        @Override is better as it implies documentation inheritance plus checks\n        that the parent method exists at the compile-time.\n\n        R\u003dnick\n        DELTA\u003d137  (0 added, 70 deleted, 67 changed)\n\nChange on 2010/04/19 by nick\n\n        Change how we resolve types.\n        Instead of leaving shell proxy types around, unbox the proxy types.\n\n        R\u003dandrew,john\n        DELTA\u003d103  (84 added, 5 deleted, 14 changed)\n\nChange on 2010/04/19 by acleung\n\n        Enable Flow Sensitive Inlining by default.\n\n        R\u003djohn\n        DELTA\u003d1  (0 added, 0 deleted, 1 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003dpqvliw\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@191 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/19/10, 4:28 PM",
      "commitName": "5da32cba7b68d69acfc535f57f21d652475d256f",
      "commitAuthor": "Nicholas.J.Santos",
      "subchanges": [
        {
          "type": "Yannotationchange",
          "commitMessage": "\nChange on 2010/04/19 by anatol\n\n        Replace {@inheritDoc} javadoc annotation with @Override.\n        @Override is better as it implies documentation inheritance plus checks\n        that the parent method exists at the compile-time.\n\n        R\u003dnick\n        DELTA\u003d137  (0 added, 70 deleted, 67 changed)\n\nChange on 2010/04/19 by nick\n\n        Change how we resolve types.\n        Instead of leaving shell proxy types around, unbox the proxy types.\n\n        R\u003dandrew,john\n        DELTA\u003d103  (84 added, 5 deleted, 14 changed)\n\nChange on 2010/04/19 by acleung\n\n        Enable Flow Sensitive Inlining by default.\n\n        R\u003djohn\n        DELTA\u003d1  (0 added, 0 deleted, 1 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003dpqvliw\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@191 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "4/19/10, 4:28 PM",
          "commitName": "5da32cba7b68d69acfc535f57f21d652475d256f",
          "commitAuthor": "Nicholas.J.Santos",
          "commitDateOld": "3/29/10, 7:04 AM",
          "commitNameOld": "3cc8b3a5889f8b88ef7a2bd0b8ccea8cb0d916c4",
          "commitAuthorOld": "Nicholas.J.Santos",
          "daysBetweenCommits": 21.39,
          "commitsBetweenForRepo": 29,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.CALL:\n            boolean isExpr \u003d parent.getType() \u003d\u003d Token.EXPR_RESULT;\n            Node left \u003d n.getFirstChild();\n            if (left.getType() \u003d\u003d Token.GETPROP) {\n                Node name \u003d left.getFirstChild();\n                if (name.getType() \u003d\u003d Token.NAME \u0026\u0026 GOOG.equals(name.getString())) {\n                    String methodName \u003d name.getNext().getString();\n                    if (\"base\".equals(methodName)) {\n                        processBaseClassCall(t, n);\n                    } else if (!isExpr) {\n                        break;\n                    } else if (\"require\".equals(methodName)) {\n                        processRequireCall(t, n, parent);\n                    } else if (\"provide\".equals(methodName)) {\n                        processProvideCall(t, n, parent);\n                    } else if (\"exportSymbol\".equals(methodName)) {\n                        Node arg \u003d left.getNext();\n                        if (arg.getType() \u003d\u003d Token.STRING) {\n                            int dot \u003d arg.getString().indexOf(\u0027.\u0027);\n                            if (dot \u003d\u003d -1) {\n                                exportedVariables.add(arg.getString());\n                            } else {\n                                exportedVariables.add(arg.getString().substring(0, dot));\n                            }\n                        }\n                    } else if (\"addDependency\".equals(methodName)) {\n                        CodingConvention convention \u003d compiler.getCodingConvention();\n                        List\u003cString\u003e typeDecls \u003d convention.identifyTypeDeclarationCall(n);\n                        if (typeDecls !\u003d null) {\n                            for (String typeDecl : typeDecls) {\n                                compiler.getTypeRegistry().forwardDeclareType(typeDecl);\n                            }\n                        }\n                        parent.replaceChild(n, Node.newNumber(0));\n                        compiler.reportCodeChange();\n                    } else if (\"setCssNameMapping\".equals(methodName)) {\n                        processSetCssNameMapping(t, n, parent);\n                    }\n                }\n            }\n            break;\n        case Token.ASSIGN:\n        case Token.NAME:\n            handleCandidateProvideDefinition(t, n, parent);\n            break;\n        case Token.FUNCTION:\n            if (t.inGlobalScope() \u0026\u0026 !NodeUtil.isFunctionAnonymous(n)) {\n                String name \u003d n.getFirstChild().getString();\n                ProvidedName pn \u003d providedNames.get(name);\n                if (pn !\u003d null) {\n                    compiler.report(t.makeError(n, FUNCTION_NAMESPACE_ERROR, name));\n                }\n            }\n            break;\n        case Token.NEW:\n            trySimplifyNewDate(t, n, parent);\n            break;\n        case Token.GETPROP:\n            if (n.getFirstChild().getType() \u003d\u003d Token.NAME \u0026\u0026 parent.getType() !\u003d Token.CALL \u0026\u0026 parent.getType() !\u003d Token.ASSIGN \u0026\u0026 \"goog.base\".equals(n.getQualifiedName())) {\n                reportBadBaseClassUse(t, n, \"May only be called directly.\");\n            }\n            break;\n    }\n}",
          "path": "src/com/google/javascript/jscomp/ProcessClosurePrimitives.java",
          "functionStartLine": 148,
          "functionName": "visit",
          "functionAnnotation": "@Override",
          "functionDoc": "",
          "diff": "@@ -1,66 +1,67 @@\n+@Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n     switch(n.getType()) {\n         case Token.CALL:\n             boolean isExpr \u003d parent.getType() \u003d\u003d Token.EXPR_RESULT;\n             Node left \u003d n.getFirstChild();\n             if (left.getType() \u003d\u003d Token.GETPROP) {\n                 Node name \u003d left.getFirstChild();\n                 if (name.getType() \u003d\u003d Token.NAME \u0026\u0026 GOOG.equals(name.getString())) {\n                     String methodName \u003d name.getNext().getString();\n                     if (\"base\".equals(methodName)) {\n                         processBaseClassCall(t, n);\n                     } else if (!isExpr) {\n                         break;\n                     } else if (\"require\".equals(methodName)) {\n                         processRequireCall(t, n, parent);\n                     } else if (\"provide\".equals(methodName)) {\n                         processProvideCall(t, n, parent);\n                     } else if (\"exportSymbol\".equals(methodName)) {\n                         Node arg \u003d left.getNext();\n                         if (arg.getType() \u003d\u003d Token.STRING) {\n                             int dot \u003d arg.getString().indexOf(\u0027.\u0027);\n                             if (dot \u003d\u003d -1) {\n                                 exportedVariables.add(arg.getString());\n                             } else {\n                                 exportedVariables.add(arg.getString().substring(0, dot));\n                             }\n                         }\n                     } else if (\"addDependency\".equals(methodName)) {\n                         CodingConvention convention \u003d compiler.getCodingConvention();\n                         List\u003cString\u003e typeDecls \u003d convention.identifyTypeDeclarationCall(n);\n                         if (typeDecls !\u003d null) {\n                             for (String typeDecl : typeDecls) {\n                                 compiler.getTypeRegistry().forwardDeclareType(typeDecl);\n                             }\n                         }\n                         parent.replaceChild(n, Node.newNumber(0));\n                         compiler.reportCodeChange();\n                     } else if (\"setCssNameMapping\".equals(methodName)) {\n                         processSetCssNameMapping(t, n, parent);\n                     }\n                 }\n             }\n             break;\n         case Token.ASSIGN:\n         case Token.NAME:\n             handleCandidateProvideDefinition(t, n, parent);\n             break;\n         case Token.FUNCTION:\n             if (t.inGlobalScope() \u0026\u0026 !NodeUtil.isFunctionAnonymous(n)) {\n                 String name \u003d n.getFirstChild().getString();\n                 ProvidedName pn \u003d providedNames.get(name);\n                 if (pn !\u003d null) {\n                     compiler.report(t.makeError(n, FUNCTION_NAMESPACE_ERROR, name));\n                 }\n             }\n             break;\n         case Token.NEW:\n             trySimplifyNewDate(t, n, parent);\n             break;\n         case Token.GETPROP:\n             if (n.getFirstChild().getType() \u003d\u003d Token.NAME \u0026\u0026 parent.getType() !\u003d Token.CALL \u0026\u0026 parent.getType() !\u003d Token.ASSIGN \u0026\u0026 \"goog.base\".equals(n.getQualifiedName())) {\n                 reportBadBaseClassUse(t, n, \"May only be called directly.\");\n             }\n             break;\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "",
            "newValue": "@Override"
          }
        },
        {
          "type": "Ydocchange",
          "commitMessage": "\nChange on 2010/04/19 by anatol\n\n        Replace {@inheritDoc} javadoc annotation with @Override.\n        @Override is better as it implies documentation inheritance plus checks\n        that the parent method exists at the compile-time.\n\n        R\u003dnick\n        DELTA\u003d137  (0 added, 70 deleted, 67 changed)\n\nChange on 2010/04/19 by nick\n\n        Change how we resolve types.\n        Instead of leaving shell proxy types around, unbox the proxy types.\n\n        R\u003dandrew,john\n        DELTA\u003d103  (84 added, 5 deleted, 14 changed)\n\nChange on 2010/04/19 by acleung\n\n        Enable Flow Sensitive Inlining by default.\n\n        R\u003djohn\n        DELTA\u003d1  (0 added, 0 deleted, 1 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003dpqvliw\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@191 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "4/19/10, 4:28 PM",
          "commitName": "5da32cba7b68d69acfc535f57f21d652475d256f",
          "commitAuthor": "Nicholas.J.Santos",
          "commitDateOld": "3/29/10, 7:04 AM",
          "commitNameOld": "3cc8b3a5889f8b88ef7a2bd0b8ccea8cb0d916c4",
          "commitAuthorOld": "Nicholas.J.Santos",
          "daysBetweenCommits": 21.39,
          "commitsBetweenForRepo": 29,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.CALL:\n            boolean isExpr \u003d parent.getType() \u003d\u003d Token.EXPR_RESULT;\n            Node left \u003d n.getFirstChild();\n            if (left.getType() \u003d\u003d Token.GETPROP) {\n                Node name \u003d left.getFirstChild();\n                if (name.getType() \u003d\u003d Token.NAME \u0026\u0026 GOOG.equals(name.getString())) {\n                    String methodName \u003d name.getNext().getString();\n                    if (\"base\".equals(methodName)) {\n                        processBaseClassCall(t, n);\n                    } else if (!isExpr) {\n                        break;\n                    } else if (\"require\".equals(methodName)) {\n                        processRequireCall(t, n, parent);\n                    } else if (\"provide\".equals(methodName)) {\n                        processProvideCall(t, n, parent);\n                    } else if (\"exportSymbol\".equals(methodName)) {\n                        Node arg \u003d left.getNext();\n                        if (arg.getType() \u003d\u003d Token.STRING) {\n                            int dot \u003d arg.getString().indexOf(\u0027.\u0027);\n                            if (dot \u003d\u003d -1) {\n                                exportedVariables.add(arg.getString());\n                            } else {\n                                exportedVariables.add(arg.getString().substring(0, dot));\n                            }\n                        }\n                    } else if (\"addDependency\".equals(methodName)) {\n                        CodingConvention convention \u003d compiler.getCodingConvention();\n                        List\u003cString\u003e typeDecls \u003d convention.identifyTypeDeclarationCall(n);\n                        if (typeDecls !\u003d null) {\n                            for (String typeDecl : typeDecls) {\n                                compiler.getTypeRegistry().forwardDeclareType(typeDecl);\n                            }\n                        }\n                        parent.replaceChild(n, Node.newNumber(0));\n                        compiler.reportCodeChange();\n                    } else if (\"setCssNameMapping\".equals(methodName)) {\n                        processSetCssNameMapping(t, n, parent);\n                    }\n                }\n            }\n            break;\n        case Token.ASSIGN:\n        case Token.NAME:\n            handleCandidateProvideDefinition(t, n, parent);\n            break;\n        case Token.FUNCTION:\n            if (t.inGlobalScope() \u0026\u0026 !NodeUtil.isFunctionAnonymous(n)) {\n                String name \u003d n.getFirstChild().getString();\n                ProvidedName pn \u003d providedNames.get(name);\n                if (pn !\u003d null) {\n                    compiler.report(t.makeError(n, FUNCTION_NAMESPACE_ERROR, name));\n                }\n            }\n            break;\n        case Token.NEW:\n            trySimplifyNewDate(t, n, parent);\n            break;\n        case Token.GETPROP:\n            if (n.getFirstChild().getType() \u003d\u003d Token.NAME \u0026\u0026 parent.getType() !\u003d Token.CALL \u0026\u0026 parent.getType() !\u003d Token.ASSIGN \u0026\u0026 \"goog.base\".equals(n.getQualifiedName())) {\n                reportBadBaseClassUse(t, n, \"May only be called directly.\");\n            }\n            break;\n    }\n}",
          "path": "src/com/google/javascript/jscomp/ProcessClosurePrimitives.java",
          "functionStartLine": 148,
          "functionName": "visit",
          "functionAnnotation": "@Override",
          "functionDoc": "",
          "diff": "@@ -1,66 +1,67 @@\n+@Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n     switch(n.getType()) {\n         case Token.CALL:\n             boolean isExpr \u003d parent.getType() \u003d\u003d Token.EXPR_RESULT;\n             Node left \u003d n.getFirstChild();\n             if (left.getType() \u003d\u003d Token.GETPROP) {\n                 Node name \u003d left.getFirstChild();\n                 if (name.getType() \u003d\u003d Token.NAME \u0026\u0026 GOOG.equals(name.getString())) {\n                     String methodName \u003d name.getNext().getString();\n                     if (\"base\".equals(methodName)) {\n                         processBaseClassCall(t, n);\n                     } else if (!isExpr) {\n                         break;\n                     } else if (\"require\".equals(methodName)) {\n                         processRequireCall(t, n, parent);\n                     } else if (\"provide\".equals(methodName)) {\n                         processProvideCall(t, n, parent);\n                     } else if (\"exportSymbol\".equals(methodName)) {\n                         Node arg \u003d left.getNext();\n                         if (arg.getType() \u003d\u003d Token.STRING) {\n                             int dot \u003d arg.getString().indexOf(\u0027.\u0027);\n                             if (dot \u003d\u003d -1) {\n                                 exportedVariables.add(arg.getString());\n                             } else {\n                                 exportedVariables.add(arg.getString().substring(0, dot));\n                             }\n                         }\n                     } else if (\"addDependency\".equals(methodName)) {\n                         CodingConvention convention \u003d compiler.getCodingConvention();\n                         List\u003cString\u003e typeDecls \u003d convention.identifyTypeDeclarationCall(n);\n                         if (typeDecls !\u003d null) {\n                             for (String typeDecl : typeDecls) {\n                                 compiler.getTypeRegistry().forwardDeclareType(typeDecl);\n                             }\n                         }\n                         parent.replaceChild(n, Node.newNumber(0));\n                         compiler.reportCodeChange();\n                     } else if (\"setCssNameMapping\".equals(methodName)) {\n                         processSetCssNameMapping(t, n, parent);\n                     }\n                 }\n             }\n             break;\n         case Token.ASSIGN:\n         case Token.NAME:\n             handleCandidateProvideDefinition(t, n, parent);\n             break;\n         case Token.FUNCTION:\n             if (t.inGlobalScope() \u0026\u0026 !NodeUtil.isFunctionAnonymous(n)) {\n                 String name \u003d n.getFirstChild().getString();\n                 ProvidedName pn \u003d providedNames.get(name);\n                 if (pn !\u003d null) {\n                     compiler.report(t.makeError(n, FUNCTION_NAMESPACE_ERROR, name));\n                 }\n             }\n             break;\n         case Token.NEW:\n             trySimplifyNewDate(t, n, parent);\n             break;\n         case Token.GETPROP:\n             if (n.getFirstChild().getType() \u003d\u003d Token.NAME \u0026\u0026 parent.getType() !\u003d Token.CALL \u0026\u0026 parent.getType() !\u003d Token.ASSIGN \u0026\u0026 \"goog.base\".equals(n.getQualifiedName())) {\n                 reportBadBaseClassUse(t, n, \"May only be called directly.\");\n             }\n             break;\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "@inheritDoc}\n",
            "newValue": ""
          }
        }
      ]
    },
    "3cc8b3a5889f8b88ef7a2bd0b8ccea8cb0d916c4": {
      "type": "Ybodychange",
      "commitMessage": "Remove circular dependency between error-reporting and the rest\nof the compiler. (Nick)\nR\u003dalan\nDELTA\u003d152  (27 added, 28 deleted, 97 changed)\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@159 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "3/29/10, 7:04 AM",
      "commitName": "3cc8b3a5889f8b88ef7a2bd0b8ccea8cb0d916c4",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "2/26/10, 3:45 PM",
      "commitNameOld": "50c1b3d39ff5b17c956a2235f97f7b5da05ab6f0",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 30.6,
      "commitsBetweenForRepo": 41,
      "commitsBetweenForFile": 1,
      "actualSource": "public void visit(NodeTraversal t, Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.CALL:\n            boolean isExpr \u003d parent.getType() \u003d\u003d Token.EXPR_RESULT;\n            Node left \u003d n.getFirstChild();\n            if (left.getType() \u003d\u003d Token.GETPROP) {\n                Node name \u003d left.getFirstChild();\n                if (name.getType() \u003d\u003d Token.NAME \u0026\u0026 GOOG.equals(name.getString())) {\n                    String methodName \u003d name.getNext().getString();\n                    if (\"base\".equals(methodName)) {\n                        processBaseClassCall(t, n);\n                    } else if (!isExpr) {\n                        break;\n                    } else if (\"require\".equals(methodName)) {\n                        processRequireCall(t, n, parent);\n                    } else if (\"provide\".equals(methodName)) {\n                        processProvideCall(t, n, parent);\n                    } else if (\"exportSymbol\".equals(methodName)) {\n                        Node arg \u003d left.getNext();\n                        if (arg.getType() \u003d\u003d Token.STRING) {\n                            int dot \u003d arg.getString().indexOf(\u0027.\u0027);\n                            if (dot \u003d\u003d -1) {\n                                exportedVariables.add(arg.getString());\n                            } else {\n                                exportedVariables.add(arg.getString().substring(0, dot));\n                            }\n                        }\n                    } else if (\"addDependency\".equals(methodName)) {\n                        CodingConvention convention \u003d compiler.getCodingConvention();\n                        List\u003cString\u003e typeDecls \u003d convention.identifyTypeDeclarationCall(n);\n                        if (typeDecls !\u003d null) {\n                            for (String typeDecl : typeDecls) {\n                                compiler.getTypeRegistry().forwardDeclareType(typeDecl);\n                            }\n                        }\n                        parent.replaceChild(n, Node.newNumber(0));\n                        compiler.reportCodeChange();\n                    } else if (\"setCssNameMapping\".equals(methodName)) {\n                        processSetCssNameMapping(t, n, parent);\n                    }\n                }\n            }\n            break;\n        case Token.ASSIGN:\n        case Token.NAME:\n            handleCandidateProvideDefinition(t, n, parent);\n            break;\n        case Token.FUNCTION:\n            if (t.inGlobalScope() \u0026\u0026 !NodeUtil.isFunctionAnonymous(n)) {\n                String name \u003d n.getFirstChild().getString();\n                ProvidedName pn \u003d providedNames.get(name);\n                if (pn !\u003d null) {\n                    compiler.report(t.makeError(n, FUNCTION_NAMESPACE_ERROR, name));\n                }\n            }\n            break;\n        case Token.NEW:\n            trySimplifyNewDate(t, n, parent);\n            break;\n        case Token.GETPROP:\n            if (n.getFirstChild().getType() \u003d\u003d Token.NAME \u0026\u0026 parent.getType() !\u003d Token.CALL \u0026\u0026 parent.getType() !\u003d Token.ASSIGN \u0026\u0026 \"goog.base\".equals(n.getQualifiedName())) {\n                reportBadBaseClassUse(t, n, \"May only be called directly.\");\n            }\n            break;\n    }\n}",
      "path": "src/com/google/javascript/jscomp/ProcessClosurePrimitives.java",
      "functionStartLine": 152,
      "functionName": "visit",
      "functionAnnotation": "",
      "functionDoc": "@inheritDoc}\n",
      "diff": "@@ -1,66 +1,66 @@\n public void visit(NodeTraversal t, Node n, Node parent) {\n     switch(n.getType()) {\n         case Token.CALL:\n             boolean isExpr \u003d parent.getType() \u003d\u003d Token.EXPR_RESULT;\n             Node left \u003d n.getFirstChild();\n             if (left.getType() \u003d\u003d Token.GETPROP) {\n                 Node name \u003d left.getFirstChild();\n                 if (name.getType() \u003d\u003d Token.NAME \u0026\u0026 GOOG.equals(name.getString())) {\n                     String methodName \u003d name.getNext().getString();\n                     if (\"base\".equals(methodName)) {\n                         processBaseClassCall(t, n);\n                     } else if (!isExpr) {\n                         break;\n                     } else if (\"require\".equals(methodName)) {\n                         processRequireCall(t, n, parent);\n                     } else if (\"provide\".equals(methodName)) {\n                         processProvideCall(t, n, parent);\n                     } else if (\"exportSymbol\".equals(methodName)) {\n                         Node arg \u003d left.getNext();\n                         if (arg.getType() \u003d\u003d Token.STRING) {\n                             int dot \u003d arg.getString().indexOf(\u0027.\u0027);\n                             if (dot \u003d\u003d -1) {\n                                 exportedVariables.add(arg.getString());\n                             } else {\n                                 exportedVariables.add(arg.getString().substring(0, dot));\n                             }\n                         }\n                     } else if (\"addDependency\".equals(methodName)) {\n                         CodingConvention convention \u003d compiler.getCodingConvention();\n                         List\u003cString\u003e typeDecls \u003d convention.identifyTypeDeclarationCall(n);\n                         if (typeDecls !\u003d null) {\n                             for (String typeDecl : typeDecls) {\n                                 compiler.getTypeRegistry().forwardDeclareType(typeDecl);\n                             }\n                         }\n                         parent.replaceChild(n, Node.newNumber(0));\n                         compiler.reportCodeChange();\n                     } else if (\"setCssNameMapping\".equals(methodName)) {\n                         processSetCssNameMapping(t, n, parent);\n                     }\n                 }\n             }\n             break;\n         case Token.ASSIGN:\n         case Token.NAME:\n             handleCandidateProvideDefinition(t, n, parent);\n             break;\n         case Token.FUNCTION:\n             if (t.inGlobalScope() \u0026\u0026 !NodeUtil.isFunctionAnonymous(n)) {\n                 String name \u003d n.getFirstChild().getString();\n                 ProvidedName pn \u003d providedNames.get(name);\n                 if (pn !\u003d null) {\n-                    compiler.report(JSError.make(t, n, FUNCTION_NAMESPACE_ERROR, name));\n+                    compiler.report(t.makeError(n, FUNCTION_NAMESPACE_ERROR, name));\n                 }\n             }\n             break;\n         case Token.NEW:\n             trySimplifyNewDate(t, n, parent);\n             break;\n         case Token.GETPROP:\n             if (n.getFirstChild().getType() \u003d\u003d Token.NAME \u0026\u0026 parent.getType() !\u003d Token.CALL \u0026\u0026 parent.getType() !\u003d Token.ASSIGN \u0026\u0026 \"goog.base\".equals(n.getQualifiedName())) {\n                 reportBadBaseClassUse(t, n, \"May only be called directly.\");\n             }\n             break;\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "45f2bdf91ad3c2f2ac901c72efe9e26148b08d2b": {
      "type": "Ybodychange",
      "commitMessage": "Fix a bunch of passes to preserve more type information.\n\nFix goog.provide/goog.require handling to work in the presence of modules.\n\nImprove a bunch of type annotations in gecko_dom.\n\nMake NameAnalyzer use the Graph package.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@95 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "2/8/10, 11:30 AM",
      "commitName": "45f2bdf91ad3c2f2ac901c72efe9e26148b08d2b",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "2/5/10, 11:27 AM",
      "commitNameOld": "1046b0c09e2371f8924f72331d42db5b554c4a32",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 3.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public void visit(NodeTraversal t, Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.CALL:\n            boolean isExpr \u003d parent.getType() \u003d\u003d Token.EXPR_RESULT;\n            Node left \u003d n.getFirstChild();\n            if (left.getType() \u003d\u003d Token.GETPROP) {\n                Node name \u003d left.getFirstChild();\n                if (name.getType() \u003d\u003d Token.NAME \u0026\u0026 GOOG.equals(name.getString())) {\n                    String methodName \u003d name.getNext().getString();\n                    if (\"base\".equals(methodName)) {\n                        processBaseClassCall(t, n);\n                    } else if (!isExpr) {\n                        break;\n                    } else if (\"require\".equals(methodName)) {\n                        processRequireCall(t, n, parent);\n                    } else if (\"provide\".equals(methodName)) {\n                        processProvideCall(t, n, parent);\n                    } else if (\"exportSymbol\".equals(methodName)) {\n                        Node arg \u003d left.getNext();\n                        if (arg.getType() \u003d\u003d Token.STRING) {\n                            int dot \u003d arg.getString().indexOf(\u0027.\u0027);\n                            if (dot \u003d\u003d -1) {\n                                exportedVariables.add(arg.getString());\n                            } else {\n                                exportedVariables.add(arg.getString().substring(0, dot));\n                            }\n                        }\n                    } else if (\"addDependency\".equals(methodName)) {\n                        CodingConvention convention \u003d compiler.getCodingConvention();\n                        List\u003cString\u003e typeDecls \u003d convention.identifyTypeDeclarationCall(n);\n                        if (typeDecls !\u003d null) {\n                            for (String typeDecl : typeDecls) {\n                                compiler.getTypeRegistry().forwardDeclareType(typeDecl);\n                            }\n                        }\n                        parent.replaceChild(n, Node.newNumber(0));\n                        compiler.reportCodeChange();\n                    } else if (\"setCssNameMapping\".equals(methodName)) {\n                        processSetCssNameMapping(t, n, parent);\n                    }\n                }\n            }\n            break;\n        case Token.ASSIGN:\n        case Token.NAME:\n            handleCandidateProvideDefinition(t, n, parent);\n            break;\n        case Token.FUNCTION:\n            if (t.inGlobalScope() \u0026\u0026 !NodeUtil.isFunctionAnonymous(n)) {\n                String name \u003d n.getFirstChild().getString();\n                ProvidedName pn \u003d providedNames.get(name);\n                if (pn !\u003d null) {\n                    compiler.report(JSError.make(t, n, FUNCTION_NAMESPACE_ERROR, name));\n                }\n            }\n            break;\n        case Token.NEW:\n            trySimplifyNewDate(t, n, parent);\n            break;\n        case Token.GETPROP:\n            if (n.getFirstChild().getType() \u003d\u003d Token.NAME \u0026\u0026 parent.getType() !\u003d Token.CALL \u0026\u0026 parent.getType() !\u003d Token.ASSIGN \u0026\u0026 \"goog.base\".equals(n.getQualifiedName())) {\n                reportBadBaseClassUse(t, n, \"May only be called directly.\");\n            }\n            break;\n    }\n}",
      "path": "src/com/google/javascript/jscomp/ProcessClosurePrimitives.java",
      "functionStartLine": 151,
      "functionName": "visit",
      "functionAnnotation": "",
      "functionDoc": "@inheritDoc}\n",
      "diff": "@@ -1,121 +1,66 @@\n public void visit(NodeTraversal t, Node n, Node parent) {\n     switch(n.getType()) {\n         case Token.CALL:\n             boolean isExpr \u003d parent.getType() \u003d\u003d Token.EXPR_RESULT;\n             Node left \u003d n.getFirstChild();\n             if (left.getType() \u003d\u003d Token.GETPROP) {\n                 Node name \u003d left.getFirstChild();\n                 if (name.getType() \u003d\u003d Token.NAME \u0026\u0026 GOOG.equals(name.getString())) {\n                     String methodName \u003d name.getNext().getString();\n                     if (\"base\".equals(methodName)) {\n                         processBaseClassCall(t, n);\n                     } else if (!isExpr) {\n                         break;\n                     } else if (\"require\".equals(methodName)) {\n-                        Node arg \u003d left.getNext();\n-                        if (verifyArgument(t, left, arg)) {\n-                            String ns \u003d arg.getString();\n-                            ProvidedName provided \u003d providedNames.get(ns);\n-                            if (provided \u003d\u003d null || !provided.isExplicitlyProvided()) {\n-                                unrecognizedRequires.add(new UnrecognizedRequire(n, ns, t.getSourceName()));\n-                            } else {\n-                                JSModule module \u003d t.getModule();\n-                                if (module !\u003d provided.firstModule \u0026\u0026 !compiler.getModuleGraph().dependsOn(module, provided.firstModule)) {\n-                                    compiler.report(JSError.make(t, n, XMODULE_REQUIRE_ERROR, ns, provided.firstModule.getName(), module.getName()));\n-                                }\n-                            }\n-                            if (provided !\u003d null || requiresLevel.isOn()) {\n-                                parent.getParent().removeChild(parent);\n-                                compiler.reportCodeChange();\n-                            }\n-                        }\n+                        processRequireCall(t, n, parent);\n                     } else if (\"provide\".equals(methodName)) {\n-                        Node arg \u003d left.getNext();\n-                        if (verifyProvide(t, left, arg)) {\n-                            String ns \u003d arg.getString();\n-                            if (providedNames.containsKey(ns)) {\n-                                ProvidedName previouslyProvided \u003d providedNames.get(ns);\n-                                if (!previouslyProvided.isExplicitlyProvided()) {\n-                                    previouslyProvided.addProvide(parent, t.getModule(), true);\n-                                } else {\n-                                    compiler.report(JSError.make(t, n, DUPLICATE_NAMESPACE_ERROR, ns));\n-                                }\n-                            } else {\n-                                registerAnyProvidedPrefixes(ns, parent, t.getModule());\n-                                providedNames.put(ns, new ProvidedName(ns, parent, t.getModule(), true));\n-                            }\n-                        }\n+                        processProvideCall(t, n, parent);\n                     } else if (\"exportSymbol\".equals(methodName)) {\n                         Node arg \u003d left.getNext();\n                         if (arg.getType() \u003d\u003d Token.STRING) {\n                             int dot \u003d arg.getString().indexOf(\u0027.\u0027);\n                             if (dot \u003d\u003d -1) {\n                                 exportedVariables.add(arg.getString());\n                             } else {\n                                 exportedVariables.add(arg.getString().substring(0, dot));\n                             }\n                         }\n                     } else if (\"addDependency\".equals(methodName)) {\n                         CodingConvention convention \u003d compiler.getCodingConvention();\n                         List\u003cString\u003e typeDecls \u003d convention.identifyTypeDeclarationCall(n);\n                         if (typeDecls !\u003d null) {\n                             for (String typeDecl : typeDecls) {\n                                 compiler.getTypeRegistry().forwardDeclareType(typeDecl);\n                             }\n                         }\n                         parent.replaceChild(n, Node.newNumber(0));\n                         compiler.reportCodeChange();\n                     } else if (\"setCssNameMapping\".equals(methodName)) {\n                         processSetCssNameMapping(t, n, parent);\n                     }\n                 }\n             }\n             break;\n         case Token.ASSIGN:\n-            if (t.inGlobalScope() \u0026\u0026 parent.getType() \u003d\u003d Token.EXPR_RESULT) {\n-                Node nameNode \u003d n.getFirstChild();\n-                String name \u003d nameNode.getQualifiedName();\n-                if (name !\u003d null) {\n-                    if (parent.getBooleanProp(Node.IS_NAMESPACE)) {\n-                        processProvideFromPreviousPass(t, name, parent);\n-                    } else {\n-                        ProvidedName pn \u003d providedNames.get(name);\n-                        if (pn !\u003d null) {\n-                            pn.addDefinition(parent);\n-                        }\n-                    }\n-                }\n-            }\n-            break;\n         case Token.NAME:\n-            if (t.inGlobalScope() \u0026\u0026 parent.getType() \u003d\u003d Token.VAR) {\n-                String name \u003d n.getString();\n-                if (parent.getBooleanProp(Node.IS_NAMESPACE)) {\n-                    processProvideFromPreviousPass(t, name, parent);\n-                } else {\n-                    ProvidedName pn \u003d providedNames.get(name);\n-                    if (pn !\u003d null) {\n-                        pn.addDefinition(parent);\n-                    }\n-                }\n-            }\n+            handleCandidateProvideDefinition(t, n, parent);\n             break;\n         case Token.FUNCTION:\n             if (t.inGlobalScope() \u0026\u0026 !NodeUtil.isFunctionAnonymous(n)) {\n                 String name \u003d n.getFirstChild().getString();\n                 ProvidedName pn \u003d providedNames.get(name);\n                 if (pn !\u003d null) {\n                     compiler.report(JSError.make(t, n, FUNCTION_NAMESPACE_ERROR, name));\n                 }\n             }\n             break;\n         case Token.NEW:\n             trySimplifyNewDate(t, n, parent);\n             break;\n         case Token.GETPROP:\n             if (n.getFirstChild().getType() \u003d\u003d Token.NAME \u0026\u0026 parent.getType() !\u003d Token.CALL \u0026\u0026 parent.getType() !\u003d Token.ASSIGN \u0026\u0026 \"goog.base\".equals(n.getQualifiedName())) {\n                 reportBadBaseClassUse(t, n, \"May only be called directly.\");\n             }\n             break;\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1046b0c09e2371f8924f72331d42db5b554c4a32": {
      "type": "Ybodychange",
      "commitMessage": "Rewrite ProcessClosurePrimitives to have a distinct indexing and mutation step.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@94 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "2/5/10, 11:27 AM",
      "commitName": "1046b0c09e2371f8924f72331d42db5b554c4a32",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "2/3/10, 7:26 AM",
      "commitNameOld": "449fdd3c1163cf42d9caa4e7382e37f20f2ca6ac",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 2.17,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "public void visit(NodeTraversal t, Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.CALL:\n            boolean isExpr \u003d parent.getType() \u003d\u003d Token.EXPR_RESULT;\n            Node left \u003d n.getFirstChild();\n            if (left.getType() \u003d\u003d Token.GETPROP) {\n                Node name \u003d left.getFirstChild();\n                if (name.getType() \u003d\u003d Token.NAME \u0026\u0026 GOOG.equals(name.getString())) {\n                    String methodName \u003d name.getNext().getString();\n                    if (\"base\".equals(methodName)) {\n                        processBaseClassCall(t, n);\n                    } else if (!isExpr) {\n                        break;\n                    } else if (\"require\".equals(methodName)) {\n                        Node arg \u003d left.getNext();\n                        if (verifyArgument(t, left, arg)) {\n                            String ns \u003d arg.getString();\n                            ProvidedName provided \u003d providedNames.get(ns);\n                            if (provided \u003d\u003d null || !provided.isExplicitlyProvided()) {\n                                unrecognizedRequires.add(new UnrecognizedRequire(n, ns, t.getSourceName()));\n                            } else {\n                                JSModule module \u003d t.getModule();\n                                if (module !\u003d provided.firstModule \u0026\u0026 !compiler.getModuleGraph().dependsOn(module, provided.firstModule)) {\n                                    compiler.report(JSError.make(t, n, XMODULE_REQUIRE_ERROR, ns, provided.firstModule.getName(), module.getName()));\n                                }\n                            }\n                            if (provided !\u003d null || requiresLevel.isOn()) {\n                                parent.getParent().removeChild(parent);\n                                compiler.reportCodeChange();\n                            }\n                        }\n                    } else if (\"provide\".equals(methodName)) {\n                        Node arg \u003d left.getNext();\n                        if (verifyProvide(t, left, arg)) {\n                            String ns \u003d arg.getString();\n                            if (providedNames.containsKey(ns)) {\n                                ProvidedName previouslyProvided \u003d providedNames.get(ns);\n                                if (!previouslyProvided.isExplicitlyProvided()) {\n                                    previouslyProvided.addProvide(parent, t.getModule(), true);\n                                } else {\n                                    compiler.report(JSError.make(t, n, DUPLICATE_NAMESPACE_ERROR, ns));\n                                }\n                            } else {\n                                registerAnyProvidedPrefixes(ns, parent, t.getModule());\n                                providedNames.put(ns, new ProvidedName(ns, parent, t.getModule(), true));\n                            }\n                        }\n                    } else if (\"exportSymbol\".equals(methodName)) {\n                        Node arg \u003d left.getNext();\n                        if (arg.getType() \u003d\u003d Token.STRING) {\n                            int dot \u003d arg.getString().indexOf(\u0027.\u0027);\n                            if (dot \u003d\u003d -1) {\n                                exportedVariables.add(arg.getString());\n                            } else {\n                                exportedVariables.add(arg.getString().substring(0, dot));\n                            }\n                        }\n                    } else if (\"addDependency\".equals(methodName)) {\n                        CodingConvention convention \u003d compiler.getCodingConvention();\n                        List\u003cString\u003e typeDecls \u003d convention.identifyTypeDeclarationCall(n);\n                        if (typeDecls !\u003d null) {\n                            for (String typeDecl : typeDecls) {\n                                compiler.getTypeRegistry().forwardDeclareType(typeDecl);\n                            }\n                        }\n                        parent.replaceChild(n, Node.newNumber(0));\n                        compiler.reportCodeChange();\n                    } else if (\"setCssNameMapping\".equals(methodName)) {\n                        processSetCssNameMapping(t, n, parent);\n                    }\n                }\n            }\n            break;\n        case Token.ASSIGN:\n            if (t.inGlobalScope() \u0026\u0026 parent.getType() \u003d\u003d Token.EXPR_RESULT) {\n                Node nameNode \u003d n.getFirstChild();\n                String name \u003d nameNode.getQualifiedName();\n                if (name !\u003d null) {\n                    if (parent.getBooleanProp(Node.IS_NAMESPACE)) {\n                        processProvideFromPreviousPass(t, name, parent);\n                    } else {\n                        ProvidedName pn \u003d providedNames.get(name);\n                        if (pn !\u003d null) {\n                            pn.addDefinition(parent);\n                        }\n                    }\n                }\n            }\n            break;\n        case Token.NAME:\n            if (t.inGlobalScope() \u0026\u0026 parent.getType() \u003d\u003d Token.VAR) {\n                String name \u003d n.getString();\n                if (parent.getBooleanProp(Node.IS_NAMESPACE)) {\n                    processProvideFromPreviousPass(t, name, parent);\n                } else {\n                    ProvidedName pn \u003d providedNames.get(name);\n                    if (pn !\u003d null) {\n                        pn.addDefinition(parent);\n                    }\n                }\n            }\n            break;\n        case Token.FUNCTION:\n            if (t.inGlobalScope() \u0026\u0026 !NodeUtil.isFunctionAnonymous(n)) {\n                String name \u003d n.getFirstChild().getString();\n                ProvidedName pn \u003d providedNames.get(name);\n                if (pn !\u003d null) {\n                    compiler.report(JSError.make(t, n, FUNCTION_NAMESPACE_ERROR, name));\n                }\n            }\n            break;\n        case Token.NEW:\n            trySimplifyNewDate(t, n, parent);\n            break;\n        case Token.GETPROP:\n            if (n.getFirstChild().getType() \u003d\u003d Token.NAME \u0026\u0026 parent.getType() !\u003d Token.CALL \u0026\u0026 parent.getType() !\u003d Token.ASSIGN \u0026\u0026 \"goog.base\".equals(n.getQualifiedName())) {\n                reportBadBaseClassUse(t, n, \"May only be called directly.\");\n            }\n            break;\n    }\n}",
      "path": "src/com/google/javascript/jscomp/ProcessClosurePrimitives.java",
      "functionStartLine": 149,
      "functionName": "visit",
      "functionAnnotation": "",
      "functionDoc": "@inheritDoc}\n",
      "diff": "@@ -1,119 +1,121 @@\n public void visit(NodeTraversal t, Node n, Node parent) {\n     switch(n.getType()) {\n         case Token.CALL:\n             boolean isExpr \u003d parent.getType() \u003d\u003d Token.EXPR_RESULT;\n             Node left \u003d n.getFirstChild();\n             if (left.getType() \u003d\u003d Token.GETPROP) {\n                 Node name \u003d left.getFirstChild();\n                 if (name.getType() \u003d\u003d Token.NAME \u0026\u0026 GOOG.equals(name.getString())) {\n                     String methodName \u003d name.getNext().getString();\n                     if (\"base\".equals(methodName)) {\n                         processBaseClassCall(t, n);\n                     } else if (!isExpr) {\n                         break;\n                     } else if (\"require\".equals(methodName)) {\n                         Node arg \u003d left.getNext();\n                         if (verifyArgument(t, left, arg)) {\n                             String ns \u003d arg.getString();\n-                            ProvidedNode provided \u003d providedNodes.get(ns);\n-                            if (provided \u003d\u003d null) {\n+                            ProvidedName provided \u003d providedNames.get(ns);\n+                            if (provided \u003d\u003d null || !provided.isExplicitlyProvided()) {\n                                 unrecognizedRequires.add(new UnrecognizedRequire(n, ns, t.getSourceName()));\n                             } else {\n                                 JSModule module \u003d t.getModule();\n-                                if (module !\u003d provided.module \u0026\u0026 !compiler.getModuleGraph().dependsOn(module, provided.module)) {\n-                                    compiler.report(JSError.make(t, n, XMODULE_REQUIRE_ERROR, ns, provided.module.getName(), module.getName()));\n+                                if (module !\u003d provided.firstModule \u0026\u0026 !compiler.getModuleGraph().dependsOn(module, provided.firstModule)) {\n+                                    compiler.report(JSError.make(t, n, XMODULE_REQUIRE_ERROR, ns, provided.firstModule.getName(), module.getName()));\n                                 }\n                             }\n                             if (provided !\u003d null || requiresLevel.isOn()) {\n                                 parent.getParent().removeChild(parent);\n                                 compiler.reportCodeChange();\n                             }\n                         }\n                     } else if (\"provide\".equals(methodName)) {\n                         Node arg \u003d left.getNext();\n                         if (verifyProvide(t, left, arg)) {\n                             String ns \u003d arg.getString();\n-                            if (providedNodes.get(ns) !\u003d null) {\n-                                compiler.report(JSError.make(t, n, DUPLICATE_NAMESPACE_ERROR, ns));\n-                            } else if (!providedNodes.containsKey(ns)) {\n-                                replaceProvide(t, parent, parent.getParent(), ns);\n+                            if (providedNames.containsKey(ns)) {\n+                                ProvidedName previouslyProvided \u003d providedNames.get(ns);\n+                                if (!previouslyProvided.isExplicitlyProvided()) {\n+                                    previouslyProvided.addProvide(parent, t.getModule(), true);\n+                                } else {\n+                                    compiler.report(JSError.make(t, n, DUPLICATE_NAMESPACE_ERROR, ns));\n+                                }\n                             } else {\n-                                parent.getParent().removeChild(parent);\n-                                providedNodes.put(ns, new ProvidedNode(null, null, t.getModule()));\n+                                registerAnyProvidedPrefixes(ns, parent, t.getModule());\n+                                providedNames.put(ns, new ProvidedName(ns, parent, t.getModule(), true));\n                             }\n-                            compiler.reportCodeChange();\n                         }\n                     } else if (\"exportSymbol\".equals(methodName)) {\n                         Node arg \u003d left.getNext();\n                         if (arg.getType() \u003d\u003d Token.STRING) {\n                             int dot \u003d arg.getString().indexOf(\u0027.\u0027);\n                             if (dot \u003d\u003d -1) {\n                                 exportedVariables.add(arg.getString());\n                             } else {\n                                 exportedVariables.add(arg.getString().substring(0, dot));\n                             }\n                         }\n                     } else if (\"addDependency\".equals(methodName)) {\n                         CodingConvention convention \u003d compiler.getCodingConvention();\n                         List\u003cString\u003e typeDecls \u003d convention.identifyTypeDeclarationCall(n);\n                         if (typeDecls !\u003d null) {\n                             for (String typeDecl : typeDecls) {\n                                 compiler.getTypeRegistry().forwardDeclareType(typeDecl);\n                             }\n                         }\n                         parent.replaceChild(n, Node.newNumber(0));\n                         compiler.reportCodeChange();\n                     } else if (\"setCssNameMapping\".equals(methodName)) {\n                         processSetCssNameMapping(t, n, parent);\n                     }\n                 }\n             }\n             break;\n         case Token.ASSIGN:\n             if (t.inGlobalScope() \u0026\u0026 parent.getType() \u003d\u003d Token.EXPR_RESULT) {\n                 Node nameNode \u003d n.getFirstChild();\n                 String name \u003d nameNode.getQualifiedName();\n                 if (name !\u003d null) {\n                     if (parent.getBooleanProp(Node.IS_NAMESPACE)) {\n                         processProvideFromPreviousPass(t, name, parent);\n                     } else {\n-                        ProvidedNode pn \u003d providedNodes.get(name);\n+                        ProvidedName pn \u003d providedNames.get(name);\n                         if (pn !\u003d null) {\n-                            pn.addCandidate(parent, parent.getParent());\n+                            pn.addDefinition(parent);\n                         }\n                     }\n                 }\n             }\n             break;\n         case Token.NAME:\n             if (t.inGlobalScope() \u0026\u0026 parent.getType() \u003d\u003d Token.VAR) {\n                 String name \u003d n.getString();\n                 if (parent.getBooleanProp(Node.IS_NAMESPACE)) {\n                     processProvideFromPreviousPass(t, name, parent);\n                 } else {\n-                    ProvidedNode pn \u003d providedNodes.get(name);\n+                    ProvidedName pn \u003d providedNames.get(name);\n                     if (pn !\u003d null) {\n-                        pn.addCandidate(parent, parent.getParent());\n+                        pn.addDefinition(parent);\n                     }\n                 }\n             }\n             break;\n         case Token.FUNCTION:\n             if (t.inGlobalScope() \u0026\u0026 !NodeUtil.isFunctionAnonymous(n)) {\n                 String name \u003d n.getFirstChild().getString();\n-                ProvidedNode pn \u003d providedNodes.get(name);\n+                ProvidedName pn \u003d providedNames.get(name);\n                 if (pn !\u003d null) {\n                     compiler.report(JSError.make(t, n, FUNCTION_NAMESPACE_ERROR, name));\n                 }\n             }\n             break;\n         case Token.NEW:\n             trySimplifyNewDate(t, n, parent);\n             break;\n         case Token.GETPROP:\n             if (n.getFirstChild().getType() \u003d\u003d Token.NAME \u0026\u0026 parent.getType() !\u003d Token.CALL \u0026\u0026 parent.getType() !\u003d Token.ASSIGN \u0026\u0026 \"goog.base\".equals(n.getQualifiedName())) {\n                 reportBadBaseClassUse(t, n, \"May only be called directly.\");\n             }\n             break;\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6a6ea480bae01f40f9795218ac911bb7de18d34a": {
      "type": "Ybodychange",
      "commitMessage": "Don\u0027t warn about duplicate variable declarations unless warning_level is\nset to VERBOSE.\n\nImplementation of libary function goog.base.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@13 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/19/09, 1:23 PM",
      "commitName": "6a6ea480bae01f40f9795218ac911bb7de18d34a",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "commitDateOld": "11/11/09, 11:05 AM",
      "commitNameOld": "6a36f04485599820ff86441accee002b4deec2eb",
      "commitAuthorOld": "nicholas.j.santos@gmail.com",
      "daysBetweenCommits": 8.1,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "public void visit(NodeTraversal t, Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.CALL:\n            boolean isExpr \u003d parent.getType() \u003d\u003d Token.EXPR_RESULT;\n            Node left \u003d n.getFirstChild();\n            if (left.getType() \u003d\u003d Token.GETPROP) {\n                Node name \u003d left.getFirstChild();\n                if (name.getType() \u003d\u003d Token.NAME \u0026\u0026 GOOG.equals(name.getString())) {\n                    String methodName \u003d name.getNext().getString();\n                    if (\"base\".equals(methodName)) {\n                        processBaseClassCall(t, n);\n                    } else if (!isExpr) {\n                        break;\n                    } else if (\"require\".equals(methodName)) {\n                        Node arg \u003d left.getNext();\n                        if (verifyArgument(t, left, arg)) {\n                            String ns \u003d arg.getString();\n                            ProvidedNode provided \u003d providedNodes.get(ns);\n                            if (provided \u003d\u003d null) {\n                                unrecognizedRequires.add(new UnrecognizedRequire(n, ns, t.getSourceName()));\n                            } else {\n                                JSModule module \u003d t.getModule();\n                                if (module !\u003d provided.module \u0026\u0026 !compiler.getModuleGraph().dependsOn(module, provided.module)) {\n                                    compiler.report(JSError.make(t, n, XMODULE_REQUIRE_ERROR, ns, provided.module.getName(), module.getName()));\n                                }\n                            }\n                            if (provided !\u003d null || requiresLevel.isOn()) {\n                                parent.getParent().removeChild(parent);\n                                compiler.reportCodeChange();\n                            }\n                        }\n                    } else if (\"provide\".equals(methodName)) {\n                        Node arg \u003d left.getNext();\n                        if (verifyProvide(t, left, arg)) {\n                            String ns \u003d arg.getString();\n                            if (providedNodes.get(ns) !\u003d null) {\n                                compiler.report(JSError.make(t, n, DUPLICATE_NAMESPACE_ERROR, ns));\n                            } else if (!providedNodes.containsKey(ns)) {\n                                replaceProvide(t, parent, parent.getParent(), ns);\n                            } else {\n                                parent.getParent().removeChild(parent);\n                                providedNodes.put(ns, new ProvidedNode(null, null, t.getModule()));\n                            }\n                            compiler.reportCodeChange();\n                        }\n                    } else if (\"exportSymbol\".equals(methodName)) {\n                        Node arg \u003d left.getNext();\n                        if (arg.getType() \u003d\u003d Token.STRING) {\n                            int dot \u003d arg.getString().indexOf(\u0027.\u0027);\n                            if (dot \u003d\u003d -1) {\n                                exportedVariables.add(arg.getString());\n                            } else {\n                                exportedVariables.add(arg.getString().substring(0, dot));\n                            }\n                        }\n                    } else if (\"addDependency\".equals(methodName)) {\n                        CodingConvention convention \u003d compiler.getCodingConvention();\n                        List\u003cString\u003e typeDecls \u003d convention.identifyTypeDeclarationCall(n);\n                        if (typeDecls !\u003d null) {\n                            for (String typeDecl : typeDecls) {\n                                compiler.getTypeRegistry().forwardDeclareType(typeDecl);\n                            }\n                        }\n                        parent.replaceChild(n, Node.newNumber(0));\n                        compiler.reportCodeChange();\n                    } else if (\"setCssNameMapping\".equals(methodName)) {\n                        processSetCssNameMapping(t, n, parent);\n                    }\n                }\n            }\n            break;\n        case Token.ASSIGN:\n            if (t.inGlobalScope() \u0026\u0026 parent.getType() \u003d\u003d Token.EXPR_RESULT) {\n                Node nameNode \u003d n.getFirstChild();\n                String name \u003d nameNode.getQualifiedName();\n                if (name !\u003d null) {\n                    if (parent.getBooleanProp(Node.IS_NAMESPACE)) {\n                        processProvideFromPreviousPass(t, name, parent);\n                    } else {\n                        ProvidedNode pn \u003d providedNodes.get(name);\n                        if (pn !\u003d null) {\n                            pn.addCandidate(parent, parent.getParent());\n                        }\n                    }\n                }\n            }\n            break;\n        case Token.NAME:\n            if (t.inGlobalScope() \u0026\u0026 parent.getType() \u003d\u003d Token.VAR) {\n                String name \u003d n.getString();\n                if (parent.getBooleanProp(Node.IS_NAMESPACE)) {\n                    processProvideFromPreviousPass(t, name, parent);\n                } else {\n                    ProvidedNode pn \u003d providedNodes.get(name);\n                    if (pn !\u003d null) {\n                        pn.addCandidate(parent, parent.getParent());\n                    }\n                }\n            }\n            break;\n        case Token.FUNCTION:\n            if (t.inGlobalScope() \u0026\u0026 !NodeUtil.isFunctionAnonymous(n)) {\n                String name \u003d n.getFirstChild().getString();\n                ProvidedNode pn \u003d providedNodes.get(name);\n                if (pn !\u003d null) {\n                    compiler.report(JSError.make(t, n, FUNCTION_NAMESPACE_ERROR, name));\n                }\n            }\n            break;\n        case Token.NEW:\n            trySimplifyNewDate(t, n, parent);\n            break;\n        case Token.GETPROP:\n            if (n.getFirstChild().getType() \u003d\u003d Token.NAME \u0026\u0026 parent.getType() !\u003d Token.CALL \u0026\u0026 parent.getType() !\u003d Token.ASSIGN \u0026\u0026 \"goog.base\".equals(n.getQualifiedName())) {\n                reportBadBaseClassUse(t, n, \"May only be called directly.\");\n            }\n            break;\n    }\n}",
      "path": "src/com/google/javascript/jscomp/ProcessClosurePrimitives.java",
      "functionStartLine": 149,
      "functionName": "visit",
      "functionAnnotation": "",
      "functionDoc": "@inheritDoc}\n",
      "diff": "@@ -1,111 +1,119 @@\n public void visit(NodeTraversal t, Node n, Node parent) {\n     switch(n.getType()) {\n         case Token.CALL:\n-            if (parent.getType() \u003d\u003d Token.EXPR_RESULT) {\n-                Node left \u003d n.getFirstChild();\n-                if (left.getType() \u003d\u003d Token.GETPROP) {\n-                    Node name \u003d left.getFirstChild();\n-                    if (name.getType() \u003d\u003d Token.NAME \u0026\u0026 GOOG.equals(name.getString())) {\n-                        String methodName \u003d name.getNext().getString();\n-                        if (\"require\".equals(methodName)) {\n-                            Node arg \u003d left.getNext();\n-                            if (verifyArgument(t, left, arg)) {\n-                                String ns \u003d arg.getString();\n-                                ProvidedNode provided \u003d providedNodes.get(ns);\n-                                if (provided \u003d\u003d null) {\n-                                    unrecognizedRequires.add(new UnrecognizedRequire(n, ns, t.getSourceName()));\n-                                } else {\n-                                    JSModule module \u003d t.getModule();\n-                                    if (module !\u003d provided.module \u0026\u0026 !compiler.getModuleGraph().dependsOn(module, provided.module)) {\n-                                        compiler.report(JSError.make(t, n, XMODULE_REQUIRE_ERROR, ns, provided.module.getName(), module.getName()));\n-                                    }\n-                                }\n-                                if (provided !\u003d null || requiresLevel.isOn()) {\n-                                    parent.getParent().removeChild(parent);\n-                                    compiler.reportCodeChange();\n+            boolean isExpr \u003d parent.getType() \u003d\u003d Token.EXPR_RESULT;\n+            Node left \u003d n.getFirstChild();\n+            if (left.getType() \u003d\u003d Token.GETPROP) {\n+                Node name \u003d left.getFirstChild();\n+                if (name.getType() \u003d\u003d Token.NAME \u0026\u0026 GOOG.equals(name.getString())) {\n+                    String methodName \u003d name.getNext().getString();\n+                    if (\"base\".equals(methodName)) {\n+                        processBaseClassCall(t, n);\n+                    } else if (!isExpr) {\n+                        break;\n+                    } else if (\"require\".equals(methodName)) {\n+                        Node arg \u003d left.getNext();\n+                        if (verifyArgument(t, left, arg)) {\n+                            String ns \u003d arg.getString();\n+                            ProvidedNode provided \u003d providedNodes.get(ns);\n+                            if (provided \u003d\u003d null) {\n+                                unrecognizedRequires.add(new UnrecognizedRequire(n, ns, t.getSourceName()));\n+                            } else {\n+                                JSModule module \u003d t.getModule();\n+                                if (module !\u003d provided.module \u0026\u0026 !compiler.getModuleGraph().dependsOn(module, provided.module)) {\n+                                    compiler.report(JSError.make(t, n, XMODULE_REQUIRE_ERROR, ns, provided.module.getName(), module.getName()));\n                                 }\n                             }\n-                        } else if (\"provide\".equals(methodName)) {\n-                            Node arg \u003d left.getNext();\n-                            if (verifyProvide(t, left, arg)) {\n-                                String ns \u003d arg.getString();\n-                                if (providedNodes.get(ns) !\u003d null) {\n-                                    compiler.report(JSError.make(t, n, DUPLICATE_NAMESPACE_ERROR, ns));\n-                                } else if (!providedNodes.containsKey(ns)) {\n-                                    replaceProvide(t, parent, parent.getParent(), ns);\n-                                } else {\n-                                    parent.getParent().removeChild(parent);\n-                                    providedNodes.put(ns, new ProvidedNode(null, null, t.getModule()));\n-                                }\n+                            if (provided !\u003d null || requiresLevel.isOn()) {\n+                                parent.getParent().removeChild(parent);\n                                 compiler.reportCodeChange();\n                             }\n-                        } else if (\"exportSymbol\".equals(methodName)) {\n-                            Node arg \u003d left.getNext();\n-                            if (arg.getType() \u003d\u003d Token.STRING) {\n-                                int dot \u003d arg.getString().indexOf(\u0027.\u0027);\n-                                if (dot \u003d\u003d -1) {\n-                                    exportedVariables.add(arg.getString());\n-                                } else {\n-                                    exportedVariables.add(arg.getString().substring(0, dot));\n-                                }\n-                            }\n-                        } else if (\"addDependency\".equals(methodName)) {\n-                            CodingConvention convention \u003d compiler.getCodingConvention();\n-                            List\u003cString\u003e typeDecls \u003d convention.identifyTypeDeclarationCall(n);\n-                            if (typeDecls !\u003d null) {\n-                                for (String typeDecl : typeDecls) {\n-                                    compiler.getTypeRegistry().forwardDeclareType(typeDecl);\n-                                }\n-                            }\n-                            parent.replaceChild(n, Node.newNumber(0));\n-                            compiler.reportCodeChange();\n-                        } else if (\"setCssNameMapping\".equals(methodName)) {\n-                            processSetCssNameMapping(t, n, parent);\n                         }\n+                    } else if (\"provide\".equals(methodName)) {\n+                        Node arg \u003d left.getNext();\n+                        if (verifyProvide(t, left, arg)) {\n+                            String ns \u003d arg.getString();\n+                            if (providedNodes.get(ns) !\u003d null) {\n+                                compiler.report(JSError.make(t, n, DUPLICATE_NAMESPACE_ERROR, ns));\n+                            } else if (!providedNodes.containsKey(ns)) {\n+                                replaceProvide(t, parent, parent.getParent(), ns);\n+                            } else {\n+                                parent.getParent().removeChild(parent);\n+                                providedNodes.put(ns, new ProvidedNode(null, null, t.getModule()));\n+                            }\n+                            compiler.reportCodeChange();\n+                        }\n+                    } else if (\"exportSymbol\".equals(methodName)) {\n+                        Node arg \u003d left.getNext();\n+                        if (arg.getType() \u003d\u003d Token.STRING) {\n+                            int dot \u003d arg.getString().indexOf(\u0027.\u0027);\n+                            if (dot \u003d\u003d -1) {\n+                                exportedVariables.add(arg.getString());\n+                            } else {\n+                                exportedVariables.add(arg.getString().substring(0, dot));\n+                            }\n+                        }\n+                    } else if (\"addDependency\".equals(methodName)) {\n+                        CodingConvention convention \u003d compiler.getCodingConvention();\n+                        List\u003cString\u003e typeDecls \u003d convention.identifyTypeDeclarationCall(n);\n+                        if (typeDecls !\u003d null) {\n+                            for (String typeDecl : typeDecls) {\n+                                compiler.getTypeRegistry().forwardDeclareType(typeDecl);\n+                            }\n+                        }\n+                        parent.replaceChild(n, Node.newNumber(0));\n+                        compiler.reportCodeChange();\n+                    } else if (\"setCssNameMapping\".equals(methodName)) {\n+                        processSetCssNameMapping(t, n, parent);\n                     }\n                 }\n             }\n             break;\n         case Token.ASSIGN:\n             if (t.inGlobalScope() \u0026\u0026 parent.getType() \u003d\u003d Token.EXPR_RESULT) {\n                 Node nameNode \u003d n.getFirstChild();\n                 String name \u003d nameNode.getQualifiedName();\n                 if (name !\u003d null) {\n                     if (parent.getBooleanProp(Node.IS_NAMESPACE)) {\n                         processProvideFromPreviousPass(t, name, parent);\n                     } else {\n                         ProvidedNode pn \u003d providedNodes.get(name);\n                         if (pn !\u003d null) {\n                             pn.addCandidate(parent, parent.getParent());\n                         }\n                     }\n                 }\n             }\n             break;\n         case Token.NAME:\n             if (t.inGlobalScope() \u0026\u0026 parent.getType() \u003d\u003d Token.VAR) {\n                 String name \u003d n.getString();\n                 if (parent.getBooleanProp(Node.IS_NAMESPACE)) {\n                     processProvideFromPreviousPass(t, name, parent);\n                 } else {\n                     ProvidedNode pn \u003d providedNodes.get(name);\n                     if (pn !\u003d null) {\n                         pn.addCandidate(parent, parent.getParent());\n                     }\n                 }\n             }\n             break;\n         case Token.FUNCTION:\n             if (t.inGlobalScope() \u0026\u0026 !NodeUtil.isFunctionAnonymous(n)) {\n                 String name \u003d n.getFirstChild().getString();\n                 ProvidedNode pn \u003d providedNodes.get(name);\n                 if (pn !\u003d null) {\n                     compiler.report(JSError.make(t, n, FUNCTION_NAMESPACE_ERROR, name));\n                 }\n             }\n             break;\n         case Token.NEW:\n             trySimplifyNewDate(t, n, parent);\n             break;\n+        case Token.GETPROP:\n+            if (n.getFirstChild().getType() \u003d\u003d Token.NAME \u0026\u0026 parent.getType() !\u003d Token.CALL \u0026\u0026 parent.getType() !\u003d Token.ASSIGN \u0026\u0026 \"goog.base\".equals(n.getQualifiedName())) {\n+                reportBadBaseClassUse(t, n, \"May only be called directly.\");\n+            }\n+            break;\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": {
      "type": "Yintroduced",
      "commitMessage": "Initial commit.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/3/09, 3:51 PM",
      "commitName": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "diff": "@@ -0,0 +1,111 @@\n+public void visit(NodeTraversal t, Node n, Node parent) {\n+    switch(n.getType()) {\n+        case Token.CALL:\n+            if (parent.getType() \u003d\u003d Token.EXPR_RESULT) {\n+                Node left \u003d n.getFirstChild();\n+                if (left.getType() \u003d\u003d Token.GETPROP) {\n+                    Node name \u003d left.getFirstChild();\n+                    if (name.getType() \u003d\u003d Token.NAME \u0026\u0026 GOOG.equals(name.getString())) {\n+                        String methodName \u003d name.getNext().getString();\n+                        if (\"require\".equals(methodName)) {\n+                            Node arg \u003d left.getNext();\n+                            if (verifyArgument(t, left, arg)) {\n+                                String ns \u003d arg.getString();\n+                                ProvidedNode provided \u003d providedNodes.get(ns);\n+                                if (provided \u003d\u003d null) {\n+                                    unrecognizedRequires.add(new UnrecognizedRequire(n, ns, t.getSourceName()));\n+                                } else {\n+                                    JSModule module \u003d t.getModule();\n+                                    if (module !\u003d provided.module \u0026\u0026 !compiler.getModuleGraph().dependsOn(module, provided.module)) {\n+                                        compiler.report(JSError.make(t, n, XMODULE_REQUIRE_ERROR, ns, provided.module.getName(), module.getName()));\n+                                    }\n+                                }\n+                                if (provided !\u003d null || requiresLevel.isOn()) {\n+                                    parent.getParent().removeChild(parent);\n+                                    compiler.reportCodeChange();\n+                                }\n+                            }\n+                        } else if (\"provide\".equals(methodName)) {\n+                            Node arg \u003d left.getNext();\n+                            if (verifyProvide(t, left, arg)) {\n+                                String ns \u003d arg.getString();\n+                                if (providedNodes.get(ns) !\u003d null) {\n+                                    compiler.report(JSError.make(t, n, DUPLICATE_NAMESPACE_ERROR, ns));\n+                                } else if (!providedNodes.containsKey(ns)) {\n+                                    replaceProvide(t, parent, parent.getParent(), ns);\n+                                } else {\n+                                    parent.getParent().removeChild(parent);\n+                                    providedNodes.put(ns, new ProvidedNode(null, null, t.getModule()));\n+                                }\n+                                compiler.reportCodeChange();\n+                            }\n+                        } else if (\"exportSymbol\".equals(methodName)) {\n+                            Node arg \u003d left.getNext();\n+                            if (arg.getType() \u003d\u003d Token.STRING) {\n+                                int dot \u003d arg.getString().indexOf(\u0027.\u0027);\n+                                if (dot \u003d\u003d -1) {\n+                                    exportedVariables.add(arg.getString());\n+                                } else {\n+                                    exportedVariables.add(arg.getString().substring(0, dot));\n+                                }\n+                            }\n+                        } else if (\"addDependency\".equals(methodName)) {\n+                            CodingConvention convention \u003d compiler.getCodingConvention();\n+                            List\u003cString\u003e typeDecls \u003d convention.identifyTypeDeclarationCall(n);\n+                            if (typeDecls !\u003d null) {\n+                                for (String typeDecl : typeDecls) {\n+                                    compiler.getTypeRegistry().forwardDeclareType(typeDecl);\n+                                }\n+                            }\n+                            parent.replaceChild(n, Node.newNumber(0));\n+                            compiler.reportCodeChange();\n+                        } else if (\"setCssNameMapping\".equals(methodName)) {\n+                            processSetCssNameMapping(t, n, parent);\n+                        }\n+                    }\n+                }\n+            }\n+            break;\n+        case Token.ASSIGN:\n+            if (t.inGlobalScope() \u0026\u0026 parent.getType() \u003d\u003d Token.EXPR_RESULT) {\n+                Node nameNode \u003d n.getFirstChild();\n+                String name \u003d nameNode.getQualifiedName();\n+                if (name !\u003d null) {\n+                    if (parent.getBooleanProp(Node.IS_NAMESPACE)) {\n+                        processProvideFromPreviousPass(t, name, parent);\n+                    } else {\n+                        ProvidedNode pn \u003d providedNodes.get(name);\n+                        if (pn !\u003d null) {\n+                            pn.addCandidate(parent, parent.getParent());\n+                        }\n+                    }\n+                }\n+            }\n+            break;\n+        case Token.NAME:\n+            if (t.inGlobalScope() \u0026\u0026 parent.getType() \u003d\u003d Token.VAR) {\n+                String name \u003d n.getString();\n+                if (parent.getBooleanProp(Node.IS_NAMESPACE)) {\n+                    processProvideFromPreviousPass(t, name, parent);\n+                } else {\n+                    ProvidedNode pn \u003d providedNodes.get(name);\n+                    if (pn !\u003d null) {\n+                        pn.addCandidate(parent, parent.getParent());\n+                    }\n+                }\n+            }\n+            break;\n+        case Token.FUNCTION:\n+            if (t.inGlobalScope() \u0026\u0026 !NodeUtil.isFunctionAnonymous(n)) {\n+                String name \u003d n.getFirstChild().getString();\n+                ProvidedNode pn \u003d providedNodes.get(name);\n+                if (pn !\u003d null) {\n+                    compiler.report(JSError.make(t, n, FUNCTION_NAMESPACE_ERROR, name));\n+                }\n+            }\n+            break;\n+        case Token.NEW:\n+            trySimplifyNewDate(t, n, parent);\n+            break;\n+    }\n+}\n\\ No newline at end of file\n",
      "actualSource": "public void visit(NodeTraversal t, Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.CALL:\n            if (parent.getType() \u003d\u003d Token.EXPR_RESULT) {\n                Node left \u003d n.getFirstChild();\n                if (left.getType() \u003d\u003d Token.GETPROP) {\n                    Node name \u003d left.getFirstChild();\n                    if (name.getType() \u003d\u003d Token.NAME \u0026\u0026 GOOG.equals(name.getString())) {\n                        String methodName \u003d name.getNext().getString();\n                        if (\"require\".equals(methodName)) {\n                            Node arg \u003d left.getNext();\n                            if (verifyArgument(t, left, arg)) {\n                                String ns \u003d arg.getString();\n                                ProvidedNode provided \u003d providedNodes.get(ns);\n                                if (provided \u003d\u003d null) {\n                                    unrecognizedRequires.add(new UnrecognizedRequire(n, ns, t.getSourceName()));\n                                } else {\n                                    JSModule module \u003d t.getModule();\n                                    if (module !\u003d provided.module \u0026\u0026 !compiler.getModuleGraph().dependsOn(module, provided.module)) {\n                                        compiler.report(JSError.make(t, n, XMODULE_REQUIRE_ERROR, ns, provided.module.getName(), module.getName()));\n                                    }\n                                }\n                                if (provided !\u003d null || requiresLevel.isOn()) {\n                                    parent.getParent().removeChild(parent);\n                                    compiler.reportCodeChange();\n                                }\n                            }\n                        } else if (\"provide\".equals(methodName)) {\n                            Node arg \u003d left.getNext();\n                            if (verifyProvide(t, left, arg)) {\n                                String ns \u003d arg.getString();\n                                if (providedNodes.get(ns) !\u003d null) {\n                                    compiler.report(JSError.make(t, n, DUPLICATE_NAMESPACE_ERROR, ns));\n                                } else if (!providedNodes.containsKey(ns)) {\n                                    replaceProvide(t, parent, parent.getParent(), ns);\n                                } else {\n                                    parent.getParent().removeChild(parent);\n                                    providedNodes.put(ns, new ProvidedNode(null, null, t.getModule()));\n                                }\n                                compiler.reportCodeChange();\n                            }\n                        } else if (\"exportSymbol\".equals(methodName)) {\n                            Node arg \u003d left.getNext();\n                            if (arg.getType() \u003d\u003d Token.STRING) {\n                                int dot \u003d arg.getString().indexOf(\u0027.\u0027);\n                                if (dot \u003d\u003d -1) {\n                                    exportedVariables.add(arg.getString());\n                                } else {\n                                    exportedVariables.add(arg.getString().substring(0, dot));\n                                }\n                            }\n                        } else if (\"addDependency\".equals(methodName)) {\n                            CodingConvention convention \u003d compiler.getCodingConvention();\n                            List\u003cString\u003e typeDecls \u003d convention.identifyTypeDeclarationCall(n);\n                            if (typeDecls !\u003d null) {\n                                for (String typeDecl : typeDecls) {\n                                    compiler.getTypeRegistry().forwardDeclareType(typeDecl);\n                                }\n                            }\n                            parent.replaceChild(n, Node.newNumber(0));\n                            compiler.reportCodeChange();\n                        } else if (\"setCssNameMapping\".equals(methodName)) {\n                            processSetCssNameMapping(t, n, parent);\n                        }\n                    }\n                }\n            }\n            break;\n        case Token.ASSIGN:\n            if (t.inGlobalScope() \u0026\u0026 parent.getType() \u003d\u003d Token.EXPR_RESULT) {\n                Node nameNode \u003d n.getFirstChild();\n                String name \u003d nameNode.getQualifiedName();\n                if (name !\u003d null) {\n                    if (parent.getBooleanProp(Node.IS_NAMESPACE)) {\n                        processProvideFromPreviousPass(t, name, parent);\n                    } else {\n                        ProvidedNode pn \u003d providedNodes.get(name);\n                        if (pn !\u003d null) {\n                            pn.addCandidate(parent, parent.getParent());\n                        }\n                    }\n                }\n            }\n            break;\n        case Token.NAME:\n            if (t.inGlobalScope() \u0026\u0026 parent.getType() \u003d\u003d Token.VAR) {\n                String name \u003d n.getString();\n                if (parent.getBooleanProp(Node.IS_NAMESPACE)) {\n                    processProvideFromPreviousPass(t, name, parent);\n                } else {\n                    ProvidedNode pn \u003d providedNodes.get(name);\n                    if (pn !\u003d null) {\n                        pn.addCandidate(parent, parent.getParent());\n                    }\n                }\n            }\n            break;\n        case Token.FUNCTION:\n            if (t.inGlobalScope() \u0026\u0026 !NodeUtil.isFunctionAnonymous(n)) {\n                String name \u003d n.getFirstChild().getString();\n                ProvidedNode pn \u003d providedNodes.get(name);\n                if (pn !\u003d null) {\n                    compiler.report(JSError.make(t, n, FUNCTION_NAMESPACE_ERROR, name));\n                }\n            }\n            break;\n        case Token.NEW:\n            trySimplifyNewDate(t, n, parent);\n            break;\n    }\n}",
      "path": "src/com/google/javascript/jscomp/ProcessClosurePrimitives.java",
      "functionStartLine": 168,
      "functionName": "visit",
      "functionAnnotation": "",
      "functionDoc": "@inheritDoc}\n"
    }
  }
}