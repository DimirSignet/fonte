{
  "origin": "codeshovel",
  "repositoryName": "Math-26b",
  "repositoryPath": "/tmp/Math-26b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ArithmeticUtils.java",
  "functionName": "gcd",
  "functionId": "gcd___p-int(modifiers-final)__q-int(modifiers-final)",
  "sourceFilePath": "src/main/java/org/apache/commons/math3/util/ArithmeticUtils.java",
  "functionAnnotation": "",
  "functionDoc": "\u003cp\u003e\nGets the greatest common divisor of the absolute value of two numbers,\nusing the \"binary gcd\" method which avoids division and modulo\noperations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef\nStein (1961).\n\u003c/p\u003e\nSpecial cases:\n\u003cul\u003e\n\u003cli\u003eThe invocations\n{@code gcd(Integer.MIN_VALUE, Integer.MIN_VALUE)},\n{@code gcd(Integer.MIN_VALUE, 0)} and\n{@code gcd(0, Integer.MIN_VALUE)} throw an\n{@code ArithmeticException}, because the result would be 2^31, which\nis too large for an int value.\u003c/li\u003e\n\u003cli\u003eThe result of {@code gcd(x, x)}, {@code gcd(0, x)} and\n{@code gcd(x, 0)} is the absolute value of {@code x}, except\nfor the special cases above.\n\u003cli\u003eThe invocation {@code gcd(0, 0)} is the only one which returns\n{@code 0}.\u003c/li\u003e\n\u003c/ul\u003e\n\n@param p Number.\n@param q Number.\n@return the greatest common divisor, never negative.\n@throws MathArithmeticException if the result cannot be represented as\na non-negative {@code int} value.\n@since 1.1\n",
  "functionStartLine": 384,
  "functionEndLine": 440,
  "numCommitsSeen": 234,
  "timeTaken": 20569,
  "changeHistory": [
    "2d698e4905cb75bd125e2fe1f5223d7e68f0adcd",
    "87e0de04ccfb68e36be14182a39e03a307e8ad4b",
    "cec984b0ade238f8ab2b2d100569dc2e4c1f2215",
    "622f5b537a2126a7f6ae1047c7e3753b5f23d56b",
    "51ec76cc5685566569af3f312efee2aaccadddfc",
    "80b1e90b42a34856b61cec628fcea6633d1000cd",
    "1eaea0b549f685bd416cef68faa3a137b9bb3519",
    "0fd871ca2c7b94bde0237cdf2f688460a05c1895",
    "b631eb68a8aa659e0760de672edfbfb9f9ac246d",
    "d6a438e931412713e99624cf9ed74470f1040184",
    "513511976ddc778f7c52d69bf43db3c3f4b88803",
    "7f88773d6c3c96c0a2fd24c3e50d1eb80daca11d",
    "58b5609fe8f99aabc990d885bf6c4d85631b7c79",
    "a96e597894562c2cf01fc678f6c435d65ccc31c5",
    "b1ade04fc274a2030fcf1df2c760755eeb83bf1b",
    "c7a42fb239f8b723a9daf1903ec1ad64388da6bd",
    "20786a617657c0c20315005c621052a2735dfe67",
    "41598b038509e9cdb7f6dbeefdb2a2876d2708a6"
  ],
  "changeHistoryShort": {
    "2d698e4905cb75bd125e2fe1f5223d7e68f0adcd": "Ymovefromfile",
    "87e0de04ccfb68e36be14182a39e03a307e8ad4b": "Yfilerename",
    "cec984b0ade238f8ab2b2d100569dc2e4c1f2215": "Ymovefromfile",
    "622f5b537a2126a7f6ae1047c7e3753b5f23d56b": "Ydocchange",
    "51ec76cc5685566569af3f312efee2aaccadddfc": "Ymultichange(Ybodychange,Ydocchange)",
    "80b1e90b42a34856b61cec628fcea6633d1000cd": "Ybodychange",
    "1eaea0b549f685bd416cef68faa3a137b9bb3519": "Ybodychange",
    "0fd871ca2c7b94bde0237cdf2f688460a05c1895": "Ydocchange",
    "b631eb68a8aa659e0760de672edfbfb9f9ac246d": "Ybodychange",
    "d6a438e931412713e99624cf9ed74470f1040184": "Yfilerename",
    "513511976ddc778f7c52d69bf43db3c3f4b88803": "Ydocchange",
    "7f88773d6c3c96c0a2fd24c3e50d1eb80daca11d": "Ybodychange",
    "58b5609fe8f99aabc990d885bf6c4d85631b7c79": "Ymultichange(Yparameterchange,Ybodychange,Ydocchange)",
    "a96e597894562c2cf01fc678f6c435d65ccc31c5": "Ybodychange",
    "b1ade04fc274a2030fcf1df2c760755eeb83bf1b": "Ymultichange(Ybodychange,Ydocchange)",
    "c7a42fb239f8b723a9daf1903ec1ad64388da6bd": "Ydocchange",
    "20786a617657c0c20315005c621052a2735dfe67": "Ymultichange(Yparameterchange,Ybodychange,Ydocchange)",
    "41598b038509e9cdb7f6dbeefdb2a2876d2708a6": "Yintroduced"
  },
  "changeHistoryDetails": {
    "2d698e4905cb75bd125e2fe1f5223d7e68f0adcd": {
      "type": "Ymovefromfile",
      "commitMessage": "MATH-444\nBase package name change: \"o.a.c.math\" -\u003e \"o.a.c.math3\"\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@1244107 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2/14/12, 8:17 AM",
      "commitName": "2d698e4905cb75bd125e2fe1f5223d7e68f0adcd",
      "commitAuthor": "Gilles Sadowski",
      "commitDateOld": "2/14/12, 6:34 AM",
      "commitNameOld": "53257329dd394be1333b38bae787bf0cf19dc900",
      "commitAuthorOld": "Gilles Sadowski",
      "daysBetweenCommits": 0.07,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public static int gcd(final int p, final int q) {\n    int u \u003d p;\n    int v \u003d q;\n    if ((u \u003d\u003d 0) || (v \u003d\u003d 0)) {\n        if ((u \u003d\u003d Integer.MIN_VALUE) || (v \u003d\u003d Integer.MIN_VALUE)) {\n            throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS, p, q);\n        }\n        return FastMath.abs(u) + FastMath.abs(v);\n    }\n    if (u \u003e 0) {\n        u \u003d -u;\n    }\n    if (v \u003e 0) {\n        v \u003d -v;\n    }\n    int k \u003d 0;\n    while ((u \u0026 1) \u003d\u003d 0 \u0026\u0026 (v \u0026 1) \u003d\u003d 0 \u0026\u0026 k \u003c 31) {\n        u /\u003d 2;\n        v /\u003d 2;\n        k++;\n    }\n    if (k \u003d\u003d 31) {\n        throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS, p, q);\n    }\n    int t \u003d ((u \u0026 1) \u003d\u003d 1) ? v : -(u / 2);\n    do {\n        while ((t \u0026 1) \u003d\u003d 0) {\n            t /\u003d 2;\n        }\n        if (t \u003e 0) {\n            u \u003d -t;\n        } else {\n            v \u003d t;\n        }\n        t \u003d (v - u) / 2;\n    } while (t !\u003d 0);\n    return -u * (1 \u003c\u003c k);\n}",
      "path": "src/main/java/org/apache/commons/math3/util/ArithmeticUtils.java",
      "functionStartLine": 384,
      "functionName": "gcd",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003e\nGets the greatest common divisor of the absolute value of two numbers,\nusing the \"binary gcd\" method which avoids division and modulo\noperations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef\nStein (1961).\n\u003c/p\u003e\nSpecial cases:\n\u003cul\u003e\n\u003cli\u003eThe invocations\n{@code gcd(Integer.MIN_VALUE, Integer.MIN_VALUE)},\n{@code gcd(Integer.MIN_VALUE, 0)} and\n{@code gcd(0, Integer.MIN_VALUE)} throw an\n{@code ArithmeticException}, because the result would be 2^31, which\nis too large for an int value.\u003c/li\u003e\n\u003cli\u003eThe result of {@code gcd(x, x)}, {@code gcd(0, x)} and\n{@code gcd(x, 0)} is the absolute value of {@code x}, except\nfor the special cases above.\n\u003cli\u003eThe invocation {@code gcd(0, 0)} is the only one which returns\n{@code 0}.\u003c/li\u003e\n\u003c/ul\u003e\n\n@param p Number.\n@param q Number.\n@return the greatest common divisor, never negative.\n@throws MathArithmeticException if the result cannot be represented as\na non-negative {@code int} value.\n@since 1.1\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/main/java/org/apache/commons/math/util/ArithmeticUtils.java",
        "newPath": "src/main/java/org/apache/commons/math3/util/ArithmeticUtils.java",
        "oldMethodName": "gcd",
        "newMethodName": "gcd"
      }
    },
    "87e0de04ccfb68e36be14182a39e03a307e8ad4b": {
      "type": "Yfilerename",
      "commitMessage": "\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@1182787 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/13/11, 4:20 AM",
      "commitName": "87e0de04ccfb68e36be14182a39e03a307e8ad4b",
      "commitAuthor": "Sebastien Brisard",
      "commitDateOld": "10/12/11, 10:29 PM",
      "commitNameOld": "994756b1a06de64cc418413fe9a7e7507f75ff79",
      "commitAuthorOld": "Sebastien Brisard",
      "daysBetweenCommits": 0.24,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public static int gcd(final int p, final int q) {\n    int u \u003d p;\n    int v \u003d q;\n    if ((u \u003d\u003d 0) || (v \u003d\u003d 0)) {\n        if ((u \u003d\u003d Integer.MIN_VALUE) || (v \u003d\u003d Integer.MIN_VALUE)) {\n            throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS, p, q);\n        }\n        return FastMath.abs(u) + FastMath.abs(v);\n    }\n    if (u \u003e 0) {\n        u \u003d -u;\n    }\n    if (v \u003e 0) {\n        v \u003d -v;\n    }\n    int k \u003d 0;\n    while ((u \u0026 1) \u003d\u003d 0 \u0026\u0026 (v \u0026 1) \u003d\u003d 0 \u0026\u0026 k \u003c 31) {\n        u /\u003d 2;\n        v /\u003d 2;\n        k++;\n    }\n    if (k \u003d\u003d 31) {\n        throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS, p, q);\n    }\n    int t \u003d ((u \u0026 1) \u003d\u003d 1) ? v : -(u / 2);\n    do {\n        while ((t \u0026 1) \u003d\u003d 0) {\n            t /\u003d 2;\n        }\n        if (t \u003e 0) {\n            u \u003d -t;\n        } else {\n            v \u003d t;\n        }\n        t \u003d (v - u) / 2;\n    } while (t !\u003d 0);\n    return -u * (1 \u003c\u003c k);\n}",
      "path": "src/main/java/org/apache/commons/math/util/ArithmeticUtils.java",
      "functionStartLine": 380,
      "functionName": "gcd",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003e\nGets the greatest common divisor of the absolute value of two numbers,\nusing the \"binary gcd\" method which avoids division and modulo\noperations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef\nStein (1961).\n\u003c/p\u003e\nSpecial cases:\n\u003cul\u003e\n\u003cli\u003eThe invocations\n{@code gcd(Integer.MIN_VALUE, Integer.MIN_VALUE)},\n{@code gcd(Integer.MIN_VALUE, 0)} and\n{@code gcd(0, Integer.MIN_VALUE)} throw an\n{@code ArithmeticException}, because the result would be 2^31, which\nis too large for an int value.\u003c/li\u003e\n\u003cli\u003eThe result of {@code gcd(x, x)}, {@code gcd(0, x)} and\n{@code gcd(x, 0)} is the absolute value of {@code x}, except\nfor the special cases above.\n\u003cli\u003eThe invocation {@code gcd(0, 0)} is the only one which returns\n{@code 0}.\u003c/li\u003e\n\u003c/ul\u003e\n\n@param p Number.\n@param q Number.\n@return the greatest common divisor, never negative.\n@throws MathArithmeticException if the result cannot be represented as\na non-negative {@code int} value.\n@since 1.1\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/main/java/org/apache/commons/math/util/ArithmeticsUtils.java",
        "newPath": "src/main/java/org/apache/commons/math/util/ArithmeticUtils.java"
      }
    },
    "cec984b0ade238f8ab2b2d100569dc2e4c1f2215": {
      "type": "Ymovefromfile",
      "commitMessage": "Created ArithmeticsUtils class (MATH-689), and corresponding unit tests. Moved some methods from MathUtils to ArithmeticsUtils.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@1182213 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/11/11, 11:17 PM",
      "commitName": "cec984b0ade238f8ab2b2d100569dc2e4c1f2215",
      "commitAuthor": "Sebastien Brisard",
      "commitDateOld": "10/11/11, 4:37 PM",
      "commitNameOld": "cad6e4ae20fc7ff4535e42b1f3aa9a462f82c0ba",
      "commitAuthorOld": "Gilles Sadowski",
      "daysBetweenCommits": 0.28,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public static int gcd(final int p, final int q) {\n    int u \u003d p;\n    int v \u003d q;\n    if ((u \u003d\u003d 0) || (v \u003d\u003d 0)) {\n        if ((u \u003d\u003d Integer.MIN_VALUE) || (v \u003d\u003d Integer.MIN_VALUE)) {\n            throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS, p, q);\n        }\n        return FastMath.abs(u) + FastMath.abs(v);\n    }\n    if (u \u003e 0) {\n        u \u003d -u;\n    }\n    if (v \u003e 0) {\n        v \u003d -v;\n    }\n    int k \u003d 0;\n    while ((u \u0026 1) \u003d\u003d 0 \u0026\u0026 (v \u0026 1) \u003d\u003d 0 \u0026\u0026 k \u003c 31) {\n        u /\u003d 2;\n        v /\u003d 2;\n        k++;\n    }\n    if (k \u003d\u003d 31) {\n        throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS, p, q);\n    }\n    int t \u003d ((u \u0026 1) \u003d\u003d 1) ? v : -(u / 2);\n    do {\n        while ((t \u0026 1) \u003d\u003d 0) {\n            t /\u003d 2;\n        }\n        if (t \u003e 0) {\n            u \u003d -t;\n        } else {\n            v \u003d t;\n        }\n        t \u003d (v - u) / 2;\n    } while (t !\u003d 0);\n    return -u * (1 \u003c\u003c k);\n}",
      "path": "src/main/java/org/apache/commons/math/util/ArithmeticsUtils.java",
      "functionStartLine": 278,
      "functionName": "gcd",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003e\nGets the greatest common divisor of the absolute value of two numbers,\nusing the \"binary gcd\" method which avoids division and modulo\noperations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef\nStein (1961).\n\u003c/p\u003e\nSpecial cases:\n\u003cul\u003e\n\u003cli\u003eThe invocations\n{@code gcd(Integer.MIN_VALUE, Integer.MIN_VALUE)},\n{@code gcd(Integer.MIN_VALUE, 0)} and\n{@code gcd(0, Integer.MIN_VALUE)} throw an\n{@code ArithmeticException}, because the result would be 2^31, which\nis too large for an int value.\u003c/li\u003e\n\u003cli\u003eThe result of {@code gcd(x, x)}, {@code gcd(0, x)} and\n{@code gcd(x, 0)} is the absolute value of {@code x}, except\nfor the special cases above.\n\u003cli\u003eThe invocation {@code gcd(0, 0)} is the only one which returns\n{@code 0}.\u003c/li\u003e\n\u003c/ul\u003e\n\n@param p Number.\n@param q Number.\n@return the greatest common divisor, never negative.\n@throws MathArithmeticException if the result cannot be represented as\na non-negative {@code int} value.\n@since 1.1\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/main/java/org/apache/commons/math/util/MathUtils.java",
        "newPath": "src/main/java/org/apache/commons/math/util/ArithmeticsUtils.java",
        "oldMethodName": "gcd",
        "newMethodName": "gcd"
      }
    },
    "622f5b537a2126a7f6ae1047c7e3753b5f23d56b": {
      "type": "Ydocchange",
      "commitMessage": "MATH-447\nMade all new exception classes inherit from \"MathRuntimeException\".\nChanged accordingly all tests that relied on catching the standard\nJava exception (e.g. \"MathIllegalArgumentEception\" is not a subclass\nof \"IllegalArgumentEception\" anymore).\nReplaced occurrences of the old \"MathRuntimeException\" by the\nappropriate exception from the \"exception\" package (MATH-459).\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@1044186 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/9/10, 4:50 PM",
      "commitName": "622f5b537a2126a7f6ae1047c7e3753b5f23d56b",
      "commitAuthor": "Gilles Sadowski",
      "commitDateOld": "11/7/10, 3:49 PM",
      "commitNameOld": "c118e62d6b95c5e0643b34e752b043ad002ba419",
      "commitAuthorOld": "Gilles Sadowski",
      "daysBetweenCommits": 32.04,
      "commitsBetweenForRepo": 74,
      "commitsBetweenForFile": 1,
      "actualSource": "public static int gcd(final int p, final int q) {\n    int u \u003d p;\n    int v \u003d q;\n    if ((u \u003d\u003d 0) || (v \u003d\u003d 0)) {\n        if ((u \u003d\u003d Integer.MIN_VALUE) || (v \u003d\u003d Integer.MIN_VALUE)) {\n            throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS, p, q);\n        }\n        return FastMath.abs(u) + FastMath.abs(v);\n    }\n    if (u \u003e 0) {\n        u \u003d -u;\n    }\n    if (v \u003e 0) {\n        v \u003d -v;\n    }\n    int k \u003d 0;\n    while ((u \u0026 1) \u003d\u003d 0 \u0026\u0026 (v \u0026 1) \u003d\u003d 0 \u0026\u0026 k \u003c 31) {\n        u /\u003d 2;\n        v /\u003d 2;\n        k++;\n    }\n    if (k \u003d\u003d 31) {\n        throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS, p, q);\n    }\n    int t \u003d ((u \u0026 1) \u003d\u003d 1) ? v : -(u / 2);\n    do {\n        while ((t \u0026 1) \u003d\u003d 0) {\n            t /\u003d 2;\n        }\n        if (t \u003e 0) {\n            u \u003d -t;\n        } else {\n            v \u003d t;\n        }\n        t \u003d (v - u) / 2;\n    } while (t !\u003d 0);\n    return -u * (1 \u003c\u003c k);\n}",
      "path": "src/main/java/org/apache/commons/math/util/MathUtils.java",
      "functionStartLine": 680,
      "functionName": "gcd",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003e\nGets the greatest common divisor of the absolute value of two numbers,\nusing the \"binary gcd\" method which avoids division and modulo\noperations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef\nStein (1961).\n\u003c/p\u003e\nSpecial cases:\n\u003cul\u003e\n\u003cli\u003eThe invocations\n{@code gcd(Integer.MIN_VALUE, Integer.MIN_VALUE)},\n{@code gcd(Integer.MIN_VALUE, 0)} and\n{@code gcd(0, Integer.MIN_VALUE)} throw an\n{@code ArithmeticException}, because the result would be 2^31, which\nis too large for an int value.\u003c/li\u003e\n\u003cli\u003eThe result of {@code gcd(x, x)}, {@code gcd(0, x)} and\n{@code gcd(x, 0)} is the absolute value of {@code x}, except\nfor the special cases above.\n\u003cli\u003eThe invocation {@code gcd(0, 0)} is the only one which returns\n{@code 0}.\u003c/li\u003e\n\u003c/ul\u003e\n\n@param p Number.\n@param q Number.\n@return the greatest common divisor, never negative.\n@throws MathArithmeticException if the result cannot be represented as\na non-negative {@code int} value.\n@since 1.1\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "\u003cp\u003e\nGets the greatest common divisor of the absolute value of two numbers,\nusing the \"binary gcd\" method which avoids division and modulo\noperations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef\nStein (1961).\n\u003c/p\u003e\nSpecial cases:\n\u003cul\u003e\n\u003cli\u003eThe invocations\n\u003ccode\u003egcd(Integer.MIN_VALUE, Integer.MIN_VALUE)\u003c/code\u003e,\n\u003ccode\u003egcd(Integer.MIN_VALUE, 0)\u003c/code\u003e and\n\u003ccode\u003egcd(0, Integer.MIN_VALUE)\u003c/code\u003e throw an\n\u003ccode\u003eArithmeticException\u003c/code\u003e, because the result would be 2^31, which\nis too large for an int value.\u003c/li\u003e\n\u003cli\u003eThe result of \u003ccode\u003egcd(x, x)\u003c/code\u003e, \u003ccode\u003egcd(0, x)\u003c/code\u003e and\n\u003ccode\u003egcd(x, 0)\u003c/code\u003e is the absolute value of \u003ccode\u003ex\u003c/code\u003e, except\nfor the special cases above.\n\u003cli\u003eThe invocation \u003ccode\u003egcd(0, 0)\u003c/code\u003e is the only one which returns\n\u003ccode\u003e0\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\n@param p Number.\n@param q Number.\n@return the greatest common divisor, never negative.\n@throws MathArithmeticException if the result cannot be represented as\na non-negative {@code int} value.\n@since 1.1\n",
        "newValue": "\u003cp\u003e\nGets the greatest common divisor of the absolute value of two numbers,\nusing the \"binary gcd\" method which avoids division and modulo\noperations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef\nStein (1961).\n\u003c/p\u003e\nSpecial cases:\n\u003cul\u003e\n\u003cli\u003eThe invocations\n{@code gcd(Integer.MIN_VALUE, Integer.MIN_VALUE)},\n{@code gcd(Integer.MIN_VALUE, 0)} and\n{@code gcd(0, Integer.MIN_VALUE)} throw an\n{@code ArithmeticException}, because the result would be 2^31, which\nis too large for an int value.\u003c/li\u003e\n\u003cli\u003eThe result of {@code gcd(x, x)}, {@code gcd(0, x)} and\n{@code gcd(x, 0)} is the absolute value of {@code x}, except\nfor the special cases above.\n\u003cli\u003eThe invocation {@code gcd(0, 0)} is the only one which returns\n{@code 0}.\u003c/li\u003e\n\u003c/ul\u003e\n\n@param p Number.\n@param q Number.\n@return the greatest common divisor, never negative.\n@throws MathArithmeticException if the result cannot be represented as\na non-negative {@code int} value.\n@since 1.1\n"
      }
    },
    "51ec76cc5685566569af3f312efee2aaccadddfc": {
      "type": "Ymultichange(Ybodychange,Ydocchange)",
      "commitMessage": "MATH-195\nCreated an unchecked \"FunctionEvaluationException\" in package \"exception\".\nRemoved \"throws\" clause from interface \"UnivariateRealFunction\".\n\"PolynomialFunctionLagrangeForm\": Added early check on the interpolating\narray having distinct points; removed redundant test in methods \"evaluate\"\nand \"computeCoefficients\".\n\"DividedDifferenceInerpolator\": Removed redundant check.\n\"Mathutils\": Added method \"sortInPlace\". Removed (most) references to the\ndeprecated \"MathRuntimeException\" class.\n\"optimization.direct\": Removed deprecated classes.\nJavadoc clean up.\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@1030464 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/3/10, 6:46 AM",
      "commitName": "51ec76cc5685566569af3f312efee2aaccadddfc",
      "commitAuthor": "Gilles Sadowski",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "MATH-195\nCreated an unchecked \"FunctionEvaluationException\" in package \"exception\".\nRemoved \"throws\" clause from interface \"UnivariateRealFunction\".\n\"PolynomialFunctionLagrangeForm\": Added early check on the interpolating\narray having distinct points; removed redundant test in methods \"evaluate\"\nand \"computeCoefficients\".\n\"DividedDifferenceInerpolator\": Removed redundant check.\n\"Mathutils\": Added method \"sortInPlace\". Removed (most) references to the\ndeprecated \"MathRuntimeException\" class.\n\"optimization.direct\": Removed deprecated classes.\nJavadoc clean up.\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@1030464 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "11/3/10, 6:46 AM",
          "commitName": "51ec76cc5685566569af3f312efee2aaccadddfc",
          "commitAuthor": "Gilles Sadowski",
          "commitDateOld": "9/1/10, 6:45 AM",
          "commitNameOld": "d2a5bc02c002acfa220ce8bad23b9e8af137f47d",
          "commitAuthorOld": "Gilles Sadowski",
          "daysBetweenCommits": 63.0,
          "commitsBetweenForRepo": 86,
          "commitsBetweenForFile": 1,
          "actualSource": "public static int gcd(final int p, final int q) {\n    int u \u003d p;\n    int v \u003d q;\n    if ((u \u003d\u003d 0) || (v \u003d\u003d 0)) {\n        if ((u \u003d\u003d Integer.MIN_VALUE) || (v \u003d\u003d Integer.MIN_VALUE)) {\n            throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS, p, q);\n        }\n        return FastMath.abs(u) + FastMath.abs(v);\n    }\n    if (u \u003e 0) {\n        u \u003d -u;\n    }\n    if (v \u003e 0) {\n        v \u003d -v;\n    }\n    int k \u003d 0;\n    while ((u \u0026 1) \u003d\u003d 0 \u0026\u0026 (v \u0026 1) \u003d\u003d 0 \u0026\u0026 k \u003c 31) {\n        u /\u003d 2;\n        v /\u003d 2;\n        k++;\n    }\n    if (k \u003d\u003d 31) {\n        throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS, p, q);\n    }\n    int t \u003d ((u \u0026 1) \u003d\u003d 1) ? v : -(u / 2);\n    do {\n        while ((t \u0026 1) \u003d\u003d 0) {\n            t /\u003d 2;\n        }\n        if (t \u003e 0) {\n            u \u003d -t;\n        } else {\n            v \u003d t;\n        }\n        t \u003d (v - u) / 2;\n    } while (t !\u003d 0);\n    return -u * (1 \u003c\u003c k);\n}",
          "path": "src/main/java/org/apache/commons/math/util/MathUtils.java",
          "functionStartLine": 682,
          "functionName": "gcd",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003e\nGets the greatest common divisor of the absolute value of two numbers,\nusing the \"binary gcd\" method which avoids division and modulo\noperations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef\nStein (1961).\n\u003c/p\u003e\nSpecial cases:\n\u003cul\u003e\n\u003cli\u003eThe invocations\n\u003ccode\u003egcd(Integer.MIN_VALUE, Integer.MIN_VALUE)\u003c/code\u003e,\n\u003ccode\u003egcd(Integer.MIN_VALUE, 0)\u003c/code\u003e and\n\u003ccode\u003egcd(0, Integer.MIN_VALUE)\u003c/code\u003e throw an\n\u003ccode\u003eArithmeticException\u003c/code\u003e, because the result would be 2^31, which\nis too large for an int value.\u003c/li\u003e\n\u003cli\u003eThe result of \u003ccode\u003egcd(x, x)\u003c/code\u003e, \u003ccode\u003egcd(0, x)\u003c/code\u003e and\n\u003ccode\u003egcd(x, 0)\u003c/code\u003e is the absolute value of \u003ccode\u003ex\u003c/code\u003e, except\nfor the special cases above.\n\u003cli\u003eThe invocation \u003ccode\u003egcd(0, 0)\u003c/code\u003e is the only one which returns\n\u003ccode\u003e0\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\n@param p Number.\n@param q Number.\n@return the greatest common divisor, never negative.\n@throws MathArithmeticException if the result cannot be represented as\na non-negative {@code int} value.\n@since 1.1\n",
          "diff": "@@ -1,38 +1,38 @@\n public static int gcd(final int p, final int q) {\n     int u \u003d p;\n     int v \u003d q;\n     if ((u \u003d\u003d 0) || (v \u003d\u003d 0)) {\n         if ((u \u003d\u003d Integer.MIN_VALUE) || (v \u003d\u003d Integer.MIN_VALUE)) {\n-            throw MathRuntimeException.createArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS, p, q);\n+            throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS, p, q);\n         }\n         return FastMath.abs(u) + FastMath.abs(v);\n     }\n     if (u \u003e 0) {\n         u \u003d -u;\n     }\n     if (v \u003e 0) {\n         v \u003d -v;\n     }\n     int k \u003d 0;\n     while ((u \u0026 1) \u003d\u003d 0 \u0026\u0026 (v \u0026 1) \u003d\u003d 0 \u0026\u0026 k \u003c 31) {\n         u /\u003d 2;\n         v /\u003d 2;\n         k++;\n     }\n     if (k \u003d\u003d 31) {\n-        throw MathRuntimeException.createArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS, p, q);\n+        throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS, p, q);\n     }\n     int t \u003d ((u \u0026 1) \u003d\u003d 1) ? v : -(u / 2);\n     do {\n         while ((t \u0026 1) \u003d\u003d 0) {\n             t /\u003d 2;\n         }\n         if (t \u003e 0) {\n             u \u003d -t;\n         } else {\n             v \u003d t;\n         }\n         t \u003d (v - u) / 2;\n     } while (t !\u003d 0);\n     return -u * (1 \u003c\u003c k);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "MATH-195\nCreated an unchecked \"FunctionEvaluationException\" in package \"exception\".\nRemoved \"throws\" clause from interface \"UnivariateRealFunction\".\n\"PolynomialFunctionLagrangeForm\": Added early check on the interpolating\narray having distinct points; removed redundant test in methods \"evaluate\"\nand \"computeCoefficients\".\n\"DividedDifferenceInerpolator\": Removed redundant check.\n\"Mathutils\": Added method \"sortInPlace\". Removed (most) references to the\ndeprecated \"MathRuntimeException\" class.\n\"optimization.direct\": Removed deprecated classes.\nJavadoc clean up.\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@1030464 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "11/3/10, 6:46 AM",
          "commitName": "51ec76cc5685566569af3f312efee2aaccadddfc",
          "commitAuthor": "Gilles Sadowski",
          "commitDateOld": "9/1/10, 6:45 AM",
          "commitNameOld": "d2a5bc02c002acfa220ce8bad23b9e8af137f47d",
          "commitAuthorOld": "Gilles Sadowski",
          "daysBetweenCommits": 63.0,
          "commitsBetweenForRepo": 86,
          "commitsBetweenForFile": 1,
          "actualSource": "public static int gcd(final int p, final int q) {\n    int u \u003d p;\n    int v \u003d q;\n    if ((u \u003d\u003d 0) || (v \u003d\u003d 0)) {\n        if ((u \u003d\u003d Integer.MIN_VALUE) || (v \u003d\u003d Integer.MIN_VALUE)) {\n            throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS, p, q);\n        }\n        return FastMath.abs(u) + FastMath.abs(v);\n    }\n    if (u \u003e 0) {\n        u \u003d -u;\n    }\n    if (v \u003e 0) {\n        v \u003d -v;\n    }\n    int k \u003d 0;\n    while ((u \u0026 1) \u003d\u003d 0 \u0026\u0026 (v \u0026 1) \u003d\u003d 0 \u0026\u0026 k \u003c 31) {\n        u /\u003d 2;\n        v /\u003d 2;\n        k++;\n    }\n    if (k \u003d\u003d 31) {\n        throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS, p, q);\n    }\n    int t \u003d ((u \u0026 1) \u003d\u003d 1) ? v : -(u / 2);\n    do {\n        while ((t \u0026 1) \u003d\u003d 0) {\n            t /\u003d 2;\n        }\n        if (t \u003e 0) {\n            u \u003d -t;\n        } else {\n            v \u003d t;\n        }\n        t \u003d (v - u) / 2;\n    } while (t !\u003d 0);\n    return -u * (1 \u003c\u003c k);\n}",
          "path": "src/main/java/org/apache/commons/math/util/MathUtils.java",
          "functionStartLine": 682,
          "functionName": "gcd",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003e\nGets the greatest common divisor of the absolute value of two numbers,\nusing the \"binary gcd\" method which avoids division and modulo\noperations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef\nStein (1961).\n\u003c/p\u003e\nSpecial cases:\n\u003cul\u003e\n\u003cli\u003eThe invocations\n\u003ccode\u003egcd(Integer.MIN_VALUE, Integer.MIN_VALUE)\u003c/code\u003e,\n\u003ccode\u003egcd(Integer.MIN_VALUE, 0)\u003c/code\u003e and\n\u003ccode\u003egcd(0, Integer.MIN_VALUE)\u003c/code\u003e throw an\n\u003ccode\u003eArithmeticException\u003c/code\u003e, because the result would be 2^31, which\nis too large for an int value.\u003c/li\u003e\n\u003cli\u003eThe result of \u003ccode\u003egcd(x, x)\u003c/code\u003e, \u003ccode\u003egcd(0, x)\u003c/code\u003e and\n\u003ccode\u003egcd(x, 0)\u003c/code\u003e is the absolute value of \u003ccode\u003ex\u003c/code\u003e, except\nfor the special cases above.\n\u003cli\u003eThe invocation \u003ccode\u003egcd(0, 0)\u003c/code\u003e is the only one which returns\n\u003ccode\u003e0\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\n@param p Number.\n@param q Number.\n@return the greatest common divisor, never negative.\n@throws MathArithmeticException if the result cannot be represented as\na non-negative {@code int} value.\n@since 1.1\n",
          "diff": "@@ -1,38 +1,38 @@\n public static int gcd(final int p, final int q) {\n     int u \u003d p;\n     int v \u003d q;\n     if ((u \u003d\u003d 0) || (v \u003d\u003d 0)) {\n         if ((u \u003d\u003d Integer.MIN_VALUE) || (v \u003d\u003d Integer.MIN_VALUE)) {\n-            throw MathRuntimeException.createArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS, p, q);\n+            throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS, p, q);\n         }\n         return FastMath.abs(u) + FastMath.abs(v);\n     }\n     if (u \u003e 0) {\n         u \u003d -u;\n     }\n     if (v \u003e 0) {\n         v \u003d -v;\n     }\n     int k \u003d 0;\n     while ((u \u0026 1) \u003d\u003d 0 \u0026\u0026 (v \u0026 1) \u003d\u003d 0 \u0026\u0026 k \u003c 31) {\n         u /\u003d 2;\n         v /\u003d 2;\n         k++;\n     }\n     if (k \u003d\u003d 31) {\n-        throw MathRuntimeException.createArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS, p, q);\n+        throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS, p, q);\n     }\n     int t \u003d ((u \u0026 1) \u003d\u003d 1) ? v : -(u / 2);\n     do {\n         while ((t \u0026 1) \u003d\u003d 0) {\n             t /\u003d 2;\n         }\n         if (t \u003e 0) {\n             u \u003d -t;\n         } else {\n             v \u003d t;\n         }\n         t \u003d (v - u) / 2;\n     } while (t !\u003d 0);\n     return -u * (1 \u003c\u003c k);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "\u003cp\u003e\nGets the greatest common divisor of the absolute value of two numbers,\nusing the \"binary gcd\" method which avoids division and modulo\noperations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef\nStein (1961).\n\u003c/p\u003e\nSpecial cases:\n\u003cul\u003e\n\u003cli\u003eThe invocations\n\u003ccode\u003egcd(Integer.MIN_VALUE, Integer.MIN_VALUE)\u003c/code\u003e,\n\u003ccode\u003egcd(Integer.MIN_VALUE, 0)\u003c/code\u003e and\n\u003ccode\u003egcd(0, Integer.MIN_VALUE)\u003c/code\u003e throw an\n\u003ccode\u003eArithmeticException\u003c/code\u003e, because the result would be 2^31, which\nis too large for an int value.\u003c/li\u003e\n\u003cli\u003eThe result of \u003ccode\u003egcd(x, x)\u003c/code\u003e, \u003ccode\u003egcd(0, x)\u003c/code\u003e and\n\u003ccode\u003egcd(x, 0)\u003c/code\u003e is the absolute value of \u003ccode\u003ex\u003c/code\u003e, except\nfor the special cases above.\n\u003cli\u003eThe invocation \u003ccode\u003egcd(0, 0)\u003c/code\u003e is the only one which returns\n\u003ccode\u003e0\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\n@param p any number\n@param q any number\n@return the greatest common divisor, never negative\n@throws ArithmeticException if the result cannot be represented as a\nnonnegative int value\n@since 1.1\n",
            "newValue": "\u003cp\u003e\nGets the greatest common divisor of the absolute value of two numbers,\nusing the \"binary gcd\" method which avoids division and modulo\noperations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef\nStein (1961).\n\u003c/p\u003e\nSpecial cases:\n\u003cul\u003e\n\u003cli\u003eThe invocations\n\u003ccode\u003egcd(Integer.MIN_VALUE, Integer.MIN_VALUE)\u003c/code\u003e,\n\u003ccode\u003egcd(Integer.MIN_VALUE, 0)\u003c/code\u003e and\n\u003ccode\u003egcd(0, Integer.MIN_VALUE)\u003c/code\u003e throw an\n\u003ccode\u003eArithmeticException\u003c/code\u003e, because the result would be 2^31, which\nis too large for an int value.\u003c/li\u003e\n\u003cli\u003eThe result of \u003ccode\u003egcd(x, x)\u003c/code\u003e, \u003ccode\u003egcd(0, x)\u003c/code\u003e and\n\u003ccode\u003egcd(x, 0)\u003c/code\u003e is the absolute value of \u003ccode\u003ex\u003c/code\u003e, except\nfor the special cases above.\n\u003cli\u003eThe invocation \u003ccode\u003egcd(0, 0)\u003c/code\u003e is the only one which returns\n\u003ccode\u003e0\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\n@param p Number.\n@param q Number.\n@return the greatest common divisor, never negative.\n@throws MathArithmeticException if the result cannot be represented as\na non-negative {@code int} value.\n@since 1.1\n"
          }
        }
      ]
    },
    "80b1e90b42a34856b61cec628fcea6633d1000cd": {
      "type": "Ybodychange",
      "commitMessage": "added FastMath and used it everywhere in replacement of java.util.Math\nthe unit tests have not been added yet (waiting for dfp library addition)\nJIRA: MATH-375\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@990658 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "8/29/10, 3:04 PM",
      "commitName": "80b1e90b42a34856b61cec628fcea6633d1000cd",
      "commitAuthor": "Luc Maisonobe",
      "commitDateOld": "8/22/10, 4:45 PM",
      "commitNameOld": "ad93f56c541538f8f721a45f48cd133d9f06a795",
      "commitAuthorOld": "Gilles Sadowski",
      "daysBetweenCommits": 6.93,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "public static int gcd(final int p, final int q) {\n    int u \u003d p;\n    int v \u003d q;\n    if ((u \u003d\u003d 0) || (v \u003d\u003d 0)) {\n        if ((u \u003d\u003d Integer.MIN_VALUE) || (v \u003d\u003d Integer.MIN_VALUE)) {\n            throw MathRuntimeException.createArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS, p, q);\n        }\n        return FastMath.abs(u) + FastMath.abs(v);\n    }\n    if (u \u003e 0) {\n        u \u003d -u;\n    }\n    if (v \u003e 0) {\n        v \u003d -v;\n    }\n    int k \u003d 0;\n    while ((u \u0026 1) \u003d\u003d 0 \u0026\u0026 (v \u0026 1) \u003d\u003d 0 \u0026\u0026 k \u003c 31) {\n        u /\u003d 2;\n        v /\u003d 2;\n        k++;\n    }\n    if (k \u003d\u003d 31) {\n        throw MathRuntimeException.createArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS, p, q);\n    }\n    int t \u003d ((u \u0026 1) \u003d\u003d 1) ? v : -(u / 2);\n    do {\n        while ((t \u0026 1) \u003d\u003d 0) {\n            t /\u003d 2;\n        }\n        if (t \u003e 0) {\n            u \u003d -t;\n        } else {\n            v \u003d t;\n        }\n        t \u003d (v - u) / 2;\n    } while (t !\u003d 0);\n    return -u * (1 \u003c\u003c k);\n}",
      "path": "src/main/java/org/apache/commons/math/util/MathUtils.java",
      "functionStartLine": 699,
      "functionName": "gcd",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003e\nGets the greatest common divisor of the absolute value of two numbers,\nusing the \"binary gcd\" method which avoids division and modulo\noperations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef\nStein (1961).\n\u003c/p\u003e\nSpecial cases:\n\u003cul\u003e\n\u003cli\u003eThe invocations\n\u003ccode\u003egcd(Integer.MIN_VALUE, Integer.MIN_VALUE)\u003c/code\u003e,\n\u003ccode\u003egcd(Integer.MIN_VALUE, 0)\u003c/code\u003e and\n\u003ccode\u003egcd(0, Integer.MIN_VALUE)\u003c/code\u003e throw an\n\u003ccode\u003eArithmeticException\u003c/code\u003e, because the result would be 2^31, which\nis too large for an int value.\u003c/li\u003e\n\u003cli\u003eThe result of \u003ccode\u003egcd(x, x)\u003c/code\u003e, \u003ccode\u003egcd(0, x)\u003c/code\u003e and\n\u003ccode\u003egcd(x, 0)\u003c/code\u003e is the absolute value of \u003ccode\u003ex\u003c/code\u003e, except\nfor the special cases above.\n\u003cli\u003eThe invocation \u003ccode\u003egcd(0, 0)\u003c/code\u003e is the only one which returns\n\u003ccode\u003e0\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\n@param p any number\n@param q any number\n@return the greatest common divisor, never negative\n@throws ArithmeticException if the result cannot be represented as a\nnonnegative int value\n@since 1.1\n",
      "diff": "@@ -1,38 +1,38 @@\n public static int gcd(final int p, final int q) {\n     int u \u003d p;\n     int v \u003d q;\n     if ((u \u003d\u003d 0) || (v \u003d\u003d 0)) {\n         if ((u \u003d\u003d Integer.MIN_VALUE) || (v \u003d\u003d Integer.MIN_VALUE)) {\n             throw MathRuntimeException.createArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS, p, q);\n         }\n-        return Math.abs(u) + Math.abs(v);\n+        return FastMath.abs(u) + FastMath.abs(v);\n     }\n     if (u \u003e 0) {\n         u \u003d -u;\n     }\n     if (v \u003e 0) {\n         v \u003d -v;\n     }\n     int k \u003d 0;\n     while ((u \u0026 1) \u003d\u003d 0 \u0026\u0026 (v \u0026 1) \u003d\u003d 0 \u0026\u0026 k \u003c 31) {\n         u /\u003d 2;\n         v /\u003d 2;\n         k++;\n     }\n     if (k \u003d\u003d 31) {\n         throw MathRuntimeException.createArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS, p, q);\n     }\n     int t \u003d ((u \u0026 1) \u003d\u003d 1) ? v : -(u / 2);\n     do {\n         while ((t \u0026 1) \u003d\u003d 0) {\n             t /\u003d 2;\n         }\n         if (t \u003e 0) {\n             u \u003d -t;\n         } else {\n             v \u003d t;\n         }\n         t \u003d (v - u) / 2;\n     } while (t !\u003d 0);\n     return -u * (1 \u003c\u003c k);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1eaea0b549f685bd416cef68faa3a137b9bb3519": {
      "type": "Ybodychange",
      "commitMessage": "changed the localization mechanism for error messages. The new system is based on an enum rather than on duplicated string literals.\nJIRA: MATH-361\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@955423 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "6/16/10, 4:03 PM",
      "commitName": "1eaea0b549f685bd416cef68faa3a137b9bb3519",
      "commitAuthor": "Luc Maisonobe",
      "commitDateOld": "6/9/10, 3:41 AM",
      "commitNameOld": "adc837ab18b037b1f28974702aaaea4dcc36595f",
      "commitAuthorOld": "Gilles Sadowski",
      "daysBetweenCommits": 7.52,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "public static int gcd(final int p, final int q) {\n    int u \u003d p;\n    int v \u003d q;\n    if ((u \u003d\u003d 0) || (v \u003d\u003d 0)) {\n        if ((u \u003d\u003d Integer.MIN_VALUE) || (v \u003d\u003d Integer.MIN_VALUE)) {\n            throw MathRuntimeException.createArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS, p, q);\n        }\n        return Math.abs(u) + Math.abs(v);\n    }\n    if (u \u003e 0) {\n        u \u003d -u;\n    }\n    if (v \u003e 0) {\n        v \u003d -v;\n    }\n    int k \u003d 0;\n    while ((u \u0026 1) \u003d\u003d 0 \u0026\u0026 (v \u0026 1) \u003d\u003d 0 \u0026\u0026 k \u003c 31) {\n        u /\u003d 2;\n        v /\u003d 2;\n        k++;\n    }\n    if (k \u003d\u003d 31) {\n        throw MathRuntimeException.createArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS, p, q);\n    }\n    int t \u003d ((u \u0026 1) \u003d\u003d 1) ? v : -(u / 2);\n    do {\n        while ((t \u0026 1) \u003d\u003d 0) {\n            t /\u003d 2;\n        }\n        if (t \u003e 0) {\n            u \u003d -t;\n        } else {\n            v \u003d t;\n        }\n        t \u003d (v - u) / 2;\n    } while (t !\u003d 0);\n    return -u * (1 \u003c\u003c k);\n}",
      "path": "src/main/java/org/apache/commons/math/util/MathUtils.java",
      "functionStartLine": 696,
      "functionName": "gcd",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003e\nGets the greatest common divisor of the absolute value of two numbers,\nusing the \"binary gcd\" method which avoids division and modulo\noperations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef\nStein (1961).\n\u003c/p\u003e\nSpecial cases:\n\u003cul\u003e\n\u003cli\u003eThe invocations\n\u003ccode\u003egcd(Integer.MIN_VALUE, Integer.MIN_VALUE)\u003c/code\u003e,\n\u003ccode\u003egcd(Integer.MIN_VALUE, 0)\u003c/code\u003e and\n\u003ccode\u003egcd(0, Integer.MIN_VALUE)\u003c/code\u003e throw an\n\u003ccode\u003eArithmeticException\u003c/code\u003e, because the result would be 2^31, which\nis too large for an int value.\u003c/li\u003e\n\u003cli\u003eThe result of \u003ccode\u003egcd(x, x)\u003c/code\u003e, \u003ccode\u003egcd(0, x)\u003c/code\u003e and\n\u003ccode\u003egcd(x, 0)\u003c/code\u003e is the absolute value of \u003ccode\u003ex\u003c/code\u003e, except\nfor the special cases above.\n\u003cli\u003eThe invocation \u003ccode\u003egcd(0, 0)\u003c/code\u003e is the only one which returns\n\u003ccode\u003e0\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\n@param p any number\n@param q any number\n@return the greatest common divisor, never negative\n@throws ArithmeticException if the result cannot be represented as a\nnonnegative int value\n@since 1.1\n",
      "diff": "@@ -1,38 +1,38 @@\n public static int gcd(final int p, final int q) {\n     int u \u003d p;\n     int v \u003d q;\n     if ((u \u003d\u003d 0) || (v \u003d\u003d 0)) {\n         if ((u \u003d\u003d Integer.MIN_VALUE) || (v \u003d\u003d Integer.MIN_VALUE)) {\n-            throw MathRuntimeException.createArithmeticException(\"overflow: gcd({0}, {1}) is 2^31\", p, q);\n+            throw MathRuntimeException.createArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS, p, q);\n         }\n         return Math.abs(u) + Math.abs(v);\n     }\n     if (u \u003e 0) {\n         u \u003d -u;\n     }\n     if (v \u003e 0) {\n         v \u003d -v;\n     }\n     int k \u003d 0;\n     while ((u \u0026 1) \u003d\u003d 0 \u0026\u0026 (v \u0026 1) \u003d\u003d 0 \u0026\u0026 k \u003c 31) {\n         u /\u003d 2;\n         v /\u003d 2;\n         k++;\n     }\n     if (k \u003d\u003d 31) {\n-        throw MathRuntimeException.createArithmeticException(\"overflow: gcd({0}, {1}) is 2^31\", p, q);\n+        throw MathRuntimeException.createArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS, p, q);\n     }\n     int t \u003d ((u \u0026 1) \u003d\u003d 1) ? v : -(u / 2);\n     do {\n         while ((t \u0026 1) \u003d\u003d 0) {\n             t /\u003d 2;\n         }\n         if (t \u003e 0) {\n             u \u003d -t;\n         } else {\n             v \u003d t;\n         }\n         t \u003d (v - u) / 2;\n     } while (t !\u003d 0);\n     return -u * (1 \u003c\u003c k);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0fd871ca2c7b94bde0237cdf2f688460a05c1895": {
      "type": "Ydocchange",
      "commitMessage": "Added gcd(long, long), lcm(long, long) methods. JIRA: MATH-239.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@894730 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/30/09, 3:03 PM",
      "commitName": "0fd871ca2c7b94bde0237cdf2f688460a05c1895",
      "commitAuthor": "Phil Steitz",
      "commitDateOld": "11/27/09, 1:45 PM",
      "commitNameOld": "138baec1c778c2ea1dc1a6efe6d5e76a3b072b1d",
      "commitAuthorOld": "Phil Steitz",
      "daysBetweenCommits": 33.05,
      "commitsBetweenForRepo": 35,
      "commitsBetweenForFile": 1,
      "actualSource": "public static int gcd(final int p, final int q) {\n    int u \u003d p;\n    int v \u003d q;\n    if ((u \u003d\u003d 0) || (v \u003d\u003d 0)) {\n        if ((u \u003d\u003d Integer.MIN_VALUE) || (v \u003d\u003d Integer.MIN_VALUE)) {\n            throw MathRuntimeException.createArithmeticException(\"overflow: gcd({0}, {1}) is 2^31\", p, q);\n        }\n        return Math.abs(u) + Math.abs(v);\n    }\n    if (u \u003e 0) {\n        u \u003d -u;\n    }\n    if (v \u003e 0) {\n        v \u003d -v;\n    }\n    int k \u003d 0;\n    while ((u \u0026 1) \u003d\u003d 0 \u0026\u0026 (v \u0026 1) \u003d\u003d 0 \u0026\u0026 k \u003c 31) {\n        u /\u003d 2;\n        v /\u003d 2;\n        k++;\n    }\n    if (k \u003d\u003d 31) {\n        throw MathRuntimeException.createArithmeticException(\"overflow: gcd({0}, {1}) is 2^31\", p, q);\n    }\n    int t \u003d ((u \u0026 1) \u003d\u003d 1) ? v : -(u / 2);\n    do {\n        while ((t \u0026 1) \u003d\u003d 0) {\n            t /\u003d 2;\n        }\n        if (t \u003e 0) {\n            u \u003d -t;\n        } else {\n            v \u003d t;\n        }\n        t \u003d (v - u) / 2;\n    } while (t !\u003d 0);\n    return -u * (1 \u003c\u003c k);\n}",
      "path": "src/main/java/org/apache/commons/math/util/MathUtils.java",
      "functionStartLine": 613,
      "functionName": "gcd",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003e\nGets the greatest common divisor of the absolute value of two numbers,\nusing the \"binary gcd\" method which avoids division and modulo\noperations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef\nStein (1961).\n\u003c/p\u003e\nSpecial cases:\n\u003cul\u003e\n\u003cli\u003eThe invocations\n\u003ccode\u003egcd(Integer.MIN_VALUE, Integer.MIN_VALUE)\u003c/code\u003e,\n\u003ccode\u003egcd(Integer.MIN_VALUE, 0)\u003c/code\u003e and\n\u003ccode\u003egcd(0, Integer.MIN_VALUE)\u003c/code\u003e throw an\n\u003ccode\u003eArithmeticException\u003c/code\u003e, because the result would be 2^31, which\nis too large for an int value.\u003c/li\u003e\n\u003cli\u003eThe result of \u003ccode\u003egcd(x, x)\u003c/code\u003e, \u003ccode\u003egcd(0, x)\u003c/code\u003e and\n\u003ccode\u003egcd(x, 0)\u003c/code\u003e is the absolute value of \u003ccode\u003ex\u003c/code\u003e, except\nfor the special cases above.\n\u003cli\u003eThe invocation \u003ccode\u003egcd(0, 0)\u003c/code\u003e is the only one which returns\n\u003ccode\u003e0\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\n@param p any number\n@param q any number\n@return the greatest common divisor, never negative\n@throws ArithmeticException if the result cannot be represented as a\nnonnegative int value\n@since 1.1\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "\u003cp\u003e\nGets the greatest common divisor of the absolute value of two numbers,\nusing the \"binary gcd\" method which avoids division and modulo\noperations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef\nStein (1961).\n\u003c/p\u003e\nSpecial cases:\n\u003cul\u003e\n\u003cli\u003eThe invocations\n\u003ccode\u003egcd(Integer.MIN_VALUE, Integer.MIN_VALUE)\u003c/code\u003e,\n\u003ccode\u003egcd(Integer.MIN_VALUE, 0)\u003c/code\u003e and\n\u003ccode\u003egcd(0, Integer.MIN_VALUE)\u003c/code\u003e throw an\n\u003ccode\u003eArithmeticException\u003c/code\u003e, because the result would be 2^31, which\nis too large for an int value.\u003c/li\u003e\n\u003cli\u003eThe result of \u003ccode\u003egcd(x, x)\u003c/code\u003e, \u003ccode\u003egcd(0, x)\u003c/code\u003e and\n\u003ccode\u003egcd(x, 0)\u003c/code\u003e is the absolute value of \u003ccode\u003ex\u003c/code\u003e, except\nfor the special cases above.\n\u003cli\u003eThe invocation \u003ccode\u003egcd(0, 0)\u003c/code\u003e is the only one which returns\n\u003ccode\u003e0\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\n@param p any number\n@param q any number\n@return the greatest common divisor, never negative\n@throws ArithmeticException\n            if the result cannot be represented as a nonnegative int\n            value\n@since 1.1\n",
        "newValue": "\u003cp\u003e\nGets the greatest common divisor of the absolute value of two numbers,\nusing the \"binary gcd\" method which avoids division and modulo\noperations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef\nStein (1961).\n\u003c/p\u003e\nSpecial cases:\n\u003cul\u003e\n\u003cli\u003eThe invocations\n\u003ccode\u003egcd(Integer.MIN_VALUE, Integer.MIN_VALUE)\u003c/code\u003e,\n\u003ccode\u003egcd(Integer.MIN_VALUE, 0)\u003c/code\u003e and\n\u003ccode\u003egcd(0, Integer.MIN_VALUE)\u003c/code\u003e throw an\n\u003ccode\u003eArithmeticException\u003c/code\u003e, because the result would be 2^31, which\nis too large for an int value.\u003c/li\u003e\n\u003cli\u003eThe result of \u003ccode\u003egcd(x, x)\u003c/code\u003e, \u003ccode\u003egcd(0, x)\u003c/code\u003e and\n\u003ccode\u003egcd(x, 0)\u003c/code\u003e is the absolute value of \u003ccode\u003ex\u003c/code\u003e, except\nfor the special cases above.\n\u003cli\u003eThe invocation \u003ccode\u003egcd(0, 0)\u003c/code\u003e is the only one which returns\n\u003ccode\u003e0\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\n@param p any number\n@param q any number\n@return the greatest common divisor, never negative\n@throws ArithmeticException if the result cannot be represented as a\nnonnegative int value\n@since 1.1\n"
      }
    },
    "b631eb68a8aa659e0760de672edfbfb9f9ac246d": {
      "type": "Ybodychange",
      "commitMessage": "removed unnecessary parentheses\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@811833 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "9/6/09, 9:27 AM",
      "commitName": "b631eb68a8aa659e0760de672edfbfb9f9ac246d",
      "commitAuthor": "Luc Maisonobe",
      "commitDateOld": "9/6/09, 8:32 AM",
      "commitNameOld": "292e891aab4d737a83ebf786c02bf4003ae0442d",
      "commitAuthorOld": "Luc Maisonobe",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public static int gcd(final int p, final int q) {\n    int u \u003d p;\n    int v \u003d q;\n    if ((u \u003d\u003d 0) || (v \u003d\u003d 0)) {\n        if ((u \u003d\u003d Integer.MIN_VALUE) || (v \u003d\u003d Integer.MIN_VALUE)) {\n            throw MathRuntimeException.createArithmeticException(\"overflow: gcd({0}, {1}) is 2^31\", p, q);\n        }\n        return Math.abs(u) + Math.abs(v);\n    }\n    if (u \u003e 0) {\n        u \u003d -u;\n    }\n    if (v \u003e 0) {\n        v \u003d -v;\n    }\n    int k \u003d 0;\n    while ((u \u0026 1) \u003d\u003d 0 \u0026\u0026 (v \u0026 1) \u003d\u003d 0 \u0026\u0026 k \u003c 31) {\n        u /\u003d 2;\n        v /\u003d 2;\n        k++;\n    }\n    if (k \u003d\u003d 31) {\n        throw MathRuntimeException.createArithmeticException(\"overflow: gcd({0}, {1}) is 2^31\", p, q);\n    }\n    int t \u003d ((u \u0026 1) \u003d\u003d 1) ? v : -(u / 2);\n    do {\n        while ((t \u0026 1) \u003d\u003d 0) {\n            t /\u003d 2;\n        }\n        if (t \u003e 0) {\n            u \u003d -t;\n        } else {\n            v \u003d t;\n        }\n        t \u003d (v - u) / 2;\n    } while (t !\u003d 0);\n    return -u * (1 \u003c\u003c k);\n}",
      "path": "src/main/java/org/apache/commons/math/util/MathUtils.java",
      "functionStartLine": 608,
      "functionName": "gcd",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003e\nGets the greatest common divisor of the absolute value of two numbers,\nusing the \"binary gcd\" method which avoids division and modulo\noperations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef\nStein (1961).\n\u003c/p\u003e\nSpecial cases:\n\u003cul\u003e\n\u003cli\u003eThe invocations\n\u003ccode\u003egcd(Integer.MIN_VALUE, Integer.MIN_VALUE)\u003c/code\u003e,\n\u003ccode\u003egcd(Integer.MIN_VALUE, 0)\u003c/code\u003e and\n\u003ccode\u003egcd(0, Integer.MIN_VALUE)\u003c/code\u003e throw an\n\u003ccode\u003eArithmeticException\u003c/code\u003e, because the result would be 2^31, which\nis too large for an int value.\u003c/li\u003e\n\u003cli\u003eThe result of \u003ccode\u003egcd(x, x)\u003c/code\u003e, \u003ccode\u003egcd(0, x)\u003c/code\u003e and\n\u003ccode\u003egcd(x, 0)\u003c/code\u003e is the absolute value of \u003ccode\u003ex\u003c/code\u003e, except\nfor the special cases above.\n\u003cli\u003eThe invocation \u003ccode\u003egcd(0, 0)\u003c/code\u003e is the only one which returns\n\u003ccode\u003e0\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\n@param p any number\n@param q any number\n@return the greatest common divisor, never negative\n@throws ArithmeticException\n            if the result cannot be represented as a nonnegative int\n            value\n@since 1.1\n",
      "diff": "@@ -1,38 +1,38 @@\n public static int gcd(final int p, final int q) {\n     int u \u003d p;\n     int v \u003d q;\n     if ((u \u003d\u003d 0) || (v \u003d\u003d 0)) {\n         if ((u \u003d\u003d Integer.MIN_VALUE) || (v \u003d\u003d Integer.MIN_VALUE)) {\n             throw MathRuntimeException.createArithmeticException(\"overflow: gcd({0}, {1}) is 2^31\", p, q);\n         }\n-        return (Math.abs(u) + Math.abs(v));\n+        return Math.abs(u) + Math.abs(v);\n     }\n     if (u \u003e 0) {\n         u \u003d -u;\n     }\n     if (v \u003e 0) {\n         v \u003d -v;\n     }\n     int k \u003d 0;\n     while ((u \u0026 1) \u003d\u003d 0 \u0026\u0026 (v \u0026 1) \u003d\u003d 0 \u0026\u0026 k \u003c 31) {\n         u /\u003d 2;\n         v /\u003d 2;\n         k++;\n     }\n     if (k \u003d\u003d 31) {\n         throw MathRuntimeException.createArithmeticException(\"overflow: gcd({0}, {1}) is 2^31\", p, q);\n     }\n     int t \u003d ((u \u0026 1) \u003d\u003d 1) ? v : -(u / 2);\n     do {\n         while ((t \u0026 1) \u003d\u003d 0) {\n             t /\u003d 2;\n         }\n         if (t \u003e 0) {\n             u \u003d -t;\n         } else {\n             v \u003d t;\n         }\n         t \u003d (v - u) / 2;\n     } while (t !\u003d 0);\n     return -u * (1 \u003c\u003c k);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d6a438e931412713e99624cf9ed74470f1040184": {
      "type": "Yfilerename",
      "commitMessage": "moved main java directory for compliance with maven standard directory layout\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@799870 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "8/1/09, 7:30 AM",
      "commitName": "d6a438e931412713e99624cf9ed74470f1040184",
      "commitAuthor": "Luc Maisonobe",
      "commitDateOld": "8/1/09, 7:23 AM",
      "commitNameOld": "2ad5ef61630be627f46ae1c266cf796f044bd4a8",
      "commitAuthorOld": "Luc Maisonobe",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public static int gcd(final int p, final int q) {\n    int u \u003d p;\n    int v \u003d q;\n    if ((u \u003d\u003d 0) || (v \u003d\u003d 0)) {\n        if ((u \u003d\u003d Integer.MIN_VALUE) || (v \u003d\u003d Integer.MIN_VALUE)) {\n            throw MathRuntimeException.createArithmeticException(\"overflow: gcd({0}, {1}) is 2^31\", p, q);\n        }\n        return (Math.abs(u) + Math.abs(v));\n    }\n    if (u \u003e 0) {\n        u \u003d -u;\n    }\n    if (v \u003e 0) {\n        v \u003d -v;\n    }\n    int k \u003d 0;\n    while ((u \u0026 1) \u003d\u003d 0 \u0026\u0026 (v \u0026 1) \u003d\u003d 0 \u0026\u0026 k \u003c 31) {\n        u /\u003d 2;\n        v /\u003d 2;\n        k++;\n    }\n    if (k \u003d\u003d 31) {\n        throw MathRuntimeException.createArithmeticException(\"overflow: gcd({0}, {1}) is 2^31\", p, q);\n    }\n    int t \u003d ((u \u0026 1) \u003d\u003d 1) ? v : -(u / 2);\n    do {\n        while ((t \u0026 1) \u003d\u003d 0) {\n            t /\u003d 2;\n        }\n        if (t \u003e 0) {\n            u \u003d -t;\n        } else {\n            v \u003d t;\n        }\n        t \u003d (v - u) / 2;\n    } while (t !\u003d 0);\n    return -u * (1 \u003c\u003c k);\n}",
      "path": "src/main/java/org/apache/commons/math/util/MathUtils.java",
      "functionStartLine": 605,
      "functionName": "gcd",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003e\nGets the greatest common divisor of the absolute value of two numbers,\nusing the \"binary gcd\" method which avoids division and modulo\noperations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef\nStein (1961).\n\u003c/p\u003e\nSpecial cases:\n\u003cul\u003e\n\u003cli\u003eThe invocations\n\u003ccode\u003egcd(Integer.MIN_VALUE, Integer.MIN_VALUE)\u003c/code\u003e,\n\u003ccode\u003egcd(Integer.MIN_VALUE, 0)\u003c/code\u003e and\n\u003ccode\u003egcd(0, Integer.MIN_VALUE)\u003c/code\u003e throw an\n\u003ccode\u003eArithmeticException\u003c/code\u003e, because the result would be 2^31, which\nis too large for an int value.\u003c/li\u003e\n\u003cli\u003eThe result of \u003ccode\u003egcd(x, x)\u003c/code\u003e, \u003ccode\u003egcd(0, x)\u003c/code\u003e and\n\u003ccode\u003egcd(x, 0)\u003c/code\u003e is the absolute value of \u003ccode\u003ex\u003c/code\u003e, except\nfor the special cases above.\n\u003cli\u003eThe invocation \u003ccode\u003egcd(0, 0)\u003c/code\u003e is the only one which returns\n\u003ccode\u003e0\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\n@param p any number\n@param q any number\n@return the greatest common divisor, never negative\n@throws ArithmeticException\n            if the result cannot be represented as a nonnegative int\n            value\n@since 1.1\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/commons/math/util/MathUtils.java",
        "newPath": "src/main/java/org/apache/commons/math/util/MathUtils.java"
      }
    },
    "513511976ddc778f7c52d69bf43db3c3f4b88803": {
      "type": "Ydocchange",
      "commitMessage": "fixed checkstyle and findbugs errors\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@754765 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "3/15/09, 2:35 PM",
      "commitName": "513511976ddc778f7c52d69bf43db3c3f4b88803",
      "commitAuthor": "Luc Maisonobe",
      "commitDateOld": "3/1/09, 2:21 PM",
      "commitNameOld": "95836d833482615c11d46e2e655f3eea06a641d7",
      "commitAuthorOld": "Luc Maisonobe",
      "daysBetweenCommits": 13.97,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "actualSource": "public static int gcd(final int p, final int q) {\n    int u \u003d p;\n    int v \u003d q;\n    if ((u \u003d\u003d 0) || (v \u003d\u003d 0)) {\n        if ((u \u003d\u003d Integer.MIN_VALUE) || (v \u003d\u003d Integer.MIN_VALUE)) {\n            throw MathRuntimeException.createArithmeticException(\"overflow: gcd({0}, {1}) is 2^31\", p, q);\n        }\n        return (Math.abs(u) + Math.abs(v));\n    }\n    if (u \u003e 0) {\n        u \u003d -u;\n    }\n    if (v \u003e 0) {\n        v \u003d -v;\n    }\n    int k \u003d 0;\n    while ((u \u0026 1) \u003d\u003d 0 \u0026\u0026 (v \u0026 1) \u003d\u003d 0 \u0026\u0026 k \u003c 31) {\n        u /\u003d 2;\n        v /\u003d 2;\n        k++;\n    }\n    if (k \u003d\u003d 31) {\n        throw MathRuntimeException.createArithmeticException(\"overflow: gcd({0}, {1}) is 2^31\", p, q);\n    }\n    int t \u003d ((u \u0026 1) \u003d\u003d 1) ? v : -(u / 2);\n    do {\n        while ((t \u0026 1) \u003d\u003d 0) {\n            t /\u003d 2;\n        }\n        if (t \u003e 0) {\n            u \u003d -t;\n        } else {\n            v \u003d t;\n        }\n        t \u003d (v - u) / 2;\n    } while (t !\u003d 0);\n    return -u * (1 \u003c\u003c k);\n}",
      "path": "src/java/org/apache/commons/math/util/MathUtils.java",
      "functionStartLine": 560,
      "functionName": "gcd",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003e\nGets the greatest common divisor of the absolute value of two numbers,\nusing the \"binary gcd\" method which avoids division and modulo\noperations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef\nStein (1961).\n\u003c/p\u003e\nSpecial cases:\n\u003cul\u003e\n\u003cli\u003eThe invocations\n\u003ccode\u003egcd(Integer.MIN_VALUE, Integer.MIN_VALUE)\u003c/code\u003e,\n\u003ccode\u003egcd(Integer.MIN_VALUE, 0)\u003c/code\u003e and\n\u003ccode\u003egcd(0, Integer.MIN_VALUE)\u003c/code\u003e throw an\n\u003ccode\u003eArithmeticException\u003c/code\u003e, because the result would be 2^31, which\nis too large for an int value.\u003c/li\u003e\n\u003cli\u003eThe result of \u003ccode\u003egcd(x, x)\u003c/code\u003e, \u003ccode\u003egcd(0, x)\u003c/code\u003e and\n\u003ccode\u003egcd(x, 0)\u003c/code\u003e is the absolute value of \u003ccode\u003ex\u003c/code\u003e, except\nfor the special cases above.\n\u003cli\u003eThe invocation \u003ccode\u003egcd(0, 0)\u003c/code\u003e is the only one which returns\n\u003ccode\u003e0\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\n@param p any number\n@param q any number\n@return the greatest common divisor, never negative\n@throws ArithmeticException\n            if the result cannot be represented as a nonnegative int\n            value\n@since 1.1\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "\u003cp\u003e\nGets the greatest common divisor of the absolute value of two numbers,\nusing the \"binary gcd\" method which avoids division and modulo\noperations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef\nStein (1961).\n\u003c/p\u003e\nSpecial cases:\n\u003cul\u003e\n\u003cli\u003eThe invocations\n\u003ccode\u003egcd(Integer.MIN_VALUE, Integer.MIN_VALUE)\u003c/code\u003e,\n\u003ccode\u003egcd(Integer.MIN_VALUE, 0)\u003c/code\u003e and\n\u003ccode\u003egcd(0, Integer.MIN_VALUE)\u003c/code\u003e throw an\n\u003ccode\u003eArithmeticException\u003c/code\u003e, because the result would be 2^31, which\nis too large for an int value.\u003c/li\u003e\n\u003cli\u003eThe result of \u003ccode\u003egcd(x, x)\u003c/code\u003e, \u003ccode\u003egcd(0, x)\u003c/code\u003e and\n\u003ccode\u003egcd(x, 0)\u003c/code\u003e is the absolute value of \u003ccode\u003ex\u003c/code\u003e, except\nfor the special cases above.\n\u003cli\u003eThe invocation \u003ccode\u003egcd(0, 0)\u003c/code\u003e is the only one which returns\n\u003ccode\u003e0\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\n@param u any number\n@param v any number\n@return the greatest common divisor, never negative\n@throws ArithmeticException\n            if the result cannot be represented as a nonnegative int\n            value\n@since 1.1\n",
        "newValue": "\u003cp\u003e\nGets the greatest common divisor of the absolute value of two numbers,\nusing the \"binary gcd\" method which avoids division and modulo\noperations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef\nStein (1961).\n\u003c/p\u003e\nSpecial cases:\n\u003cul\u003e\n\u003cli\u003eThe invocations\n\u003ccode\u003egcd(Integer.MIN_VALUE, Integer.MIN_VALUE)\u003c/code\u003e,\n\u003ccode\u003egcd(Integer.MIN_VALUE, 0)\u003c/code\u003e and\n\u003ccode\u003egcd(0, Integer.MIN_VALUE)\u003c/code\u003e throw an\n\u003ccode\u003eArithmeticException\u003c/code\u003e, because the result would be 2^31, which\nis too large for an int value.\u003c/li\u003e\n\u003cli\u003eThe result of \u003ccode\u003egcd(x, x)\u003c/code\u003e, \u003ccode\u003egcd(0, x)\u003c/code\u003e and\n\u003ccode\u003egcd(x, 0)\u003c/code\u003e is the absolute value of \u003ccode\u003ex\u003c/code\u003e, except\nfor the special cases above.\n\u003cli\u003eThe invocation \u003ccode\u003egcd(0, 0)\u003c/code\u003e is the only one which returns\n\u003ccode\u003e0\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\n@param p any number\n@param q any number\n@return the greatest common divisor, never negative\n@throws ArithmeticException\n            if the result cannot be represented as a nonnegative int\n            value\n@since 1.1\n"
      }
    },
    "7f88773d6c3c96c0a2fd24c3e50d1eb80daca11d": {
      "type": "Ybodychange",
      "commitMessage": "replaced Object[] parameters by variable arguments in exceptions constructors\nthis allows simpler error declaration and removes the need for the strange\nnull argument with fixed messages\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@746578 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2/21/09, 12:01 PM",
      "commitName": "7f88773d6c3c96c0a2fd24c3e50d1eb80daca11d",
      "commitAuthor": "Luc Maisonobe",
      "commitDateOld": "2/21/09, 5:54 AM",
      "commitNameOld": "58b5609fe8f99aabc990d885bf6c4d85631b7c79",
      "commitAuthorOld": "Luc Maisonobe",
      "daysBetweenCommits": 0.25,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public static int gcd(final int p, final int q) {\n    int u \u003d p;\n    int v \u003d q;\n    if ((u \u003d\u003d 0) || (v \u003d\u003d 0)) {\n        if ((u \u003d\u003d Integer.MIN_VALUE) || (v \u003d\u003d Integer.MIN_VALUE)) {\n            throw MathRuntimeException.createArithmeticException(\"overflow: gcd({0}, {1}) is 2^31\", p, q);\n        }\n        return (Math.abs(u) + Math.abs(v));\n    }\n    if (u \u003e 0) {\n        u \u003d -u;\n    }\n    if (v \u003e 0) {\n        v \u003d -v;\n    }\n    int k \u003d 0;\n    while ((u \u0026 1) \u003d\u003d 0 \u0026\u0026 (v \u0026 1) \u003d\u003d 0 \u0026\u0026 k \u003c 31) {\n        u /\u003d 2;\n        v /\u003d 2;\n        k++;\n    }\n    if (k \u003d\u003d 31) {\n        throw MathRuntimeException.createArithmeticException(\"overflow: gcd({0}, {1}) is 2^31\", p, q);\n    }\n    int t \u003d ((u \u0026 1) \u003d\u003d 1) ? v : -(u / 2);\n    do {\n        while ((t \u0026 1) \u003d\u003d 0) {\n            t /\u003d 2;\n        }\n        if (t \u003e 0) {\n            u \u003d -t;\n        } else {\n            v \u003d t;\n        }\n        t \u003d (v - u) / 2;\n    } while (t !\u003d 0);\n    return -u * (1 \u003c\u003c k);\n}",
      "path": "src/java/org/apache/commons/math/util/MathUtils.java",
      "functionStartLine": 538,
      "functionName": "gcd",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003e\nGets the greatest common divisor of the absolute value of two numbers,\nusing the \"binary gcd\" method which avoids division and modulo\noperations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef\nStein (1961).\n\u003c/p\u003e\nSpecial cases:\n\u003cul\u003e\n\u003cli\u003eThe invocations\n\u003ccode\u003egcd(Integer.MIN_VALUE, Integer.MIN_VALUE)\u003c/code\u003e,\n\u003ccode\u003egcd(Integer.MIN_VALUE, 0)\u003c/code\u003e and\n\u003ccode\u003egcd(0, Integer.MIN_VALUE)\u003c/code\u003e throw an\n\u003ccode\u003eArithmeticException\u003c/code\u003e, because the result would be 2^31, which\nis too large for an int value.\u003c/li\u003e\n\u003cli\u003eThe result of \u003ccode\u003egcd(x, x)\u003c/code\u003e, \u003ccode\u003egcd(0, x)\u003c/code\u003e and\n\u003ccode\u003egcd(x, 0)\u003c/code\u003e is the absolute value of \u003ccode\u003ex\u003c/code\u003e, except\nfor the special cases above.\n\u003cli\u003eThe invocation \u003ccode\u003egcd(0, 0)\u003c/code\u003e is the only one which returns\n\u003ccode\u003e0\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\n@param u any number\n@param v any number\n@return the greatest common divisor, never negative\n@throws ArithmeticException\n            if the result cannot be represented as a nonnegative int\n            value\n@since 1.1\n",
      "diff": "@@ -1,38 +1,38 @@\n public static int gcd(final int p, final int q) {\n     int u \u003d p;\n     int v \u003d q;\n     if ((u \u003d\u003d 0) || (v \u003d\u003d 0)) {\n         if ((u \u003d\u003d Integer.MIN_VALUE) || (v \u003d\u003d Integer.MIN_VALUE)) {\n-            throw MathRuntimeException.createArithmeticException(\"overflow: gcd({0}, {1}) is 2^31\", new Object[] { p, q });\n+            throw MathRuntimeException.createArithmeticException(\"overflow: gcd({0}, {1}) is 2^31\", p, q);\n         }\n         return (Math.abs(u) + Math.abs(v));\n     }\n     if (u \u003e 0) {\n         u \u003d -u;\n     }\n     if (v \u003e 0) {\n         v \u003d -v;\n     }\n     int k \u003d 0;\n     while ((u \u0026 1) \u003d\u003d 0 \u0026\u0026 (v \u0026 1) \u003d\u003d 0 \u0026\u0026 k \u003c 31) {\n         u /\u003d 2;\n         v /\u003d 2;\n         k++;\n     }\n     if (k \u003d\u003d 31) {\n-        throw MathRuntimeException.createArithmeticException(\"overflow: gcd({0}, {1}) is 2^31\", new Object[] { p, q });\n+        throw MathRuntimeException.createArithmeticException(\"overflow: gcd({0}, {1}) is 2^31\", p, q);\n     }\n     int t \u003d ((u \u0026 1) \u003d\u003d 1) ? v : -(u / 2);\n     do {\n         while ((t \u0026 1) \u003d\u003d 0) {\n             t /\u003d 2;\n         }\n         if (t \u003e 0) {\n             u \u003d -t;\n         } else {\n             v \u003d t;\n         }\n         t \u003d (v - u) / 2;\n     } while (t !\u003d 0);\n     return -u * (1 \u003c\u003c k);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "58b5609fe8f99aabc990d885bf6c4d85631b7c79": {
      "type": "Ymultichange(Yparameterchange,Ybodychange,Ydocchange)",
      "commitMessage": "Fixed an error in computing gcd and lcm for some extreme values at integer range boundaries.\nJIRA: MATH-243\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@746511 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2/21/09, 5:54 AM",
      "commitName": "58b5609fe8f99aabc990d885bf6c4d85631b7c79",
      "commitAuthor": "Luc Maisonobe",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Fixed an error in computing gcd and lcm for some extreme values at integer range boundaries.\nJIRA: MATH-243\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@746511 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2/21/09, 5:54 AM",
          "commitName": "58b5609fe8f99aabc990d885bf6c4d85631b7c79",
          "commitAuthor": "Luc Maisonobe",
          "commitDateOld": "2/21/09, 5:36 AM",
          "commitNameOld": "924b6d76a2d44baf858c3aee46ab1439c9641959",
          "commitAuthorOld": "Luc Maisonobe",
          "daysBetweenCommits": 0.01,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public static int gcd(final int p, final int q) {\n    int u \u003d p;\n    int v \u003d q;\n    if ((u \u003d\u003d 0) || (v \u003d\u003d 0)) {\n        if ((u \u003d\u003d Integer.MIN_VALUE) || (v \u003d\u003d Integer.MIN_VALUE)) {\n            throw MathRuntimeException.createArithmeticException(\"overflow: gcd({0}, {1}) is 2^31\", new Object[] { p, q });\n        }\n        return (Math.abs(u) + Math.abs(v));\n    }\n    if (u \u003e 0) {\n        u \u003d -u;\n    }\n    if (v \u003e 0) {\n        v \u003d -v;\n    }\n    int k \u003d 0;\n    while ((u \u0026 1) \u003d\u003d 0 \u0026\u0026 (v \u0026 1) \u003d\u003d 0 \u0026\u0026 k \u003c 31) {\n        u /\u003d 2;\n        v /\u003d 2;\n        k++;\n    }\n    if (k \u003d\u003d 31) {\n        throw MathRuntimeException.createArithmeticException(\"overflow: gcd({0}, {1}) is 2^31\", new Object[] { p, q });\n    }\n    int t \u003d ((u \u0026 1) \u003d\u003d 1) ? v : -(u / 2);\n    do {\n        while ((t \u0026 1) \u003d\u003d 0) {\n            t /\u003d 2;\n        }\n        if (t \u003e 0) {\n            u \u003d -t;\n        } else {\n            v \u003d t;\n        }\n        t \u003d (v - u) / 2;\n    } while (t !\u003d 0);\n    return -u * (1 \u003c\u003c k);\n}",
          "path": "src/java/org/apache/commons/math/util/MathUtils.java",
          "functionStartLine": 539,
          "functionName": "gcd",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003e\nGets the greatest common divisor of the absolute value of two numbers,\nusing the \"binary gcd\" method which avoids division and modulo\noperations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef\nStein (1961).\n\u003c/p\u003e\nSpecial cases:\n\u003cul\u003e\n\u003cli\u003eThe invocations\n\u003ccode\u003egcd(Integer.MIN_VALUE, Integer.MIN_VALUE)\u003c/code\u003e,\n\u003ccode\u003egcd(Integer.MIN_VALUE, 0)\u003c/code\u003e and\n\u003ccode\u003egcd(0, Integer.MIN_VALUE)\u003c/code\u003e throw an\n\u003ccode\u003eArithmeticException\u003c/code\u003e, because the result would be 2^31, which\nis too large for an int value.\u003c/li\u003e\n\u003cli\u003eThe result of \u003ccode\u003egcd(x, x)\u003c/code\u003e, \u003ccode\u003egcd(0, x)\u003c/code\u003e and\n\u003ccode\u003egcd(x, 0)\u003c/code\u003e is the absolute value of \u003ccode\u003ex\u003c/code\u003e, except\nfor the special cases above.\n\u003cli\u003eThe invocation \u003ccode\u003egcd(0, 0)\u003c/code\u003e is the only one which returns\n\u003ccode\u003e0\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\n@param u any number\n@param v any number\n@return the greatest common divisor, never negative\n@throws ArithmeticException\n            if the result cannot be represented as a nonnegative int\n            value\n@since 1.1\n",
          "diff": "@@ -1,33 +1,38 @@\n-public static int gcd(int u, int v) {\n+public static int gcd(final int p, final int q) {\n+    int u \u003d p;\n+    int v \u003d q;\n     if ((u \u003d\u003d 0) || (v \u003d\u003d 0)) {\n+        if ((u \u003d\u003d Integer.MIN_VALUE) || (v \u003d\u003d Integer.MIN_VALUE)) {\n+            throw MathRuntimeException.createArithmeticException(\"overflow: gcd({0}, {1}) is 2^31\", new Object[] { p, q });\n+        }\n         return (Math.abs(u) + Math.abs(v));\n     }\n     if (u \u003e 0) {\n         u \u003d -u;\n     }\n     if (v \u003e 0) {\n         v \u003d -v;\n     }\n     int k \u003d 0;\n     while ((u \u0026 1) \u003d\u003d 0 \u0026\u0026 (v \u0026 1) \u003d\u003d 0 \u0026\u0026 k \u003c 31) {\n         u /\u003d 2;\n         v /\u003d 2;\n         k++;\n     }\n     if (k \u003d\u003d 31) {\n-        throw new ArithmeticException(\"overflow: gcd is 2^31\");\n+        throw MathRuntimeException.createArithmeticException(\"overflow: gcd({0}, {1}) is 2^31\", new Object[] { p, q });\n     }\n     int t \u003d ((u \u0026 1) \u003d\u003d 1) ? v : -(u / 2);\n     do {\n         while ((t \u0026 1) \u003d\u003d 0) {\n             t /\u003d 2;\n         }\n         if (t \u003e 0) {\n             u \u003d -t;\n         } else {\n             v \u003d t;\n         }\n         t \u003d (v - u) / 2;\n     } while (t !\u003d 0);\n     return -u * (1 \u003c\u003c k);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[u-int, v-int]",
            "newValue": "[p-int(modifiers-final), q-int(modifiers-final)]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Fixed an error in computing gcd and lcm for some extreme values at integer range boundaries.\nJIRA: MATH-243\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@746511 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2/21/09, 5:54 AM",
          "commitName": "58b5609fe8f99aabc990d885bf6c4d85631b7c79",
          "commitAuthor": "Luc Maisonobe",
          "commitDateOld": "2/21/09, 5:36 AM",
          "commitNameOld": "924b6d76a2d44baf858c3aee46ab1439c9641959",
          "commitAuthorOld": "Luc Maisonobe",
          "daysBetweenCommits": 0.01,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public static int gcd(final int p, final int q) {\n    int u \u003d p;\n    int v \u003d q;\n    if ((u \u003d\u003d 0) || (v \u003d\u003d 0)) {\n        if ((u \u003d\u003d Integer.MIN_VALUE) || (v \u003d\u003d Integer.MIN_VALUE)) {\n            throw MathRuntimeException.createArithmeticException(\"overflow: gcd({0}, {1}) is 2^31\", new Object[] { p, q });\n        }\n        return (Math.abs(u) + Math.abs(v));\n    }\n    if (u \u003e 0) {\n        u \u003d -u;\n    }\n    if (v \u003e 0) {\n        v \u003d -v;\n    }\n    int k \u003d 0;\n    while ((u \u0026 1) \u003d\u003d 0 \u0026\u0026 (v \u0026 1) \u003d\u003d 0 \u0026\u0026 k \u003c 31) {\n        u /\u003d 2;\n        v /\u003d 2;\n        k++;\n    }\n    if (k \u003d\u003d 31) {\n        throw MathRuntimeException.createArithmeticException(\"overflow: gcd({0}, {1}) is 2^31\", new Object[] { p, q });\n    }\n    int t \u003d ((u \u0026 1) \u003d\u003d 1) ? v : -(u / 2);\n    do {\n        while ((t \u0026 1) \u003d\u003d 0) {\n            t /\u003d 2;\n        }\n        if (t \u003e 0) {\n            u \u003d -t;\n        } else {\n            v \u003d t;\n        }\n        t \u003d (v - u) / 2;\n    } while (t !\u003d 0);\n    return -u * (1 \u003c\u003c k);\n}",
          "path": "src/java/org/apache/commons/math/util/MathUtils.java",
          "functionStartLine": 539,
          "functionName": "gcd",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003e\nGets the greatest common divisor of the absolute value of two numbers,\nusing the \"binary gcd\" method which avoids division and modulo\noperations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef\nStein (1961).\n\u003c/p\u003e\nSpecial cases:\n\u003cul\u003e\n\u003cli\u003eThe invocations\n\u003ccode\u003egcd(Integer.MIN_VALUE, Integer.MIN_VALUE)\u003c/code\u003e,\n\u003ccode\u003egcd(Integer.MIN_VALUE, 0)\u003c/code\u003e and\n\u003ccode\u003egcd(0, Integer.MIN_VALUE)\u003c/code\u003e throw an\n\u003ccode\u003eArithmeticException\u003c/code\u003e, because the result would be 2^31, which\nis too large for an int value.\u003c/li\u003e\n\u003cli\u003eThe result of \u003ccode\u003egcd(x, x)\u003c/code\u003e, \u003ccode\u003egcd(0, x)\u003c/code\u003e and\n\u003ccode\u003egcd(x, 0)\u003c/code\u003e is the absolute value of \u003ccode\u003ex\u003c/code\u003e, except\nfor the special cases above.\n\u003cli\u003eThe invocation \u003ccode\u003egcd(0, 0)\u003c/code\u003e is the only one which returns\n\u003ccode\u003e0\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\n@param u any number\n@param v any number\n@return the greatest common divisor, never negative\n@throws ArithmeticException\n            if the result cannot be represented as a nonnegative int\n            value\n@since 1.1\n",
          "diff": "@@ -1,33 +1,38 @@\n-public static int gcd(int u, int v) {\n+public static int gcd(final int p, final int q) {\n+    int u \u003d p;\n+    int v \u003d q;\n     if ((u \u003d\u003d 0) || (v \u003d\u003d 0)) {\n+        if ((u \u003d\u003d Integer.MIN_VALUE) || (v \u003d\u003d Integer.MIN_VALUE)) {\n+            throw MathRuntimeException.createArithmeticException(\"overflow: gcd({0}, {1}) is 2^31\", new Object[] { p, q });\n+        }\n         return (Math.abs(u) + Math.abs(v));\n     }\n     if (u \u003e 0) {\n         u \u003d -u;\n     }\n     if (v \u003e 0) {\n         v \u003d -v;\n     }\n     int k \u003d 0;\n     while ((u \u0026 1) \u003d\u003d 0 \u0026\u0026 (v \u0026 1) \u003d\u003d 0 \u0026\u0026 k \u003c 31) {\n         u /\u003d 2;\n         v /\u003d 2;\n         k++;\n     }\n     if (k \u003d\u003d 31) {\n-        throw new ArithmeticException(\"overflow: gcd is 2^31\");\n+        throw MathRuntimeException.createArithmeticException(\"overflow: gcd({0}, {1}) is 2^31\", new Object[] { p, q });\n     }\n     int t \u003d ((u \u0026 1) \u003d\u003d 1) ? v : -(u / 2);\n     do {\n         while ((t \u0026 1) \u003d\u003d 0) {\n             t /\u003d 2;\n         }\n         if (t \u003e 0) {\n             u \u003d -t;\n         } else {\n             v \u003d t;\n         }\n         t \u003d (v - u) / 2;\n     } while (t !\u003d 0);\n     return -u * (1 \u003c\u003c k);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Fixed an error in computing gcd and lcm for some extreme values at integer range boundaries.\nJIRA: MATH-243\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@746511 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2/21/09, 5:54 AM",
          "commitName": "58b5609fe8f99aabc990d885bf6c4d85631b7c79",
          "commitAuthor": "Luc Maisonobe",
          "commitDateOld": "2/21/09, 5:36 AM",
          "commitNameOld": "924b6d76a2d44baf858c3aee46ab1439c9641959",
          "commitAuthorOld": "Luc Maisonobe",
          "daysBetweenCommits": 0.01,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public static int gcd(final int p, final int q) {\n    int u \u003d p;\n    int v \u003d q;\n    if ((u \u003d\u003d 0) || (v \u003d\u003d 0)) {\n        if ((u \u003d\u003d Integer.MIN_VALUE) || (v \u003d\u003d Integer.MIN_VALUE)) {\n            throw MathRuntimeException.createArithmeticException(\"overflow: gcd({0}, {1}) is 2^31\", new Object[] { p, q });\n        }\n        return (Math.abs(u) + Math.abs(v));\n    }\n    if (u \u003e 0) {\n        u \u003d -u;\n    }\n    if (v \u003e 0) {\n        v \u003d -v;\n    }\n    int k \u003d 0;\n    while ((u \u0026 1) \u003d\u003d 0 \u0026\u0026 (v \u0026 1) \u003d\u003d 0 \u0026\u0026 k \u003c 31) {\n        u /\u003d 2;\n        v /\u003d 2;\n        k++;\n    }\n    if (k \u003d\u003d 31) {\n        throw MathRuntimeException.createArithmeticException(\"overflow: gcd({0}, {1}) is 2^31\", new Object[] { p, q });\n    }\n    int t \u003d ((u \u0026 1) \u003d\u003d 1) ? v : -(u / 2);\n    do {\n        while ((t \u0026 1) \u003d\u003d 0) {\n            t /\u003d 2;\n        }\n        if (t \u003e 0) {\n            u \u003d -t;\n        } else {\n            v \u003d t;\n        }\n        t \u003d (v - u) / 2;\n    } while (t !\u003d 0);\n    return -u * (1 \u003c\u003c k);\n}",
          "path": "src/java/org/apache/commons/math/util/MathUtils.java",
          "functionStartLine": 539,
          "functionName": "gcd",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003e\nGets the greatest common divisor of the absolute value of two numbers,\nusing the \"binary gcd\" method which avoids division and modulo\noperations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef\nStein (1961).\n\u003c/p\u003e\nSpecial cases:\n\u003cul\u003e\n\u003cli\u003eThe invocations\n\u003ccode\u003egcd(Integer.MIN_VALUE, Integer.MIN_VALUE)\u003c/code\u003e,\n\u003ccode\u003egcd(Integer.MIN_VALUE, 0)\u003c/code\u003e and\n\u003ccode\u003egcd(0, Integer.MIN_VALUE)\u003c/code\u003e throw an\n\u003ccode\u003eArithmeticException\u003c/code\u003e, because the result would be 2^31, which\nis too large for an int value.\u003c/li\u003e\n\u003cli\u003eThe result of \u003ccode\u003egcd(x, x)\u003c/code\u003e, \u003ccode\u003egcd(0, x)\u003c/code\u003e and\n\u003ccode\u003egcd(x, 0)\u003c/code\u003e is the absolute value of \u003ccode\u003ex\u003c/code\u003e, except\nfor the special cases above.\n\u003cli\u003eThe invocation \u003ccode\u003egcd(0, 0)\u003c/code\u003e is the only one which returns\n\u003ccode\u003e0\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\n@param u any number\n@param v any number\n@return the greatest common divisor, never negative\n@throws ArithmeticException\n            if the result cannot be represented as a nonnegative int\n            value\n@since 1.1\n",
          "diff": "@@ -1,33 +1,38 @@\n-public static int gcd(int u, int v) {\n+public static int gcd(final int p, final int q) {\n+    int u \u003d p;\n+    int v \u003d q;\n     if ((u \u003d\u003d 0) || (v \u003d\u003d 0)) {\n+        if ((u \u003d\u003d Integer.MIN_VALUE) || (v \u003d\u003d Integer.MIN_VALUE)) {\n+            throw MathRuntimeException.createArithmeticException(\"overflow: gcd({0}, {1}) is 2^31\", new Object[] { p, q });\n+        }\n         return (Math.abs(u) + Math.abs(v));\n     }\n     if (u \u003e 0) {\n         u \u003d -u;\n     }\n     if (v \u003e 0) {\n         v \u003d -v;\n     }\n     int k \u003d 0;\n     while ((u \u0026 1) \u003d\u003d 0 \u0026\u0026 (v \u0026 1) \u003d\u003d 0 \u0026\u0026 k \u003c 31) {\n         u /\u003d 2;\n         v /\u003d 2;\n         k++;\n     }\n     if (k \u003d\u003d 31) {\n-        throw new ArithmeticException(\"overflow: gcd is 2^31\");\n+        throw MathRuntimeException.createArithmeticException(\"overflow: gcd({0}, {1}) is 2^31\", new Object[] { p, q });\n     }\n     int t \u003d ((u \u0026 1) \u003d\u003d 1) ? v : -(u / 2);\n     do {\n         while ((t \u0026 1) \u003d\u003d 0) {\n             t /\u003d 2;\n         }\n         if (t \u003e 0) {\n             u \u003d -t;\n         } else {\n             v \u003d t;\n         }\n         t \u003d (v - u) / 2;\n     } while (t !\u003d 0);\n     return -u * (1 \u003c\u003c k);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "\u003cp\u003e\nGets the greatest common divisor of the absolute value of two numbers,\nusing the \"binary gcd\" method which avoids division and modulo\noperations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef\nStein (1961).\n\u003c/p\u003e\n\n@param u a non-zero number\n@param v a non-zero number\n@return the greatest common divisor, never zero\n@since 1.1\n",
            "newValue": "\u003cp\u003e\nGets the greatest common divisor of the absolute value of two numbers,\nusing the \"binary gcd\" method which avoids division and modulo\noperations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef\nStein (1961).\n\u003c/p\u003e\nSpecial cases:\n\u003cul\u003e\n\u003cli\u003eThe invocations\n\u003ccode\u003egcd(Integer.MIN_VALUE, Integer.MIN_VALUE)\u003c/code\u003e,\n\u003ccode\u003egcd(Integer.MIN_VALUE, 0)\u003c/code\u003e and\n\u003ccode\u003egcd(0, Integer.MIN_VALUE)\u003c/code\u003e throw an\n\u003ccode\u003eArithmeticException\u003c/code\u003e, because the result would be 2^31, which\nis too large for an int value.\u003c/li\u003e\n\u003cli\u003eThe result of \u003ccode\u003egcd(x, x)\u003c/code\u003e, \u003ccode\u003egcd(0, x)\u003c/code\u003e and\n\u003ccode\u003egcd(x, 0)\u003c/code\u003e is the absolute value of \u003ccode\u003ex\u003c/code\u003e, except\nfor the special cases above.\n\u003cli\u003eThe invocation \u003ccode\u003egcd(0, 0)\u003c/code\u003e is the only one which returns\n\u003ccode\u003e0\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\n@param u any number\n@param v any number\n@return the greatest common divisor, never negative\n@throws ArithmeticException\n            if the result cannot be represented as a nonnegative int\n            value\n@since 1.1\n"
          }
        }
      ]
    },
    "a96e597894562c2cf01fc678f6c435d65ccc31c5": {
      "type": "Ybodychange",
      "commitMessage": "fixed overflow error in gdc computation\nJIRA: MATH-238\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@735178 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "1/16/09, 3:06 PM",
      "commitName": "a96e597894562c2cf01fc678f6c435d65ccc31c5",
      "commitAuthor": "Luc Maisonobe",
      "commitDateOld": "11/22/08, 12:25 PM",
      "commitNameOld": "4b83ccb4273636b59711ab4a3e52bb9bb28d59c8",
      "commitAuthorOld": "Phil Steitz",
      "daysBetweenCommits": 55.11,
      "commitsBetweenForRepo": 98,
      "commitsBetweenForFile": 1,
      "actualSource": "public static int gcd(int u, int v) {\n    if ((u \u003d\u003d 0) || (v \u003d\u003d 0)) {\n        return (Math.abs(u) + Math.abs(v));\n    }\n    if (u \u003e 0) {\n        u \u003d -u;\n    }\n    if (v \u003e 0) {\n        v \u003d -v;\n    }\n    int k \u003d 0;\n    while ((u \u0026 1) \u003d\u003d 0 \u0026\u0026 (v \u0026 1) \u003d\u003d 0 \u0026\u0026 k \u003c 31) {\n        u /\u003d 2;\n        v /\u003d 2;\n        k++;\n    }\n    if (k \u003d\u003d 31) {\n        throw new ArithmeticException(\"overflow: gcd is 2^31\");\n    }\n    int t \u003d ((u \u0026 1) \u003d\u003d 1) ? v : -(u / 2);\n    do {\n        while ((t \u0026 1) \u003d\u003d 0) {\n            t /\u003d 2;\n        }\n        if (t \u003e 0) {\n            u \u003d -t;\n        } else {\n            v \u003d t;\n        }\n        t \u003d (v - u) / 2;\n    } while (t !\u003d 0);\n    return -u * (1 \u003c\u003c k);\n}",
      "path": "src/java/org/apache/commons/math/util/MathUtils.java",
      "functionStartLine": 411,
      "functionName": "gcd",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003e\nGets the greatest common divisor of the absolute value of two numbers,\nusing the \"binary gcd\" method which avoids division and modulo\noperations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef\nStein (1961).\n\u003c/p\u003e\n\n@param u a non-zero number\n@param v a non-zero number\n@return the greatest common divisor, never zero\n@since 1.1\n",
      "diff": "@@ -1,33 +1,33 @@\n public static int gcd(int u, int v) {\n-    if (u * v \u003d\u003d 0) {\n+    if ((u \u003d\u003d 0) || (v \u003d\u003d 0)) {\n         return (Math.abs(u) + Math.abs(v));\n     }\n     if (u \u003e 0) {\n         u \u003d -u;\n     }\n     if (v \u003e 0) {\n         v \u003d -v;\n     }\n     int k \u003d 0;\n     while ((u \u0026 1) \u003d\u003d 0 \u0026\u0026 (v \u0026 1) \u003d\u003d 0 \u0026\u0026 k \u003c 31) {\n         u /\u003d 2;\n         v /\u003d 2;\n         k++;\n     }\n     if (k \u003d\u003d 31) {\n         throw new ArithmeticException(\"overflow: gcd is 2^31\");\n     }\n     int t \u003d ((u \u0026 1) \u003d\u003d 1) ? v : -(u / 2);\n     do {\n         while ((t \u0026 1) \u003d\u003d 0) {\n             t /\u003d 2;\n         }\n         if (t \u003e 0) {\n             u \u003d -t;\n         } else {\n             v \u003d t;\n         }\n         t \u003d (v - u) / 2;\n     } while (t !\u003d 0);\n     return -u * (1 \u003c\u003c k);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b1ade04fc274a2030fcf1df2c760755eeb83bf1b": {
      "type": "Ymultichange(Ybodychange,Ydocchange)",
      "commitMessage": "PR: 35904\nChanged rounding methods to not rely on BigDecimal conversions which was causing numerical error.\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/math/trunk@231029 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "8/9/05, 6:10 AM",
      "commitName": "b1ade04fc274a2030fcf1df2c760755eeb83bf1b",
      "commitAuthor": "Brent Worden",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "PR: 35904\nChanged rounding methods to not rely on BigDecimal conversions which was causing numerical error.\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/math/trunk@231029 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "8/9/05, 6:10 AM",
          "commitName": "b1ade04fc274a2030fcf1df2c760755eeb83bf1b",
          "commitAuthor": "Brent Worden",
          "commitDateOld": "7/30/05, 12:25 AM",
          "commitNameOld": "7153fa9be229ee078c7026dba8c9b2be3d791ed2",
          "commitAuthorOld": "Phil Steitz",
          "daysBetweenCommits": 10.24,
          "commitsBetweenForRepo": 3,
          "commitsBetweenForFile": 1,
          "actualSource": "public static int gcd(int u, int v) {\n    if (u * v \u003d\u003d 0) {\n        return (Math.abs(u) + Math.abs(v));\n    }\n    if (u \u003e 0) {\n        u \u003d -u;\n    }\n    if (v \u003e 0) {\n        v \u003d -v;\n    }\n    int k \u003d 0;\n    while ((u \u0026 1) \u003d\u003d 0 \u0026\u0026 (v \u0026 1) \u003d\u003d 0 \u0026\u0026 k \u003c 31) {\n        u /\u003d 2;\n        v /\u003d 2;\n        k++;\n    }\n    if (k \u003d\u003d 31) {\n        throw new ArithmeticException(\"overflow: gcd is 2^31\");\n    }\n    int t \u003d ((u \u0026 1) \u003d\u003d 1) ? v : -(u / 2);\n    do {\n        while ((t \u0026 1) \u003d\u003d 0) {\n            t /\u003d 2;\n        }\n        if (t \u003e 0) {\n            u \u003d -t;\n        } else {\n            v \u003d t;\n        }\n        t \u003d (v - u) / 2;\n    } while (t !\u003d 0);\n    return -u * (1 \u003c\u003c k);\n}",
          "path": "src/java/org/apache/commons/math/util/MathUtils.java",
          "functionStartLine": 309,
          "functionName": "gcd",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003e\nGets the greatest common divisor of the absolute value of two numbers,\nusing the \"binary gcd\" method which avoids division and modulo\noperations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef\nStein (1961).\n\u003c/p\u003e\n\n@param u a non-zero number\n@param v a non-zero number\n@return the greatest common divisor, never zero\n@since 1.1\n",
          "diff": "",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "PR: 35904\nChanged rounding methods to not rely on BigDecimal conversions which was causing numerical error.\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/math/trunk@231029 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "8/9/05, 6:10 AM",
          "commitName": "b1ade04fc274a2030fcf1df2c760755eeb83bf1b",
          "commitAuthor": "Brent Worden",
          "commitDateOld": "7/30/05, 12:25 AM",
          "commitNameOld": "7153fa9be229ee078c7026dba8c9b2be3d791ed2",
          "commitAuthorOld": "Phil Steitz",
          "daysBetweenCommits": 10.24,
          "commitsBetweenForRepo": 3,
          "commitsBetweenForFile": 1,
          "actualSource": "public static int gcd(int u, int v) {\n    if (u * v \u003d\u003d 0) {\n        return (Math.abs(u) + Math.abs(v));\n    }\n    if (u \u003e 0) {\n        u \u003d -u;\n    }\n    if (v \u003e 0) {\n        v \u003d -v;\n    }\n    int k \u003d 0;\n    while ((u \u0026 1) \u003d\u003d 0 \u0026\u0026 (v \u0026 1) \u003d\u003d 0 \u0026\u0026 k \u003c 31) {\n        u /\u003d 2;\n        v /\u003d 2;\n        k++;\n    }\n    if (k \u003d\u003d 31) {\n        throw new ArithmeticException(\"overflow: gcd is 2^31\");\n    }\n    int t \u003d ((u \u0026 1) \u003d\u003d 1) ? v : -(u / 2);\n    do {\n        while ((t \u0026 1) \u003d\u003d 0) {\n            t /\u003d 2;\n        }\n        if (t \u003e 0) {\n            u \u003d -t;\n        } else {\n            v \u003d t;\n        }\n        t \u003d (v - u) / 2;\n    } while (t !\u003d 0);\n    return -u * (1 \u003c\u003c k);\n}",
          "path": "src/java/org/apache/commons/math/util/MathUtils.java",
          "functionStartLine": 309,
          "functionName": "gcd",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003e\nGets the greatest common divisor of the absolute value of two numbers,\nusing the \"binary gcd\" method which avoids division and modulo\noperations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef\nStein (1961).\n\u003c/p\u003e\n\n@param u a non-zero number\n@param v a non-zero number\n@return the greatest common divisor, never zero\n@since 1.1\n",
          "diff": "",
          "extendedDetails": {
            "oldValue": "\u003cp\u003eGets the greatest common divisor of the absolute value of\ntwo numbers, using the \"binary gcd\" method which avoids\ndivision and modulo operations.  See Knuth 4.5.2 algorithm B.\nThis algorithm is due to Josef Stein (1961).\u003c/p\u003e\n\n@param u a non-zero number\n@param v a non-zero number\n@return the greatest common divisor, never zero\n@since 1.1\n",
            "newValue": "\u003cp\u003e\nGets the greatest common divisor of the absolute value of two numbers,\nusing the \"binary gcd\" method which avoids division and modulo\noperations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef\nStein (1961).\n\u003c/p\u003e\n\n@param u a non-zero number\n@param v a non-zero number\n@return the greatest common divisor, never zero\n@since 1.1\n"
          }
        }
      ]
    },
    "c7a42fb239f8b723a9daf1903ec1ad64388da6bd": {
      "type": "Ydocchange",
      "commitMessage": "added @since tag to new methods.\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/math/trunk@178166 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "5/24/05, 6:24 AM",
      "commitName": "c7a42fb239f8b723a9daf1903ec1ad64388da6bd",
      "commitAuthor": "Brent Worden",
      "commitDateOld": "5/21/05, 10:25 PM",
      "commitNameOld": "b64000af437bfa5282f94ac0dfd2a0b1994af099",
      "commitAuthorOld": "Brent Worden",
      "daysBetweenCommits": 2.33,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "public static int gcd(int u, int v) {\n    if (u * v \u003d\u003d 0) {\n        return (Math.abs(u) + Math.abs(v));\n    }\n    if (u \u003e 0) {\n        u \u003d -u;\n    }\n    if (v \u003e 0) {\n        v \u003d -v;\n    }\n    int k \u003d 0;\n    while ((u \u0026 1) \u003d\u003d 0 \u0026\u0026 (v \u0026 1) \u003d\u003d 0 \u0026\u0026 k \u003c 31) {\n        u /\u003d 2;\n        v /\u003d 2;\n        k++;\n    }\n    if (k \u003d\u003d 31) {\n        throw new ArithmeticException(\"overflow: gcd is 2^31\");\n    }\n    int t \u003d ((u \u0026 1) \u003d\u003d 1) ? v : -(u / 2);\n    do {\n        while ((t \u0026 1) \u003d\u003d 0) {\n            t /\u003d 2;\n        }\n        if (t \u003e 0) {\n            u \u003d -t;\n        } else {\n            v \u003d t;\n        }\n        t \u003d (v - u) / 2;\n    } while (t !\u003d 0);\n    return -u * (1 \u003c\u003c k);\n}",
      "path": "src/java/org/apache/commons/math/util/MathUtils.java",
      "functionStartLine": 553,
      "functionName": "gcd",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eGets the greatest common divisor of the absolute value of\ntwo numbers, using the \"binary gcd\" method which avoids\ndivision and modulo operations.  See Knuth 4.5.2 algorithm B.\nThis algorithm is due to Josef Stein (1961).\u003c/p\u003e\n\n@param u a non-zero number\n@param v a non-zero number\n@return the greatest common divisor, never zero\n@since 1.1\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "\u003cp\u003eGets the greatest common divisor of the absolute value of\ntwo numbers, using the \"binary gcd\" method which avoids\ndivision and modulo operations.  See Knuth 4.5.2 algorithm B.\nThis algorithm is due to Josef Stein (1961).\u003c/p\u003e\n\n@param u a non-zero number\n@param v a non-zero number\n@return the greatest common divisor, never zero\n",
        "newValue": "\u003cp\u003eGets the greatest common divisor of the absolute value of\ntwo numbers, using the \"binary gcd\" method which avoids\ndivision and modulo operations.  See Knuth 4.5.2 algorithm B.\nThis algorithm is due to Josef Stein (1961).\u003c/p\u003e\n\n@param u a non-zero number\n@param v a non-zero number\n@return the greatest common divisor, never zero\n@since 1.1\n"
      }
    },
    "20786a617657c0c20315005c621052a2735dfe67": {
      "type": "Ymultichange(Yparameterchange,Ybodychange,Ydocchange)",
      "commitMessage": "Ported numerics improvements in commons lang Fraction implementation.\nAdded utility methods for overflow-checked integer arithmetic and\nimproved gcd method in MathUtils.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/math/trunk@168072 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "5/3/05, 10:14 PM",
      "commitName": "20786a617657c0c20315005c621052a2735dfe67",
      "commitAuthor": "Phil Steitz",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Ported numerics improvements in commons lang Fraction implementation.\nAdded utility methods for overflow-checked integer arithmetic and\nimproved gcd method in MathUtils.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/math/trunk@168072 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "5/3/05, 10:14 PM",
          "commitName": "20786a617657c0c20315005c621052a2735dfe67",
          "commitAuthor": "Phil Steitz",
          "commitDateOld": "2/26/05, 5:11 AM",
          "commitNameOld": "65b65f88b74de6b3462b04b2cf2a69f064a77557",
          "commitAuthorOld": "Dirk Verbeeck",
          "daysBetweenCommits": 66.67,
          "commitsBetweenForRepo": 13,
          "commitsBetweenForFile": 1,
          "actualSource": "public static int gcd(int u, int v) {\n    if (u * v \u003d\u003d 0) {\n        return (Math.abs(u) + Math.abs(v));\n    }\n    if (u \u003e 0) {\n        u \u003d -u;\n    }\n    if (v \u003e 0) {\n        v \u003d -v;\n    }\n    int k \u003d 0;\n    while ((u \u0026 1) \u003d\u003d 0 \u0026\u0026 (v \u0026 1) \u003d\u003d 0 \u0026\u0026 k \u003c 31) {\n        u /\u003d 2;\n        v /\u003d 2;\n        k++;\n    }\n    if (k \u003d\u003d 31) {\n        throw new ArithmeticException(\"overflow: gcd is 2^31\");\n    }\n    int t \u003d ((u \u0026 1) \u003d\u003d 1) ? v : -(u / 2);\n    do {\n        while ((t \u0026 1) \u003d\u003d 0) {\n            t /\u003d 2;\n        }\n        if (t \u003e 0) {\n            u \u003d -t;\n        } else {\n            v \u003d t;\n        }\n        t \u003d (v - u) / 2;\n    } while (t !\u003d 0);\n    return -u * (1 \u003c\u003c k);\n}",
          "path": "src/java/org/apache/commons/math/util/MathUtils.java",
          "functionStartLine": 547,
          "functionName": "gcd",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003eGets the greatest common divisor of the absolute value of\ntwo numbers, using the \"binary gcd\" method which avoids\ndivision and modulo operations.  See Knuth 4.5.2 algorithm B.\nThis algorithm is due to Josef Stein (1961).\u003c/p\u003e\n\n@param u a non-zero number\n@param v a non-zero number\n@return the greatest common divisor, never zero\n",
          "diff": "@@ -1,21 +1,33 @@\n-public static int gcd(int a, int b) {\n-    int ret;\n-    if (a \u003d\u003d 0) {\n-        ret \u003d Math.abs(b);\n-    } else if (b \u003d\u003d 0) {\n-        ret \u003d Math.abs(a);\n-    } else if (a \u003c 0) {\n-        ret \u003d gcd(-a, b);\n-    } else if (b \u003c 0) {\n-        ret \u003d gcd(a, -b);\n-    } else {\n-        int r \u003d 0;\n-        while (b \u003e 0) {\n-            r \u003d a % b;\n-            a \u003d b;\n-            b \u003d r;\n-        }\n-        ret \u003d a;\n+public static int gcd(int u, int v) {\n+    if (u * v \u003d\u003d 0) {\n+        return (Math.abs(u) + Math.abs(v));\n     }\n-    return ret;\n+    if (u \u003e 0) {\n+        u \u003d -u;\n+    }\n+    if (v \u003e 0) {\n+        v \u003d -v;\n+    }\n+    int k \u003d 0;\n+    while ((u \u0026 1) \u003d\u003d 0 \u0026\u0026 (v \u0026 1) \u003d\u003d 0 \u0026\u0026 k \u003c 31) {\n+        u /\u003d 2;\n+        v /\u003d 2;\n+        k++;\n+    }\n+    if (k \u003d\u003d 31) {\n+        throw new ArithmeticException(\"overflow: gcd is 2^31\");\n+    }\n+    int t \u003d ((u \u0026 1) \u003d\u003d 1) ? v : -(u / 2);\n+    do {\n+        while ((t \u0026 1) \u003d\u003d 0) {\n+            t /\u003d 2;\n+        }\n+        if (t \u003e 0) {\n+            u \u003d -t;\n+        } else {\n+            v \u003d t;\n+        }\n+        t \u003d (v - u) / 2;\n+    } while (t !\u003d 0);\n+    return -u * (1 \u003c\u003c k);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[a-int, b-int]",
            "newValue": "[u-int, v-int]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Ported numerics improvements in commons lang Fraction implementation.\nAdded utility methods for overflow-checked integer arithmetic and\nimproved gcd method in MathUtils.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/math/trunk@168072 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "5/3/05, 10:14 PM",
          "commitName": "20786a617657c0c20315005c621052a2735dfe67",
          "commitAuthor": "Phil Steitz",
          "commitDateOld": "2/26/05, 5:11 AM",
          "commitNameOld": "65b65f88b74de6b3462b04b2cf2a69f064a77557",
          "commitAuthorOld": "Dirk Verbeeck",
          "daysBetweenCommits": 66.67,
          "commitsBetweenForRepo": 13,
          "commitsBetweenForFile": 1,
          "actualSource": "public static int gcd(int u, int v) {\n    if (u * v \u003d\u003d 0) {\n        return (Math.abs(u) + Math.abs(v));\n    }\n    if (u \u003e 0) {\n        u \u003d -u;\n    }\n    if (v \u003e 0) {\n        v \u003d -v;\n    }\n    int k \u003d 0;\n    while ((u \u0026 1) \u003d\u003d 0 \u0026\u0026 (v \u0026 1) \u003d\u003d 0 \u0026\u0026 k \u003c 31) {\n        u /\u003d 2;\n        v /\u003d 2;\n        k++;\n    }\n    if (k \u003d\u003d 31) {\n        throw new ArithmeticException(\"overflow: gcd is 2^31\");\n    }\n    int t \u003d ((u \u0026 1) \u003d\u003d 1) ? v : -(u / 2);\n    do {\n        while ((t \u0026 1) \u003d\u003d 0) {\n            t /\u003d 2;\n        }\n        if (t \u003e 0) {\n            u \u003d -t;\n        } else {\n            v \u003d t;\n        }\n        t \u003d (v - u) / 2;\n    } while (t !\u003d 0);\n    return -u * (1 \u003c\u003c k);\n}",
          "path": "src/java/org/apache/commons/math/util/MathUtils.java",
          "functionStartLine": 547,
          "functionName": "gcd",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003eGets the greatest common divisor of the absolute value of\ntwo numbers, using the \"binary gcd\" method which avoids\ndivision and modulo operations.  See Knuth 4.5.2 algorithm B.\nThis algorithm is due to Josef Stein (1961).\u003c/p\u003e\n\n@param u a non-zero number\n@param v a non-zero number\n@return the greatest common divisor, never zero\n",
          "diff": "@@ -1,21 +1,33 @@\n-public static int gcd(int a, int b) {\n-    int ret;\n-    if (a \u003d\u003d 0) {\n-        ret \u003d Math.abs(b);\n-    } else if (b \u003d\u003d 0) {\n-        ret \u003d Math.abs(a);\n-    } else if (a \u003c 0) {\n-        ret \u003d gcd(-a, b);\n-    } else if (b \u003c 0) {\n-        ret \u003d gcd(a, -b);\n-    } else {\n-        int r \u003d 0;\n-        while (b \u003e 0) {\n-            r \u003d a % b;\n-            a \u003d b;\n-            b \u003d r;\n-        }\n-        ret \u003d a;\n+public static int gcd(int u, int v) {\n+    if (u * v \u003d\u003d 0) {\n+        return (Math.abs(u) + Math.abs(v));\n     }\n-    return ret;\n+    if (u \u003e 0) {\n+        u \u003d -u;\n+    }\n+    if (v \u003e 0) {\n+        v \u003d -v;\n+    }\n+    int k \u003d 0;\n+    while ((u \u0026 1) \u003d\u003d 0 \u0026\u0026 (v \u0026 1) \u003d\u003d 0 \u0026\u0026 k \u003c 31) {\n+        u /\u003d 2;\n+        v /\u003d 2;\n+        k++;\n+    }\n+    if (k \u003d\u003d 31) {\n+        throw new ArithmeticException(\"overflow: gcd is 2^31\");\n+    }\n+    int t \u003d ((u \u0026 1) \u003d\u003d 1) ? v : -(u / 2);\n+    do {\n+        while ((t \u0026 1) \u003d\u003d 0) {\n+            t /\u003d 2;\n+        }\n+        if (t \u003e 0) {\n+            u \u003d -t;\n+        } else {\n+            v \u003d t;\n+        }\n+        t \u003d (v - u) / 2;\n+    } while (t !\u003d 0);\n+    return -u * (1 \u003c\u003c k);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Ported numerics improvements in commons lang Fraction implementation.\nAdded utility methods for overflow-checked integer arithmetic and\nimproved gcd method in MathUtils.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/math/trunk@168072 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "5/3/05, 10:14 PM",
          "commitName": "20786a617657c0c20315005c621052a2735dfe67",
          "commitAuthor": "Phil Steitz",
          "commitDateOld": "2/26/05, 5:11 AM",
          "commitNameOld": "65b65f88b74de6b3462b04b2cf2a69f064a77557",
          "commitAuthorOld": "Dirk Verbeeck",
          "daysBetweenCommits": 66.67,
          "commitsBetweenForRepo": 13,
          "commitsBetweenForFile": 1,
          "actualSource": "public static int gcd(int u, int v) {\n    if (u * v \u003d\u003d 0) {\n        return (Math.abs(u) + Math.abs(v));\n    }\n    if (u \u003e 0) {\n        u \u003d -u;\n    }\n    if (v \u003e 0) {\n        v \u003d -v;\n    }\n    int k \u003d 0;\n    while ((u \u0026 1) \u003d\u003d 0 \u0026\u0026 (v \u0026 1) \u003d\u003d 0 \u0026\u0026 k \u003c 31) {\n        u /\u003d 2;\n        v /\u003d 2;\n        k++;\n    }\n    if (k \u003d\u003d 31) {\n        throw new ArithmeticException(\"overflow: gcd is 2^31\");\n    }\n    int t \u003d ((u \u0026 1) \u003d\u003d 1) ? v : -(u / 2);\n    do {\n        while ((t \u0026 1) \u003d\u003d 0) {\n            t /\u003d 2;\n        }\n        if (t \u003e 0) {\n            u \u003d -t;\n        } else {\n            v \u003d t;\n        }\n        t \u003d (v - u) / 2;\n    } while (t !\u003d 0);\n    return -u * (1 \u003c\u003c k);\n}",
          "path": "src/java/org/apache/commons/math/util/MathUtils.java",
          "functionStartLine": 547,
          "functionName": "gcd",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003eGets the greatest common divisor of the absolute value of\ntwo numbers, using the \"binary gcd\" method which avoids\ndivision and modulo operations.  See Knuth 4.5.2 algorithm B.\nThis algorithm is due to Josef Stein (1961).\u003c/p\u003e\n\n@param u a non-zero number\n@param v a non-zero number\n@return the greatest common divisor, never zero\n",
          "diff": "@@ -1,21 +1,33 @@\n-public static int gcd(int a, int b) {\n-    int ret;\n-    if (a \u003d\u003d 0) {\n-        ret \u003d Math.abs(b);\n-    } else if (b \u003d\u003d 0) {\n-        ret \u003d Math.abs(a);\n-    } else if (a \u003c 0) {\n-        ret \u003d gcd(-a, b);\n-    } else if (b \u003c 0) {\n-        ret \u003d gcd(a, -b);\n-    } else {\n-        int r \u003d 0;\n-        while (b \u003e 0) {\n-            r \u003d a % b;\n-            a \u003d b;\n-            b \u003d r;\n-        }\n-        ret \u003d a;\n+public static int gcd(int u, int v) {\n+    if (u * v \u003d\u003d 0) {\n+        return (Math.abs(u) + Math.abs(v));\n     }\n-    return ret;\n+    if (u \u003e 0) {\n+        u \u003d -u;\n+    }\n+    if (v \u003e 0) {\n+        v \u003d -v;\n+    }\n+    int k \u003d 0;\n+    while ((u \u0026 1) \u003d\u003d 0 \u0026\u0026 (v \u0026 1) \u003d\u003d 0 \u0026\u0026 k \u003c 31) {\n+        u /\u003d 2;\n+        v /\u003d 2;\n+        k++;\n+    }\n+    if (k \u003d\u003d 31) {\n+        throw new ArithmeticException(\"overflow: gcd is 2^31\");\n+    }\n+    int t \u003d ((u \u0026 1) \u003d\u003d 1) ? v : -(u / 2);\n+    do {\n+        while ((t \u0026 1) \u003d\u003d 0) {\n+            t /\u003d 2;\n+        }\n+        if (t \u003e 0) {\n+            u \u003d -t;\n+        } else {\n+            v \u003d t;\n+        }\n+        t \u003d (v - u) / 2;\n+    } while (t !\u003d 0);\n+    return -u * (1 \u003c\u003c k);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Returns the greatest common divisor between two integer values.\n\n@param a the first integer value.\n@param b the second integer value.\n@return the greatest common divisor between a and b.\n",
            "newValue": "\u003cp\u003eGets the greatest common divisor of the absolute value of\ntwo numbers, using the \"binary gcd\" method which avoids\ndivision and modulo operations.  See Knuth 4.5.2 algorithm B.\nThis algorithm is due to Josef Stein (1961).\u003c/p\u003e\n\n@param u a non-zero number\n@param v a non-zero number\n@return the greatest common divisor, never zero\n"
          }
        }
      ]
    },
    "41598b038509e9cdb7f6dbeefdb2a2876d2708a6": {
      "type": "Yintroduced",
      "commitMessage": "added fraction class and fraction formatting classes.\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/math/trunk@151479 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2/4/05, 9:49 PM",
      "commitName": "41598b038509e9cdb7f6dbeefdb2a2876d2708a6",
      "commitAuthor": "Brent Worden",
      "diff": "@@ -0,0 +1,21 @@\n+public static int gcd(int a, int b) {\n+    int ret;\n+    if (a \u003d\u003d 0) {\n+        ret \u003d Math.abs(b);\n+    } else if (b \u003d\u003d 0) {\n+        ret \u003d Math.abs(a);\n+    } else if (a \u003c 0) {\n+        ret \u003d gcd(-a, b);\n+    } else if (b \u003c 0) {\n+        ret \u003d gcd(a, -b);\n+    } else {\n+        int r \u003d 0;\n+        while (b \u003e 0) {\n+            r \u003d a % b;\n+            a \u003d b;\n+            b \u003d r;\n+        }\n+        ret \u003d a;\n+    }\n+    return ret;\n+}\n\\ No newline at end of file\n",
      "actualSource": "public static int gcd(int a, int b) {\n    int ret;\n    if (a \u003d\u003d 0) {\n        ret \u003d Math.abs(b);\n    } else if (b \u003d\u003d 0) {\n        ret \u003d Math.abs(a);\n    } else if (a \u003c 0) {\n        ret \u003d gcd(-a, b);\n    } else if (b \u003c 0) {\n        ret \u003d gcd(a, -b);\n    } else {\n        int r \u003d 0;\n        while (b \u003e 0) {\n            r \u003d a % b;\n            a \u003d b;\n            b \u003d r;\n        }\n        ret \u003d a;\n    }\n    return ret;\n}",
      "path": "src/java/org/apache/commons/math/util/MathUtils.java",
      "functionStartLine": 488,
      "functionName": "gcd",
      "functionAnnotation": "",
      "functionDoc": "Returns the greatest common divisor between two integer values.\n\n@param a the first integer value.\n@param b the second integer value.\n@return the greatest common divisor between a and b.\n"
    }
  }
}