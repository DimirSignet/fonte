{
  "origin": "codeshovel",
  "repositoryName": "Lang-13b",
  "repositoryPath": "/tmp/Lang-13b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "SerializationUtils.java",
  "functionName": "clone",
  "functionId": "clone___object-T",
  "sourceFilePath": "src/main/java/org/apache/commons/lang3/SerializationUtils.java",
  "functionAnnotation": "",
  "functionDoc": "\u003cp\u003eDeep clone an {@code Object} using serialization.\u003c/p\u003e\n\n\u003cp\u003eThis is many times slower than writing clone methods by hand\non all objects in your object graph. However, for complex object\ngraphs, or for those that don\u0027t support deep cloning this can\nbe a simple alternative implementation. Of course all the objects\nmust be {@code Serializable}.\u003c/p\u003e\n\n@param \u003cT\u003e the type of the object involved\n@param object the {@code Serializable} object to clone\n@return the cloned object\n@throws SerializationException (runtime) if the serialization fails\n",
  "functionStartLine": 76,
  "functionEndLine": 109,
  "numCommitsSeen": 37,
  "timeTaken": 1661,
  "changeHistory": [
    "6ab98d913ae8cfc1cb54749ca7f6d20b5ec4b505",
    "01ab63a0f1d4b8d17d86dc4be56cbc7b92154a48",
    "ffe79899ff05351f5cba5156273b0d32046be5f8",
    "3fce71c9c1e59a4b555ac4591b0cfa35ddc94e27",
    "b2c32dc35e90124e62f0ddc32952fe5bbf8e656f",
    "dbd787b0d5c7394188ec4d74a5d52b461327f1c8",
    "b1686009b5494119575d43525b0829162ab79853",
    "586080851f6bca4d7aa84a7d307203ad8222407e",
    "30a5db352bf74d4f869f65cc320c63ccfd2f8cc7",
    "2f94a814dc01ae392768afb8110b2b55169ed69f",
    "d23b22c78078ee7468e797e80188ae9508c0eee0"
  ],
  "changeHistoryShort": {
    "6ab98d913ae8cfc1cb54749ca7f6d20b5ec4b505": "Ybodychange",
    "01ab63a0f1d4b8d17d86dc4be56cbc7b92154a48": "Ybodychange",
    "ffe79899ff05351f5cba5156273b0d32046be5f8": "Ydocchange",
    "3fce71c9c1e59a4b555ac4591b0cfa35ddc94e27": "Ydocchange",
    "b2c32dc35e90124e62f0ddc32952fe5bbf8e656f": "Ymultichange(Ybodychange,Yannotationchange)",
    "dbd787b0d5c7394188ec4d74a5d52b461327f1c8": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange,Yannotationchange)",
    "b1686009b5494119575d43525b0829162ab79853": "Yfilerename",
    "586080851f6bca4d7aa84a7d307203ad8222407e": "Yfilerename",
    "30a5db352bf74d4f869f65cc320c63ccfd2f8cc7": "Ydocchange",
    "2f94a814dc01ae392768afb8110b2b55169ed69f": "Yformatchange",
    "d23b22c78078ee7468e797e80188ae9508c0eee0": "Yintroduced"
  },
  "changeHistoryDetails": {
    "6ab98d913ae8cfc1cb54749ca7f6d20b5ec4b505": {
      "type": "Ybodychange",
      "commitMessage": "Suppress generic warning\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1199718 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/9/11, 4:43 AM",
      "commitName": "6ab98d913ae8cfc1cb54749ca7f6d20b5ec4b505",
      "commitAuthor": "Sebastian Bazley",
      "commitDateOld": "8/1/11, 11:57 PM",
      "commitNameOld": "01ab63a0f1d4b8d17d86dc4be56cbc7b92154a48",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 99.24,
      "commitsBetweenForRepo": 151,
      "commitsBetweenForFile": 1,
      "actualSource": "public static \u003cT extends Serializable\u003e T clone(T object) {\n    if (object \u003d\u003d null) {\n        return null;\n    }\n    byte[] objectData \u003d serialize(object);\n    ByteArrayInputStream bais \u003d new ByteArrayInputStream(objectData);\n    ClassLoaderAwareObjectInputStream in \u003d null;\n    try {\n        in \u003d new ClassLoaderAwareObjectInputStream(bais, object.getClass().getClassLoader());\n        @SuppressWarnings(\"unchecked\") T readObject \u003d (T) in.readObject();\n        return readObject;\n    } catch (ClassNotFoundException ex) {\n        throw new SerializationException(\"ClassNotFoundException while reading cloned object data\", ex);\n    } catch (IOException ex) {\n        throw new SerializationException(\"IOException while reading cloned object data\", ex);\n    } finally {\n        try {\n            if (in !\u003d null) {\n                in.close();\n            }\n        } catch (IOException ex) {\n            throw new SerializationException(\"IOException on closing cloned object data InputStream.\", ex);\n        }\n    }\n}",
      "path": "src/main/java/org/apache/commons/lang3/SerializationUtils.java",
      "functionStartLine": 76,
      "functionName": "clone",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eDeep clone an {@code Object} using serialization.\u003c/p\u003e\n\n\u003cp\u003eThis is many times slower than writing clone methods by hand\non all objects in your object graph. However, for complex object\ngraphs, or for those that don\u0027t support deep cloning this can\nbe a simple alternative implementation. Of course all the objects\nmust be {@code Serializable}.\u003c/p\u003e\n\n@param \u003cT\u003e the type of the object involved\n@param object the {@code Serializable} object to clone\n@return the cloned object\n@throws SerializationException (runtime) if the serialization fails\n",
      "diff": "@@ -1,24 +1,25 @@\n public static \u003cT extends Serializable\u003e T clone(T object) {\n     if (object \u003d\u003d null) {\n         return null;\n     }\n     byte[] objectData \u003d serialize(object);\n     ByteArrayInputStream bais \u003d new ByteArrayInputStream(objectData);\n     ClassLoaderAwareObjectInputStream in \u003d null;\n     try {\n         in \u003d new ClassLoaderAwareObjectInputStream(bais, object.getClass().getClassLoader());\n-        return (T) in.readObject();\n+        @SuppressWarnings(\"unchecked\") T readObject \u003d (T) in.readObject();\n+        return readObject;\n     } catch (ClassNotFoundException ex) {\n         throw new SerializationException(\"ClassNotFoundException while reading cloned object data\", ex);\n     } catch (IOException ex) {\n         throw new SerializationException(\"IOException while reading cloned object data\", ex);\n     } finally {\n         try {\n             if (in !\u003d null) {\n                 in.close();\n             }\n         } catch (IOException ex) {\n             throw new SerializationException(\"IOException on closing cloned object data InputStream.\", ex);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "01ab63a0f1d4b8d17d86dc4be56cbc7b92154a48": {
      "type": "Ybodychange",
      "commitMessage": "Applying Sven Ludwig\u0027s patch from LANG-626. This modifies the SerializationUtils.clone method to use the threadContextLoader if it is unable to find a class using the object\u0027s current classloader. This should (hopefully) help with Weblogic and Tomcat situations where Lang is outside the web-inf for some reason (likely user error with Tomcat, by design for Weblogic)\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1153046 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "8/1/11, 11:57 PM",
      "commitName": "01ab63a0f1d4b8d17d86dc4be56cbc7b92154a48",
      "commitAuthor": "Henri Yandell",
      "commitDateOld": "4/6/11, 9:39 PM",
      "commitNameOld": "5564fb57cf13dac2f052ceb3a7039a5d156fbe8d",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 117.1,
      "commitsBetweenForRepo": 236,
      "commitsBetweenForFile": 1,
      "actualSource": "public static \u003cT extends Serializable\u003e T clone(T object) {\n    if (object \u003d\u003d null) {\n        return null;\n    }\n    byte[] objectData \u003d serialize(object);\n    ByteArrayInputStream bais \u003d new ByteArrayInputStream(objectData);\n    ClassLoaderAwareObjectInputStream in \u003d null;\n    try {\n        in \u003d new ClassLoaderAwareObjectInputStream(bais, object.getClass().getClassLoader());\n        return (T) in.readObject();\n    } catch (ClassNotFoundException ex) {\n        throw new SerializationException(\"ClassNotFoundException while reading cloned object data\", ex);\n    } catch (IOException ex) {\n        throw new SerializationException(\"IOException while reading cloned object data\", ex);\n    } finally {\n        try {\n            if (in !\u003d null) {\n                in.close();\n            }\n        } catch (IOException ex) {\n            throw new SerializationException(\"IOException on closing cloned object data InputStream.\", ex);\n        }\n    }\n}",
      "path": "src/main/java/org/apache/commons/lang3/SerializationUtils.java",
      "functionStartLine": 76,
      "functionName": "clone",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eDeep clone an {@code Object} using serialization.\u003c/p\u003e\n\n\u003cp\u003eThis is many times slower than writing clone methods by hand\non all objects in your object graph. However, for complex object\ngraphs, or for those that don\u0027t support deep cloning this can\nbe a simple alternative implementation. Of course all the objects\nmust be {@code Serializable}.\u003c/p\u003e\n\n@param \u003cT\u003e the type of the object involved\n@param object the {@code Serializable} object to clone\n@return the cloned object\n@throws SerializationException (runtime) if the serialization fails\n",
      "diff": "@@ -1,4 +1,24 @@\n public static \u003cT extends Serializable\u003e T clone(T object) {\n-    @SuppressWarnings(\"unchecked\") final T result \u003d (T) deserialize(serialize(object));\n-    return result;\n+    if (object \u003d\u003d null) {\n+        return null;\n+    }\n+    byte[] objectData \u003d serialize(object);\n+    ByteArrayInputStream bais \u003d new ByteArrayInputStream(objectData);\n+    ClassLoaderAwareObjectInputStream in \u003d null;\n+    try {\n+        in \u003d new ClassLoaderAwareObjectInputStream(bais, object.getClass().getClassLoader());\n+        return (T) in.readObject();\n+    } catch (ClassNotFoundException ex) {\n+        throw new SerializationException(\"ClassNotFoundException while reading cloned object data\", ex);\n+    } catch (IOException ex) {\n+        throw new SerializationException(\"IOException while reading cloned object data\", ex);\n+    } finally {\n+        try {\n+            if (in !\u003d null) {\n+                in.close();\n+            }\n+        } catch (IOException ex) {\n+            throw new SerializationException(\"IOException on closing cloned object data InputStream.\", ex);\n+        }\n+    }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ffe79899ff05351f5cba5156273b0d32046be5f8": {
      "type": "Ydocchange",
      "commitMessage": "Checkstyle and trailing spaces.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1083207 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "3/19/11, 9:09 AM",
      "commitName": "ffe79899ff05351f5cba5156273b0d32046be5f8",
      "commitAuthor": "Oliver Heger",
      "commitDateOld": "3/4/11, 8:07 AM",
      "commitNameOld": "3fce71c9c1e59a4b555ac4591b0cfa35ddc94e27",
      "commitAuthorOld": "Stephen Colebourne",
      "daysBetweenCommits": 15.0,
      "commitsBetweenForRepo": 55,
      "commitsBetweenForFile": 1,
      "actualSource": "public static \u003cT extends Serializable\u003e T clone(T object) {\n    @SuppressWarnings(\"unchecked\") final T result \u003d (T) deserialize(serialize(object));\n    return result;\n}",
      "path": "src/main/java/org/apache/commons/lang3/SerializationUtils.java",
      "functionStartLine": 81,
      "functionName": "clone",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eDeep clone an {@code Object} using serialization.\u003c/p\u003e\n\n\u003cp\u003eThis is many times slower than writing clone methods by hand\non all objects in your object graph. However, for complex object\ngraphs, or for those that don\u0027t support deep cloning this can\nbe a simple alternative implementation. Of course all the objects\nmust be {@code Serializable}.\u003c/p\u003e\n\n@param \u003cT\u003e the type of the object involved\n@param object the {@code Serializable} object to clone\n@return the cloned object\n@throws SerializationException (runtime) if the serialization fails\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "\u003cp\u003eDeep clone an {@code Object} using serialization.\u003c/p\u003e\n\n\u003cp\u003eThis is many times slower than writing clone methods by hand\non all objects in your object graph. However, for complex object\ngraphs, or for those that don\u0027t support deep cloning this can\nbe a simple alternative implementation. Of course all the objects\nmust be {@code Serializable}.\u003c/p\u003e\n\n@param object the {@code Serializable} object to clone\n@return the cloned object\n@throws SerializationException (runtime) if the serialization fails\n",
        "newValue": "\u003cp\u003eDeep clone an {@code Object} using serialization.\u003c/p\u003e\n\n\u003cp\u003eThis is many times slower than writing clone methods by hand\non all objects in your object graph. However, for complex object\ngraphs, or for those that don\u0027t support deep cloning this can\nbe a simple alternative implementation. Of course all the objects\nmust be {@code Serializable}.\u003c/p\u003e\n\n@param \u003cT\u003e the type of the object involved\n@param object the {@code Serializable} object to clone\n@return the cloned object\n@throws SerializationException (runtime) if the serialization fails\n"
      }
    },
    "3fce71c9c1e59a4b555ac4591b0cfa35ddc94e27": {
      "type": "Ydocchange",
      "commitMessage": "Javadoc\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1078032 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "3/4/11, 8:07 AM",
      "commitName": "3fce71c9c1e59a4b555ac4591b0cfa35ddc94e27",
      "commitAuthor": "Stephen Colebourne",
      "commitDateOld": "8/25/10, 3:22 PM",
      "commitNameOld": "b2c32dc35e90124e62f0ddc32952fe5bbf8e656f",
      "commitAuthorOld": "Matthew Jason Benson",
      "daysBetweenCommits": 190.74,
      "commitsBetweenForRepo": 168,
      "commitsBetweenForFile": 1,
      "actualSource": "public static \u003cT extends Serializable\u003e T clone(T object) {\n    @SuppressWarnings(\"unchecked\") final T result \u003d (T) deserialize(serialize(object));\n    return result;\n}",
      "path": "src/main/java/org/apache/commons/lang3/SerializationUtils.java",
      "functionStartLine": 80,
      "functionName": "clone",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eDeep clone an {@code Object} using serialization.\u003c/p\u003e\n\n\u003cp\u003eThis is many times slower than writing clone methods by hand\non all objects in your object graph. However, for complex object\ngraphs, or for those that don\u0027t support deep cloning this can\nbe a simple alternative implementation. Of course all the objects\nmust be {@code Serializable}.\u003c/p\u003e\n\n@param object the {@code Serializable} object to clone\n@return the cloned object\n@throws SerializationException (runtime) if the serialization fails\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "\u003cp\u003eDeep clone an \u003ccode\u003eObject\u003c/code\u003e using serialization.\u003c/p\u003e\n\n\u003cp\u003eThis is many times slower than writing clone methods by hand\non all objects in your object graph. However, for complex object\ngraphs, or for those that don\u0027t support deep cloning this can\nbe a simple alternative implementation. Of course all the objects\nmust be \u003ccode\u003eSerializable\u003c/code\u003e.\u003c/p\u003e\n\n@param object the \u003ccode\u003eSerializable\u003c/code\u003e object to clone\n@return the cloned object\n@throws SerializationException (runtime) if the serialization fails\n",
        "newValue": "\u003cp\u003eDeep clone an {@code Object} using serialization.\u003c/p\u003e\n\n\u003cp\u003eThis is many times slower than writing clone methods by hand\non all objects in your object graph. However, for complex object\ngraphs, or for those that don\u0027t support deep cloning this can\nbe a simple alternative implementation. Of course all the objects\nmust be {@code Serializable}.\u003c/p\u003e\n\n@param object the {@code Serializable} object to clone\n@return the cloned object\n@throws SerializationException (runtime) if the serialization fails\n"
      }
    },
    "b2c32dc35e90124e62f0ddc32952fe5bbf8e656f": {
      "type": "Ymultichange(Ybodychange,Yannotationchange)",
      "commitMessage": "explain why it is safe to suppress the cast warning on SerializationUtils.clone()\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@989390 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "8/25/10, 3:22 PM",
      "commitName": "b2c32dc35e90124e62f0ddc32952fe5bbf8e656f",
      "commitAuthor": "Matthew Jason Benson",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "explain why it is safe to suppress the cast warning on SerializationUtils.clone()\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@989390 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "8/25/10, 3:22 PM",
          "commitName": "b2c32dc35e90124e62f0ddc32952fe5bbf8e656f",
          "commitAuthor": "Matthew Jason Benson",
          "commitDateOld": "8/25/10, 9:15 AM",
          "commitNameOld": "dbd787b0d5c7394188ec4d74a5d52b461327f1c8",
          "commitAuthorOld": "Matthew Jason Benson",
          "daysBetweenCommits": 0.25,
          "commitsBetweenForRepo": 3,
          "commitsBetweenForFile": 1,
          "actualSource": "public static \u003cT extends Serializable\u003e T clone(T object) {\n    @SuppressWarnings(\"unchecked\") final T result \u003d (T) deserialize(serialize(object));\n    return result;\n}",
          "path": "src/main/java/org/apache/commons/lang3/SerializationUtils.java",
          "functionStartLine": 80,
          "functionName": "clone",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003eDeep clone an \u003ccode\u003eObject\u003c/code\u003e using serialization.\u003c/p\u003e\n\n\u003cp\u003eThis is many times slower than writing clone methods by hand\non all objects in your object graph. However, for complex object\ngraphs, or for those that don\u0027t support deep cloning this can\nbe a simple alternative implementation. Of course all the objects\nmust be \u003ccode\u003eSerializable\u003c/code\u003e.\u003c/p\u003e\n\n@param object the \u003ccode\u003eSerializable\u003c/code\u003e object to clone\n@return the cloned object\n@throws SerializationException (runtime) if the serialization fails\n",
          "diff": "@@ -1,4 +1,4 @@\n-@SuppressWarnings(\"unchecked\")\n public static \u003cT extends Serializable\u003e T clone(T object) {\n-    return (T) deserialize(serialize(object));\n+    @SuppressWarnings(\"unchecked\") final T result \u003d (T) deserialize(serialize(object));\n+    return result;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Yannotationchange",
          "commitMessage": "explain why it is safe to suppress the cast warning on SerializationUtils.clone()\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@989390 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "8/25/10, 3:22 PM",
          "commitName": "b2c32dc35e90124e62f0ddc32952fe5bbf8e656f",
          "commitAuthor": "Matthew Jason Benson",
          "commitDateOld": "8/25/10, 9:15 AM",
          "commitNameOld": "dbd787b0d5c7394188ec4d74a5d52b461327f1c8",
          "commitAuthorOld": "Matthew Jason Benson",
          "daysBetweenCommits": 0.25,
          "commitsBetweenForRepo": 3,
          "commitsBetweenForFile": 1,
          "actualSource": "public static \u003cT extends Serializable\u003e T clone(T object) {\n    @SuppressWarnings(\"unchecked\") final T result \u003d (T) deserialize(serialize(object));\n    return result;\n}",
          "path": "src/main/java/org/apache/commons/lang3/SerializationUtils.java",
          "functionStartLine": 80,
          "functionName": "clone",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003eDeep clone an \u003ccode\u003eObject\u003c/code\u003e using serialization.\u003c/p\u003e\n\n\u003cp\u003eThis is many times slower than writing clone methods by hand\non all objects in your object graph. However, for complex object\ngraphs, or for those that don\u0027t support deep cloning this can\nbe a simple alternative implementation. Of course all the objects\nmust be \u003ccode\u003eSerializable\u003c/code\u003e.\u003c/p\u003e\n\n@param object the \u003ccode\u003eSerializable\u003c/code\u003e object to clone\n@return the cloned object\n@throws SerializationException (runtime) if the serialization fails\n",
          "diff": "@@ -1,4 +1,4 @@\n-@SuppressWarnings(\"unchecked\")\n public static \u003cT extends Serializable\u003e T clone(T object) {\n-    return (T) deserialize(serialize(object));\n+    @SuppressWarnings(\"unchecked\") final T result \u003d (T) deserialize(serialize(object));\n+    return result;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "@SuppressWarnings(\"unchecked\")",
            "newValue": ""
          }
        }
      ]
    },
    "dbd787b0d5c7394188ec4d74a5d52b461327f1c8": {
      "type": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange,Yannotationchange)",
      "commitMessage": "make SerializationUtils.clone() type-safe\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@989199 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "8/25/10, 9:15 AM",
      "commitName": "dbd787b0d5c7394188ec4d74a5d52b461327f1c8",
      "commitAuthor": "Matthew Jason Benson",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "make SerializationUtils.clone() type-safe\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@989199 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "8/25/10, 9:15 AM",
          "commitName": "dbd787b0d5c7394188ec4d74a5d52b461327f1c8",
          "commitAuthor": "Matthew Jason Benson",
          "commitDateOld": "3/3/10, 10:22 PM",
          "commitNameOld": "7638d74426ce99c497852311da4bda6eae51d595",
          "commitAuthorOld": "Henri Yandell",
          "daysBetweenCommits": 174.41,
          "commitsBetweenForRepo": 164,
          "commitsBetweenForFile": 1,
          "actualSource": "@SuppressWarnings(\"unchecked\")\npublic static \u003cT extends Serializable\u003e T clone(T object) {\n    return (T) deserialize(serialize(object));\n}",
          "path": "src/main/java/org/apache/commons/lang3/SerializationUtils.java",
          "functionStartLine": 81,
          "functionName": "clone",
          "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
          "functionDoc": "\u003cp\u003eDeep clone an \u003ccode\u003eObject\u003c/code\u003e using serialization.\u003c/p\u003e\n\n\u003cp\u003eThis is many times slower than writing clone methods by hand\non all objects in your object graph. However, for complex object\ngraphs, or for those that don\u0027t support deep cloning this can\nbe a simple alternative implementation. Of course all the objects\nmust be \u003ccode\u003eSerializable\u003c/code\u003e.\u003c/p\u003e\n\n@param object the \u003ccode\u003eSerializable\u003c/code\u003e object to clone\n@return the cloned object\n@throws SerializationException (runtime) if the serialization fails\n",
          "diff": "@@ -1,3 +1,4 @@\n-public static Object clone(Serializable object) {\n-    return deserialize(serialize(object));\n+@SuppressWarnings(\"unchecked\")\n+public static \u003cT extends Serializable\u003e T clone(T object) {\n+    return (T) deserialize(serialize(object));\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[object-Serializable]",
            "newValue": "[object-T]"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "make SerializationUtils.clone() type-safe\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@989199 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "8/25/10, 9:15 AM",
          "commitName": "dbd787b0d5c7394188ec4d74a5d52b461327f1c8",
          "commitAuthor": "Matthew Jason Benson",
          "commitDateOld": "3/3/10, 10:22 PM",
          "commitNameOld": "7638d74426ce99c497852311da4bda6eae51d595",
          "commitAuthorOld": "Henri Yandell",
          "daysBetweenCommits": 174.41,
          "commitsBetweenForRepo": 164,
          "commitsBetweenForFile": 1,
          "actualSource": "@SuppressWarnings(\"unchecked\")\npublic static \u003cT extends Serializable\u003e T clone(T object) {\n    return (T) deserialize(serialize(object));\n}",
          "path": "src/main/java/org/apache/commons/lang3/SerializationUtils.java",
          "functionStartLine": 81,
          "functionName": "clone",
          "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
          "functionDoc": "\u003cp\u003eDeep clone an \u003ccode\u003eObject\u003c/code\u003e using serialization.\u003c/p\u003e\n\n\u003cp\u003eThis is many times slower than writing clone methods by hand\non all objects in your object graph. However, for complex object\ngraphs, or for those that don\u0027t support deep cloning this can\nbe a simple alternative implementation. Of course all the objects\nmust be \u003ccode\u003eSerializable\u003c/code\u003e.\u003c/p\u003e\n\n@param object the \u003ccode\u003eSerializable\u003c/code\u003e object to clone\n@return the cloned object\n@throws SerializationException (runtime) if the serialization fails\n",
          "diff": "@@ -1,3 +1,4 @@\n-public static Object clone(Serializable object) {\n-    return deserialize(serialize(object));\n+@SuppressWarnings(\"unchecked\")\n+public static \u003cT extends Serializable\u003e T clone(T object) {\n+    return (T) deserialize(serialize(object));\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Object",
            "newValue": "T"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "make SerializationUtils.clone() type-safe\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@989199 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "8/25/10, 9:15 AM",
          "commitName": "dbd787b0d5c7394188ec4d74a5d52b461327f1c8",
          "commitAuthor": "Matthew Jason Benson",
          "commitDateOld": "3/3/10, 10:22 PM",
          "commitNameOld": "7638d74426ce99c497852311da4bda6eae51d595",
          "commitAuthorOld": "Henri Yandell",
          "daysBetweenCommits": 174.41,
          "commitsBetweenForRepo": 164,
          "commitsBetweenForFile": 1,
          "actualSource": "@SuppressWarnings(\"unchecked\")\npublic static \u003cT extends Serializable\u003e T clone(T object) {\n    return (T) deserialize(serialize(object));\n}",
          "path": "src/main/java/org/apache/commons/lang3/SerializationUtils.java",
          "functionStartLine": 81,
          "functionName": "clone",
          "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
          "functionDoc": "\u003cp\u003eDeep clone an \u003ccode\u003eObject\u003c/code\u003e using serialization.\u003c/p\u003e\n\n\u003cp\u003eThis is many times slower than writing clone methods by hand\non all objects in your object graph. However, for complex object\ngraphs, or for those that don\u0027t support deep cloning this can\nbe a simple alternative implementation. Of course all the objects\nmust be \u003ccode\u003eSerializable\u003c/code\u003e.\u003c/p\u003e\n\n@param object the \u003ccode\u003eSerializable\u003c/code\u003e object to clone\n@return the cloned object\n@throws SerializationException (runtime) if the serialization fails\n",
          "diff": "@@ -1,3 +1,4 @@\n-public static Object clone(Serializable object) {\n-    return deserialize(serialize(object));\n+@SuppressWarnings(\"unchecked\")\n+public static \u003cT extends Serializable\u003e T clone(T object) {\n+    return (T) deserialize(serialize(object));\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Yannotationchange",
          "commitMessage": "make SerializationUtils.clone() type-safe\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@989199 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "8/25/10, 9:15 AM",
          "commitName": "dbd787b0d5c7394188ec4d74a5d52b461327f1c8",
          "commitAuthor": "Matthew Jason Benson",
          "commitDateOld": "3/3/10, 10:22 PM",
          "commitNameOld": "7638d74426ce99c497852311da4bda6eae51d595",
          "commitAuthorOld": "Henri Yandell",
          "daysBetweenCommits": 174.41,
          "commitsBetweenForRepo": 164,
          "commitsBetweenForFile": 1,
          "actualSource": "@SuppressWarnings(\"unchecked\")\npublic static \u003cT extends Serializable\u003e T clone(T object) {\n    return (T) deserialize(serialize(object));\n}",
          "path": "src/main/java/org/apache/commons/lang3/SerializationUtils.java",
          "functionStartLine": 81,
          "functionName": "clone",
          "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
          "functionDoc": "\u003cp\u003eDeep clone an \u003ccode\u003eObject\u003c/code\u003e using serialization.\u003c/p\u003e\n\n\u003cp\u003eThis is many times slower than writing clone methods by hand\non all objects in your object graph. However, for complex object\ngraphs, or for those that don\u0027t support deep cloning this can\nbe a simple alternative implementation. Of course all the objects\nmust be \u003ccode\u003eSerializable\u003c/code\u003e.\u003c/p\u003e\n\n@param object the \u003ccode\u003eSerializable\u003c/code\u003e object to clone\n@return the cloned object\n@throws SerializationException (runtime) if the serialization fails\n",
          "diff": "@@ -1,3 +1,4 @@\n-public static Object clone(Serializable object) {\n-    return deserialize(serialize(object));\n+@SuppressWarnings(\"unchecked\")\n+public static \u003cT extends Serializable\u003e T clone(T object) {\n+    return (T) deserialize(serialize(object));\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "",
            "newValue": "@SuppressWarnings(\"unchecked\")"
          }
        }
      ]
    },
    "b1686009b5494119575d43525b0829162ab79853": {
      "type": "Yfilerename",
      "commitMessage": "Move main source to src/main/java\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@895322 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "1/2/10, 6:11 PM",
      "commitName": "b1686009b5494119575d43525b0829162ab79853",
      "commitAuthor": "Paul C. Benedict Jr",
      "commitDateOld": "1/2/10, 6:09 PM",
      "commitNameOld": "1f725a97e73edd27301e889408832b34a3d69e63",
      "commitAuthorOld": "Paul C. Benedict Jr",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public static Object clone(Serializable object) {\n    return deserialize(serialize(object));\n}",
      "path": "src/main/java/org/apache/commons/lang3/SerializationUtils.java",
      "functionStartLine": 79,
      "functionName": "clone",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eDeep clone an \u003ccode\u003eObject\u003c/code\u003e using serialization.\u003c/p\u003e\n\n\u003cp\u003eThis is many times slower than writing clone methods by hand\non all objects in your object graph. However, for complex object\ngraphs, or for those that don\u0027t support deep cloning this can\nbe a simple alternative implementation. Of course all the objects\nmust be \u003ccode\u003eSerializable\u003c/code\u003e.\u003c/p\u003e\n\n@param object the \u003ccode\u003eSerializable\u003c/code\u003e object to clone\n@return the cloned object\n@throws SerializationException (runtime) if the serialization fails\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/commons/lang3/SerializationUtils.java",
        "newPath": "src/main/java/org/apache/commons/lang3/SerializationUtils.java"
      }
    },
    "586080851f6bca4d7aa84a7d307203ad8222407e": {
      "type": "Yfilerename",
      "commitMessage": "Changing directory name from lang to lang3. Build will fail (probably) until Java code is changed in subsequent commit. LANG-563\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@889202 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/10/09, 3:33 AM",
      "commitName": "586080851f6bca4d7aa84a7d307203ad8222407e",
      "commitAuthor": "Henri Yandell",
      "commitDateOld": "12/10/09, 3:31 AM",
      "commitNameOld": "da479d635f66c1f82a1f858591cfb1b9941457ae",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public static Object clone(Serializable object) {\n    return deserialize(serialize(object));\n}",
      "path": "src/java/org/apache/commons/lang3/SerializationUtils.java",
      "functionStartLine": 79,
      "functionName": "clone",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eDeep clone an \u003ccode\u003eObject\u003c/code\u003e using serialization.\u003c/p\u003e\n\n\u003cp\u003eThis is many times slower than writing clone methods by hand\non all objects in your object graph. However, for complex object\ngraphs, or for those that don\u0027t support deep cloning this can\nbe a simple alternative implementation. Of course all the objects\nmust be \u003ccode\u003eSerializable\u003c/code\u003e.\u003c/p\u003e\n\n@param object the \u003ccode\u003eSerializable\u003c/code\u003e object to clone\n@return the cloned object\n@throws SerializationException (runtime) if the serialization fails\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/commons/lang/SerializationUtils.java",
        "newPath": "src/java/org/apache/commons/lang3/SerializationUtils.java"
      }
    },
    "30a5db352bf74d4f869f65cc320c63ccfd2f8cc7": {
      "type": "Ydocchange",
      "commitMessage": "Javadoc formatting patch, by Fredrik Westermarck\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137133 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/16/02, 2:41 AM",
      "commitName": "30a5db352bf74d4f869f65cc320c63ccfd2f8cc7",
      "commitAuthor": "Stephen Colebourne",
      "commitDateOld": "8/31/02, 4:11 AM",
      "commitNameOld": "2f94a814dc01ae392768afb8110b2b55169ed69f",
      "commitAuthorOld": "Stephen Colebourne",
      "daysBetweenCommits": 76.98,
      "commitsBetweenForRepo": 128,
      "commitsBetweenForFile": 1,
      "actualSource": "public static Object clone(Serializable object) {\n    return deserialize(serialize(object));\n}",
      "path": "src/java/org/apache/commons/lang/SerializationUtils.java",
      "functionStartLine": 103,
      "functionName": "clone",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eDeep clone an \u003ccode\u003eObject\u003c/code\u003e using serialization.\u003c/p\u003e\n\n\u003cp\u003eThis is many times slower than writing clone methods by hand\non all objects in your object graph. However, for complex object\ngraphs, or for those that don\u0027t support deep cloning this can\nbe a simple alternative implementation. Of course all the objects\nmust be \u003ccode\u003eSerializable\u003c/code\u003e.\u003c/p\u003e\n\n@param object the \u003ccode\u003eSerializable\u003c/code\u003e object to clone\n@return the cloned object\n@throws SerializationException (runtime) if the serialization fails\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "Deep clone an object using serialization.\n\u003cp\u003e\nThis is many times slower than writing clone methods by hand\non all objects in your object graph. However, for complex object\ngraphs, or for those that don\u0027t support deep cloning this can\nbe a simple alternative implementation. Of course all the objects\nmust be \u003ccode\u003eSerializable\u003c/code\u003e.\n\n@param object the \u003ccode\u003eSerializable\u003c/code\u003e object to clone\n@return the cloned object\n@throws SerializationException (runtime) if the serialization fails\n",
        "newValue": "\u003cp\u003eDeep clone an \u003ccode\u003eObject\u003c/code\u003e using serialization.\u003c/p\u003e\n\n\u003cp\u003eThis is many times slower than writing clone methods by hand\non all objects in your object graph. However, for complex object\ngraphs, or for those that don\u0027t support deep cloning this can\nbe a simple alternative implementation. Of course all the objects\nmust be \u003ccode\u003eSerializable\u003c/code\u003e.\u003c/p\u003e\n\n@param object the \u003ccode\u003eSerializable\u003c/code\u003e object to clone\n@return the cloned object\n@throws SerializationException (runtime) if the serialization fails\n"
      }
    },
    "2f94a814dc01ae392768afb8110b2b55169ed69f": {
      "type": "Yformatchange",
      "commitMessage": "Improve checkstyle report\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137001 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "8/31/02, 4:11 AM",
      "commitName": "2f94a814dc01ae392768afb8110b2b55169ed69f",
      "commitAuthor": "Stephen Colebourne",
      "commitDateOld": "7/18/02, 8:35 PM",
      "commitNameOld": "d23b22c78078ee7468e797e80188ae9508c0eee0",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 43.32,
      "commitsBetweenForRepo": 67,
      "commitsBetweenForFile": 1,
      "actualSource": "public static Object clone(Serializable object) {\n    return deserialize(serialize(object));\n}",
      "path": "src/java/org/apache/commons/lang/SerializationUtils.java",
      "functionStartLine": 103,
      "functionName": "clone",
      "functionAnnotation": "",
      "functionDoc": "Deep clone an object using serialization.\n\u003cp\u003e\nThis is many times slower than writing clone methods by hand\non all objects in your object graph. However, for complex object\ngraphs, or for those that don\u0027t support deep cloning this can\nbe a simple alternative implementation. Of course all the objects\nmust be \u003ccode\u003eSerializable\u003c/code\u003e.\n\n@param object the \u003ccode\u003eSerializable\u003c/code\u003e object to clone\n@return the cloned object\n@throws SerializationException (runtime) if the serialization fails\n",
      "diff": "",
      "extendedDetails": {}
    },
    "d23b22c78078ee7468e797e80188ae9508c0eee0": {
      "type": "Yintroduced",
      "commitMessage": "Initial copy from jakarta-commons-sandbox\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@136932 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "7/18/02, 8:35 PM",
      "commitName": "d23b22c78078ee7468e797e80188ae9508c0eee0",
      "commitAuthor": "Henri Yandell",
      "diff": "@@ -0,0 +1,3 @@\n+public static Object clone(Serializable object) {\n+    return deserialize(serialize(object));\n+}\n\\ No newline at end of file\n",
      "actualSource": "public static Object clone(Serializable object) {\n    return deserialize(serialize(object));\n}",
      "path": "src/java/org/apache/commons/lang/SerializationUtils.java",
      "functionStartLine": 103,
      "functionName": "clone",
      "functionAnnotation": "",
      "functionDoc": "Deep clone an object using serialization.\n\u003cp\u003e\nThis is many times slower than writing clone methods by hand\non all objects in your object graph. However, for complex object\ngraphs, or for those that don\u0027t support deep cloning this can\nbe a simple alternative implementation. Of course all the objects\nmust be \u003ccode\u003eSerializable\u003c/code\u003e.\n\n@param object the \u003ccode\u003eSerializable\u003c/code\u003e object to clone\n@return the cloned object\n@throws SerializationException (runtime) if the serialization fails\n"
    }
  }
}