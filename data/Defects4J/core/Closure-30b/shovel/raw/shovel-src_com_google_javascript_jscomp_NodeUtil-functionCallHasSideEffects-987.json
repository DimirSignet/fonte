{
  "origin": "codeshovel",
  "repositoryName": "Closure-30b",
  "repositoryPath": "/tmp/Closure-30b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "NodeUtil.java",
  "functionName": "functionCallHasSideEffects",
  "functionId": "functionCallHasSideEffects___callNode-Node__compiler-AbstractCompiler(annotations-@Nullable)",
  "sourceFilePath": "src/com/google/javascript/jscomp/NodeUtil.java",
  "functionAnnotation": "",
  "functionDoc": "Returns true if calls to this function have side effects.\n\n@param callNode The call node to inspected.\n@param compiler A compiler object to provide program state changing\n    context information. Can be null.\n",
  "functionStartLine": 987,
  "functionEndLine": 1043,
  "numCommitsSeen": 139,
  "timeTaken": 11314,
  "changeHistory": [
    "4d98fc9034031ee146c7e5534a150e2700d89f8e",
    "33d99d84f3b7781baa6cbefd3d911361a378bf07",
    "34e4616a924bf272c076039e143e20f1d792731e",
    "e9a1cc9c431416354dec3dcb393affd7f41c6596",
    "ef332935817a940ca10d1ce431d8a2037fe59ac9",
    "73f98ee988dad825ba8320bf4d8df0413fde531c",
    "6a2378d43d1f06344f6418388d45c66fe3466a07",
    "5254fe6ac0ef2363d760430c39788aceaed3f5af",
    "80fe41fd0173c3eaa56f4abb783031966ea89cef",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3"
  ],
  "changeHistoryShort": {
    "4d98fc9034031ee146c7e5534a150e2700d89f8e": "Ybodychange",
    "33d99d84f3b7781baa6cbefd3d911361a378bf07": "Ybodychange",
    "34e4616a924bf272c076039e143e20f1d792731e": "Ybodychange",
    "e9a1cc9c431416354dec3dcb393affd7f41c6596": "Ybodychange",
    "ef332935817a940ca10d1ce431d8a2037fe59ac9": "Ybodychange",
    "73f98ee988dad825ba8320bf4d8df0413fde531c": "Ybodychange",
    "6a2378d43d1f06344f6418388d45c66fe3466a07": "Ybodychange",
    "5254fe6ac0ef2363d760430c39788aceaed3f5af": "Ybodychange",
    "80fe41fd0173c3eaa56f4abb783031966ea89cef": "Ymultichange(Yparameterchange,Ybodychange,Ydocchange)",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "4d98fc9034031ee146c7e5534a150e2700d89f8e": {
      "type": "Ybodychange",
      "commitMessage": "\nAdd basic Node type helpers to Node\n\nR\u003dnicksantos\nDELTA\u003d241  (135 added, 9 deleted, 97 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3672\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1577 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/9/11, 12:32 PM",
      "commitName": "4d98fc9034031ee146c7e5534a150e2700d89f8e",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "11/9/11, 10:08 AM",
      "commitNameOld": "ca41f5d443aad22b11b2b6d514fdf20101f33276",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "static boolean functionCallHasSideEffects(Node callNode, @Nullable AbstractCompiler compiler) {\n    if (!callNode.isCall()) {\n        throw new IllegalStateException(\"Expected CALL node, got \" + Token.name(callNode.getType()));\n    }\n    if (callNode.isNoSideEffectsCall()) {\n        return false;\n    }\n    Node nameNode \u003d callNode.getFirstChild();\n    if (nameNode.isName()) {\n        String name \u003d nameNode.getString();\n        if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {\n            return false;\n        }\n    } else if (nameNode.isGetProp()) {\n        if (callNode.hasOneChild() \u0026\u0026 OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(nameNode.getLastChild().getString())) {\n            return false;\n        }\n        if (callNode.isOnlyModifiesThisCall() \u0026\u0026 evaluatesToLocalValue(nameNode.getFirstChild())) {\n            return false;\n        }\n        if (nameNode.getFirstChild().isName()) {\n            if (\"Math.floor\".equals(nameNode.getQualifiedName())) {\n                return false;\n            }\n        }\n        if (compiler !\u003d null \u0026\u0026 !compiler.hasRegExpGlobalReferences()) {\n            if (nameNode.getFirstChild().isRegExp() \u0026\u0026 REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n                return false;\n            } else if (nameNode.getFirstChild().isString() \u0026\u0026 STRING_REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n                Node param \u003d nameNode.getNext();\n                if (param !\u003d null \u0026\u0026 (param.isString() || param.isRegExp()))\n                    return false;\n            }\n        }\n    }\n    return true;\n}",
      "path": "src/com/google/javascript/jscomp/NodeUtil.java",
      "functionStartLine": 985,
      "functionName": "functionCallHasSideEffects",
      "functionAnnotation": "",
      "functionDoc": "Returns true if calls to this function have side effects.\n\n@param callNode The call node to inspected.\n@param compiler A compiler object to provide program state changing\n    context information. Can be null.\n",
      "diff": "@@ -1,37 +1,37 @@\n static boolean functionCallHasSideEffects(Node callNode, @Nullable AbstractCompiler compiler) {\n-    if (callNode.getType() !\u003d Token.CALL) {\n+    if (!callNode.isCall()) {\n         throw new IllegalStateException(\"Expected CALL node, got \" + Token.name(callNode.getType()));\n     }\n     if (callNode.isNoSideEffectsCall()) {\n         return false;\n     }\n     Node nameNode \u003d callNode.getFirstChild();\n-    if (nameNode.getType() \u003d\u003d Token.NAME) {\n+    if (nameNode.isName()) {\n         String name \u003d nameNode.getString();\n         if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {\n             return false;\n         }\n-    } else if (nameNode.getType() \u003d\u003d Token.GETPROP) {\n+    } else if (nameNode.isGetProp()) {\n         if (callNode.hasOneChild() \u0026\u0026 OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(nameNode.getLastChild().getString())) {\n             return false;\n         }\n         if (callNode.isOnlyModifiesThisCall() \u0026\u0026 evaluatesToLocalValue(nameNode.getFirstChild())) {\n             return false;\n         }\n-        if (nameNode.getFirstChild().getType() \u003d\u003d Token.NAME) {\n+        if (nameNode.getFirstChild().isName()) {\n             if (\"Math.floor\".equals(nameNode.getQualifiedName())) {\n                 return false;\n             }\n         }\n         if (compiler !\u003d null \u0026\u0026 !compiler.hasRegExpGlobalReferences()) {\n-            if (nameNode.getFirstChild().getType() \u003d\u003d Token.REGEXP \u0026\u0026 REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n+            if (nameNode.getFirstChild().isRegExp() \u0026\u0026 REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n                 return false;\n-            } else if (nameNode.getFirstChild().getType() \u003d\u003d Token.STRING \u0026\u0026 STRING_REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n+            } else if (nameNode.getFirstChild().isString() \u0026\u0026 STRING_REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n                 Node param \u003d nameNode.getNext();\n-                if (param !\u003d null \u0026\u0026 (param.getType() \u003d\u003d Token.STRING || param.getType() \u003d\u003d Token.REGEXP))\n+                if (param !\u003d null \u0026\u0026 (param.isString() || param.isRegExp()))\n                     return false;\n             }\n         }\n     }\n     return true;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "33d99d84f3b7781baa6cbefd3d911361a378bf07": {
      "type": "Ybodychange",
      "commitMessage": "\nDon\u0027t assume that all Math functions are side-effect free, but\nleave one little hack in.\nFixes issue 501\n\nR\u003djohnlenz\nDELTA\u003d33  (23 added, 2 deleted, 8 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d2461\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1234 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "6/30/11, 8:30 AM",
      "commitName": "33d99d84f3b7781baa6cbefd3d911361a378bf07",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "6/28/11, 6:34 PM",
      "commitNameOld": "34e4616a924bf272c076039e143e20f1d792731e",
      "commitAuthorOld": "chrishenry@google.com",
      "daysBetweenCommits": 1.58,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "static boolean functionCallHasSideEffects(Node callNode, @Nullable AbstractCompiler compiler) {\n    if (callNode.getType() !\u003d Token.CALL) {\n        throw new IllegalStateException(\"Expected CALL node, got \" + Token.name(callNode.getType()));\n    }\n    if (callNode.isNoSideEffectsCall()) {\n        return false;\n    }\n    Node nameNode \u003d callNode.getFirstChild();\n    if (nameNode.getType() \u003d\u003d Token.NAME) {\n        String name \u003d nameNode.getString();\n        if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {\n            return false;\n        }\n    } else if (nameNode.getType() \u003d\u003d Token.GETPROP) {\n        if (callNode.hasOneChild() \u0026\u0026 OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(nameNode.getLastChild().getString())) {\n            return false;\n        }\n        if (callNode.isOnlyModifiesThisCall() \u0026\u0026 evaluatesToLocalValue(nameNode.getFirstChild())) {\n            return false;\n        }\n        if (nameNode.getFirstChild().getType() \u003d\u003d Token.NAME) {\n            if (\"Math.floor\".equals(nameNode.getQualifiedName())) {\n                return false;\n            }\n        }\n        if (compiler !\u003d null \u0026\u0026 !compiler.hasRegExpGlobalReferences()) {\n            if (nameNode.getFirstChild().getType() \u003d\u003d Token.REGEXP \u0026\u0026 REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n                return false;\n            } else if (nameNode.getFirstChild().getType() \u003d\u003d Token.STRING \u0026\u0026 STRING_REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n                Node param \u003d nameNode.getNext();\n                if (param !\u003d null \u0026\u0026 (param.getType() \u003d\u003d Token.STRING || param.getType() \u003d\u003d Token.REGEXP))\n                    return false;\n            }\n        }\n    }\n    return true;\n}",
      "path": "src/com/google/javascript/jscomp/NodeUtil.java",
      "functionStartLine": 926,
      "functionName": "functionCallHasSideEffects",
      "functionAnnotation": "",
      "functionDoc": "Returns true if calls to this function have side effects.\n\n@param callNode The call node to inspected.\n@param compiler A compiler object to provide program state changing\n    context information. Can be null.\n",
      "diff": "@@ -1,38 +1,37 @@\n static boolean functionCallHasSideEffects(Node callNode, @Nullable AbstractCompiler compiler) {\n     if (callNode.getType() !\u003d Token.CALL) {\n         throw new IllegalStateException(\"Expected CALL node, got \" + Token.name(callNode.getType()));\n     }\n     if (callNode.isNoSideEffectsCall()) {\n         return false;\n     }\n     Node nameNode \u003d callNode.getFirstChild();\n     if (nameNode.getType() \u003d\u003d Token.NAME) {\n         String name \u003d nameNode.getString();\n         if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {\n             return false;\n         }\n     } else if (nameNode.getType() \u003d\u003d Token.GETPROP) {\n         if (callNode.hasOneChild() \u0026\u0026 OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(nameNode.getLastChild().getString())) {\n             return false;\n         }\n         if (callNode.isOnlyModifiesThisCall() \u0026\u0026 evaluatesToLocalValue(nameNode.getFirstChild())) {\n             return false;\n         }\n         if (nameNode.getFirstChild().getType() \u003d\u003d Token.NAME) {\n-            String namespaceName \u003d nameNode.getFirstChild().getString();\n-            if (namespaceName.equals(\"Math\")) {\n+            if (\"Math.floor\".equals(nameNode.getQualifiedName())) {\n                 return false;\n             }\n         }\n         if (compiler !\u003d null \u0026\u0026 !compiler.hasRegExpGlobalReferences()) {\n             if (nameNode.getFirstChild().getType() \u003d\u003d Token.REGEXP \u0026\u0026 REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n                 return false;\n             } else if (nameNode.getFirstChild().getType() \u003d\u003d Token.STRING \u0026\u0026 STRING_REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n                 Node param \u003d nameNode.getNext();\n                 if (param !\u003d null \u0026\u0026 (param.getType() \u003d\u003d Token.STRING || param.getType() \u003d\u003d Token.REGEXP))\n                     return false;\n             }\n         }\n     }\n     return true;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "34e4616a924bf272c076039e143e20f1d792731e": {
      "type": "Ybodychange",
      "commitMessage": "\nAutomated g4 rollback.\n\n*** Reason for rollback ***\n\nBreaking Closure test. The test looks correct, so rolling\nback for now.\n\n*** Original change description ***\n\nDon\u0027t assume that all Math functions are side-effect free.\nFixes issue 501\n\nR\u003djohnlenz\nDELTA\u003d36  (9 added, 21 deleted, 6 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d2452\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1226 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "6/28/11, 6:34 PM",
      "commitName": "34e4616a924bf272c076039e143e20f1d792731e",
      "commitAuthor": "chrishenry@google.com",
      "commitDateOld": "6/28/11, 2:12 PM",
      "commitNameOld": "e9a1cc9c431416354dec3dcb393affd7f41c6596",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 0.18,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "static boolean functionCallHasSideEffects(Node callNode, @Nullable AbstractCompiler compiler) {\n    if (callNode.getType() !\u003d Token.CALL) {\n        throw new IllegalStateException(\"Expected CALL node, got \" + Token.name(callNode.getType()));\n    }\n    if (callNode.isNoSideEffectsCall()) {\n        return false;\n    }\n    Node nameNode \u003d callNode.getFirstChild();\n    if (nameNode.getType() \u003d\u003d Token.NAME) {\n        String name \u003d nameNode.getString();\n        if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {\n            return false;\n        }\n    } else if (nameNode.getType() \u003d\u003d Token.GETPROP) {\n        if (callNode.hasOneChild() \u0026\u0026 OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(nameNode.getLastChild().getString())) {\n            return false;\n        }\n        if (callNode.isOnlyModifiesThisCall() \u0026\u0026 evaluatesToLocalValue(nameNode.getFirstChild())) {\n            return false;\n        }\n        if (nameNode.getFirstChild().getType() \u003d\u003d Token.NAME) {\n            String namespaceName \u003d nameNode.getFirstChild().getString();\n            if (namespaceName.equals(\"Math\")) {\n                return false;\n            }\n        }\n        if (compiler !\u003d null \u0026\u0026 !compiler.hasRegExpGlobalReferences()) {\n            if (nameNode.getFirstChild().getType() \u003d\u003d Token.REGEXP \u0026\u0026 REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n                return false;\n            } else if (nameNode.getFirstChild().getType() \u003d\u003d Token.STRING \u0026\u0026 STRING_REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n                Node param \u003d nameNode.getNext();\n                if (param !\u003d null \u0026\u0026 (param.getType() \u003d\u003d Token.STRING || param.getType() \u003d\u003d Token.REGEXP))\n                    return false;\n            }\n        }\n    }\n    return true;\n}",
      "path": "src/com/google/javascript/jscomp/NodeUtil.java",
      "functionStartLine": 926,
      "functionName": "functionCallHasSideEffects",
      "functionAnnotation": "",
      "functionDoc": "Returns true if calls to this function have side effects.\n\n@param callNode The call node to inspected.\n@param compiler A compiler object to provide program state changing\n    context information. Can be null.\n",
      "diff": "@@ -1,32 +1,38 @@\n static boolean functionCallHasSideEffects(Node callNode, @Nullable AbstractCompiler compiler) {\n     if (callNode.getType() !\u003d Token.CALL) {\n         throw new IllegalStateException(\"Expected CALL node, got \" + Token.name(callNode.getType()));\n     }\n     if (callNode.isNoSideEffectsCall()) {\n         return false;\n     }\n     Node nameNode \u003d callNode.getFirstChild();\n     if (nameNode.getType() \u003d\u003d Token.NAME) {\n         String name \u003d nameNode.getString();\n         if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {\n             return false;\n         }\n     } else if (nameNode.getType() \u003d\u003d Token.GETPROP) {\n         if (callNode.hasOneChild() \u0026\u0026 OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(nameNode.getLastChild().getString())) {\n             return false;\n         }\n         if (callNode.isOnlyModifiesThisCall() \u0026\u0026 evaluatesToLocalValue(nameNode.getFirstChild())) {\n             return false;\n         }\n+        if (nameNode.getFirstChild().getType() \u003d\u003d Token.NAME) {\n+            String namespaceName \u003d nameNode.getFirstChild().getString();\n+            if (namespaceName.equals(\"Math\")) {\n+                return false;\n+            }\n+        }\n         if (compiler !\u003d null \u0026\u0026 !compiler.hasRegExpGlobalReferences()) {\n             if (nameNode.getFirstChild().getType() \u003d\u003d Token.REGEXP \u0026\u0026 REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n                 return false;\n             } else if (nameNode.getFirstChild().getType() \u003d\u003d Token.STRING \u0026\u0026 STRING_REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n                 Node param \u003d nameNode.getNext();\n                 if (param !\u003d null \u0026\u0026 (param.getType() \u003d\u003d Token.STRING || param.getType() \u003d\u003d Token.REGEXP))\n                     return false;\n             }\n         }\n     }\n     return true;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e9a1cc9c431416354dec3dcb393affd7f41c6596": {
      "type": "Ybodychange",
      "commitMessage": "\nDon\u0027t assume that all Math functions are side-effect free.\nFixes issue 501\n\nR\u003djohnlenz\nDELTA\u003d36  (21 added, 9 deleted, 6 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d2425\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1222 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "6/28/11, 2:12 PM",
      "commitName": "e9a1cc9c431416354dec3dcb393affd7f41c6596",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "6/24/11, 3:02 PM",
      "commitNameOld": "01bf122e7cb05ee5b9187b3c35608db52c051a49",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 3.97,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "actualSource": "static boolean functionCallHasSideEffects(Node callNode, @Nullable AbstractCompiler compiler) {\n    if (callNode.getType() !\u003d Token.CALL) {\n        throw new IllegalStateException(\"Expected CALL node, got \" + Token.name(callNode.getType()));\n    }\n    if (callNode.isNoSideEffectsCall()) {\n        return false;\n    }\n    Node nameNode \u003d callNode.getFirstChild();\n    if (nameNode.getType() \u003d\u003d Token.NAME) {\n        String name \u003d nameNode.getString();\n        if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {\n            return false;\n        }\n    } else if (nameNode.getType() \u003d\u003d Token.GETPROP) {\n        if (callNode.hasOneChild() \u0026\u0026 OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(nameNode.getLastChild().getString())) {\n            return false;\n        }\n        if (callNode.isOnlyModifiesThisCall() \u0026\u0026 evaluatesToLocalValue(nameNode.getFirstChild())) {\n            return false;\n        }\n        if (compiler !\u003d null \u0026\u0026 !compiler.hasRegExpGlobalReferences()) {\n            if (nameNode.getFirstChild().getType() \u003d\u003d Token.REGEXP \u0026\u0026 REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n                return false;\n            } else if (nameNode.getFirstChild().getType() \u003d\u003d Token.STRING \u0026\u0026 STRING_REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n                Node param \u003d nameNode.getNext();\n                if (param !\u003d null \u0026\u0026 (param.getType() \u003d\u003d Token.STRING || param.getType() \u003d\u003d Token.REGEXP))\n                    return false;\n            }\n        }\n    }\n    return true;\n}",
      "path": "src/com/google/javascript/jscomp/NodeUtil.java",
      "functionStartLine": 926,
      "functionName": "functionCallHasSideEffects",
      "functionAnnotation": "",
      "functionDoc": "Returns true if calls to this function have side effects.\n\n@param callNode The call node to inspected.\n@param compiler A compiler object to provide program state changing\n    context information. Can be null.\n",
      "diff": "@@ -1,38 +1,32 @@\n static boolean functionCallHasSideEffects(Node callNode, @Nullable AbstractCompiler compiler) {\n     if (callNode.getType() !\u003d Token.CALL) {\n         throw new IllegalStateException(\"Expected CALL node, got \" + Token.name(callNode.getType()));\n     }\n     if (callNode.isNoSideEffectsCall()) {\n         return false;\n     }\n     Node nameNode \u003d callNode.getFirstChild();\n     if (nameNode.getType() \u003d\u003d Token.NAME) {\n         String name \u003d nameNode.getString();\n         if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {\n             return false;\n         }\n     } else if (nameNode.getType() \u003d\u003d Token.GETPROP) {\n         if (callNode.hasOneChild() \u0026\u0026 OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(nameNode.getLastChild().getString())) {\n             return false;\n         }\n         if (callNode.isOnlyModifiesThisCall() \u0026\u0026 evaluatesToLocalValue(nameNode.getFirstChild())) {\n             return false;\n         }\n-        if (nameNode.getFirstChild().getType() \u003d\u003d Token.NAME) {\n-            String namespaceName \u003d nameNode.getFirstChild().getString();\n-            if (namespaceName.equals(\"Math\")) {\n-                return false;\n-            }\n-        }\n         if (compiler !\u003d null \u0026\u0026 !compiler.hasRegExpGlobalReferences()) {\n             if (nameNode.getFirstChild().getType() \u003d\u003d Token.REGEXP \u0026\u0026 REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n                 return false;\n             } else if (nameNode.getFirstChild().getType() \u003d\u003d Token.STRING \u0026\u0026 STRING_REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n                 Node param \u003d nameNode.getNext();\n                 if (param !\u003d null \u0026\u0026 (param.getType() \u003d\u003d Token.STRING || param.getType() \u003d\u003d Token.REGEXP))\n                     return false;\n             }\n         }\n     }\n     return true;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ef332935817a940ca10d1ce431d8a2037fe59ac9": {
      "type": "Ybodychange",
      "commitMessage": "\nAssume \"toString\" and \"valueOf\" are side-effect free and \"toString\"\nreturns a string.\n\nR\u003dnicksantos\nDELTA\u003d39  (36 added, 0 deleted, 3 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d17\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@571 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/29/10, 1:42 PM",
      "commitName": "ef332935817a940ca10d1ce431d8a2037fe59ac9",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "11/29/10, 10:09 AM",
      "commitNameOld": "73f98ee988dad825ba8320bf4d8df0413fde531c",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 0.15,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "static boolean functionCallHasSideEffects(Node callNode, @Nullable AbstractCompiler compiler) {\n    if (callNode.getType() !\u003d Token.CALL) {\n        throw new IllegalStateException(\"Expected CALL node, got \" + Token.name(callNode.getType()));\n    }\n    if (callNode.isNoSideEffectsCall()) {\n        return false;\n    }\n    Node nameNode \u003d callNode.getFirstChild();\n    if (nameNode.getType() \u003d\u003d Token.NAME) {\n        String name \u003d nameNode.getString();\n        if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {\n            return false;\n        }\n    } else if (nameNode.getType() \u003d\u003d Token.GETPROP) {\n        if (callNode.hasOneChild() \u0026\u0026 OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(nameNode.getLastChild().getString())) {\n            return false;\n        }\n        if (callNode.isOnlyModifiesThisCall() \u0026\u0026 evaluatesToLocalValue(nameNode.getFirstChild())) {\n            return false;\n        }\n        if (nameNode.getFirstChild().getType() \u003d\u003d Token.NAME) {\n            String namespaceName \u003d nameNode.getFirstChild().getString();\n            if (namespaceName.equals(\"Math\")) {\n                return false;\n            }\n        }\n        if (compiler !\u003d null \u0026\u0026 !compiler.hasRegExpGlobalReferences()) {\n            if (nameNode.getFirstChild().getType() \u003d\u003d Token.REGEXP \u0026\u0026 REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n                return false;\n            } else if (nameNode.getFirstChild().getType() \u003d\u003d Token.STRING \u0026\u0026 STRING_REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n                Node param \u003d nameNode.getNext();\n                if (param !\u003d null \u0026\u0026 (param.getType() \u003d\u003d Token.STRING || param.getType() \u003d\u003d Token.REGEXP))\n                    return false;\n            }\n        }\n    }\n    return true;\n}",
      "path": "src/com/google/javascript/jscomp/NodeUtil.java",
      "functionStartLine": 691,
      "functionName": "functionCallHasSideEffects",
      "functionAnnotation": "",
      "functionDoc": "Returns true if calls to this function have side effects.\n\n@param callNode The call node to inspected.\n@param compiler A compiler object to provide program state changing\n    context information. Can be null.\n",
      "diff": "@@ -1,35 +1,38 @@\n static boolean functionCallHasSideEffects(Node callNode, @Nullable AbstractCompiler compiler) {\n     if (callNode.getType() !\u003d Token.CALL) {\n         throw new IllegalStateException(\"Expected CALL node, got \" + Token.name(callNode.getType()));\n     }\n     if (callNode.isNoSideEffectsCall()) {\n         return false;\n     }\n     Node nameNode \u003d callNode.getFirstChild();\n     if (nameNode.getType() \u003d\u003d Token.NAME) {\n         String name \u003d nameNode.getString();\n         if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {\n             return false;\n         }\n     } else if (nameNode.getType() \u003d\u003d Token.GETPROP) {\n+        if (callNode.hasOneChild() \u0026\u0026 OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(nameNode.getLastChild().getString())) {\n+            return false;\n+        }\n         if (callNode.isOnlyModifiesThisCall() \u0026\u0026 evaluatesToLocalValue(nameNode.getFirstChild())) {\n             return false;\n         }\n         if (nameNode.getFirstChild().getType() \u003d\u003d Token.NAME) {\n             String namespaceName \u003d nameNode.getFirstChild().getString();\n             if (namespaceName.equals(\"Math\")) {\n                 return false;\n             }\n         }\n         if (compiler !\u003d null \u0026\u0026 !compiler.hasRegExpGlobalReferences()) {\n             if (nameNode.getFirstChild().getType() \u003d\u003d Token.REGEXP \u0026\u0026 REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n                 return false;\n             } else if (nameNode.getFirstChild().getType() \u003d\u003d Token.STRING \u0026\u0026 STRING_REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n                 Node param \u003d nameNode.getNext();\n                 if (param !\u003d null \u0026\u0026 (param.getType() \u003d\u003d Token.STRING || param.getType() \u003d\u003d Token.REGEXP))\n                     return false;\n             }\n         }\n     }\n     return true;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "73f98ee988dad825ba8320bf4d8df0413fde531c": {
      "type": "Ybodychange",
      "commitMessage": "\nLay the groundwork for the my next call optimization.\n\nR\u003dacleung\nDELTA\u003d428  (267 added, 117 deleted, 44 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d6\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@570 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/29/10, 10:09 AM",
      "commitName": "73f98ee988dad825ba8320bf4d8df0413fde531c",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "11/15/10, 10:48 AM",
      "commitNameOld": "853cb5d209e39fdf1944fbd48e1fab349c24b76d",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 13.97,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "actualSource": "static boolean functionCallHasSideEffects(Node callNode, @Nullable AbstractCompiler compiler) {\n    if (callNode.getType() !\u003d Token.CALL) {\n        throw new IllegalStateException(\"Expected CALL node, got \" + Token.name(callNode.getType()));\n    }\n    if (callNode.isNoSideEffectsCall()) {\n        return false;\n    }\n    Node nameNode \u003d callNode.getFirstChild();\n    if (nameNode.getType() \u003d\u003d Token.NAME) {\n        String name \u003d nameNode.getString();\n        if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {\n            return false;\n        }\n    } else if (nameNode.getType() \u003d\u003d Token.GETPROP) {\n        if (callNode.isOnlyModifiesThisCall() \u0026\u0026 evaluatesToLocalValue(nameNode.getFirstChild())) {\n            return false;\n        }\n        if (nameNode.getFirstChild().getType() \u003d\u003d Token.NAME) {\n            String namespaceName \u003d nameNode.getFirstChild().getString();\n            if (namespaceName.equals(\"Math\")) {\n                return false;\n            }\n        }\n        if (compiler !\u003d null \u0026\u0026 !compiler.hasRegExpGlobalReferences()) {\n            if (nameNode.getFirstChild().getType() \u003d\u003d Token.REGEXP \u0026\u0026 REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n                return false;\n            } else if (nameNode.getFirstChild().getType() \u003d\u003d Token.STRING \u0026\u0026 STRING_REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n                Node param \u003d nameNode.getNext();\n                if (param !\u003d null \u0026\u0026 (param.getType() \u003d\u003d Token.STRING || param.getType() \u003d\u003d Token.REGEXP))\n                    return false;\n            }\n        }\n    }\n    return true;\n}",
      "path": "src/com/google/javascript/jscomp/NodeUtil.java",
      "functionStartLine": 689,
      "functionName": "functionCallHasSideEffects",
      "functionAnnotation": "",
      "functionDoc": "Returns true if calls to this function have side effects.\n\n@param callNode The call node to inspected.\n@param compiler A compiler object to provide program state changing\n    context information. Can be null.\n",
      "diff": "@@ -1,33 +1,35 @@\n static boolean functionCallHasSideEffects(Node callNode, @Nullable AbstractCompiler compiler) {\n-    Preconditions.checkArgument(callNode.getType() \u003d\u003d Token.CALL, \"Expected CALL node, got \" + Token.name(callNode.getType()));\n+    if (callNode.getType() !\u003d Token.CALL) {\n+        throw new IllegalStateException(\"Expected CALL node, got \" + Token.name(callNode.getType()));\n+    }\n     if (callNode.isNoSideEffectsCall()) {\n         return false;\n     }\n     Node nameNode \u003d callNode.getFirstChild();\n     if (nameNode.getType() \u003d\u003d Token.NAME) {\n         String name \u003d nameNode.getString();\n         if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {\n             return false;\n         }\n     } else if (nameNode.getType() \u003d\u003d Token.GETPROP) {\n         if (callNode.isOnlyModifiesThisCall() \u0026\u0026 evaluatesToLocalValue(nameNode.getFirstChild())) {\n             return false;\n         }\n         if (nameNode.getFirstChild().getType() \u003d\u003d Token.NAME) {\n             String namespaceName \u003d nameNode.getFirstChild().getString();\n             if (namespaceName.equals(\"Math\")) {\n                 return false;\n             }\n         }\n         if (compiler !\u003d null \u0026\u0026 !compiler.hasRegExpGlobalReferences()) {\n             if (nameNode.getFirstChild().getType() \u003d\u003d Token.REGEXP \u0026\u0026 REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n                 return false;\n             } else if (nameNode.getFirstChild().getType() \u003d\u003d Token.STRING \u0026\u0026 STRING_REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n                 Node param \u003d nameNode.getNext();\n                 if (param !\u003d null \u0026\u0026 (param.getType() \u003d\u003d Token.STRING || param.getType() \u003d\u003d Token.REGEXP))\n                     return false;\n             }\n         }\n     }\n     return true;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6a2378d43d1f06344f6418388d45c66fe3466a07": {
      "type": "Ybodychange",
      "commitMessage": "\nTake advantage of the finer grain side-effect information when\ndetermining side-effects.\nThe bulk of the changes here are the move of the \"isKnownLocalValue\"\nfunction and its tests from to NodeUtil/NodeUtilTest.\n\nR\u003dnicksantos\nDELTA\u003d664  (419 added, 201 deleted, 44 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d260873\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@466 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "9/27/10, 4:16 PM",
      "commitName": "6a2378d43d1f06344f6418388d45c66fe3466a07",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "9/24/10, 6:20 PM",
      "commitNameOld": "2e526cbea28c991cd34d3f73a77891fa2ffbf6ee",
      "commitAuthorOld": "jschorr@google.com",
      "daysBetweenCommits": 2.91,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "static boolean functionCallHasSideEffects(Node callNode, @Nullable AbstractCompiler compiler) {\n    Preconditions.checkArgument(callNode.getType() \u003d\u003d Token.CALL, \"Expected CALL node, got \" + Token.name(callNode.getType()));\n    if (callNode.isNoSideEffectsCall()) {\n        return false;\n    }\n    Node nameNode \u003d callNode.getFirstChild();\n    if (nameNode.getType() \u003d\u003d Token.NAME) {\n        String name \u003d nameNode.getString();\n        if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {\n            return false;\n        }\n    } else if (nameNode.getType() \u003d\u003d Token.GETPROP) {\n        if (callNode.isOnlyModifiesThisCall() \u0026\u0026 evaluatesToLocalValue(nameNode.getFirstChild())) {\n            return false;\n        }\n        if (nameNode.getFirstChild().getType() \u003d\u003d Token.NAME) {\n            String namespaceName \u003d nameNode.getFirstChild().getString();\n            if (namespaceName.equals(\"Math\")) {\n                return false;\n            }\n        }\n        if (compiler !\u003d null \u0026\u0026 !compiler.hasRegExpGlobalReferences()) {\n            if (nameNode.getFirstChild().getType() \u003d\u003d Token.REGEXP \u0026\u0026 REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n                return false;\n            } else if (nameNode.getFirstChild().getType() \u003d\u003d Token.STRING \u0026\u0026 STRING_REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n                Node param \u003d nameNode.getNext();\n                if (param !\u003d null \u0026\u0026 (param.getType() \u003d\u003d Token.STRING || param.getType() \u003d\u003d Token.REGEXP))\n                    return false;\n            }\n        }\n    }\n    return true;\n}",
      "path": "src/com/google/javascript/jscomp/NodeUtil.java",
      "functionStartLine": 645,
      "functionName": "functionCallHasSideEffects",
      "functionAnnotation": "",
      "functionDoc": "Returns true if calls to this function have side effects.\n\n@param callNode The call node to inspected.\n@param compiler A compiler object to provide program state changing\n    context information. Can be null.\n",
      "diff": "@@ -1,30 +1,33 @@\n static boolean functionCallHasSideEffects(Node callNode, @Nullable AbstractCompiler compiler) {\n     Preconditions.checkArgument(callNode.getType() \u003d\u003d Token.CALL, \"Expected CALL node, got \" + Token.name(callNode.getType()));\n     if (callNode.isNoSideEffectsCall()) {\n         return false;\n     }\n     Node nameNode \u003d callNode.getFirstChild();\n     if (nameNode.getType() \u003d\u003d Token.NAME) {\n         String name \u003d nameNode.getString();\n         if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {\n             return false;\n         }\n     } else if (nameNode.getType() \u003d\u003d Token.GETPROP) {\n+        if (callNode.isOnlyModifiesThisCall() \u0026\u0026 evaluatesToLocalValue(nameNode.getFirstChild())) {\n+            return false;\n+        }\n         if (nameNode.getFirstChild().getType() \u003d\u003d Token.NAME) {\n             String namespaceName \u003d nameNode.getFirstChild().getString();\n             if (namespaceName.equals(\"Math\")) {\n                 return false;\n             }\n         }\n         if (compiler !\u003d null \u0026\u0026 !compiler.hasRegExpGlobalReferences()) {\n             if (nameNode.getFirstChild().getType() \u003d\u003d Token.REGEXP \u0026\u0026 REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n                 return false;\n             } else if (nameNode.getFirstChild().getType() \u003d\u003d Token.STRING \u0026\u0026 STRING_REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n                 Node param \u003d nameNode.getNext();\n                 if (param !\u003d null \u0026\u0026 (param.getType() \u003d\u003d Token.STRING || param.getType() \u003d\u003d Token.REGEXP))\n                     return false;\n             }\n         }\n     }\n     return true;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5254fe6ac0ef2363d760430c39788aceaed3f5af": {
      "type": "Ybodychange",
      "commitMessage": "\nHandle standard constructors that are also functions:\n\"new RegExp(\u0027foo\u0027)\" would get stripped but \"RegExp(\u0027foo\u0027)\"\nwould not.\n\nR\u003davd\nDELTA\u003d7  (6 added, 0 deleted, 1 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d225429\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@437 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "9/16/10, 2:03 PM",
      "commitName": "5254fe6ac0ef2363d760430c39788aceaed3f5af",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "9/15/10, 7:50 AM",
      "commitNameOld": "f6607996d6d3bd6820ce3848d147991b27600a12",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 1.26,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "static boolean functionCallHasSideEffects(Node callNode, @Nullable AbstractCompiler compiler) {\n    Preconditions.checkArgument(callNode.getType() \u003d\u003d Token.CALL, \"Expected CALL node, got \" + Token.name(callNode.getType()));\n    if (callNode.isNoSideEffectsCall()) {\n        return false;\n    }\n    Node nameNode \u003d callNode.getFirstChild();\n    if (nameNode.getType() \u003d\u003d Token.NAME) {\n        String name \u003d nameNode.getString();\n        if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {\n            return false;\n        }\n    } else if (nameNode.getType() \u003d\u003d Token.GETPROP) {\n        if (nameNode.getFirstChild().getType() \u003d\u003d Token.NAME) {\n            String namespaceName \u003d nameNode.getFirstChild().getString();\n            if (namespaceName.equals(\"Math\")) {\n                return false;\n            }\n        }\n        if (compiler !\u003d null \u0026\u0026 !compiler.hasRegExpGlobalReferences()) {\n            if (nameNode.getFirstChild().getType() \u003d\u003d Token.REGEXP \u0026\u0026 REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n                return false;\n            } else if (nameNode.getFirstChild().getType() \u003d\u003d Token.STRING \u0026\u0026 STRING_REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n                Node param \u003d nameNode.getNext();\n                if (param !\u003d null \u0026\u0026 (param.getType() \u003d\u003d Token.STRING || param.getType() \u003d\u003d Token.REGEXP))\n                    return false;\n            }\n        }\n    }\n    return true;\n}",
      "path": "src/com/google/javascript/jscomp/NodeUtil.java",
      "functionStartLine": 588,
      "functionName": "functionCallHasSideEffects",
      "functionAnnotation": "",
      "functionDoc": "Returns true if calls to this function have side effects.\n\n@param callNode The call node to inspected.\n@param compiler A compiler object to provide program state changing\n    context information. Can be null.\n",
      "diff": "@@ -1,30 +1,30 @@\n static boolean functionCallHasSideEffects(Node callNode, @Nullable AbstractCompiler compiler) {\n     Preconditions.checkArgument(callNode.getType() \u003d\u003d Token.CALL, \"Expected CALL node, got \" + Token.name(callNode.getType()));\n     if (callNode.isNoSideEffectsCall()) {\n         return false;\n     }\n     Node nameNode \u003d callNode.getFirstChild();\n     if (nameNode.getType() \u003d\u003d Token.NAME) {\n         String name \u003d nameNode.getString();\n-        if (name.equals(\"String\")) {\n+        if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {\n             return false;\n         }\n     } else if (nameNode.getType() \u003d\u003d Token.GETPROP) {\n         if (nameNode.getFirstChild().getType() \u003d\u003d Token.NAME) {\n             String namespaceName \u003d nameNode.getFirstChild().getString();\n             if (namespaceName.equals(\"Math\")) {\n                 return false;\n             }\n         }\n         if (compiler !\u003d null \u0026\u0026 !compiler.hasRegExpGlobalReferences()) {\n             if (nameNode.getFirstChild().getType() \u003d\u003d Token.REGEXP \u0026\u0026 REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n                 return false;\n             } else if (nameNode.getFirstChild().getType() \u003d\u003d Token.STRING \u0026\u0026 STRING_REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n                 Node param \u003d nameNode.getNext();\n                 if (param !\u003d null \u0026\u0026 (param.getType() \u003d\u003d Token.STRING || param.getType() \u003d\u003d Token.REGEXP))\n                     return false;\n             }\n         }\n     }\n     return true;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "80fe41fd0173c3eaa56f4abb783031966ea89cef": {
      "type": "Ymultichange(Yparameterchange,Ybodychange,Ydocchange)",
      "commitMessage": "\nChange on 2010/04/09 by john\n\n        Part II: Use global RegExp reference information to optimize references when possible.\n\n        R\u003dalan\n        DELTA\u003d231  (173 added, 17 deleted, 41 changed)\n\nChange on 2010/04/09 by nicksantos\n\n        Make JsFileLineParser much more efficient for large files\n        (we were running into problems with it running out of memory.)\n\n        R\u003dandrew\n        DELTA\u003d192  (157 added, 1 deleted, 34 changed)\n\nChange on 2010/04/09 by alan\n\n        Fix typed code gen crash when generating typed code.\n\n        R\u003dnicksantos\n        DELTA\u003d35  (24 added, 2 deleted, 9 changed)\n\nChange on 2010/04/09 by alan\n\n        Disable method motion on functions that reads closure variables.\n\n        R\u003dnicksantos\n        DELTA\u003d171  (162 added, 1 deleted, 8 changed)\n\nChange on 2010/04/12 by nada\n\n        In AmbiguateProperties, invert the related type relationship, by\n        considering subclasses and implementors (down) instead of superclasses\n        and implemented interfaces (up). This has two advantages:\n\n        - The \u0027independent of\u0027 relationship is simplified, because we only\n          need to consider whether the related types intersect.\n\n        - We can account for \u0027multiple inheritance\u0027, which is a practical\n          issue because of interfaces.\n\n        Note that the \u0027up\u0027 relationship allows us to easily find common\n        ancestors while the \u0027down\u0027 relationship allows us to easily find\n        common descendants -- and this is what we care about for ambiguation.\n\n\n        R\u003dmoedinger\n        DELTA\u003d173  (124 added, 15 deleted, 34 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003dmwgnge\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@180 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/12/10, 7:59 AM",
      "commitName": "80fe41fd0173c3eaa56f4abb783031966ea89cef",
      "commitAuthor": "Nicholas.J.Santos",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "\nChange on 2010/04/09 by john\n\n        Part II: Use global RegExp reference information to optimize references when possible.\n\n        R\u003dalan\n        DELTA\u003d231  (173 added, 17 deleted, 41 changed)\n\nChange on 2010/04/09 by nicksantos\n\n        Make JsFileLineParser much more efficient for large files\n        (we were running into problems with it running out of memory.)\n\n        R\u003dandrew\n        DELTA\u003d192  (157 added, 1 deleted, 34 changed)\n\nChange on 2010/04/09 by alan\n\n        Fix typed code gen crash when generating typed code.\n\n        R\u003dnicksantos\n        DELTA\u003d35  (24 added, 2 deleted, 9 changed)\n\nChange on 2010/04/09 by alan\n\n        Disable method motion on functions that reads closure variables.\n\n        R\u003dnicksantos\n        DELTA\u003d171  (162 added, 1 deleted, 8 changed)\n\nChange on 2010/04/12 by nada\n\n        In AmbiguateProperties, invert the related type relationship, by\n        considering subclasses and implementors (down) instead of superclasses\n        and implemented interfaces (up). This has two advantages:\n\n        - The \u0027independent of\u0027 relationship is simplified, because we only\n          need to consider whether the related types intersect.\n\n        - We can account for \u0027multiple inheritance\u0027, which is a practical\n          issue because of interfaces.\n\n        Note that the \u0027up\u0027 relationship allows us to easily find common\n        ancestors while the \u0027down\u0027 relationship allows us to easily find\n        common descendants -- and this is what we care about for ambiguation.\n\n\n        R\u003dmoedinger\n        DELTA\u003d173  (124 added, 15 deleted, 34 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003dmwgnge\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@180 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "4/12/10, 7:59 AM",
          "commitName": "80fe41fd0173c3eaa56f4abb783031966ea89cef",
          "commitAuthor": "Nicholas.J.Santos",
          "commitDateOld": "4/7/10, 11:34 AM",
          "commitNameOld": "7eaa0d8eca2549742649af34671eaf3da83b5c08",
          "commitAuthorOld": "Nicholas.J.Santos",
          "daysBetweenCommits": 4.85,
          "commitsBetweenForRepo": 5,
          "commitsBetweenForFile": 1,
          "actualSource": "static boolean functionCallHasSideEffects(Node callNode, @Nullable AbstractCompiler compiler) {\n    Preconditions.checkArgument(callNode.getType() \u003d\u003d Token.CALL, \"Expected CALL node, got \" + Token.name(callNode.getType()));\n    if (callNode.isNoSideEffectsCall()) {\n        return false;\n    }\n    Node nameNode \u003d callNode.getFirstChild();\n    if (nameNode.getType() \u003d\u003d Token.NAME) {\n        String name \u003d nameNode.getString();\n        if (name.equals(\"String\")) {\n            return false;\n        }\n    } else if (nameNode.getType() \u003d\u003d Token.GETPROP) {\n        if (nameNode.getFirstChild().getType() \u003d\u003d Token.NAME) {\n            String namespaceName \u003d nameNode.getFirstChild().getString();\n            if (namespaceName.equals(\"Math\")) {\n                return false;\n            }\n        }\n        if (compiler !\u003d null \u0026\u0026 !compiler.hasRegExpGlobalReferences()) {\n            if (nameNode.getFirstChild().getType() \u003d\u003d Token.REGEXP \u0026\u0026 REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n                return false;\n            } else if (nameNode.getFirstChild().getType() \u003d\u003d Token.STRING \u0026\u0026 STRING_REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n                Node param \u003d nameNode.getNext();\n                if (param !\u003d null \u0026\u0026 (param.getType() \u003d\u003d Token.STRING || param.getType() \u003d\u003d Token.REGEXP))\n                    return false;\n            }\n        }\n    }\n    return true;\n}",
          "path": "src/com/google/javascript/jscomp/NodeUtil.java",
          "functionStartLine": 520,
          "functionName": "functionCallHasSideEffects",
          "functionAnnotation": "",
          "functionDoc": "Returns true if calls to this function have side effects.\n\n@param callNode The call node to inspected.\n@param compiler A compiler object to provide program state changing\n    context information. Can be null.\n",
          "diff": "@@ -1,20 +1,30 @@\n-static boolean functionCallHasSideEffects(Node callNode) {\n+static boolean functionCallHasSideEffects(Node callNode, @Nullable AbstractCompiler compiler) {\n     Preconditions.checkArgument(callNode.getType() \u003d\u003d Token.CALL, \"Expected CALL node, got \" + Token.name(callNode.getType()));\n     if (callNode.isNoSideEffectsCall()) {\n         return false;\n     }\n     Node nameNode \u003d callNode.getFirstChild();\n     if (nameNode.getType() \u003d\u003d Token.NAME) {\n         String name \u003d nameNode.getString();\n         if (name.equals(\"String\")) {\n             return false;\n         }\n-    }\n-    if (nameNode.getType() \u003d\u003d Token.GETPROP \u0026\u0026 nameNode.getFirstChild().getType() \u003d\u003d Token.NAME) {\n-        String namespaceName \u003d nameNode.getFirstChild().getString();\n-        if (namespaceName.equals(\"Math\")) {\n-            return false;\n+    } else if (nameNode.getType() \u003d\u003d Token.GETPROP) {\n+        if (nameNode.getFirstChild().getType() \u003d\u003d Token.NAME) {\n+            String namespaceName \u003d nameNode.getFirstChild().getString();\n+            if (namespaceName.equals(\"Math\")) {\n+                return false;\n+            }\n+        }\n+        if (compiler !\u003d null \u0026\u0026 !compiler.hasRegExpGlobalReferences()) {\n+            if (nameNode.getFirstChild().getType() \u003d\u003d Token.REGEXP \u0026\u0026 REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n+                return false;\n+            } else if (nameNode.getFirstChild().getType() \u003d\u003d Token.STRING \u0026\u0026 STRING_REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n+                Node param \u003d nameNode.getNext();\n+                if (param !\u003d null \u0026\u0026 (param.getType() \u003d\u003d Token.STRING || param.getType() \u003d\u003d Token.REGEXP))\n+                    return false;\n+            }\n         }\n     }\n     return true;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[callNode-Node]",
            "newValue": "[callNode-Node, compiler-AbstractCompiler(annotations-@Nullable)]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "\nChange on 2010/04/09 by john\n\n        Part II: Use global RegExp reference information to optimize references when possible.\n\n        R\u003dalan\n        DELTA\u003d231  (173 added, 17 deleted, 41 changed)\n\nChange on 2010/04/09 by nicksantos\n\n        Make JsFileLineParser much more efficient for large files\n        (we were running into problems with it running out of memory.)\n\n        R\u003dandrew\n        DELTA\u003d192  (157 added, 1 deleted, 34 changed)\n\nChange on 2010/04/09 by alan\n\n        Fix typed code gen crash when generating typed code.\n\n        R\u003dnicksantos\n        DELTA\u003d35  (24 added, 2 deleted, 9 changed)\n\nChange on 2010/04/09 by alan\n\n        Disable method motion on functions that reads closure variables.\n\n        R\u003dnicksantos\n        DELTA\u003d171  (162 added, 1 deleted, 8 changed)\n\nChange on 2010/04/12 by nada\n\n        In AmbiguateProperties, invert the related type relationship, by\n        considering subclasses and implementors (down) instead of superclasses\n        and implemented interfaces (up). This has two advantages:\n\n        - The \u0027independent of\u0027 relationship is simplified, because we only\n          need to consider whether the related types intersect.\n\n        - We can account for \u0027multiple inheritance\u0027, which is a practical\n          issue because of interfaces.\n\n        Note that the \u0027up\u0027 relationship allows us to easily find common\n        ancestors while the \u0027down\u0027 relationship allows us to easily find\n        common descendants -- and this is what we care about for ambiguation.\n\n\n        R\u003dmoedinger\n        DELTA\u003d173  (124 added, 15 deleted, 34 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003dmwgnge\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@180 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "4/12/10, 7:59 AM",
          "commitName": "80fe41fd0173c3eaa56f4abb783031966ea89cef",
          "commitAuthor": "Nicholas.J.Santos",
          "commitDateOld": "4/7/10, 11:34 AM",
          "commitNameOld": "7eaa0d8eca2549742649af34671eaf3da83b5c08",
          "commitAuthorOld": "Nicholas.J.Santos",
          "daysBetweenCommits": 4.85,
          "commitsBetweenForRepo": 5,
          "commitsBetweenForFile": 1,
          "actualSource": "static boolean functionCallHasSideEffects(Node callNode, @Nullable AbstractCompiler compiler) {\n    Preconditions.checkArgument(callNode.getType() \u003d\u003d Token.CALL, \"Expected CALL node, got \" + Token.name(callNode.getType()));\n    if (callNode.isNoSideEffectsCall()) {\n        return false;\n    }\n    Node nameNode \u003d callNode.getFirstChild();\n    if (nameNode.getType() \u003d\u003d Token.NAME) {\n        String name \u003d nameNode.getString();\n        if (name.equals(\"String\")) {\n            return false;\n        }\n    } else if (nameNode.getType() \u003d\u003d Token.GETPROP) {\n        if (nameNode.getFirstChild().getType() \u003d\u003d Token.NAME) {\n            String namespaceName \u003d nameNode.getFirstChild().getString();\n            if (namespaceName.equals(\"Math\")) {\n                return false;\n            }\n        }\n        if (compiler !\u003d null \u0026\u0026 !compiler.hasRegExpGlobalReferences()) {\n            if (nameNode.getFirstChild().getType() \u003d\u003d Token.REGEXP \u0026\u0026 REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n                return false;\n            } else if (nameNode.getFirstChild().getType() \u003d\u003d Token.STRING \u0026\u0026 STRING_REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n                Node param \u003d nameNode.getNext();\n                if (param !\u003d null \u0026\u0026 (param.getType() \u003d\u003d Token.STRING || param.getType() \u003d\u003d Token.REGEXP))\n                    return false;\n            }\n        }\n    }\n    return true;\n}",
          "path": "src/com/google/javascript/jscomp/NodeUtil.java",
          "functionStartLine": 520,
          "functionName": "functionCallHasSideEffects",
          "functionAnnotation": "",
          "functionDoc": "Returns true if calls to this function have side effects.\n\n@param callNode The call node to inspected.\n@param compiler A compiler object to provide program state changing\n    context information. Can be null.\n",
          "diff": "@@ -1,20 +1,30 @@\n-static boolean functionCallHasSideEffects(Node callNode) {\n+static boolean functionCallHasSideEffects(Node callNode, @Nullable AbstractCompiler compiler) {\n     Preconditions.checkArgument(callNode.getType() \u003d\u003d Token.CALL, \"Expected CALL node, got \" + Token.name(callNode.getType()));\n     if (callNode.isNoSideEffectsCall()) {\n         return false;\n     }\n     Node nameNode \u003d callNode.getFirstChild();\n     if (nameNode.getType() \u003d\u003d Token.NAME) {\n         String name \u003d nameNode.getString();\n         if (name.equals(\"String\")) {\n             return false;\n         }\n-    }\n-    if (nameNode.getType() \u003d\u003d Token.GETPROP \u0026\u0026 nameNode.getFirstChild().getType() \u003d\u003d Token.NAME) {\n-        String namespaceName \u003d nameNode.getFirstChild().getString();\n-        if (namespaceName.equals(\"Math\")) {\n-            return false;\n+    } else if (nameNode.getType() \u003d\u003d Token.GETPROP) {\n+        if (nameNode.getFirstChild().getType() \u003d\u003d Token.NAME) {\n+            String namespaceName \u003d nameNode.getFirstChild().getString();\n+            if (namespaceName.equals(\"Math\")) {\n+                return false;\n+            }\n+        }\n+        if (compiler !\u003d null \u0026\u0026 !compiler.hasRegExpGlobalReferences()) {\n+            if (nameNode.getFirstChild().getType() \u003d\u003d Token.REGEXP \u0026\u0026 REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n+                return false;\n+            } else if (nameNode.getFirstChild().getType() \u003d\u003d Token.STRING \u0026\u0026 STRING_REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n+                Node param \u003d nameNode.getNext();\n+                if (param !\u003d null \u0026\u0026 (param.getType() \u003d\u003d Token.STRING || param.getType() \u003d\u003d Token.REGEXP))\n+                    return false;\n+            }\n         }\n     }\n     return true;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "\nChange on 2010/04/09 by john\n\n        Part II: Use global RegExp reference information to optimize references when possible.\n\n        R\u003dalan\n        DELTA\u003d231  (173 added, 17 deleted, 41 changed)\n\nChange on 2010/04/09 by nicksantos\n\n        Make JsFileLineParser much more efficient for large files\n        (we were running into problems with it running out of memory.)\n\n        R\u003dandrew\n        DELTA\u003d192  (157 added, 1 deleted, 34 changed)\n\nChange on 2010/04/09 by alan\n\n        Fix typed code gen crash when generating typed code.\n\n        R\u003dnicksantos\n        DELTA\u003d35  (24 added, 2 deleted, 9 changed)\n\nChange on 2010/04/09 by alan\n\n        Disable method motion on functions that reads closure variables.\n\n        R\u003dnicksantos\n        DELTA\u003d171  (162 added, 1 deleted, 8 changed)\n\nChange on 2010/04/12 by nada\n\n        In AmbiguateProperties, invert the related type relationship, by\n        considering subclasses and implementors (down) instead of superclasses\n        and implemented interfaces (up). This has two advantages:\n\n        - The \u0027independent of\u0027 relationship is simplified, because we only\n          need to consider whether the related types intersect.\n\n        - We can account for \u0027multiple inheritance\u0027, which is a practical\n          issue because of interfaces.\n\n        Note that the \u0027up\u0027 relationship allows us to easily find common\n        ancestors while the \u0027down\u0027 relationship allows us to easily find\n        common descendants -- and this is what we care about for ambiguation.\n\n\n        R\u003dmoedinger\n        DELTA\u003d173  (124 added, 15 deleted, 34 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003dmwgnge\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@180 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "4/12/10, 7:59 AM",
          "commitName": "80fe41fd0173c3eaa56f4abb783031966ea89cef",
          "commitAuthor": "Nicholas.J.Santos",
          "commitDateOld": "4/7/10, 11:34 AM",
          "commitNameOld": "7eaa0d8eca2549742649af34671eaf3da83b5c08",
          "commitAuthorOld": "Nicholas.J.Santos",
          "daysBetweenCommits": 4.85,
          "commitsBetweenForRepo": 5,
          "commitsBetweenForFile": 1,
          "actualSource": "static boolean functionCallHasSideEffects(Node callNode, @Nullable AbstractCompiler compiler) {\n    Preconditions.checkArgument(callNode.getType() \u003d\u003d Token.CALL, \"Expected CALL node, got \" + Token.name(callNode.getType()));\n    if (callNode.isNoSideEffectsCall()) {\n        return false;\n    }\n    Node nameNode \u003d callNode.getFirstChild();\n    if (nameNode.getType() \u003d\u003d Token.NAME) {\n        String name \u003d nameNode.getString();\n        if (name.equals(\"String\")) {\n            return false;\n        }\n    } else if (nameNode.getType() \u003d\u003d Token.GETPROP) {\n        if (nameNode.getFirstChild().getType() \u003d\u003d Token.NAME) {\n            String namespaceName \u003d nameNode.getFirstChild().getString();\n            if (namespaceName.equals(\"Math\")) {\n                return false;\n            }\n        }\n        if (compiler !\u003d null \u0026\u0026 !compiler.hasRegExpGlobalReferences()) {\n            if (nameNode.getFirstChild().getType() \u003d\u003d Token.REGEXP \u0026\u0026 REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n                return false;\n            } else if (nameNode.getFirstChild().getType() \u003d\u003d Token.STRING \u0026\u0026 STRING_REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n                Node param \u003d nameNode.getNext();\n                if (param !\u003d null \u0026\u0026 (param.getType() \u003d\u003d Token.STRING || param.getType() \u003d\u003d Token.REGEXP))\n                    return false;\n            }\n        }\n    }\n    return true;\n}",
          "path": "src/com/google/javascript/jscomp/NodeUtil.java",
          "functionStartLine": 520,
          "functionName": "functionCallHasSideEffects",
          "functionAnnotation": "",
          "functionDoc": "Returns true if calls to this function have side effects.\n\n@param callNode The call node to inspected.\n@param compiler A compiler object to provide program state changing\n    context information. Can be null.\n",
          "diff": "@@ -1,20 +1,30 @@\n-static boolean functionCallHasSideEffects(Node callNode) {\n+static boolean functionCallHasSideEffects(Node callNode, @Nullable AbstractCompiler compiler) {\n     Preconditions.checkArgument(callNode.getType() \u003d\u003d Token.CALL, \"Expected CALL node, got \" + Token.name(callNode.getType()));\n     if (callNode.isNoSideEffectsCall()) {\n         return false;\n     }\n     Node nameNode \u003d callNode.getFirstChild();\n     if (nameNode.getType() \u003d\u003d Token.NAME) {\n         String name \u003d nameNode.getString();\n         if (name.equals(\"String\")) {\n             return false;\n         }\n-    }\n-    if (nameNode.getType() \u003d\u003d Token.GETPROP \u0026\u0026 nameNode.getFirstChild().getType() \u003d\u003d Token.NAME) {\n-        String namespaceName \u003d nameNode.getFirstChild().getString();\n-        if (namespaceName.equals(\"Math\")) {\n-            return false;\n+    } else if (nameNode.getType() \u003d\u003d Token.GETPROP) {\n+        if (nameNode.getFirstChild().getType() \u003d\u003d Token.NAME) {\n+            String namespaceName \u003d nameNode.getFirstChild().getString();\n+            if (namespaceName.equals(\"Math\")) {\n+                return false;\n+            }\n+        }\n+        if (compiler !\u003d null \u0026\u0026 !compiler.hasRegExpGlobalReferences()) {\n+            if (nameNode.getFirstChild().getType() \u003d\u003d Token.REGEXP \u0026\u0026 REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n+                return false;\n+            } else if (nameNode.getFirstChild().getType() \u003d\u003d Token.STRING \u0026\u0026 STRING_REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n+                Node param \u003d nameNode.getNext();\n+                if (param !\u003d null \u0026\u0026 (param.getType() \u003d\u003d Token.STRING || param.getType() \u003d\u003d Token.REGEXP))\n+                    return false;\n+            }\n         }\n     }\n     return true;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Returns true if calls to this function have side effects.\n\n@param callNode - function call node\n",
            "newValue": "Returns true if calls to this function have side effects.\n\n@param callNode The call node to inspected.\n@param compiler A compiler object to provide program state changing\n    context information. Can be null.\n"
          }
        }
      ]
    },
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": {
      "type": "Yintroduced",
      "commitMessage": "Initial commit.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/3/09, 3:51 PM",
      "commitName": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "diff": "@@ -0,0 +1,20 @@\n+static boolean functionCallHasSideEffects(Node callNode) {\n+    Preconditions.checkArgument(callNode.getType() \u003d\u003d Token.CALL, \"Expected CALL node, got \" + Token.name(callNode.getType()));\n+    if (callNode.isNoSideEffectsCall()) {\n+        return false;\n+    }\n+    Node nameNode \u003d callNode.getFirstChild();\n+    if (nameNode.getType() \u003d\u003d Token.NAME) {\n+        String name \u003d nameNode.getString();\n+        if (name.equals(\"String\")) {\n+            return false;\n+        }\n+    }\n+    if (nameNode.getType() \u003d\u003d Token.GETPROP \u0026\u0026 nameNode.getFirstChild().getType() \u003d\u003d Token.NAME) {\n+        String namespaceName \u003d nameNode.getFirstChild().getString();\n+        if (namespaceName.equals(\"Math\")) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n\\ No newline at end of file\n",
      "actualSource": "static boolean functionCallHasSideEffects(Node callNode) {\n    Preconditions.checkArgument(callNode.getType() \u003d\u003d Token.CALL, \"Expected CALL node, got \" + Token.name(callNode.getType()));\n    if (callNode.isNoSideEffectsCall()) {\n        return false;\n    }\n    Node nameNode \u003d callNode.getFirstChild();\n    if (nameNode.getType() \u003d\u003d Token.NAME) {\n        String name \u003d nameNode.getString();\n        if (name.equals(\"String\")) {\n            return false;\n        }\n    }\n    if (nameNode.getType() \u003d\u003d Token.GETPROP \u0026\u0026 nameNode.getFirstChild().getType() \u003d\u003d Token.NAME) {\n        String namespaceName \u003d nameNode.getFirstChild().getString();\n        if (namespaceName.equals(\"Math\")) {\n            return false;\n        }\n    }\n    return true;\n}",
      "path": "src/com/google/javascript/jscomp/NodeUtil.java",
      "functionStartLine": 485,
      "functionName": "functionCallHasSideEffects",
      "functionAnnotation": "",
      "functionDoc": "Returns true if calls to this function have side effects.\n\n@param callNode - function call node\n"
    }
  }
}