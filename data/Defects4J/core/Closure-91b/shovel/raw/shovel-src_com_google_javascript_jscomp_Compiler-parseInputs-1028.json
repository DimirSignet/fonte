{
  "origin": "codeshovel",
  "repositoryName": "Closure-91b",
  "repositoryPath": "/tmp/Closure-91b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "Compiler.java",
  "functionName": "parseInputs",
  "functionId": "parseInputs",
  "sourceFilePath": "src/com/google/javascript/jscomp/Compiler.java",
  "functionAnnotation": "",
  "functionDoc": "Parses the externs and main inputs.\n\n@return A synthetic root node whose two children are the externs root\n    and the main root\n",
  "functionStartLine": 1028,
  "functionEndLine": 1165,
  "numCommitsSeen": 49,
  "timeTaken": 3295,
  "changeHistory": [
    "cf96848764f0b01a57bd9daa512903a1f0b1c00a",
    "35d56dd1fadec0ed50797d222de4e05f78bbf1c9",
    "e33e925eea3a8e4de958864e531e1adc4da62e18",
    "c2d3c87f726630f66cbae09614853f660616eb16",
    "301ed5b03eb52debdc9b87929a45880eb2faf1fe",
    "475548341c38755063c8475379745ba31caffe41",
    "279196b617c5de1ade21110979b6b13d8eda6342",
    "9147da9979fb00599efd700fa5e0cccfa93d25a5",
    "b29d4a8bc7138f9216930edfebed29d42f0dca89",
    "e3bcc1c6e7ce7e9bfc3098cd5bf57774049f5baa",
    "a70a7c599e53a7752cf4b9e6e82b4408c3c4c04b",
    "847b296c23a63aa0a0b38cc3e63883e1688288e3",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3"
  ],
  "changeHistoryShort": {
    "cf96848764f0b01a57bd9daa512903a1f0b1c00a": "Ybodychange",
    "35d56dd1fadec0ed50797d222de4e05f78bbf1c9": "Ybodychange",
    "e33e925eea3a8e4de958864e531e1adc4da62e18": "Ybodychange",
    "c2d3c87f726630f66cbae09614853f660616eb16": "Ybodychange",
    "301ed5b03eb52debdc9b87929a45880eb2faf1fe": "Ybodychange",
    "475548341c38755063c8475379745ba31caffe41": "Ybodychange",
    "279196b617c5de1ade21110979b6b13d8eda6342": "Ybodychange",
    "9147da9979fb00599efd700fa5e0cccfa93d25a5": "Ybodychange",
    "b29d4a8bc7138f9216930edfebed29d42f0dca89": "Ybodychange",
    "e3bcc1c6e7ce7e9bfc3098cd5bf57774049f5baa": "Ybodychange",
    "a70a7c599e53a7752cf4b9e6e82b4408c3c4c04b": "Ybodychange",
    "847b296c23a63aa0a0b38cc3e63883e1688288e3": "Ybodychange",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "cf96848764f0b01a57bd9daa512903a1f0b1c00a": {
      "type": "Ybodychange",
      "commitMessage": "\nAdd a flag for defining entry points that we won\u0027t remove\nin manage_closure_dependencies mode.\nFixes issue 187\n\nR\u003dacleung\nDELTA\u003d232  (199 added, 15 deleted, 18 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d285838\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@476 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "10/5/10, 8:56 AM",
      "commitName": "cf96848764f0b01a57bd9daa512903a1f0b1c00a",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "9/16/10, 2:20 PM",
      "commitNameOld": "d00fc0c64dba6762b649f9690cd52c68b849e118",
      "commitAuthorOld": "mgoodman@google.com",
      "daysBetweenCommits": 18.78,
      "commitsBetweenForRepo": 32,
      "commitsBetweenForFile": 1,
      "actualSource": "Node parseInputs() {\n    boolean devMode \u003d options.devMode !\u003d DevMode.OFF;\n    if (externsRoot !\u003d null) {\n        externsRoot.detachChildren();\n    }\n    if (jsRoot !\u003d null) {\n        jsRoot.detachChildren();\n    }\n    jsRoot \u003d new Node(Token.BLOCK);\n    jsRoot.setIsSyntheticBlock(true);\n    if (options.tracer.isOn()) {\n        tracker \u003d new PerformanceTracker(jsRoot, options.tracer \u003d\u003d TracerMode.ALL);\n        addChangeHandler(tracker.getCodeChangeHandler());\n    }\n    Tracer tracer \u003d newTracer(\"parseInputs\");\n    try {\n        externsRoot \u003d new Node(Token.BLOCK);\n        externsRoot.setIsSyntheticBlock(true);\n        for (CompilerInput input : externs) {\n            Node n \u003d input.getAstRoot(this);\n            if (hasErrors()) {\n                return null;\n            }\n            externsRoot.addChildToBack(n);\n        }\n        if (options.manageClosureDependencies) {\n            for (CompilerInput input : inputs) {\n                input.setCompiler(this);\n                for (String provide : input.getProvides()) {\n                    getTypeRegistry().forwardDeclareType(provide);\n                }\n            }\n            try {\n                inputs \u003d (moduleGraph \u003d\u003d null ? new JSModuleGraph(modules) : moduleGraph).manageDependencies(options.manageClosureDependenciesEntryPoints, inputs);\n            } catch (CircularDependencyException e) {\n                report(JSError.make(JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n                return null;\n            } catch (MissingProvideException e) {\n                report(JSError.make(MISSING_ENTRY_ERROR, e.getMessage()));\n                return null;\n            }\n        }\n        boolean staleInputs \u003d false;\n        for (CompilerInput input : inputs) {\n            Node n \u003d input.getAstRoot(this);\n            if (hasErrors()) {\n                return null;\n            }\n            if (n \u003d\u003d null) {\n                continue;\n            }\n            if (n.getJSDocInfo() !\u003d null) {\n                JSDocInfo info \u003d n.getJSDocInfo();\n                if (info.isExterns()) {\n                    externsRoot.addChildToBack(n);\n                    input.setIsExtern(true);\n                    input.getModule().remove(input);\n                    externs.add(input);\n                    staleInputs \u003d true;\n                } else if (info.isNoCompile()) {\n                    input.getModule().remove(input);\n                    staleInputs \u003d true;\n                }\n            }\n        }\n        if (staleInputs) {\n            fillEmptyModules(modules);\n            rebuildInputsFromModules();\n        }\n        for (CompilerInput input : inputs) {\n            Node n \u003d input.getAstRoot(this);\n            if (n \u003d\u003d null) {\n                continue;\n            }\n            if (devMode) {\n                runSanityCheck();\n                if (hasErrors()) {\n                    return null;\n                }\n            }\n            if (options.sourceMapOutputPath !\u003d null || options.nameReferenceReportPath !\u003d null) {\n                SourceInformationAnnotator sia \u003d new SourceInformationAnnotator(input.getName(), options.devMode !\u003d DevMode.OFF);\n                NodeTraversal.traverse(this, n, sia);\n            }\n            jsRoot.addChildToBack(n);\n        }\n        externAndJsRoot \u003d new Node(Token.BLOCK, externsRoot, jsRoot);\n        externAndJsRoot.setIsSyntheticBlock(true);\n        return externAndJsRoot;\n    } finally {\n        stopTracer(tracer, \"parseInputs\");\n    }\n}",
      "path": "src/com/google/javascript/jscomp/Compiler.java",
      "functionStartLine": 1028,
      "functionName": "parseInputs",
      "functionAnnotation": "",
      "functionDoc": "Parses the externs and main inputs.\n\n@return A synthetic root node whose two children are the externs root\n    and the main root\n",
      "diff": "@@ -1,90 +1,93 @@\n Node parseInputs() {\n     boolean devMode \u003d options.devMode !\u003d DevMode.OFF;\n     if (externsRoot !\u003d null) {\n         externsRoot.detachChildren();\n     }\n     if (jsRoot !\u003d null) {\n         jsRoot.detachChildren();\n     }\n     jsRoot \u003d new Node(Token.BLOCK);\n     jsRoot.setIsSyntheticBlock(true);\n     if (options.tracer.isOn()) {\n         tracker \u003d new PerformanceTracker(jsRoot, options.tracer \u003d\u003d TracerMode.ALL);\n         addChangeHandler(tracker.getCodeChangeHandler());\n     }\n     Tracer tracer \u003d newTracer(\"parseInputs\");\n     try {\n         externsRoot \u003d new Node(Token.BLOCK);\n         externsRoot.setIsSyntheticBlock(true);\n         for (CompilerInput input : externs) {\n             Node n \u003d input.getAstRoot(this);\n             if (hasErrors()) {\n                 return null;\n             }\n             externsRoot.addChildToBack(n);\n         }\n         if (options.manageClosureDependencies) {\n             for (CompilerInput input : inputs) {\n                 input.setCompiler(this);\n                 for (String provide : input.getProvides()) {\n                     getTypeRegistry().forwardDeclareType(provide);\n                 }\n             }\n             try {\n-                inputs \u003d (moduleGraph \u003d\u003d null ? new JSModuleGraph(modules) : moduleGraph).manageDependencies(inputs);\n+                inputs \u003d (moduleGraph \u003d\u003d null ? new JSModuleGraph(modules) : moduleGraph).manageDependencies(options.manageClosureDependenciesEntryPoints, inputs);\n             } catch (CircularDependencyException e) {\n                 report(JSError.make(JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n                 return null;\n+            } catch (MissingProvideException e) {\n+                report(JSError.make(MISSING_ENTRY_ERROR, e.getMessage()));\n+                return null;\n             }\n         }\n         boolean staleInputs \u003d false;\n         for (CompilerInput input : inputs) {\n             Node n \u003d input.getAstRoot(this);\n             if (hasErrors()) {\n                 return null;\n             }\n             if (n \u003d\u003d null) {\n                 continue;\n             }\n             if (n.getJSDocInfo() !\u003d null) {\n                 JSDocInfo info \u003d n.getJSDocInfo();\n                 if (info.isExterns()) {\n                     externsRoot.addChildToBack(n);\n                     input.setIsExtern(true);\n                     input.getModule().remove(input);\n                     externs.add(input);\n                     staleInputs \u003d true;\n                 } else if (info.isNoCompile()) {\n                     input.getModule().remove(input);\n                     staleInputs \u003d true;\n                 }\n             }\n         }\n         if (staleInputs) {\n             fillEmptyModules(modules);\n             rebuildInputsFromModules();\n         }\n         for (CompilerInput input : inputs) {\n             Node n \u003d input.getAstRoot(this);\n             if (n \u003d\u003d null) {\n                 continue;\n             }\n             if (devMode) {\n                 runSanityCheck();\n                 if (hasErrors()) {\n                     return null;\n                 }\n             }\n             if (options.sourceMapOutputPath !\u003d null || options.nameReferenceReportPath !\u003d null) {\n                 SourceInformationAnnotator sia \u003d new SourceInformationAnnotator(input.getName(), options.devMode !\u003d DevMode.OFF);\n                 NodeTraversal.traverse(this, n, sia);\n             }\n             jsRoot.addChildToBack(n);\n         }\n         externAndJsRoot \u003d new Node(Token.BLOCK, externsRoot, jsRoot);\n         externAndJsRoot.setIsSyntheticBlock(true);\n         return externAndJsRoot;\n     } finally {\n         stopTracer(tracer, \"parseInputs\");\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "35d56dd1fadec0ed50797d222de4e05f78bbf1c9": {
      "type": "Ybodychange",
      "commitMessage": "\nChange on 2010/07/02 17:44:46 by nicksantos\n\n        fix RAI when comparing two types that are always equal.\n        Fixes issue 172\n\n        R\u003dacleung\n        DELTA\u003d20  (19 added, 0 deleted, 1 changed)\n\nChange on 2010/07/03 08:52:08 by johnlenz\n\n        Prefer the use of the unsyncronized StringBuilder over StringBuffer. This is just a code style change, this are no uses that should have any performance impact.\n\n        R\u003dacleung\n        DELTA\u003d30  (0 added, 2 deleted, 28 changed)\n\nChange on 2010/07/07 11:56:02 by johnlenz\n\n        Reduce the memory cost of generating source maps by reducing the number\n        of property structure objects that are created.  We do this by taking\n        advantage of the fact the property list objects are immutable and can be\n        shared between Nodes.  The source file prop is then shared between\n        every Node in the AST for a given source file, reducing the the number\n        of property nodes used to store this information from O(ast-nodes) to\n        O(source-files).\n\n        R\u003dbowdidge\n        DELTA\u003d122  (68 added, 1 deleted, 53 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d49002\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@265 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "7/7/10, 3:14 PM",
      "commitName": "35d56dd1fadec0ed50797d222de4e05f78bbf1c9",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "7/1/10, 7:38 AM",
      "commitNameOld": "9de5e9b4671773bb3f2d5932e57c1b4186b9b777",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 6.32,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "Node parseInputs() {\n    boolean devMode \u003d options.devMode !\u003d DevMode.OFF;\n    if (externsRoot !\u003d null) {\n        externsRoot.detachChildren();\n    }\n    if (jsRoot !\u003d null) {\n        jsRoot.detachChildren();\n    }\n    jsRoot \u003d new Node(Token.BLOCK);\n    jsRoot.setIsSyntheticBlock(true);\n    if (options.tracer.isOn()) {\n        tracker \u003d new PerformanceTracker(jsRoot, options.tracer \u003d\u003d TracerMode.ALL);\n        addChangeHandler(tracker.getCodeChangeHandler());\n    }\n    Tracer tracer \u003d newTracer(\"parseInputs\");\n    try {\n        externsRoot \u003d new Node(Token.BLOCK);\n        externsRoot.setIsSyntheticBlock(true);\n        for (CompilerInput input : externs) {\n            Node n \u003d input.getAstRoot(this);\n            if (hasErrors()) {\n                return null;\n            }\n            externsRoot.addChildToBack(n);\n        }\n        if (options.manageClosureDependencies) {\n            for (CompilerInput input : inputs) {\n                input.setCompiler(this);\n                for (String provide : input.getProvides()) {\n                    getTypeRegistry().forwardDeclareType(provide);\n                }\n            }\n            try {\n                inputs \u003d (moduleGraph \u003d\u003d null ? new JSModuleGraph(modules) : moduleGraph).manageDependencies(inputs);\n            } catch (CircularDependencyException e) {\n                report(JSError.make(JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n                return null;\n            }\n        }\n        boolean staleInputs \u003d false;\n        for (CompilerInput input : inputs) {\n            Node n \u003d input.getAstRoot(this);\n            if (hasErrors()) {\n                return null;\n            }\n            if (n \u003d\u003d null) {\n                continue;\n            }\n            if (n.getJSDocInfo() !\u003d null) {\n                JSDocInfo info \u003d n.getJSDocInfo();\n                if (info.isExterns()) {\n                    externsRoot.addChildToBack(n);\n                    input.setIsExtern(true);\n                    input.getModule().remove(input);\n                    externs.add(input);\n                    staleInputs \u003d true;\n                } else if (info.isNoCompile()) {\n                    input.getModule().remove(input);\n                    staleInputs \u003d true;\n                }\n            }\n        }\n        if (staleInputs) {\n            fillEmptyModules(modules);\n            rebuildInputsFromModules();\n        }\n        for (CompilerInput input : inputs) {\n            Node n \u003d input.getAstRoot(this);\n            if (n \u003d\u003d null) {\n                continue;\n            }\n            if (devMode) {\n                runSanityCheck();\n                if (hasErrors()) {\n                    return null;\n                }\n            }\n            if (options.sourceMapOutputPath !\u003d null || options.nameReferenceReportPath !\u003d null) {\n                SourceInformationAnnotator sia \u003d new SourceInformationAnnotator(input.getName(), options.devMode !\u003d DevMode.OFF);\n                NodeTraversal.traverse(this, n, sia);\n            }\n            jsRoot.addChildToBack(n);\n        }\n        externAndJsRoot \u003d new Node(Token.BLOCK, externsRoot, jsRoot);\n        externAndJsRoot.setIsSyntheticBlock(true);\n        return externAndJsRoot;\n    } finally {\n        stopTracer(tracer, \"parseInputs\");\n    }\n}",
      "path": "src/com/google/javascript/jscomp/Compiler.java",
      "functionStartLine": 997,
      "functionName": "parseInputs",
      "functionAnnotation": "",
      "functionDoc": "Parses the externs and main inputs.\n\n@return A synthetic root node whose two children are the externs root\n    and the main root\n",
      "diff": "@@ -1,90 +1,90 @@\n Node parseInputs() {\n     boolean devMode \u003d options.devMode !\u003d DevMode.OFF;\n     if (externsRoot !\u003d null) {\n         externsRoot.detachChildren();\n     }\n     if (jsRoot !\u003d null) {\n         jsRoot.detachChildren();\n     }\n     jsRoot \u003d new Node(Token.BLOCK);\n     jsRoot.setIsSyntheticBlock(true);\n     if (options.tracer.isOn()) {\n         tracker \u003d new PerformanceTracker(jsRoot, options.tracer \u003d\u003d TracerMode.ALL);\n         addChangeHandler(tracker.getCodeChangeHandler());\n     }\n     Tracer tracer \u003d newTracer(\"parseInputs\");\n     try {\n         externsRoot \u003d new Node(Token.BLOCK);\n         externsRoot.setIsSyntheticBlock(true);\n         for (CompilerInput input : externs) {\n             Node n \u003d input.getAstRoot(this);\n             if (hasErrors()) {\n                 return null;\n             }\n             externsRoot.addChildToBack(n);\n         }\n         if (options.manageClosureDependencies) {\n             for (CompilerInput input : inputs) {\n                 input.setCompiler(this);\n                 for (String provide : input.getProvides()) {\n                     getTypeRegistry().forwardDeclareType(provide);\n                 }\n             }\n             try {\n                 inputs \u003d (moduleGraph \u003d\u003d null ? new JSModuleGraph(modules) : moduleGraph).manageDependencies(inputs);\n             } catch (CircularDependencyException e) {\n                 report(JSError.make(JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n                 return null;\n             }\n         }\n         boolean staleInputs \u003d false;\n         for (CompilerInput input : inputs) {\n             Node n \u003d input.getAstRoot(this);\n             if (hasErrors()) {\n                 return null;\n             }\n             if (n \u003d\u003d null) {\n                 continue;\n             }\n             if (n.getJSDocInfo() !\u003d null) {\n                 JSDocInfo info \u003d n.getJSDocInfo();\n                 if (info.isExterns()) {\n                     externsRoot.addChildToBack(n);\n                     input.setIsExtern(true);\n                     input.getModule().remove(input);\n                     externs.add(input);\n                     staleInputs \u003d true;\n                 } else if (info.isNoCompile()) {\n                     input.getModule().remove(input);\n                     staleInputs \u003d true;\n                 }\n             }\n         }\n         if (staleInputs) {\n             fillEmptyModules(modules);\n             rebuildInputsFromModules();\n         }\n         for (CompilerInput input : inputs) {\n             Node n \u003d input.getAstRoot(this);\n             if (n \u003d\u003d null) {\n                 continue;\n             }\n             if (devMode) {\n                 runSanityCheck();\n                 if (hasErrors()) {\n                     return null;\n                 }\n             }\n             if (options.sourceMapOutputPath !\u003d null || options.nameReferenceReportPath !\u003d null) {\n-                SourceInformationAnnotator sia \u003d new SourceInformationAnnotator(input.getName());\n+                SourceInformationAnnotator sia \u003d new SourceInformationAnnotator(input.getName(), options.devMode !\u003d DevMode.OFF);\n                 NodeTraversal.traverse(this, n, sia);\n             }\n             jsRoot.addChildToBack(n);\n         }\n         externAndJsRoot \u003d new Node(Token.BLOCK, externsRoot, jsRoot);\n         externAndJsRoot.setIsSyntheticBlock(true);\n         return externAndJsRoot;\n     } finally {\n         stopTracer(tracer, \"parseInputs\");\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e33e925eea3a8e4de958864e531e1adc4da62e18": {
      "type": "Ybodychange",
      "commitMessage": "\nChange on 2010/06/14 by johnlenz\n\n        Remove unneed parenthese from hook expressions.\n\n        R\u003dacleung\n        DELTA\u003d76  (20 added, 4 deleted, 52 changed)\n\nChange on 2010/06/14 by johnlenz\n\n        Fix non-determinisim.\n\n        R\u003djschorr\n        DELTA\u003d5  (3 added, 0 deleted, 2 changed)\n\nChange on 2010/06/15 by nicksantos\n\n        fix a regression caused by a change in the ordering in which\n        constant folding is done.\n        parts of PeepholeSubstituteAlternateSyntax will crash if they\n        see a NEG node with a NUMBER child.\n        They were assuming that FoldConstants would fold these into one node.\n\n        R\u003ddcc,acleung\n        DELTA\u003d153  (70 added, 6 deleted, 77 changed)\n\nChange on 2010/06/15 by johnlenz\n\n        More debug diffing improvements: convert unique globally unique names\n        to locally unique names for reproduciblity.\n\n        R\u003dacleung\n        DELTA\u003d222  (44 added, 7 deleted, 171 changed)\n\nChange on 2010/06/15 by nicksantos\n\n        Add the @nocompile annotation as a signal that this file should\n        be dropped silently if it gets pulled into a --manage_closure_dependencies\n        build.\n\n        R\u003dbowdidge,gboyer\n        DELTA\u003d82  (60 added, 1 deleted, 21 changed)\n\nChange on 2010/06/15 by dcc\n\n        Refactor FoldConstants dead code removal into PeepholeRemoveDeadCode.\n\n        R\u003dacleung\n        DELTA\u003d744  (403 added, 307 deleted, 34 changed)\n\nChange on 2010/06/15 by dcc\n\n        ExternExports test now emits type annotation for exported externs.\n                - Changed ExternExportsPass to generate the externs as an AST and then print\n        to a String rather than ad hoc with a StringBuilder.\n                - Changed TypedCodeGenerator to generate \u0027*\u0027 (AllType) for parameters with unknown types rather than \u0027?\u0027 (UnknownType) since \u0027?\u0027 is not valid JSDoc.\n\n        R\u003dacleung\n        DELTA\u003d643  (496 added, 66 deleted, 81 changed)\n\nChange on 2010/06/16 by johnlenz\n\n        Tweak to PureFunctionIndentifier to propagate the side-effects for\n        anonymous function expressions like: (Date.now||function(){return\n        +new Date})()\n\n        R\u003davd\n        DELTA\u003d42  (39 added, 0 deleted, 3 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d29010\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@243 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "6/16/10, 12:33 PM",
      "commitName": "e33e925eea3a8e4de958864e531e1adc4da62e18",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "5/25/10, 10:51 AM",
      "commitNameOld": "170b23fa89cdcc38411fc29ec4453935e0903b16",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 22.07,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "actualSource": "Node parseInputs() {\n    boolean devMode \u003d options.devMode !\u003d DevMode.OFF;\n    if (externsRoot !\u003d null) {\n        externsRoot.detachChildren();\n    }\n    if (jsRoot !\u003d null) {\n        jsRoot.detachChildren();\n    }\n    jsRoot \u003d new Node(Token.BLOCK);\n    jsRoot.setIsSyntheticBlock(true);\n    if (options.tracer.isOn()) {\n        tracker \u003d new PerformanceTracker(jsRoot, options.tracer \u003d\u003d TracerMode.ALL);\n        addChangeHandler(tracker.getCodeChangeHandler());\n    }\n    Tracer tracer \u003d newTracer(\"parseInputs\");\n    try {\n        externsRoot \u003d new Node(Token.BLOCK);\n        externsRoot.setIsSyntheticBlock(true);\n        for (CompilerInput input : externs) {\n            Node n \u003d input.getAstRoot(this);\n            if (hasErrors()) {\n                return null;\n            }\n            externsRoot.addChildToBack(n);\n        }\n        if (options.manageClosureDependencies) {\n            for (CompilerInput input : inputs) {\n                input.setCompiler(this);\n                for (String provide : input.getProvides()) {\n                    getTypeRegistry().forwardDeclareType(provide);\n                }\n            }\n            try {\n                inputs \u003d (moduleGraph \u003d\u003d null ? new JSModuleGraph(modules) : moduleGraph).manageDependencies(inputs);\n            } catch (CircularDependencyException e) {\n                report(JSError.make(JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n                return null;\n            }\n        }\n        boolean staleInputs \u003d false;\n        for (CompilerInput input : inputs) {\n            Node n \u003d input.getAstRoot(this);\n            if (hasErrors()) {\n                return null;\n            }\n            if (n \u003d\u003d null) {\n                continue;\n            }\n            if (n.getJSDocInfo() !\u003d null) {\n                JSDocInfo info \u003d n.getJSDocInfo();\n                if (info.isExterns()) {\n                    externsRoot.addChildToBack(n);\n                    input.setIsExtern(true);\n                    input.getModule().remove(input);\n                    externs.add(input);\n                    staleInputs \u003d true;\n                } else if (info.isNoCompile()) {\n                    input.getModule().remove(input);\n                    staleInputs \u003d true;\n                }\n            }\n        }\n        if (staleInputs) {\n            fillEmptyModules(modules);\n            rebuildInputsFromModules();\n        }\n        for (CompilerInput input : inputs) {\n            Node n \u003d input.getAstRoot(this);\n            if (n \u003d\u003d null) {\n                continue;\n            }\n            if (devMode) {\n                runSanityCheck();\n                if (hasErrors()) {\n                    return null;\n                }\n            }\n            if (options.sourceMapOutputPath !\u003d null || options.nameReferenceReportPath !\u003d null) {\n                SourceInformationAnnotator sia \u003d new SourceInformationAnnotator(input.getName());\n                NodeTraversal.traverse(this, n, sia);\n            }\n            jsRoot.addChildToBack(n);\n        }\n        externAndJsRoot \u003d new Node(Token.BLOCK, externsRoot, jsRoot);\n        externAndJsRoot.setIsSyntheticBlock(true);\n        return externAndJsRoot;\n    } finally {\n        stopTracer(tracer, \"parseInputs\");\n    }\n}",
      "path": "src/com/google/javascript/jscomp/Compiler.java",
      "functionStartLine": 996,
      "functionName": "parseInputs",
      "functionAnnotation": "",
      "functionDoc": "Parses the externs and main inputs.\n\n@return A synthetic root node whose two children are the externs root\n    and the main root\n",
      "diff": "@@ -1,84 +1,90 @@\n Node parseInputs() {\n     boolean devMode \u003d options.devMode !\u003d DevMode.OFF;\n     if (externsRoot !\u003d null) {\n         externsRoot.detachChildren();\n     }\n     if (jsRoot !\u003d null) {\n         jsRoot.detachChildren();\n     }\n     jsRoot \u003d new Node(Token.BLOCK);\n     jsRoot.setIsSyntheticBlock(true);\n     if (options.tracer.isOn()) {\n         tracker \u003d new PerformanceTracker(jsRoot, options.tracer \u003d\u003d TracerMode.ALL);\n         addChangeHandler(tracker.getCodeChangeHandler());\n     }\n     Tracer tracer \u003d newTracer(\"parseInputs\");\n     try {\n         externsRoot \u003d new Node(Token.BLOCK);\n         externsRoot.setIsSyntheticBlock(true);\n         for (CompilerInput input : externs) {\n             Node n \u003d input.getAstRoot(this);\n             if (hasErrors()) {\n                 return null;\n             }\n             externsRoot.addChildToBack(n);\n         }\n         if (options.manageClosureDependencies) {\n             for (CompilerInput input : inputs) {\n                 input.setCompiler(this);\n                 for (String provide : input.getProvides()) {\n                     getTypeRegistry().forwardDeclareType(provide);\n                 }\n             }\n             try {\n                 inputs \u003d (moduleGraph \u003d\u003d null ? new JSModuleGraph(modules) : moduleGraph).manageDependencies(inputs);\n             } catch (CircularDependencyException e) {\n                 report(JSError.make(JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n                 return null;\n             }\n         }\n-        boolean liftedExterns \u003d false;\n+        boolean staleInputs \u003d false;\n         for (CompilerInput input : inputs) {\n             Node n \u003d input.getAstRoot(this);\n             if (hasErrors()) {\n                 return null;\n             }\n             if (n \u003d\u003d null) {\n                 continue;\n             }\n-            if (n.getJSDocInfo() !\u003d null \u0026\u0026 n.getJSDocInfo().isExterns()) {\n-                externsRoot.addChildToBack(n);\n-                input.setIsExtern(true);\n-                input.getModule().remove(input);\n-                externs.add(input);\n-                liftedExterns \u003d true;\n+            if (n.getJSDocInfo() !\u003d null) {\n+                JSDocInfo info \u003d n.getJSDocInfo();\n+                if (info.isExterns()) {\n+                    externsRoot.addChildToBack(n);\n+                    input.setIsExtern(true);\n+                    input.getModule().remove(input);\n+                    externs.add(input);\n+                    staleInputs \u003d true;\n+                } else if (info.isNoCompile()) {\n+                    input.getModule().remove(input);\n+                    staleInputs \u003d true;\n+                }\n             }\n         }\n-        if (liftedExterns) {\n+        if (staleInputs) {\n             fillEmptyModules(modules);\n             rebuildInputsFromModules();\n         }\n         for (CompilerInput input : inputs) {\n             Node n \u003d input.getAstRoot(this);\n             if (n \u003d\u003d null) {\n                 continue;\n             }\n             if (devMode) {\n                 runSanityCheck();\n                 if (hasErrors()) {\n                     return null;\n                 }\n             }\n             if (options.sourceMapOutputPath !\u003d null || options.nameReferenceReportPath !\u003d null) {\n                 SourceInformationAnnotator sia \u003d new SourceInformationAnnotator(input.getName());\n                 NodeTraversal.traverse(this, n, sia);\n             }\n             jsRoot.addChildToBack(n);\n         }\n         externAndJsRoot \u003d new Node(Token.BLOCK, externsRoot, jsRoot);\n         externAndJsRoot.setIsSyntheticBlock(true);\n         return externAndJsRoot;\n     } finally {\n         stopTracer(tracer, \"parseInputs\");\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c2d3c87f726630f66cbae09614853f660616eb16": {
      "type": "Ybodychange",
      "commitMessage": "\nChange on 2010/05/18 by nick\n\n        handle circular dependencies properly.\n\n        R\u003dalan\n        DELTA\u003d216  (182 added, 0 deleted, 34 changed)\n\nChange on 2010/05/18 by nick\n\n        open-source i18n plugin for translating goog.getMsg.\n        Slaps an apache license on everything and removes dependencies\n        on non-open-source code.\n\n        R\u003drobert\n        DELTA\u003d96  (78 added, 7 deleted, 11 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d7001\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@223 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "5/18/10, 5:37 PM",
      "commitName": "c2d3c87f726630f66cbae09614853f660616eb16",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "5/13/10, 5:34 PM",
      "commitNameOld": "260f0ffc9243ef15bd17e324c9cf7e2dfac9cc6a",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 5.0,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "Node parseInputs() {\n    boolean devMode \u003d options.devMode !\u003d DevMode.OFF;\n    if (externsRoot !\u003d null) {\n        externsRoot.detachChildren();\n    }\n    if (jsRoot !\u003d null) {\n        jsRoot.detachChildren();\n    }\n    jsRoot \u003d new Node(Token.BLOCK);\n    jsRoot.setIsSyntheticBlock(true);\n    if (options.tracer.isOn()) {\n        tracker \u003d new PerformanceTracker(jsRoot, options.tracer \u003d\u003d TracerMode.ALL);\n        addChangeHandler(tracker.getCodeChangeHandler());\n    }\n    Tracer tracer \u003d newTracer(\"parseInputs\");\n    try {\n        externsRoot \u003d new Node(Token.BLOCK);\n        externsRoot.setIsSyntheticBlock(true);\n        for (CompilerInput input : externs) {\n            Node n \u003d input.getAstRoot(this);\n            if (hasErrors()) {\n                return null;\n            }\n            externsRoot.addChildToBack(n);\n        }\n        if (options.manageClosureDependencies) {\n            for (CompilerInput input : inputs) {\n                input.setCompiler(this);\n                for (String provide : input.getProvides()) {\n                    getTypeRegistry().forwardDeclareType(provide);\n                }\n            }\n            try {\n                inputs \u003d (moduleGraph \u003d\u003d null ? new JSModuleGraph(modules) : moduleGraph).manageDependencies(inputs);\n            } catch (CircularDependencyException e) {\n                report(JSError.make(JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n                return null;\n            }\n        }\n        boolean liftedExterns \u003d false;\n        for (CompilerInput input : inputs) {\n            Node n \u003d input.getAstRoot(this);\n            if (hasErrors()) {\n                return null;\n            }\n            if (n \u003d\u003d null) {\n                continue;\n            }\n            if (n.getJSDocInfo() !\u003d null \u0026\u0026 n.getJSDocInfo().isExterns()) {\n                externsRoot.addChildToBack(n);\n                input.setIsExtern(true);\n                input.getModule().remove(input);\n                externs.add(input);\n                liftedExterns \u003d true;\n            }\n        }\n        if (liftedExterns) {\n            fillEmptyModules(modules);\n            rebuildInputsFromModules();\n        }\n        for (CompilerInput input : inputs) {\n            Node n \u003d input.getAstRoot(this);\n            if (n \u003d\u003d null) {\n                continue;\n            }\n            if (devMode) {\n                runSanityCheck();\n                if (hasErrors()) {\n                    return null;\n                }\n            }\n            if (options.sourceMapOutputPath !\u003d null || options.nameReferenceReportPath !\u003d null) {\n                SourceInformationAnnotator sia \u003d new SourceInformationAnnotator(input.getName());\n                NodeTraversal.traverse(this, n, sia);\n            }\n            jsRoot.addChildToBack(n);\n        }\n        externAndJsRoot \u003d new Node(Token.BLOCK, externsRoot, jsRoot);\n        externAndJsRoot.setIsSyntheticBlock(true);\n        return externAndJsRoot;\n    } finally {\n        stopTracer(tracer, \"parseInputs\");\n    }\n}",
      "path": "src/com/google/javascript/jscomp/Compiler.java",
      "functionStartLine": 1010,
      "functionName": "parseInputs",
      "functionAnnotation": "",
      "functionDoc": "Parses the externs and main inputs.\n\n@return A synthetic root node whose two children are the externs root\n    and the main root\n",
      "diff": "@@ -1,79 +1,84 @@\n Node parseInputs() {\n     boolean devMode \u003d options.devMode !\u003d DevMode.OFF;\n     if (externsRoot !\u003d null) {\n         externsRoot.detachChildren();\n     }\n     if (jsRoot !\u003d null) {\n         jsRoot.detachChildren();\n     }\n     jsRoot \u003d new Node(Token.BLOCK);\n     jsRoot.setIsSyntheticBlock(true);\n     if (options.tracer.isOn()) {\n         tracker \u003d new PerformanceTracker(jsRoot, options.tracer \u003d\u003d TracerMode.ALL);\n         addChangeHandler(tracker.getCodeChangeHandler());\n     }\n     Tracer tracer \u003d newTracer(\"parseInputs\");\n     try {\n         externsRoot \u003d new Node(Token.BLOCK);\n         externsRoot.setIsSyntheticBlock(true);\n         for (CompilerInput input : externs) {\n             Node n \u003d input.getAstRoot(this);\n             if (hasErrors()) {\n                 return null;\n             }\n             externsRoot.addChildToBack(n);\n         }\n         if (options.manageClosureDependencies) {\n             for (CompilerInput input : inputs) {\n                 input.setCompiler(this);\n                 for (String provide : input.getProvides()) {\n                     getTypeRegistry().forwardDeclareType(provide);\n                 }\n             }\n-            inputs \u003d (moduleGraph \u003d\u003d null ? new JSModuleGraph(modules) : moduleGraph).manageDependencies(inputs);\n+            try {\n+                inputs \u003d (moduleGraph \u003d\u003d null ? new JSModuleGraph(modules) : moduleGraph).manageDependencies(inputs);\n+            } catch (CircularDependencyException e) {\n+                report(JSError.make(JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n+                return null;\n+            }\n         }\n         boolean liftedExterns \u003d false;\n         for (CompilerInput input : inputs) {\n             Node n \u003d input.getAstRoot(this);\n             if (hasErrors()) {\n                 return null;\n             }\n             if (n \u003d\u003d null) {\n                 continue;\n             }\n             if (n.getJSDocInfo() !\u003d null \u0026\u0026 n.getJSDocInfo().isExterns()) {\n                 externsRoot.addChildToBack(n);\n                 input.setIsExtern(true);\n                 input.getModule().remove(input);\n                 externs.add(input);\n                 liftedExterns \u003d true;\n             }\n         }\n         if (liftedExterns) {\n             fillEmptyModules(modules);\n             rebuildInputsFromModules();\n         }\n         for (CompilerInput input : inputs) {\n             Node n \u003d input.getAstRoot(this);\n             if (n \u003d\u003d null) {\n                 continue;\n             }\n             if (devMode) {\n                 runSanityCheck();\n                 if (hasErrors()) {\n                     return null;\n                 }\n             }\n             if (options.sourceMapOutputPath !\u003d null || options.nameReferenceReportPath !\u003d null) {\n                 SourceInformationAnnotator sia \u003d new SourceInformationAnnotator(input.getName());\n                 NodeTraversal.traverse(this, n, sia);\n             }\n             jsRoot.addChildToBack(n);\n         }\n         externAndJsRoot \u003d new Node(Token.BLOCK, externsRoot, jsRoot);\n         externAndJsRoot.setIsSyntheticBlock(true);\n         return externAndJsRoot;\n     } finally {\n         stopTracer(tracer, \"parseInputs\");\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "301ed5b03eb52debdc9b87929a45880eb2faf1fe": {
      "type": "Ybodychange",
      "commitMessage": "\nChange on 2010/05/11 by robby\n\n        Support aliases in JsDoc + some additional tests.\n\n        R\u003dnick\n        DELTA\u003d311  (294 added, 2 deleted, 15 changed)\n\nChange on 2010/05/11 by nick\n\n        forward-declare type names that are dropped from the input.\n\n        R\u003dalan\n        DELTA\u003d31  (31 added, 0 deleted, 0 changed)\n\nChange on 2010/05/11 by nick\n\n        Verify that closure-compiler issue 157 is invalid.\n\n        R\u003drobert\n        DELTA\u003d4  (4 added, 0 deleted, 0 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003dvflmak\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@208 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "5/11/10, 6:45 PM",
      "commitName": "301ed5b03eb52debdc9b87929a45880eb2faf1fe",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "5/7/10, 2:59 PM",
      "commitNameOld": "475548341c38755063c8475379745ba31caffe41",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 4.16,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "Node parseInputs() {\n    boolean devMode \u003d options.devMode !\u003d DevMode.OFF;\n    if (externsRoot !\u003d null) {\n        externsRoot.detachChildren();\n    }\n    if (jsRoot !\u003d null) {\n        jsRoot.detachChildren();\n    }\n    jsRoot \u003d new Node(Token.BLOCK);\n    jsRoot.setIsSyntheticBlock(true);\n    if (options.tracer.isOn()) {\n        tracker \u003d new PerformanceTracker(jsRoot, options.tracer \u003d\u003d TracerMode.ALL);\n        addChangeHandler(tracker.getCodeChangeHandler());\n    }\n    Tracer tracer \u003d newTracer(\"parseInputs\");\n    try {\n        externsRoot \u003d new Node(Token.BLOCK);\n        externsRoot.setIsSyntheticBlock(true);\n        for (CompilerInput input : externs) {\n            Node n \u003d input.getAstRoot(this);\n            if (hasErrors()) {\n                return null;\n            }\n            externsRoot.addChildToBack(n);\n        }\n        if (options.manageClosureDependencies) {\n            for (CompilerInput input : inputs) {\n                input.setCompiler(this);\n                for (String provide : input.getProvides()) {\n                    getTypeRegistry().forwardDeclareType(provide);\n                }\n            }\n            inputs \u003d (moduleGraph \u003d\u003d null ? new JSModuleGraph(modules) : moduleGraph).manageDependencies(inputs);\n        }\n        boolean liftedExterns \u003d false;\n        for (CompilerInput input : inputs) {\n            Node n \u003d input.getAstRoot(this);\n            if (hasErrors()) {\n                return null;\n            }\n            if (n \u003d\u003d null) {\n                continue;\n            }\n            if (n.getJSDocInfo() !\u003d null \u0026\u0026 n.getJSDocInfo().isExterns()) {\n                externsRoot.addChildToBack(n);\n                input.setIsExtern(true);\n                input.getModule().remove(input);\n                externs.add(input);\n                liftedExterns \u003d true;\n            }\n        }\n        if (liftedExterns) {\n            fillEmptyModules(modules);\n            rebuildInputsFromModules();\n        }\n        for (CompilerInput input : inputs) {\n            Node n \u003d input.getAstRoot(this);\n            if (n \u003d\u003d null) {\n                continue;\n            }\n            if (devMode) {\n                runSanityCheck();\n                if (hasErrors()) {\n                    return null;\n                }\n            }\n            if (options.sourceMapOutputPath !\u003d null || options.nameReferenceReportPath !\u003d null) {\n                SourceInformationAnnotator sia \u003d new SourceInformationAnnotator(input.getName());\n                NodeTraversal.traverse(this, n, sia);\n            }\n            jsRoot.addChildToBack(n);\n        }\n        externAndJsRoot \u003d new Node(Token.BLOCK, externsRoot, jsRoot);\n        externAndJsRoot.setIsSyntheticBlock(true);\n        return externAndJsRoot;\n    } finally {\n        stopTracer(tracer, \"parseInputs\");\n    }\n}",
      "path": "src/com/google/javascript/jscomp/Compiler.java",
      "functionStartLine": 1008,
      "functionName": "parseInputs",
      "functionAnnotation": "",
      "functionDoc": "Parses the externs and main inputs.\n\n@return A synthetic root node whose two children are the externs root\n    and the main root\n",
      "diff": "@@ -1,76 +1,79 @@\n Node parseInputs() {\n     boolean devMode \u003d options.devMode !\u003d DevMode.OFF;\n     if (externsRoot !\u003d null) {\n         externsRoot.detachChildren();\n     }\n     if (jsRoot !\u003d null) {\n         jsRoot.detachChildren();\n     }\n     jsRoot \u003d new Node(Token.BLOCK);\n     jsRoot.setIsSyntheticBlock(true);\n     if (options.tracer.isOn()) {\n         tracker \u003d new PerformanceTracker(jsRoot, options.tracer \u003d\u003d TracerMode.ALL);\n         addChangeHandler(tracker.getCodeChangeHandler());\n     }\n     Tracer tracer \u003d newTracer(\"parseInputs\");\n     try {\n         externsRoot \u003d new Node(Token.BLOCK);\n         externsRoot.setIsSyntheticBlock(true);\n         for (CompilerInput input : externs) {\n             Node n \u003d input.getAstRoot(this);\n             if (hasErrors()) {\n                 return null;\n             }\n             externsRoot.addChildToBack(n);\n         }\n         if (options.manageClosureDependencies) {\n             for (CompilerInput input : inputs) {\n                 input.setCompiler(this);\n+                for (String provide : input.getProvides()) {\n+                    getTypeRegistry().forwardDeclareType(provide);\n+                }\n             }\n             inputs \u003d (moduleGraph \u003d\u003d null ? new JSModuleGraph(modules) : moduleGraph).manageDependencies(inputs);\n         }\n         boolean liftedExterns \u003d false;\n         for (CompilerInput input : inputs) {\n             Node n \u003d input.getAstRoot(this);\n             if (hasErrors()) {\n                 return null;\n             }\n             if (n \u003d\u003d null) {\n                 continue;\n             }\n             if (n.getJSDocInfo() !\u003d null \u0026\u0026 n.getJSDocInfo().isExterns()) {\n                 externsRoot.addChildToBack(n);\n                 input.setIsExtern(true);\n                 input.getModule().remove(input);\n                 externs.add(input);\n                 liftedExterns \u003d true;\n             }\n         }\n         if (liftedExterns) {\n             fillEmptyModules(modules);\n             rebuildInputsFromModules();\n         }\n         for (CompilerInput input : inputs) {\n             Node n \u003d input.getAstRoot(this);\n             if (n \u003d\u003d null) {\n                 continue;\n             }\n             if (devMode) {\n                 runSanityCheck();\n                 if (hasErrors()) {\n                     return null;\n                 }\n             }\n             if (options.sourceMapOutputPath !\u003d null || options.nameReferenceReportPath !\u003d null) {\n                 SourceInformationAnnotator sia \u003d new SourceInformationAnnotator(input.getName());\n                 NodeTraversal.traverse(this, n, sia);\n             }\n             jsRoot.addChildToBack(n);\n         }\n         externAndJsRoot \u003d new Node(Token.BLOCK, externsRoot, jsRoot);\n         externAndJsRoot.setIsSyntheticBlock(true);\n         return externAndJsRoot;\n     } finally {\n         stopTracer(tracer, \"parseInputs\");\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "475548341c38755063c8475379745ba31caffe41": {
      "type": "Ybodychange",
      "commitMessage": "\nChange on 2010/05/06 by nick\n\n        Automatic source sorting--now with modules!\n\n        R\u003dalan\n        DELTA\u003d194  (176 added, 7 deleted, 11 changed)\n\nChange on 2010/05/06 by nick\n\n        Identify unknown @suppress parameters.\n\n        R\u003dalan\n        DELTA\u003d109  (83 added, 12 deleted, 14 changed)\n\nChange on 2010/05/06 by alan\n\n        Enable flow sensitive inlining in open source world.\n\n        R\u003dnick\n        DELTA\u003d2  (2 added, 0 deleted, 0 changed)\n\nChange on 2010/05/06 by alan\n\n        Factor out JoinOp\n\n        R\u003dnick\n        DELTA\u003d137  (77 added, 54 deleted, 6 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003dewwtfu\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@204 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "5/7/10, 2:59 PM",
      "commitName": "475548341c38755063c8475379745ba31caffe41",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "5/5/10, 4:36 PM",
      "commitNameOld": "279196b617c5de1ade21110979b6b13d8eda6342",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 1.93,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "Node parseInputs() {\n    boolean devMode \u003d options.devMode !\u003d DevMode.OFF;\n    if (externsRoot !\u003d null) {\n        externsRoot.detachChildren();\n    }\n    if (jsRoot !\u003d null) {\n        jsRoot.detachChildren();\n    }\n    jsRoot \u003d new Node(Token.BLOCK);\n    jsRoot.setIsSyntheticBlock(true);\n    if (options.tracer.isOn()) {\n        tracker \u003d new PerformanceTracker(jsRoot, options.tracer \u003d\u003d TracerMode.ALL);\n        addChangeHandler(tracker.getCodeChangeHandler());\n    }\n    Tracer tracer \u003d newTracer(\"parseInputs\");\n    try {\n        externsRoot \u003d new Node(Token.BLOCK);\n        externsRoot.setIsSyntheticBlock(true);\n        for (CompilerInput input : externs) {\n            Node n \u003d input.getAstRoot(this);\n            if (hasErrors()) {\n                return null;\n            }\n            externsRoot.addChildToBack(n);\n        }\n        if (options.manageClosureDependencies) {\n            for (CompilerInput input : inputs) {\n                input.setCompiler(this);\n            }\n            inputs \u003d (moduleGraph \u003d\u003d null ? new JSModuleGraph(modules) : moduleGraph).manageDependencies(inputs);\n        }\n        boolean liftedExterns \u003d false;\n        for (CompilerInput input : inputs) {\n            Node n \u003d input.getAstRoot(this);\n            if (hasErrors()) {\n                return null;\n            }\n            if (n \u003d\u003d null) {\n                continue;\n            }\n            if (n.getJSDocInfo() !\u003d null \u0026\u0026 n.getJSDocInfo().isExterns()) {\n                externsRoot.addChildToBack(n);\n                input.setIsExtern(true);\n                input.getModule().remove(input);\n                externs.add(input);\n                liftedExterns \u003d true;\n            }\n        }\n        if (liftedExterns) {\n            fillEmptyModules(modules);\n            rebuildInputsFromModules();\n        }\n        for (CompilerInput input : inputs) {\n            Node n \u003d input.getAstRoot(this);\n            if (n \u003d\u003d null) {\n                continue;\n            }\n            if (devMode) {\n                runSanityCheck();\n                if (hasErrors()) {\n                    return null;\n                }\n            }\n            if (options.sourceMapOutputPath !\u003d null || options.nameReferenceReportPath !\u003d null) {\n                SourceInformationAnnotator sia \u003d new SourceInformationAnnotator(input.getName());\n                NodeTraversal.traverse(this, n, sia);\n            }\n            jsRoot.addChildToBack(n);\n        }\n        externAndJsRoot \u003d new Node(Token.BLOCK, externsRoot, jsRoot);\n        externAndJsRoot.setIsSyntheticBlock(true);\n        return externAndJsRoot;\n    } finally {\n        stopTracer(tracer, \"parseInputs\");\n    }\n}",
      "path": "src/com/google/javascript/jscomp/Compiler.java",
      "functionStartLine": 1008,
      "functionName": "parseInputs",
      "functionAnnotation": "",
      "functionDoc": "Parses the externs and main inputs.\n\n@return A synthetic root node whose two children are the externs root\n    and the main root\n",
      "diff": "@@ -1,77 +1,76 @@\n Node parseInputs() {\n     boolean devMode \u003d options.devMode !\u003d DevMode.OFF;\n     if (externsRoot !\u003d null) {\n         externsRoot.detachChildren();\n     }\n     if (jsRoot !\u003d null) {\n         jsRoot.detachChildren();\n     }\n     jsRoot \u003d new Node(Token.BLOCK);\n     jsRoot.setIsSyntheticBlock(true);\n     if (options.tracer.isOn()) {\n         tracker \u003d new PerformanceTracker(jsRoot, options.tracer \u003d\u003d TracerMode.ALL);\n         addChangeHandler(tracker.getCodeChangeHandler());\n     }\n     Tracer tracer \u003d newTracer(\"parseInputs\");\n     try {\n         externsRoot \u003d new Node(Token.BLOCK);\n         externsRoot.setIsSyntheticBlock(true);\n         for (CompilerInput input : externs) {\n             Node n \u003d input.getAstRoot(this);\n             if (hasErrors()) {\n                 return null;\n             }\n             externsRoot.addChildToBack(n);\n         }\n         if (options.manageClosureDependencies) {\n             for (CompilerInput input : inputs) {\n                 input.setCompiler(this);\n             }\n-            SortedDependencies\u003cCompilerInput\u003e sorter \u003d new SortedDependencies\u003cCompilerInput\u003e(inputs);\n-            inputs \u003d Lists.newArrayList(sorter.getSortedDependenciesOf(sorter.getInputsWithoutProvides()));\n+            inputs \u003d (moduleGraph \u003d\u003d null ? new JSModuleGraph(modules) : moduleGraph).manageDependencies(inputs);\n         }\n         boolean liftedExterns \u003d false;\n         for (CompilerInput input : inputs) {\n             Node n \u003d input.getAstRoot(this);\n             if (hasErrors()) {\n                 return null;\n             }\n             if (n \u003d\u003d null) {\n                 continue;\n             }\n             if (n.getJSDocInfo() !\u003d null \u0026\u0026 n.getJSDocInfo().isExterns()) {\n                 externsRoot.addChildToBack(n);\n                 input.setIsExtern(true);\n                 input.getModule().remove(input);\n                 externs.add(input);\n                 liftedExterns \u003d true;\n             }\n         }\n         if (liftedExterns) {\n             fillEmptyModules(modules);\n             rebuildInputsFromModules();\n         }\n         for (CompilerInput input : inputs) {\n             Node n \u003d input.getAstRoot(this);\n             if (n \u003d\u003d null) {\n                 continue;\n             }\n             if (devMode) {\n                 runSanityCheck();\n                 if (hasErrors()) {\n                     return null;\n                 }\n             }\n             if (options.sourceMapOutputPath !\u003d null || options.nameReferenceReportPath !\u003d null) {\n                 SourceInformationAnnotator sia \u003d new SourceInformationAnnotator(input.getName());\n                 NodeTraversal.traverse(this, n, sia);\n             }\n             jsRoot.addChildToBack(n);\n         }\n         externAndJsRoot \u003d new Node(Token.BLOCK, externsRoot, jsRoot);\n         externAndJsRoot.setIsSyntheticBlock(true);\n         return externAndJsRoot;\n     } finally {\n         stopTracer(tracer, \"parseInputs\");\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "279196b617c5de1ade21110979b6b13d8eda6342": {
      "type": "Ybodychange",
      "commitMessage": "\nChange on 2010/05/04 by nick\n\n        Pipe everything through the module code path.\n        This teases out a bunch of edge-case bugs that worked in the non-module\n        code path, but not the module code path (and vice-versa)\n\n        R\u003dalan\n        DELTA\u003d136  (67 added, 19 deleted, 50 changed)\n\nChange on 2010/05/04 by nick\n\n        fiddle with the check_global_this_level decision tree\n        This should be off by default if collapse_properties is off,\n        and on by default if collapse_properties is on.\n\n        R\u003dalan\n        DELTA\u003d47  (32 added, 4 deleted, 11 changed)\n\nChange on 2010/05/04 by andrew\n\n        -Infer that arguments to goog.asserts.assert() are non-nullable after the\n        call.\n        -Infer the types of arguments to goog.asserts.assert{String,Number,...} after\n        the call.\n\n        Tested:\n          -Added new unit tests.\n\n        R\u003dnick\n        DELTA\u003d277  (266 added, 4 deleted, 7 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003dqdhuno\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@203 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "5/5/10, 4:36 PM",
      "commitName": "279196b617c5de1ade21110979b6b13d8eda6342",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "5/3/10, 7:03 AM",
      "commitNameOld": "9147da9979fb00599efd700fa5e0cccfa93d25a5",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 2.4,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "Node parseInputs() {\n    boolean devMode \u003d options.devMode !\u003d DevMode.OFF;\n    if (externsRoot !\u003d null) {\n        externsRoot.detachChildren();\n    }\n    if (jsRoot !\u003d null) {\n        jsRoot.detachChildren();\n    }\n    jsRoot \u003d new Node(Token.BLOCK);\n    jsRoot.setIsSyntheticBlock(true);\n    if (options.tracer.isOn()) {\n        tracker \u003d new PerformanceTracker(jsRoot, options.tracer \u003d\u003d TracerMode.ALL);\n        addChangeHandler(tracker.getCodeChangeHandler());\n    }\n    Tracer tracer \u003d newTracer(\"parseInputs\");\n    try {\n        externsRoot \u003d new Node(Token.BLOCK);\n        externsRoot.setIsSyntheticBlock(true);\n        for (CompilerInput input : externs) {\n            Node n \u003d input.getAstRoot(this);\n            if (hasErrors()) {\n                return null;\n            }\n            externsRoot.addChildToBack(n);\n        }\n        if (options.manageClosureDependencies) {\n            for (CompilerInput input : inputs) {\n                input.setCompiler(this);\n            }\n            SortedDependencies\u003cCompilerInput\u003e sorter \u003d new SortedDependencies\u003cCompilerInput\u003e(inputs);\n            inputs \u003d Lists.newArrayList(sorter.getSortedDependenciesOf(sorter.getInputsWithoutProvides()));\n        }\n        boolean liftedExterns \u003d false;\n        for (CompilerInput input : inputs) {\n            Node n \u003d input.getAstRoot(this);\n            if (hasErrors()) {\n                return null;\n            }\n            if (n \u003d\u003d null) {\n                continue;\n            }\n            if (n.getJSDocInfo() !\u003d null \u0026\u0026 n.getJSDocInfo().isExterns()) {\n                externsRoot.addChildToBack(n);\n                input.setIsExtern(true);\n                input.getModule().remove(input);\n                externs.add(input);\n                liftedExterns \u003d true;\n            }\n        }\n        if (liftedExterns) {\n            fillEmptyModules(modules);\n            rebuildInputsFromModules();\n        }\n        for (CompilerInput input : inputs) {\n            Node n \u003d input.getAstRoot(this);\n            if (n \u003d\u003d null) {\n                continue;\n            }\n            if (devMode) {\n                runSanityCheck();\n                if (hasErrors()) {\n                    return null;\n                }\n            }\n            if (options.sourceMapOutputPath !\u003d null || options.nameReferenceReportPath !\u003d null) {\n                SourceInformationAnnotator sia \u003d new SourceInformationAnnotator(input.getName());\n                NodeTraversal.traverse(this, n, sia);\n            }\n            jsRoot.addChildToBack(n);\n        }\n        externAndJsRoot \u003d new Node(Token.BLOCK, externsRoot, jsRoot);\n        externAndJsRoot.setIsSyntheticBlock(true);\n        return externAndJsRoot;\n    } finally {\n        stopTracer(tracer, \"parseInputs\");\n    }\n}",
      "path": "src/com/google/javascript/jscomp/Compiler.java",
      "functionStartLine": 1011,
      "functionName": "parseInputs",
      "functionAnnotation": "",
      "functionDoc": "Parses the externs and main inputs.\n\n@return A synthetic root node whose two children are the externs root\n    and the main root\n",
      "diff": "@@ -1,69 +1,77 @@\n Node parseInputs() {\n     boolean devMode \u003d options.devMode !\u003d DevMode.OFF;\n     if (externsRoot !\u003d null) {\n         externsRoot.detachChildren();\n     }\n     if (jsRoot !\u003d null) {\n         jsRoot.detachChildren();\n     }\n     jsRoot \u003d new Node(Token.BLOCK);\n     jsRoot.setIsSyntheticBlock(true);\n     if (options.tracer.isOn()) {\n         tracker \u003d new PerformanceTracker(jsRoot, options.tracer \u003d\u003d TracerMode.ALL);\n         addChangeHandler(tracker.getCodeChangeHandler());\n     }\n     Tracer tracer \u003d newTracer(\"parseInputs\");\n     try {\n         externsRoot \u003d new Node(Token.BLOCK);\n         externsRoot.setIsSyntheticBlock(true);\n         for (CompilerInput input : externs) {\n             Node n \u003d input.getAstRoot(this);\n             if (hasErrors()) {\n                 return null;\n             }\n             externsRoot.addChildToBack(n);\n         }\n         if (options.manageClosureDependencies) {\n             for (CompilerInput input : inputs) {\n                 input.setCompiler(this);\n             }\n             SortedDependencies\u003cCompilerInput\u003e sorter \u003d new SortedDependencies\u003cCompilerInput\u003e(inputs);\n             inputs \u003d Lists.newArrayList(sorter.getSortedDependenciesOf(sorter.getInputsWithoutProvides()));\n         }\n-        List\u003cCompilerInput\u003e annotatedExterns \u003d Lists.newArrayList();\n-        Iterator\u003cCompilerInput\u003e inputIterator \u003d inputs.iterator();\n-        while (inputIterator.hasNext()) {\n-            CompilerInput input \u003d inputIterator.next();\n+        boolean liftedExterns \u003d false;\n+        for (CompilerInput input : inputs) {\n             Node n \u003d input.getAstRoot(this);\n             if (hasErrors()) {\n                 return null;\n             }\n             if (n \u003d\u003d null) {\n                 continue;\n             }\n             if (n.getJSDocInfo() !\u003d null \u0026\u0026 n.getJSDocInfo().isExterns()) {\n                 externsRoot.addChildToBack(n);\n                 input.setIsExtern(true);\n-                inputIterator.remove();\n+                input.getModule().remove(input);\n                 externs.add(input);\n+                liftedExterns \u003d true;\n+            }\n+        }\n+        if (liftedExterns) {\n+            fillEmptyModules(modules);\n+            rebuildInputsFromModules();\n+        }\n+        for (CompilerInput input : inputs) {\n+            Node n \u003d input.getAstRoot(this);\n+            if (n \u003d\u003d null) {\n                 continue;\n             }\n             if (devMode) {\n                 runSanityCheck();\n                 if (hasErrors()) {\n                     return null;\n                 }\n             }\n             if (options.sourceMapOutputPath !\u003d null || options.nameReferenceReportPath !\u003d null) {\n                 SourceInformationAnnotator sia \u003d new SourceInformationAnnotator(input.getName());\n                 NodeTraversal.traverse(this, n, sia);\n             }\n             jsRoot.addChildToBack(n);\n         }\n         externAndJsRoot \u003d new Node(Token.BLOCK, externsRoot, jsRoot);\n         externAndJsRoot.setIsSyntheticBlock(true);\n         return externAndJsRoot;\n     } finally {\n         stopTracer(tracer, \"parseInputs\");\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9147da9979fb00599efd700fa5e0cccfa93d25a5": {
      "type": "Ybodychange",
      "commitMessage": "\nChange on 2010/04/29 by alan\n\n        Don\u0027t inline a variable that has dependence on outer scoped variables.\n\n        R\u003dnick\n        DELTA\u003d44  (41 added, 0 deleted, 3 changed)\n\nChange on 2010/04/29 by nick\n\n        Remove some dead code.\n\n        R\u003dalan\n        DELTA\u003d113  (0 added, 113 deleted, 0 changed)\n\nChange on 2010/04/30 by andrew\n\n        -Fix up a copy/paste error in a comment.\n\n        R\u003djohn\n        DELTA\u003d1  (0 added, 0 deleted, 1 changed)\n\nChange on 2010/04/30 by nick\n\n        Prune sources that are not required when --manage_closure_dependencies\n        is on.\n\n        R\u003dalan\n        DELTA\u003d45  (22 added, 0 deleted, 23 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003dlwqqkv\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@201 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "5/3/10, 7:03 AM",
      "commitName": "9147da9979fb00599efd700fa5e0cccfa93d25a5",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "4/28/10, 11:13 AM",
      "commitNameOld": "3c2047d4ed1b14fc5e5269d08ee17bfc19bb5374",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 4.83,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "Node parseInputs() {\n    boolean devMode \u003d options.devMode !\u003d DevMode.OFF;\n    if (externsRoot !\u003d null) {\n        externsRoot.detachChildren();\n    }\n    if (jsRoot !\u003d null) {\n        jsRoot.detachChildren();\n    }\n    jsRoot \u003d new Node(Token.BLOCK);\n    jsRoot.setIsSyntheticBlock(true);\n    if (options.tracer.isOn()) {\n        tracker \u003d new PerformanceTracker(jsRoot, options.tracer \u003d\u003d TracerMode.ALL);\n        addChangeHandler(tracker.getCodeChangeHandler());\n    }\n    Tracer tracer \u003d newTracer(\"parseInputs\");\n    try {\n        externsRoot \u003d new Node(Token.BLOCK);\n        externsRoot.setIsSyntheticBlock(true);\n        for (CompilerInput input : externs) {\n            Node n \u003d input.getAstRoot(this);\n            if (hasErrors()) {\n                return null;\n            }\n            externsRoot.addChildToBack(n);\n        }\n        if (options.manageClosureDependencies) {\n            for (CompilerInput input : inputs) {\n                input.setCompiler(this);\n            }\n            SortedDependencies\u003cCompilerInput\u003e sorter \u003d new SortedDependencies\u003cCompilerInput\u003e(inputs);\n            inputs \u003d Lists.newArrayList(sorter.getSortedDependenciesOf(sorter.getInputsWithoutProvides()));\n        }\n        List\u003cCompilerInput\u003e annotatedExterns \u003d Lists.newArrayList();\n        Iterator\u003cCompilerInput\u003e inputIterator \u003d inputs.iterator();\n        while (inputIterator.hasNext()) {\n            CompilerInput input \u003d inputIterator.next();\n            Node n \u003d input.getAstRoot(this);\n            if (hasErrors()) {\n                return null;\n            }\n            if (n \u003d\u003d null) {\n                continue;\n            }\n            if (n.getJSDocInfo() !\u003d null \u0026\u0026 n.getJSDocInfo().isExterns()) {\n                externsRoot.addChildToBack(n);\n                input.setIsExtern(true);\n                inputIterator.remove();\n                externs.add(input);\n                continue;\n            }\n            if (devMode) {\n                runSanityCheck();\n                if (hasErrors()) {\n                    return null;\n                }\n            }\n            if (options.sourceMapOutputPath !\u003d null || options.nameReferenceReportPath !\u003d null) {\n                SourceInformationAnnotator sia \u003d new SourceInformationAnnotator(input.getName());\n                NodeTraversal.traverse(this, n, sia);\n            }\n            jsRoot.addChildToBack(n);\n        }\n        externAndJsRoot \u003d new Node(Token.BLOCK, externsRoot, jsRoot);\n        externAndJsRoot.setIsSyntheticBlock(true);\n        return externAndJsRoot;\n    } finally {\n        stopTracer(tracer, \"parseInputs\");\n    }\n}",
      "path": "src/com/google/javascript/jscomp/Compiler.java",
      "functionStartLine": 1019,
      "functionName": "parseInputs",
      "functionAnnotation": "",
      "functionDoc": "Parses the externs and main inputs.\n\n@return A synthetic root node whose two children are the externs root\n    and the main root\n",
      "diff": "@@ -1,69 +1,69 @@\n Node parseInputs() {\n     boolean devMode \u003d options.devMode !\u003d DevMode.OFF;\n     if (externsRoot !\u003d null) {\n         externsRoot.detachChildren();\n     }\n     if (jsRoot !\u003d null) {\n         jsRoot.detachChildren();\n     }\n     jsRoot \u003d new Node(Token.BLOCK);\n     jsRoot.setIsSyntheticBlock(true);\n     if (options.tracer.isOn()) {\n         tracker \u003d new PerformanceTracker(jsRoot, options.tracer \u003d\u003d TracerMode.ALL);\n         addChangeHandler(tracker.getCodeChangeHandler());\n     }\n     Tracer tracer \u003d newTracer(\"parseInputs\");\n     try {\n         externsRoot \u003d new Node(Token.BLOCK);\n         externsRoot.setIsSyntheticBlock(true);\n         for (CompilerInput input : externs) {\n             Node n \u003d input.getAstRoot(this);\n             if (hasErrors()) {\n                 return null;\n             }\n             externsRoot.addChildToBack(n);\n         }\n-        if (options.sortClosureDependencies) {\n+        if (options.manageClosureDependencies) {\n             for (CompilerInput input : inputs) {\n                 input.setCompiler(this);\n             }\n             SortedDependencies\u003cCompilerInput\u003e sorter \u003d new SortedDependencies\u003cCompilerInput\u003e(inputs);\n-            inputs \u003d Lists.newArrayList(sorter.getSortedList());\n+            inputs \u003d Lists.newArrayList(sorter.getSortedDependenciesOf(sorter.getInputsWithoutProvides()));\n         }\n         List\u003cCompilerInput\u003e annotatedExterns \u003d Lists.newArrayList();\n         Iterator\u003cCompilerInput\u003e inputIterator \u003d inputs.iterator();\n         while (inputIterator.hasNext()) {\n             CompilerInput input \u003d inputIterator.next();\n             Node n \u003d input.getAstRoot(this);\n             if (hasErrors()) {\n                 return null;\n             }\n             if (n \u003d\u003d null) {\n                 continue;\n             }\n             if (n.getJSDocInfo() !\u003d null \u0026\u0026 n.getJSDocInfo().isExterns()) {\n                 externsRoot.addChildToBack(n);\n                 input.setIsExtern(true);\n                 inputIterator.remove();\n                 externs.add(input);\n                 continue;\n             }\n             if (devMode) {\n                 runSanityCheck();\n                 if (hasErrors()) {\n                     return null;\n                 }\n             }\n             if (options.sourceMapOutputPath !\u003d null || options.nameReferenceReportPath !\u003d null) {\n                 SourceInformationAnnotator sia \u003d new SourceInformationAnnotator(input.getName());\n                 NodeTraversal.traverse(this, n, sia);\n             }\n             jsRoot.addChildToBack(n);\n         }\n         externAndJsRoot \u003d new Node(Token.BLOCK, externsRoot, jsRoot);\n         externAndJsRoot.setIsSyntheticBlock(true);\n         return externAndJsRoot;\n     } finally {\n         stopTracer(tracer, \"parseInputs\");\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b29d4a8bc7138f9216930edfebed29d42f0dca89": {
      "type": "Ybodychange",
      "commitMessage": "\nChange on 2010/04/19 by nick\n\n        automatic source-sorting based on closure dependencies.\n\n        R\u003dalan\n        DELTA\u003d98  (89 added, 5 deleted, 4 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003dohwxnh\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@192 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/20/10, 9:00 AM",
      "commitName": "b29d4a8bc7138f9216930edfebed29d42f0dca89",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "4/15/10, 4:45 PM",
      "commitNameOld": "e3bcc1c6e7ce7e9bfc3098cd5bf57774049f5baa",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 4.68,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "Node parseInputs() {\n    boolean devMode \u003d options.devMode !\u003d DevMode.OFF;\n    if (externsRoot !\u003d null) {\n        externsRoot.detachChildren();\n    }\n    if (jsRoot !\u003d null) {\n        jsRoot.detachChildren();\n    }\n    jsRoot \u003d new Node(Token.BLOCK);\n    jsRoot.setIsSyntheticBlock(true);\n    if (options.tracer.isOn()) {\n        tracker \u003d new PerformanceTracker(jsRoot, options.tracer \u003d\u003d TracerMode.ALL);\n        addChangeHandler(tracker.getCodeChangeHandler());\n    }\n    Tracer tracer \u003d newTracer(\"parseInputs\");\n    try {\n        externsRoot \u003d new Node(Token.BLOCK);\n        externsRoot.setIsSyntheticBlock(true);\n        for (CompilerInput input : externs) {\n            Node n \u003d input.getAstRoot(this);\n            if (hasErrors()) {\n                return null;\n            }\n            externsRoot.addChildToBack(n);\n        }\n        if (options.sortClosureDependencies) {\n            for (CompilerInput input : inputs) {\n                input.setCompiler(this);\n            }\n            SortedDependencies\u003cCompilerInput\u003e sorter \u003d new SortedDependencies\u003cCompilerInput\u003e(inputs);\n            inputs \u003d Lists.newArrayList(sorter.getSortedList());\n        }\n        List\u003cCompilerInput\u003e annotatedExterns \u003d Lists.newArrayList();\n        Iterator\u003cCompilerInput\u003e inputIterator \u003d inputs.iterator();\n        while (inputIterator.hasNext()) {\n            CompilerInput input \u003d inputIterator.next();\n            Node n \u003d input.getAstRoot(this);\n            if (hasErrors()) {\n                return null;\n            }\n            if (n \u003d\u003d null) {\n                continue;\n            }\n            if (n.getJSDocInfo() !\u003d null \u0026\u0026 n.getJSDocInfo().isExterns()) {\n                externsRoot.addChildToBack(n);\n                input.setIsExtern(true);\n                inputIterator.remove();\n                externs.add(input);\n                continue;\n            }\n            if (devMode) {\n                runSanityCheck();\n                if (hasErrors()) {\n                    return null;\n                }\n            }\n            if (options.sourceMapOutputPath !\u003d null || options.nameReferenceReportPath !\u003d null) {\n                SourceInformationAnnotator sia \u003d new SourceInformationAnnotator(input.getName());\n                NodeTraversal.traverse(this, n, sia);\n            }\n            jsRoot.addChildToBack(n);\n        }\n        externAndJsRoot \u003d new Node(Token.BLOCK, externsRoot, jsRoot);\n        externAndJsRoot.setIsSyntheticBlock(true);\n        return externAndJsRoot;\n    } finally {\n        stopTracer(tracer, \"parseInputs\");\n    }\n}",
      "path": "src/com/google/javascript/jscomp/Compiler.java",
      "functionStartLine": 1026,
      "functionName": "parseInputs",
      "functionAnnotation": "",
      "functionDoc": "Parses the externs and main inputs.\n\n@return A synthetic root node whose two children are the externs root\n    and the main root\n",
      "diff": "@@ -1,62 +1,69 @@\n Node parseInputs() {\n     boolean devMode \u003d options.devMode !\u003d DevMode.OFF;\n     if (externsRoot !\u003d null) {\n         externsRoot.detachChildren();\n     }\n     if (jsRoot !\u003d null) {\n         jsRoot.detachChildren();\n     }\n     jsRoot \u003d new Node(Token.BLOCK);\n     jsRoot.setIsSyntheticBlock(true);\n     if (options.tracer.isOn()) {\n         tracker \u003d new PerformanceTracker(jsRoot, options.tracer \u003d\u003d TracerMode.ALL);\n         addChangeHandler(tracker.getCodeChangeHandler());\n     }\n     Tracer tracer \u003d newTracer(\"parseInputs\");\n     try {\n         externsRoot \u003d new Node(Token.BLOCK);\n         externsRoot.setIsSyntheticBlock(true);\n         for (CompilerInput input : externs) {\n             Node n \u003d input.getAstRoot(this);\n             if (hasErrors()) {\n                 return null;\n             }\n             externsRoot.addChildToBack(n);\n         }\n+        if (options.sortClosureDependencies) {\n+            for (CompilerInput input : inputs) {\n+                input.setCompiler(this);\n+            }\n+            SortedDependencies\u003cCompilerInput\u003e sorter \u003d new SortedDependencies\u003cCompilerInput\u003e(inputs);\n+            inputs \u003d Lists.newArrayList(sorter.getSortedList());\n+        }\n         List\u003cCompilerInput\u003e annotatedExterns \u003d Lists.newArrayList();\n         Iterator\u003cCompilerInput\u003e inputIterator \u003d inputs.iterator();\n         while (inputIterator.hasNext()) {\n             CompilerInput input \u003d inputIterator.next();\n             Node n \u003d input.getAstRoot(this);\n             if (hasErrors()) {\n                 return null;\n             }\n             if (n \u003d\u003d null) {\n                 continue;\n             }\n             if (n.getJSDocInfo() !\u003d null \u0026\u0026 n.getJSDocInfo().isExterns()) {\n                 externsRoot.addChildToBack(n);\n                 input.setIsExtern(true);\n                 inputIterator.remove();\n                 externs.add(input);\n                 continue;\n             }\n             if (devMode) {\n                 runSanityCheck();\n                 if (hasErrors()) {\n                     return null;\n                 }\n             }\n             if (options.sourceMapOutputPath !\u003d null || options.nameReferenceReportPath !\u003d null) {\n                 SourceInformationAnnotator sia \u003d new SourceInformationAnnotator(input.getName());\n                 NodeTraversal.traverse(this, n, sia);\n             }\n             jsRoot.addChildToBack(n);\n         }\n         externAndJsRoot \u003d new Node(Token.BLOCK, externsRoot, jsRoot);\n         externAndJsRoot.setIsSyntheticBlock(true);\n         return externAndJsRoot;\n     } finally {\n         stopTracer(tracer, \"parseInputs\");\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e3bcc1c6e7ce7e9bfc3098cd5bf57774049f5baa": {
      "type": "Ybodychange",
      "commitMessage": "\nChange on 2010/04/15 by nick\n\n        Move the construction of ArrowTypes out of FunctionType.\n\n        R\u003djohn\n        DELTA\u003d197  (79 added, 27 deleted, 91 changed)\n\nChange on 2010/04/15 by nick\n\n        if a file is marked as an @extern, then make it an extern.\n\n        R\u003drobert\n        DELTA\u003d51  (46 added, 0 deleted, 5 changed)\n\nChange on 2010/04/15 by john\n\n        Maintain source information.\n\n        R\u003dalan\n        DELTA\u003d60  (28 added, 7 deleted, 25 changed)\n\nChange on 2010/04/15 by john\n\n        Fix overly aggressive RegExp check.\n\n        R\u003dalan\n        DELTA\u003d15  (12 added, 0 deleted, 3 changed)\n\nChange on 2010/04/15 by nick\n\n        more fun with function-type building.\n\n        R\u003djohn\n        DELTA\u003d432  (206 added, 142 deleted, 84 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003doqlcyn\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@186 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/15/10, 4:45 PM",
      "commitName": "e3bcc1c6e7ce7e9bfc3098cd5bf57774049f5baa",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "4/13/10, 2:39 PM",
      "commitNameOld": "de13c3313c05f4449c50c560324389d6905a214d",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 2.09,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "Node parseInputs() {\n    boolean devMode \u003d options.devMode !\u003d DevMode.OFF;\n    if (externsRoot !\u003d null) {\n        externsRoot.detachChildren();\n    }\n    if (jsRoot !\u003d null) {\n        jsRoot.detachChildren();\n    }\n    jsRoot \u003d new Node(Token.BLOCK);\n    jsRoot.setIsSyntheticBlock(true);\n    if (options.tracer.isOn()) {\n        tracker \u003d new PerformanceTracker(jsRoot, options.tracer \u003d\u003d TracerMode.ALL);\n        addChangeHandler(tracker.getCodeChangeHandler());\n    }\n    Tracer tracer \u003d newTracer(\"parseInputs\");\n    try {\n        externsRoot \u003d new Node(Token.BLOCK);\n        externsRoot.setIsSyntheticBlock(true);\n        for (CompilerInput input : externs) {\n            Node n \u003d input.getAstRoot(this);\n            if (hasErrors()) {\n                return null;\n            }\n            externsRoot.addChildToBack(n);\n        }\n        List\u003cCompilerInput\u003e annotatedExterns \u003d Lists.newArrayList();\n        Iterator\u003cCompilerInput\u003e inputIterator \u003d inputs.iterator();\n        while (inputIterator.hasNext()) {\n            CompilerInput input \u003d inputIterator.next();\n            Node n \u003d input.getAstRoot(this);\n            if (hasErrors()) {\n                return null;\n            }\n            if (n \u003d\u003d null) {\n                continue;\n            }\n            if (n.getJSDocInfo() !\u003d null \u0026\u0026 n.getJSDocInfo().isExterns()) {\n                externsRoot.addChildToBack(n);\n                input.setIsExtern(true);\n                inputIterator.remove();\n                externs.add(input);\n                continue;\n            }\n            if (devMode) {\n                runSanityCheck();\n                if (hasErrors()) {\n                    return null;\n                }\n            }\n            if (options.sourceMapOutputPath !\u003d null || options.nameReferenceReportPath !\u003d null) {\n                SourceInformationAnnotator sia \u003d new SourceInformationAnnotator(input.getName());\n                NodeTraversal.traverse(this, n, sia);\n            }\n            jsRoot.addChildToBack(n);\n        }\n        externAndJsRoot \u003d new Node(Token.BLOCK, externsRoot, jsRoot);\n        externAndJsRoot.setIsSyntheticBlock(true);\n        return externAndJsRoot;\n    } finally {\n        stopTracer(tracer, \"parseInputs\");\n    }\n}",
      "path": "src/com/google/javascript/jscomp/Compiler.java",
      "functionStartLine": 1025,
      "functionName": "parseInputs",
      "functionAnnotation": "",
      "functionDoc": "Parses the externs and main inputs.\n\n@return A synthetic root node whose two children are the externs root\n    and the main root\n",
      "diff": "@@ -1,52 +1,62 @@\n Node parseInputs() {\n     boolean devMode \u003d options.devMode !\u003d DevMode.OFF;\n     if (externsRoot !\u003d null) {\n         externsRoot.detachChildren();\n     }\n     if (jsRoot !\u003d null) {\n         jsRoot.detachChildren();\n     }\n     jsRoot \u003d new Node(Token.BLOCK);\n     jsRoot.setIsSyntheticBlock(true);\n     if (options.tracer.isOn()) {\n         tracker \u003d new PerformanceTracker(jsRoot, options.tracer \u003d\u003d TracerMode.ALL);\n         addChangeHandler(tracker.getCodeChangeHandler());\n     }\n     Tracer tracer \u003d newTracer(\"parseInputs\");\n     try {\n         externsRoot \u003d new Node(Token.BLOCK);\n         externsRoot.setIsSyntheticBlock(true);\n         for (CompilerInput input : externs) {\n             Node n \u003d input.getAstRoot(this);\n             if (hasErrors()) {\n                 return null;\n             }\n             externsRoot.addChildToBack(n);\n         }\n-        for (CompilerInput input : inputs) {\n+        List\u003cCompilerInput\u003e annotatedExterns \u003d Lists.newArrayList();\n+        Iterator\u003cCompilerInput\u003e inputIterator \u003d inputs.iterator();\n+        while (inputIterator.hasNext()) {\n+            CompilerInput input \u003d inputIterator.next();\n             Node n \u003d input.getAstRoot(this);\n             if (hasErrors()) {\n                 return null;\n             }\n             if (n \u003d\u003d null) {\n                 continue;\n             }\n+            if (n.getJSDocInfo() !\u003d null \u0026\u0026 n.getJSDocInfo().isExterns()) {\n+                externsRoot.addChildToBack(n);\n+                input.setIsExtern(true);\n+                inputIterator.remove();\n+                externs.add(input);\n+                continue;\n+            }\n             if (devMode) {\n                 runSanityCheck();\n                 if (hasErrors()) {\n                     return null;\n                 }\n             }\n             if (options.sourceMapOutputPath !\u003d null || options.nameReferenceReportPath !\u003d null) {\n                 SourceInformationAnnotator sia \u003d new SourceInformationAnnotator(input.getName());\n                 NodeTraversal.traverse(this, n, sia);\n             }\n             jsRoot.addChildToBack(n);\n         }\n         externAndJsRoot \u003d new Node(Token.BLOCK, externsRoot, jsRoot);\n         externAndJsRoot.setIsSyntheticBlock(true);\n         return externAndJsRoot;\n     } finally {\n         stopTracer(tracer, \"parseInputs\");\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a70a7c599e53a7752cf4b9e6e82b4408c3c4c04b": {
      "type": "Ybodychange",
      "commitMessage": "fix silly 2004-era naming conventions (Nick)\nR\u003djohn\nDELTA\u003d134  (0 added, 0 deleted, 134 changed)\n\nInsert a place holder file for any empty modules. (Alan)\nR\u003dnick\nDELTA\u003d53  (46 added, 6 deleted, 1 changed)\n\nMaps API extern update.\n(Contributed by Chad Killingsworth)\nFixes issue 121\nDELTA\u003d86  (48 added, 16 deleted, 22 changed)\n\n\nGoogle Loader API externs.\n(Contributed by Chad Killingsworth)\nFixes issue 126\nDELTA\u003d54  (54 added, 0 deleted, 0 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@149 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "3/22/10, 10:51 PM",
      "commitName": "a70a7c599e53a7752cf4b9e6e82b4408c3c4c04b",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "3/22/10, 3:55 PM",
      "commitNameOld": "b347ce3a71e23a4ab92dc0a6c07d43e2f497c953",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 0.29,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "Node parseInputs() {\n    boolean devMode \u003d options.devMode !\u003d DevMode.OFF;\n    if (externsRoot !\u003d null) {\n        externsRoot.detachChildren();\n    }\n    if (jsRoot !\u003d null) {\n        jsRoot.detachChildren();\n    }\n    jsRoot \u003d new Node(Token.BLOCK);\n    jsRoot.setIsSyntheticBlock(true);\n    if (options.tracer.isOn()) {\n        tracker \u003d new PerformanceTracker(jsRoot, options.tracer \u003d\u003d TracerMode.ALL);\n        addChangeHandler(tracker.getCodeChangeHandler());\n    }\n    Tracer tracer \u003d newTracer(\"parseInputs\");\n    try {\n        externsRoot \u003d new Node(Token.BLOCK);\n        externsRoot.setIsSyntheticBlock(true);\n        for (CompilerInput input : externs) {\n            Node n \u003d input.getAstRoot(this);\n            if (hasErrors()) {\n                return null;\n            }\n            externsRoot.addChildToBack(n);\n        }\n        for (CompilerInput input : inputs) {\n            Node n \u003d input.getAstRoot(this);\n            if (hasErrors()) {\n                return null;\n            }\n            if (n \u003d\u003d null) {\n                continue;\n            }\n            if (devMode) {\n                runSanityCheck();\n                if (hasErrors()) {\n                    return null;\n                }\n            }\n            if (options.sourceMapOutputPath !\u003d null || options.nameReferenceReportPath !\u003d null) {\n                SourceInformationAnnotator sia \u003d new SourceInformationAnnotator(input.getName());\n                NodeTraversal.traverse(this, n, sia);\n            }\n            jsRoot.addChildToBack(n);\n        }\n        externAndJsRoot \u003d new Node(Token.BLOCK, externsRoot, jsRoot);\n        externAndJsRoot.setIsSyntheticBlock(true);\n        return externAndJsRoot;\n    } finally {\n        stopTracer(tracer, \"parseInputs\");\n    }\n}",
      "path": "src/com/google/javascript/jscomp/Compiler.java",
      "functionStartLine": 976,
      "functionName": "parseInputs",
      "functionAnnotation": "",
      "functionDoc": "Parses the externs and main inputs.\n\n@return A synthetic root node whose two children are the externs root\n    and the main root\n",
      "diff": "@@ -1,52 +1,52 @@\n Node parseInputs() {\n-    boolean devMode \u003d options_.devMode !\u003d DevMode.OFF;\n+    boolean devMode \u003d options.devMode !\u003d DevMode.OFF;\n     if (externsRoot !\u003d null) {\n         externsRoot.detachChildren();\n     }\n     if (jsRoot !\u003d null) {\n         jsRoot.detachChildren();\n     }\n     jsRoot \u003d new Node(Token.BLOCK);\n     jsRoot.setIsSyntheticBlock(true);\n-    if (options_.tracer.isOn()) {\n-        tracker \u003d new PerformanceTracker(jsRoot, options_.tracer \u003d\u003d TracerMode.ALL);\n+    if (options.tracer.isOn()) {\n+        tracker \u003d new PerformanceTracker(jsRoot, options.tracer \u003d\u003d TracerMode.ALL);\n         addChangeHandler(tracker.getCodeChangeHandler());\n     }\n     Tracer tracer \u003d newTracer(\"parseInputs\");\n     try {\n         externsRoot \u003d new Node(Token.BLOCK);\n         externsRoot.setIsSyntheticBlock(true);\n-        for (CompilerInput input : externs_) {\n+        for (CompilerInput input : externs) {\n             Node n \u003d input.getAstRoot(this);\n             if (hasErrors()) {\n                 return null;\n             }\n             externsRoot.addChildToBack(n);\n         }\n-        for (CompilerInput input : inputs_) {\n+        for (CompilerInput input : inputs) {\n             Node n \u003d input.getAstRoot(this);\n             if (hasErrors()) {\n                 return null;\n             }\n             if (n \u003d\u003d null) {\n                 continue;\n             }\n             if (devMode) {\n                 runSanityCheck();\n                 if (hasErrors()) {\n                     return null;\n                 }\n             }\n-            if (options_.sourceMapOutputPath !\u003d null || options_.nameReferenceReportPath !\u003d null) {\n+            if (options.sourceMapOutputPath !\u003d null || options.nameReferenceReportPath !\u003d null) {\n                 SourceInformationAnnotator sia \u003d new SourceInformationAnnotator(input.getName());\n                 NodeTraversal.traverse(this, n, sia);\n             }\n             jsRoot.addChildToBack(n);\n         }\n         externAndJsRoot \u003d new Node(Token.BLOCK, externsRoot, jsRoot);\n         externAndJsRoot.setIsSyntheticBlock(true);\n         return externAndJsRoot;\n     } finally {\n         stopTracer(tracer, \"parseInputs\");\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "847b296c23a63aa0a0b38cc3e63883e1688288e3": {
      "type": "Ybodychange",
      "commitMessage": "Add support for other charset types.\n\nAdd support for ES5 directives.\n\nFork unit tests, so that they run more hermetically.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@21 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "12/8/09, 3:50 PM",
      "commitName": "847b296c23a63aa0a0b38cc3e63883e1688288e3",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "commitDateOld": "12/7/09, 1:53 PM",
      "commitNameOld": "845f5ff65858fd0d1829f3d2f16f758725e8028f",
      "commitAuthorOld": "nicholas.j.santos@gmail.com",
      "daysBetweenCommits": 1.08,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "Node parseInputs() {\n    boolean devMode \u003d options_.devMode !\u003d DevMode.OFF;\n    if (externsRoot !\u003d null) {\n        externsRoot.detachChildren();\n    }\n    if (jsRoot !\u003d null) {\n        jsRoot.detachChildren();\n    }\n    jsRoot \u003d new Node(Token.BLOCK);\n    jsRoot.setIsSyntheticBlock(true);\n    if (options_.tracer.isOn()) {\n        tracker \u003d new PerformanceTracker(jsRoot, options_.tracer \u003d\u003d TracerMode.ALL);\n        addChangeHandler(tracker.getCodeChangeHandler());\n    }\n    Tracer tracer \u003d newTracer(\"parseInputs\");\n    try {\n        externsRoot \u003d new Node(Token.BLOCK);\n        externsRoot.setIsSyntheticBlock(true);\n        for (CompilerInput input : externs_) {\n            Node n \u003d input.getAstRoot(this);\n            if (hasErrors()) {\n                return null;\n            }\n            externsRoot.addChildToBack(n);\n        }\n        for (CompilerInput input : inputs_) {\n            Node n \u003d input.getAstRoot(this);\n            if (hasErrors()) {\n                return null;\n            }\n            if (n \u003d\u003d null) {\n                continue;\n            }\n            if (devMode) {\n                runSanityCheck();\n                if (hasErrors()) {\n                    return null;\n                }\n            }\n            if (options_.sourceMapOutputPath !\u003d null || options_.nameReferenceReportPath !\u003d null) {\n                SourceInformationAnnotator sia \u003d new SourceInformationAnnotator(input.getName());\n                NodeTraversal.traverse(this, n, sia);\n            }\n            jsRoot.addChildToBack(n);\n        }\n        externAndJsRoot \u003d new Node(Token.BLOCK, externsRoot, jsRoot);\n        externAndJsRoot.setIsSyntheticBlock(true);\n        return externAndJsRoot;\n    } finally {\n        stopTracer(tracer, \"parseInputs\");\n    }\n}",
      "path": "src/com/google/javascript/jscomp/Compiler.java",
      "functionStartLine": 932,
      "functionName": "parseInputs",
      "functionAnnotation": "",
      "functionDoc": "Parses the externs and main inputs.\n\n@return A synthetic root node whose two children are the externs root\n    and the main root\n",
      "diff": "@@ -1,52 +1,52 @@\n Node parseInputs() {\n     boolean devMode \u003d options_.devMode !\u003d DevMode.OFF;\n     if (externsRoot !\u003d null) {\n         externsRoot.detachChildren();\n     }\n     if (jsRoot !\u003d null) {\n         jsRoot.detachChildren();\n     }\n     jsRoot \u003d new Node(Token.BLOCK);\n     jsRoot.setIsSyntheticBlock(true);\n     if (options_.tracer.isOn()) {\n         tracker \u003d new PerformanceTracker(jsRoot, options_.tracer \u003d\u003d TracerMode.ALL);\n         addChangeHandler(tracker.getCodeChangeHandler());\n     }\n     Tracer tracer \u003d newTracer(\"parseInputs\");\n     try {\n         externsRoot \u003d new Node(Token.BLOCK);\n         externsRoot.setIsSyntheticBlock(true);\n         for (CompilerInput input : externs_) {\n             Node n \u003d input.getAstRoot(this);\n             if (hasErrors()) {\n                 return null;\n             }\n             externsRoot.addChildToBack(n);\n         }\n         for (CompilerInput input : inputs_) {\n             Node n \u003d input.getAstRoot(this);\n             if (hasErrors()) {\n                 return null;\n             }\n             if (n \u003d\u003d null) {\n                 continue;\n             }\n             if (devMode) {\n-                sanityCheck.create(this).process(null, n);\n+                runSanityCheck();\n                 if (hasErrors()) {\n                     return null;\n                 }\n             }\n             if (options_.sourceMapOutputPath !\u003d null || options_.nameReferenceReportPath !\u003d null) {\n                 SourceInformationAnnotator sia \u003d new SourceInformationAnnotator(input.getName());\n                 NodeTraversal.traverse(this, n, sia);\n             }\n             jsRoot.addChildToBack(n);\n         }\n         externAndJsRoot \u003d new Node(Token.BLOCK, externsRoot, jsRoot);\n         externAndJsRoot.setIsSyntheticBlock(true);\n         return externAndJsRoot;\n     } finally {\n         stopTracer(tracer, \"parseInputs\");\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": {
      "type": "Yintroduced",
      "commitMessage": "Initial commit.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/3/09, 3:51 PM",
      "commitName": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "diff": "@@ -0,0 +1,52 @@\n+Node parseInputs() {\n+    boolean devMode \u003d options_.devMode !\u003d DevMode.OFF;\n+    if (externsRoot !\u003d null) {\n+        externsRoot.detachChildren();\n+    }\n+    if (jsRoot !\u003d null) {\n+        jsRoot.detachChildren();\n+    }\n+    jsRoot \u003d new Node(Token.BLOCK);\n+    jsRoot.setIsSyntheticBlock(true);\n+    if (options_.tracer.isOn()) {\n+        tracker \u003d new PerformanceTracker(jsRoot, options_.tracer \u003d\u003d TracerMode.ALL);\n+        addChangeHandler(tracker.getCodeChangeHandler());\n+    }\n+    Tracer tracer \u003d newTracer(\"parseInputs\");\n+    try {\n+        externsRoot \u003d new Node(Token.BLOCK);\n+        externsRoot.setIsSyntheticBlock(true);\n+        for (CompilerInput input : externs_) {\n+            Node n \u003d input.getAstRoot(this);\n+            if (hasErrors()) {\n+                return null;\n+            }\n+            externsRoot.addChildToBack(n);\n+        }\n+        for (CompilerInput input : inputs_) {\n+            Node n \u003d input.getAstRoot(this);\n+            if (hasErrors()) {\n+                return null;\n+            }\n+            if (n \u003d\u003d null) {\n+                continue;\n+            }\n+            if (devMode) {\n+                sanityCheck.create(this).process(null, n);\n+                if (hasErrors()) {\n+                    return null;\n+                }\n+            }\n+            if (options_.sourceMapOutputPath !\u003d null || options_.nameReferenceReportPath !\u003d null) {\n+                SourceInformationAnnotator sia \u003d new SourceInformationAnnotator(input.getName());\n+                NodeTraversal.traverse(this, n, sia);\n+            }\n+            jsRoot.addChildToBack(n);\n+        }\n+        externAndJsRoot \u003d new Node(Token.BLOCK, externsRoot, jsRoot);\n+        externAndJsRoot.setIsSyntheticBlock(true);\n+        return externAndJsRoot;\n+    } finally {\n+        stopTracer(tracer, \"parseInputs\");\n+    }\n+}\n\\ No newline at end of file\n",
      "actualSource": "Node parseInputs() {\n    boolean devMode \u003d options_.devMode !\u003d DevMode.OFF;\n    if (externsRoot !\u003d null) {\n        externsRoot.detachChildren();\n    }\n    if (jsRoot !\u003d null) {\n        jsRoot.detachChildren();\n    }\n    jsRoot \u003d new Node(Token.BLOCK);\n    jsRoot.setIsSyntheticBlock(true);\n    if (options_.tracer.isOn()) {\n        tracker \u003d new PerformanceTracker(jsRoot, options_.tracer \u003d\u003d TracerMode.ALL);\n        addChangeHandler(tracker.getCodeChangeHandler());\n    }\n    Tracer tracer \u003d newTracer(\"parseInputs\");\n    try {\n        externsRoot \u003d new Node(Token.BLOCK);\n        externsRoot.setIsSyntheticBlock(true);\n        for (CompilerInput input : externs_) {\n            Node n \u003d input.getAstRoot(this);\n            if (hasErrors()) {\n                return null;\n            }\n            externsRoot.addChildToBack(n);\n        }\n        for (CompilerInput input : inputs_) {\n            Node n \u003d input.getAstRoot(this);\n            if (hasErrors()) {\n                return null;\n            }\n            if (n \u003d\u003d null) {\n                continue;\n            }\n            if (devMode) {\n                sanityCheck.create(this).process(null, n);\n                if (hasErrors()) {\n                    return null;\n                }\n            }\n            if (options_.sourceMapOutputPath !\u003d null || options_.nameReferenceReportPath !\u003d null) {\n                SourceInformationAnnotator sia \u003d new SourceInformationAnnotator(input.getName());\n                NodeTraversal.traverse(this, n, sia);\n            }\n            jsRoot.addChildToBack(n);\n        }\n        externAndJsRoot \u003d new Node(Token.BLOCK, externsRoot, jsRoot);\n        externAndJsRoot.setIsSyntheticBlock(true);\n        return externAndJsRoot;\n    } finally {\n        stopTracer(tracer, \"parseInputs\");\n    }\n}",
      "path": "src/com/google/javascript/jscomp/Compiler.java",
      "functionStartLine": 972,
      "functionName": "parseInputs",
      "functionAnnotation": "",
      "functionDoc": "Parses the externs and main inputs.\n\n@return A synthetic root node whose two children are the externs root\n    and the main root\n"
    }
  }
}