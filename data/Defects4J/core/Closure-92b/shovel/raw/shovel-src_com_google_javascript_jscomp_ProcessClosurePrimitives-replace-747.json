{
  "origin": "codeshovel",
  "repositoryName": "Closure-92b",
  "repositoryPath": "/tmp/Closure-92b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ProcessClosurePrimitives.java",
  "functionName": "replace",
  "functionId": "$replace",
  "sourceFilePath": "src/com/google/javascript/jscomp/ProcessClosurePrimitives.java",
  "functionAnnotation": "",
  "functionDoc": "Replace the provide statement.\n\nIf we\u0027re providing a name with no definition, then create one.\nIf we\u0027re providing a name with a duplicate definition, then make sure\nthat definition becomes a declaration.\n",
  "functionStartLine": 747,
  "functionEndLine": 809,
  "numCommitsSeen": 23,
  "timeTaken": 1512,
  "changeHistory": [
    "5a3b4cb6b7e816aacd0ffd4c71e23da949fe360d",
    "9d1e18e87a41f2a610ed70f3a1d57abbce7a1cd7",
    "45f2bdf91ad3c2f2ac901c72efe9e26148b08d2b",
    "1046b0c09e2371f8924f72331d42db5b554c4a32"
  ],
  "changeHistoryShort": {
    "5a3b4cb6b7e816aacd0ffd4c71e23da949fe360d": "Ybodychange",
    "9d1e18e87a41f2a610ed70f3a1d57abbce7a1cd7": "Ybodychange",
    "45f2bdf91ad3c2f2ac901c72efe9e26148b08d2b": "Ybodychange",
    "1046b0c09e2371f8924f72331d42db5b554c4a32": "Yintroduced"
  },
  "changeHistoryDetails": {
    "5a3b4cb6b7e816aacd0ffd4c71e23da949fe360d": {
      "type": "Ybodychange",
      "commitMessage": "\nimprove validation for types that are resolved later.\n\nR\u003djohnlenz\nDELTA\u003d192  (166 added, 1 deleted, 25 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d337976\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@486 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "10/13/10, 2:23 PM",
      "commitName": "5a3b4cb6b7e816aacd0ffd4c71e23da949fe360d",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "10/13/10, 3:48 PM",
      "commitNameOld": "9d1e18e87a41f2a610ed70f3a1d57abbce7a1cd7",
      "commitAuthorOld": "mbolin",
      "daysBetweenCommits": -0.06,
      "commitsBetweenForRepo": 0,
      "commitsBetweenForFile": 0,
      "actualSource": "void replace() {\n    if (firstNode \u003d\u003d null) {\n        replacementNode \u003d candidateDefinition;\n        return;\n    }\n    if (candidateDefinition !\u003d null \u0026\u0026 explicitNode !\u003d null) {\n        explicitNode.detachFromParent();\n        compiler.reportCodeChange();\n        replacementNode \u003d candidateDefinition;\n        if (NodeUtil.isExpressionNode(candidateDefinition)) {\n            candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n            Node assignNode \u003d candidateDefinition.getFirstChild();\n            Node nameNode \u003d assignNode.getFirstChild();\n            if (nameNode.getType() \u003d\u003d Token.NAME) {\n                Node valueNode \u003d nameNode.getNext();\n                assignNode.removeChild(nameNode);\n                assignNode.removeChild(valueNode);\n                nameNode.addChildToFront(valueNode);\n                Node varNode \u003d new Node(Token.VAR, nameNode);\n                varNode.copyInformationFrom(candidateDefinition);\n                candidateDefinition.getParent().replaceChild(candidateDefinition, varNode);\n                nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n                compiler.reportCodeChange();\n                replacementNode \u003d varNode;\n            }\n        }\n    } else {\n        replacementNode \u003d createDeclarationNode();\n        if (firstModule \u003d\u003d minimumModule) {\n            firstNode.getParent().addChildBefore(replacementNode, firstNode);\n        } else {\n            int indexOfDot \u003d namespace.indexOf(\u0027.\u0027);\n            if (indexOfDot \u003d\u003d -1) {\n                compiler.getNodeForCodeInsertion(minimumModule).addChildToBack(replacementNode);\n            } else {\n                ProvidedName parentName \u003d providedNames.get(namespace.substring(0, indexOfDot));\n                Preconditions.checkNotNull(parentName);\n                Preconditions.checkNotNull(parentName.replacementNode);\n                parentName.replacementNode.getParent().addChildAfter(replacementNode, parentName.replacementNode);\n            }\n        }\n        if (explicitNode !\u003d null) {\n            explicitNode.detachFromParent();\n        }\n        compiler.reportCodeChange();\n    }\n}",
      "path": "src/com/google/javascript/jscomp/ProcessClosurePrimitives.java",
      "functionStartLine": 747,
      "functionName": "replace",
      "functionAnnotation": "",
      "functionDoc": "Replace the provide statement.\n\nIf we\u0027re providing a name with no definition, then create one.\nIf we\u0027re providing a name with a duplicate definition, then make sure\nthat definition becomes a declaration.\n",
      "diff": "@@ -1,47 +1,47 @@\n void replace() {\n     if (firstNode \u003d\u003d null) {\n         replacementNode \u003d candidateDefinition;\n         return;\n     }\n     if (candidateDefinition !\u003d null \u0026\u0026 explicitNode !\u003d null) {\n         explicitNode.detachFromParent();\n         compiler.reportCodeChange();\n         replacementNode \u003d candidateDefinition;\n         if (NodeUtil.isExpressionNode(candidateDefinition)) {\n             candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n             Node assignNode \u003d candidateDefinition.getFirstChild();\n             Node nameNode \u003d assignNode.getFirstChild();\n             if (nameNode.getType() \u003d\u003d Token.NAME) {\n                 Node valueNode \u003d nameNode.getNext();\n                 assignNode.removeChild(nameNode);\n                 assignNode.removeChild(valueNode);\n                 nameNode.addChildToFront(valueNode);\n                 Node varNode \u003d new Node(Token.VAR, nameNode);\n                 varNode.copyInformationFrom(candidateDefinition);\n                 candidateDefinition.getParent().replaceChild(candidateDefinition, varNode);\n                 nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n                 compiler.reportCodeChange();\n                 replacementNode \u003d varNode;\n             }\n         }\n     } else {\n         replacementNode \u003d createDeclarationNode();\n         if (firstModule \u003d\u003d minimumModule) {\n             firstNode.getParent().addChildBefore(replacementNode, firstNode);\n         } else {\n-            int indexOfDot \u003d namespace.lastIndexOf(\u0027.\u0027);\n+            int indexOfDot \u003d namespace.indexOf(\u0027.\u0027);\n             if (indexOfDot \u003d\u003d -1) {\n                 compiler.getNodeForCodeInsertion(minimumModule).addChildToBack(replacementNode);\n             } else {\n                 ProvidedName parentName \u003d providedNames.get(namespace.substring(0, indexOfDot));\n                 Preconditions.checkNotNull(parentName);\n                 Preconditions.checkNotNull(parentName.replacementNode);\n                 parentName.replacementNode.getParent().addChildAfter(replacementNode, parentName.replacementNode);\n             }\n         }\n         if (explicitNode !\u003d null) {\n             explicitNode.detachFromParent();\n         }\n         compiler.reportCodeChange();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9d1e18e87a41f2a610ed70f3a1d57abbce7a1cd7": {
      "type": "Ybodychange",
      "commitMessage": "Fixed bug 261: http://code.google.com/p/closure-compiler/issues/detail?id\u003d261\nMade JUnit test failure in Ant result in Ant failure (previously Ant printed BUILD SUCCESSFUL even when a test failed, thereby masking the failure).\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@485 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "10/13/10, 3:48 PM",
      "commitName": "9d1e18e87a41f2a610ed70f3a1d57abbce7a1cd7",
      "commitAuthor": "mbolin",
      "commitDateOld": "9/13/10, 11:12 AM",
      "commitNameOld": "4c6e1039b80859f17de5f3cbcfeba61ed8ea0485",
      "commitAuthorOld": "elbaum@google.com",
      "daysBetweenCommits": 30.19,
      "commitsBetweenForRepo": 60,
      "commitsBetweenForFile": 1,
      "actualSource": "void replace() {\n    if (firstNode \u003d\u003d null) {\n        replacementNode \u003d candidateDefinition;\n        return;\n    }\n    if (candidateDefinition !\u003d null \u0026\u0026 explicitNode !\u003d null) {\n        explicitNode.detachFromParent();\n        compiler.reportCodeChange();\n        replacementNode \u003d candidateDefinition;\n        if (NodeUtil.isExpressionNode(candidateDefinition)) {\n            candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n            Node assignNode \u003d candidateDefinition.getFirstChild();\n            Node nameNode \u003d assignNode.getFirstChild();\n            if (nameNode.getType() \u003d\u003d Token.NAME) {\n                Node valueNode \u003d nameNode.getNext();\n                assignNode.removeChild(nameNode);\n                assignNode.removeChild(valueNode);\n                nameNode.addChildToFront(valueNode);\n                Node varNode \u003d new Node(Token.VAR, nameNode);\n                varNode.copyInformationFrom(candidateDefinition);\n                candidateDefinition.getParent().replaceChild(candidateDefinition, varNode);\n                nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n                compiler.reportCodeChange();\n                replacementNode \u003d varNode;\n            }\n        }\n    } else {\n        replacementNode \u003d createDeclarationNode();\n        if (firstModule \u003d\u003d minimumModule) {\n            firstNode.getParent().addChildBefore(replacementNode, firstNode);\n        } else {\n            int indexOfDot \u003d namespace.lastIndexOf(\u0027.\u0027);\n            if (indexOfDot \u003d\u003d -1) {\n                compiler.getNodeForCodeInsertion(minimumModule).addChildToBack(replacementNode);\n            } else {\n                ProvidedName parentName \u003d providedNames.get(namespace.substring(0, indexOfDot));\n                Preconditions.checkNotNull(parentName);\n                Preconditions.checkNotNull(parentName.replacementNode);\n                parentName.replacementNode.getParent().addChildAfter(replacementNode, parentName.replacementNode);\n            }\n        }\n        if (explicitNode !\u003d null) {\n            explicitNode.detachFromParent();\n        }\n        compiler.reportCodeChange();\n    }\n}",
      "path": "src/com/google/javascript/jscomp/ProcessClosurePrimitives.java",
      "functionStartLine": 747,
      "functionName": "replace",
      "functionAnnotation": "",
      "functionDoc": "Replace the provide statement.\n\nIf we\u0027re providing a name with no definition, then create one.\nIf we\u0027re providing a name with a duplicate definition, then make sure\nthat definition becomes a declaration.\n",
      "diff": "@@ -1,47 +1,47 @@\n void replace() {\n     if (firstNode \u003d\u003d null) {\n         replacementNode \u003d candidateDefinition;\n         return;\n     }\n     if (candidateDefinition !\u003d null \u0026\u0026 explicitNode !\u003d null) {\n         explicitNode.detachFromParent();\n         compiler.reportCodeChange();\n         replacementNode \u003d candidateDefinition;\n         if (NodeUtil.isExpressionNode(candidateDefinition)) {\n             candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n             Node assignNode \u003d candidateDefinition.getFirstChild();\n             Node nameNode \u003d assignNode.getFirstChild();\n             if (nameNode.getType() \u003d\u003d Token.NAME) {\n                 Node valueNode \u003d nameNode.getNext();\n                 assignNode.removeChild(nameNode);\n                 assignNode.removeChild(valueNode);\n                 nameNode.addChildToFront(valueNode);\n                 Node varNode \u003d new Node(Token.VAR, nameNode);\n                 varNode.copyInformationFrom(candidateDefinition);\n                 candidateDefinition.getParent().replaceChild(candidateDefinition, varNode);\n                 nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n                 compiler.reportCodeChange();\n                 replacementNode \u003d varNode;\n             }\n         }\n     } else {\n         replacementNode \u003d createDeclarationNode();\n         if (firstModule \u003d\u003d minimumModule) {\n             firstNode.getParent().addChildBefore(replacementNode, firstNode);\n         } else {\n-            int indexOfDot \u003d namespace.indexOf(\u0027.\u0027);\n+            int indexOfDot \u003d namespace.lastIndexOf(\u0027.\u0027);\n             if (indexOfDot \u003d\u003d -1) {\n                 compiler.getNodeForCodeInsertion(minimumModule).addChildToBack(replacementNode);\n             } else {\n                 ProvidedName parentName \u003d providedNames.get(namespace.substring(0, indexOfDot));\n                 Preconditions.checkNotNull(parentName);\n                 Preconditions.checkNotNull(parentName.replacementNode);\n                 parentName.replacementNode.getParent().addChildAfter(replacementNode, parentName.replacementNode);\n             }\n         }\n         if (explicitNode !\u003d null) {\n             explicitNode.detachFromParent();\n         }\n         compiler.reportCodeChange();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "45f2bdf91ad3c2f2ac901c72efe9e26148b08d2b": {
      "type": "Ybodychange",
      "commitMessage": "Fix a bunch of passes to preserve more type information.\n\nFix goog.provide/goog.require handling to work in the presence of modules.\n\nImprove a bunch of type annotations in gecko_dom.\n\nMake NameAnalyzer use the Graph package.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@95 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "2/8/10, 11:30 AM",
      "commitName": "45f2bdf91ad3c2f2ac901c72efe9e26148b08d2b",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "2/5/10, 11:27 AM",
      "commitNameOld": "1046b0c09e2371f8924f72331d42db5b554c4a32",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 3.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "void replace() {\n    if (firstNode \u003d\u003d null) {\n        replacementNode \u003d candidateDefinition;\n        return;\n    }\n    if (candidateDefinition !\u003d null \u0026\u0026 explicitNode !\u003d null) {\n        explicitNode.detachFromParent();\n        compiler.reportCodeChange();\n        replacementNode \u003d candidateDefinition;\n        if (NodeUtil.isExpressionNode(candidateDefinition)) {\n            candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n            Node assignNode \u003d candidateDefinition.getFirstChild();\n            Node nameNode \u003d assignNode.getFirstChild();\n            if (nameNode.getType() \u003d\u003d Token.NAME) {\n                Node valueNode \u003d nameNode.getNext();\n                assignNode.removeChild(nameNode);\n                assignNode.removeChild(valueNode);\n                nameNode.addChildToFront(valueNode);\n                Node varNode \u003d new Node(Token.VAR, nameNode);\n                varNode.copyInformationFrom(candidateDefinition);\n                candidateDefinition.getParent().replaceChild(candidateDefinition, varNode);\n                nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n                compiler.reportCodeChange();\n                replacementNode \u003d varNode;\n            }\n        }\n    } else {\n        replacementNode \u003d createDeclarationNode();\n        if (firstModule \u003d\u003d minimumModule) {\n            firstNode.getParent().addChildBefore(replacementNode, firstNode);\n        } else {\n            int indexOfDot \u003d namespace.indexOf(\u0027.\u0027);\n            if (indexOfDot \u003d\u003d -1) {\n                compiler.getNodeForCodeInsertion(minimumModule).addChildToBack(replacementNode);\n            } else {\n                ProvidedName parentName \u003d providedNames.get(namespace.substring(0, indexOfDot));\n                Preconditions.checkNotNull(parentName);\n                Preconditions.checkNotNull(parentName.replacementNode);\n                parentName.replacementNode.getParent().addChildAfter(replacementNode, parentName.replacementNode);\n            }\n        }\n        if (explicitNode !\u003d null) {\n            explicitNode.detachFromParent();\n        }\n        compiler.reportCodeChange();\n    }\n}",
      "path": "src/com/google/javascript/jscomp/ProcessClosurePrimitives.java",
      "functionStartLine": 745,
      "functionName": "replace",
      "functionAnnotation": "",
      "functionDoc": "Replace the provide statement.\n\nIf we\u0027re providing a name with no definition, then create one.\nIf we\u0027re providing a name with a duplicate definition, then make sure\nthat definition becomes a declaration.\n",
      "diff": "@@ -1,37 +1,47 @@\n void replace() {\n     if (firstNode \u003d\u003d null) {\n+        replacementNode \u003d candidateDefinition;\n         return;\n     }\n     if (candidateDefinition !\u003d null \u0026\u0026 explicitNode !\u003d null) {\n         explicitNode.detachFromParent();\n         compiler.reportCodeChange();\n+        replacementNode \u003d candidateDefinition;\n         if (NodeUtil.isExpressionNode(candidateDefinition)) {\n             candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n             Node assignNode \u003d candidateDefinition.getFirstChild();\n             Node nameNode \u003d assignNode.getFirstChild();\n             if (nameNode.getType() \u003d\u003d Token.NAME) {\n                 Node valueNode \u003d nameNode.getNext();\n                 assignNode.removeChild(nameNode);\n                 assignNode.removeChild(valueNode);\n                 nameNode.addChildToFront(valueNode);\n                 Node varNode \u003d new Node(Token.VAR, nameNode);\n                 varNode.copyInformationFrom(candidateDefinition);\n                 candidateDefinition.getParent().replaceChild(candidateDefinition, varNode);\n                 nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n                 compiler.reportCodeChange();\n+                replacementNode \u003d varNode;\n             }\n         }\n     } else {\n-        Node declaration \u003d createDeclarationNode();\n-        if (explicitNode !\u003d firstNode) {\n-            firstNode.getParent().addChildBefore(declaration, firstNode);\n-            if (explicitNode !\u003d null) {\n-                explicitNode.detachFromParent();\n-            }\n+        replacementNode \u003d createDeclarationNode();\n+        if (firstModule \u003d\u003d minimumModule) {\n+            firstNode.getParent().addChildBefore(replacementNode, firstNode);\n         } else {\n-            Preconditions.checkNotNull(explicitNode);\n-            explicitNode.getParent().replaceChild(explicitNode, declaration);\n+            int indexOfDot \u003d namespace.indexOf(\u0027.\u0027);\n+            if (indexOfDot \u003d\u003d -1) {\n+                compiler.getNodeForCodeInsertion(minimumModule).addChildToBack(replacementNode);\n+            } else {\n+                ProvidedName parentName \u003d providedNames.get(namespace.substring(0, indexOfDot));\n+                Preconditions.checkNotNull(parentName);\n+                Preconditions.checkNotNull(parentName.replacementNode);\n+                parentName.replacementNode.getParent().addChildAfter(replacementNode, parentName.replacementNode);\n+            }\n+        }\n+        if (explicitNode !\u003d null) {\n+            explicitNode.detachFromParent();\n         }\n         compiler.reportCodeChange();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1046b0c09e2371f8924f72331d42db5b554c4a32": {
      "type": "Yintroduced",
      "commitMessage": "Rewrite ProcessClosurePrimitives to have a distinct indexing and mutation step.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@94 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "2/5/10, 11:27 AM",
      "commitName": "1046b0c09e2371f8924f72331d42db5b554c4a32",
      "commitAuthor": "Nicholas.J.Santos",
      "diff": "@@ -0,0 +1,37 @@\n+void replace() {\n+    if (firstNode \u003d\u003d null) {\n+        return;\n+    }\n+    if (candidateDefinition !\u003d null \u0026\u0026 explicitNode !\u003d null) {\n+        explicitNode.detachFromParent();\n+        compiler.reportCodeChange();\n+        if (NodeUtil.isExpressionNode(candidateDefinition)) {\n+            candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n+            Node assignNode \u003d candidateDefinition.getFirstChild();\n+            Node nameNode \u003d assignNode.getFirstChild();\n+            if (nameNode.getType() \u003d\u003d Token.NAME) {\n+                Node valueNode \u003d nameNode.getNext();\n+                assignNode.removeChild(nameNode);\n+                assignNode.removeChild(valueNode);\n+                nameNode.addChildToFront(valueNode);\n+                Node varNode \u003d new Node(Token.VAR, nameNode);\n+                varNode.copyInformationFrom(candidateDefinition);\n+                candidateDefinition.getParent().replaceChild(candidateDefinition, varNode);\n+                nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n+                compiler.reportCodeChange();\n+            }\n+        }\n+    } else {\n+        Node declaration \u003d createDeclarationNode();\n+        if (explicitNode !\u003d firstNode) {\n+            firstNode.getParent().addChildBefore(declaration, firstNode);\n+            if (explicitNode !\u003d null) {\n+                explicitNode.detachFromParent();\n+            }\n+        } else {\n+            Preconditions.checkNotNull(explicitNode);\n+            explicitNode.getParent().replaceChild(explicitNode, declaration);\n+        }\n+        compiler.reportCodeChange();\n+    }\n+}\n\\ No newline at end of file\n",
      "actualSource": "void replace() {\n    if (firstNode \u003d\u003d null) {\n        return;\n    }\n    if (candidateDefinition !\u003d null \u0026\u0026 explicitNode !\u003d null) {\n        explicitNode.detachFromParent();\n        compiler.reportCodeChange();\n        if (NodeUtil.isExpressionNode(candidateDefinition)) {\n            candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n            Node assignNode \u003d candidateDefinition.getFirstChild();\n            Node nameNode \u003d assignNode.getFirstChild();\n            if (nameNode.getType() \u003d\u003d Token.NAME) {\n                Node valueNode \u003d nameNode.getNext();\n                assignNode.removeChild(nameNode);\n                assignNode.removeChild(valueNode);\n                nameNode.addChildToFront(valueNode);\n                Node varNode \u003d new Node(Token.VAR, nameNode);\n                varNode.copyInformationFrom(candidateDefinition);\n                candidateDefinition.getParent().replaceChild(candidateDefinition, varNode);\n                nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n                compiler.reportCodeChange();\n            }\n        }\n    } else {\n        Node declaration \u003d createDeclarationNode();\n        if (explicitNode !\u003d firstNode) {\n            firstNode.getParent().addChildBefore(declaration, firstNode);\n            if (explicitNode !\u003d null) {\n                explicitNode.detachFromParent();\n            }\n        } else {\n            Preconditions.checkNotNull(explicitNode);\n            explicitNode.getParent().replaceChild(explicitNode, declaration);\n        }\n        compiler.reportCodeChange();\n    }\n}",
      "path": "src/com/google/javascript/jscomp/ProcessClosurePrimitives.java",
      "functionStartLine": 710,
      "functionName": "replace",
      "functionAnnotation": "",
      "functionDoc": "Replace the provide statement.\n\nIf we\u0027re providing a name with no definition, then create one.\nIf we\u0027re providing a name with a duplicate definition, then make sure\nthat definition becomes a declaration.\n"
    }
  }
}