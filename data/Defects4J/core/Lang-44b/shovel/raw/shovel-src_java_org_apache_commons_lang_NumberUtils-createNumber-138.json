{
  "origin": "codeshovel",
  "repositoryName": "Lang-44b",
  "repositoryPath": "/tmp/Lang-44b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "NumberUtils.java",
  "functionName": "createNumber",
  "functionId": "createNumber___val-String",
  "sourceFilePath": "src/java/org/apache/commons/lang/NumberUtils.java",
  "functionAnnotation": "",
  "functionDoc": "\u003cp\u003eTurns a string value into a java.lang.Number.\u003c/p\u003e\n\n\u003cp\u003eFirst, the value is examined for a type qualifier on the end\n(\u003ccode\u003e\u0027f\u0027,\u0027F\u0027,\u0027d\u0027,\u0027D\u0027,\u0027l\u0027,\u0027L\u0027\u003c/code\u003e).  If it is found, it starts \ntrying to create successively larger types from the type specified\nuntil one is found that can hold the value.\u003c/p\u003e\n\n\u003cp\u003eIf a type specifier is not found, it will check for a decimal point\nand then try successively larger types from \u003ccode\u003eInteger\u003c/code\u003e to\n\u003ccode\u003eBigInteger\u003c/code\u003e and from \u003ccode\u003eFloat\u003c/code\u003e to\n\u003ccode\u003eBigDecimal\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eIf the string starts with \u003ccode\u003e0x\u003c/code\u003e or \u003ccode\u003e-0x\u003c/code\u003e, it\nwill be interpreted as a hexadecimal integer.  Values with leading\n\u003ccode\u003e0\u003c/code\u003e\u0027s will not be interpreted as octal.\u003c/p\u003e\n\n@param val String containing a number\n@return Number created from the string\n@throws NumberFormatException if the value cannot be converted\n",
  "functionStartLine": 138,
  "functionEndLine": 286,
  "numCommitsSeen": 27,
  "timeTaken": 1567,
  "changeHistory": [
    "1fd45a4f68ea497dfbdf1a67b8b8805a4a9b1166",
    "f93aa9970a20d53e5db92196a4716b4550cb3042",
    "608c5159f2e6543809ce07432a51c0571c16bba0",
    "11ff5aa662b11ecdafe9c7d128f6e2211a234be3",
    "5c89ea5c8f8a5110b575f0b8dd511b6aecd19359",
    "30a5db352bf74d4f869f65cc320c63ccfd2f8cc7",
    "d23b22c78078ee7468e797e80188ae9508c0eee0"
  ],
  "changeHistoryShort": {
    "1fd45a4f68ea497dfbdf1a67b8b8805a4a9b1166": "Ybodychange",
    "f93aa9970a20d53e5db92196a4716b4550cb3042": "Ybodychange",
    "608c5159f2e6543809ce07432a51c0571c16bba0": "Ybodychange",
    "11ff5aa662b11ecdafe9c7d128f6e2211a234be3": "Ybodychange",
    "5c89ea5c8f8a5110b575f0b8dd511b6aecd19359": "Ymultichange(Ybodychange,Ydocchange)",
    "30a5db352bf74d4f869f65cc320c63ccfd2f8cc7": "Ydocchange",
    "d23b22c78078ee7468e797e80188ae9508c0eee0": "Yintroduced"
  },
  "changeHistoryDetails": {
    "1fd45a4f68ea497dfbdf1a67b8b8805a4a9b1166": {
      "type": "Ybodychange",
      "commitMessage": "Fixing LANG-300 (reported by Jeremy Lemaire) - 1L to 9L incorrectly throw exceptions when passed into NumberUtils.createNumber. Fixed in both the math.NumbersUtils and the deprecated NumberUtils classes. \n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@488819 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/19/06, 1:50 PM",
      "commitName": "1fd45a4f68ea497dfbdf1a67b8b8805a4a9b1166",
      "commitAuthor": "Henri Yandell",
      "commitDateOld": "11/5/06, 8:02 PM",
      "commitNameOld": "8a1148782c0db469ad9328b0fc1ea63ddba1714c",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 43.74,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "actualSource": "public static Number createNumber(String val) throws NumberFormatException {\n    if (val \u003d\u003d null) {\n        return null;\n    }\n    if (val.length() \u003d\u003d 0) {\n        throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n    }\n    if (val.startsWith(\"--\")) {\n        return null;\n    }\n    if (val.startsWith(\"0x\") || val.startsWith(\"-0x\")) {\n        return createInteger(val);\n    }\n    char lastChar \u003d val.charAt(val.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos \u003d val.indexOf(\u0027.\u0027);\n    int expPos \u003d val.indexOf(\u0027e\u0027) + val.indexOf(\u0027E\u0027) + 1;\n    if (decPos \u003e -1) {\n        if (expPos \u003e -1) {\n            if (expPos \u003c decPos) {\n                throw new NumberFormatException(val + \" is not a valid number.\");\n            }\n            dec \u003d val.substring(decPos + 1, expPos);\n        } else {\n            dec \u003d val.substring(decPos + 1);\n        }\n        mant \u003d val.substring(0, decPos);\n    } else {\n        if (expPos \u003e -1) {\n            mant \u003d val.substring(0, expPos);\n        } else {\n            mant \u003d val;\n        }\n        dec \u003d null;\n    }\n    if (!Character.isDigit(lastChar)) {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c val.length() - 1) {\n            exp \u003d val.substring(expPos + 1, val.length() - 1);\n        } else {\n            exp \u003d null;\n        }\n        String numeric \u003d val.substring(0, val.length() - 1);\n        boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n        switch(lastChar) {\n            case \u0027l\u0027:\n            case \u0027L\u0027:\n                if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (NumberFormatException nfe) {\n                    }\n                    return createBigInteger(numeric);\n                }\n                throw new NumberFormatException(val + \" is not a valid number.\");\n            case \u0027f\u0027:\n            case \u0027F\u0027:\n                try {\n                    Float f \u003d NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException e) {\n                }\n            case \u0027d\u0027:\n            case \u0027D\u0027:\n                try {\n                    Double d \u003d NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (NumberFormatException e) {\n                }\n            default:\n                throw new NumberFormatException(val + \" is not a valid number.\");\n        }\n    } else {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c val.length() - 1) {\n            exp \u003d val.substring(expPos + 1, val.length());\n        } else {\n            exp \u003d null;\n        }\n        if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n            try {\n                return createInteger(val);\n            } catch (NumberFormatException nfe) {\n            }\n            try {\n                return createLong(val);\n            } catch (NumberFormatException nfe) {\n            }\n            return createBigInteger(val);\n        } else {\n            boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n            try {\n                Float f \u003d createFloat(val);\n                if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                    return f;\n                }\n            } catch (NumberFormatException nfe) {\n            }\n            try {\n                Double d \u003d createDouble(val);\n                if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                    return d;\n                }\n            } catch (NumberFormatException nfe) {\n            }\n            return createBigDecimal(val);\n        }\n    }\n}",
      "path": "src/java/org/apache/commons/lang/NumberUtils.java",
      "functionStartLine": 138,
      "functionName": "createNumber",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eTurns a string value into a java.lang.Number.\u003c/p\u003e\n\n\u003cp\u003eFirst, the value is examined for a type qualifier on the end\n(\u003ccode\u003e\u0027f\u0027,\u0027F\u0027,\u0027d\u0027,\u0027D\u0027,\u0027l\u0027,\u0027L\u0027\u003c/code\u003e).  If it is found, it starts \ntrying to create successively larger types from the type specified\nuntil one is found that can hold the value.\u003c/p\u003e\n\n\u003cp\u003eIf a type specifier is not found, it will check for a decimal point\nand then try successively larger types from \u003ccode\u003eInteger\u003c/code\u003e to\n\u003ccode\u003eBigInteger\u003c/code\u003e and from \u003ccode\u003eFloat\u003c/code\u003e to\n\u003ccode\u003eBigDecimal\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eIf the string starts with \u003ccode\u003e0x\u003c/code\u003e or \u003ccode\u003e-0x\u003c/code\u003e, it\nwill be interpreted as a hexadecimal integer.  Values with leading\n\u003ccode\u003e0\u003c/code\u003e\u0027s will not be interpreted as octal.\u003c/p\u003e\n\n@param val String containing a number\n@return Number created from the string\n@throws NumberFormatException if the value cannot be converted\n",
      "diff": "@@ -1,117 +1,117 @@\n public static Number createNumber(String val) throws NumberFormatException {\n     if (val \u003d\u003d null) {\n         return null;\n     }\n     if (val.length() \u003d\u003d 0) {\n         throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n     }\n     if (val.startsWith(\"--\")) {\n         return null;\n     }\n     if (val.startsWith(\"0x\") || val.startsWith(\"-0x\")) {\n         return createInteger(val);\n     }\n     char lastChar \u003d val.charAt(val.length() - 1);\n     String mant;\n     String dec;\n     String exp;\n     int decPos \u003d val.indexOf(\u0027.\u0027);\n     int expPos \u003d val.indexOf(\u0027e\u0027) + val.indexOf(\u0027E\u0027) + 1;\n     if (decPos \u003e -1) {\n         if (expPos \u003e -1) {\n             if (expPos \u003c decPos) {\n                 throw new NumberFormatException(val + \" is not a valid number.\");\n             }\n             dec \u003d val.substring(decPos + 1, expPos);\n         } else {\n             dec \u003d val.substring(decPos + 1);\n         }\n         mant \u003d val.substring(0, decPos);\n     } else {\n         if (expPos \u003e -1) {\n             mant \u003d val.substring(0, expPos);\n         } else {\n             mant \u003d val;\n         }\n         dec \u003d null;\n     }\n     if (!Character.isDigit(lastChar)) {\n         if (expPos \u003e -1 \u0026\u0026 expPos \u003c val.length() - 1) {\n             exp \u003d val.substring(expPos + 1, val.length() - 1);\n         } else {\n             exp \u003d null;\n         }\n         String numeric \u003d val.substring(0, val.length() - 1);\n         boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n         switch(lastChar) {\n             case \u0027l\u0027:\n             case \u0027L\u0027:\n-                if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 isDigits(numeric.substring(1)) \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 || Character.isDigit(numeric.charAt(0)))) {\n+                if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 \u0026\u0026 isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                     try {\n                         return createLong(numeric);\n                     } catch (NumberFormatException nfe) {\n                     }\n                     return createBigInteger(numeric);\n                 }\n                 throw new NumberFormatException(val + \" is not a valid number.\");\n             case \u0027f\u0027:\n             case \u0027F\u0027:\n                 try {\n                     Float f \u003d NumberUtils.createFloat(numeric);\n                     if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                         return f;\n                     }\n                 } catch (NumberFormatException e) {\n                 }\n             case \u0027d\u0027:\n             case \u0027D\u0027:\n                 try {\n                     Double d \u003d NumberUtils.createDouble(numeric);\n                     if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                         return d;\n                     }\n                 } catch (NumberFormatException nfe) {\n                 }\n                 try {\n                     return createBigDecimal(numeric);\n                 } catch (NumberFormatException e) {\n                 }\n             default:\n                 throw new NumberFormatException(val + \" is not a valid number.\");\n         }\n     } else {\n         if (expPos \u003e -1 \u0026\u0026 expPos \u003c val.length() - 1) {\n             exp \u003d val.substring(expPos + 1, val.length());\n         } else {\n             exp \u003d null;\n         }\n         if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n             try {\n                 return createInteger(val);\n             } catch (NumberFormatException nfe) {\n             }\n             try {\n                 return createLong(val);\n             } catch (NumberFormatException nfe) {\n             }\n             return createBigInteger(val);\n         } else {\n             boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n             try {\n                 Float f \u003d createFloat(val);\n                 if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                     return f;\n                 }\n             } catch (NumberFormatException nfe) {\n             }\n             try {\n                 Double d \u003d createDouble(val);\n                 if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                     return d;\n                 }\n             } catch (NumberFormatException nfe) {\n             }\n             return createBigDecimal(val);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f93aa9970a20d53e5db92196a4716b4550cb3042": {
      "type": "Ybodychange",
      "commitMessage": "removed empty statement from catch block that takes no action, using comment only to denote no action\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@209371 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "7/5/05, 6:10 PM",
      "commitName": "f93aa9970a20d53e5db92196a4716b4550cb3042",
      "commitAuthor": "Steven Caswell",
      "commitDateOld": "6/27/05, 1:24 PM",
      "commitNameOld": "608c5159f2e6543809ce07432a51c0571c16bba0",
      "commitAuthorOld": "Steven Caswell",
      "daysBetweenCommits": 8.2,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "public static Number createNumber(String val) throws NumberFormatException {\n    if (val \u003d\u003d null) {\n        return null;\n    }\n    if (val.length() \u003d\u003d 0) {\n        throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n    }\n    if (val.startsWith(\"--\")) {\n        return null;\n    }\n    if (val.startsWith(\"0x\") || val.startsWith(\"-0x\")) {\n        return createInteger(val);\n    }\n    char lastChar \u003d val.charAt(val.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos \u003d val.indexOf(\u0027.\u0027);\n    int expPos \u003d val.indexOf(\u0027e\u0027) + val.indexOf(\u0027E\u0027) + 1;\n    if (decPos \u003e -1) {\n        if (expPos \u003e -1) {\n            if (expPos \u003c decPos) {\n                throw new NumberFormatException(val + \" is not a valid number.\");\n            }\n            dec \u003d val.substring(decPos + 1, expPos);\n        } else {\n            dec \u003d val.substring(decPos + 1);\n        }\n        mant \u003d val.substring(0, decPos);\n    } else {\n        if (expPos \u003e -1) {\n            mant \u003d val.substring(0, expPos);\n        } else {\n            mant \u003d val;\n        }\n        dec \u003d null;\n    }\n    if (!Character.isDigit(lastChar)) {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c val.length() - 1) {\n            exp \u003d val.substring(expPos + 1, val.length() - 1);\n        } else {\n            exp \u003d null;\n        }\n        String numeric \u003d val.substring(0, val.length() - 1);\n        boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n        switch(lastChar) {\n            case \u0027l\u0027:\n            case \u0027L\u0027:\n                if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 isDigits(numeric.substring(1)) \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 || Character.isDigit(numeric.charAt(0)))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (NumberFormatException nfe) {\n                    }\n                    return createBigInteger(numeric);\n                }\n                throw new NumberFormatException(val + \" is not a valid number.\");\n            case \u0027f\u0027:\n            case \u0027F\u0027:\n                try {\n                    Float f \u003d NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException e) {\n                }\n            case \u0027d\u0027:\n            case \u0027D\u0027:\n                try {\n                    Double d \u003d NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (NumberFormatException e) {\n                }\n            default:\n                throw new NumberFormatException(val + \" is not a valid number.\");\n        }\n    } else {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c val.length() - 1) {\n            exp \u003d val.substring(expPos + 1, val.length());\n        } else {\n            exp \u003d null;\n        }\n        if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n            try {\n                return createInteger(val);\n            } catch (NumberFormatException nfe) {\n            }\n            try {\n                return createLong(val);\n            } catch (NumberFormatException nfe) {\n            }\n            return createBigInteger(val);\n        } else {\n            boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n            try {\n                Float f \u003d createFloat(val);\n                if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                    return f;\n                }\n            } catch (NumberFormatException nfe) {\n            }\n            try {\n                Double d \u003d createDouble(val);\n                if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                    return d;\n                }\n            } catch (NumberFormatException nfe) {\n            }\n            return createBigDecimal(val);\n        }\n    }\n}",
      "path": "src/java/org/apache/commons/lang/NumberUtils.java",
      "functionStartLine": 138,
      "functionName": "createNumber",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eTurns a string value into a java.lang.Number.\u003c/p\u003e\n\n\u003cp\u003eFirst, the value is examined for a type qualifier on the end\n(\u003ccode\u003e\u0027f\u0027,\u0027F\u0027,\u0027d\u0027,\u0027D\u0027,\u0027l\u0027,\u0027L\u0027\u003c/code\u003e).  If it is found, it starts \ntrying to create successively larger types from the type specified\nuntil one is found that can hold the value.\u003c/p\u003e\n\n\u003cp\u003eIf a type specifier is not found, it will check for a decimal point\nand then try successively larger types from \u003ccode\u003eInteger\u003c/code\u003e to\n\u003ccode\u003eBigInteger\u003c/code\u003e and from \u003ccode\u003eFloat\u003c/code\u003e to\n\u003ccode\u003eBigDecimal\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eIf the string starts with \u003ccode\u003e0x\u003c/code\u003e or \u003ccode\u003e-0x\u003c/code\u003e, it\nwill be interpreted as a hexadecimal integer.  Values with leading\n\u003ccode\u003e0\u003c/code\u003e\u0027s will not be interpreted as octal.\u003c/p\u003e\n\n@param val String containing a number\n@return Number created from the string\n@throws NumberFormatException if the value cannot be converted\n",
      "diff": "@@ -1,125 +1,117 @@\n public static Number createNumber(String val) throws NumberFormatException {\n     if (val \u003d\u003d null) {\n         return null;\n     }\n     if (val.length() \u003d\u003d 0) {\n         throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n     }\n     if (val.startsWith(\"--\")) {\n         return null;\n     }\n     if (val.startsWith(\"0x\") || val.startsWith(\"-0x\")) {\n         return createInteger(val);\n     }\n     char lastChar \u003d val.charAt(val.length() - 1);\n     String mant;\n     String dec;\n     String exp;\n     int decPos \u003d val.indexOf(\u0027.\u0027);\n     int expPos \u003d val.indexOf(\u0027e\u0027) + val.indexOf(\u0027E\u0027) + 1;\n     if (decPos \u003e -1) {\n         if (expPos \u003e -1) {\n             if (expPos \u003c decPos) {\n                 throw new NumberFormatException(val + \" is not a valid number.\");\n             }\n             dec \u003d val.substring(decPos + 1, expPos);\n         } else {\n             dec \u003d val.substring(decPos + 1);\n         }\n         mant \u003d val.substring(0, decPos);\n     } else {\n         if (expPos \u003e -1) {\n             mant \u003d val.substring(0, expPos);\n         } else {\n             mant \u003d val;\n         }\n         dec \u003d null;\n     }\n     if (!Character.isDigit(lastChar)) {\n         if (expPos \u003e -1 \u0026\u0026 expPos \u003c val.length() - 1) {\n             exp \u003d val.substring(expPos + 1, val.length() - 1);\n         } else {\n             exp \u003d null;\n         }\n         String numeric \u003d val.substring(0, val.length() - 1);\n         boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n         switch(lastChar) {\n             case \u0027l\u0027:\n             case \u0027L\u0027:\n                 if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 isDigits(numeric.substring(1)) \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 || Character.isDigit(numeric.charAt(0)))) {\n                     try {\n                         return createLong(numeric);\n                     } catch (NumberFormatException nfe) {\n-                        ;\n                     }\n                     return createBigInteger(numeric);\n                 }\n                 throw new NumberFormatException(val + \" is not a valid number.\");\n             case \u0027f\u0027:\n             case \u0027F\u0027:\n                 try {\n                     Float f \u003d NumberUtils.createFloat(numeric);\n                     if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                         return f;\n                     }\n-                } catch (NumberFormatException nfe) {\n-                    ;\n+                } catch (NumberFormatException e) {\n                 }\n             case \u0027d\u0027:\n             case \u0027D\u0027:\n                 try {\n                     Double d \u003d NumberUtils.createDouble(numeric);\n                     if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                         return d;\n                     }\n                 } catch (NumberFormatException nfe) {\n-                    ;\n                 }\n                 try {\n                     return createBigDecimal(numeric);\n                 } catch (NumberFormatException e) {\n-                    ;\n                 }\n             default:\n                 throw new NumberFormatException(val + \" is not a valid number.\");\n         }\n     } else {\n         if (expPos \u003e -1 \u0026\u0026 expPos \u003c val.length() - 1) {\n             exp \u003d val.substring(expPos + 1, val.length());\n         } else {\n             exp \u003d null;\n         }\n         if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n             try {\n                 return createInteger(val);\n             } catch (NumberFormatException nfe) {\n-                ;\n             }\n             try {\n                 return createLong(val);\n             } catch (NumberFormatException nfe) {\n-                ;\n             }\n             return createBigInteger(val);\n         } else {\n             boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n             try {\n                 Float f \u003d createFloat(val);\n                 if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                     return f;\n                 }\n             } catch (NumberFormatException nfe) {\n-                ;\n             }\n             try {\n                 Double d \u003d createDouble(val);\n                 if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                     return d;\n                 }\n             } catch (NumberFormatException nfe) {\n-                ;\n             }\n             return createBigDecimal(val);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "608c5159f2e6543809ce07432a51c0571c16bba0": {
      "type": "Ybodychange",
      "commitMessage": "added empty statement to empty catch blocks\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@202043 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "6/27/05, 1:24 PM",
      "commitName": "608c5159f2e6543809ce07432a51c0571c16bba0",
      "commitAuthor": "Steven Caswell",
      "commitDateOld": "6/26/05, 5:54 PM",
      "commitNameOld": "de9bb803f62d8f5b3ccc352594da45245c3115ee",
      "commitAuthorOld": "Steven Caswell",
      "daysBetweenCommits": 0.81,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public static Number createNumber(String val) throws NumberFormatException {\n    if (val \u003d\u003d null) {\n        return null;\n    }\n    if (val.length() \u003d\u003d 0) {\n        throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n    }\n    if (val.startsWith(\"--\")) {\n        return null;\n    }\n    if (val.startsWith(\"0x\") || val.startsWith(\"-0x\")) {\n        return createInteger(val);\n    }\n    char lastChar \u003d val.charAt(val.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos \u003d val.indexOf(\u0027.\u0027);\n    int expPos \u003d val.indexOf(\u0027e\u0027) + val.indexOf(\u0027E\u0027) + 1;\n    if (decPos \u003e -1) {\n        if (expPos \u003e -1) {\n            if (expPos \u003c decPos) {\n                throw new NumberFormatException(val + \" is not a valid number.\");\n            }\n            dec \u003d val.substring(decPos + 1, expPos);\n        } else {\n            dec \u003d val.substring(decPos + 1);\n        }\n        mant \u003d val.substring(0, decPos);\n    } else {\n        if (expPos \u003e -1) {\n            mant \u003d val.substring(0, expPos);\n        } else {\n            mant \u003d val;\n        }\n        dec \u003d null;\n    }\n    if (!Character.isDigit(lastChar)) {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c val.length() - 1) {\n            exp \u003d val.substring(expPos + 1, val.length() - 1);\n        } else {\n            exp \u003d null;\n        }\n        String numeric \u003d val.substring(0, val.length() - 1);\n        boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n        switch(lastChar) {\n            case \u0027l\u0027:\n            case \u0027L\u0027:\n                if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 isDigits(numeric.substring(1)) \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 || Character.isDigit(numeric.charAt(0)))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (NumberFormatException nfe) {\n                        ;\n                    }\n                    return createBigInteger(numeric);\n                }\n                throw new NumberFormatException(val + \" is not a valid number.\");\n            case \u0027f\u0027:\n            case \u0027F\u0027:\n                try {\n                    Float f \u003d NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                    ;\n                }\n            case \u0027d\u0027:\n            case \u0027D\u0027:\n                try {\n                    Double d \u003d NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                    ;\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (NumberFormatException e) {\n                    ;\n                }\n            default:\n                throw new NumberFormatException(val + \" is not a valid number.\");\n        }\n    } else {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c val.length() - 1) {\n            exp \u003d val.substring(expPos + 1, val.length());\n        } else {\n            exp \u003d null;\n        }\n        if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n            try {\n                return createInteger(val);\n            } catch (NumberFormatException nfe) {\n                ;\n            }\n            try {\n                return createLong(val);\n            } catch (NumberFormatException nfe) {\n                ;\n            }\n            return createBigInteger(val);\n        } else {\n            boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n            try {\n                Float f \u003d createFloat(val);\n                if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                    return f;\n                }\n            } catch (NumberFormatException nfe) {\n                ;\n            }\n            try {\n                Double d \u003d createDouble(val);\n                if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                    return d;\n                }\n            } catch (NumberFormatException nfe) {\n                ;\n            }\n            return createBigDecimal(val);\n        }\n    }\n}",
      "path": "src/java/org/apache/commons/lang/NumberUtils.java",
      "functionStartLine": 138,
      "functionName": "createNumber",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eTurns a string value into a java.lang.Number.\u003c/p\u003e\n\n\u003cp\u003eFirst, the value is examined for a type qualifier on the end\n(\u003ccode\u003e\u0027f\u0027,\u0027F\u0027,\u0027d\u0027,\u0027D\u0027,\u0027l\u0027,\u0027L\u0027\u003c/code\u003e).  If it is found, it starts \ntrying to create successively larger types from the type specified\nuntil one is found that can hold the value.\u003c/p\u003e\n\n\u003cp\u003eIf a type specifier is not found, it will check for a decimal point\nand then try successively larger types from \u003ccode\u003eInteger\u003c/code\u003e to\n\u003ccode\u003eBigInteger\u003c/code\u003e and from \u003ccode\u003eFloat\u003c/code\u003e to\n\u003ccode\u003eBigDecimal\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eIf the string starts with \u003ccode\u003e0x\u003c/code\u003e or \u003ccode\u003e-0x\u003c/code\u003e, it\nwill be interpreted as a hexadecimal integer.  Values with leading\n\u003ccode\u003e0\u003c/code\u003e\u0027s will not be interpreted as octal.\u003c/p\u003e\n\n@param val String containing a number\n@return Number created from the string\n@throws NumberFormatException if the value cannot be converted\n",
      "diff": "@@ -1,124 +1,125 @@\n public static Number createNumber(String val) throws NumberFormatException {\n     if (val \u003d\u003d null) {\n         return null;\n     }\n     if (val.length() \u003d\u003d 0) {\n         throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n     }\n     if (val.startsWith(\"--\")) {\n         return null;\n     }\n     if (val.startsWith(\"0x\") || val.startsWith(\"-0x\")) {\n         return createInteger(val);\n     }\n     char lastChar \u003d val.charAt(val.length() - 1);\n     String mant;\n     String dec;\n     String exp;\n     int decPos \u003d val.indexOf(\u0027.\u0027);\n     int expPos \u003d val.indexOf(\u0027e\u0027) + val.indexOf(\u0027E\u0027) + 1;\n     if (decPos \u003e -1) {\n         if (expPos \u003e -1) {\n             if (expPos \u003c decPos) {\n                 throw new NumberFormatException(val + \" is not a valid number.\");\n             }\n             dec \u003d val.substring(decPos + 1, expPos);\n         } else {\n             dec \u003d val.substring(decPos + 1);\n         }\n         mant \u003d val.substring(0, decPos);\n     } else {\n         if (expPos \u003e -1) {\n             mant \u003d val.substring(0, expPos);\n         } else {\n             mant \u003d val;\n         }\n         dec \u003d null;\n     }\n     if (!Character.isDigit(lastChar)) {\n         if (expPos \u003e -1 \u0026\u0026 expPos \u003c val.length() - 1) {\n             exp \u003d val.substring(expPos + 1, val.length() - 1);\n         } else {\n             exp \u003d null;\n         }\n         String numeric \u003d val.substring(0, val.length() - 1);\n         boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n         switch(lastChar) {\n             case \u0027l\u0027:\n             case \u0027L\u0027:\n                 if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 isDigits(numeric.substring(1)) \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 || Character.isDigit(numeric.charAt(0)))) {\n                     try {\n                         return createLong(numeric);\n                     } catch (NumberFormatException nfe) {\n+                        ;\n                     }\n                     return createBigInteger(numeric);\n                 }\n                 throw new NumberFormatException(val + \" is not a valid number.\");\n             case \u0027f\u0027:\n             case \u0027F\u0027:\n                 try {\n                     Float f \u003d NumberUtils.createFloat(numeric);\n                     if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                         return f;\n                     }\n                 } catch (NumberFormatException nfe) {\n                     ;\n                 }\n             case \u0027d\u0027:\n             case \u0027D\u0027:\n                 try {\n                     Double d \u003d NumberUtils.createDouble(numeric);\n                     if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                         return d;\n                     }\n                 } catch (NumberFormatException nfe) {\n                     ;\n                 }\n                 try {\n                     return createBigDecimal(numeric);\n                 } catch (NumberFormatException e) {\n                     ;\n                 }\n             default:\n                 throw new NumberFormatException(val + \" is not a valid number.\");\n         }\n     } else {\n         if (expPos \u003e -1 \u0026\u0026 expPos \u003c val.length() - 1) {\n             exp \u003d val.substring(expPos + 1, val.length());\n         } else {\n             exp \u003d null;\n         }\n         if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n             try {\n                 return createInteger(val);\n             } catch (NumberFormatException nfe) {\n                 ;\n             }\n             try {\n                 return createLong(val);\n             } catch (NumberFormatException nfe) {\n                 ;\n             }\n             return createBigInteger(val);\n         } else {\n             boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n             try {\n                 Float f \u003d createFloat(val);\n                 if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                     return f;\n                 }\n             } catch (NumberFormatException nfe) {\n                 ;\n             }\n             try {\n                 Double d \u003d createDouble(val);\n                 if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                     return d;\n                 }\n             } catch (NumberFormatException nfe) {\n                 ;\n             }\n             return createBigDecimal(val);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "11ff5aa662b11ecdafe9c7d128f6e2211a234be3": {
      "type": "Ybodychange",
      "commitMessage": "corrected style issues (mostly empty blocks and missing javadocs)\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@201881 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "6/26/05, 10:42 AM",
      "commitName": "11ff5aa662b11ecdafe9c7d128f6e2211a234be3",
      "commitAuthor": "Steven Caswell",
      "commitDateOld": "4/13/05, 9:30 PM",
      "commitNameOld": "0bedaaebf88001d27d49ffa19ea3b234f496d88f",
      "commitAuthorOld": "Gary D. Gregory",
      "daysBetweenCommits": 73.55,
      "commitsBetweenForRepo": 60,
      "commitsBetweenForFile": 1,
      "actualSource": "public static Number createNumber(String val) throws NumberFormatException {\n    if (val \u003d\u003d null) {\n        return null;\n    }\n    if (val.length() \u003d\u003d 0) {\n        throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n    }\n    if (val.startsWith(\"--\")) {\n        return null;\n    }\n    if (val.startsWith(\"0x\") || val.startsWith(\"-0x\")) {\n        return createInteger(val);\n    }\n    char lastChar \u003d val.charAt(val.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos \u003d val.indexOf(\u0027.\u0027);\n    int expPos \u003d val.indexOf(\u0027e\u0027) + val.indexOf(\u0027E\u0027) + 1;\n    if (decPos \u003e -1) {\n        if (expPos \u003e -1) {\n            if (expPos \u003c decPos) {\n                throw new NumberFormatException(val + \" is not a valid number.\");\n            }\n            dec \u003d val.substring(decPos + 1, expPos);\n        } else {\n            dec \u003d val.substring(decPos + 1);\n        }\n        mant \u003d val.substring(0, decPos);\n    } else {\n        if (expPos \u003e -1) {\n            mant \u003d val.substring(0, expPos);\n        } else {\n            mant \u003d val;\n        }\n        dec \u003d null;\n    }\n    if (!Character.isDigit(lastChar)) {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c val.length() - 1) {\n            exp \u003d val.substring(expPos + 1, val.length() - 1);\n        } else {\n            exp \u003d null;\n        }\n        String numeric \u003d val.substring(0, val.length() - 1);\n        boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n        switch(lastChar) {\n            case \u0027l\u0027:\n            case \u0027L\u0027:\n                if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 isDigits(numeric.substring(1)) \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 || Character.isDigit(numeric.charAt(0)))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (NumberFormatException nfe) {\n                    }\n                    return createBigInteger(numeric);\n                }\n                throw new NumberFormatException(val + \" is not a valid number.\");\n            case \u0027f\u0027:\n            case \u0027F\u0027:\n                try {\n                    Float f \u003d NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                    ;\n                }\n            case \u0027d\u0027:\n            case \u0027D\u0027:\n                try {\n                    Double d \u003d NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                    ;\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (NumberFormatException e) {\n                    ;\n                }\n            default:\n                throw new NumberFormatException(val + \" is not a valid number.\");\n        }\n    } else {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c val.length() - 1) {\n            exp \u003d val.substring(expPos + 1, val.length());\n        } else {\n            exp \u003d null;\n        }\n        if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n            try {\n                return createInteger(val);\n            } catch (NumberFormatException nfe) {\n                ;\n            }\n            try {\n                return createLong(val);\n            } catch (NumberFormatException nfe) {\n                ;\n            }\n            return createBigInteger(val);\n        } else {\n            boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n            try {\n                Float f \u003d createFloat(val);\n                if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                    return f;\n                }\n            } catch (NumberFormatException nfe) {\n                ;\n            }\n            try {\n                Double d \u003d createDouble(val);\n                if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                    return d;\n                }\n            } catch (NumberFormatException nfe) {\n                ;\n            }\n            return createBigDecimal(val);\n        }\n    }\n}",
      "path": "src/java/org/apache/commons/lang/NumberUtils.java",
      "functionStartLine": 138,
      "functionName": "createNumber",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eTurns a string value into a java.lang.Number.\u003c/p\u003e\n\n\u003cp\u003eFirst, the value is examined for a type qualifier on the end\n(\u003ccode\u003e\u0027f\u0027,\u0027F\u0027,\u0027d\u0027,\u0027D\u0027,\u0027l\u0027,\u0027L\u0027\u003c/code\u003e).  If it is found, it starts \ntrying to create successively larger types from the type specified\nuntil one is found that can hold the value.\u003c/p\u003e\n\n\u003cp\u003eIf a type specifier is not found, it will check for a decimal point\nand then try successively larger types from \u003ccode\u003eInteger\u003c/code\u003e to\n\u003ccode\u003eBigInteger\u003c/code\u003e and from \u003ccode\u003eFloat\u003c/code\u003e to\n\u003ccode\u003eBigDecimal\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eIf the string starts with \u003ccode\u003e0x\u003c/code\u003e or \u003ccode\u003e-0x\u003c/code\u003e, it\nwill be interpreted as a hexadecimal integer.  Values with leading\n\u003ccode\u003e0\u003c/code\u003e\u0027s will not be interpreted as octal.\u003c/p\u003e\n\n@param val String containing a number\n@return Number created from the string\n@throws NumberFormatException if the value cannot be converted\n",
      "diff": "@@ -1,117 +1,124 @@\n public static Number createNumber(String val) throws NumberFormatException {\n     if (val \u003d\u003d null) {\n         return null;\n     }\n     if (val.length() \u003d\u003d 0) {\n         throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n     }\n     if (val.startsWith(\"--\")) {\n         return null;\n     }\n     if (val.startsWith(\"0x\") || val.startsWith(\"-0x\")) {\n         return createInteger(val);\n     }\n     char lastChar \u003d val.charAt(val.length() - 1);\n     String mant;\n     String dec;\n     String exp;\n     int decPos \u003d val.indexOf(\u0027.\u0027);\n     int expPos \u003d val.indexOf(\u0027e\u0027) + val.indexOf(\u0027E\u0027) + 1;\n     if (decPos \u003e -1) {\n         if (expPos \u003e -1) {\n             if (expPos \u003c decPos) {\n                 throw new NumberFormatException(val + \" is not a valid number.\");\n             }\n             dec \u003d val.substring(decPos + 1, expPos);\n         } else {\n             dec \u003d val.substring(decPos + 1);\n         }\n         mant \u003d val.substring(0, decPos);\n     } else {\n         if (expPos \u003e -1) {\n             mant \u003d val.substring(0, expPos);\n         } else {\n             mant \u003d val;\n         }\n         dec \u003d null;\n     }\n     if (!Character.isDigit(lastChar)) {\n         if (expPos \u003e -1 \u0026\u0026 expPos \u003c val.length() - 1) {\n             exp \u003d val.substring(expPos + 1, val.length() - 1);\n         } else {\n             exp \u003d null;\n         }\n         String numeric \u003d val.substring(0, val.length() - 1);\n         boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n         switch(lastChar) {\n             case \u0027l\u0027:\n             case \u0027L\u0027:\n                 if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 isDigits(numeric.substring(1)) \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 || Character.isDigit(numeric.charAt(0)))) {\n                     try {\n                         return createLong(numeric);\n                     } catch (NumberFormatException nfe) {\n                     }\n                     return createBigInteger(numeric);\n                 }\n                 throw new NumberFormatException(val + \" is not a valid number.\");\n             case \u0027f\u0027:\n             case \u0027F\u0027:\n                 try {\n                     Float f \u003d NumberUtils.createFloat(numeric);\n                     if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                         return f;\n                     }\n                 } catch (NumberFormatException nfe) {\n+                    ;\n                 }\n             case \u0027d\u0027:\n             case \u0027D\u0027:\n                 try {\n                     Double d \u003d NumberUtils.createDouble(numeric);\n                     if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                         return d;\n                     }\n                 } catch (NumberFormatException nfe) {\n+                    ;\n                 }\n                 try {\n                     return createBigDecimal(numeric);\n                 } catch (NumberFormatException e) {\n+                    ;\n                 }\n             default:\n                 throw new NumberFormatException(val + \" is not a valid number.\");\n         }\n     } else {\n         if (expPos \u003e -1 \u0026\u0026 expPos \u003c val.length() - 1) {\n             exp \u003d val.substring(expPos + 1, val.length());\n         } else {\n             exp \u003d null;\n         }\n         if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n             try {\n                 return createInteger(val);\n             } catch (NumberFormatException nfe) {\n+                ;\n             }\n             try {\n                 return createLong(val);\n             } catch (NumberFormatException nfe) {\n+                ;\n             }\n             return createBigInteger(val);\n         } else {\n             boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n             try {\n                 Float f \u003d createFloat(val);\n                 if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                     return f;\n                 }\n             } catch (NumberFormatException nfe) {\n+                ;\n             }\n             try {\n                 Double d \u003d createDouble(val);\n                 if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                     return d;\n                 }\n             } catch (NumberFormatException nfe) {\n+                ;\n             }\n             return createBigDecimal(val);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5c89ea5c8f8a5110b575f0b8dd511b6aecd19359": {
      "type": "Ymultichange(Ybodychange,Ydocchange)",
      "commitMessage": "Fixed typos in javadoc and some inline comments.\nPr #22908.\nPatch submitted by Janek Bogucki.\nReviewed by Phil Steitz.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137666 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "9/7/03, 7:32 AM",
      "commitName": "5c89ea5c8f8a5110b575f0b8dd511b6aecd19359",
      "commitAuthor": "Phil Steitz",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "Fixed typos in javadoc and some inline comments.\nPr #22908.\nPatch submitted by Janek Bogucki.\nReviewed by Phil Steitz.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137666 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "9/7/03, 7:32 AM",
          "commitName": "5c89ea5c8f8a5110b575f0b8dd511b6aecd19359",
          "commitAuthor": "Phil Steitz",
          "commitDateOld": "8/17/03, 7:22 PM",
          "commitNameOld": "d643ab9ff3728a441e74e3dc8c8fb0fa57a567f0",
          "commitAuthorOld": "Henri Yandell",
          "daysBetweenCommits": 20.51,
          "commitsBetweenForRepo": 39,
          "commitsBetweenForFile": 1,
          "actualSource": "public static Number createNumber(String val) throws NumberFormatException {\n    if (val \u003d\u003d null) {\n        return null;\n    }\n    if (val.length() \u003d\u003d 0) {\n        throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n    }\n    if (val.startsWith(\"--\")) {\n        return null;\n    }\n    if (val.startsWith(\"0x\") || val.startsWith(\"-0x\")) {\n        return createInteger(val);\n    }\n    char lastChar \u003d val.charAt(val.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos \u003d val.indexOf(\u0027.\u0027);\n    int expPos \u003d val.indexOf(\u0027e\u0027) + val.indexOf(\u0027E\u0027) + 1;\n    if (decPos \u003e -1) {\n        if (expPos \u003e -1) {\n            if (expPos \u003c decPos) {\n                throw new NumberFormatException(val + \" is not a valid number.\");\n            }\n            dec \u003d val.substring(decPos + 1, expPos);\n        } else {\n            dec \u003d val.substring(decPos + 1);\n        }\n        mant \u003d val.substring(0, decPos);\n    } else {\n        if (expPos \u003e -1) {\n            mant \u003d val.substring(0, expPos);\n        } else {\n            mant \u003d val;\n        }\n        dec \u003d null;\n    }\n    if (!Character.isDigit(lastChar)) {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c val.length() - 1) {\n            exp \u003d val.substring(expPos + 1, val.length() - 1);\n        } else {\n            exp \u003d null;\n        }\n        String numeric \u003d val.substring(0, val.length() - 1);\n        boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n        switch(lastChar) {\n            case \u0027l\u0027:\n            case \u0027L\u0027:\n                if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 isDigits(numeric.substring(1)) \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 || Character.isDigit(numeric.charAt(0)))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (NumberFormatException nfe) {\n                    }\n                    return createBigInteger(numeric);\n                }\n                throw new NumberFormatException(val + \" is not a valid number.\");\n            case \u0027f\u0027:\n            case \u0027F\u0027:\n                try {\n                    Float f \u003d NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n            case \u0027d\u0027:\n            case \u0027D\u0027:\n                try {\n                    Double d \u003d NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (NumberFormatException e) {\n                }\n            default:\n                throw new NumberFormatException(val + \" is not a valid number.\");\n        }\n    } else {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c val.length() - 1) {\n            exp \u003d val.substring(expPos + 1, val.length());\n        } else {\n            exp \u003d null;\n        }\n        if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n            try {\n                return createInteger(val);\n            } catch (NumberFormatException nfe) {\n            }\n            try {\n                return createLong(val);\n            } catch (NumberFormatException nfe) {\n            }\n            return createBigInteger(val);\n        } else {\n            boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n            try {\n                Float f \u003d createFloat(val);\n                if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                    return f;\n                }\n            } catch (NumberFormatException nfe) {\n            }\n            try {\n                Double d \u003d createDouble(val);\n                if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                    return d;\n                }\n            } catch (NumberFormatException nfe) {\n            }\n            return createBigDecimal(val);\n        }\n    }\n}",
          "path": "src/java/org/apache/commons/lang/NumberUtils.java",
          "functionStartLine": 175,
          "functionName": "createNumber",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003eTurns a string value into a java.lang.Number.\u003c/p\u003e\n\n\u003cp\u003eFirst, the value is examined for a type qualifier on the end\n(\u003ccode\u003e\u0027f\u0027,\u0027F\u0027,\u0027d\u0027,\u0027D\u0027,\u0027l\u0027,\u0027L\u0027\u003c/code\u003e).  If it is found, it starts \ntrying to create successively larger types from the type specified\nuntil one is found that can hold the value.\u003c/p\u003e\n\n\u003cp\u003eIf a type specifier is not found, it will check for a decimal point\nand then try successively larger types from \u003ccode\u003eInteger\u003c/code\u003e to\n\u003ccode\u003eBigInteger\u003c/code\u003e and from \u003ccode\u003eFloat\u003c/code\u003e to\n\u003ccode\u003eBigDecimal\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eIf the string starts with \u003ccode\u003e0x\u003c/code\u003e or \u003ccode\u003e-0x\u003c/code\u003e, it\nwill be interpreted as a hexadecimal integer.  Values with leading\n\u003ccode\u003e0\u003c/code\u003e\u0027s will not be interpreted as octal.\u003c/p\u003e\n\n@param val String containing a number\n@return Number created from the string\n@throws NumberFormatException if the value cannot be converted\n",
          "diff": "",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Fixed typos in javadoc and some inline comments.\nPr #22908.\nPatch submitted by Janek Bogucki.\nReviewed by Phil Steitz.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137666 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "9/7/03, 7:32 AM",
          "commitName": "5c89ea5c8f8a5110b575f0b8dd511b6aecd19359",
          "commitAuthor": "Phil Steitz",
          "commitDateOld": "8/17/03, 7:22 PM",
          "commitNameOld": "d643ab9ff3728a441e74e3dc8c8fb0fa57a567f0",
          "commitAuthorOld": "Henri Yandell",
          "daysBetweenCommits": 20.51,
          "commitsBetweenForRepo": 39,
          "commitsBetweenForFile": 1,
          "actualSource": "public static Number createNumber(String val) throws NumberFormatException {\n    if (val \u003d\u003d null) {\n        return null;\n    }\n    if (val.length() \u003d\u003d 0) {\n        throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n    }\n    if (val.startsWith(\"--\")) {\n        return null;\n    }\n    if (val.startsWith(\"0x\") || val.startsWith(\"-0x\")) {\n        return createInteger(val);\n    }\n    char lastChar \u003d val.charAt(val.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos \u003d val.indexOf(\u0027.\u0027);\n    int expPos \u003d val.indexOf(\u0027e\u0027) + val.indexOf(\u0027E\u0027) + 1;\n    if (decPos \u003e -1) {\n        if (expPos \u003e -1) {\n            if (expPos \u003c decPos) {\n                throw new NumberFormatException(val + \" is not a valid number.\");\n            }\n            dec \u003d val.substring(decPos + 1, expPos);\n        } else {\n            dec \u003d val.substring(decPos + 1);\n        }\n        mant \u003d val.substring(0, decPos);\n    } else {\n        if (expPos \u003e -1) {\n            mant \u003d val.substring(0, expPos);\n        } else {\n            mant \u003d val;\n        }\n        dec \u003d null;\n    }\n    if (!Character.isDigit(lastChar)) {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c val.length() - 1) {\n            exp \u003d val.substring(expPos + 1, val.length() - 1);\n        } else {\n            exp \u003d null;\n        }\n        String numeric \u003d val.substring(0, val.length() - 1);\n        boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n        switch(lastChar) {\n            case \u0027l\u0027:\n            case \u0027L\u0027:\n                if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 isDigits(numeric.substring(1)) \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 || Character.isDigit(numeric.charAt(0)))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (NumberFormatException nfe) {\n                    }\n                    return createBigInteger(numeric);\n                }\n                throw new NumberFormatException(val + \" is not a valid number.\");\n            case \u0027f\u0027:\n            case \u0027F\u0027:\n                try {\n                    Float f \u003d NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n            case \u0027d\u0027:\n            case \u0027D\u0027:\n                try {\n                    Double d \u003d NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (NumberFormatException e) {\n                }\n            default:\n                throw new NumberFormatException(val + \" is not a valid number.\");\n        }\n    } else {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c val.length() - 1) {\n            exp \u003d val.substring(expPos + 1, val.length());\n        } else {\n            exp \u003d null;\n        }\n        if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n            try {\n                return createInteger(val);\n            } catch (NumberFormatException nfe) {\n            }\n            try {\n                return createLong(val);\n            } catch (NumberFormatException nfe) {\n            }\n            return createBigInteger(val);\n        } else {\n            boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n            try {\n                Float f \u003d createFloat(val);\n                if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                    return f;\n                }\n            } catch (NumberFormatException nfe) {\n            }\n            try {\n                Double d \u003d createDouble(val);\n                if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                    return d;\n                }\n            } catch (NumberFormatException nfe) {\n            }\n            return createBigDecimal(val);\n        }\n    }\n}",
          "path": "src/java/org/apache/commons/lang/NumberUtils.java",
          "functionStartLine": 175,
          "functionName": "createNumber",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003eTurns a string value into a java.lang.Number.\u003c/p\u003e\n\n\u003cp\u003eFirst, the value is examined for a type qualifier on the end\n(\u003ccode\u003e\u0027f\u0027,\u0027F\u0027,\u0027d\u0027,\u0027D\u0027,\u0027l\u0027,\u0027L\u0027\u003c/code\u003e).  If it is found, it starts \ntrying to create successively larger types from the type specified\nuntil one is found that can hold the value.\u003c/p\u003e\n\n\u003cp\u003eIf a type specifier is not found, it will check for a decimal point\nand then try successively larger types from \u003ccode\u003eInteger\u003c/code\u003e to\n\u003ccode\u003eBigInteger\u003c/code\u003e and from \u003ccode\u003eFloat\u003c/code\u003e to\n\u003ccode\u003eBigDecimal\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eIf the string starts with \u003ccode\u003e0x\u003c/code\u003e or \u003ccode\u003e-0x\u003c/code\u003e, it\nwill be interpreted as a hexadecimal integer.  Values with leading\n\u003ccode\u003e0\u003c/code\u003e\u0027s will not be interpreted as octal.\u003c/p\u003e\n\n@param val String containing a number\n@return Number created from the string\n@throws NumberFormatException if the value cannot be converted\n",
          "diff": "",
          "extendedDetails": {
            "oldValue": "\u003cp\u003eTurns a string value into a java.lang.Number.\u003c/p\u003e\n\n\u003cp\u003eFirst, the value is examined for a type qualifier on the end\n(\u003ccode\u003e\u0027f\u0027,\u0027F\u0027,\u0027d\u0027,\u0027D\u0027,\u0027l\u0027,\u0027L\u0027\u003c/code\u003e).  If it is found, it starts \ntrying to create succissively larger types from the type specified\nuntil one is found that can hold the value.\u003c/p\u003e\n\n\u003cp\u003eIf a type specifier is not found, it will check for a decimal point\nand then try successively larger types from \u003ccode\u003eInteger\u003c/code\u003e to\n\u003ccode\u003eBigInteger\u003c/code\u003e and from \u003ccode\u003eFloat\u003c/code\u003e to\n\u003ccode\u003eBigDecimal\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eIf the string starts with \u003ccode\u003e0x\u003c/code\u003e or \u003ccode\u003e-0x\u003c/code\u003e, it\nwill be interpreted as a hexadecimal integer.  Values with leading\n\u003ccode\u003e0\u003c/code\u003e\u0027s will not be interpreted as octal.\u003c/p\u003e\n\n@param val String containing a number\n@return Number created from the string\n@throws NumberFormatException if the value cannot be converted\n",
            "newValue": "\u003cp\u003eTurns a string value into a java.lang.Number.\u003c/p\u003e\n\n\u003cp\u003eFirst, the value is examined for a type qualifier on the end\n(\u003ccode\u003e\u0027f\u0027,\u0027F\u0027,\u0027d\u0027,\u0027D\u0027,\u0027l\u0027,\u0027L\u0027\u003c/code\u003e).  If it is found, it starts \ntrying to create successively larger types from the type specified\nuntil one is found that can hold the value.\u003c/p\u003e\n\n\u003cp\u003eIf a type specifier is not found, it will check for a decimal point\nand then try successively larger types from \u003ccode\u003eInteger\u003c/code\u003e to\n\u003ccode\u003eBigInteger\u003c/code\u003e and from \u003ccode\u003eFloat\u003c/code\u003e to\n\u003ccode\u003eBigDecimal\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eIf the string starts with \u003ccode\u003e0x\u003c/code\u003e or \u003ccode\u003e-0x\u003c/code\u003e, it\nwill be interpreted as a hexadecimal integer.  Values with leading\n\u003ccode\u003e0\u003c/code\u003e\u0027s will not be interpreted as octal.\u003c/p\u003e\n\n@param val String containing a number\n@return Number created from the string\n@throws NumberFormatException if the value cannot be converted\n"
          }
        }
      ]
    },
    "30a5db352bf74d4f869f65cc320c63ccfd2f8cc7": {
      "type": "Ydocchange",
      "commitMessage": "Javadoc formatting patch, by Fredrik Westermarck\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137133 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/16/02, 2:41 AM",
      "commitName": "30a5db352bf74d4f869f65cc320c63ccfd2f8cc7",
      "commitAuthor": "Stephen Colebourne",
      "commitDateOld": "9/28/02, 3:34 AM",
      "commitNameOld": "a97291db617c65c90564618ca4cdca91ed07db53",
      "commitAuthorOld": "Stephen Colebourne",
      "daysBetweenCommits": 49.0,
      "commitsBetweenForRepo": 60,
      "commitsBetweenForFile": 1,
      "actualSource": "public static Number createNumber(String val) throws NumberFormatException {\n    if (val \u003d\u003d null) {\n        return null;\n    }\n    if (val.length() \u003d\u003d 0) {\n        throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n    }\n    if (val.startsWith(\"--\")) {\n        return null;\n    }\n    if (val.startsWith(\"0x\") || val.startsWith(\"-0x\")) {\n        return createInteger(val);\n    }\n    char lastChar \u003d val.charAt(val.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos \u003d val.indexOf(\u0027.\u0027);\n    int expPos \u003d val.indexOf(\u0027e\u0027) + val.indexOf(\u0027E\u0027) + 1;\n    if (decPos \u003e -1) {\n        if (expPos \u003e -1) {\n            if (expPos \u003c decPos) {\n                throw new NumberFormatException(val + \" is not a valid number.\");\n            }\n            dec \u003d val.substring(decPos + 1, expPos);\n        } else {\n            dec \u003d val.substring(decPos + 1);\n        }\n        mant \u003d val.substring(0, decPos);\n    } else {\n        if (expPos \u003e -1) {\n            mant \u003d val.substring(0, expPos);\n        } else {\n            mant \u003d val;\n        }\n        dec \u003d null;\n    }\n    if (!Character.isDigit(lastChar)) {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c val.length() - 1) {\n            exp \u003d val.substring(expPos + 1, val.length() - 1);\n        } else {\n            exp \u003d null;\n        }\n        String numeric \u003d val.substring(0, val.length() - 1);\n        boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n        switch(lastChar) {\n            case \u0027l\u0027:\n            case \u0027L\u0027:\n                if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 isDigits(numeric.substring(1)) \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 || Character.isDigit(numeric.charAt(0)))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (NumberFormatException nfe) {\n                    }\n                    return createBigInteger(numeric);\n                }\n                throw new NumberFormatException(val + \" is not a valid number.\");\n            case \u0027f\u0027:\n            case \u0027F\u0027:\n                try {\n                    Float f \u003d NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n            case \u0027d\u0027:\n            case \u0027D\u0027:\n                try {\n                    Double d \u003d NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (NumberFormatException e) {\n                }\n            default:\n                throw new NumberFormatException(val + \" is not a valid number.\");\n        }\n    } else {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c val.length() - 1) {\n            exp \u003d val.substring(expPos + 1, val.length());\n        } else {\n            exp \u003d null;\n        }\n        if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n            try {\n                return createInteger(val);\n            } catch (NumberFormatException nfe) {\n            }\n            try {\n                return createLong(val);\n            } catch (NumberFormatException nfe) {\n            }\n            return createBigInteger(val);\n        } else {\n            boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n            try {\n                Float f \u003d createFloat(val);\n                if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                    return f;\n                }\n            } catch (NumberFormatException nfe) {\n            }\n            try {\n                Double d \u003d createDouble(val);\n                if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                    return d;\n                }\n            } catch (NumberFormatException nfe) {\n            }\n            return createBigDecimal(val);\n        }\n    }\n}",
      "path": "src/java/org/apache/commons/lang/NumberUtils.java",
      "functionStartLine": 168,
      "functionName": "createNumber",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eTurns a string value into a java.lang.Number.\u003c/p\u003e\n\n\u003cp\u003eFirst, the value is examined for a type qualifier on the end\n(\u003ccode\u003e\u0027f\u0027,\u0027F\u0027,\u0027d\u0027,\u0027D\u0027,\u0027l\u0027,\u0027L\u0027\u003c/code\u003e).  If it is found, it starts \ntrying to create succissively larger types from the type specified\nuntil one is found that can hold the value.\u003c/p\u003e\n\n\u003cp\u003eIf a type specifier is not found, it will check for a decimal point\nand then try successively larger types from \u003ccode\u003eInteger\u003c/code\u003e to\n\u003ccode\u003eBigInteger\u003c/code\u003e and from \u003ccode\u003eFloat\u003c/code\u003e to\n\u003ccode\u003eBigDecimal\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eIf the string starts with \u003ccode\u003e0x\u003c/code\u003e or \u003ccode\u003e-0x\u003c/code\u003e, it\nwill be interpreted as a hexadecimal integer.  Values with leading\n\u003ccode\u003e0\u003c/code\u003e\u0027s will not be interpreted as octal.\u003c/p\u003e\n\n@param val String containing a number\n@return Number created from the string\n@throws NumberFormatException if the value cannot be converted\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "\u003cp\u003e\nTurns a string value into a java.lang.Number.\nFirst, the value is examined for a type qualifier on the end \n(\u003ccode\u003e\u0027f\u0027,\u0027F\u0027,\u0027d\u0027,\u0027D\u0027,\u0027l\u0027,\u0027L\u0027\u003c/code\u003e).  If it is found, it starts \ntrying to create succissively larger types from the type specified\nuntil one is found that can hold the value.\n\u003c/p\u003e\n\u003cp\u003e\nIf a type specifier is not found, it will check for a decimal point\nand then try successively larger types from Integer to BigInteger \nand from Float to BigDecimal.\n\u003c/p\u003e\n\u003cp\u003e\nIf the string starts with \"0x\" or \"-0x\", it will be interpreted as a \nhexadecimal integer.  Values with leading 0\u0027s will not be interpreted \nas octal.\n\u003c/p\u003e\n\n@param val String containing a number\n@return Number created from the string\n@throws NumberFormatException if the value cannot be converted\n",
        "newValue": "\u003cp\u003eTurns a string value into a java.lang.Number.\u003c/p\u003e\n\n\u003cp\u003eFirst, the value is examined for a type qualifier on the end\n(\u003ccode\u003e\u0027f\u0027,\u0027F\u0027,\u0027d\u0027,\u0027D\u0027,\u0027l\u0027,\u0027L\u0027\u003c/code\u003e).  If it is found, it starts \ntrying to create succissively larger types from the type specified\nuntil one is found that can hold the value.\u003c/p\u003e\n\n\u003cp\u003eIf a type specifier is not found, it will check for a decimal point\nand then try successively larger types from \u003ccode\u003eInteger\u003c/code\u003e to\n\u003ccode\u003eBigInteger\u003c/code\u003e and from \u003ccode\u003eFloat\u003c/code\u003e to\n\u003ccode\u003eBigDecimal\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eIf the string starts with \u003ccode\u003e0x\u003c/code\u003e or \u003ccode\u003e-0x\u003c/code\u003e, it\nwill be interpreted as a hexadecimal integer.  Values with leading\n\u003ccode\u003e0\u003c/code\u003e\u0027s will not be interpreted as octal.\u003c/p\u003e\n\n@param val String containing a number\n@return Number created from the string\n@throws NumberFormatException if the value cannot be converted\n"
      }
    },
    "d23b22c78078ee7468e797e80188ae9508c0eee0": {
      "type": "Yintroduced",
      "commitMessage": "Initial copy from jakarta-commons-sandbox\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@136932 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "7/18/02, 8:35 PM",
      "commitName": "d23b22c78078ee7468e797e80188ae9508c0eee0",
      "commitAuthor": "Henri Yandell",
      "diff": "@@ -0,0 +1,117 @@\n+public static Number createNumber(String val) throws NumberFormatException {\n+    if (val \u003d\u003d null) {\n+        return null;\n+    }\n+    if (val.length() \u003d\u003d 0) {\n+        throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n+    }\n+    if (val.startsWith(\"--\")) {\n+        return null;\n+    }\n+    if (val.startsWith(\"0x\") || val.startsWith(\"-0x\")) {\n+        return createInteger(val);\n+    }\n+    char lastChar \u003d val.charAt(val.length() - 1);\n+    String mant;\n+    String dec;\n+    String exp;\n+    int decPos \u003d val.indexOf(\u0027.\u0027);\n+    int expPos \u003d val.indexOf(\u0027e\u0027) + val.indexOf(\u0027E\u0027) + 1;\n+    if (decPos \u003e -1) {\n+        if (expPos \u003e -1) {\n+            if (expPos \u003c decPos) {\n+                throw new NumberFormatException(val + \" is not a valid number.\");\n+            }\n+            dec \u003d val.substring(decPos + 1, expPos);\n+        } else {\n+            dec \u003d val.substring(decPos + 1);\n+        }\n+        mant \u003d val.substring(0, decPos);\n+    } else {\n+        if (expPos \u003e -1) {\n+            mant \u003d val.substring(0, expPos);\n+        } else {\n+            mant \u003d val;\n+        }\n+        dec \u003d null;\n+    }\n+    if (!Character.isDigit(lastChar)) {\n+        if (expPos \u003e -1 \u0026\u0026 expPos \u003c val.length() - 1) {\n+            exp \u003d val.substring(expPos + 1, val.length() - 1);\n+        } else {\n+            exp \u003d null;\n+        }\n+        String numeric \u003d val.substring(0, val.length() - 1);\n+        boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n+        switch(lastChar) {\n+            case \u0027l\u0027:\n+            case \u0027L\u0027:\n+                if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 isDigits(numeric.substring(1)) \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 || Character.isDigit(numeric.charAt(0)))) {\n+                    try {\n+                        return createLong(numeric);\n+                    } catch (NumberFormatException nfe) {\n+                    }\n+                    return createBigInteger(numeric);\n+                }\n+                throw new NumberFormatException(val + \" is not a valid number.\");\n+            case \u0027f\u0027:\n+            case \u0027F\u0027:\n+                try {\n+                    Float f \u003d NumberUtils.createFloat(numeric);\n+                    if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n+                        return f;\n+                    }\n+                } catch (NumberFormatException nfe) {\n+                }\n+            case \u0027d\u0027:\n+            case \u0027D\u0027:\n+                try {\n+                    Double d \u003d NumberUtils.createDouble(numeric);\n+                    if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n+                        return d;\n+                    }\n+                } catch (NumberFormatException nfe) {\n+                }\n+                try {\n+                    return createBigDecimal(numeric);\n+                } catch (NumberFormatException e) {\n+                }\n+            default:\n+                throw new NumberFormatException(val + \" is not a valid number.\");\n+        }\n+    } else {\n+        if (expPos \u003e -1 \u0026\u0026 expPos \u003c val.length() - 1) {\n+            exp \u003d val.substring(expPos + 1, val.length());\n+        } else {\n+            exp \u003d null;\n+        }\n+        if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n+            try {\n+                return createInteger(val);\n+            } catch (NumberFormatException nfe) {\n+            }\n+            try {\n+                return createLong(val);\n+            } catch (NumberFormatException nfe) {\n+            }\n+            return createBigInteger(val);\n+        } else {\n+            boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n+            try {\n+                Float f \u003d createFloat(val);\n+                if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n+                    return f;\n+                }\n+            } catch (NumberFormatException nfe) {\n+            }\n+            try {\n+                Double d \u003d createDouble(val);\n+                if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n+                    return d;\n+                }\n+            } catch (NumberFormatException nfe) {\n+            }\n+            return createBigDecimal(val);\n+        }\n+    }\n+}\n\\ No newline at end of file\n",
      "actualSource": "public static Number createNumber(String val) throws NumberFormatException {\n    if (val \u003d\u003d null) {\n        return null;\n    }\n    if (val.length() \u003d\u003d 0) {\n        throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n    }\n    if (val.startsWith(\"--\")) {\n        return null;\n    }\n    if (val.startsWith(\"0x\") || val.startsWith(\"-0x\")) {\n        return createInteger(val);\n    }\n    char lastChar \u003d val.charAt(val.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos \u003d val.indexOf(\u0027.\u0027);\n    int expPos \u003d val.indexOf(\u0027e\u0027) + val.indexOf(\u0027E\u0027) + 1;\n    if (decPos \u003e -1) {\n        if (expPos \u003e -1) {\n            if (expPos \u003c decPos) {\n                throw new NumberFormatException(val + \" is not a valid number.\");\n            }\n            dec \u003d val.substring(decPos + 1, expPos);\n        } else {\n            dec \u003d val.substring(decPos + 1);\n        }\n        mant \u003d val.substring(0, decPos);\n    } else {\n        if (expPos \u003e -1) {\n            mant \u003d val.substring(0, expPos);\n        } else {\n            mant \u003d val;\n        }\n        dec \u003d null;\n    }\n    if (!Character.isDigit(lastChar)) {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c val.length() - 1) {\n            exp \u003d val.substring(expPos + 1, val.length() - 1);\n        } else {\n            exp \u003d null;\n        }\n        String numeric \u003d val.substring(0, val.length() - 1);\n        boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n        switch(lastChar) {\n            case \u0027l\u0027:\n            case \u0027L\u0027:\n                if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null \u0026\u0026 isDigits(numeric.substring(1)) \u0026\u0026 (numeric.charAt(0) \u003d\u003d \u0027-\u0027 || Character.isDigit(numeric.charAt(0)))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (NumberFormatException nfe) {\n                    }\n                    return createBigInteger(numeric);\n                }\n                throw new NumberFormatException(val + \" is not a valid number.\");\n            case \u0027f\u0027:\n            case \u0027F\u0027:\n                try {\n                    Float f \u003d NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n            case \u0027d\u0027:\n            case \u0027D\u0027:\n                try {\n                    Double d \u003d NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (NumberFormatException e) {\n                }\n            default:\n                throw new NumberFormatException(val + \" is not a valid number.\");\n        }\n    } else {\n        if (expPos \u003e -1 \u0026\u0026 expPos \u003c val.length() - 1) {\n            exp \u003d val.substring(expPos + 1, val.length());\n        } else {\n            exp \u003d null;\n        }\n        if (dec \u003d\u003d null \u0026\u0026 exp \u003d\u003d null) {\n            try {\n                return createInteger(val);\n            } catch (NumberFormatException nfe) {\n            }\n            try {\n                return createLong(val);\n            } catch (NumberFormatException nfe) {\n            }\n            return createBigInteger(val);\n        } else {\n            boolean allZeros \u003d isAllZeros(mant) \u0026\u0026 isAllZeros(exp);\n            try {\n                Float f \u003d createFloat(val);\n                if (!(f.isInfinite() || (f.floatValue() \u003d\u003d 0.0F \u0026\u0026 !allZeros))) {\n                    return f;\n                }\n            } catch (NumberFormatException nfe) {\n            }\n            try {\n                Double d \u003d createDouble(val);\n                if (!(d.isInfinite() || (d.doubleValue() \u003d\u003d 0.0D \u0026\u0026 !allZeros))) {\n                    return d;\n                }\n            } catch (NumberFormatException nfe) {\n            }\n            return createBigDecimal(val);\n        }\n    }\n}",
      "path": "src/java/org/apache/commons/lang/NumberUtils.java",
      "functionStartLine": 153,
      "functionName": "createNumber",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003e\nTurns a string value into a java.lang.Number.\nFirst, the value is examined for a type qualifier on the end \n(\u003ccode\u003e\u0027f\u0027,\u0027F\u0027,\u0027d\u0027,\u0027D\u0027,\u0027l\u0027,\u0027L\u0027\u003c/code\u003e).  If it is found, it starts \ntrying to create succissively larger types from the type specified\nuntil one is found that can hold the value.\n\u003c/p\u003e\n\u003cp\u003e\nIf a type specifier is not found, it will check for a decimal point\nand then try successively larger types from Integer to BigInteger \nand from Float to BigDecimal.\n\u003c/p\u003e\n\u003cp\u003e\nIf the string starts with \"0x\" or \"-0x\", it will be interpreted as a \nhexadecimal integer.  Values with leading 0\u0027s will not be interpreted \nas octal.\n\u003c/p\u003e\n\n@param val String containing a number\n@return Number created from the string\n@throws NumberFormatException if the value cannot be converted\n"
    }
  }
}