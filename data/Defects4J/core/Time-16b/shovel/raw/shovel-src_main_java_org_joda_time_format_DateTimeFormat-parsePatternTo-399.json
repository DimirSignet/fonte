{
  "origin": "codeshovel",
  "repositoryName": "Time-16b",
  "repositoryPath": "/tmp/Time-16b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "DateTimeFormat.java",
  "functionName": "parsePatternTo",
  "functionId": "parsePatternTo___builder-DateTimeFormatterBuilder__pattern-String",
  "sourceFilePath": "src/main/java/org/joda/time/format/DateTimeFormat.java",
  "functionAnnotation": "",
  "functionDoc": "Parses the given pattern and appends the rules to the given\nDateTimeFormatterBuilder.\n\n@param pattern pattern specification\n@throws IllegalArgumentException if the pattern is invalid\n@see #forPattern\n",
  "functionStartLine": 399,
  "functionEndLine": 563,
  "numCommitsSeen": 55,
  "timeTaken": 4628,
  "changeHistory": [
    "df4a82f4fb46cc2248280c462e18f08d55a3d112",
    "53feb3fa56af7260e607844524b7e5a9be49ecc1",
    "9bad997820d36741944e86ba28f6999e074a0a95",
    "ab6b7a46049bba471d8cb9d2f85f31b77e67e293",
    "0531e3dc4fe73eacc1742644a8847c2dd9dc9466",
    "b7c1594f3758b3e5b6f9672407a9d06638aadd03",
    "66a8d06f1a039de49b9ca5ebaebcf3459e83a642",
    "3f51e8e42b421465459b12f94ceadb6fd42e1128",
    "eac6e8608dc93816b685f96a43b27cbd351e77c6",
    "5082337a4152e04ebd8077fd0b7fa28113a4d79e",
    "9316fce1b432caa8b56ff6056d916f0a0aaefc1a",
    "0d18055d0b3c2e687197a8651b3a06e097fe5c48",
    "4f78ec4d836c5aa1a1706eaf9c75a6e5c41d1d16",
    "49b93444b594c2418063c1f95cb07bd30bd639a1",
    "0e07ac6b2cff63550d7df336355ca63cc05aa40b",
    "7fe68f297f7c372b515fde7f0bc8d721ec257ceb"
  ],
  "changeHistoryShort": {
    "df4a82f4fb46cc2248280c462e18f08d55a3d112": "Yfilerename",
    "53feb3fa56af7260e607844524b7e5a9be49ecc1": "Yfilerename",
    "9bad997820d36741944e86ba28f6999e074a0a95": "Ybodychange",
    "ab6b7a46049bba471d8cb9d2f85f31b77e67e293": "Ybodychange",
    "0531e3dc4fe73eacc1742644a8847c2dd9dc9466": "Ybodychange",
    "b7c1594f3758b3e5b6f9672407a9d06638aadd03": "Ybodychange",
    "66a8d06f1a039de49b9ca5ebaebcf3459e83a642": "Ybodychange",
    "3f51e8e42b421465459b12f94ceadb6fd42e1128": "Ybodychange",
    "eac6e8608dc93816b685f96a43b27cbd351e77c6": "Ybodychange",
    "5082337a4152e04ebd8077fd0b7fa28113a4d79e": "Ymultichange(Yrename,Ymodifierchange)",
    "9316fce1b432caa8b56ff6056d916f0a0aaefc1a": "Ybodychange",
    "0d18055d0b3c2e687197a8651b3a06e097fe5c48": "Ybodychange",
    "4f78ec4d836c5aa1a1706eaf9c75a6e5c41d1d16": "Ybodychange",
    "49b93444b594c2418063c1f95cb07bd30bd639a1": "Ybodychange",
    "0e07ac6b2cff63550d7df336355ca63cc05aa40b": "Ymultichange(Ymovefromfile,Yreturntypechange,Ymodifierchange,Yexceptionschange,Ybodychange,Ydocchange,Yrename,Yparameterchange)",
    "7fe68f297f7c372b515fde7f0bc8d721ec257ceb": "Yintroduced"
  },
  "changeHistoryDetails": {
    "df4a82f4fb46cc2248280c462e18f08d55a3d112": {
      "type": "Yfilerename",
      "commitMessage": "Remove JodaTime folder moving files to top level\n",
      "commitDate": "5/16/11, 10:02 AM",
      "commitName": "df4a82f4fb46cc2248280c462e18f08d55a3d112",
      "commitAuthor": "Stephen Colebourne",
      "commitDateOld": "5/16/11, 9:58 AM",
      "commitNameOld": "72b22654962284bac59c2777131b42a2d1f53228",
      "commitAuthorOld": "Stephen Colebourne",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n    int length \u003d pattern.length();\n    int[] indexRef \u003d new int[1];\n    for (int i \u003d 0; i \u003c length; i++) {\n        indexRef[0] \u003d i;\n        String token \u003d parseToken(pattern, indexRef);\n        i \u003d indexRef[0];\n        int tokenLen \u003d token.length();\n        if (tokenLen \u003d\u003d 0) {\n            break;\n        }\n        char c \u003d token.charAt(0);\n        switch(c) {\n            case \u0027G\u0027:\n                builder.appendEraText();\n                break;\n            case \u0027C\u0027:\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case \u0027x\u0027:\n            case \u0027y\u0027:\n            case \u0027Y\u0027:\n                if (tokenLen \u003d\u003d 2) {\n                    boolean lenientParse \u003d true;\n                    if (i + 1 \u003c length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            lenientParse \u003d false;\n                        }\n                        indexRef[0]--;\n                    }\n                    switch(c) {\n                        case \u0027x\u0027:\n                            builder.appendTwoDigitWeekyear(new DateTime().getWeekyear() - 30, lenientParse);\n                            break;\n                        case \u0027y\u0027:\n                        case \u0027Y\u0027:\n                        default:\n                            builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                            break;\n                    }\n                } else {\n                    int maxDigits \u003d 9;\n                    if (i + 1 \u003c length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            maxDigits \u003d tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n                    switch(c) {\n                        case \u0027x\u0027:\n                            builder.appendWeekyear(tokenLen, maxDigits);\n                            break;\n                        case \u0027y\u0027:\n                            builder.appendYear(tokenLen, maxDigits);\n                            break;\n                        case \u0027Y\u0027:\n                            builder.appendYearOfEra(tokenLen, maxDigits);\n                            break;\n                    }\n                }\n                break;\n            case \u0027M\u0027:\n                if (tokenLen \u003e\u003d 3) {\n                    if (tokenLen \u003e\u003d 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case \u0027d\u0027:\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case \u0027a\u0027:\n                builder.appendHalfdayOfDayText();\n                break;\n            case \u0027h\u0027:\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case \u0027H\u0027:\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case \u0027k\u0027:\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case \u0027K\u0027:\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case \u0027m\u0027:\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case \u0027s\u0027:\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case \u0027S\u0027:\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case \u0027e\u0027:\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case \u0027E\u0027:\n                if (tokenLen \u003e\u003d 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case \u0027D\u0027:\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case \u0027w\u0027:\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case \u0027z\u0027:\n                if (tokenLen \u003e\u003d 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName();\n                }\n                break;\n            case \u0027Z\u0027:\n                if (tokenLen \u003d\u003d 1) {\n                    builder.appendTimeZoneOffset(null, \"Z\", false, 2, 2);\n                } else if (tokenLen \u003d\u003d 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case \u0027\\\u0027\u0027:\n                String sub \u003d token.substring(1);\n                if (sub.length() \u003d\u003d 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n        }\n    }\n}",
      "path": "src/main/java/org/joda/time/format/DateTimeFormat.java",
      "functionStartLine": 399,
      "functionName": "parsePatternTo",
      "functionAnnotation": "",
      "functionDoc": "Parses the given pattern and appends the rules to the given\nDateTimeFormatterBuilder.\n\n@param pattern pattern specification\n@throws IllegalArgumentException if the pattern is invalid\n@see #forPattern\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "JodaTime/src/main/java/org/joda/time/format/DateTimeFormat.java",
        "newPath": "src/main/java/org/joda/time/format/DateTimeFormat.java"
      }
    },
    "53feb3fa56af7260e607844524b7e5a9be49ecc1": {
      "type": "Yfilerename",
      "commitMessage": "Convert to maven 2\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@1540 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1\n",
      "commitDate": "8/8/10, 5:17 PM",
      "commitName": "53feb3fa56af7260e607844524b7e5a9be49ecc1",
      "commitAuthor": "Stephen Colebourne",
      "commitDateOld": "8/8/10, 5:02 PM",
      "commitNameOld": "7fa2ceaf5d95d050095432aa646ea803aa35e122",
      "commitAuthorOld": "Stephen Colebourne",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n    int length \u003d pattern.length();\n    int[] indexRef \u003d new int[1];\n    for (int i \u003d 0; i \u003c length; i++) {\n        indexRef[0] \u003d i;\n        String token \u003d parseToken(pattern, indexRef);\n        i \u003d indexRef[0];\n        int tokenLen \u003d token.length();\n        if (tokenLen \u003d\u003d 0) {\n            break;\n        }\n        char c \u003d token.charAt(0);\n        switch(c) {\n            case \u0027G\u0027:\n                builder.appendEraText();\n                break;\n            case \u0027C\u0027:\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case \u0027x\u0027:\n            case \u0027y\u0027:\n            case \u0027Y\u0027:\n                if (tokenLen \u003d\u003d 2) {\n                    boolean lenientParse \u003d true;\n                    if (i + 1 \u003c length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            lenientParse \u003d false;\n                        }\n                        indexRef[0]--;\n                    }\n                    switch(c) {\n                        case \u0027x\u0027:\n                            builder.appendTwoDigitWeekyear(new DateTime().getWeekyear() - 30, lenientParse);\n                            break;\n                        case \u0027y\u0027:\n                        case \u0027Y\u0027:\n                        default:\n                            builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                            break;\n                    }\n                } else {\n                    int maxDigits \u003d 9;\n                    if (i + 1 \u003c length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            maxDigits \u003d tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n                    switch(c) {\n                        case \u0027x\u0027:\n                            builder.appendWeekyear(tokenLen, maxDigits);\n                            break;\n                        case \u0027y\u0027:\n                            builder.appendYear(tokenLen, maxDigits);\n                            break;\n                        case \u0027Y\u0027:\n                            builder.appendYearOfEra(tokenLen, maxDigits);\n                            break;\n                    }\n                }\n                break;\n            case \u0027M\u0027:\n                if (tokenLen \u003e\u003d 3) {\n                    if (tokenLen \u003e\u003d 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case \u0027d\u0027:\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case \u0027a\u0027:\n                builder.appendHalfdayOfDayText();\n                break;\n            case \u0027h\u0027:\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case \u0027H\u0027:\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case \u0027k\u0027:\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case \u0027K\u0027:\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case \u0027m\u0027:\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case \u0027s\u0027:\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case \u0027S\u0027:\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case \u0027e\u0027:\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case \u0027E\u0027:\n                if (tokenLen \u003e\u003d 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case \u0027D\u0027:\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case \u0027w\u0027:\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case \u0027z\u0027:\n                if (tokenLen \u003e\u003d 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName();\n                }\n                break;\n            case \u0027Z\u0027:\n                if (tokenLen \u003d\u003d 1) {\n                    builder.appendTimeZoneOffset(null, \"Z\", false, 2, 2);\n                } else if (tokenLen \u003d\u003d 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case \u0027\\\u0027\u0027:\n                String sub \u003d token.substring(1);\n                if (sub.length() \u003d\u003d 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n        }\n    }\n}",
      "path": "JodaTime/src/main/java/org/joda/time/format/DateTimeFormat.java",
      "functionStartLine": 399,
      "functionName": "parsePatternTo",
      "functionAnnotation": "",
      "functionDoc": "Parses the given pattern and appends the rules to the given\nDateTimeFormatterBuilder.\n\n@param pattern pattern specification\n@throws IllegalArgumentException if the pattern is invalid\n@see #forPattern\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "JodaTime/src/java/org/joda/time/format/DateTimeFormat.java",
        "newPath": "JodaTime/src/main/java/org/joda/time/format/DateTimeFormat.java"
      }
    },
    "9bad997820d36741944e86ba28f6999e074a0a95": {
      "type": "Ybodychange",
      "commitMessage": "Allow \u0027Z\u0027 and \u0027ZZ\u0027 in format patterns to parse \u0027Z\u0027 as \u0027+00:00\u0027 [2827359]\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@1405 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1\n",
      "commitDate": "11/4/09, 2:27 PM",
      "commitName": "9bad997820d36741944e86ba28f6999e074a0a95",
      "commitAuthor": "Stephen Colebourne",
      "commitDateOld": "5/26/07, 5:45 AM",
      "commitNameOld": "ddd50d2773c7126e0c3249c99bbed04cf7544b34",
      "commitAuthorOld": "Stephen Colebourne",
      "daysBetweenCommits": 893.4,
      "commitsBetweenForRepo": 161,
      "commitsBetweenForFile": 1,
      "actualSource": "private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n    int length \u003d pattern.length();\n    int[] indexRef \u003d new int[1];\n    for (int i \u003d 0; i \u003c length; i++) {\n        indexRef[0] \u003d i;\n        String token \u003d parseToken(pattern, indexRef);\n        i \u003d indexRef[0];\n        int tokenLen \u003d token.length();\n        if (tokenLen \u003d\u003d 0) {\n            break;\n        }\n        char c \u003d token.charAt(0);\n        switch(c) {\n            case \u0027G\u0027:\n                builder.appendEraText();\n                break;\n            case \u0027C\u0027:\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case \u0027x\u0027:\n            case \u0027y\u0027:\n            case \u0027Y\u0027:\n                if (tokenLen \u003d\u003d 2) {\n                    boolean lenientParse \u003d true;\n                    if (i + 1 \u003c length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            lenientParse \u003d false;\n                        }\n                        indexRef[0]--;\n                    }\n                    switch(c) {\n                        case \u0027x\u0027:\n                            builder.appendTwoDigitWeekyear(new DateTime().getWeekyear() - 30, lenientParse);\n                            break;\n                        case \u0027y\u0027:\n                        case \u0027Y\u0027:\n                        default:\n                            builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                            break;\n                    }\n                } else {\n                    int maxDigits \u003d 9;\n                    if (i + 1 \u003c length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            maxDigits \u003d tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n                    switch(c) {\n                        case \u0027x\u0027:\n                            builder.appendWeekyear(tokenLen, maxDigits);\n                            break;\n                        case \u0027y\u0027:\n                            builder.appendYear(tokenLen, maxDigits);\n                            break;\n                        case \u0027Y\u0027:\n                            builder.appendYearOfEra(tokenLen, maxDigits);\n                            break;\n                    }\n                }\n                break;\n            case \u0027M\u0027:\n                if (tokenLen \u003e\u003d 3) {\n                    if (tokenLen \u003e\u003d 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case \u0027d\u0027:\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case \u0027a\u0027:\n                builder.appendHalfdayOfDayText();\n                break;\n            case \u0027h\u0027:\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case \u0027H\u0027:\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case \u0027k\u0027:\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case \u0027K\u0027:\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case \u0027m\u0027:\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case \u0027s\u0027:\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case \u0027S\u0027:\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case \u0027e\u0027:\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case \u0027E\u0027:\n                if (tokenLen \u003e\u003d 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case \u0027D\u0027:\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case \u0027w\u0027:\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case \u0027z\u0027:\n                if (tokenLen \u003e\u003d 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName();\n                }\n                break;\n            case \u0027Z\u0027:\n                if (tokenLen \u003d\u003d 1) {\n                    builder.appendTimeZoneOffset(null, \"Z\", false, 2, 2);\n                } else if (tokenLen \u003d\u003d 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case \u0027\\\u0027\u0027:\n                String sub \u003d token.substring(1);\n                if (sub.length() \u003d\u003d 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n        }\n    }\n}",
      "path": "JodaTime/src/java/org/joda/time/format/DateTimeFormat.java",
      "functionStartLine": 399,
      "functionName": "parsePatternTo",
      "functionAnnotation": "",
      "functionDoc": "Parses the given pattern and appends the rules to the given\nDateTimeFormatterBuilder.\n\n@param pattern pattern specification\n@throws IllegalArgumentException if the pattern is invalid\n@see #forPattern\n",
      "diff": "@@ -1,146 +1,146 @@\n private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n     int length \u003d pattern.length();\n     int[] indexRef \u003d new int[1];\n     for (int i \u003d 0; i \u003c length; i++) {\n         indexRef[0] \u003d i;\n         String token \u003d parseToken(pattern, indexRef);\n         i \u003d indexRef[0];\n         int tokenLen \u003d token.length();\n         if (tokenLen \u003d\u003d 0) {\n             break;\n         }\n         char c \u003d token.charAt(0);\n         switch(c) {\n             case \u0027G\u0027:\n                 builder.appendEraText();\n                 break;\n             case \u0027C\u0027:\n                 builder.appendCenturyOfEra(tokenLen, tokenLen);\n                 break;\n             case \u0027x\u0027:\n             case \u0027y\u0027:\n             case \u0027Y\u0027:\n                 if (tokenLen \u003d\u003d 2) {\n                     boolean lenientParse \u003d true;\n                     if (i + 1 \u003c length) {\n                         indexRef[0]++;\n                         if (isNumericToken(parseToken(pattern, indexRef))) {\n                             lenientParse \u003d false;\n                         }\n                         indexRef[0]--;\n                     }\n                     switch(c) {\n                         case \u0027x\u0027:\n                             builder.appendTwoDigitWeekyear(new DateTime().getWeekyear() - 30, lenientParse);\n                             break;\n                         case \u0027y\u0027:\n                         case \u0027Y\u0027:\n                         default:\n                             builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                             break;\n                     }\n                 } else {\n                     int maxDigits \u003d 9;\n                     if (i + 1 \u003c length) {\n                         indexRef[0]++;\n                         if (isNumericToken(parseToken(pattern, indexRef))) {\n                             maxDigits \u003d tokenLen;\n                         }\n                         indexRef[0]--;\n                     }\n                     switch(c) {\n                         case \u0027x\u0027:\n                             builder.appendWeekyear(tokenLen, maxDigits);\n                             break;\n                         case \u0027y\u0027:\n                             builder.appendYear(tokenLen, maxDigits);\n                             break;\n                         case \u0027Y\u0027:\n                             builder.appendYearOfEra(tokenLen, maxDigits);\n                             break;\n                     }\n                 }\n                 break;\n             case \u0027M\u0027:\n                 if (tokenLen \u003e\u003d 3) {\n                     if (tokenLen \u003e\u003d 4) {\n                         builder.appendMonthOfYearText();\n                     } else {\n                         builder.appendMonthOfYearShortText();\n                     }\n                 } else {\n                     builder.appendMonthOfYear(tokenLen);\n                 }\n                 break;\n             case \u0027d\u0027:\n                 builder.appendDayOfMonth(tokenLen);\n                 break;\n             case \u0027a\u0027:\n                 builder.appendHalfdayOfDayText();\n                 break;\n             case \u0027h\u0027:\n                 builder.appendClockhourOfHalfday(tokenLen);\n                 break;\n             case \u0027H\u0027:\n                 builder.appendHourOfDay(tokenLen);\n                 break;\n             case \u0027k\u0027:\n                 builder.appendClockhourOfDay(tokenLen);\n                 break;\n             case \u0027K\u0027:\n                 builder.appendHourOfHalfday(tokenLen);\n                 break;\n             case \u0027m\u0027:\n                 builder.appendMinuteOfHour(tokenLen);\n                 break;\n             case \u0027s\u0027:\n                 builder.appendSecondOfMinute(tokenLen);\n                 break;\n             case \u0027S\u0027:\n                 builder.appendFractionOfSecond(tokenLen, tokenLen);\n                 break;\n             case \u0027e\u0027:\n                 builder.appendDayOfWeek(tokenLen);\n                 break;\n             case \u0027E\u0027:\n                 if (tokenLen \u003e\u003d 4) {\n                     builder.appendDayOfWeekText();\n                 } else {\n                     builder.appendDayOfWeekShortText();\n                 }\n                 break;\n             case \u0027D\u0027:\n                 builder.appendDayOfYear(tokenLen);\n                 break;\n             case \u0027w\u0027:\n                 builder.appendWeekOfWeekyear(tokenLen);\n                 break;\n             case \u0027z\u0027:\n                 if (tokenLen \u003e\u003d 4) {\n                     builder.appendTimeZoneName();\n                 } else {\n                     builder.appendTimeZoneShortName();\n                 }\n                 break;\n             case \u0027Z\u0027:\n                 if (tokenLen \u003d\u003d 1) {\n-                    builder.appendTimeZoneOffset(null, false, 2, 2);\n+                    builder.appendTimeZoneOffset(null, \"Z\", false, 2, 2);\n                 } else if (tokenLen \u003d\u003d 2) {\n-                    builder.appendTimeZoneOffset(null, true, 2, 2);\n+                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                 } else {\n                     builder.appendTimeZoneId();\n                 }\n                 break;\n             case \u0027\\\u0027\u0027:\n                 String sub \u003d token.substring(1);\n                 if (sub.length() \u003d\u003d 1) {\n                     builder.appendLiteral(sub.charAt(0));\n                 } else {\n                     builder.appendLiteral(new String(sub));\n                 }\n                 break;\n             default:\n                 throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ab6b7a46049bba471d8cb9d2f85f31b77e67e293": {
      "type": "Ybodychange",
      "commitMessage": "Fix DateTimeFormat pattern letter K\nfrom Maxim Zhao\n\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@977 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1\n",
      "commitDate": "12/18/05, 4:37 PM",
      "commitName": "ab6b7a46049bba471d8cb9d2f85f31b77e67e293",
      "commitAuthor": "Stephen Colebourne",
      "commitDateOld": "8/10/05, 3:34 PM",
      "commitNameOld": "22b39081c85640ff5add5ed3a8037f4ac00ccb49",
      "commitAuthorOld": "Stephen Colebourne",
      "daysBetweenCommits": 130.08,
      "commitsBetweenForRepo": 122,
      "commitsBetweenForFile": 1,
      "actualSource": "private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n    int length \u003d pattern.length();\n    int[] indexRef \u003d new int[1];\n    for (int i \u003d 0; i \u003c length; i++) {\n        indexRef[0] \u003d i;\n        String token \u003d parseToken(pattern, indexRef);\n        i \u003d indexRef[0];\n        int tokenLen \u003d token.length();\n        if (tokenLen \u003d\u003d 0) {\n            break;\n        }\n        char c \u003d token.charAt(0);\n        switch(c) {\n            case \u0027G\u0027:\n                builder.appendEraText();\n                break;\n            case \u0027C\u0027:\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case \u0027x\u0027:\n            case \u0027y\u0027:\n            case \u0027Y\u0027:\n                if (tokenLen \u003d\u003d 2) {\n                    boolean lenientParse \u003d true;\n                    if (i + 1 \u003c length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            lenientParse \u003d false;\n                        }\n                        indexRef[0]--;\n                    }\n                    switch(c) {\n                        case \u0027x\u0027:\n                            builder.appendTwoDigitWeekyear(new DateTime().getWeekyear() - 30, lenientParse);\n                            break;\n                        case \u0027y\u0027:\n                        case \u0027Y\u0027:\n                        default:\n                            builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                            break;\n                    }\n                } else {\n                    int maxDigits \u003d 9;\n                    if (i + 1 \u003c length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            maxDigits \u003d tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n                    switch(c) {\n                        case \u0027x\u0027:\n                            builder.appendWeekyear(tokenLen, maxDigits);\n                            break;\n                        case \u0027y\u0027:\n                            builder.appendYear(tokenLen, maxDigits);\n                            break;\n                        case \u0027Y\u0027:\n                            builder.appendYearOfEra(tokenLen, maxDigits);\n                            break;\n                    }\n                }\n                break;\n            case \u0027M\u0027:\n                if (tokenLen \u003e\u003d 3) {\n                    if (tokenLen \u003e\u003d 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case \u0027d\u0027:\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case \u0027a\u0027:\n                builder.appendHalfdayOfDayText();\n                break;\n            case \u0027h\u0027:\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case \u0027H\u0027:\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case \u0027k\u0027:\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case \u0027K\u0027:\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case \u0027m\u0027:\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case \u0027s\u0027:\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case \u0027S\u0027:\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case \u0027e\u0027:\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case \u0027E\u0027:\n                if (tokenLen \u003e\u003d 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case \u0027D\u0027:\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case \u0027w\u0027:\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case \u0027z\u0027:\n                if (tokenLen \u003e\u003d 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName();\n                }\n                break;\n            case \u0027Z\u0027:\n                if (tokenLen \u003d\u003d 1) {\n                    builder.appendTimeZoneOffset(null, false, 2, 2);\n                } else if (tokenLen \u003d\u003d 2) {\n                    builder.appendTimeZoneOffset(null, true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case \u0027\\\u0027\u0027:\n                String sub \u003d token.substring(1);\n                if (sub.length() \u003d\u003d 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n        }\n    }\n}",
      "path": "JodaTime/src/java/org/joda/time/format/DateTimeFormat.java",
      "functionStartLine": 373,
      "functionName": "parsePatternTo",
      "functionAnnotation": "",
      "functionDoc": "Parses the given pattern and appends the rules to the given\nDateTimeFormatterBuilder.\n\n@param pattern pattern specification\n@throws IllegalArgumentException if the pattern is invalid\n@see #forPattern\n",
      "diff": "@@ -1,146 +1,146 @@\n private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n     int length \u003d pattern.length();\n     int[] indexRef \u003d new int[1];\n     for (int i \u003d 0; i \u003c length; i++) {\n         indexRef[0] \u003d i;\n         String token \u003d parseToken(pattern, indexRef);\n         i \u003d indexRef[0];\n         int tokenLen \u003d token.length();\n         if (tokenLen \u003d\u003d 0) {\n             break;\n         }\n         char c \u003d token.charAt(0);\n         switch(c) {\n             case \u0027G\u0027:\n                 builder.appendEraText();\n                 break;\n             case \u0027C\u0027:\n                 builder.appendCenturyOfEra(tokenLen, tokenLen);\n                 break;\n             case \u0027x\u0027:\n             case \u0027y\u0027:\n             case \u0027Y\u0027:\n                 if (tokenLen \u003d\u003d 2) {\n                     boolean lenientParse \u003d true;\n                     if (i + 1 \u003c length) {\n                         indexRef[0]++;\n                         if (isNumericToken(parseToken(pattern, indexRef))) {\n                             lenientParse \u003d false;\n                         }\n                         indexRef[0]--;\n                     }\n                     switch(c) {\n                         case \u0027x\u0027:\n                             builder.appendTwoDigitWeekyear(new DateTime().getWeekyear() - 30, lenientParse);\n                             break;\n                         case \u0027y\u0027:\n                         case \u0027Y\u0027:\n                         default:\n                             builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                             break;\n                     }\n                 } else {\n                     int maxDigits \u003d 9;\n                     if (i + 1 \u003c length) {\n                         indexRef[0]++;\n                         if (isNumericToken(parseToken(pattern, indexRef))) {\n                             maxDigits \u003d tokenLen;\n                         }\n                         indexRef[0]--;\n                     }\n                     switch(c) {\n                         case \u0027x\u0027:\n                             builder.appendWeekyear(tokenLen, maxDigits);\n                             break;\n                         case \u0027y\u0027:\n                             builder.appendYear(tokenLen, maxDigits);\n                             break;\n                         case \u0027Y\u0027:\n                             builder.appendYearOfEra(tokenLen, maxDigits);\n                             break;\n                     }\n                 }\n                 break;\n             case \u0027M\u0027:\n                 if (tokenLen \u003e\u003d 3) {\n                     if (tokenLen \u003e\u003d 4) {\n                         builder.appendMonthOfYearText();\n                     } else {\n                         builder.appendMonthOfYearShortText();\n                     }\n                 } else {\n                     builder.appendMonthOfYear(tokenLen);\n                 }\n                 break;\n             case \u0027d\u0027:\n                 builder.appendDayOfMonth(tokenLen);\n                 break;\n+            case \u0027a\u0027:\n+                builder.appendHalfdayOfDayText();\n+                break;\n             case \u0027h\u0027:\n                 builder.appendClockhourOfHalfday(tokenLen);\n                 break;\n             case \u0027H\u0027:\n                 builder.appendHourOfDay(tokenLen);\n                 break;\n+            case \u0027k\u0027:\n+                builder.appendClockhourOfDay(tokenLen);\n+                break;\n+            case \u0027K\u0027:\n+                builder.appendHourOfHalfday(tokenLen);\n+                break;\n             case \u0027m\u0027:\n                 builder.appendMinuteOfHour(tokenLen);\n                 break;\n             case \u0027s\u0027:\n                 builder.appendSecondOfMinute(tokenLen);\n                 break;\n             case \u0027S\u0027:\n                 builder.appendFractionOfSecond(tokenLen, tokenLen);\n                 break;\n             case \u0027e\u0027:\n                 builder.appendDayOfWeek(tokenLen);\n                 break;\n             case \u0027E\u0027:\n                 if (tokenLen \u003e\u003d 4) {\n                     builder.appendDayOfWeekText();\n                 } else {\n                     builder.appendDayOfWeekShortText();\n                 }\n                 break;\n             case \u0027D\u0027:\n                 builder.appendDayOfYear(tokenLen);\n                 break;\n             case \u0027w\u0027:\n                 builder.appendWeekOfWeekyear(tokenLen);\n                 break;\n-            case \u0027a\u0027:\n-                builder.appendHalfdayOfDayText();\n-                break;\n-            case \u0027k\u0027:\n-                builder.appendClockhourOfDay(tokenLen);\n-                break;\n-            case \u0027K\u0027:\n-                builder.appendClockhourOfHalfday(tokenLen);\n-                break;\n             case \u0027z\u0027:\n                 if (tokenLen \u003e\u003d 4) {\n                     builder.appendTimeZoneName();\n                 } else {\n                     builder.appendTimeZoneShortName();\n                 }\n                 break;\n             case \u0027Z\u0027:\n                 if (tokenLen \u003d\u003d 1) {\n                     builder.appendTimeZoneOffset(null, false, 2, 2);\n                 } else if (tokenLen \u003d\u003d 2) {\n                     builder.appendTimeZoneOffset(null, true, 2, 2);\n                 } else {\n                     builder.appendTimeZoneId();\n                 }\n                 break;\n             case \u0027\\\u0027\u0027:\n                 String sub \u003d token.substring(1);\n                 if (sub.length() \u003d\u003d 1) {\n                     builder.appendLiteral(sub.charAt(0));\n                 } else {\n                     builder.appendLiteral(new String(sub));\n                 }\n                 break;\n             default:\n                 throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0531e3dc4fe73eacc1742644a8847c2dd9dc9466": {
      "type": "Ybodychange",
      "commitMessage": "Remove unused code\n\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@846 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1\n",
      "commitDate": "8/3/05, 3:07 PM",
      "commitName": "0531e3dc4fe73eacc1742644a8847c2dd9dc9466",
      "commitAuthor": "Stephen Colebourne",
      "commitDateOld": "6/26/05, 5:13 PM",
      "commitNameOld": "130676f765d636563f24c1d28718808072cea612",
      "commitAuthorOld": "Stephen Colebourne",
      "daysBetweenCommits": 37.91,
      "commitsBetweenForRepo": 47,
      "commitsBetweenForFile": 1,
      "actualSource": "private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n    int length \u003d pattern.length();\n    int[] indexRef \u003d new int[1];\n    for (int i \u003d 0; i \u003c length; i++) {\n        indexRef[0] \u003d i;\n        String token \u003d parseToken(pattern, indexRef);\n        i \u003d indexRef[0];\n        int tokenLen \u003d token.length();\n        if (tokenLen \u003d\u003d 0) {\n            break;\n        }\n        char c \u003d token.charAt(0);\n        switch(c) {\n            case \u0027G\u0027:\n                builder.appendEraText();\n                break;\n            case \u0027C\u0027:\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case \u0027x\u0027:\n            case \u0027y\u0027:\n            case \u0027Y\u0027:\n                if (tokenLen \u003d\u003d 2) {\n                    boolean lenientParse \u003d true;\n                    if (i + 1 \u003c length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            lenientParse \u003d false;\n                        }\n                        indexRef[0]--;\n                    }\n                    switch(c) {\n                        case \u0027x\u0027:\n                            builder.appendTwoDigitWeekyear(new DateTime().getWeekyear() - 30, lenientParse);\n                            break;\n                        case \u0027y\u0027:\n                        case \u0027Y\u0027:\n                        default:\n                            builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                            break;\n                    }\n                } else {\n                    int maxDigits \u003d 9;\n                    if (i + 1 \u003c length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            maxDigits \u003d tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n                    switch(c) {\n                        case \u0027x\u0027:\n                            builder.appendWeekyear(tokenLen, maxDigits);\n                            break;\n                        case \u0027y\u0027:\n                            builder.appendYear(tokenLen, maxDigits);\n                            break;\n                        case \u0027Y\u0027:\n                            builder.appendYearOfEra(tokenLen, maxDigits);\n                            break;\n                    }\n                }\n                break;\n            case \u0027M\u0027:\n                if (tokenLen \u003e\u003d 3) {\n                    if (tokenLen \u003e\u003d 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case \u0027d\u0027:\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case \u0027h\u0027:\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case \u0027H\u0027:\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case \u0027m\u0027:\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case \u0027s\u0027:\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case \u0027S\u0027:\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case \u0027e\u0027:\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case \u0027E\u0027:\n                if (tokenLen \u003e\u003d 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case \u0027D\u0027:\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case \u0027w\u0027:\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case \u0027a\u0027:\n                builder.appendHalfdayOfDayText();\n                break;\n            case \u0027k\u0027:\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case \u0027K\u0027:\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case \u0027z\u0027:\n                if (tokenLen \u003e\u003d 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName();\n                }\n                break;\n            case \u0027Z\u0027:\n                if (tokenLen \u003d\u003d 1) {\n                    builder.appendTimeZoneOffset(null, false, 2, 2);\n                } else if (tokenLen \u003d\u003d 2) {\n                    builder.appendTimeZoneOffset(null, true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case \u0027\\\u0027\u0027:\n                String sub \u003d token.substring(1);\n                if (sub.length() \u003d\u003d 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n        }\n    }\n}",
      "path": "JodaTime/src/java/org/joda/time/format/DateTimeFormat.java",
      "functionStartLine": 370,
      "functionName": "parsePatternTo",
      "functionAnnotation": "",
      "functionDoc": "Parses the given pattern and appends the rules to the given\nDateTimeFormatterBuilder.\n\n@param pattern pattern specification\n@throws IllegalArgumentException if the pattern is invalid\n@see #forPattern\n",
      "diff": "@@ -1,147 +1,146 @@\n private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n     int length \u003d pattern.length();\n     int[] indexRef \u003d new int[1];\n     for (int i \u003d 0; i \u003c length; i++) {\n         indexRef[0] \u003d i;\n         String token \u003d parseToken(pattern, indexRef);\n         i \u003d indexRef[0];\n         int tokenLen \u003d token.length();\n         if (tokenLen \u003d\u003d 0) {\n             break;\n         }\n         char c \u003d token.charAt(0);\n         switch(c) {\n             case \u0027G\u0027:\n                 builder.appendEraText();\n                 break;\n             case \u0027C\u0027:\n                 builder.appendCenturyOfEra(tokenLen, tokenLen);\n                 break;\n             case \u0027x\u0027:\n             case \u0027y\u0027:\n             case \u0027Y\u0027:\n                 if (tokenLen \u003d\u003d 2) {\n                     boolean lenientParse \u003d true;\n                     if (i + 1 \u003c length) {\n                         indexRef[0]++;\n                         if (isNumericToken(parseToken(pattern, indexRef))) {\n                             lenientParse \u003d false;\n                         }\n                         indexRef[0]--;\n                     }\n-                    DateTimeFieldType type;\n                     switch(c) {\n                         case \u0027x\u0027:\n                             builder.appendTwoDigitWeekyear(new DateTime().getWeekyear() - 30, lenientParse);\n                             break;\n                         case \u0027y\u0027:\n                         case \u0027Y\u0027:\n                         default:\n                             builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                             break;\n                     }\n                 } else {\n                     int maxDigits \u003d 9;\n                     if (i + 1 \u003c length) {\n                         indexRef[0]++;\n                         if (isNumericToken(parseToken(pattern, indexRef))) {\n                             maxDigits \u003d tokenLen;\n                         }\n                         indexRef[0]--;\n                     }\n                     switch(c) {\n                         case \u0027x\u0027:\n                             builder.appendWeekyear(tokenLen, maxDigits);\n                             break;\n                         case \u0027y\u0027:\n                             builder.appendYear(tokenLen, maxDigits);\n                             break;\n                         case \u0027Y\u0027:\n                             builder.appendYearOfEra(tokenLen, maxDigits);\n                             break;\n                     }\n                 }\n                 break;\n             case \u0027M\u0027:\n                 if (tokenLen \u003e\u003d 3) {\n                     if (tokenLen \u003e\u003d 4) {\n                         builder.appendMonthOfYearText();\n                     } else {\n                         builder.appendMonthOfYearShortText();\n                     }\n                 } else {\n                     builder.appendMonthOfYear(tokenLen);\n                 }\n                 break;\n             case \u0027d\u0027:\n                 builder.appendDayOfMonth(tokenLen);\n                 break;\n             case \u0027h\u0027:\n                 builder.appendClockhourOfHalfday(tokenLen);\n                 break;\n             case \u0027H\u0027:\n                 builder.appendHourOfDay(tokenLen);\n                 break;\n             case \u0027m\u0027:\n                 builder.appendMinuteOfHour(tokenLen);\n                 break;\n             case \u0027s\u0027:\n                 builder.appendSecondOfMinute(tokenLen);\n                 break;\n             case \u0027S\u0027:\n                 builder.appendFractionOfSecond(tokenLen, tokenLen);\n                 break;\n             case \u0027e\u0027:\n                 builder.appendDayOfWeek(tokenLen);\n                 break;\n             case \u0027E\u0027:\n                 if (tokenLen \u003e\u003d 4) {\n                     builder.appendDayOfWeekText();\n                 } else {\n                     builder.appendDayOfWeekShortText();\n                 }\n                 break;\n             case \u0027D\u0027:\n                 builder.appendDayOfYear(tokenLen);\n                 break;\n             case \u0027w\u0027:\n                 builder.appendWeekOfWeekyear(tokenLen);\n                 break;\n             case \u0027a\u0027:\n                 builder.appendHalfdayOfDayText();\n                 break;\n             case \u0027k\u0027:\n                 builder.appendClockhourOfDay(tokenLen);\n                 break;\n             case \u0027K\u0027:\n                 builder.appendClockhourOfHalfday(tokenLen);\n                 break;\n             case \u0027z\u0027:\n                 if (tokenLen \u003e\u003d 4) {\n                     builder.appendTimeZoneName();\n                 } else {\n                     builder.appendTimeZoneShortName();\n                 }\n                 break;\n             case \u0027Z\u0027:\n                 if (tokenLen \u003d\u003d 1) {\n                     builder.appendTimeZoneOffset(null, false, 2, 2);\n                 } else if (tokenLen \u003d\u003d 2) {\n                     builder.appendTimeZoneOffset(null, true, 2, 2);\n                 } else {\n                     builder.appendTimeZoneId();\n                 }\n                 break;\n             case \u0027\\\u0027\u0027:\n                 String sub \u003d token.substring(1);\n                 if (sub.length() \u003d\u003d 1) {\n                     builder.appendLiteral(sub.charAt(0));\n                 } else {\n                     builder.appendLiteral(new String(sub));\n                 }\n                 break;\n             default:\n                 throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b7c1594f3758b3e5b6f9672407a9d06638aadd03": {
      "type": "Ybodychange",
      "commitMessage": "Two digit year parse can only be lenient if it is not followed by another numeric token\n\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@752 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1\n",
      "commitDate": "4/17/05, 10:37 PM",
      "commitName": "b7c1594f3758b3e5b6f9672407a9d06638aadd03",
      "commitAuthor": "Brian S O\u0027Neill",
      "commitDateOld": "4/17/05, 10:27 AM",
      "commitNameOld": "66a8d06f1a039de49b9ca5ebaebcf3459e83a642",
      "commitAuthorOld": "Brian S O\u0027Neill",
      "daysBetweenCommits": 0.51,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n    int length \u003d pattern.length();\n    int[] indexRef \u003d new int[1];\n    for (int i \u003d 0; i \u003c length; i++) {\n        indexRef[0] \u003d i;\n        String token \u003d parseToken(pattern, indexRef);\n        i \u003d indexRef[0];\n        int tokenLen \u003d token.length();\n        if (tokenLen \u003d\u003d 0) {\n            break;\n        }\n        char c \u003d token.charAt(0);\n        switch(c) {\n            case \u0027G\u0027:\n                builder.appendEraText();\n                break;\n            case \u0027C\u0027:\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case \u0027x\u0027:\n            case \u0027y\u0027:\n            case \u0027Y\u0027:\n                if (tokenLen \u003d\u003d 2) {\n                    boolean lenientParse \u003d true;\n                    if (i + 1 \u003c length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            lenientParse \u003d false;\n                        }\n                        indexRef[0]--;\n                    }\n                    DateTimeFieldType type;\n                    switch(c) {\n                        case \u0027x\u0027:\n                            builder.appendTwoDigitWeekyear(new DateTime().getWeekyear() - 30, lenientParse);\n                            break;\n                        case \u0027y\u0027:\n                        case \u0027Y\u0027:\n                        default:\n                            builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                            break;\n                    }\n                } else {\n                    int maxDigits \u003d 9;\n                    if (i + 1 \u003c length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            maxDigits \u003d tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n                    switch(c) {\n                        case \u0027x\u0027:\n                            builder.appendWeekyear(tokenLen, maxDigits);\n                            break;\n                        case \u0027y\u0027:\n                            builder.appendYear(tokenLen, maxDigits);\n                            break;\n                        case \u0027Y\u0027:\n                            builder.appendYearOfEra(tokenLen, maxDigits);\n                            break;\n                    }\n                }\n                break;\n            case \u0027M\u0027:\n                if (tokenLen \u003e\u003d 3) {\n                    if (tokenLen \u003e\u003d 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case \u0027d\u0027:\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case \u0027h\u0027:\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case \u0027H\u0027:\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case \u0027m\u0027:\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case \u0027s\u0027:\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case \u0027S\u0027:\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case \u0027e\u0027:\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case \u0027E\u0027:\n                if (tokenLen \u003e\u003d 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case \u0027D\u0027:\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case \u0027w\u0027:\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case \u0027a\u0027:\n                builder.appendHalfdayOfDayText();\n                break;\n            case \u0027k\u0027:\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case \u0027K\u0027:\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case \u0027z\u0027:\n                if (tokenLen \u003e\u003d 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName();\n                }\n                break;\n            case \u0027Z\u0027:\n                if (tokenLen \u003d\u003d 1) {\n                    builder.appendTimeZoneOffset(null, false, 2, 2);\n                } else if (tokenLen \u003d\u003d 2) {\n                    builder.appendTimeZoneOffset(null, true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case \u0027\\\u0027\u0027:\n                String sub \u003d token.substring(1);\n                if (sub.length() \u003d\u003d 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n        }\n    }\n}",
      "path": "JodaTime/src/java/org/joda/time/format/DateTimeFormat.java",
      "functionStartLine": 371,
      "functionName": "parsePatternTo",
      "functionAnnotation": "",
      "functionDoc": "Parses the given pattern and appends the rules to the given\nDateTimeFormatterBuilder.\n\n@param pattern pattern specification\n@throws IllegalArgumentException if the pattern is invalid\n@see #forPattern\n",
      "diff": "@@ -1,139 +1,147 @@\n private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n     int length \u003d pattern.length();\n     int[] indexRef \u003d new int[1];\n     for (int i \u003d 0; i \u003c length; i++) {\n         indexRef[0] \u003d i;\n         String token \u003d parseToken(pattern, indexRef);\n         i \u003d indexRef[0];\n         int tokenLen \u003d token.length();\n         if (tokenLen \u003d\u003d 0) {\n             break;\n         }\n         char c \u003d token.charAt(0);\n         switch(c) {\n             case \u0027G\u0027:\n                 builder.appendEraText();\n                 break;\n             case \u0027C\u0027:\n                 builder.appendCenturyOfEra(tokenLen, tokenLen);\n                 break;\n             case \u0027x\u0027:\n             case \u0027y\u0027:\n             case \u0027Y\u0027:\n                 if (tokenLen \u003d\u003d 2) {\n+                    boolean lenientParse \u003d true;\n+                    if (i + 1 \u003c length) {\n+                        indexRef[0]++;\n+                        if (isNumericToken(parseToken(pattern, indexRef))) {\n+                            lenientParse \u003d false;\n+                        }\n+                        indexRef[0]--;\n+                    }\n                     DateTimeFieldType type;\n                     switch(c) {\n                         case \u0027x\u0027:\n-                            builder.appendTwoDigitWeekyear(new DateTime().getWeekyear() - 30, true);\n+                            builder.appendTwoDigitWeekyear(new DateTime().getWeekyear() - 30, lenientParse);\n                             break;\n                         case \u0027y\u0027:\n                         case \u0027Y\u0027:\n                         default:\n-                            builder.appendTwoDigitYear(new DateTime().getYear() - 30, true);\n+                            builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                             break;\n                     }\n                 } else {\n                     int maxDigits \u003d 9;\n                     if (i + 1 \u003c length) {\n                         indexRef[0]++;\n                         if (isNumericToken(parseToken(pattern, indexRef))) {\n                             maxDigits \u003d tokenLen;\n                         }\n                         indexRef[0]--;\n                     }\n                     switch(c) {\n                         case \u0027x\u0027:\n                             builder.appendWeekyear(tokenLen, maxDigits);\n                             break;\n                         case \u0027y\u0027:\n                             builder.appendYear(tokenLen, maxDigits);\n                             break;\n                         case \u0027Y\u0027:\n                             builder.appendYearOfEra(tokenLen, maxDigits);\n                             break;\n                     }\n                 }\n                 break;\n             case \u0027M\u0027:\n                 if (tokenLen \u003e\u003d 3) {\n                     if (tokenLen \u003e\u003d 4) {\n                         builder.appendMonthOfYearText();\n                     } else {\n                         builder.appendMonthOfYearShortText();\n                     }\n                 } else {\n                     builder.appendMonthOfYear(tokenLen);\n                 }\n                 break;\n             case \u0027d\u0027:\n                 builder.appendDayOfMonth(tokenLen);\n                 break;\n             case \u0027h\u0027:\n                 builder.appendClockhourOfHalfday(tokenLen);\n                 break;\n             case \u0027H\u0027:\n                 builder.appendHourOfDay(tokenLen);\n                 break;\n             case \u0027m\u0027:\n                 builder.appendMinuteOfHour(tokenLen);\n                 break;\n             case \u0027s\u0027:\n                 builder.appendSecondOfMinute(tokenLen);\n                 break;\n             case \u0027S\u0027:\n                 builder.appendFractionOfSecond(tokenLen, tokenLen);\n                 break;\n             case \u0027e\u0027:\n                 builder.appendDayOfWeek(tokenLen);\n                 break;\n             case \u0027E\u0027:\n                 if (tokenLen \u003e\u003d 4) {\n                     builder.appendDayOfWeekText();\n                 } else {\n                     builder.appendDayOfWeekShortText();\n                 }\n                 break;\n             case \u0027D\u0027:\n                 builder.appendDayOfYear(tokenLen);\n                 break;\n             case \u0027w\u0027:\n                 builder.appendWeekOfWeekyear(tokenLen);\n                 break;\n             case \u0027a\u0027:\n                 builder.appendHalfdayOfDayText();\n                 break;\n             case \u0027k\u0027:\n                 builder.appendClockhourOfDay(tokenLen);\n                 break;\n             case \u0027K\u0027:\n                 builder.appendClockhourOfHalfday(tokenLen);\n                 break;\n             case \u0027z\u0027:\n                 if (tokenLen \u003e\u003d 4) {\n                     builder.appendTimeZoneName();\n                 } else {\n                     builder.appendTimeZoneShortName();\n                 }\n                 break;\n             case \u0027Z\u0027:\n                 if (tokenLen \u003d\u003d 1) {\n                     builder.appendTimeZoneOffset(null, false, 2, 2);\n                 } else if (tokenLen \u003d\u003d 2) {\n                     builder.appendTimeZoneOffset(null, true, 2, 2);\n                 } else {\n                     builder.appendTimeZoneId();\n                 }\n                 break;\n             case \u0027\\\u0027\u0027:\n                 String sub \u003d token.substring(1);\n                 if (sub.length() \u003d\u003d 1) {\n                     builder.appendLiteral(sub.charAt(0));\n                 } else {\n                     builder.appendLiteral(new String(sub));\n                 }\n                 break;\n             default:\n                 throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "66a8d06f1a039de49b9ca5ebaebcf3459e83a642": {
      "type": "Ybodychange",
      "commitMessage": "Bug fix for parsing two digit year pattern with more or less than two digits.\n\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@750 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1\n",
      "commitDate": "4/17/05, 10:27 AM",
      "commitName": "66a8d06f1a039de49b9ca5ebaebcf3459e83a642",
      "commitAuthor": "Brian S O\u0027Neill",
      "commitDateOld": "2/17/05, 4:08 PM",
      "commitNameOld": "ad1be7578f5822b29a3b14149f462298d6b5553d",
      "commitAuthorOld": "Stephen Colebourne",
      "daysBetweenCommits": 58.72,
      "commitsBetweenForRepo": 29,
      "commitsBetweenForFile": 1,
      "actualSource": "private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n    int length \u003d pattern.length();\n    int[] indexRef \u003d new int[1];\n    for (int i \u003d 0; i \u003c length; i++) {\n        indexRef[0] \u003d i;\n        String token \u003d parseToken(pattern, indexRef);\n        i \u003d indexRef[0];\n        int tokenLen \u003d token.length();\n        if (tokenLen \u003d\u003d 0) {\n            break;\n        }\n        char c \u003d token.charAt(0);\n        switch(c) {\n            case \u0027G\u0027:\n                builder.appendEraText();\n                break;\n            case \u0027C\u0027:\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case \u0027x\u0027:\n            case \u0027y\u0027:\n            case \u0027Y\u0027:\n                if (tokenLen \u003d\u003d 2) {\n                    DateTimeFieldType type;\n                    switch(c) {\n                        case \u0027x\u0027:\n                            builder.appendTwoDigitWeekyear(new DateTime().getWeekyear() - 30, true);\n                            break;\n                        case \u0027y\u0027:\n                        case \u0027Y\u0027:\n                        default:\n                            builder.appendTwoDigitYear(new DateTime().getYear() - 30, true);\n                            break;\n                    }\n                } else {\n                    int maxDigits \u003d 9;\n                    if (i + 1 \u003c length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            maxDigits \u003d tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n                    switch(c) {\n                        case \u0027x\u0027:\n                            builder.appendWeekyear(tokenLen, maxDigits);\n                            break;\n                        case \u0027y\u0027:\n                            builder.appendYear(tokenLen, maxDigits);\n                            break;\n                        case \u0027Y\u0027:\n                            builder.appendYearOfEra(tokenLen, maxDigits);\n                            break;\n                    }\n                }\n                break;\n            case \u0027M\u0027:\n                if (tokenLen \u003e\u003d 3) {\n                    if (tokenLen \u003e\u003d 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case \u0027d\u0027:\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case \u0027h\u0027:\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case \u0027H\u0027:\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case \u0027m\u0027:\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case \u0027s\u0027:\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case \u0027S\u0027:\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case \u0027e\u0027:\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case \u0027E\u0027:\n                if (tokenLen \u003e\u003d 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case \u0027D\u0027:\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case \u0027w\u0027:\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case \u0027a\u0027:\n                builder.appendHalfdayOfDayText();\n                break;\n            case \u0027k\u0027:\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case \u0027K\u0027:\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case \u0027z\u0027:\n                if (tokenLen \u003e\u003d 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName();\n                }\n                break;\n            case \u0027Z\u0027:\n                if (tokenLen \u003d\u003d 1) {\n                    builder.appendTimeZoneOffset(null, false, 2, 2);\n                } else if (tokenLen \u003d\u003d 2) {\n                    builder.appendTimeZoneOffset(null, true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case \u0027\\\u0027\u0027:\n                String sub \u003d token.substring(1);\n                if (sub.length() \u003d\u003d 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n        }\n    }\n}",
      "path": "JodaTime/src/java/org/joda/time/format/DateTimeFormat.java",
      "functionStartLine": 371,
      "functionName": "parsePatternTo",
      "functionAnnotation": "",
      "functionDoc": "Parses the given pattern and appends the rules to the given\nDateTimeFormatterBuilder.\n\n@param pattern pattern specification\n@throws IllegalArgumentException if the pattern is invalid\n@see #forPattern\n",
      "diff": "@@ -1,139 +1,139 @@\n private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n     int length \u003d pattern.length();\n     int[] indexRef \u003d new int[1];\n     for (int i \u003d 0; i \u003c length; i++) {\n         indexRef[0] \u003d i;\n         String token \u003d parseToken(pattern, indexRef);\n         i \u003d indexRef[0];\n         int tokenLen \u003d token.length();\n         if (tokenLen \u003d\u003d 0) {\n             break;\n         }\n         char c \u003d token.charAt(0);\n         switch(c) {\n             case \u0027G\u0027:\n                 builder.appendEraText();\n                 break;\n             case \u0027C\u0027:\n                 builder.appendCenturyOfEra(tokenLen, tokenLen);\n                 break;\n             case \u0027x\u0027:\n             case \u0027y\u0027:\n             case \u0027Y\u0027:\n                 if (tokenLen \u003d\u003d 2) {\n                     DateTimeFieldType type;\n                     switch(c) {\n                         case \u0027x\u0027:\n-                            builder.appendTwoDigitWeekyear(new DateTime().getWeekyear() - 30);\n+                            builder.appendTwoDigitWeekyear(new DateTime().getWeekyear() - 30, true);\n                             break;\n                         case \u0027y\u0027:\n                         case \u0027Y\u0027:\n                         default:\n-                            builder.appendTwoDigitYear(new DateTime().getYear() - 30);\n+                            builder.appendTwoDigitYear(new DateTime().getYear() - 30, true);\n                             break;\n                     }\n                 } else {\n                     int maxDigits \u003d 9;\n                     if (i + 1 \u003c length) {\n                         indexRef[0]++;\n                         if (isNumericToken(parseToken(pattern, indexRef))) {\n                             maxDigits \u003d tokenLen;\n                         }\n                         indexRef[0]--;\n                     }\n                     switch(c) {\n                         case \u0027x\u0027:\n                             builder.appendWeekyear(tokenLen, maxDigits);\n                             break;\n                         case \u0027y\u0027:\n                             builder.appendYear(tokenLen, maxDigits);\n                             break;\n                         case \u0027Y\u0027:\n                             builder.appendYearOfEra(tokenLen, maxDigits);\n                             break;\n                     }\n                 }\n                 break;\n             case \u0027M\u0027:\n                 if (tokenLen \u003e\u003d 3) {\n                     if (tokenLen \u003e\u003d 4) {\n                         builder.appendMonthOfYearText();\n                     } else {\n                         builder.appendMonthOfYearShortText();\n                     }\n                 } else {\n                     builder.appendMonthOfYear(tokenLen);\n                 }\n                 break;\n             case \u0027d\u0027:\n                 builder.appendDayOfMonth(tokenLen);\n                 break;\n             case \u0027h\u0027:\n                 builder.appendClockhourOfHalfday(tokenLen);\n                 break;\n             case \u0027H\u0027:\n                 builder.appendHourOfDay(tokenLen);\n                 break;\n             case \u0027m\u0027:\n                 builder.appendMinuteOfHour(tokenLen);\n                 break;\n             case \u0027s\u0027:\n                 builder.appendSecondOfMinute(tokenLen);\n                 break;\n             case \u0027S\u0027:\n                 builder.appendFractionOfSecond(tokenLen, tokenLen);\n                 break;\n             case \u0027e\u0027:\n                 builder.appendDayOfWeek(tokenLen);\n                 break;\n             case \u0027E\u0027:\n                 if (tokenLen \u003e\u003d 4) {\n                     builder.appendDayOfWeekText();\n                 } else {\n                     builder.appendDayOfWeekShortText();\n                 }\n                 break;\n             case \u0027D\u0027:\n                 builder.appendDayOfYear(tokenLen);\n                 break;\n             case \u0027w\u0027:\n                 builder.appendWeekOfWeekyear(tokenLen);\n                 break;\n             case \u0027a\u0027:\n                 builder.appendHalfdayOfDayText();\n                 break;\n             case \u0027k\u0027:\n                 builder.appendClockhourOfDay(tokenLen);\n                 break;\n             case \u0027K\u0027:\n                 builder.appendClockhourOfHalfday(tokenLen);\n                 break;\n             case \u0027z\u0027:\n                 if (tokenLen \u003e\u003d 4) {\n                     builder.appendTimeZoneName();\n                 } else {\n                     builder.appendTimeZoneShortName();\n                 }\n                 break;\n             case \u0027Z\u0027:\n                 if (tokenLen \u003d\u003d 1) {\n                     builder.appendTimeZoneOffset(null, false, 2, 2);\n                 } else if (tokenLen \u003d\u003d 2) {\n                     builder.appendTimeZoneOffset(null, true, 2, 2);\n                 } else {\n                     builder.appendTimeZoneId();\n                 }\n                 break;\n             case \u0027\\\u0027\u0027:\n                 String sub \u003d token.substring(1);\n                 if (sub.length() \u003d\u003d 1) {\n                     builder.appendLiteral(sub.charAt(0));\n                 } else {\n                     builder.appendLiteral(new String(sub));\n                 }\n                 break;\n             default:\n                 throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3f51e8e42b421465459b12f94ceadb6fd42e1128": {
      "type": "Ybodychange",
      "commitMessage": "Comment change on two digit year pivot\n\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@711 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1\n",
      "commitDate": "2/14/05, 10:33 PM",
      "commitName": "3f51e8e42b421465459b12f94ceadb6fd42e1128",
      "commitAuthor": "Brian S O\u0027Neill",
      "commitDateOld": "2/13/05, 9:37 AM",
      "commitNameOld": "94b4a6ad9a9d6313d62d2d47956502cf9a00e028",
      "commitAuthorOld": "Brian S O\u0027Neill",
      "daysBetweenCommits": 1.54,
      "commitsBetweenForRepo": 18,
      "commitsBetweenForFile": 1,
      "actualSource": "private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n    int length \u003d pattern.length();\n    int[] indexRef \u003d new int[1];\n    for (int i \u003d 0; i \u003c length; i++) {\n        indexRef[0] \u003d i;\n        String token \u003d parseToken(pattern, indexRef);\n        i \u003d indexRef[0];\n        int tokenLen \u003d token.length();\n        if (tokenLen \u003d\u003d 0) {\n            break;\n        }\n        char c \u003d token.charAt(0);\n        switch(c) {\n            case \u0027G\u0027:\n                builder.appendEraText();\n                break;\n            case \u0027C\u0027:\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case \u0027x\u0027:\n            case \u0027y\u0027:\n            case \u0027Y\u0027:\n                if (tokenLen \u003d\u003d 2) {\n                    DateTimeFieldType type;\n                    switch(c) {\n                        case \u0027x\u0027:\n                            builder.appendTwoDigitWeekyear(new DateTime().getWeekyear() - 30);\n                            break;\n                        case \u0027y\u0027:\n                        case \u0027Y\u0027:\n                        default:\n                            builder.appendTwoDigitYear(new DateTime().getYear() - 30);\n                            break;\n                    }\n                } else {\n                    int maxDigits \u003d 9;\n                    if (i + 1 \u003c length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            maxDigits \u003d tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n                    switch(c) {\n                        case \u0027x\u0027:\n                            builder.appendWeekyear(tokenLen, maxDigits);\n                            break;\n                        case \u0027y\u0027:\n                            builder.appendYear(tokenLen, maxDigits);\n                            break;\n                        case \u0027Y\u0027:\n                            builder.appendYearOfEra(tokenLen, maxDigits);\n                            break;\n                    }\n                }\n                break;\n            case \u0027M\u0027:\n                if (tokenLen \u003e\u003d 3) {\n                    if (tokenLen \u003e\u003d 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case \u0027d\u0027:\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case \u0027h\u0027:\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case \u0027H\u0027:\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case \u0027m\u0027:\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case \u0027s\u0027:\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case \u0027S\u0027:\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case \u0027e\u0027:\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case \u0027E\u0027:\n                if (tokenLen \u003e\u003d 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case \u0027D\u0027:\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case \u0027w\u0027:\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case \u0027a\u0027:\n                builder.appendHalfdayOfDayText();\n                break;\n            case \u0027k\u0027:\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case \u0027K\u0027:\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case \u0027z\u0027:\n                if (tokenLen \u003e\u003d 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName();\n                }\n                break;\n            case \u0027Z\u0027:\n                if (tokenLen \u003d\u003d 1) {\n                    builder.appendTimeZoneOffset(null, false, 2, 2);\n                } else if (tokenLen \u003d\u003d 2) {\n                    builder.appendTimeZoneOffset(null, true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case \u0027\\\u0027\u0027:\n                String sub \u003d token.substring(1);\n                if (sub.length() \u003d\u003d 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n        }\n    }\n}",
      "path": "JodaTime/src/java/org/joda/time/format/DateTimeFormat.java",
      "functionStartLine": 381,
      "functionName": "parsePatternTo",
      "functionAnnotation": "",
      "functionDoc": "Parses the given pattern and appends the rules to the given\nDateTimeFormatterBuilder.\n\n@param pattern pattern specification\n@throws IllegalArgumentException if the pattern is invalid\n@see #forPattern\n",
      "diff": "",
      "extendedDetails": {}
    },
    "eac6e8608dc93816b685f96a43b27cbd351e77c6": {
      "type": "Ybodychange",
      "commitMessage": "Test DateTimeFormat styles and patterns\nAdd ability to print time zone ids\n\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@690 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1\n",
      "commitDate": "2/13/05, 9:12 AM",
      "commitName": "eac6e8608dc93816b685f96a43b27cbd351e77c6",
      "commitAuthor": "Stephen Colebourne",
      "commitDateOld": "2/12/05, 6:39 PM",
      "commitNameOld": "5082337a4152e04ebd8077fd0b7fa28113a4d79e",
      "commitAuthorOld": "Stephen Colebourne",
      "daysBetweenCommits": 0.61,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n    int length \u003d pattern.length();\n    int[] indexRef \u003d new int[1];\n    for (int i \u003d 0; i \u003c length; i++) {\n        indexRef[0] \u003d i;\n        String token \u003d parseToken(pattern, indexRef);\n        i \u003d indexRef[0];\n        int tokenLen \u003d token.length();\n        if (tokenLen \u003d\u003d 0) {\n            break;\n        }\n        char c \u003d token.charAt(0);\n        switch(c) {\n            case \u0027G\u0027:\n                builder.appendEraText();\n                break;\n            case \u0027C\u0027:\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case \u0027x\u0027:\n            case \u0027y\u0027:\n            case \u0027Y\u0027:\n                if (tokenLen \u003d\u003d 2) {\n                    DateTimeFieldType type;\n                    switch(c) {\n                        case \u0027x\u0027:\n                            builder.appendTwoDigitWeekyear(new DateTime().getWeekyear() - 30);\n                            break;\n                        case \u0027y\u0027:\n                        case \u0027Y\u0027:\n                        default:\n                            builder.appendTwoDigitYear(new DateTime().getYear() - 30);\n                            break;\n                    }\n                } else {\n                    int maxDigits \u003d 9;\n                    if (i + 1 \u003c length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            maxDigits \u003d tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n                    switch(c) {\n                        case \u0027x\u0027:\n                            builder.appendWeekyear(tokenLen, maxDigits);\n                            break;\n                        case \u0027y\u0027:\n                            builder.appendYear(tokenLen, maxDigits);\n                            break;\n                        case \u0027Y\u0027:\n                            builder.appendYearOfEra(tokenLen, maxDigits);\n                            break;\n                    }\n                }\n                break;\n            case \u0027M\u0027:\n                if (tokenLen \u003e\u003d 3) {\n                    if (tokenLen \u003e\u003d 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case \u0027d\u0027:\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case \u0027h\u0027:\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case \u0027H\u0027:\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case \u0027m\u0027:\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case \u0027s\u0027:\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case \u0027S\u0027:\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case \u0027e\u0027:\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case \u0027E\u0027:\n                if (tokenLen \u003e\u003d 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case \u0027D\u0027:\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case \u0027w\u0027:\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case \u0027a\u0027:\n                builder.appendHalfdayOfDayText();\n                break;\n            case \u0027k\u0027:\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case \u0027K\u0027:\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case \u0027z\u0027:\n                if (tokenLen \u003e\u003d 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName();\n                }\n                break;\n            case \u0027Z\u0027:\n                if (tokenLen \u003d\u003d 1) {\n                    builder.appendTimeZoneOffset(null, false, 2, 2);\n                } else if (tokenLen \u003d\u003d 2) {\n                    builder.appendTimeZoneOffset(null, true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case \u0027\\\u0027\u0027:\n                String sub \u003d token.substring(1);\n                if (sub.length() \u003d\u003d 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n        }\n    }\n}",
      "path": "JodaTime/src/java/org/joda/time/format/DateTimeFormat.java",
      "functionStartLine": 381,
      "functionName": "parsePatternTo",
      "functionAnnotation": "",
      "functionDoc": "Parses the given pattern and appends the rules to the given\nDateTimeFormatterBuilder.\n\n@param pattern pattern specification\n@throws IllegalArgumentException if the pattern is invalid\n@see #forPattern\n",
      "diff": "@@ -1,140 +1,139 @@\n private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n     int length \u003d pattern.length();\n     int[] indexRef \u003d new int[1];\n     for (int i \u003d 0; i \u003c length; i++) {\n         indexRef[0] \u003d i;\n         String token \u003d parseToken(pattern, indexRef);\n         i \u003d indexRef[0];\n         int tokenLen \u003d token.length();\n         if (tokenLen \u003d\u003d 0) {\n             break;\n         }\n         char c \u003d token.charAt(0);\n         switch(c) {\n             case \u0027G\u0027:\n                 builder.appendEraText();\n                 break;\n             case \u0027C\u0027:\n                 builder.appendCenturyOfEra(tokenLen, tokenLen);\n                 break;\n             case \u0027x\u0027:\n             case \u0027y\u0027:\n             case \u0027Y\u0027:\n                 if (tokenLen \u003d\u003d 2) {\n                     DateTimeFieldType type;\n                     switch(c) {\n                         case \u0027x\u0027:\n-                            type \u003d new RemainderType(DateTimeFieldType.weekyear(), DateTimeFieldType.weekyearOfCentury(), 100);\n+                            builder.appendTwoDigitWeekyear(new DateTime().getWeekyear() - 30);\n                             break;\n                         case \u0027y\u0027:\n-                        default:\n-                            type \u003d new RemainderType(DateTimeFieldType.year(), DateTimeFieldType.yearOfCentury(), 100);\n-                            break;\n                         case \u0027Y\u0027:\n-                            type \u003d new RemainderType(DateTimeFieldType.yearOfEra(), DateTimeFieldType.yearOfCentury(), 100);\n+                        default:\n+                            builder.appendTwoDigitYear(new DateTime().getYear() - 30);\n                             break;\n                     }\n-                    builder.appendDecimal(type, 2, 2);\n                 } else {\n                     int maxDigits \u003d 9;\n                     if (i + 1 \u003c length) {\n                         indexRef[0]++;\n                         if (isNumericToken(parseToken(pattern, indexRef))) {\n                             maxDigits \u003d tokenLen;\n                         }\n                         indexRef[0]--;\n                     }\n                     switch(c) {\n                         case \u0027x\u0027:\n                             builder.appendWeekyear(tokenLen, maxDigits);\n                             break;\n                         case \u0027y\u0027:\n                             builder.appendYear(tokenLen, maxDigits);\n                             break;\n                         case \u0027Y\u0027:\n                             builder.appendYearOfEra(tokenLen, maxDigits);\n                             break;\n                     }\n                 }\n                 break;\n             case \u0027M\u0027:\n                 if (tokenLen \u003e\u003d 3) {\n                     if (tokenLen \u003e\u003d 4) {\n                         builder.appendMonthOfYearText();\n                     } else {\n                         builder.appendMonthOfYearShortText();\n                     }\n                 } else {\n                     builder.appendMonthOfYear(tokenLen);\n                 }\n                 break;\n             case \u0027d\u0027:\n                 builder.appendDayOfMonth(tokenLen);\n                 break;\n             case \u0027h\u0027:\n                 builder.appendClockhourOfHalfday(tokenLen);\n                 break;\n             case \u0027H\u0027:\n                 builder.appendHourOfDay(tokenLen);\n                 break;\n             case \u0027m\u0027:\n                 builder.appendMinuteOfHour(tokenLen);\n                 break;\n             case \u0027s\u0027:\n                 builder.appendSecondOfMinute(tokenLen);\n                 break;\n             case \u0027S\u0027:\n                 builder.appendFractionOfSecond(tokenLen, tokenLen);\n                 break;\n             case \u0027e\u0027:\n                 builder.appendDayOfWeek(tokenLen);\n                 break;\n             case \u0027E\u0027:\n                 if (tokenLen \u003e\u003d 4) {\n                     builder.appendDayOfWeekText();\n                 } else {\n                     builder.appendDayOfWeekShortText();\n                 }\n                 break;\n             case \u0027D\u0027:\n                 builder.appendDayOfYear(tokenLen);\n                 break;\n             case \u0027w\u0027:\n                 builder.appendWeekOfWeekyear(tokenLen);\n                 break;\n             case \u0027a\u0027:\n                 builder.appendHalfdayOfDayText();\n                 break;\n             case \u0027k\u0027:\n                 builder.appendClockhourOfDay(tokenLen);\n                 break;\n             case \u0027K\u0027:\n                 builder.appendClockhourOfHalfday(tokenLen);\n                 break;\n             case \u0027z\u0027:\n                 if (tokenLen \u003e\u003d 4) {\n                     builder.appendTimeZoneName();\n                 } else {\n                     builder.appendTimeZoneShortName();\n                 }\n                 break;\n             case \u0027Z\u0027:\n-                if (tokenLen \u003e\u003d 4) {\n+                if (tokenLen \u003d\u003d 1) {\n+                    builder.appendTimeZoneOffset(null, false, 2, 2);\n+                } else if (tokenLen \u003d\u003d 2) {\n                     builder.appendTimeZoneOffset(null, true, 2, 2);\n                 } else {\n-                    builder.appendTimeZoneOffset(null, false, 2, 2);\n+                    builder.appendTimeZoneId();\n                 }\n                 break;\n             case \u0027\\\u0027\u0027:\n                 String sub \u003d token.substring(1);\n                 if (sub.length() \u003d\u003d 1) {\n                     builder.appendLiteral(sub.charAt(0));\n                 } else {\n                     builder.appendLiteral(new String(sub));\n                 }\n                 break;\n             default:\n                 throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5082337a4152e04ebd8077fd0b7fa28113a4d79e": {
      "type": "Ymultichange(Yrename,Ymodifierchange)",
      "commitMessage": "Refactor DateTime formatting to use decoration pattern\n\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@687 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1\n",
      "commitDate": "2/12/05, 6:39 PM",
      "commitName": "5082337a4152e04ebd8077fd0b7fa28113a4d79e",
      "commitAuthor": "Stephen Colebourne",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "Refactor DateTime formatting to use decoration pattern\n\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@687 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1\n",
          "commitDate": "2/12/05, 6:39 PM",
          "commitName": "5082337a4152e04ebd8077fd0b7fa28113a4d79e",
          "commitAuthor": "Stephen Colebourne",
          "commitDateOld": "2/12/05, 3:28 PM",
          "commitNameOld": "28108d2dd6ba602f2b3d328045e74a3d2bf2d0a9",
          "commitAuthorOld": "Stephen Colebourne",
          "daysBetweenCommits": 0.13,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "actualSource": "private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n    int length \u003d pattern.length();\n    int[] indexRef \u003d new int[1];\n    for (int i \u003d 0; i \u003c length; i++) {\n        indexRef[0] \u003d i;\n        String token \u003d parseToken(pattern, indexRef);\n        i \u003d indexRef[0];\n        int tokenLen \u003d token.length();\n        if (tokenLen \u003d\u003d 0) {\n            break;\n        }\n        char c \u003d token.charAt(0);\n        switch(c) {\n            case \u0027G\u0027:\n                builder.appendEraText();\n                break;\n            case \u0027C\u0027:\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case \u0027x\u0027:\n            case \u0027y\u0027:\n            case \u0027Y\u0027:\n                if (tokenLen \u003d\u003d 2) {\n                    DateTimeFieldType type;\n                    switch(c) {\n                        case \u0027x\u0027:\n                            type \u003d new RemainderType(DateTimeFieldType.weekyear(), DateTimeFieldType.weekyearOfCentury(), 100);\n                            break;\n                        case \u0027y\u0027:\n                        default:\n                            type \u003d new RemainderType(DateTimeFieldType.year(), DateTimeFieldType.yearOfCentury(), 100);\n                            break;\n                        case \u0027Y\u0027:\n                            type \u003d new RemainderType(DateTimeFieldType.yearOfEra(), DateTimeFieldType.yearOfCentury(), 100);\n                            break;\n                    }\n                    builder.appendDecimal(type, 2, 2);\n                } else {\n                    int maxDigits \u003d 9;\n                    if (i + 1 \u003c length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            maxDigits \u003d tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n                    switch(c) {\n                        case \u0027x\u0027:\n                            builder.appendWeekyear(tokenLen, maxDigits);\n                            break;\n                        case \u0027y\u0027:\n                            builder.appendYear(tokenLen, maxDigits);\n                            break;\n                        case \u0027Y\u0027:\n                            builder.appendYearOfEra(tokenLen, maxDigits);\n                            break;\n                    }\n                }\n                break;\n            case \u0027M\u0027:\n                if (tokenLen \u003e\u003d 3) {\n                    if (tokenLen \u003e\u003d 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case \u0027d\u0027:\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case \u0027h\u0027:\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case \u0027H\u0027:\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case \u0027m\u0027:\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case \u0027s\u0027:\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case \u0027S\u0027:\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case \u0027e\u0027:\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case \u0027E\u0027:\n                if (tokenLen \u003e\u003d 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case \u0027D\u0027:\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case \u0027w\u0027:\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case \u0027a\u0027:\n                builder.appendHalfdayOfDayText();\n                break;\n            case \u0027k\u0027:\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case \u0027K\u0027:\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case \u0027z\u0027:\n                if (tokenLen \u003e\u003d 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName();\n                }\n                break;\n            case \u0027Z\u0027:\n                if (tokenLen \u003e\u003d 4) {\n                    builder.appendTimeZoneOffset(null, true, 2, 2);\n                } else {\n                    builder.appendTimeZoneOffset(null, false, 2, 2);\n                }\n                break;\n            case \u0027\\\u0027\u0027:\n                String sub \u003d token.substring(1);\n                if (sub.length() \u003d\u003d 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n        }\n    }\n}",
          "path": "JodaTime/src/java/org/joda/time/format/DateTimeFormat.java",
          "functionStartLine": 368,
          "functionName": "parsePatternTo",
          "functionAnnotation": "",
          "functionDoc": "Parses the given pattern and appends the rules to the given\nDateTimeFormatterBuilder.\n\n@param pattern pattern specification\n@throws IllegalArgumentException if the pattern is invalid\n@see #forPattern\n",
          "diff": "@@ -1,140 +1,140 @@\n-public static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern) {\n+private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n     int length \u003d pattern.length();\n     int[] indexRef \u003d new int[1];\n     for (int i \u003d 0; i \u003c length; i++) {\n         indexRef[0] \u003d i;\n         String token \u003d parseToken(pattern, indexRef);\n         i \u003d indexRef[0];\n         int tokenLen \u003d token.length();\n         if (tokenLen \u003d\u003d 0) {\n             break;\n         }\n         char c \u003d token.charAt(0);\n         switch(c) {\n             case \u0027G\u0027:\n                 builder.appendEraText();\n                 break;\n             case \u0027C\u0027:\n                 builder.appendCenturyOfEra(tokenLen, tokenLen);\n                 break;\n             case \u0027x\u0027:\n             case \u0027y\u0027:\n             case \u0027Y\u0027:\n                 if (tokenLen \u003d\u003d 2) {\n                     DateTimeFieldType type;\n                     switch(c) {\n                         case \u0027x\u0027:\n                             type \u003d new RemainderType(DateTimeFieldType.weekyear(), DateTimeFieldType.weekyearOfCentury(), 100);\n                             break;\n                         case \u0027y\u0027:\n                         default:\n                             type \u003d new RemainderType(DateTimeFieldType.year(), DateTimeFieldType.yearOfCentury(), 100);\n                             break;\n                         case \u0027Y\u0027:\n                             type \u003d new RemainderType(DateTimeFieldType.yearOfEra(), DateTimeFieldType.yearOfCentury(), 100);\n                             break;\n                     }\n                     builder.appendDecimal(type, 2, 2);\n                 } else {\n                     int maxDigits \u003d 9;\n                     if (i + 1 \u003c length) {\n                         indexRef[0]++;\n                         if (isNumericToken(parseToken(pattern, indexRef))) {\n                             maxDigits \u003d tokenLen;\n                         }\n                         indexRef[0]--;\n                     }\n                     switch(c) {\n                         case \u0027x\u0027:\n                             builder.appendWeekyear(tokenLen, maxDigits);\n                             break;\n                         case \u0027y\u0027:\n                             builder.appendYear(tokenLen, maxDigits);\n                             break;\n                         case \u0027Y\u0027:\n                             builder.appendYearOfEra(tokenLen, maxDigits);\n                             break;\n                     }\n                 }\n                 break;\n             case \u0027M\u0027:\n                 if (tokenLen \u003e\u003d 3) {\n                     if (tokenLen \u003e\u003d 4) {\n                         builder.appendMonthOfYearText();\n                     } else {\n                         builder.appendMonthOfYearShortText();\n                     }\n                 } else {\n                     builder.appendMonthOfYear(tokenLen);\n                 }\n                 break;\n             case \u0027d\u0027:\n                 builder.appendDayOfMonth(tokenLen);\n                 break;\n             case \u0027h\u0027:\n                 builder.appendClockhourOfHalfday(tokenLen);\n                 break;\n             case \u0027H\u0027:\n                 builder.appendHourOfDay(tokenLen);\n                 break;\n             case \u0027m\u0027:\n                 builder.appendMinuteOfHour(tokenLen);\n                 break;\n             case \u0027s\u0027:\n                 builder.appendSecondOfMinute(tokenLen);\n                 break;\n             case \u0027S\u0027:\n                 builder.appendFractionOfSecond(tokenLen, tokenLen);\n                 break;\n             case \u0027e\u0027:\n                 builder.appendDayOfWeek(tokenLen);\n                 break;\n             case \u0027E\u0027:\n                 if (tokenLen \u003e\u003d 4) {\n                     builder.appendDayOfWeekText();\n                 } else {\n                     builder.appendDayOfWeekShortText();\n                 }\n                 break;\n             case \u0027D\u0027:\n                 builder.appendDayOfYear(tokenLen);\n                 break;\n             case \u0027w\u0027:\n                 builder.appendWeekOfWeekyear(tokenLen);\n                 break;\n             case \u0027a\u0027:\n                 builder.appendHalfdayOfDayText();\n                 break;\n             case \u0027k\u0027:\n                 builder.appendClockhourOfDay(tokenLen);\n                 break;\n             case \u0027K\u0027:\n                 builder.appendClockhourOfHalfday(tokenLen);\n                 break;\n             case \u0027z\u0027:\n                 if (tokenLen \u003e\u003d 4) {\n                     builder.appendTimeZoneName();\n                 } else {\n                     builder.appendTimeZoneShortName();\n                 }\n                 break;\n             case \u0027Z\u0027:\n                 if (tokenLen \u003e\u003d 4) {\n                     builder.appendTimeZoneOffset(null, true, 2, 2);\n                 } else {\n                     builder.appendTimeZoneOffset(null, false, 2, 2);\n                 }\n                 break;\n             case \u0027\\\u0027\u0027:\n                 String sub \u003d token.substring(1);\n                 if (sub.length() \u003d\u003d 1) {\n                     builder.appendLiteral(sub.charAt(0));\n                 } else {\n                     builder.appendLiteral(new String(sub));\n                 }\n                 break;\n             default:\n                 throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "appendPatternTo",
            "newValue": "parsePatternTo"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "Refactor DateTime formatting to use decoration pattern\n\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@687 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1\n",
          "commitDate": "2/12/05, 6:39 PM",
          "commitName": "5082337a4152e04ebd8077fd0b7fa28113a4d79e",
          "commitAuthor": "Stephen Colebourne",
          "commitDateOld": "2/12/05, 3:28 PM",
          "commitNameOld": "28108d2dd6ba602f2b3d328045e74a3d2bf2d0a9",
          "commitAuthorOld": "Stephen Colebourne",
          "daysBetweenCommits": 0.13,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "actualSource": "private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n    int length \u003d pattern.length();\n    int[] indexRef \u003d new int[1];\n    for (int i \u003d 0; i \u003c length; i++) {\n        indexRef[0] \u003d i;\n        String token \u003d parseToken(pattern, indexRef);\n        i \u003d indexRef[0];\n        int tokenLen \u003d token.length();\n        if (tokenLen \u003d\u003d 0) {\n            break;\n        }\n        char c \u003d token.charAt(0);\n        switch(c) {\n            case \u0027G\u0027:\n                builder.appendEraText();\n                break;\n            case \u0027C\u0027:\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case \u0027x\u0027:\n            case \u0027y\u0027:\n            case \u0027Y\u0027:\n                if (tokenLen \u003d\u003d 2) {\n                    DateTimeFieldType type;\n                    switch(c) {\n                        case \u0027x\u0027:\n                            type \u003d new RemainderType(DateTimeFieldType.weekyear(), DateTimeFieldType.weekyearOfCentury(), 100);\n                            break;\n                        case \u0027y\u0027:\n                        default:\n                            type \u003d new RemainderType(DateTimeFieldType.year(), DateTimeFieldType.yearOfCentury(), 100);\n                            break;\n                        case \u0027Y\u0027:\n                            type \u003d new RemainderType(DateTimeFieldType.yearOfEra(), DateTimeFieldType.yearOfCentury(), 100);\n                            break;\n                    }\n                    builder.appendDecimal(type, 2, 2);\n                } else {\n                    int maxDigits \u003d 9;\n                    if (i + 1 \u003c length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            maxDigits \u003d tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n                    switch(c) {\n                        case \u0027x\u0027:\n                            builder.appendWeekyear(tokenLen, maxDigits);\n                            break;\n                        case \u0027y\u0027:\n                            builder.appendYear(tokenLen, maxDigits);\n                            break;\n                        case \u0027Y\u0027:\n                            builder.appendYearOfEra(tokenLen, maxDigits);\n                            break;\n                    }\n                }\n                break;\n            case \u0027M\u0027:\n                if (tokenLen \u003e\u003d 3) {\n                    if (tokenLen \u003e\u003d 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case \u0027d\u0027:\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case \u0027h\u0027:\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case \u0027H\u0027:\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case \u0027m\u0027:\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case \u0027s\u0027:\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case \u0027S\u0027:\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case \u0027e\u0027:\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case \u0027E\u0027:\n                if (tokenLen \u003e\u003d 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case \u0027D\u0027:\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case \u0027w\u0027:\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case \u0027a\u0027:\n                builder.appendHalfdayOfDayText();\n                break;\n            case \u0027k\u0027:\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case \u0027K\u0027:\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case \u0027z\u0027:\n                if (tokenLen \u003e\u003d 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName();\n                }\n                break;\n            case \u0027Z\u0027:\n                if (tokenLen \u003e\u003d 4) {\n                    builder.appendTimeZoneOffset(null, true, 2, 2);\n                } else {\n                    builder.appendTimeZoneOffset(null, false, 2, 2);\n                }\n                break;\n            case \u0027\\\u0027\u0027:\n                String sub \u003d token.substring(1);\n                if (sub.length() \u003d\u003d 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n        }\n    }\n}",
          "path": "JodaTime/src/java/org/joda/time/format/DateTimeFormat.java",
          "functionStartLine": 368,
          "functionName": "parsePatternTo",
          "functionAnnotation": "",
          "functionDoc": "Parses the given pattern and appends the rules to the given\nDateTimeFormatterBuilder.\n\n@param pattern pattern specification\n@throws IllegalArgumentException if the pattern is invalid\n@see #forPattern\n",
          "diff": "@@ -1,140 +1,140 @@\n-public static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern) {\n+private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n     int length \u003d pattern.length();\n     int[] indexRef \u003d new int[1];\n     for (int i \u003d 0; i \u003c length; i++) {\n         indexRef[0] \u003d i;\n         String token \u003d parseToken(pattern, indexRef);\n         i \u003d indexRef[0];\n         int tokenLen \u003d token.length();\n         if (tokenLen \u003d\u003d 0) {\n             break;\n         }\n         char c \u003d token.charAt(0);\n         switch(c) {\n             case \u0027G\u0027:\n                 builder.appendEraText();\n                 break;\n             case \u0027C\u0027:\n                 builder.appendCenturyOfEra(tokenLen, tokenLen);\n                 break;\n             case \u0027x\u0027:\n             case \u0027y\u0027:\n             case \u0027Y\u0027:\n                 if (tokenLen \u003d\u003d 2) {\n                     DateTimeFieldType type;\n                     switch(c) {\n                         case \u0027x\u0027:\n                             type \u003d new RemainderType(DateTimeFieldType.weekyear(), DateTimeFieldType.weekyearOfCentury(), 100);\n                             break;\n                         case \u0027y\u0027:\n                         default:\n                             type \u003d new RemainderType(DateTimeFieldType.year(), DateTimeFieldType.yearOfCentury(), 100);\n                             break;\n                         case \u0027Y\u0027:\n                             type \u003d new RemainderType(DateTimeFieldType.yearOfEra(), DateTimeFieldType.yearOfCentury(), 100);\n                             break;\n                     }\n                     builder.appendDecimal(type, 2, 2);\n                 } else {\n                     int maxDigits \u003d 9;\n                     if (i + 1 \u003c length) {\n                         indexRef[0]++;\n                         if (isNumericToken(parseToken(pattern, indexRef))) {\n                             maxDigits \u003d tokenLen;\n                         }\n                         indexRef[0]--;\n                     }\n                     switch(c) {\n                         case \u0027x\u0027:\n                             builder.appendWeekyear(tokenLen, maxDigits);\n                             break;\n                         case \u0027y\u0027:\n                             builder.appendYear(tokenLen, maxDigits);\n                             break;\n                         case \u0027Y\u0027:\n                             builder.appendYearOfEra(tokenLen, maxDigits);\n                             break;\n                     }\n                 }\n                 break;\n             case \u0027M\u0027:\n                 if (tokenLen \u003e\u003d 3) {\n                     if (tokenLen \u003e\u003d 4) {\n                         builder.appendMonthOfYearText();\n                     } else {\n                         builder.appendMonthOfYearShortText();\n                     }\n                 } else {\n                     builder.appendMonthOfYear(tokenLen);\n                 }\n                 break;\n             case \u0027d\u0027:\n                 builder.appendDayOfMonth(tokenLen);\n                 break;\n             case \u0027h\u0027:\n                 builder.appendClockhourOfHalfday(tokenLen);\n                 break;\n             case \u0027H\u0027:\n                 builder.appendHourOfDay(tokenLen);\n                 break;\n             case \u0027m\u0027:\n                 builder.appendMinuteOfHour(tokenLen);\n                 break;\n             case \u0027s\u0027:\n                 builder.appendSecondOfMinute(tokenLen);\n                 break;\n             case \u0027S\u0027:\n                 builder.appendFractionOfSecond(tokenLen, tokenLen);\n                 break;\n             case \u0027e\u0027:\n                 builder.appendDayOfWeek(tokenLen);\n                 break;\n             case \u0027E\u0027:\n                 if (tokenLen \u003e\u003d 4) {\n                     builder.appendDayOfWeekText();\n                 } else {\n                     builder.appendDayOfWeekShortText();\n                 }\n                 break;\n             case \u0027D\u0027:\n                 builder.appendDayOfYear(tokenLen);\n                 break;\n             case \u0027w\u0027:\n                 builder.appendWeekOfWeekyear(tokenLen);\n                 break;\n             case \u0027a\u0027:\n                 builder.appendHalfdayOfDayText();\n                 break;\n             case \u0027k\u0027:\n                 builder.appendClockhourOfDay(tokenLen);\n                 break;\n             case \u0027K\u0027:\n                 builder.appendClockhourOfHalfday(tokenLen);\n                 break;\n             case \u0027z\u0027:\n                 if (tokenLen \u003e\u003d 4) {\n                     builder.appendTimeZoneName();\n                 } else {\n                     builder.appendTimeZoneShortName();\n                 }\n                 break;\n             case \u0027Z\u0027:\n                 if (tokenLen \u003e\u003d 4) {\n                     builder.appendTimeZoneOffset(null, true, 2, 2);\n                 } else {\n                     builder.appendTimeZoneOffset(null, false, 2, 2);\n                 }\n                 break;\n             case \u0027\\\u0027\u0027:\n                 String sub \u003d token.substring(1);\n                 if (sub.length() \u003d\u003d 1) {\n                     builder.appendLiteral(sub.charAt(0));\n                 } else {\n                     builder.appendLiteral(new String(sub));\n                 }\n                 break;\n             default:\n                 throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[public, static]",
            "newValue": "[private, static]"
          }
        }
      ]
    },
    "9316fce1b432caa8b56ff6056d916f0a0aaefc1a": {
      "type": "Ybodychange",
      "commitMessage": "Use DateTimeFieldType for custom fields\n\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@504 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1\n",
      "commitDate": "9/11/04, 4:30 PM",
      "commitName": "9316fce1b432caa8b56ff6056d916f0a0aaefc1a",
      "commitAuthor": "Brian S O\u0027Neill",
      "commitDateOld": "9/2/04, 3:47 PM",
      "commitNameOld": "0d18055d0b3c2e687197a8651b3a06e097fe5c48",
      "commitAuthorOld": "Stephen Colebourne",
      "daysBetweenCommits": 9.03,
      "commitsBetweenForRepo": 36,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern) {\n    int length \u003d pattern.length();\n    int[] indexRef \u003d new int[1];\n    for (int i \u003d 0; i \u003c length; i++) {\n        indexRef[0] \u003d i;\n        String token \u003d parseToken(pattern, indexRef);\n        i \u003d indexRef[0];\n        int tokenLen \u003d token.length();\n        if (tokenLen \u003d\u003d 0) {\n            break;\n        }\n        char c \u003d token.charAt(0);\n        switch(c) {\n            case \u0027G\u0027:\n                builder.appendEraText();\n                break;\n            case \u0027C\u0027:\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case \u0027x\u0027:\n            case \u0027y\u0027:\n            case \u0027Y\u0027:\n                if (tokenLen \u003d\u003d 2) {\n                    DateTimeFieldType type;\n                    switch(c) {\n                        case \u0027x\u0027:\n                            type \u003d new RemainderType(DateTimeFieldType.weekyear(), DateTimeFieldType.weekyearOfCentury(), 100);\n                            break;\n                        case \u0027y\u0027:\n                        default:\n                            type \u003d new RemainderType(DateTimeFieldType.year(), DateTimeFieldType.yearOfCentury(), 100);\n                            break;\n                        case \u0027Y\u0027:\n                            type \u003d new RemainderType(DateTimeFieldType.yearOfEra(), DateTimeFieldType.yearOfCentury(), 100);\n                            break;\n                    }\n                    builder.appendDecimal(type, 2, 2);\n                } else {\n                    int maxDigits \u003d 9;\n                    if (i + 1 \u003c length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            maxDigits \u003d tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n                    switch(c) {\n                        case \u0027x\u0027:\n                            builder.appendWeekyear(tokenLen, maxDigits);\n                            break;\n                        case \u0027y\u0027:\n                            builder.appendYear(tokenLen, maxDigits);\n                            break;\n                        case \u0027Y\u0027:\n                            builder.appendYearOfEra(tokenLen, maxDigits);\n                            break;\n                    }\n                }\n                break;\n            case \u0027M\u0027:\n                if (tokenLen \u003e\u003d 3) {\n                    if (tokenLen \u003e\u003d 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case \u0027d\u0027:\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case \u0027h\u0027:\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case \u0027H\u0027:\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case \u0027m\u0027:\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case \u0027s\u0027:\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case \u0027S\u0027:\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case \u0027e\u0027:\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case \u0027E\u0027:\n                if (tokenLen \u003e\u003d 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case \u0027D\u0027:\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case \u0027w\u0027:\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case \u0027a\u0027:\n                builder.appendHalfdayOfDayText();\n                break;\n            case \u0027k\u0027:\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case \u0027K\u0027:\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case \u0027z\u0027:\n                if (tokenLen \u003e\u003d 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName();\n                }\n                break;\n            case \u0027Z\u0027:\n                if (tokenLen \u003e\u003d 4) {\n                    builder.appendTimeZoneOffset(null, true, 2, 2);\n                } else {\n                    builder.appendTimeZoneOffset(null, false, 2, 2);\n                }\n                break;\n            case \u0027\\\u0027\u0027:\n                String sub \u003d token.substring(1);\n                if (sub.length() \u003d\u003d 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n        }\n    }\n}",
      "path": "JodaTime/src/java/org/joda/time/format/DateTimeFormat.java",
      "functionStartLine": 261,
      "functionName": "appendPatternTo",
      "functionAnnotation": "",
      "functionDoc": "Parses the given pattern and appends the rules to the given\nDateTimeFormatterBuilder.\n\n@param pattern pattern specification\n@throws IllegalArgumentException if the pattern is invalid\n@see #forPattern\n",
      "diff": "@@ -1,141 +1,140 @@\n public static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern) {\n     int length \u003d pattern.length();\n     int[] indexRef \u003d new int[1];\n     for (int i \u003d 0; i \u003c length; i++) {\n         indexRef[0] \u003d i;\n         String token \u003d parseToken(pattern, indexRef);\n         i \u003d indexRef[0];\n         int tokenLen \u003d token.length();\n         if (tokenLen \u003d\u003d 0) {\n             break;\n         }\n         char c \u003d token.charAt(0);\n         switch(c) {\n             case \u0027G\u0027:\n                 builder.appendEraText();\n                 break;\n             case \u0027C\u0027:\n                 builder.appendCenturyOfEra(tokenLen, tokenLen);\n                 break;\n             case \u0027x\u0027:\n             case \u0027y\u0027:\n             case \u0027Y\u0027:\n                 if (tokenLen \u003d\u003d 2) {\n-                    DateTimeField field;\n-                    Chronology chronoUTC \u003d builder.getChronology().withUTC();\n+                    DateTimeFieldType type;\n                     switch(c) {\n                         case \u0027x\u0027:\n-                            field \u003d new RemainderDateTimeField(chronoUTC.weekyear(), DateTimeFieldType.weekyearOfCentury(), 100);\n+                            type \u003d new RemainderType(DateTimeFieldType.weekyear(), DateTimeFieldType.weekyearOfCentury(), 100);\n                             break;\n                         case \u0027y\u0027:\n                         default:\n-                            field \u003d new RemainderDateTimeField(chronoUTC.year(), DateTimeFieldType.yearOfCentury(), 100);\n+                            type \u003d new RemainderType(DateTimeFieldType.year(), DateTimeFieldType.yearOfCentury(), 100);\n                             break;\n                         case \u0027Y\u0027:\n-                            field \u003d new RemainderDateTimeField(chronoUTC.yearOfEra(), DateTimeFieldType.yearOfCentury(), 100);\n+                            type \u003d new RemainderType(DateTimeFieldType.yearOfEra(), DateTimeFieldType.yearOfCentury(), 100);\n                             break;\n                     }\n-                    builder.appendDecimal(field, 2, 2);\n+                    builder.appendDecimal(type, 2, 2);\n                 } else {\n                     int maxDigits \u003d 9;\n                     if (i + 1 \u003c length) {\n                         indexRef[0]++;\n                         if (isNumericToken(parseToken(pattern, indexRef))) {\n                             maxDigits \u003d tokenLen;\n                         }\n                         indexRef[0]--;\n                     }\n                     switch(c) {\n                         case \u0027x\u0027:\n                             builder.appendWeekyear(tokenLen, maxDigits);\n                             break;\n                         case \u0027y\u0027:\n                             builder.appendYear(tokenLen, maxDigits);\n                             break;\n                         case \u0027Y\u0027:\n                             builder.appendYearOfEra(tokenLen, maxDigits);\n                             break;\n                     }\n                 }\n                 break;\n             case \u0027M\u0027:\n                 if (tokenLen \u003e\u003d 3) {\n                     if (tokenLen \u003e\u003d 4) {\n                         builder.appendMonthOfYearText();\n                     } else {\n                         builder.appendMonthOfYearShortText();\n                     }\n                 } else {\n                     builder.appendMonthOfYear(tokenLen);\n                 }\n                 break;\n             case \u0027d\u0027:\n                 builder.appendDayOfMonth(tokenLen);\n                 break;\n             case \u0027h\u0027:\n                 builder.appendClockhourOfHalfday(tokenLen);\n                 break;\n             case \u0027H\u0027:\n                 builder.appendHourOfDay(tokenLen);\n                 break;\n             case \u0027m\u0027:\n                 builder.appendMinuteOfHour(tokenLen);\n                 break;\n             case \u0027s\u0027:\n                 builder.appendSecondOfMinute(tokenLen);\n                 break;\n             case \u0027S\u0027:\n                 builder.appendFractionOfSecond(tokenLen, tokenLen);\n                 break;\n             case \u0027e\u0027:\n                 builder.appendDayOfWeek(tokenLen);\n                 break;\n             case \u0027E\u0027:\n                 if (tokenLen \u003e\u003d 4) {\n                     builder.appendDayOfWeekText();\n                 } else {\n                     builder.appendDayOfWeekShortText();\n                 }\n                 break;\n             case \u0027D\u0027:\n                 builder.appendDayOfYear(tokenLen);\n                 break;\n             case \u0027w\u0027:\n                 builder.appendWeekOfWeekyear(tokenLen);\n                 break;\n             case \u0027a\u0027:\n                 builder.appendHalfdayOfDayText();\n                 break;\n             case \u0027k\u0027:\n                 builder.appendClockhourOfDay(tokenLen);\n                 break;\n             case \u0027K\u0027:\n                 builder.appendClockhourOfHalfday(tokenLen);\n                 break;\n             case \u0027z\u0027:\n                 if (tokenLen \u003e\u003d 4) {\n                     builder.appendTimeZoneName();\n                 } else {\n                     builder.appendTimeZoneShortName();\n                 }\n                 break;\n             case \u0027Z\u0027:\n                 if (tokenLen \u003e\u003d 4) {\n                     builder.appendTimeZoneOffset(null, true, 2, 2);\n                 } else {\n                     builder.appendTimeZoneOffset(null, false, 2, 2);\n                 }\n                 break;\n             case \u0027\\\u0027\u0027:\n                 String sub \u003d token.substring(1);\n                 if (sub.length() \u003d\u003d 1) {\n                     builder.appendLiteral(sub.charAt(0));\n                 } else {\n                     builder.appendLiteral(new String(sub));\n                 }\n                 break;\n             default:\n                 throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0d18055d0b3c2e687197a8651b3a06e097fe5c48": {
      "type": "Ybodychange",
      "commitMessage": "Use DurationFieldType in DurationField\n\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@468 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1\n",
      "commitDate": "9/2/04, 3:47 PM",
      "commitName": "0d18055d0b3c2e687197a8651b3a06e097fe5c48",
      "commitAuthor": "Stephen Colebourne",
      "commitDateOld": "9/2/04, 2:40 PM",
      "commitNameOld": "4f78ec4d836c5aa1a1706eaf9c75a6e5c41d1d16",
      "commitAuthorOld": "Stephen Colebourne",
      "daysBetweenCommits": 0.05,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern) {\n    int length \u003d pattern.length();\n    int[] indexRef \u003d new int[1];\n    for (int i \u003d 0; i \u003c length; i++) {\n        indexRef[0] \u003d i;\n        String token \u003d parseToken(pattern, indexRef);\n        i \u003d indexRef[0];\n        int tokenLen \u003d token.length();\n        if (tokenLen \u003d\u003d 0) {\n            break;\n        }\n        char c \u003d token.charAt(0);\n        switch(c) {\n            case \u0027G\u0027:\n                builder.appendEraText();\n                break;\n            case \u0027C\u0027:\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case \u0027x\u0027:\n            case \u0027y\u0027:\n            case \u0027Y\u0027:\n                if (tokenLen \u003d\u003d 2) {\n                    DateTimeField field;\n                    Chronology chronoUTC \u003d builder.getChronology().withUTC();\n                    switch(c) {\n                        case \u0027x\u0027:\n                            field \u003d new RemainderDateTimeField(chronoUTC.weekyear(), DateTimeFieldType.weekyearOfCentury(), 100);\n                            break;\n                        case \u0027y\u0027:\n                        default:\n                            field \u003d new RemainderDateTimeField(chronoUTC.year(), DateTimeFieldType.yearOfCentury(), 100);\n                            break;\n                        case \u0027Y\u0027:\n                            field \u003d new RemainderDateTimeField(chronoUTC.yearOfEra(), DateTimeFieldType.yearOfCentury(), 100);\n                            break;\n                    }\n                    builder.appendDecimal(field, 2, 2);\n                } else {\n                    int maxDigits \u003d 9;\n                    if (i + 1 \u003c length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            maxDigits \u003d tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n                    switch(c) {\n                        case \u0027x\u0027:\n                            builder.appendWeekyear(tokenLen, maxDigits);\n                            break;\n                        case \u0027y\u0027:\n                            builder.appendYear(tokenLen, maxDigits);\n                            break;\n                        case \u0027Y\u0027:\n                            builder.appendYearOfEra(tokenLen, maxDigits);\n                            break;\n                    }\n                }\n                break;\n            case \u0027M\u0027:\n                if (tokenLen \u003e\u003d 3) {\n                    if (tokenLen \u003e\u003d 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case \u0027d\u0027:\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case \u0027h\u0027:\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case \u0027H\u0027:\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case \u0027m\u0027:\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case \u0027s\u0027:\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case \u0027S\u0027:\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case \u0027e\u0027:\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case \u0027E\u0027:\n                if (tokenLen \u003e\u003d 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case \u0027D\u0027:\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case \u0027w\u0027:\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case \u0027a\u0027:\n                builder.appendHalfdayOfDayText();\n                break;\n            case \u0027k\u0027:\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case \u0027K\u0027:\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case \u0027z\u0027:\n                if (tokenLen \u003e\u003d 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName();\n                }\n                break;\n            case \u0027Z\u0027:\n                if (tokenLen \u003e\u003d 4) {\n                    builder.appendTimeZoneOffset(null, true, 2, 2);\n                } else {\n                    builder.appendTimeZoneOffset(null, false, 2, 2);\n                }\n                break;\n            case \u0027\\\u0027\u0027:\n                String sub \u003d token.substring(1);\n                if (sub.length() \u003d\u003d 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n        }\n    }\n}",
      "path": "JodaTime/src/java/org/joda/time/format/DateTimeFormat.java",
      "functionStartLine": 260,
      "functionName": "appendPatternTo",
      "functionAnnotation": "",
      "functionDoc": "Parses the given pattern and appends the rules to the given\nDateTimeFormatterBuilder.\n\n@param pattern pattern specification\n@throws IllegalArgumentException if the pattern is invalid\n@see #forPattern\n",
      "diff": "@@ -1,141 +1,141 @@\n public static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern) {\n     int length \u003d pattern.length();\n     int[] indexRef \u003d new int[1];\n     for (int i \u003d 0; i \u003c length; i++) {\n         indexRef[0] \u003d i;\n         String token \u003d parseToken(pattern, indexRef);\n         i \u003d indexRef[0];\n         int tokenLen \u003d token.length();\n         if (tokenLen \u003d\u003d 0) {\n             break;\n         }\n         char c \u003d token.charAt(0);\n         switch(c) {\n             case \u0027G\u0027:\n                 builder.appendEraText();\n                 break;\n             case \u0027C\u0027:\n                 builder.appendCenturyOfEra(tokenLen, tokenLen);\n                 break;\n             case \u0027x\u0027:\n             case \u0027y\u0027:\n             case \u0027Y\u0027:\n                 if (tokenLen \u003d\u003d 2) {\n                     DateTimeField field;\n                     Chronology chronoUTC \u003d builder.getChronology().withUTC();\n                     switch(c) {\n                         case \u0027x\u0027:\n-                            field \u003d new RemainderDateTimeField(chronoUTC.weekyear(), DateTimeFieldType.weekyearOfCentury(), \"centuries\", 100);\n+                            field \u003d new RemainderDateTimeField(chronoUTC.weekyear(), DateTimeFieldType.weekyearOfCentury(), 100);\n                             break;\n                         case \u0027y\u0027:\n                         default:\n-                            field \u003d new RemainderDateTimeField(chronoUTC.year(), DateTimeFieldType.yearOfCentury(), \"centuries\", 100);\n+                            field \u003d new RemainderDateTimeField(chronoUTC.year(), DateTimeFieldType.yearOfCentury(), 100);\n                             break;\n                         case \u0027Y\u0027:\n-                            field \u003d new RemainderDateTimeField(chronoUTC.yearOfEra(), DateTimeFieldType.yearOfCentury(), \"centuries\", 100);\n+                            field \u003d new RemainderDateTimeField(chronoUTC.yearOfEra(), DateTimeFieldType.yearOfCentury(), 100);\n                             break;\n                     }\n                     builder.appendDecimal(field, 2, 2);\n                 } else {\n                     int maxDigits \u003d 9;\n                     if (i + 1 \u003c length) {\n                         indexRef[0]++;\n                         if (isNumericToken(parseToken(pattern, indexRef))) {\n                             maxDigits \u003d tokenLen;\n                         }\n                         indexRef[0]--;\n                     }\n                     switch(c) {\n                         case \u0027x\u0027:\n                             builder.appendWeekyear(tokenLen, maxDigits);\n                             break;\n                         case \u0027y\u0027:\n                             builder.appendYear(tokenLen, maxDigits);\n                             break;\n                         case \u0027Y\u0027:\n                             builder.appendYearOfEra(tokenLen, maxDigits);\n                             break;\n                     }\n                 }\n                 break;\n             case \u0027M\u0027:\n                 if (tokenLen \u003e\u003d 3) {\n                     if (tokenLen \u003e\u003d 4) {\n                         builder.appendMonthOfYearText();\n                     } else {\n                         builder.appendMonthOfYearShortText();\n                     }\n                 } else {\n                     builder.appendMonthOfYear(tokenLen);\n                 }\n                 break;\n             case \u0027d\u0027:\n                 builder.appendDayOfMonth(tokenLen);\n                 break;\n             case \u0027h\u0027:\n                 builder.appendClockhourOfHalfday(tokenLen);\n                 break;\n             case \u0027H\u0027:\n                 builder.appendHourOfDay(tokenLen);\n                 break;\n             case \u0027m\u0027:\n                 builder.appendMinuteOfHour(tokenLen);\n                 break;\n             case \u0027s\u0027:\n                 builder.appendSecondOfMinute(tokenLen);\n                 break;\n             case \u0027S\u0027:\n                 builder.appendFractionOfSecond(tokenLen, tokenLen);\n                 break;\n             case \u0027e\u0027:\n                 builder.appendDayOfWeek(tokenLen);\n                 break;\n             case \u0027E\u0027:\n                 if (tokenLen \u003e\u003d 4) {\n                     builder.appendDayOfWeekText();\n                 } else {\n                     builder.appendDayOfWeekShortText();\n                 }\n                 break;\n             case \u0027D\u0027:\n                 builder.appendDayOfYear(tokenLen);\n                 break;\n             case \u0027w\u0027:\n                 builder.appendWeekOfWeekyear(tokenLen);\n                 break;\n             case \u0027a\u0027:\n                 builder.appendHalfdayOfDayText();\n                 break;\n             case \u0027k\u0027:\n                 builder.appendClockhourOfDay(tokenLen);\n                 break;\n             case \u0027K\u0027:\n                 builder.appendClockhourOfHalfday(tokenLen);\n                 break;\n             case \u0027z\u0027:\n                 if (tokenLen \u003e\u003d 4) {\n                     builder.appendTimeZoneName();\n                 } else {\n                     builder.appendTimeZoneShortName();\n                 }\n                 break;\n             case \u0027Z\u0027:\n                 if (tokenLen \u003e\u003d 4) {\n                     builder.appendTimeZoneOffset(null, true, 2, 2);\n                 } else {\n                     builder.appendTimeZoneOffset(null, false, 2, 2);\n                 }\n                 break;\n             case \u0027\\\u0027\u0027:\n                 String sub \u003d token.substring(1);\n                 if (sub.length() \u003d\u003d 1) {\n                     builder.appendLiteral(sub.charAt(0));\n                 } else {\n                     builder.appendLiteral(new String(sub));\n                 }\n                 break;\n             default:\n                 throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4f78ec4d836c5aa1a1706eaf9c75a6e5c41d1d16": {
      "type": "Ybodychange",
      "commitMessage": "Use DateTimeFieldType in DateTimeField\n\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@466 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1\n",
      "commitDate": "9/2/04, 2:40 PM",
      "commitName": "4f78ec4d836c5aa1a1706eaf9c75a6e5c41d1d16",
      "commitAuthor": "Stephen Colebourne",
      "commitDateOld": "7/15/04, 4:33 PM",
      "commitNameOld": "a1ef0abe322f8101a2d894f4b0dc575b4643cc15",
      "commitAuthorOld": "Stephen Colebourne",
      "daysBetweenCommits": 48.92,
      "commitsBetweenForRepo": 176,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern) {\n    int length \u003d pattern.length();\n    int[] indexRef \u003d new int[1];\n    for (int i \u003d 0; i \u003c length; i++) {\n        indexRef[0] \u003d i;\n        String token \u003d parseToken(pattern, indexRef);\n        i \u003d indexRef[0];\n        int tokenLen \u003d token.length();\n        if (tokenLen \u003d\u003d 0) {\n            break;\n        }\n        char c \u003d token.charAt(0);\n        switch(c) {\n            case \u0027G\u0027:\n                builder.appendEraText();\n                break;\n            case \u0027C\u0027:\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case \u0027x\u0027:\n            case \u0027y\u0027:\n            case \u0027Y\u0027:\n                if (tokenLen \u003d\u003d 2) {\n                    DateTimeField field;\n                    Chronology chronoUTC \u003d builder.getChronology().withUTC();\n                    switch(c) {\n                        case \u0027x\u0027:\n                            field \u003d new RemainderDateTimeField(chronoUTC.weekyear(), DateTimeFieldType.weekyearOfCentury(), \"centuries\", 100);\n                            break;\n                        case \u0027y\u0027:\n                        default:\n                            field \u003d new RemainderDateTimeField(chronoUTC.year(), DateTimeFieldType.yearOfCentury(), \"centuries\", 100);\n                            break;\n                        case \u0027Y\u0027:\n                            field \u003d new RemainderDateTimeField(chronoUTC.yearOfEra(), DateTimeFieldType.yearOfCentury(), \"centuries\", 100);\n                            break;\n                    }\n                    builder.appendDecimal(field, 2, 2);\n                } else {\n                    int maxDigits \u003d 9;\n                    if (i + 1 \u003c length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            maxDigits \u003d tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n                    switch(c) {\n                        case \u0027x\u0027:\n                            builder.appendWeekyear(tokenLen, maxDigits);\n                            break;\n                        case \u0027y\u0027:\n                            builder.appendYear(tokenLen, maxDigits);\n                            break;\n                        case \u0027Y\u0027:\n                            builder.appendYearOfEra(tokenLen, maxDigits);\n                            break;\n                    }\n                }\n                break;\n            case \u0027M\u0027:\n                if (tokenLen \u003e\u003d 3) {\n                    if (tokenLen \u003e\u003d 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case \u0027d\u0027:\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case \u0027h\u0027:\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case \u0027H\u0027:\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case \u0027m\u0027:\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case \u0027s\u0027:\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case \u0027S\u0027:\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case \u0027e\u0027:\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case \u0027E\u0027:\n                if (tokenLen \u003e\u003d 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case \u0027D\u0027:\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case \u0027w\u0027:\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case \u0027a\u0027:\n                builder.appendHalfdayOfDayText();\n                break;\n            case \u0027k\u0027:\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case \u0027K\u0027:\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case \u0027z\u0027:\n                if (tokenLen \u003e\u003d 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName();\n                }\n                break;\n            case \u0027Z\u0027:\n                if (tokenLen \u003e\u003d 4) {\n                    builder.appendTimeZoneOffset(null, true, 2, 2);\n                } else {\n                    builder.appendTimeZoneOffset(null, false, 2, 2);\n                }\n                break;\n            case \u0027\\\u0027\u0027:\n                String sub \u003d token.substring(1);\n                if (sub.length() \u003d\u003d 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n        }\n    }\n}",
      "path": "JodaTime/src/java/org/joda/time/format/DateTimeFormat.java",
      "functionStartLine": 260,
      "functionName": "appendPatternTo",
      "functionAnnotation": "",
      "functionDoc": "Parses the given pattern and appends the rules to the given\nDateTimeFormatterBuilder.\n\n@param pattern pattern specification\n@throws IllegalArgumentException if the pattern is invalid\n@see #forPattern\n",
      "diff": "@@ -1,141 +1,141 @@\n public static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern) {\n     int length \u003d pattern.length();\n     int[] indexRef \u003d new int[1];\n     for (int i \u003d 0; i \u003c length; i++) {\n         indexRef[0] \u003d i;\n         String token \u003d parseToken(pattern, indexRef);\n         i \u003d indexRef[0];\n         int tokenLen \u003d token.length();\n         if (tokenLen \u003d\u003d 0) {\n             break;\n         }\n         char c \u003d token.charAt(0);\n         switch(c) {\n             case \u0027G\u0027:\n                 builder.appendEraText();\n                 break;\n             case \u0027C\u0027:\n                 builder.appendCenturyOfEra(tokenLen, tokenLen);\n                 break;\n             case \u0027x\u0027:\n             case \u0027y\u0027:\n             case \u0027Y\u0027:\n                 if (tokenLen \u003d\u003d 2) {\n                     DateTimeField field;\n                     Chronology chronoUTC \u003d builder.getChronology().withUTC();\n                     switch(c) {\n                         case \u0027x\u0027:\n-                            field \u003d new RemainderDateTimeField(chronoUTC.weekyear(), \"weekyearOfCentury\", \"centuries\", 100);\n+                            field \u003d new RemainderDateTimeField(chronoUTC.weekyear(), DateTimeFieldType.weekyearOfCentury(), \"centuries\", 100);\n                             break;\n                         case \u0027y\u0027:\n                         default:\n-                            field \u003d new RemainderDateTimeField(chronoUTC.year(), \"yearOfCentury\", \"centuries\", 100);\n+                            field \u003d new RemainderDateTimeField(chronoUTC.year(), DateTimeFieldType.yearOfCentury(), \"centuries\", 100);\n                             break;\n                         case \u0027Y\u0027:\n-                            field \u003d new RemainderDateTimeField(chronoUTC.yearOfEra(), \"yearOfCentury\", \"centuries\", 100);\n+                            field \u003d new RemainderDateTimeField(chronoUTC.yearOfEra(), DateTimeFieldType.yearOfCentury(), \"centuries\", 100);\n                             break;\n                     }\n                     builder.appendDecimal(field, 2, 2);\n                 } else {\n                     int maxDigits \u003d 9;\n                     if (i + 1 \u003c length) {\n                         indexRef[0]++;\n                         if (isNumericToken(parseToken(pattern, indexRef))) {\n                             maxDigits \u003d tokenLen;\n                         }\n                         indexRef[0]--;\n                     }\n                     switch(c) {\n                         case \u0027x\u0027:\n                             builder.appendWeekyear(tokenLen, maxDigits);\n                             break;\n                         case \u0027y\u0027:\n                             builder.appendYear(tokenLen, maxDigits);\n                             break;\n                         case \u0027Y\u0027:\n                             builder.appendYearOfEra(tokenLen, maxDigits);\n                             break;\n                     }\n                 }\n                 break;\n             case \u0027M\u0027:\n                 if (tokenLen \u003e\u003d 3) {\n                     if (tokenLen \u003e\u003d 4) {\n                         builder.appendMonthOfYearText();\n                     } else {\n                         builder.appendMonthOfYearShortText();\n                     }\n                 } else {\n                     builder.appendMonthOfYear(tokenLen);\n                 }\n                 break;\n             case \u0027d\u0027:\n                 builder.appendDayOfMonth(tokenLen);\n                 break;\n             case \u0027h\u0027:\n                 builder.appendClockhourOfHalfday(tokenLen);\n                 break;\n             case \u0027H\u0027:\n                 builder.appendHourOfDay(tokenLen);\n                 break;\n             case \u0027m\u0027:\n                 builder.appendMinuteOfHour(tokenLen);\n                 break;\n             case \u0027s\u0027:\n                 builder.appendSecondOfMinute(tokenLen);\n                 break;\n             case \u0027S\u0027:\n                 builder.appendFractionOfSecond(tokenLen, tokenLen);\n                 break;\n             case \u0027e\u0027:\n                 builder.appendDayOfWeek(tokenLen);\n                 break;\n             case \u0027E\u0027:\n                 if (tokenLen \u003e\u003d 4) {\n                     builder.appendDayOfWeekText();\n                 } else {\n                     builder.appendDayOfWeekShortText();\n                 }\n                 break;\n             case \u0027D\u0027:\n                 builder.appendDayOfYear(tokenLen);\n                 break;\n             case \u0027w\u0027:\n                 builder.appendWeekOfWeekyear(tokenLen);\n                 break;\n             case \u0027a\u0027:\n                 builder.appendHalfdayOfDayText();\n                 break;\n             case \u0027k\u0027:\n                 builder.appendClockhourOfDay(tokenLen);\n                 break;\n             case \u0027K\u0027:\n                 builder.appendClockhourOfHalfday(tokenLen);\n                 break;\n             case \u0027z\u0027:\n                 if (tokenLen \u003e\u003d 4) {\n                     builder.appendTimeZoneName();\n                 } else {\n                     builder.appendTimeZoneShortName();\n                 }\n                 break;\n             case \u0027Z\u0027:\n                 if (tokenLen \u003e\u003d 4) {\n                     builder.appendTimeZoneOffset(null, true, 2, 2);\n                 } else {\n                     builder.appendTimeZoneOffset(null, false, 2, 2);\n                 }\n                 break;\n             case \u0027\\\u0027\u0027:\n                 String sub \u003d token.substring(1);\n                 if (sub.length() \u003d\u003d 1) {\n                     builder.appendLiteral(sub.charAt(0));\n                 } else {\n                     builder.appendLiteral(new String(sub));\n                 }\n                 break;\n             default:\n                 throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "49b93444b594c2418063c1f95cb07bd30bd639a1": {
      "type": "Ybodychange",
      "commitMessage": "Rename appendNumeric to appendDecimal, reserving \"numeric\" for later use.\n\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@73 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1\n",
      "commitDate": "12/27/03, 9:18 AM",
      "commitName": "49b93444b594c2418063c1f95cb07bd30bd639a1",
      "commitAuthor": "Brian S O\u0027Neill",
      "commitDateOld": "12/18/03, 7:01 PM",
      "commitNameOld": "048f3a5cc26c89f60f93d547dbcd9413f0eae73c",
      "commitAuthorOld": "Brian S O\u0027Neill",
      "daysBetweenCommits": 8.6,
      "commitsBetweenForRepo": 56,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern) {\n    int length \u003d pattern.length();\n    int[] indexRef \u003d new int[1];\n    for (int i \u003d 0; i \u003c length; i++) {\n        indexRef[0] \u003d i;\n        String token \u003d parseToken(pattern, indexRef);\n        i \u003d indexRef[0];\n        int tokenLen \u003d token.length();\n        if (tokenLen \u003d\u003d 0) {\n            break;\n        }\n        char c \u003d token.charAt(0);\n        switch(c) {\n            case \u0027G\u0027:\n                builder.appendEraText();\n                break;\n            case \u0027C\u0027:\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case \u0027x\u0027:\n            case \u0027y\u0027:\n            case \u0027Y\u0027:\n                if (tokenLen \u003d\u003d 2) {\n                    DateTimeField field;\n                    Chronology chronoUTC \u003d builder.getChronology().withUTC();\n                    switch(c) {\n                        case \u0027x\u0027:\n                            field \u003d new RemainderDateTimeField(chronoUTC.weekyear(), \"weekyearOfCentury\", \"centuries\", 100);\n                            break;\n                        case \u0027y\u0027:\n                        default:\n                            field \u003d new RemainderDateTimeField(chronoUTC.year(), \"yearOfCentury\", \"centuries\", 100);\n                            break;\n                        case \u0027Y\u0027:\n                            field \u003d new RemainderDateTimeField(chronoUTC.yearOfEra(), \"yearOfCentury\", \"centuries\", 100);\n                            break;\n                    }\n                    builder.appendDecimal(field, 2, 2);\n                } else {\n                    int maxDigits \u003d 9;\n                    if (i + 1 \u003c length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            maxDigits \u003d tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n                    switch(c) {\n                        case \u0027x\u0027:\n                            builder.appendWeekyear(tokenLen, maxDigits);\n                            break;\n                        case \u0027y\u0027:\n                            builder.appendYear(tokenLen, maxDigits);\n                            break;\n                        case \u0027Y\u0027:\n                            builder.appendYearOfEra(tokenLen, maxDigits);\n                            break;\n                    }\n                }\n                break;\n            case \u0027M\u0027:\n                if (tokenLen \u003e\u003d 3) {\n                    if (tokenLen \u003e\u003d 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case \u0027d\u0027:\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case \u0027h\u0027:\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case \u0027H\u0027:\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case \u0027m\u0027:\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case \u0027s\u0027:\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case \u0027S\u0027:\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case \u0027e\u0027:\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case \u0027E\u0027:\n                if (tokenLen \u003e\u003d 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case \u0027D\u0027:\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case \u0027w\u0027:\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case \u0027a\u0027:\n                builder.appendHalfdayOfDayText();\n                break;\n            case \u0027k\u0027:\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case \u0027K\u0027:\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case \u0027z\u0027:\n                if (tokenLen \u003e\u003d 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName();\n                }\n                break;\n            case \u0027Z\u0027:\n                if (tokenLen \u003e\u003d 4) {\n                    builder.appendTimeZoneOffset(null, true, 2, 2);\n                } else {\n                    builder.appendTimeZoneOffset(null, false, 2, 2);\n                }\n                break;\n            case \u0027\\\u0027\u0027:\n                String sub \u003d token.substring(1);\n                if (sub.length() \u003d\u003d 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n        }\n    }\n}",
      "path": "JodaTime/src/java/org/joda/time/format/DateTimeFormat.java",
      "functionStartLine": 258,
      "functionName": "appendPatternTo",
      "functionAnnotation": "",
      "functionDoc": "Parses the given pattern and appends the rules to the given\nDateTimeFormatterBuilder.\n\n@param pattern pattern specification\n@throws IllegalArgumentException if the pattern is invalid\n@see #forPattern\n",
      "diff": "@@ -1,141 +1,141 @@\n public static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern) {\n     int length \u003d pattern.length();\n     int[] indexRef \u003d new int[1];\n     for (int i \u003d 0; i \u003c length; i++) {\n         indexRef[0] \u003d i;\n         String token \u003d parseToken(pattern, indexRef);\n         i \u003d indexRef[0];\n         int tokenLen \u003d token.length();\n         if (tokenLen \u003d\u003d 0) {\n             break;\n         }\n         char c \u003d token.charAt(0);\n         switch(c) {\n             case \u0027G\u0027:\n                 builder.appendEraText();\n                 break;\n             case \u0027C\u0027:\n                 builder.appendCenturyOfEra(tokenLen, tokenLen);\n                 break;\n             case \u0027x\u0027:\n             case \u0027y\u0027:\n             case \u0027Y\u0027:\n                 if (tokenLen \u003d\u003d 2) {\n                     DateTimeField field;\n                     Chronology chronoUTC \u003d builder.getChronology().withUTC();\n                     switch(c) {\n                         case \u0027x\u0027:\n                             field \u003d new RemainderDateTimeField(chronoUTC.weekyear(), \"weekyearOfCentury\", \"centuries\", 100);\n                             break;\n                         case \u0027y\u0027:\n                         default:\n                             field \u003d new RemainderDateTimeField(chronoUTC.year(), \"yearOfCentury\", \"centuries\", 100);\n                             break;\n                         case \u0027Y\u0027:\n                             field \u003d new RemainderDateTimeField(chronoUTC.yearOfEra(), \"yearOfCentury\", \"centuries\", 100);\n                             break;\n                     }\n-                    builder.appendNumeric(field, 2, 2);\n+                    builder.appendDecimal(field, 2, 2);\n                 } else {\n                     int maxDigits \u003d 9;\n                     if (i + 1 \u003c length) {\n                         indexRef[0]++;\n                         if (isNumericToken(parseToken(pattern, indexRef))) {\n                             maxDigits \u003d tokenLen;\n                         }\n                         indexRef[0]--;\n                     }\n                     switch(c) {\n                         case \u0027x\u0027:\n                             builder.appendWeekyear(tokenLen, maxDigits);\n                             break;\n                         case \u0027y\u0027:\n                             builder.appendYear(tokenLen, maxDigits);\n                             break;\n                         case \u0027Y\u0027:\n                             builder.appendYearOfEra(tokenLen, maxDigits);\n                             break;\n                     }\n                 }\n                 break;\n             case \u0027M\u0027:\n                 if (tokenLen \u003e\u003d 3) {\n                     if (tokenLen \u003e\u003d 4) {\n                         builder.appendMonthOfYearText();\n                     } else {\n                         builder.appendMonthOfYearShortText();\n                     }\n                 } else {\n                     builder.appendMonthOfYear(tokenLen);\n                 }\n                 break;\n             case \u0027d\u0027:\n                 builder.appendDayOfMonth(tokenLen);\n                 break;\n             case \u0027h\u0027:\n                 builder.appendClockhourOfHalfday(tokenLen);\n                 break;\n             case \u0027H\u0027:\n                 builder.appendHourOfDay(tokenLen);\n                 break;\n             case \u0027m\u0027:\n                 builder.appendMinuteOfHour(tokenLen);\n                 break;\n             case \u0027s\u0027:\n                 builder.appendSecondOfMinute(tokenLen);\n                 break;\n             case \u0027S\u0027:\n                 builder.appendFractionOfSecond(tokenLen, tokenLen);\n                 break;\n             case \u0027e\u0027:\n                 builder.appendDayOfWeek(tokenLen);\n                 break;\n             case \u0027E\u0027:\n                 if (tokenLen \u003e\u003d 4) {\n                     builder.appendDayOfWeekText();\n                 } else {\n                     builder.appendDayOfWeekShortText();\n                 }\n                 break;\n             case \u0027D\u0027:\n                 builder.appendDayOfYear(tokenLen);\n                 break;\n             case \u0027w\u0027:\n                 builder.appendWeekOfWeekyear(tokenLen);\n                 break;\n             case \u0027a\u0027:\n                 builder.appendHalfdayOfDayText();\n                 break;\n             case \u0027k\u0027:\n                 builder.appendClockhourOfDay(tokenLen);\n                 break;\n             case \u0027K\u0027:\n                 builder.appendClockhourOfHalfday(tokenLen);\n                 break;\n             case \u0027z\u0027:\n                 if (tokenLen \u003e\u003d 4) {\n                     builder.appendTimeZoneName();\n                 } else {\n                     builder.appendTimeZoneShortName();\n                 }\n                 break;\n             case \u0027Z\u0027:\n                 if (tokenLen \u003e\u003d 4) {\n                     builder.appendTimeZoneOffset(null, true, 2, 2);\n                 } else {\n                     builder.appendTimeZoneOffset(null, false, 2, 2);\n                 }\n                 break;\n             case \u0027\\\u0027\u0027:\n                 String sub \u003d token.substring(1);\n                 if (sub.length() \u003d\u003d 1) {\n                     builder.appendLiteral(sub.charAt(0));\n                 } else {\n                     builder.appendLiteral(new String(sub));\n                 }\n                 break;\n             default:\n                 throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0e07ac6b2cff63550d7df336355ca63cc05aa40b": {
      "type": "Ymultichange(Ymovefromfile,Yreturntypechange,Ymodifierchange,Yexceptionschange,Ybodychange,Ydocchange,Yrename,Yparameterchange)",
      "commitMessage": "Move from Joda CVS\n\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@10 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1\n",
      "commitDate": "12/18/03, 6:07 PM",
      "commitName": "0e07ac6b2cff63550d7df336355ca63cc05aa40b",
      "commitAuthor": "Stephen Colebourne",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "Move from Joda CVS\n\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@10 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1\n",
          "commitDate": "12/18/03, 6:07 PM",
          "commitName": "0e07ac6b2cff63550d7df336355ca63cc05aa40b",
          "commitAuthor": "Stephen Colebourne",
          "commitDateOld": "12/18/03, 2:04 PM",
          "commitNameOld": "1ba4f9861a0cfbc32c56efced3619874a43ec5dd",
          "commitAuthorOld": "Stephen Colebourne",
          "daysBetweenCommits": 0.17,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern) {\n    int length \u003d pattern.length();\n    int[] indexRef \u003d new int[1];\n    for (int i \u003d 0; i \u003c length; i++) {\n        indexRef[0] \u003d i;\n        String token \u003d parseToken(pattern, indexRef);\n        i \u003d indexRef[0];\n        int tokenLen \u003d token.length();\n        if (tokenLen \u003d\u003d 0) {\n            break;\n        }\n        char c \u003d token.charAt(0);\n        switch(c) {\n            case \u0027G\u0027:\n                builder.appendEraText();\n                break;\n            case \u0027C\u0027:\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case \u0027x\u0027:\n            case \u0027y\u0027:\n            case \u0027Y\u0027:\n                if (tokenLen \u003d\u003d 2) {\n                    DateTimeField field;\n                    Chronology chronoUTC \u003d builder.getChronology().withUTC();\n                    switch(c) {\n                        case \u0027x\u0027:\n                            field \u003d new RemainderDateTimeField(chronoUTC.weekyear(), \"weekyearOfCentury\", \"centuries\", 100);\n                            break;\n                        case \u0027y\u0027:\n                        default:\n                            field \u003d new RemainderDateTimeField(chronoUTC.year(), \"yearOfCentury\", \"centuries\", 100);\n                            break;\n                        case \u0027Y\u0027:\n                            field \u003d new RemainderDateTimeField(chronoUTC.yearOfEra(), \"yearOfCentury\", \"centuries\", 100);\n                            break;\n                    }\n                    builder.appendNumeric(field, 2, 2);\n                } else {\n                    int maxDigits \u003d 9;\n                    if (i + 1 \u003c length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            maxDigits \u003d tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n                    switch(c) {\n                        case \u0027x\u0027:\n                            builder.appendWeekyear(tokenLen, maxDigits);\n                            break;\n                        case \u0027y\u0027:\n                            builder.appendYear(tokenLen, maxDigits);\n                            break;\n                        case \u0027Y\u0027:\n                            builder.appendYearOfEra(tokenLen, maxDigits);\n                            break;\n                    }\n                }\n                break;\n            case \u0027M\u0027:\n                if (tokenLen \u003e\u003d 3) {\n                    if (tokenLen \u003e\u003d 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case \u0027d\u0027:\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case \u0027h\u0027:\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case \u0027H\u0027:\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case \u0027m\u0027:\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case \u0027s\u0027:\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case \u0027S\u0027:\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case \u0027e\u0027:\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case \u0027E\u0027:\n                if (tokenLen \u003e\u003d 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case \u0027D\u0027:\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case \u0027w\u0027:\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case \u0027a\u0027:\n                builder.appendHalfdayOfDayText();\n                break;\n            case \u0027k\u0027:\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case \u0027K\u0027:\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case \u0027z\u0027:\n                if (tokenLen \u003e\u003d 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName();\n                }\n                break;\n            case \u0027Z\u0027:\n                if (tokenLen \u003e\u003d 4) {\n                    builder.appendTimeZoneOffset(null, true, 2, 2);\n                } else {\n                    builder.appendTimeZoneOffset(null, false, 2, 2);\n                }\n                break;\n            case \u0027\\\u0027\u0027:\n                String sub \u003d token.substring(1);\n                if (sub.length() \u003d\u003d 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n        }\n    }\n}",
          "path": "JodaTime/src/java/org/joda/time/format/DateTimeFormat.java",
          "functionStartLine": 258,
          "functionName": "appendPatternTo",
          "functionAnnotation": "",
          "functionDoc": "Parses the given pattern and appends the rules to the given\nDateTimeFormatterBuilder.\n\n@param pattern pattern specification\n@throws IllegalArgumentException if the pattern is invalid\n@see #forPattern\n",
          "diff": "@@ -1,141 +1,141 @@\n-public DateTimeFormatterBuilder appendPattern(String pattern) throws IllegalArgumentException {\n+public static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern) {\n     int length \u003d pattern.length();\n     int[] indexRef \u003d new int[1];\n     for (int i \u003d 0; i \u003c length; i++) {\n         indexRef[0] \u003d i;\n         String token \u003d parseToken(pattern, indexRef);\n         i \u003d indexRef[0];\n         int tokenLen \u003d token.length();\n         if (tokenLen \u003d\u003d 0) {\n             break;\n         }\n         char c \u003d token.charAt(0);\n         switch(c) {\n             case \u0027G\u0027:\n-                appendEraText();\n+                builder.appendEraText();\n                 break;\n             case \u0027C\u0027:\n-                appendCenturyOfEra(tokenLen, tokenLen);\n+                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                 break;\n             case \u0027x\u0027:\n             case \u0027y\u0027:\n             case \u0027Y\u0027:\n                 if (tokenLen \u003d\u003d 2) {\n                     DateTimeField field;\n+                    Chronology chronoUTC \u003d builder.getChronology().withUTC();\n                     switch(c) {\n                         case \u0027x\u0027:\n-                            field \u003d new RemainderDateTimeField(\"weekyearOfCentury\", iChronoUTC.weekyear(), 100);\n+                            field \u003d new RemainderDateTimeField(chronoUTC.weekyear(), \"weekyearOfCentury\", \"centuries\", 100);\n                             break;\n                         case \u0027y\u0027:\n                         default:\n-                            field \u003d new RemainderDateTimeField(\"yearOfCentury\", iChronoUTC.year(), 100);\n+                            field \u003d new RemainderDateTimeField(chronoUTC.year(), \"yearOfCentury\", \"centuries\", 100);\n                             break;\n                         case \u0027Y\u0027:\n-                            field \u003d new RemainderDateTimeField(\"yearOfCentury\", iChronoUTC.yearOfEra(), 100);\n+                            field \u003d new RemainderDateTimeField(chronoUTC.yearOfEra(), \"yearOfCentury\", \"centuries\", 100);\n                             break;\n                     }\n-                    appendNumeric(field, 2, 2);\n+                    builder.appendNumeric(field, 2, 2);\n                 } else {\n                     int maxDigits \u003d 9;\n                     if (i + 1 \u003c length) {\n                         indexRef[0]++;\n                         if (isNumericToken(parseToken(pattern, indexRef))) {\n                             maxDigits \u003d tokenLen;\n                         }\n                         indexRef[0]--;\n                     }\n                     switch(c) {\n                         case \u0027x\u0027:\n-                            appendWeekyear(tokenLen, maxDigits);\n+                            builder.appendWeekyear(tokenLen, maxDigits);\n                             break;\n                         case \u0027y\u0027:\n-                            appendYear(tokenLen, maxDigits);\n+                            builder.appendYear(tokenLen, maxDigits);\n                             break;\n                         case \u0027Y\u0027:\n-                            appendYearOfEra(tokenLen, maxDigits);\n+                            builder.appendYearOfEra(tokenLen, maxDigits);\n                             break;\n                     }\n                 }\n                 break;\n             case \u0027M\u0027:\n                 if (tokenLen \u003e\u003d 3) {\n                     if (tokenLen \u003e\u003d 4) {\n-                        appendMonthOfYearText();\n+                        builder.appendMonthOfYearText();\n                     } else {\n-                        appendMonthOfYearShortText();\n+                        builder.appendMonthOfYearShortText();\n                     }\n                 } else {\n-                    appendMonthOfYear(tokenLen);\n+                    builder.appendMonthOfYear(tokenLen);\n                 }\n                 break;\n             case \u0027d\u0027:\n-                appendDayOfMonth(tokenLen);\n+                builder.appendDayOfMonth(tokenLen);\n                 break;\n             case \u0027h\u0027:\n-                appendClockhourOfHalfday(tokenLen);\n+                builder.appendClockhourOfHalfday(tokenLen);\n                 break;\n             case \u0027H\u0027:\n-                appendHourOfDay(tokenLen);\n+                builder.appendHourOfDay(tokenLen);\n                 break;\n             case \u0027m\u0027:\n-                appendMinuteOfHour(tokenLen);\n+                builder.appendMinuteOfHour(tokenLen);\n                 break;\n             case \u0027s\u0027:\n-                appendSecondOfMinute(tokenLen);\n+                builder.appendSecondOfMinute(tokenLen);\n                 break;\n             case \u0027S\u0027:\n-                appendFractionOfSecond(tokenLen, tokenLen);\n+                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                 break;\n             case \u0027e\u0027:\n-                appendDayOfWeek(tokenLen);\n+                builder.appendDayOfWeek(tokenLen);\n                 break;\n             case \u0027E\u0027:\n                 if (tokenLen \u003e\u003d 4) {\n-                    appendDayOfWeekText();\n+                    builder.appendDayOfWeekText();\n                 } else {\n-                    appendDayOfWeekShortText();\n+                    builder.appendDayOfWeekShortText();\n                 }\n                 break;\n             case \u0027D\u0027:\n-                appendDayOfYear(tokenLen);\n+                builder.appendDayOfYear(tokenLen);\n                 break;\n             case \u0027w\u0027:\n-                appendWeekOfWeekyear(tokenLen);\n+                builder.appendWeekOfWeekyear(tokenLen);\n                 break;\n             case \u0027a\u0027:\n-                appendHalfdayOfDayText();\n+                builder.appendHalfdayOfDayText();\n                 break;\n             case \u0027k\u0027:\n-                appendClockhourOfDay(tokenLen);\n+                builder.appendClockhourOfDay(tokenLen);\n                 break;\n             case \u0027K\u0027:\n-                appendClockhourOfHalfday(tokenLen);\n+                builder.appendClockhourOfHalfday(tokenLen);\n                 break;\n             case \u0027z\u0027:\n                 if (tokenLen \u003e\u003d 4) {\n-                    appendTimeZoneName();\n+                    builder.appendTimeZoneName();\n                 } else {\n-                    appendTimeZoneShortName();\n+                    builder.appendTimeZoneShortName();\n                 }\n                 break;\n             case \u0027Z\u0027:\n                 if (tokenLen \u003e\u003d 4) {\n-                    appendTimeZoneOffset(null, true, 2, 2);\n+                    builder.appendTimeZoneOffset(null, true, 2, 2);\n                 } else {\n-                    appendTimeZoneOffset(null, false, 2, 2);\n+                    builder.appendTimeZoneOffset(null, false, 2, 2);\n                 }\n                 break;\n             case \u0027\\\u0027\u0027:\n                 String sub \u003d token.substring(1);\n                 if (sub.length() \u003d\u003d 1) {\n-                    appendLiteral(sub.charAt(0));\n+                    builder.appendLiteral(sub.charAt(0));\n                 } else {\n-                    appendLiteral(new String(sub));\n+                    builder.appendLiteral(new String(sub));\n                 }\n                 break;\n             default:\n                 throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n         }\n     }\n-    return this;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldPath": "JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java",
            "newPath": "JodaTime/src/java/org/joda/time/format/DateTimeFormat.java",
            "oldMethodName": "appendPattern",
            "newMethodName": "appendPatternTo"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "Move from Joda CVS\n\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@10 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1\n",
          "commitDate": "12/18/03, 6:07 PM",
          "commitName": "0e07ac6b2cff63550d7df336355ca63cc05aa40b",
          "commitAuthor": "Stephen Colebourne",
          "commitDateOld": "12/18/03, 2:04 PM",
          "commitNameOld": "1ba4f9861a0cfbc32c56efced3619874a43ec5dd",
          "commitAuthorOld": "Stephen Colebourne",
          "daysBetweenCommits": 0.17,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern) {\n    int length \u003d pattern.length();\n    int[] indexRef \u003d new int[1];\n    for (int i \u003d 0; i \u003c length; i++) {\n        indexRef[0] \u003d i;\n        String token \u003d parseToken(pattern, indexRef);\n        i \u003d indexRef[0];\n        int tokenLen \u003d token.length();\n        if (tokenLen \u003d\u003d 0) {\n            break;\n        }\n        char c \u003d token.charAt(0);\n        switch(c) {\n            case \u0027G\u0027:\n                builder.appendEraText();\n                break;\n            case \u0027C\u0027:\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case \u0027x\u0027:\n            case \u0027y\u0027:\n            case \u0027Y\u0027:\n                if (tokenLen \u003d\u003d 2) {\n                    DateTimeField field;\n                    Chronology chronoUTC \u003d builder.getChronology().withUTC();\n                    switch(c) {\n                        case \u0027x\u0027:\n                            field \u003d new RemainderDateTimeField(chronoUTC.weekyear(), \"weekyearOfCentury\", \"centuries\", 100);\n                            break;\n                        case \u0027y\u0027:\n                        default:\n                            field \u003d new RemainderDateTimeField(chronoUTC.year(), \"yearOfCentury\", \"centuries\", 100);\n                            break;\n                        case \u0027Y\u0027:\n                            field \u003d new RemainderDateTimeField(chronoUTC.yearOfEra(), \"yearOfCentury\", \"centuries\", 100);\n                            break;\n                    }\n                    builder.appendNumeric(field, 2, 2);\n                } else {\n                    int maxDigits \u003d 9;\n                    if (i + 1 \u003c length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            maxDigits \u003d tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n                    switch(c) {\n                        case \u0027x\u0027:\n                            builder.appendWeekyear(tokenLen, maxDigits);\n                            break;\n                        case \u0027y\u0027:\n                            builder.appendYear(tokenLen, maxDigits);\n                            break;\n                        case \u0027Y\u0027:\n                            builder.appendYearOfEra(tokenLen, maxDigits);\n                            break;\n                    }\n                }\n                break;\n            case \u0027M\u0027:\n                if (tokenLen \u003e\u003d 3) {\n                    if (tokenLen \u003e\u003d 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case \u0027d\u0027:\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case \u0027h\u0027:\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case \u0027H\u0027:\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case \u0027m\u0027:\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case \u0027s\u0027:\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case \u0027S\u0027:\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case \u0027e\u0027:\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case \u0027E\u0027:\n                if (tokenLen \u003e\u003d 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case \u0027D\u0027:\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case \u0027w\u0027:\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case \u0027a\u0027:\n                builder.appendHalfdayOfDayText();\n                break;\n            case \u0027k\u0027:\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case \u0027K\u0027:\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case \u0027z\u0027:\n                if (tokenLen \u003e\u003d 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName();\n                }\n                break;\n            case \u0027Z\u0027:\n                if (tokenLen \u003e\u003d 4) {\n                    builder.appendTimeZoneOffset(null, true, 2, 2);\n                } else {\n                    builder.appendTimeZoneOffset(null, false, 2, 2);\n                }\n                break;\n            case \u0027\\\u0027\u0027:\n                String sub \u003d token.substring(1);\n                if (sub.length() \u003d\u003d 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n        }\n    }\n}",
          "path": "JodaTime/src/java/org/joda/time/format/DateTimeFormat.java",
          "functionStartLine": 258,
          "functionName": "appendPatternTo",
          "functionAnnotation": "",
          "functionDoc": "Parses the given pattern and appends the rules to the given\nDateTimeFormatterBuilder.\n\n@param pattern pattern specification\n@throws IllegalArgumentException if the pattern is invalid\n@see #forPattern\n",
          "diff": "@@ -1,141 +1,141 @@\n-public DateTimeFormatterBuilder appendPattern(String pattern) throws IllegalArgumentException {\n+public static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern) {\n     int length \u003d pattern.length();\n     int[] indexRef \u003d new int[1];\n     for (int i \u003d 0; i \u003c length; i++) {\n         indexRef[0] \u003d i;\n         String token \u003d parseToken(pattern, indexRef);\n         i \u003d indexRef[0];\n         int tokenLen \u003d token.length();\n         if (tokenLen \u003d\u003d 0) {\n             break;\n         }\n         char c \u003d token.charAt(0);\n         switch(c) {\n             case \u0027G\u0027:\n-                appendEraText();\n+                builder.appendEraText();\n                 break;\n             case \u0027C\u0027:\n-                appendCenturyOfEra(tokenLen, tokenLen);\n+                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                 break;\n             case \u0027x\u0027:\n             case \u0027y\u0027:\n             case \u0027Y\u0027:\n                 if (tokenLen \u003d\u003d 2) {\n                     DateTimeField field;\n+                    Chronology chronoUTC \u003d builder.getChronology().withUTC();\n                     switch(c) {\n                         case \u0027x\u0027:\n-                            field \u003d new RemainderDateTimeField(\"weekyearOfCentury\", iChronoUTC.weekyear(), 100);\n+                            field \u003d new RemainderDateTimeField(chronoUTC.weekyear(), \"weekyearOfCentury\", \"centuries\", 100);\n                             break;\n                         case \u0027y\u0027:\n                         default:\n-                            field \u003d new RemainderDateTimeField(\"yearOfCentury\", iChronoUTC.year(), 100);\n+                            field \u003d new RemainderDateTimeField(chronoUTC.year(), \"yearOfCentury\", \"centuries\", 100);\n                             break;\n                         case \u0027Y\u0027:\n-                            field \u003d new RemainderDateTimeField(\"yearOfCentury\", iChronoUTC.yearOfEra(), 100);\n+                            field \u003d new RemainderDateTimeField(chronoUTC.yearOfEra(), \"yearOfCentury\", \"centuries\", 100);\n                             break;\n                     }\n-                    appendNumeric(field, 2, 2);\n+                    builder.appendNumeric(field, 2, 2);\n                 } else {\n                     int maxDigits \u003d 9;\n                     if (i + 1 \u003c length) {\n                         indexRef[0]++;\n                         if (isNumericToken(parseToken(pattern, indexRef))) {\n                             maxDigits \u003d tokenLen;\n                         }\n                         indexRef[0]--;\n                     }\n                     switch(c) {\n                         case \u0027x\u0027:\n-                            appendWeekyear(tokenLen, maxDigits);\n+                            builder.appendWeekyear(tokenLen, maxDigits);\n                             break;\n                         case \u0027y\u0027:\n-                            appendYear(tokenLen, maxDigits);\n+                            builder.appendYear(tokenLen, maxDigits);\n                             break;\n                         case \u0027Y\u0027:\n-                            appendYearOfEra(tokenLen, maxDigits);\n+                            builder.appendYearOfEra(tokenLen, maxDigits);\n                             break;\n                     }\n                 }\n                 break;\n             case \u0027M\u0027:\n                 if (tokenLen \u003e\u003d 3) {\n                     if (tokenLen \u003e\u003d 4) {\n-                        appendMonthOfYearText();\n+                        builder.appendMonthOfYearText();\n                     } else {\n-                        appendMonthOfYearShortText();\n+                        builder.appendMonthOfYearShortText();\n                     }\n                 } else {\n-                    appendMonthOfYear(tokenLen);\n+                    builder.appendMonthOfYear(tokenLen);\n                 }\n                 break;\n             case \u0027d\u0027:\n-                appendDayOfMonth(tokenLen);\n+                builder.appendDayOfMonth(tokenLen);\n                 break;\n             case \u0027h\u0027:\n-                appendClockhourOfHalfday(tokenLen);\n+                builder.appendClockhourOfHalfday(tokenLen);\n                 break;\n             case \u0027H\u0027:\n-                appendHourOfDay(tokenLen);\n+                builder.appendHourOfDay(tokenLen);\n                 break;\n             case \u0027m\u0027:\n-                appendMinuteOfHour(tokenLen);\n+                builder.appendMinuteOfHour(tokenLen);\n                 break;\n             case \u0027s\u0027:\n-                appendSecondOfMinute(tokenLen);\n+                builder.appendSecondOfMinute(tokenLen);\n                 break;\n             case \u0027S\u0027:\n-                appendFractionOfSecond(tokenLen, tokenLen);\n+                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                 break;\n             case \u0027e\u0027:\n-                appendDayOfWeek(tokenLen);\n+                builder.appendDayOfWeek(tokenLen);\n                 break;\n             case \u0027E\u0027:\n                 if (tokenLen \u003e\u003d 4) {\n-                    appendDayOfWeekText();\n+                    builder.appendDayOfWeekText();\n                 } else {\n-                    appendDayOfWeekShortText();\n+                    builder.appendDayOfWeekShortText();\n                 }\n                 break;\n             case \u0027D\u0027:\n-                appendDayOfYear(tokenLen);\n+                builder.appendDayOfYear(tokenLen);\n                 break;\n             case \u0027w\u0027:\n-                appendWeekOfWeekyear(tokenLen);\n+                builder.appendWeekOfWeekyear(tokenLen);\n                 break;\n             case \u0027a\u0027:\n-                appendHalfdayOfDayText();\n+                builder.appendHalfdayOfDayText();\n                 break;\n             case \u0027k\u0027:\n-                appendClockhourOfDay(tokenLen);\n+                builder.appendClockhourOfDay(tokenLen);\n                 break;\n             case \u0027K\u0027:\n-                appendClockhourOfHalfday(tokenLen);\n+                builder.appendClockhourOfHalfday(tokenLen);\n                 break;\n             case \u0027z\u0027:\n                 if (tokenLen \u003e\u003d 4) {\n-                    appendTimeZoneName();\n+                    builder.appendTimeZoneName();\n                 } else {\n-                    appendTimeZoneShortName();\n+                    builder.appendTimeZoneShortName();\n                 }\n                 break;\n             case \u0027Z\u0027:\n                 if (tokenLen \u003e\u003d 4) {\n-                    appendTimeZoneOffset(null, true, 2, 2);\n+                    builder.appendTimeZoneOffset(null, true, 2, 2);\n                 } else {\n-                    appendTimeZoneOffset(null, false, 2, 2);\n+                    builder.appendTimeZoneOffset(null, false, 2, 2);\n                 }\n                 break;\n             case \u0027\\\u0027\u0027:\n                 String sub \u003d token.substring(1);\n                 if (sub.length() \u003d\u003d 1) {\n-                    appendLiteral(sub.charAt(0));\n+                    builder.appendLiteral(sub.charAt(0));\n                 } else {\n-                    appendLiteral(new String(sub));\n+                    builder.appendLiteral(new String(sub));\n                 }\n                 break;\n             default:\n                 throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n         }\n     }\n-    return this;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "DateTimeFormatterBuilder",
            "newValue": "void"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "Move from Joda CVS\n\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@10 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1\n",
          "commitDate": "12/18/03, 6:07 PM",
          "commitName": "0e07ac6b2cff63550d7df336355ca63cc05aa40b",
          "commitAuthor": "Stephen Colebourne",
          "commitDateOld": "12/18/03, 2:04 PM",
          "commitNameOld": "1ba4f9861a0cfbc32c56efced3619874a43ec5dd",
          "commitAuthorOld": "Stephen Colebourne",
          "daysBetweenCommits": 0.17,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern) {\n    int length \u003d pattern.length();\n    int[] indexRef \u003d new int[1];\n    for (int i \u003d 0; i \u003c length; i++) {\n        indexRef[0] \u003d i;\n        String token \u003d parseToken(pattern, indexRef);\n        i \u003d indexRef[0];\n        int tokenLen \u003d token.length();\n        if (tokenLen \u003d\u003d 0) {\n            break;\n        }\n        char c \u003d token.charAt(0);\n        switch(c) {\n            case \u0027G\u0027:\n                builder.appendEraText();\n                break;\n            case \u0027C\u0027:\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case \u0027x\u0027:\n            case \u0027y\u0027:\n            case \u0027Y\u0027:\n                if (tokenLen \u003d\u003d 2) {\n                    DateTimeField field;\n                    Chronology chronoUTC \u003d builder.getChronology().withUTC();\n                    switch(c) {\n                        case \u0027x\u0027:\n                            field \u003d new RemainderDateTimeField(chronoUTC.weekyear(), \"weekyearOfCentury\", \"centuries\", 100);\n                            break;\n                        case \u0027y\u0027:\n                        default:\n                            field \u003d new RemainderDateTimeField(chronoUTC.year(), \"yearOfCentury\", \"centuries\", 100);\n                            break;\n                        case \u0027Y\u0027:\n                            field \u003d new RemainderDateTimeField(chronoUTC.yearOfEra(), \"yearOfCentury\", \"centuries\", 100);\n                            break;\n                    }\n                    builder.appendNumeric(field, 2, 2);\n                } else {\n                    int maxDigits \u003d 9;\n                    if (i + 1 \u003c length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            maxDigits \u003d tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n                    switch(c) {\n                        case \u0027x\u0027:\n                            builder.appendWeekyear(tokenLen, maxDigits);\n                            break;\n                        case \u0027y\u0027:\n                            builder.appendYear(tokenLen, maxDigits);\n                            break;\n                        case \u0027Y\u0027:\n                            builder.appendYearOfEra(tokenLen, maxDigits);\n                            break;\n                    }\n                }\n                break;\n            case \u0027M\u0027:\n                if (tokenLen \u003e\u003d 3) {\n                    if (tokenLen \u003e\u003d 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case \u0027d\u0027:\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case \u0027h\u0027:\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case \u0027H\u0027:\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case \u0027m\u0027:\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case \u0027s\u0027:\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case \u0027S\u0027:\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case \u0027e\u0027:\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case \u0027E\u0027:\n                if (tokenLen \u003e\u003d 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case \u0027D\u0027:\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case \u0027w\u0027:\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case \u0027a\u0027:\n                builder.appendHalfdayOfDayText();\n                break;\n            case \u0027k\u0027:\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case \u0027K\u0027:\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case \u0027z\u0027:\n                if (tokenLen \u003e\u003d 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName();\n                }\n                break;\n            case \u0027Z\u0027:\n                if (tokenLen \u003e\u003d 4) {\n                    builder.appendTimeZoneOffset(null, true, 2, 2);\n                } else {\n                    builder.appendTimeZoneOffset(null, false, 2, 2);\n                }\n                break;\n            case \u0027\\\u0027\u0027:\n                String sub \u003d token.substring(1);\n                if (sub.length() \u003d\u003d 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n        }\n    }\n}",
          "path": "JodaTime/src/java/org/joda/time/format/DateTimeFormat.java",
          "functionStartLine": 258,
          "functionName": "appendPatternTo",
          "functionAnnotation": "",
          "functionDoc": "Parses the given pattern and appends the rules to the given\nDateTimeFormatterBuilder.\n\n@param pattern pattern specification\n@throws IllegalArgumentException if the pattern is invalid\n@see #forPattern\n",
          "diff": "@@ -1,141 +1,141 @@\n-public DateTimeFormatterBuilder appendPattern(String pattern) throws IllegalArgumentException {\n+public static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern) {\n     int length \u003d pattern.length();\n     int[] indexRef \u003d new int[1];\n     for (int i \u003d 0; i \u003c length; i++) {\n         indexRef[0] \u003d i;\n         String token \u003d parseToken(pattern, indexRef);\n         i \u003d indexRef[0];\n         int tokenLen \u003d token.length();\n         if (tokenLen \u003d\u003d 0) {\n             break;\n         }\n         char c \u003d token.charAt(0);\n         switch(c) {\n             case \u0027G\u0027:\n-                appendEraText();\n+                builder.appendEraText();\n                 break;\n             case \u0027C\u0027:\n-                appendCenturyOfEra(tokenLen, tokenLen);\n+                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                 break;\n             case \u0027x\u0027:\n             case \u0027y\u0027:\n             case \u0027Y\u0027:\n                 if (tokenLen \u003d\u003d 2) {\n                     DateTimeField field;\n+                    Chronology chronoUTC \u003d builder.getChronology().withUTC();\n                     switch(c) {\n                         case \u0027x\u0027:\n-                            field \u003d new RemainderDateTimeField(\"weekyearOfCentury\", iChronoUTC.weekyear(), 100);\n+                            field \u003d new RemainderDateTimeField(chronoUTC.weekyear(), \"weekyearOfCentury\", \"centuries\", 100);\n                             break;\n                         case \u0027y\u0027:\n                         default:\n-                            field \u003d new RemainderDateTimeField(\"yearOfCentury\", iChronoUTC.year(), 100);\n+                            field \u003d new RemainderDateTimeField(chronoUTC.year(), \"yearOfCentury\", \"centuries\", 100);\n                             break;\n                         case \u0027Y\u0027:\n-                            field \u003d new RemainderDateTimeField(\"yearOfCentury\", iChronoUTC.yearOfEra(), 100);\n+                            field \u003d new RemainderDateTimeField(chronoUTC.yearOfEra(), \"yearOfCentury\", \"centuries\", 100);\n                             break;\n                     }\n-                    appendNumeric(field, 2, 2);\n+                    builder.appendNumeric(field, 2, 2);\n                 } else {\n                     int maxDigits \u003d 9;\n                     if (i + 1 \u003c length) {\n                         indexRef[0]++;\n                         if (isNumericToken(parseToken(pattern, indexRef))) {\n                             maxDigits \u003d tokenLen;\n                         }\n                         indexRef[0]--;\n                     }\n                     switch(c) {\n                         case \u0027x\u0027:\n-                            appendWeekyear(tokenLen, maxDigits);\n+                            builder.appendWeekyear(tokenLen, maxDigits);\n                             break;\n                         case \u0027y\u0027:\n-                            appendYear(tokenLen, maxDigits);\n+                            builder.appendYear(tokenLen, maxDigits);\n                             break;\n                         case \u0027Y\u0027:\n-                            appendYearOfEra(tokenLen, maxDigits);\n+                            builder.appendYearOfEra(tokenLen, maxDigits);\n                             break;\n                     }\n                 }\n                 break;\n             case \u0027M\u0027:\n                 if (tokenLen \u003e\u003d 3) {\n                     if (tokenLen \u003e\u003d 4) {\n-                        appendMonthOfYearText();\n+                        builder.appendMonthOfYearText();\n                     } else {\n-                        appendMonthOfYearShortText();\n+                        builder.appendMonthOfYearShortText();\n                     }\n                 } else {\n-                    appendMonthOfYear(tokenLen);\n+                    builder.appendMonthOfYear(tokenLen);\n                 }\n                 break;\n             case \u0027d\u0027:\n-                appendDayOfMonth(tokenLen);\n+                builder.appendDayOfMonth(tokenLen);\n                 break;\n             case \u0027h\u0027:\n-                appendClockhourOfHalfday(tokenLen);\n+                builder.appendClockhourOfHalfday(tokenLen);\n                 break;\n             case \u0027H\u0027:\n-                appendHourOfDay(tokenLen);\n+                builder.appendHourOfDay(tokenLen);\n                 break;\n             case \u0027m\u0027:\n-                appendMinuteOfHour(tokenLen);\n+                builder.appendMinuteOfHour(tokenLen);\n                 break;\n             case \u0027s\u0027:\n-                appendSecondOfMinute(tokenLen);\n+                builder.appendSecondOfMinute(tokenLen);\n                 break;\n             case \u0027S\u0027:\n-                appendFractionOfSecond(tokenLen, tokenLen);\n+                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                 break;\n             case \u0027e\u0027:\n-                appendDayOfWeek(tokenLen);\n+                builder.appendDayOfWeek(tokenLen);\n                 break;\n             case \u0027E\u0027:\n                 if (tokenLen \u003e\u003d 4) {\n-                    appendDayOfWeekText();\n+                    builder.appendDayOfWeekText();\n                 } else {\n-                    appendDayOfWeekShortText();\n+                    builder.appendDayOfWeekShortText();\n                 }\n                 break;\n             case \u0027D\u0027:\n-                appendDayOfYear(tokenLen);\n+                builder.appendDayOfYear(tokenLen);\n                 break;\n             case \u0027w\u0027:\n-                appendWeekOfWeekyear(tokenLen);\n+                builder.appendWeekOfWeekyear(tokenLen);\n                 break;\n             case \u0027a\u0027:\n-                appendHalfdayOfDayText();\n+                builder.appendHalfdayOfDayText();\n                 break;\n             case \u0027k\u0027:\n-                appendClockhourOfDay(tokenLen);\n+                builder.appendClockhourOfDay(tokenLen);\n                 break;\n             case \u0027K\u0027:\n-                appendClockhourOfHalfday(tokenLen);\n+                builder.appendClockhourOfHalfday(tokenLen);\n                 break;\n             case \u0027z\u0027:\n                 if (tokenLen \u003e\u003d 4) {\n-                    appendTimeZoneName();\n+                    builder.appendTimeZoneName();\n                 } else {\n-                    appendTimeZoneShortName();\n+                    builder.appendTimeZoneShortName();\n                 }\n                 break;\n             case \u0027Z\u0027:\n                 if (tokenLen \u003e\u003d 4) {\n-                    appendTimeZoneOffset(null, true, 2, 2);\n+                    builder.appendTimeZoneOffset(null, true, 2, 2);\n                 } else {\n-                    appendTimeZoneOffset(null, false, 2, 2);\n+                    builder.appendTimeZoneOffset(null, false, 2, 2);\n                 }\n                 break;\n             case \u0027\\\u0027\u0027:\n                 String sub \u003d token.substring(1);\n                 if (sub.length() \u003d\u003d 1) {\n-                    appendLiteral(sub.charAt(0));\n+                    builder.appendLiteral(sub.charAt(0));\n                 } else {\n-                    appendLiteral(new String(sub));\n+                    builder.appendLiteral(new String(sub));\n                 }\n                 break;\n             default:\n                 throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n         }\n     }\n-    return this;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[public]",
            "newValue": "[public, static]"
          }
        },
        {
          "type": "Yexceptionschange",
          "commitMessage": "Move from Joda CVS\n\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@10 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1\n",
          "commitDate": "12/18/03, 6:07 PM",
          "commitName": "0e07ac6b2cff63550d7df336355ca63cc05aa40b",
          "commitAuthor": "Stephen Colebourne",
          "commitDateOld": "12/18/03, 2:04 PM",
          "commitNameOld": "1ba4f9861a0cfbc32c56efced3619874a43ec5dd",
          "commitAuthorOld": "Stephen Colebourne",
          "daysBetweenCommits": 0.17,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern) {\n    int length \u003d pattern.length();\n    int[] indexRef \u003d new int[1];\n    for (int i \u003d 0; i \u003c length; i++) {\n        indexRef[0] \u003d i;\n        String token \u003d parseToken(pattern, indexRef);\n        i \u003d indexRef[0];\n        int tokenLen \u003d token.length();\n        if (tokenLen \u003d\u003d 0) {\n            break;\n        }\n        char c \u003d token.charAt(0);\n        switch(c) {\n            case \u0027G\u0027:\n                builder.appendEraText();\n                break;\n            case \u0027C\u0027:\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case \u0027x\u0027:\n            case \u0027y\u0027:\n            case \u0027Y\u0027:\n                if (tokenLen \u003d\u003d 2) {\n                    DateTimeField field;\n                    Chronology chronoUTC \u003d builder.getChronology().withUTC();\n                    switch(c) {\n                        case \u0027x\u0027:\n                            field \u003d new RemainderDateTimeField(chronoUTC.weekyear(), \"weekyearOfCentury\", \"centuries\", 100);\n                            break;\n                        case \u0027y\u0027:\n                        default:\n                            field \u003d new RemainderDateTimeField(chronoUTC.year(), \"yearOfCentury\", \"centuries\", 100);\n                            break;\n                        case \u0027Y\u0027:\n                            field \u003d new RemainderDateTimeField(chronoUTC.yearOfEra(), \"yearOfCentury\", \"centuries\", 100);\n                            break;\n                    }\n                    builder.appendNumeric(field, 2, 2);\n                } else {\n                    int maxDigits \u003d 9;\n                    if (i + 1 \u003c length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            maxDigits \u003d tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n                    switch(c) {\n                        case \u0027x\u0027:\n                            builder.appendWeekyear(tokenLen, maxDigits);\n                            break;\n                        case \u0027y\u0027:\n                            builder.appendYear(tokenLen, maxDigits);\n                            break;\n                        case \u0027Y\u0027:\n                            builder.appendYearOfEra(tokenLen, maxDigits);\n                            break;\n                    }\n                }\n                break;\n            case \u0027M\u0027:\n                if (tokenLen \u003e\u003d 3) {\n                    if (tokenLen \u003e\u003d 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case \u0027d\u0027:\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case \u0027h\u0027:\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case \u0027H\u0027:\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case \u0027m\u0027:\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case \u0027s\u0027:\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case \u0027S\u0027:\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case \u0027e\u0027:\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case \u0027E\u0027:\n                if (tokenLen \u003e\u003d 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case \u0027D\u0027:\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case \u0027w\u0027:\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case \u0027a\u0027:\n                builder.appendHalfdayOfDayText();\n                break;\n            case \u0027k\u0027:\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case \u0027K\u0027:\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case \u0027z\u0027:\n                if (tokenLen \u003e\u003d 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName();\n                }\n                break;\n            case \u0027Z\u0027:\n                if (tokenLen \u003e\u003d 4) {\n                    builder.appendTimeZoneOffset(null, true, 2, 2);\n                } else {\n                    builder.appendTimeZoneOffset(null, false, 2, 2);\n                }\n                break;\n            case \u0027\\\u0027\u0027:\n                String sub \u003d token.substring(1);\n                if (sub.length() \u003d\u003d 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n        }\n    }\n}",
          "path": "JodaTime/src/java/org/joda/time/format/DateTimeFormat.java",
          "functionStartLine": 258,
          "functionName": "appendPatternTo",
          "functionAnnotation": "",
          "functionDoc": "Parses the given pattern and appends the rules to the given\nDateTimeFormatterBuilder.\n\n@param pattern pattern specification\n@throws IllegalArgumentException if the pattern is invalid\n@see #forPattern\n",
          "diff": "@@ -1,141 +1,141 @@\n-public DateTimeFormatterBuilder appendPattern(String pattern) throws IllegalArgumentException {\n+public static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern) {\n     int length \u003d pattern.length();\n     int[] indexRef \u003d new int[1];\n     for (int i \u003d 0; i \u003c length; i++) {\n         indexRef[0] \u003d i;\n         String token \u003d parseToken(pattern, indexRef);\n         i \u003d indexRef[0];\n         int tokenLen \u003d token.length();\n         if (tokenLen \u003d\u003d 0) {\n             break;\n         }\n         char c \u003d token.charAt(0);\n         switch(c) {\n             case \u0027G\u0027:\n-                appendEraText();\n+                builder.appendEraText();\n                 break;\n             case \u0027C\u0027:\n-                appendCenturyOfEra(tokenLen, tokenLen);\n+                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                 break;\n             case \u0027x\u0027:\n             case \u0027y\u0027:\n             case \u0027Y\u0027:\n                 if (tokenLen \u003d\u003d 2) {\n                     DateTimeField field;\n+                    Chronology chronoUTC \u003d builder.getChronology().withUTC();\n                     switch(c) {\n                         case \u0027x\u0027:\n-                            field \u003d new RemainderDateTimeField(\"weekyearOfCentury\", iChronoUTC.weekyear(), 100);\n+                            field \u003d new RemainderDateTimeField(chronoUTC.weekyear(), \"weekyearOfCentury\", \"centuries\", 100);\n                             break;\n                         case \u0027y\u0027:\n                         default:\n-                            field \u003d new RemainderDateTimeField(\"yearOfCentury\", iChronoUTC.year(), 100);\n+                            field \u003d new RemainderDateTimeField(chronoUTC.year(), \"yearOfCentury\", \"centuries\", 100);\n                             break;\n                         case \u0027Y\u0027:\n-                            field \u003d new RemainderDateTimeField(\"yearOfCentury\", iChronoUTC.yearOfEra(), 100);\n+                            field \u003d new RemainderDateTimeField(chronoUTC.yearOfEra(), \"yearOfCentury\", \"centuries\", 100);\n                             break;\n                     }\n-                    appendNumeric(field, 2, 2);\n+                    builder.appendNumeric(field, 2, 2);\n                 } else {\n                     int maxDigits \u003d 9;\n                     if (i + 1 \u003c length) {\n                         indexRef[0]++;\n                         if (isNumericToken(parseToken(pattern, indexRef))) {\n                             maxDigits \u003d tokenLen;\n                         }\n                         indexRef[0]--;\n                     }\n                     switch(c) {\n                         case \u0027x\u0027:\n-                            appendWeekyear(tokenLen, maxDigits);\n+                            builder.appendWeekyear(tokenLen, maxDigits);\n                             break;\n                         case \u0027y\u0027:\n-                            appendYear(tokenLen, maxDigits);\n+                            builder.appendYear(tokenLen, maxDigits);\n                             break;\n                         case \u0027Y\u0027:\n-                            appendYearOfEra(tokenLen, maxDigits);\n+                            builder.appendYearOfEra(tokenLen, maxDigits);\n                             break;\n                     }\n                 }\n                 break;\n             case \u0027M\u0027:\n                 if (tokenLen \u003e\u003d 3) {\n                     if (tokenLen \u003e\u003d 4) {\n-                        appendMonthOfYearText();\n+                        builder.appendMonthOfYearText();\n                     } else {\n-                        appendMonthOfYearShortText();\n+                        builder.appendMonthOfYearShortText();\n                     }\n                 } else {\n-                    appendMonthOfYear(tokenLen);\n+                    builder.appendMonthOfYear(tokenLen);\n                 }\n                 break;\n             case \u0027d\u0027:\n-                appendDayOfMonth(tokenLen);\n+                builder.appendDayOfMonth(tokenLen);\n                 break;\n             case \u0027h\u0027:\n-                appendClockhourOfHalfday(tokenLen);\n+                builder.appendClockhourOfHalfday(tokenLen);\n                 break;\n             case \u0027H\u0027:\n-                appendHourOfDay(tokenLen);\n+                builder.appendHourOfDay(tokenLen);\n                 break;\n             case \u0027m\u0027:\n-                appendMinuteOfHour(tokenLen);\n+                builder.appendMinuteOfHour(tokenLen);\n                 break;\n             case \u0027s\u0027:\n-                appendSecondOfMinute(tokenLen);\n+                builder.appendSecondOfMinute(tokenLen);\n                 break;\n             case \u0027S\u0027:\n-                appendFractionOfSecond(tokenLen, tokenLen);\n+                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                 break;\n             case \u0027e\u0027:\n-                appendDayOfWeek(tokenLen);\n+                builder.appendDayOfWeek(tokenLen);\n                 break;\n             case \u0027E\u0027:\n                 if (tokenLen \u003e\u003d 4) {\n-                    appendDayOfWeekText();\n+                    builder.appendDayOfWeekText();\n                 } else {\n-                    appendDayOfWeekShortText();\n+                    builder.appendDayOfWeekShortText();\n                 }\n                 break;\n             case \u0027D\u0027:\n-                appendDayOfYear(tokenLen);\n+                builder.appendDayOfYear(tokenLen);\n                 break;\n             case \u0027w\u0027:\n-                appendWeekOfWeekyear(tokenLen);\n+                builder.appendWeekOfWeekyear(tokenLen);\n                 break;\n             case \u0027a\u0027:\n-                appendHalfdayOfDayText();\n+                builder.appendHalfdayOfDayText();\n                 break;\n             case \u0027k\u0027:\n-                appendClockhourOfDay(tokenLen);\n+                builder.appendClockhourOfDay(tokenLen);\n                 break;\n             case \u0027K\u0027:\n-                appendClockhourOfHalfday(tokenLen);\n+                builder.appendClockhourOfHalfday(tokenLen);\n                 break;\n             case \u0027z\u0027:\n                 if (tokenLen \u003e\u003d 4) {\n-                    appendTimeZoneName();\n+                    builder.appendTimeZoneName();\n                 } else {\n-                    appendTimeZoneShortName();\n+                    builder.appendTimeZoneShortName();\n                 }\n                 break;\n             case \u0027Z\u0027:\n                 if (tokenLen \u003e\u003d 4) {\n-                    appendTimeZoneOffset(null, true, 2, 2);\n+                    builder.appendTimeZoneOffset(null, true, 2, 2);\n                 } else {\n-                    appendTimeZoneOffset(null, false, 2, 2);\n+                    builder.appendTimeZoneOffset(null, false, 2, 2);\n                 }\n                 break;\n             case \u0027\\\u0027\u0027:\n                 String sub \u003d token.substring(1);\n                 if (sub.length() \u003d\u003d 1) {\n-                    appendLiteral(sub.charAt(0));\n+                    builder.appendLiteral(sub.charAt(0));\n                 } else {\n-                    appendLiteral(new String(sub));\n+                    builder.appendLiteral(new String(sub));\n                 }\n                 break;\n             default:\n                 throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n         }\n     }\n-    return this;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[IllegalArgumentException]",
            "newValue": "[]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Move from Joda CVS\n\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@10 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1\n",
          "commitDate": "12/18/03, 6:07 PM",
          "commitName": "0e07ac6b2cff63550d7df336355ca63cc05aa40b",
          "commitAuthor": "Stephen Colebourne",
          "commitDateOld": "12/18/03, 2:04 PM",
          "commitNameOld": "1ba4f9861a0cfbc32c56efced3619874a43ec5dd",
          "commitAuthorOld": "Stephen Colebourne",
          "daysBetweenCommits": 0.17,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern) {\n    int length \u003d pattern.length();\n    int[] indexRef \u003d new int[1];\n    for (int i \u003d 0; i \u003c length; i++) {\n        indexRef[0] \u003d i;\n        String token \u003d parseToken(pattern, indexRef);\n        i \u003d indexRef[0];\n        int tokenLen \u003d token.length();\n        if (tokenLen \u003d\u003d 0) {\n            break;\n        }\n        char c \u003d token.charAt(0);\n        switch(c) {\n            case \u0027G\u0027:\n                builder.appendEraText();\n                break;\n            case \u0027C\u0027:\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case \u0027x\u0027:\n            case \u0027y\u0027:\n            case \u0027Y\u0027:\n                if (tokenLen \u003d\u003d 2) {\n                    DateTimeField field;\n                    Chronology chronoUTC \u003d builder.getChronology().withUTC();\n                    switch(c) {\n                        case \u0027x\u0027:\n                            field \u003d new RemainderDateTimeField(chronoUTC.weekyear(), \"weekyearOfCentury\", \"centuries\", 100);\n                            break;\n                        case \u0027y\u0027:\n                        default:\n                            field \u003d new RemainderDateTimeField(chronoUTC.year(), \"yearOfCentury\", \"centuries\", 100);\n                            break;\n                        case \u0027Y\u0027:\n                            field \u003d new RemainderDateTimeField(chronoUTC.yearOfEra(), \"yearOfCentury\", \"centuries\", 100);\n                            break;\n                    }\n                    builder.appendNumeric(field, 2, 2);\n                } else {\n                    int maxDigits \u003d 9;\n                    if (i + 1 \u003c length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            maxDigits \u003d tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n                    switch(c) {\n                        case \u0027x\u0027:\n                            builder.appendWeekyear(tokenLen, maxDigits);\n                            break;\n                        case \u0027y\u0027:\n                            builder.appendYear(tokenLen, maxDigits);\n                            break;\n                        case \u0027Y\u0027:\n                            builder.appendYearOfEra(tokenLen, maxDigits);\n                            break;\n                    }\n                }\n                break;\n            case \u0027M\u0027:\n                if (tokenLen \u003e\u003d 3) {\n                    if (tokenLen \u003e\u003d 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case \u0027d\u0027:\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case \u0027h\u0027:\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case \u0027H\u0027:\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case \u0027m\u0027:\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case \u0027s\u0027:\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case \u0027S\u0027:\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case \u0027e\u0027:\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case \u0027E\u0027:\n                if (tokenLen \u003e\u003d 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case \u0027D\u0027:\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case \u0027w\u0027:\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case \u0027a\u0027:\n                builder.appendHalfdayOfDayText();\n                break;\n            case \u0027k\u0027:\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case \u0027K\u0027:\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case \u0027z\u0027:\n                if (tokenLen \u003e\u003d 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName();\n                }\n                break;\n            case \u0027Z\u0027:\n                if (tokenLen \u003e\u003d 4) {\n                    builder.appendTimeZoneOffset(null, true, 2, 2);\n                } else {\n                    builder.appendTimeZoneOffset(null, false, 2, 2);\n                }\n                break;\n            case \u0027\\\u0027\u0027:\n                String sub \u003d token.substring(1);\n                if (sub.length() \u003d\u003d 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n        }\n    }\n}",
          "path": "JodaTime/src/java/org/joda/time/format/DateTimeFormat.java",
          "functionStartLine": 258,
          "functionName": "appendPatternTo",
          "functionAnnotation": "",
          "functionDoc": "Parses the given pattern and appends the rules to the given\nDateTimeFormatterBuilder.\n\n@param pattern pattern specification\n@throws IllegalArgumentException if the pattern is invalid\n@see #forPattern\n",
          "diff": "@@ -1,141 +1,141 @@\n-public DateTimeFormatterBuilder appendPattern(String pattern) throws IllegalArgumentException {\n+public static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern) {\n     int length \u003d pattern.length();\n     int[] indexRef \u003d new int[1];\n     for (int i \u003d 0; i \u003c length; i++) {\n         indexRef[0] \u003d i;\n         String token \u003d parseToken(pattern, indexRef);\n         i \u003d indexRef[0];\n         int tokenLen \u003d token.length();\n         if (tokenLen \u003d\u003d 0) {\n             break;\n         }\n         char c \u003d token.charAt(0);\n         switch(c) {\n             case \u0027G\u0027:\n-                appendEraText();\n+                builder.appendEraText();\n                 break;\n             case \u0027C\u0027:\n-                appendCenturyOfEra(tokenLen, tokenLen);\n+                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                 break;\n             case \u0027x\u0027:\n             case \u0027y\u0027:\n             case \u0027Y\u0027:\n                 if (tokenLen \u003d\u003d 2) {\n                     DateTimeField field;\n+                    Chronology chronoUTC \u003d builder.getChronology().withUTC();\n                     switch(c) {\n                         case \u0027x\u0027:\n-                            field \u003d new RemainderDateTimeField(\"weekyearOfCentury\", iChronoUTC.weekyear(), 100);\n+                            field \u003d new RemainderDateTimeField(chronoUTC.weekyear(), \"weekyearOfCentury\", \"centuries\", 100);\n                             break;\n                         case \u0027y\u0027:\n                         default:\n-                            field \u003d new RemainderDateTimeField(\"yearOfCentury\", iChronoUTC.year(), 100);\n+                            field \u003d new RemainderDateTimeField(chronoUTC.year(), \"yearOfCentury\", \"centuries\", 100);\n                             break;\n                         case \u0027Y\u0027:\n-                            field \u003d new RemainderDateTimeField(\"yearOfCentury\", iChronoUTC.yearOfEra(), 100);\n+                            field \u003d new RemainderDateTimeField(chronoUTC.yearOfEra(), \"yearOfCentury\", \"centuries\", 100);\n                             break;\n                     }\n-                    appendNumeric(field, 2, 2);\n+                    builder.appendNumeric(field, 2, 2);\n                 } else {\n                     int maxDigits \u003d 9;\n                     if (i + 1 \u003c length) {\n                         indexRef[0]++;\n                         if (isNumericToken(parseToken(pattern, indexRef))) {\n                             maxDigits \u003d tokenLen;\n                         }\n                         indexRef[0]--;\n                     }\n                     switch(c) {\n                         case \u0027x\u0027:\n-                            appendWeekyear(tokenLen, maxDigits);\n+                            builder.appendWeekyear(tokenLen, maxDigits);\n                             break;\n                         case \u0027y\u0027:\n-                            appendYear(tokenLen, maxDigits);\n+                            builder.appendYear(tokenLen, maxDigits);\n                             break;\n                         case \u0027Y\u0027:\n-                            appendYearOfEra(tokenLen, maxDigits);\n+                            builder.appendYearOfEra(tokenLen, maxDigits);\n                             break;\n                     }\n                 }\n                 break;\n             case \u0027M\u0027:\n                 if (tokenLen \u003e\u003d 3) {\n                     if (tokenLen \u003e\u003d 4) {\n-                        appendMonthOfYearText();\n+                        builder.appendMonthOfYearText();\n                     } else {\n-                        appendMonthOfYearShortText();\n+                        builder.appendMonthOfYearShortText();\n                     }\n                 } else {\n-                    appendMonthOfYear(tokenLen);\n+                    builder.appendMonthOfYear(tokenLen);\n                 }\n                 break;\n             case \u0027d\u0027:\n-                appendDayOfMonth(tokenLen);\n+                builder.appendDayOfMonth(tokenLen);\n                 break;\n             case \u0027h\u0027:\n-                appendClockhourOfHalfday(tokenLen);\n+                builder.appendClockhourOfHalfday(tokenLen);\n                 break;\n             case \u0027H\u0027:\n-                appendHourOfDay(tokenLen);\n+                builder.appendHourOfDay(tokenLen);\n                 break;\n             case \u0027m\u0027:\n-                appendMinuteOfHour(tokenLen);\n+                builder.appendMinuteOfHour(tokenLen);\n                 break;\n             case \u0027s\u0027:\n-                appendSecondOfMinute(tokenLen);\n+                builder.appendSecondOfMinute(tokenLen);\n                 break;\n             case \u0027S\u0027:\n-                appendFractionOfSecond(tokenLen, tokenLen);\n+                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                 break;\n             case \u0027e\u0027:\n-                appendDayOfWeek(tokenLen);\n+                builder.appendDayOfWeek(tokenLen);\n                 break;\n             case \u0027E\u0027:\n                 if (tokenLen \u003e\u003d 4) {\n-                    appendDayOfWeekText();\n+                    builder.appendDayOfWeekText();\n                 } else {\n-                    appendDayOfWeekShortText();\n+                    builder.appendDayOfWeekShortText();\n                 }\n                 break;\n             case \u0027D\u0027:\n-                appendDayOfYear(tokenLen);\n+                builder.appendDayOfYear(tokenLen);\n                 break;\n             case \u0027w\u0027:\n-                appendWeekOfWeekyear(tokenLen);\n+                builder.appendWeekOfWeekyear(tokenLen);\n                 break;\n             case \u0027a\u0027:\n-                appendHalfdayOfDayText();\n+                builder.appendHalfdayOfDayText();\n                 break;\n             case \u0027k\u0027:\n-                appendClockhourOfDay(tokenLen);\n+                builder.appendClockhourOfDay(tokenLen);\n                 break;\n             case \u0027K\u0027:\n-                appendClockhourOfHalfday(tokenLen);\n+                builder.appendClockhourOfHalfday(tokenLen);\n                 break;\n             case \u0027z\u0027:\n                 if (tokenLen \u003e\u003d 4) {\n-                    appendTimeZoneName();\n+                    builder.appendTimeZoneName();\n                 } else {\n-                    appendTimeZoneShortName();\n+                    builder.appendTimeZoneShortName();\n                 }\n                 break;\n             case \u0027Z\u0027:\n                 if (tokenLen \u003e\u003d 4) {\n-                    appendTimeZoneOffset(null, true, 2, 2);\n+                    builder.appendTimeZoneOffset(null, true, 2, 2);\n                 } else {\n-                    appendTimeZoneOffset(null, false, 2, 2);\n+                    builder.appendTimeZoneOffset(null, false, 2, 2);\n                 }\n                 break;\n             case \u0027\\\u0027\u0027:\n                 String sub \u003d token.substring(1);\n                 if (sub.length() \u003d\u003d 1) {\n-                    appendLiteral(sub.charAt(0));\n+                    builder.appendLiteral(sub.charAt(0));\n                 } else {\n-                    appendLiteral(new String(sub));\n+                    builder.appendLiteral(new String(sub));\n                 }\n                 break;\n             default:\n                 throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n         }\n     }\n-    return this;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Move from Joda CVS\n\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@10 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1\n",
          "commitDate": "12/18/03, 6:07 PM",
          "commitName": "0e07ac6b2cff63550d7df336355ca63cc05aa40b",
          "commitAuthor": "Stephen Colebourne",
          "commitDateOld": "12/18/03, 2:04 PM",
          "commitNameOld": "1ba4f9861a0cfbc32c56efced3619874a43ec5dd",
          "commitAuthorOld": "Stephen Colebourne",
          "daysBetweenCommits": 0.17,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern) {\n    int length \u003d pattern.length();\n    int[] indexRef \u003d new int[1];\n    for (int i \u003d 0; i \u003c length; i++) {\n        indexRef[0] \u003d i;\n        String token \u003d parseToken(pattern, indexRef);\n        i \u003d indexRef[0];\n        int tokenLen \u003d token.length();\n        if (tokenLen \u003d\u003d 0) {\n            break;\n        }\n        char c \u003d token.charAt(0);\n        switch(c) {\n            case \u0027G\u0027:\n                builder.appendEraText();\n                break;\n            case \u0027C\u0027:\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case \u0027x\u0027:\n            case \u0027y\u0027:\n            case \u0027Y\u0027:\n                if (tokenLen \u003d\u003d 2) {\n                    DateTimeField field;\n                    Chronology chronoUTC \u003d builder.getChronology().withUTC();\n                    switch(c) {\n                        case \u0027x\u0027:\n                            field \u003d new RemainderDateTimeField(chronoUTC.weekyear(), \"weekyearOfCentury\", \"centuries\", 100);\n                            break;\n                        case \u0027y\u0027:\n                        default:\n                            field \u003d new RemainderDateTimeField(chronoUTC.year(), \"yearOfCentury\", \"centuries\", 100);\n                            break;\n                        case \u0027Y\u0027:\n                            field \u003d new RemainderDateTimeField(chronoUTC.yearOfEra(), \"yearOfCentury\", \"centuries\", 100);\n                            break;\n                    }\n                    builder.appendNumeric(field, 2, 2);\n                } else {\n                    int maxDigits \u003d 9;\n                    if (i + 1 \u003c length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            maxDigits \u003d tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n                    switch(c) {\n                        case \u0027x\u0027:\n                            builder.appendWeekyear(tokenLen, maxDigits);\n                            break;\n                        case \u0027y\u0027:\n                            builder.appendYear(tokenLen, maxDigits);\n                            break;\n                        case \u0027Y\u0027:\n                            builder.appendYearOfEra(tokenLen, maxDigits);\n                            break;\n                    }\n                }\n                break;\n            case \u0027M\u0027:\n                if (tokenLen \u003e\u003d 3) {\n                    if (tokenLen \u003e\u003d 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case \u0027d\u0027:\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case \u0027h\u0027:\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case \u0027H\u0027:\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case \u0027m\u0027:\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case \u0027s\u0027:\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case \u0027S\u0027:\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case \u0027e\u0027:\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case \u0027E\u0027:\n                if (tokenLen \u003e\u003d 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case \u0027D\u0027:\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case \u0027w\u0027:\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case \u0027a\u0027:\n                builder.appendHalfdayOfDayText();\n                break;\n            case \u0027k\u0027:\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case \u0027K\u0027:\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case \u0027z\u0027:\n                if (tokenLen \u003e\u003d 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName();\n                }\n                break;\n            case \u0027Z\u0027:\n                if (tokenLen \u003e\u003d 4) {\n                    builder.appendTimeZoneOffset(null, true, 2, 2);\n                } else {\n                    builder.appendTimeZoneOffset(null, false, 2, 2);\n                }\n                break;\n            case \u0027\\\u0027\u0027:\n                String sub \u003d token.substring(1);\n                if (sub.length() \u003d\u003d 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n        }\n    }\n}",
          "path": "JodaTime/src/java/org/joda/time/format/DateTimeFormat.java",
          "functionStartLine": 258,
          "functionName": "appendPatternTo",
          "functionAnnotation": "",
          "functionDoc": "Parses the given pattern and appends the rules to the given\nDateTimeFormatterBuilder.\n\n@param pattern pattern specification\n@throws IllegalArgumentException if the pattern is invalid\n@see #forPattern\n",
          "diff": "@@ -1,141 +1,141 @@\n-public DateTimeFormatterBuilder appendPattern(String pattern) throws IllegalArgumentException {\n+public static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern) {\n     int length \u003d pattern.length();\n     int[] indexRef \u003d new int[1];\n     for (int i \u003d 0; i \u003c length; i++) {\n         indexRef[0] \u003d i;\n         String token \u003d parseToken(pattern, indexRef);\n         i \u003d indexRef[0];\n         int tokenLen \u003d token.length();\n         if (tokenLen \u003d\u003d 0) {\n             break;\n         }\n         char c \u003d token.charAt(0);\n         switch(c) {\n             case \u0027G\u0027:\n-                appendEraText();\n+                builder.appendEraText();\n                 break;\n             case \u0027C\u0027:\n-                appendCenturyOfEra(tokenLen, tokenLen);\n+                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                 break;\n             case \u0027x\u0027:\n             case \u0027y\u0027:\n             case \u0027Y\u0027:\n                 if (tokenLen \u003d\u003d 2) {\n                     DateTimeField field;\n+                    Chronology chronoUTC \u003d builder.getChronology().withUTC();\n                     switch(c) {\n                         case \u0027x\u0027:\n-                            field \u003d new RemainderDateTimeField(\"weekyearOfCentury\", iChronoUTC.weekyear(), 100);\n+                            field \u003d new RemainderDateTimeField(chronoUTC.weekyear(), \"weekyearOfCentury\", \"centuries\", 100);\n                             break;\n                         case \u0027y\u0027:\n                         default:\n-                            field \u003d new RemainderDateTimeField(\"yearOfCentury\", iChronoUTC.year(), 100);\n+                            field \u003d new RemainderDateTimeField(chronoUTC.year(), \"yearOfCentury\", \"centuries\", 100);\n                             break;\n                         case \u0027Y\u0027:\n-                            field \u003d new RemainderDateTimeField(\"yearOfCentury\", iChronoUTC.yearOfEra(), 100);\n+                            field \u003d new RemainderDateTimeField(chronoUTC.yearOfEra(), \"yearOfCentury\", \"centuries\", 100);\n                             break;\n                     }\n-                    appendNumeric(field, 2, 2);\n+                    builder.appendNumeric(field, 2, 2);\n                 } else {\n                     int maxDigits \u003d 9;\n                     if (i + 1 \u003c length) {\n                         indexRef[0]++;\n                         if (isNumericToken(parseToken(pattern, indexRef))) {\n                             maxDigits \u003d tokenLen;\n                         }\n                         indexRef[0]--;\n                     }\n                     switch(c) {\n                         case \u0027x\u0027:\n-                            appendWeekyear(tokenLen, maxDigits);\n+                            builder.appendWeekyear(tokenLen, maxDigits);\n                             break;\n                         case \u0027y\u0027:\n-                            appendYear(tokenLen, maxDigits);\n+                            builder.appendYear(tokenLen, maxDigits);\n                             break;\n                         case \u0027Y\u0027:\n-                            appendYearOfEra(tokenLen, maxDigits);\n+                            builder.appendYearOfEra(tokenLen, maxDigits);\n                             break;\n                     }\n                 }\n                 break;\n             case \u0027M\u0027:\n                 if (tokenLen \u003e\u003d 3) {\n                     if (tokenLen \u003e\u003d 4) {\n-                        appendMonthOfYearText();\n+                        builder.appendMonthOfYearText();\n                     } else {\n-                        appendMonthOfYearShortText();\n+                        builder.appendMonthOfYearShortText();\n                     }\n                 } else {\n-                    appendMonthOfYear(tokenLen);\n+                    builder.appendMonthOfYear(tokenLen);\n                 }\n                 break;\n             case \u0027d\u0027:\n-                appendDayOfMonth(tokenLen);\n+                builder.appendDayOfMonth(tokenLen);\n                 break;\n             case \u0027h\u0027:\n-                appendClockhourOfHalfday(tokenLen);\n+                builder.appendClockhourOfHalfday(tokenLen);\n                 break;\n             case \u0027H\u0027:\n-                appendHourOfDay(tokenLen);\n+                builder.appendHourOfDay(tokenLen);\n                 break;\n             case \u0027m\u0027:\n-                appendMinuteOfHour(tokenLen);\n+                builder.appendMinuteOfHour(tokenLen);\n                 break;\n             case \u0027s\u0027:\n-                appendSecondOfMinute(tokenLen);\n+                builder.appendSecondOfMinute(tokenLen);\n                 break;\n             case \u0027S\u0027:\n-                appendFractionOfSecond(tokenLen, tokenLen);\n+                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                 break;\n             case \u0027e\u0027:\n-                appendDayOfWeek(tokenLen);\n+                builder.appendDayOfWeek(tokenLen);\n                 break;\n             case \u0027E\u0027:\n                 if (tokenLen \u003e\u003d 4) {\n-                    appendDayOfWeekText();\n+                    builder.appendDayOfWeekText();\n                 } else {\n-                    appendDayOfWeekShortText();\n+                    builder.appendDayOfWeekShortText();\n                 }\n                 break;\n             case \u0027D\u0027:\n-                appendDayOfYear(tokenLen);\n+                builder.appendDayOfYear(tokenLen);\n                 break;\n             case \u0027w\u0027:\n-                appendWeekOfWeekyear(tokenLen);\n+                builder.appendWeekOfWeekyear(tokenLen);\n                 break;\n             case \u0027a\u0027:\n-                appendHalfdayOfDayText();\n+                builder.appendHalfdayOfDayText();\n                 break;\n             case \u0027k\u0027:\n-                appendClockhourOfDay(tokenLen);\n+                builder.appendClockhourOfDay(tokenLen);\n                 break;\n             case \u0027K\u0027:\n-                appendClockhourOfHalfday(tokenLen);\n+                builder.appendClockhourOfHalfday(tokenLen);\n                 break;\n             case \u0027z\u0027:\n                 if (tokenLen \u003e\u003d 4) {\n-                    appendTimeZoneName();\n+                    builder.appendTimeZoneName();\n                 } else {\n-                    appendTimeZoneShortName();\n+                    builder.appendTimeZoneShortName();\n                 }\n                 break;\n             case \u0027Z\u0027:\n                 if (tokenLen \u003e\u003d 4) {\n-                    appendTimeZoneOffset(null, true, 2, 2);\n+                    builder.appendTimeZoneOffset(null, true, 2, 2);\n                 } else {\n-                    appendTimeZoneOffset(null, false, 2, 2);\n+                    builder.appendTimeZoneOffset(null, false, 2, 2);\n                 }\n                 break;\n             case \u0027\\\u0027\u0027:\n                 String sub \u003d token.substring(1);\n                 if (sub.length() \u003d\u003d 1) {\n-                    appendLiteral(sub.charAt(0));\n+                    builder.appendLiteral(sub.charAt(0));\n                 } else {\n-                    appendLiteral(new String(sub));\n+                    builder.appendLiteral(new String(sub));\n                 }\n                 break;\n             default:\n                 throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n         }\n     }\n-    return this;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "The pattern syntax is compatible with java.text.SimpleDateFormat, but a\nfew more symbols are also supported.\n\u003cp\u003e\nTo specify the time format use a \u003cem\u003etime pattern\u003c/em\u003e string.\nIn this pattern, all ASCII letters are reserved as pattern letters,\nwhich are defined as the following:\n\u003cblockquote\u003e\n\u003cpre\u003e\nSymbol  Meaning                      Presentation  Examples\n------  -------                      ------------  -------\nG       era                          text          AD\nC       century of era (\u0026gt;\u003d0)         number        20\nY       year of era (\u0026gt;\u003d0)            year          1996\n\nx       weekyear                     year          1996\nw       week of weekyear             number        27\ne       day of week                  number        2\nE       day of week                  text          Tuesday; Tue\n\ny       year                         year          1996\nD       day of year                  number        189\nM       month of year                month         July; Jul; 07\nd       day of month                 number        10\n\na       halfday of day               text          PM\nK       hour of halfday (0~11)       number        0\nh       clockhour of halfday (1~12)  number        12\n\nH       hour of day (0~23)           number        0\nk       clockhour of day (1~24)      number        24\nm       minute of hour               number        30\ns       second of minute             number        55\nS       fraction of second           number        978\n\nz       time zone                    text          Pacific Standard Time; PST\nZ       RFC 822 time zone            text          -0800; -08:00\n\n\u0027       escape for text              delimiter\n\u0027\u0027      single quote                 literal       \u0027\n\u003c/pre\u003e\n\u003c/blockquote\u003e\nThe count of pattern letters determine the format.\n\u003cp\u003e\n\u003cstrong\u003eText\u003c/strong\u003e: If the number of pattern letters is 4 or more,\nthe full form is used; otherwise a short or abbreviated form is used if\navailable.\n\u003cp\u003e\n\u003cstrong\u003eNumber\u003c/strong\u003e: The minimum number of digits. Shorter numbers\nare zero-padded to this amount.\n\u003cp\u003e\n\u003cstrong\u003eYear\u003c/strong\u003e: Numeric presentation for year and weekyear fields\nare handled specially. For example, if the count of \u0027y\u0027 is 2, the year\nwill be displayed as the zero-based year of the century, which is two\ndigits.\n\u003cp\u003e\n\u003cstrong\u003eMonth\u003c/strong\u003e: 3 or over, use text, otherwise use number.\n\u003cp\u003e\nAny characters in the pattern that are not in the ranges of [\u0027a\u0027..\u0027z\u0027]\nand [\u0027A\u0027..\u0027Z\u0027] will be treated as quoted text. For instance, characters\nlike \u0027:\u0027, \u0027.\u0027, \u0027 \u0027, \u0027#\u0027 and \u0027@\u0027 will appear in the resulting time text\neven they are not embraced within single quotes.\n",
            "newValue": "Parses the given pattern and appends the rules to the given\nDateTimeFormatterBuilder.\n\n@param pattern pattern specification\n@throws IllegalArgumentException if the pattern is invalid\n@see #forPattern\n"
          }
        },
        {
          "type": "Yrename",
          "commitMessage": "Move from Joda CVS\n\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@10 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1\n",
          "commitDate": "12/18/03, 6:07 PM",
          "commitName": "0e07ac6b2cff63550d7df336355ca63cc05aa40b",
          "commitAuthor": "Stephen Colebourne",
          "commitDateOld": "12/18/03, 2:04 PM",
          "commitNameOld": "1ba4f9861a0cfbc32c56efced3619874a43ec5dd",
          "commitAuthorOld": "Stephen Colebourne",
          "daysBetweenCommits": 0.17,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern) {\n    int length \u003d pattern.length();\n    int[] indexRef \u003d new int[1];\n    for (int i \u003d 0; i \u003c length; i++) {\n        indexRef[0] \u003d i;\n        String token \u003d parseToken(pattern, indexRef);\n        i \u003d indexRef[0];\n        int tokenLen \u003d token.length();\n        if (tokenLen \u003d\u003d 0) {\n            break;\n        }\n        char c \u003d token.charAt(0);\n        switch(c) {\n            case \u0027G\u0027:\n                builder.appendEraText();\n                break;\n            case \u0027C\u0027:\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case \u0027x\u0027:\n            case \u0027y\u0027:\n            case \u0027Y\u0027:\n                if (tokenLen \u003d\u003d 2) {\n                    DateTimeField field;\n                    Chronology chronoUTC \u003d builder.getChronology().withUTC();\n                    switch(c) {\n                        case \u0027x\u0027:\n                            field \u003d new RemainderDateTimeField(chronoUTC.weekyear(), \"weekyearOfCentury\", \"centuries\", 100);\n                            break;\n                        case \u0027y\u0027:\n                        default:\n                            field \u003d new RemainderDateTimeField(chronoUTC.year(), \"yearOfCentury\", \"centuries\", 100);\n                            break;\n                        case \u0027Y\u0027:\n                            field \u003d new RemainderDateTimeField(chronoUTC.yearOfEra(), \"yearOfCentury\", \"centuries\", 100);\n                            break;\n                    }\n                    builder.appendNumeric(field, 2, 2);\n                } else {\n                    int maxDigits \u003d 9;\n                    if (i + 1 \u003c length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            maxDigits \u003d tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n                    switch(c) {\n                        case \u0027x\u0027:\n                            builder.appendWeekyear(tokenLen, maxDigits);\n                            break;\n                        case \u0027y\u0027:\n                            builder.appendYear(tokenLen, maxDigits);\n                            break;\n                        case \u0027Y\u0027:\n                            builder.appendYearOfEra(tokenLen, maxDigits);\n                            break;\n                    }\n                }\n                break;\n            case \u0027M\u0027:\n                if (tokenLen \u003e\u003d 3) {\n                    if (tokenLen \u003e\u003d 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case \u0027d\u0027:\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case \u0027h\u0027:\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case \u0027H\u0027:\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case \u0027m\u0027:\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case \u0027s\u0027:\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case \u0027S\u0027:\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case \u0027e\u0027:\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case \u0027E\u0027:\n                if (tokenLen \u003e\u003d 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case \u0027D\u0027:\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case \u0027w\u0027:\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case \u0027a\u0027:\n                builder.appendHalfdayOfDayText();\n                break;\n            case \u0027k\u0027:\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case \u0027K\u0027:\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case \u0027z\u0027:\n                if (tokenLen \u003e\u003d 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName();\n                }\n                break;\n            case \u0027Z\u0027:\n                if (tokenLen \u003e\u003d 4) {\n                    builder.appendTimeZoneOffset(null, true, 2, 2);\n                } else {\n                    builder.appendTimeZoneOffset(null, false, 2, 2);\n                }\n                break;\n            case \u0027\\\u0027\u0027:\n                String sub \u003d token.substring(1);\n                if (sub.length() \u003d\u003d 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n        }\n    }\n}",
          "path": "JodaTime/src/java/org/joda/time/format/DateTimeFormat.java",
          "functionStartLine": 258,
          "functionName": "appendPatternTo",
          "functionAnnotation": "",
          "functionDoc": "Parses the given pattern and appends the rules to the given\nDateTimeFormatterBuilder.\n\n@param pattern pattern specification\n@throws IllegalArgumentException if the pattern is invalid\n@see #forPattern\n",
          "diff": "@@ -1,141 +1,141 @@\n-public DateTimeFormatterBuilder appendPattern(String pattern) throws IllegalArgumentException {\n+public static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern) {\n     int length \u003d pattern.length();\n     int[] indexRef \u003d new int[1];\n     for (int i \u003d 0; i \u003c length; i++) {\n         indexRef[0] \u003d i;\n         String token \u003d parseToken(pattern, indexRef);\n         i \u003d indexRef[0];\n         int tokenLen \u003d token.length();\n         if (tokenLen \u003d\u003d 0) {\n             break;\n         }\n         char c \u003d token.charAt(0);\n         switch(c) {\n             case \u0027G\u0027:\n-                appendEraText();\n+                builder.appendEraText();\n                 break;\n             case \u0027C\u0027:\n-                appendCenturyOfEra(tokenLen, tokenLen);\n+                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                 break;\n             case \u0027x\u0027:\n             case \u0027y\u0027:\n             case \u0027Y\u0027:\n                 if (tokenLen \u003d\u003d 2) {\n                     DateTimeField field;\n+                    Chronology chronoUTC \u003d builder.getChronology().withUTC();\n                     switch(c) {\n                         case \u0027x\u0027:\n-                            field \u003d new RemainderDateTimeField(\"weekyearOfCentury\", iChronoUTC.weekyear(), 100);\n+                            field \u003d new RemainderDateTimeField(chronoUTC.weekyear(), \"weekyearOfCentury\", \"centuries\", 100);\n                             break;\n                         case \u0027y\u0027:\n                         default:\n-                            field \u003d new RemainderDateTimeField(\"yearOfCentury\", iChronoUTC.year(), 100);\n+                            field \u003d new RemainderDateTimeField(chronoUTC.year(), \"yearOfCentury\", \"centuries\", 100);\n                             break;\n                         case \u0027Y\u0027:\n-                            field \u003d new RemainderDateTimeField(\"yearOfCentury\", iChronoUTC.yearOfEra(), 100);\n+                            field \u003d new RemainderDateTimeField(chronoUTC.yearOfEra(), \"yearOfCentury\", \"centuries\", 100);\n                             break;\n                     }\n-                    appendNumeric(field, 2, 2);\n+                    builder.appendNumeric(field, 2, 2);\n                 } else {\n                     int maxDigits \u003d 9;\n                     if (i + 1 \u003c length) {\n                         indexRef[0]++;\n                         if (isNumericToken(parseToken(pattern, indexRef))) {\n                             maxDigits \u003d tokenLen;\n                         }\n                         indexRef[0]--;\n                     }\n                     switch(c) {\n                         case \u0027x\u0027:\n-                            appendWeekyear(tokenLen, maxDigits);\n+                            builder.appendWeekyear(tokenLen, maxDigits);\n                             break;\n                         case \u0027y\u0027:\n-                            appendYear(tokenLen, maxDigits);\n+                            builder.appendYear(tokenLen, maxDigits);\n                             break;\n                         case \u0027Y\u0027:\n-                            appendYearOfEra(tokenLen, maxDigits);\n+                            builder.appendYearOfEra(tokenLen, maxDigits);\n                             break;\n                     }\n                 }\n                 break;\n             case \u0027M\u0027:\n                 if (tokenLen \u003e\u003d 3) {\n                     if (tokenLen \u003e\u003d 4) {\n-                        appendMonthOfYearText();\n+                        builder.appendMonthOfYearText();\n                     } else {\n-                        appendMonthOfYearShortText();\n+                        builder.appendMonthOfYearShortText();\n                     }\n                 } else {\n-                    appendMonthOfYear(tokenLen);\n+                    builder.appendMonthOfYear(tokenLen);\n                 }\n                 break;\n             case \u0027d\u0027:\n-                appendDayOfMonth(tokenLen);\n+                builder.appendDayOfMonth(tokenLen);\n                 break;\n             case \u0027h\u0027:\n-                appendClockhourOfHalfday(tokenLen);\n+                builder.appendClockhourOfHalfday(tokenLen);\n                 break;\n             case \u0027H\u0027:\n-                appendHourOfDay(tokenLen);\n+                builder.appendHourOfDay(tokenLen);\n                 break;\n             case \u0027m\u0027:\n-                appendMinuteOfHour(tokenLen);\n+                builder.appendMinuteOfHour(tokenLen);\n                 break;\n             case \u0027s\u0027:\n-                appendSecondOfMinute(tokenLen);\n+                builder.appendSecondOfMinute(tokenLen);\n                 break;\n             case \u0027S\u0027:\n-                appendFractionOfSecond(tokenLen, tokenLen);\n+                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                 break;\n             case \u0027e\u0027:\n-                appendDayOfWeek(tokenLen);\n+                builder.appendDayOfWeek(tokenLen);\n                 break;\n             case \u0027E\u0027:\n                 if (tokenLen \u003e\u003d 4) {\n-                    appendDayOfWeekText();\n+                    builder.appendDayOfWeekText();\n                 } else {\n-                    appendDayOfWeekShortText();\n+                    builder.appendDayOfWeekShortText();\n                 }\n                 break;\n             case \u0027D\u0027:\n-                appendDayOfYear(tokenLen);\n+                builder.appendDayOfYear(tokenLen);\n                 break;\n             case \u0027w\u0027:\n-                appendWeekOfWeekyear(tokenLen);\n+                builder.appendWeekOfWeekyear(tokenLen);\n                 break;\n             case \u0027a\u0027:\n-                appendHalfdayOfDayText();\n+                builder.appendHalfdayOfDayText();\n                 break;\n             case \u0027k\u0027:\n-                appendClockhourOfDay(tokenLen);\n+                builder.appendClockhourOfDay(tokenLen);\n                 break;\n             case \u0027K\u0027:\n-                appendClockhourOfHalfday(tokenLen);\n+                builder.appendClockhourOfHalfday(tokenLen);\n                 break;\n             case \u0027z\u0027:\n                 if (tokenLen \u003e\u003d 4) {\n-                    appendTimeZoneName();\n+                    builder.appendTimeZoneName();\n                 } else {\n-                    appendTimeZoneShortName();\n+                    builder.appendTimeZoneShortName();\n                 }\n                 break;\n             case \u0027Z\u0027:\n                 if (tokenLen \u003e\u003d 4) {\n-                    appendTimeZoneOffset(null, true, 2, 2);\n+                    builder.appendTimeZoneOffset(null, true, 2, 2);\n                 } else {\n-                    appendTimeZoneOffset(null, false, 2, 2);\n+                    builder.appendTimeZoneOffset(null, false, 2, 2);\n                 }\n                 break;\n             case \u0027\\\u0027\u0027:\n                 String sub \u003d token.substring(1);\n                 if (sub.length() \u003d\u003d 1) {\n-                    appendLiteral(sub.charAt(0));\n+                    builder.appendLiteral(sub.charAt(0));\n                 } else {\n-                    appendLiteral(new String(sub));\n+                    builder.appendLiteral(new String(sub));\n                 }\n                 break;\n             default:\n                 throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n         }\n     }\n-    return this;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "appendPattern",
            "newValue": "appendPatternTo"
          }
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "Move from Joda CVS\n\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@10 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1\n",
          "commitDate": "12/18/03, 6:07 PM",
          "commitName": "0e07ac6b2cff63550d7df336355ca63cc05aa40b",
          "commitAuthor": "Stephen Colebourne",
          "commitDateOld": "12/18/03, 2:04 PM",
          "commitNameOld": "1ba4f9861a0cfbc32c56efced3619874a43ec5dd",
          "commitAuthorOld": "Stephen Colebourne",
          "daysBetweenCommits": 0.17,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern) {\n    int length \u003d pattern.length();\n    int[] indexRef \u003d new int[1];\n    for (int i \u003d 0; i \u003c length; i++) {\n        indexRef[0] \u003d i;\n        String token \u003d parseToken(pattern, indexRef);\n        i \u003d indexRef[0];\n        int tokenLen \u003d token.length();\n        if (tokenLen \u003d\u003d 0) {\n            break;\n        }\n        char c \u003d token.charAt(0);\n        switch(c) {\n            case \u0027G\u0027:\n                builder.appendEraText();\n                break;\n            case \u0027C\u0027:\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case \u0027x\u0027:\n            case \u0027y\u0027:\n            case \u0027Y\u0027:\n                if (tokenLen \u003d\u003d 2) {\n                    DateTimeField field;\n                    Chronology chronoUTC \u003d builder.getChronology().withUTC();\n                    switch(c) {\n                        case \u0027x\u0027:\n                            field \u003d new RemainderDateTimeField(chronoUTC.weekyear(), \"weekyearOfCentury\", \"centuries\", 100);\n                            break;\n                        case \u0027y\u0027:\n                        default:\n                            field \u003d new RemainderDateTimeField(chronoUTC.year(), \"yearOfCentury\", \"centuries\", 100);\n                            break;\n                        case \u0027Y\u0027:\n                            field \u003d new RemainderDateTimeField(chronoUTC.yearOfEra(), \"yearOfCentury\", \"centuries\", 100);\n                            break;\n                    }\n                    builder.appendNumeric(field, 2, 2);\n                } else {\n                    int maxDigits \u003d 9;\n                    if (i + 1 \u003c length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            maxDigits \u003d tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n                    switch(c) {\n                        case \u0027x\u0027:\n                            builder.appendWeekyear(tokenLen, maxDigits);\n                            break;\n                        case \u0027y\u0027:\n                            builder.appendYear(tokenLen, maxDigits);\n                            break;\n                        case \u0027Y\u0027:\n                            builder.appendYearOfEra(tokenLen, maxDigits);\n                            break;\n                    }\n                }\n                break;\n            case \u0027M\u0027:\n                if (tokenLen \u003e\u003d 3) {\n                    if (tokenLen \u003e\u003d 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case \u0027d\u0027:\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case \u0027h\u0027:\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case \u0027H\u0027:\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case \u0027m\u0027:\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case \u0027s\u0027:\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case \u0027S\u0027:\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case \u0027e\u0027:\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case \u0027E\u0027:\n                if (tokenLen \u003e\u003d 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case \u0027D\u0027:\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case \u0027w\u0027:\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case \u0027a\u0027:\n                builder.appendHalfdayOfDayText();\n                break;\n            case \u0027k\u0027:\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case \u0027K\u0027:\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case \u0027z\u0027:\n                if (tokenLen \u003e\u003d 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName();\n                }\n                break;\n            case \u0027Z\u0027:\n                if (tokenLen \u003e\u003d 4) {\n                    builder.appendTimeZoneOffset(null, true, 2, 2);\n                } else {\n                    builder.appendTimeZoneOffset(null, false, 2, 2);\n                }\n                break;\n            case \u0027\\\u0027\u0027:\n                String sub \u003d token.substring(1);\n                if (sub.length() \u003d\u003d 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n        }\n    }\n}",
          "path": "JodaTime/src/java/org/joda/time/format/DateTimeFormat.java",
          "functionStartLine": 258,
          "functionName": "appendPatternTo",
          "functionAnnotation": "",
          "functionDoc": "Parses the given pattern and appends the rules to the given\nDateTimeFormatterBuilder.\n\n@param pattern pattern specification\n@throws IllegalArgumentException if the pattern is invalid\n@see #forPattern\n",
          "diff": "@@ -1,141 +1,141 @@\n-public DateTimeFormatterBuilder appendPattern(String pattern) throws IllegalArgumentException {\n+public static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern) {\n     int length \u003d pattern.length();\n     int[] indexRef \u003d new int[1];\n     for (int i \u003d 0; i \u003c length; i++) {\n         indexRef[0] \u003d i;\n         String token \u003d parseToken(pattern, indexRef);\n         i \u003d indexRef[0];\n         int tokenLen \u003d token.length();\n         if (tokenLen \u003d\u003d 0) {\n             break;\n         }\n         char c \u003d token.charAt(0);\n         switch(c) {\n             case \u0027G\u0027:\n-                appendEraText();\n+                builder.appendEraText();\n                 break;\n             case \u0027C\u0027:\n-                appendCenturyOfEra(tokenLen, tokenLen);\n+                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                 break;\n             case \u0027x\u0027:\n             case \u0027y\u0027:\n             case \u0027Y\u0027:\n                 if (tokenLen \u003d\u003d 2) {\n                     DateTimeField field;\n+                    Chronology chronoUTC \u003d builder.getChronology().withUTC();\n                     switch(c) {\n                         case \u0027x\u0027:\n-                            field \u003d new RemainderDateTimeField(\"weekyearOfCentury\", iChronoUTC.weekyear(), 100);\n+                            field \u003d new RemainderDateTimeField(chronoUTC.weekyear(), \"weekyearOfCentury\", \"centuries\", 100);\n                             break;\n                         case \u0027y\u0027:\n                         default:\n-                            field \u003d new RemainderDateTimeField(\"yearOfCentury\", iChronoUTC.year(), 100);\n+                            field \u003d new RemainderDateTimeField(chronoUTC.year(), \"yearOfCentury\", \"centuries\", 100);\n                             break;\n                         case \u0027Y\u0027:\n-                            field \u003d new RemainderDateTimeField(\"yearOfCentury\", iChronoUTC.yearOfEra(), 100);\n+                            field \u003d new RemainderDateTimeField(chronoUTC.yearOfEra(), \"yearOfCentury\", \"centuries\", 100);\n                             break;\n                     }\n-                    appendNumeric(field, 2, 2);\n+                    builder.appendNumeric(field, 2, 2);\n                 } else {\n                     int maxDigits \u003d 9;\n                     if (i + 1 \u003c length) {\n                         indexRef[0]++;\n                         if (isNumericToken(parseToken(pattern, indexRef))) {\n                             maxDigits \u003d tokenLen;\n                         }\n                         indexRef[0]--;\n                     }\n                     switch(c) {\n                         case \u0027x\u0027:\n-                            appendWeekyear(tokenLen, maxDigits);\n+                            builder.appendWeekyear(tokenLen, maxDigits);\n                             break;\n                         case \u0027y\u0027:\n-                            appendYear(tokenLen, maxDigits);\n+                            builder.appendYear(tokenLen, maxDigits);\n                             break;\n                         case \u0027Y\u0027:\n-                            appendYearOfEra(tokenLen, maxDigits);\n+                            builder.appendYearOfEra(tokenLen, maxDigits);\n                             break;\n                     }\n                 }\n                 break;\n             case \u0027M\u0027:\n                 if (tokenLen \u003e\u003d 3) {\n                     if (tokenLen \u003e\u003d 4) {\n-                        appendMonthOfYearText();\n+                        builder.appendMonthOfYearText();\n                     } else {\n-                        appendMonthOfYearShortText();\n+                        builder.appendMonthOfYearShortText();\n                     }\n                 } else {\n-                    appendMonthOfYear(tokenLen);\n+                    builder.appendMonthOfYear(tokenLen);\n                 }\n                 break;\n             case \u0027d\u0027:\n-                appendDayOfMonth(tokenLen);\n+                builder.appendDayOfMonth(tokenLen);\n                 break;\n             case \u0027h\u0027:\n-                appendClockhourOfHalfday(tokenLen);\n+                builder.appendClockhourOfHalfday(tokenLen);\n                 break;\n             case \u0027H\u0027:\n-                appendHourOfDay(tokenLen);\n+                builder.appendHourOfDay(tokenLen);\n                 break;\n             case \u0027m\u0027:\n-                appendMinuteOfHour(tokenLen);\n+                builder.appendMinuteOfHour(tokenLen);\n                 break;\n             case \u0027s\u0027:\n-                appendSecondOfMinute(tokenLen);\n+                builder.appendSecondOfMinute(tokenLen);\n                 break;\n             case \u0027S\u0027:\n-                appendFractionOfSecond(tokenLen, tokenLen);\n+                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                 break;\n             case \u0027e\u0027:\n-                appendDayOfWeek(tokenLen);\n+                builder.appendDayOfWeek(tokenLen);\n                 break;\n             case \u0027E\u0027:\n                 if (tokenLen \u003e\u003d 4) {\n-                    appendDayOfWeekText();\n+                    builder.appendDayOfWeekText();\n                 } else {\n-                    appendDayOfWeekShortText();\n+                    builder.appendDayOfWeekShortText();\n                 }\n                 break;\n             case \u0027D\u0027:\n-                appendDayOfYear(tokenLen);\n+                builder.appendDayOfYear(tokenLen);\n                 break;\n             case \u0027w\u0027:\n-                appendWeekOfWeekyear(tokenLen);\n+                builder.appendWeekOfWeekyear(tokenLen);\n                 break;\n             case \u0027a\u0027:\n-                appendHalfdayOfDayText();\n+                builder.appendHalfdayOfDayText();\n                 break;\n             case \u0027k\u0027:\n-                appendClockhourOfDay(tokenLen);\n+                builder.appendClockhourOfDay(tokenLen);\n                 break;\n             case \u0027K\u0027:\n-                appendClockhourOfHalfday(tokenLen);\n+                builder.appendClockhourOfHalfday(tokenLen);\n                 break;\n             case \u0027z\u0027:\n                 if (tokenLen \u003e\u003d 4) {\n-                    appendTimeZoneName();\n+                    builder.appendTimeZoneName();\n                 } else {\n-                    appendTimeZoneShortName();\n+                    builder.appendTimeZoneShortName();\n                 }\n                 break;\n             case \u0027Z\u0027:\n                 if (tokenLen \u003e\u003d 4) {\n-                    appendTimeZoneOffset(null, true, 2, 2);\n+                    builder.appendTimeZoneOffset(null, true, 2, 2);\n                 } else {\n-                    appendTimeZoneOffset(null, false, 2, 2);\n+                    builder.appendTimeZoneOffset(null, false, 2, 2);\n                 }\n                 break;\n             case \u0027\\\u0027\u0027:\n                 String sub \u003d token.substring(1);\n                 if (sub.length() \u003d\u003d 1) {\n-                    appendLiteral(sub.charAt(0));\n+                    builder.appendLiteral(sub.charAt(0));\n                 } else {\n-                    appendLiteral(new String(sub));\n+                    builder.appendLiteral(new String(sub));\n                 }\n                 break;\n             default:\n                 throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n         }\n     }\n-    return this;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[pattern-String]",
            "newValue": "[builder-DateTimeFormatterBuilder, pattern-String]"
          }
        }
      ]
    },
    "7fe68f297f7c372b515fde7f0bc8d721ec257ceb": {
      "type": "Yintroduced",
      "commitMessage": "Move version 0.9 to joda-time repository\n\n\ngit-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@4 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1\n",
      "commitDate": "12/16/03, 1:39 PM",
      "commitName": "7fe68f297f7c372b515fde7f0bc8d721ec257ceb",
      "commitAuthor": "Stephen Colebourne",
      "diff": "@@ -0,0 +1,141 @@\n+public DateTimeFormatterBuilder appendPattern(String pattern) throws IllegalArgumentException {\n+    int length \u003d pattern.length();\n+    int[] indexRef \u003d new int[1];\n+    for (int i \u003d 0; i \u003c length; i++) {\n+        indexRef[0] \u003d i;\n+        String token \u003d parseToken(pattern, indexRef);\n+        i \u003d indexRef[0];\n+        int tokenLen \u003d token.length();\n+        if (tokenLen \u003d\u003d 0) {\n+            break;\n+        }\n+        char c \u003d token.charAt(0);\n+        switch(c) {\n+            case \u0027G\u0027:\n+                appendEraText();\n+                break;\n+            case \u0027C\u0027:\n+                appendCenturyOfEra(tokenLen, tokenLen);\n+                break;\n+            case \u0027x\u0027:\n+            case \u0027y\u0027:\n+            case \u0027Y\u0027:\n+                if (tokenLen \u003d\u003d 2) {\n+                    DateTimeField field;\n+                    switch(c) {\n+                        case \u0027x\u0027:\n+                            field \u003d new RemainderDateTimeField(\"weekyearOfCentury\", iChronoUTC.weekyear(), 100);\n+                            break;\n+                        case \u0027y\u0027:\n+                        default:\n+                            field \u003d new RemainderDateTimeField(\"yearOfCentury\", iChronoUTC.year(), 100);\n+                            break;\n+                        case \u0027Y\u0027:\n+                            field \u003d new RemainderDateTimeField(\"yearOfCentury\", iChronoUTC.yearOfEra(), 100);\n+                            break;\n+                    }\n+                    appendNumeric(field, 2, 2);\n+                } else {\n+                    int maxDigits \u003d 9;\n+                    if (i + 1 \u003c length) {\n+                        indexRef[0]++;\n+                        if (isNumericToken(parseToken(pattern, indexRef))) {\n+                            maxDigits \u003d tokenLen;\n+                        }\n+                        indexRef[0]--;\n+                    }\n+                    switch(c) {\n+                        case \u0027x\u0027:\n+                            appendWeekyear(tokenLen, maxDigits);\n+                            break;\n+                        case \u0027y\u0027:\n+                            appendYear(tokenLen, maxDigits);\n+                            break;\n+                        case \u0027Y\u0027:\n+                            appendYearOfEra(tokenLen, maxDigits);\n+                            break;\n+                    }\n+                }\n+                break;\n+            case \u0027M\u0027:\n+                if (tokenLen \u003e\u003d 3) {\n+                    if (tokenLen \u003e\u003d 4) {\n+                        appendMonthOfYearText();\n+                    } else {\n+                        appendMonthOfYearShortText();\n+                    }\n+                } else {\n+                    appendMonthOfYear(tokenLen);\n+                }\n+                break;\n+            case \u0027d\u0027:\n+                appendDayOfMonth(tokenLen);\n+                break;\n+            case \u0027h\u0027:\n+                appendClockhourOfHalfday(tokenLen);\n+                break;\n+            case \u0027H\u0027:\n+                appendHourOfDay(tokenLen);\n+                break;\n+            case \u0027m\u0027:\n+                appendMinuteOfHour(tokenLen);\n+                break;\n+            case \u0027s\u0027:\n+                appendSecondOfMinute(tokenLen);\n+                break;\n+            case \u0027S\u0027:\n+                appendFractionOfSecond(tokenLen, tokenLen);\n+                break;\n+            case \u0027e\u0027:\n+                appendDayOfWeek(tokenLen);\n+                break;\n+            case \u0027E\u0027:\n+                if (tokenLen \u003e\u003d 4) {\n+                    appendDayOfWeekText();\n+                } else {\n+                    appendDayOfWeekShortText();\n+                }\n+                break;\n+            case \u0027D\u0027:\n+                appendDayOfYear(tokenLen);\n+                break;\n+            case \u0027w\u0027:\n+                appendWeekOfWeekyear(tokenLen);\n+                break;\n+            case \u0027a\u0027:\n+                appendHalfdayOfDayText();\n+                break;\n+            case \u0027k\u0027:\n+                appendClockhourOfDay(tokenLen);\n+                break;\n+            case \u0027K\u0027:\n+                appendClockhourOfHalfday(tokenLen);\n+                break;\n+            case \u0027z\u0027:\n+                if (tokenLen \u003e\u003d 4) {\n+                    appendTimeZoneName();\n+                } else {\n+                    appendTimeZoneShortName();\n+                }\n+                break;\n+            case \u0027Z\u0027:\n+                if (tokenLen \u003e\u003d 4) {\n+                    appendTimeZoneOffset(null, true, 2, 2);\n+                } else {\n+                    appendTimeZoneOffset(null, false, 2, 2);\n+                }\n+                break;\n+            case \u0027\\\u0027\u0027:\n+                String sub \u003d token.substring(1);\n+                if (sub.length() \u003d\u003d 1) {\n+                    appendLiteral(sub.charAt(0));\n+                } else {\n+                    appendLiteral(new String(sub));\n+                }\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n+        }\n+    }\n+    return this;\n+}\n\\ No newline at end of file\n",
      "actualSource": "public DateTimeFormatterBuilder appendPattern(String pattern) throws IllegalArgumentException {\n    int length \u003d pattern.length();\n    int[] indexRef \u003d new int[1];\n    for (int i \u003d 0; i \u003c length; i++) {\n        indexRef[0] \u003d i;\n        String token \u003d parseToken(pattern, indexRef);\n        i \u003d indexRef[0];\n        int tokenLen \u003d token.length();\n        if (tokenLen \u003d\u003d 0) {\n            break;\n        }\n        char c \u003d token.charAt(0);\n        switch(c) {\n            case \u0027G\u0027:\n                appendEraText();\n                break;\n            case \u0027C\u0027:\n                appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case \u0027x\u0027:\n            case \u0027y\u0027:\n            case \u0027Y\u0027:\n                if (tokenLen \u003d\u003d 2) {\n                    DateTimeField field;\n                    switch(c) {\n                        case \u0027x\u0027:\n                            field \u003d new RemainderDateTimeField(\"weekyearOfCentury\", iChronoUTC.weekyear(), 100);\n                            break;\n                        case \u0027y\u0027:\n                        default:\n                            field \u003d new RemainderDateTimeField(\"yearOfCentury\", iChronoUTC.year(), 100);\n                            break;\n                        case \u0027Y\u0027:\n                            field \u003d new RemainderDateTimeField(\"yearOfCentury\", iChronoUTC.yearOfEra(), 100);\n                            break;\n                    }\n                    appendNumeric(field, 2, 2);\n                } else {\n                    int maxDigits \u003d 9;\n                    if (i + 1 \u003c length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            maxDigits \u003d tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n                    switch(c) {\n                        case \u0027x\u0027:\n                            appendWeekyear(tokenLen, maxDigits);\n                            break;\n                        case \u0027y\u0027:\n                            appendYear(tokenLen, maxDigits);\n                            break;\n                        case \u0027Y\u0027:\n                            appendYearOfEra(tokenLen, maxDigits);\n                            break;\n                    }\n                }\n                break;\n            case \u0027M\u0027:\n                if (tokenLen \u003e\u003d 3) {\n                    if (tokenLen \u003e\u003d 4) {\n                        appendMonthOfYearText();\n                    } else {\n                        appendMonthOfYearShortText();\n                    }\n                } else {\n                    appendMonthOfYear(tokenLen);\n                }\n                break;\n            case \u0027d\u0027:\n                appendDayOfMonth(tokenLen);\n                break;\n            case \u0027h\u0027:\n                appendClockhourOfHalfday(tokenLen);\n                break;\n            case \u0027H\u0027:\n                appendHourOfDay(tokenLen);\n                break;\n            case \u0027m\u0027:\n                appendMinuteOfHour(tokenLen);\n                break;\n            case \u0027s\u0027:\n                appendSecondOfMinute(tokenLen);\n                break;\n            case \u0027S\u0027:\n                appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case \u0027e\u0027:\n                appendDayOfWeek(tokenLen);\n                break;\n            case \u0027E\u0027:\n                if (tokenLen \u003e\u003d 4) {\n                    appendDayOfWeekText();\n                } else {\n                    appendDayOfWeekShortText();\n                }\n                break;\n            case \u0027D\u0027:\n                appendDayOfYear(tokenLen);\n                break;\n            case \u0027w\u0027:\n                appendWeekOfWeekyear(tokenLen);\n                break;\n            case \u0027a\u0027:\n                appendHalfdayOfDayText();\n                break;\n            case \u0027k\u0027:\n                appendClockhourOfDay(tokenLen);\n                break;\n            case \u0027K\u0027:\n                appendClockhourOfHalfday(tokenLen);\n                break;\n            case \u0027z\u0027:\n                if (tokenLen \u003e\u003d 4) {\n                    appendTimeZoneName();\n                } else {\n                    appendTimeZoneShortName();\n                }\n                break;\n            case \u0027Z\u0027:\n                if (tokenLen \u003e\u003d 4) {\n                    appendTimeZoneOffset(null, true, 2, 2);\n                } else {\n                    appendTimeZoneOffset(null, false, 2, 2);\n                }\n                break;\n            case \u0027\\\u0027\u0027:\n                String sub \u003d token.substring(1);\n                if (sub.length() \u003d\u003d 1) {\n                    appendLiteral(sub.charAt(0));\n                } else {\n                    appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n        }\n    }\n    return this;\n}",
      "path": "JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java",
      "functionStartLine": 914,
      "functionName": "appendPattern",
      "functionAnnotation": "",
      "functionDoc": "The pattern syntax is compatible with java.text.SimpleDateFormat, but a\nfew more symbols are also supported.\n\u003cp\u003e\nTo specify the time format use a \u003cem\u003etime pattern\u003c/em\u003e string.\nIn this pattern, all ASCII letters are reserved as pattern letters,\nwhich are defined as the following:\n\u003cblockquote\u003e\n\u003cpre\u003e\nSymbol  Meaning                      Presentation  Examples\n------  -------                      ------------  -------\nG       era                          text          AD\nC       century of era (\u0026gt;\u003d0)         number        20\nY       year of era (\u0026gt;\u003d0)            year          1996\n\nx       weekyear                     year          1996\nw       week of weekyear             number        27\ne       day of week                  number        2\nE       day of week                  text          Tuesday; Tue\n\ny       year                         year          1996\nD       day of year                  number        189\nM       month of year                month         July; Jul; 07\nd       day of month                 number        10\n\na       halfday of day               text          PM\nK       hour of halfday (0~11)       number        0\nh       clockhour of halfday (1~12)  number        12\n\nH       hour of day (0~23)           number        0\nk       clockhour of day (1~24)      number        24\nm       minute of hour               number        30\ns       second of minute             number        55\nS       fraction of second           number        978\n\nz       time zone                    text          Pacific Standard Time; PST\nZ       RFC 822 time zone            text          -0800; -08:00\n\n\u0027       escape for text              delimiter\n\u0027\u0027      single quote                 literal       \u0027\n\u003c/pre\u003e\n\u003c/blockquote\u003e\nThe count of pattern letters determine the format.\n\u003cp\u003e\n\u003cstrong\u003eText\u003c/strong\u003e: If the number of pattern letters is 4 or more,\nthe full form is used; otherwise a short or abbreviated form is used if\navailable.\n\u003cp\u003e\n\u003cstrong\u003eNumber\u003c/strong\u003e: The minimum number of digits. Shorter numbers\nare zero-padded to this amount.\n\u003cp\u003e\n\u003cstrong\u003eYear\u003c/strong\u003e: Numeric presentation for year and weekyear fields\nare handled specially. For example, if the count of \u0027y\u0027 is 2, the year\nwill be displayed as the zero-based year of the century, which is two\ndigits.\n\u003cp\u003e\n\u003cstrong\u003eMonth\u003c/strong\u003e: 3 or over, use text, otherwise use number.\n\u003cp\u003e\nAny characters in the pattern that are not in the ranges of [\u0027a\u0027..\u0027z\u0027]\nand [\u0027A\u0027..\u0027Z\u0027] will be treated as quoted text. For instance, characters\nlike \u0027:\u0027, \u0027.\u0027, \u0027 \u0027, \u0027#\u0027 and \u0027@\u0027 will appear in the resulting time text\neven they are not embraced within single quotes.\n"
    }
  }
}