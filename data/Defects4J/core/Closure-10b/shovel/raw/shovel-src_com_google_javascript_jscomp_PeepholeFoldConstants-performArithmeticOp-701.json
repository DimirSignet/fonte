{
  "origin": "codeshovel",
  "repositoryName": "Closure-10b",
  "repositoryPath": "/tmp/Closure-10b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "PeepholeFoldConstants.java",
  "functionName": "performArithmeticOp",
  "functionId": "performArithmeticOp___opType-int__left-Node__right-Node",
  "sourceFilePath": "src/com/google/javascript/jscomp/PeepholeFoldConstants.java",
  "functionAnnotation": "",
  "functionDoc": "Try to fold arithmetic binary operators\n",
  "functionStartLine": 701,
  "functionEndLine": 776,
  "numCommitsSeen": 100,
  "timeTaken": 7911,
  "changeHistory": [
    "70a5626922ea7e8c98747e22b6986638ba38fadc",
    "edb6e4c48c19be681f38e9ee27e67b66a1944640",
    "25829b0395164533782d608399096803321225a7",
    "1a7fbd18b47c102152869c3b046b65ff0f12fc43",
    "bb877849306e221202b283f9b8eb3873d7bdc9ae",
    "685443251d5be1186e0d8abf4ad1181153bebe01",
    "510ff24ac51a8c73ff3f2401379654c37a00546b",
    "b14f33a0c7d07320600acdf732f16f6f52aa999c",
    "bbf3ed85e0f668331edb269329bf577fe27932a8",
    "83d03ec5c8b7c49896841a9386bec0f75d2697a5",
    "c9e89727dc8063d087d28e42629606f4fd74a6e5",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3"
  ],
  "changeHistoryShort": {
    "70a5626922ea7e8c98747e22b6986638ba38fadc": "Ybodychange",
    "edb6e4c48c19be681f38e9ee27e67b66a1944640": "Ybodychange",
    "25829b0395164533782d608399096803321225a7": "Ybodychange",
    "1a7fbd18b47c102152869c3b046b65ff0f12fc43": "Ybodychange",
    "bb877849306e221202b283f9b8eb3873d7bdc9ae": "Ybodychange",
    "685443251d5be1186e0d8abf4ad1181153bebe01": "Ybodychange",
    "510ff24ac51a8c73ff3f2401379654c37a00546b": "Ybodychange",
    "b14f33a0c7d07320600acdf732f16f6f52aa999c": "Ymultichange(Yrename,Yparameterchange,Ybodychange)",
    "bbf3ed85e0f668331edb269329bf577fe27932a8": "Ybodychange",
    "83d03ec5c8b7c49896841a9386bec0f75d2697a5": "Ybodychange",
    "c9e89727dc8063d087d28e42629606f4fd74a6e5": "Ymultichange(Ymovefromfile,Yreturntypechange,Ymodifierchange,Ybodychange,Yparameterchange)",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "70a5626922ea7e8c98747e22b6986638ba38fadc": {
      "type": "Ybodychange",
      "commitMessage": "\nFix various typos, spelling and grammar errors.\nFixes issue 734. \nContributed by Robert Gust Bardon\n\nR\u003dnicksantos\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d4827\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1979 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "5/18/12, 11:09 AM",
      "commitName": "70a5626922ea7e8c98747e22b6986638ba38fadc",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "4/25/12, 1:34 PM",
      "commitNameOld": "f412f0c0efd54842b30207c845d65cb826217fd6",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 22.9,
      "commitsBetweenForRepo": 51,
      "commitsBetweenForFile": 1,
      "actualSource": "private Node performArithmeticOp(int opType, Node left, Node right) {\n    if (opType \u003d\u003d Token.ADD \u0026\u0026 (NodeUtil.mayBeString(left, false) || NodeUtil.mayBeString(right, false))) {\n        return null;\n    }\n    double result;\n    Double lValObj \u003d NodeUtil.getNumberValue(left);\n    if (lValObj \u003d\u003d null) {\n        return null;\n    }\n    Double rValObj \u003d NodeUtil.getNumberValue(right);\n    if (rValObj \u003d\u003d null) {\n        return null;\n    }\n    double lval \u003d lValObj;\n    double rval \u003d rValObj;\n    switch(opType) {\n        case Token.BITAND:\n            result \u003d ScriptRuntime.toInt32(lval) \u0026 ScriptRuntime.toInt32(rval);\n            break;\n        case Token.BITOR:\n            result \u003d ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);\n            break;\n        case Token.BITXOR:\n            result \u003d ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);\n            break;\n        case Token.ADD:\n            result \u003d lval + rval;\n            break;\n        case Token.SUB:\n            result \u003d lval - rval;\n            break;\n        case Token.MUL:\n            result \u003d lval * rval;\n            break;\n        case Token.MOD:\n            if (rval \u003d\u003d 0) {\n                return null;\n            }\n            result \u003d lval % rval;\n            break;\n        case Token.DIV:\n            if (rval \u003d\u003d 0) {\n                return null;\n            }\n            result \u003d lval / rval;\n            break;\n        default:\n            throw new Error(\"Unexpected arithmetic operator\");\n    }\n    if ((String.valueOf(result).length() \u003c\u003d String.valueOf(lval).length() + String.valueOf(rval).length() + 1 \u0026\u0026 Math.abs(result) \u003c\u003d MAX_FOLD_NUMBER) || Double.isNaN(result) || result \u003d\u003d Double.POSITIVE_INFINITY || result \u003d\u003d Double.NEGATIVE_INFINITY) {\n        return NodeUtil.numberNode(result, null);\n    }\n    return null;\n}",
      "path": "src/com/google/javascript/jscomp/PeepholeFoldConstants.java",
      "functionStartLine": 701,
      "functionName": "performArithmeticOp",
      "functionAnnotation": "",
      "functionDoc": "Try to fold arithmetic binary operators\n",
      "diff": "",
      "extendedDetails": {}
    },
    "edb6e4c48c19be681f38e9ee27e67b66a1944640": {
      "type": "Ybodychange",
      "commitMessage": "\nTry out the IR AST construction functions in the Peephole passes\n\nR\u003dnicksantos\nDELTA\u003d154  (41 added, 35 deleted, 78 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3795\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1637 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/21/11, 4:28 PM",
      "commitName": "edb6e4c48c19be681f38e9ee27e67b66a1944640",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "11/21/11, 12:02 PM",
      "commitNameOld": "e85593d14461f5342013d0d6c6e8484dca003eef",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 0.18,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "actualSource": "private Node performArithmeticOp(int opType, Node left, Node right) {\n    if (opType \u003d\u003d Token.ADD \u0026\u0026 (NodeUtil.mayBeString(left, false) || NodeUtil.mayBeString(right, false))) {\n        return null;\n    }\n    double result;\n    Double lValObj \u003d NodeUtil.getNumberValue(left);\n    if (lValObj \u003d\u003d null) {\n        return null;\n    }\n    Double rValObj \u003d NodeUtil.getNumberValue(right);\n    if (rValObj \u003d\u003d null) {\n        return null;\n    }\n    double lval \u003d lValObj;\n    double rval \u003d rValObj;\n    switch(opType) {\n        case Token.BITAND:\n            result \u003d ScriptRuntime.toInt32(lval) \u0026 ScriptRuntime.toInt32(rval);\n            break;\n        case Token.BITOR:\n            result \u003d ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);\n            break;\n        case Token.BITXOR:\n            result \u003d ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);\n            break;\n        case Token.ADD:\n            result \u003d lval + rval;\n            break;\n        case Token.SUB:\n            result \u003d lval - rval;\n            break;\n        case Token.MUL:\n            result \u003d lval * rval;\n            break;\n        case Token.MOD:\n            if (rval \u003d\u003d 0) {\n                return null;\n            }\n            result \u003d lval % rval;\n            break;\n        case Token.DIV:\n            if (rval \u003d\u003d 0) {\n                return null;\n            }\n            result \u003d lval / rval;\n            break;\n        default:\n            throw new Error(\"Unexpected arithmetic operator\");\n    }\n    if ((String.valueOf(result).length() \u003c\u003d String.valueOf(lval).length() + String.valueOf(rval).length() + 1 \u0026\u0026 Math.abs(result) \u003c\u003d MAX_FOLD_NUMBER) || Double.isNaN(result) || result \u003d\u003d Double.POSITIVE_INFINITY || result \u003d\u003d Double.NEGATIVE_INFINITY) {\n        return NodeUtil.numberNode(result, null);\n    }\n    return null;\n}",
      "path": "src/com/google/javascript/jscomp/PeepholeFoldConstants.java",
      "functionStartLine": 698,
      "functionName": "performArithmeticOp",
      "functionAnnotation": "",
      "functionDoc": "Try to fold arithmetic binary operators\n",
      "diff": "@@ -1,61 +1,54 @@\n private Node performArithmeticOp(int opType, Node left, Node right) {\n     if (opType \u003d\u003d Token.ADD \u0026\u0026 (NodeUtil.mayBeString(left, false) || NodeUtil.mayBeString(right, false))) {\n         return null;\n     }\n     double result;\n     Double lValObj \u003d NodeUtil.getNumberValue(left);\n     if (lValObj \u003d\u003d null) {\n         return null;\n     }\n     Double rValObj \u003d NodeUtil.getNumberValue(right);\n     if (rValObj \u003d\u003d null) {\n         return null;\n     }\n     double lval \u003d lValObj;\n     double rval \u003d rValObj;\n     switch(opType) {\n         case Token.BITAND:\n             result \u003d ScriptRuntime.toInt32(lval) \u0026 ScriptRuntime.toInt32(rval);\n             break;\n         case Token.BITOR:\n             result \u003d ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);\n             break;\n         case Token.BITXOR:\n             result \u003d ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);\n             break;\n         case Token.ADD:\n             result \u003d lval + rval;\n             break;\n         case Token.SUB:\n             result \u003d lval - rval;\n             break;\n         case Token.MUL:\n             result \u003d lval * rval;\n             break;\n         case Token.MOD:\n             if (rval \u003d\u003d 0) {\n                 return null;\n             }\n             result \u003d lval % rval;\n             break;\n         case Token.DIV:\n             if (rval \u003d\u003d 0) {\n                 return null;\n             }\n             result \u003d lval / rval;\n             break;\n         default:\n             throw new Error(\"Unexpected arithmetic operator\");\n     }\n-    if (String.valueOf(result).length() \u003c\u003d String.valueOf(lval).length() + String.valueOf(rval).length() + 1 \u0026\u0026 Math.abs(result) \u003c\u003d MAX_FOLD_NUMBER) {\n-        Node newNumber \u003d Node.newNumber(result);\n-        return newNumber;\n-    } else if (Double.isNaN(result)) {\n-        return Node.newString(Token.NAME, \"NaN\");\n-    } else if (result \u003d\u003d Double.POSITIVE_INFINITY) {\n-        return Node.newString(Token.NAME, \"Infinity\");\n-    } else if (result \u003d\u003d Double.NEGATIVE_INFINITY) {\n-        return new Node(Token.NEG, Node.newString(Token.NAME, \"Infinity\"));\n+    if ((String.valueOf(result).length() \u003c\u003d String.valueOf(lval).length() + String.valueOf(rval).length() + 1 \u0026\u0026 Math.abs(result) \u003c\u003d MAX_FOLD_NUMBER) || Double.isNaN(result) || result \u003d\u003d Double.POSITIVE_INFINITY || result \u003d\u003d Double.NEGATIVE_INFINITY) {\n+        return NodeUtil.numberNode(result, null);\n     }\n     return null;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "25829b0395164533782d608399096803321225a7": {
      "type": "Ybodychange",
      "commitMessage": "\nDelete the divide by zero error\nI\u0027ve never heard of this catching any real bug. It seems like if\nyou explicitly typed \"1 / 0\", you meant to do that.\nfixes issue 381\n\nR\u003djohnlenz\nDELTA\u003d8  (0 added, 6 deleted, 2 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d924\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@900 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "3/17/11, 11:12 AM",
      "commitName": "25829b0395164533782d608399096803321225a7",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "3/15/11, 12:44 PM",
      "commitNameOld": "6667430d7d2cf9f2b7ad487b517c96c929398f25",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 1.94,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "actualSource": "private Node performArithmeticOp(int opType, Node left, Node right) {\n    if (opType \u003d\u003d Token.ADD \u0026\u0026 (NodeUtil.mayBeString(left, false) || NodeUtil.mayBeString(right, false))) {\n        return null;\n    }\n    double result;\n    Double lValObj \u003d NodeUtil.getNumberValue(left);\n    if (lValObj \u003d\u003d null) {\n        return null;\n    }\n    Double rValObj \u003d NodeUtil.getNumberValue(right);\n    if (rValObj \u003d\u003d null) {\n        return null;\n    }\n    double lval \u003d lValObj;\n    double rval \u003d rValObj;\n    switch(opType) {\n        case Token.BITAND:\n            result \u003d ScriptRuntime.toInt32(lval) \u0026 ScriptRuntime.toInt32(rval);\n            break;\n        case Token.BITOR:\n            result \u003d ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);\n            break;\n        case Token.BITXOR:\n            result \u003d ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);\n            break;\n        case Token.ADD:\n            result \u003d lval + rval;\n            break;\n        case Token.SUB:\n            result \u003d lval - rval;\n            break;\n        case Token.MUL:\n            result \u003d lval * rval;\n            break;\n        case Token.MOD:\n            if (rval \u003d\u003d 0) {\n                return null;\n            }\n            result \u003d lval % rval;\n            break;\n        case Token.DIV:\n            if (rval \u003d\u003d 0) {\n                return null;\n            }\n            result \u003d lval / rval;\n            break;\n        default:\n            throw new Error(\"Unexpected arithmetic operator\");\n    }\n    if (String.valueOf(result).length() \u003c\u003d String.valueOf(lval).length() + String.valueOf(rval).length() + 1 \u0026\u0026 Math.abs(result) \u003c\u003d MAX_FOLD_NUMBER) {\n        Node newNumber \u003d Node.newNumber(result);\n        return newNumber;\n    } else if (Double.isNaN(result)) {\n        return Node.newString(Token.NAME, \"NaN\");\n    } else if (result \u003d\u003d Double.POSITIVE_INFINITY) {\n        return Node.newString(Token.NAME, \"Infinity\");\n    } else if (result \u003d\u003d Double.NEGATIVE_INFINITY) {\n        return new Node(Token.NEG, Node.newString(Token.NAME, \"Infinity\"));\n    }\n    return null;\n}",
      "path": "src/com/google/javascript/jscomp/PeepholeFoldConstants.java",
      "functionStartLine": 664,
      "functionName": "performArithmeticOp",
      "functionAnnotation": "",
      "functionDoc": "Try to fold arithmetic binary operators\n",
      "diff": "@@ -1,63 +1,61 @@\n private Node performArithmeticOp(int opType, Node left, Node right) {\n     if (opType \u003d\u003d Token.ADD \u0026\u0026 (NodeUtil.mayBeString(left, false) || NodeUtil.mayBeString(right, false))) {\n         return null;\n     }\n     double result;\n     Double lValObj \u003d NodeUtil.getNumberValue(left);\n     if (lValObj \u003d\u003d null) {\n         return null;\n     }\n     Double rValObj \u003d NodeUtil.getNumberValue(right);\n     if (rValObj \u003d\u003d null) {\n         return null;\n     }\n     double lval \u003d lValObj;\n     double rval \u003d rValObj;\n     switch(opType) {\n         case Token.BITAND:\n             result \u003d ScriptRuntime.toInt32(lval) \u0026 ScriptRuntime.toInt32(rval);\n             break;\n         case Token.BITOR:\n             result \u003d ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);\n             break;\n         case Token.BITXOR:\n             result \u003d ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);\n             break;\n         case Token.ADD:\n             result \u003d lval + rval;\n             break;\n         case Token.SUB:\n             result \u003d lval - rval;\n             break;\n         case Token.MUL:\n             result \u003d lval * rval;\n             break;\n         case Token.MOD:\n             if (rval \u003d\u003d 0) {\n-                error(DIVIDE_BY_0_ERROR, right);\n                 return null;\n             }\n             result \u003d lval % rval;\n             break;\n         case Token.DIV:\n             if (rval \u003d\u003d 0) {\n-                error(DIVIDE_BY_0_ERROR, right);\n                 return null;\n             }\n             result \u003d lval / rval;\n             break;\n         default:\n             throw new Error(\"Unexpected arithmetic operator\");\n     }\n     if (String.valueOf(result).length() \u003c\u003d String.valueOf(lval).length() + String.valueOf(rval).length() + 1 \u0026\u0026 Math.abs(result) \u003c\u003d MAX_FOLD_NUMBER) {\n         Node newNumber \u003d Node.newNumber(result);\n         return newNumber;\n     } else if (Double.isNaN(result)) {\n         return Node.newString(Token.NAME, \"NaN\");\n     } else if (result \u003d\u003d Double.POSITIVE_INFINITY) {\n         return Node.newString(Token.NAME, \"Infinity\");\n     } else if (result \u003d\u003d Double.NEGATIVE_INFINITY) {\n         return new Node(Token.NEG, Node.newString(Token.NAME, \"Infinity\"));\n     }\n     return null;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1a7fbd18b47c102152869c3b046b65ff0f12fc43": {
      "type": "Ybodychange",
      "commitMessage": "\nAllow more folding of Token.ADD.\n\nR\u003dacleung\nDELTA\u003d160  (107 added, 4 deleted, 49 changed)\n\nHi Jason!\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d453\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@764 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "2/7/11, 2:59 PM",
      "commitName": "1a7fbd18b47c102152869c3b046b65ff0f12fc43",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "1/19/11, 3:22 PM",
      "commitNameOld": "bb877849306e221202b283f9b8eb3873d7bdc9ae",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 18.98,
      "commitsBetweenForRepo": 51,
      "commitsBetweenForFile": 1,
      "actualSource": "private Node performArithmeticOp(int opType, Node left, Node right) {\n    if (opType \u003d\u003d Token.ADD \u0026\u0026 (NodeUtil.mayBeString(left, false) || NodeUtil.mayBeString(right, false))) {\n        return null;\n    }\n    double result;\n    Double lValObj \u003d NodeUtil.getNumberValue(left);\n    if (lValObj \u003d\u003d null) {\n        return null;\n    }\n    Double rValObj \u003d NodeUtil.getNumberValue(right);\n    if (rValObj \u003d\u003d null) {\n        return null;\n    }\n    double lval \u003d lValObj;\n    double rval \u003d rValObj;\n    switch(opType) {\n        case Token.BITAND:\n            result \u003d ScriptRuntime.toInt32(lval) \u0026 ScriptRuntime.toInt32(rval);\n            break;\n        case Token.BITOR:\n            result \u003d ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);\n            break;\n        case Token.BITXOR:\n            result \u003d ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);\n            break;\n        case Token.ADD:\n            result \u003d lval + rval;\n            break;\n        case Token.SUB:\n            result \u003d lval - rval;\n            break;\n        case Token.MUL:\n            result \u003d lval * rval;\n            break;\n        case Token.MOD:\n            if (rval \u003d\u003d 0) {\n                error(DIVIDE_BY_0_ERROR, right);\n                return null;\n            }\n            result \u003d lval % rval;\n            break;\n        case Token.DIV:\n            if (rval \u003d\u003d 0) {\n                error(DIVIDE_BY_0_ERROR, right);\n                return null;\n            }\n            result \u003d lval / rval;\n            break;\n        default:\n            throw new Error(\"Unexpected arithmetic operator\");\n    }\n    if (String.valueOf(result).length() \u003c\u003d String.valueOf(lval).length() + String.valueOf(rval).length() + 1 \u0026\u0026 Math.abs(result) \u003c\u003d MAX_FOLD_NUMBER) {\n        Node newNumber \u003d Node.newNumber(result);\n        return newNumber;\n    } else if (Double.isNaN(result)) {\n        return Node.newString(Token.NAME, \"NaN\");\n    } else if (result \u003d\u003d Double.POSITIVE_INFINITY) {\n        return Node.newString(Token.NAME, \"Infinity\");\n    } else if (result \u003d\u003d Double.NEGATIVE_INFINITY) {\n        return new Node(Token.NEG, Node.newString(Token.NAME, \"Infinity\"));\n    }\n    return null;\n}",
      "path": "src/com/google/javascript/jscomp/PeepholeFoldConstants.java",
      "functionStartLine": 643,
      "functionName": "performArithmeticOp",
      "functionAnnotation": "",
      "functionDoc": "Try to fold arithmetic binary operators\n",
      "diff": "@@ -1,63 +1,63 @@\n private Node performArithmeticOp(int opType, Node left, Node right) {\n-    if (opType \u003d\u003d Token.ADD \u0026\u0026 (left.getType() !\u003d Token.NUMBER || right.getType() !\u003d Token.NUMBER)) {\n+    if (opType \u003d\u003d Token.ADD \u0026\u0026 (NodeUtil.mayBeString(left, false) || NodeUtil.mayBeString(right, false))) {\n         return null;\n     }\n     double result;\n     Double lValObj \u003d NodeUtil.getNumberValue(left);\n     if (lValObj \u003d\u003d null) {\n         return null;\n     }\n     Double rValObj \u003d NodeUtil.getNumberValue(right);\n     if (rValObj \u003d\u003d null) {\n         return null;\n     }\n     double lval \u003d lValObj;\n     double rval \u003d rValObj;\n     switch(opType) {\n         case Token.BITAND:\n             result \u003d ScriptRuntime.toInt32(lval) \u0026 ScriptRuntime.toInt32(rval);\n             break;\n         case Token.BITOR:\n             result \u003d ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);\n             break;\n         case Token.BITXOR:\n             result \u003d ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);\n             break;\n         case Token.ADD:\n             result \u003d lval + rval;\n             break;\n         case Token.SUB:\n             result \u003d lval - rval;\n             break;\n         case Token.MUL:\n             result \u003d lval * rval;\n             break;\n         case Token.MOD:\n             if (rval \u003d\u003d 0) {\n                 error(DIVIDE_BY_0_ERROR, right);\n                 return null;\n             }\n             result \u003d lval % rval;\n             break;\n         case Token.DIV:\n             if (rval \u003d\u003d 0) {\n                 error(DIVIDE_BY_0_ERROR, right);\n                 return null;\n             }\n             result \u003d lval / rval;\n             break;\n         default:\n             throw new Error(\"Unexpected arithmetic operator\");\n     }\n     if (String.valueOf(result).length() \u003c\u003d String.valueOf(lval).length() + String.valueOf(rval).length() + 1 \u0026\u0026 Math.abs(result) \u003c\u003d MAX_FOLD_NUMBER) {\n         Node newNumber \u003d Node.newNumber(result);\n         return newNumber;\n     } else if (Double.isNaN(result)) {\n         return Node.newString(Token.NAME, \"NaN\");\n     } else if (result \u003d\u003d Double.POSITIVE_INFINITY) {\n         return Node.newString(Token.NAME, \"Infinity\");\n     } else if (result \u003d\u003d Double.NEGATIVE_INFINITY) {\n         return new Node(Token.NEG, Node.newString(Token.NAME, \"Infinity\"));\n     }\n     return null;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "bb877849306e221202b283f9b8eb3873d7bdc9ae": {
      "type": "Ybodychange",
      "commitMessage": "\nMore constant folding tweaks.\n- Remove extraneous unary \"+\"\n- Convert number to integer for BIT ops (not shift)\n- reduce literals in numberic contexts\n\nR\u003dnicksantos\nDELTA\u003d275  (225 added, 30 deleted, 20 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d319\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@712 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "1/19/11, 3:22 PM",
      "commitName": "bb877849306e221202b283f9b8eb3873d7bdc9ae",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "1/13/11, 1:33 PM",
      "commitNameOld": "e6e661b9ad751a51132f6de7e46be94d86fb3557",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 6.08,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "actualSource": "private Node performArithmeticOp(int opType, Node left, Node right) {\n    if (opType \u003d\u003d Token.ADD \u0026\u0026 (left.getType() !\u003d Token.NUMBER || right.getType() !\u003d Token.NUMBER)) {\n        return null;\n    }\n    double result;\n    Double lValObj \u003d NodeUtil.getNumberValue(left);\n    if (lValObj \u003d\u003d null) {\n        return null;\n    }\n    Double rValObj \u003d NodeUtil.getNumberValue(right);\n    if (rValObj \u003d\u003d null) {\n        return null;\n    }\n    double lval \u003d lValObj;\n    double rval \u003d rValObj;\n    switch(opType) {\n        case Token.BITAND:\n            result \u003d ScriptRuntime.toInt32(lval) \u0026 ScriptRuntime.toInt32(rval);\n            break;\n        case Token.BITOR:\n            result \u003d ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);\n            break;\n        case Token.BITXOR:\n            result \u003d ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);\n            break;\n        case Token.ADD:\n            result \u003d lval + rval;\n            break;\n        case Token.SUB:\n            result \u003d lval - rval;\n            break;\n        case Token.MUL:\n            result \u003d lval * rval;\n            break;\n        case Token.MOD:\n            if (rval \u003d\u003d 0) {\n                error(DIVIDE_BY_0_ERROR, right);\n                return null;\n            }\n            result \u003d lval % rval;\n            break;\n        case Token.DIV:\n            if (rval \u003d\u003d 0) {\n                error(DIVIDE_BY_0_ERROR, right);\n                return null;\n            }\n            result \u003d lval / rval;\n            break;\n        default:\n            throw new Error(\"Unexpected arithmetic operator\");\n    }\n    if (String.valueOf(result).length() \u003c\u003d String.valueOf(lval).length() + String.valueOf(rval).length() + 1 \u0026\u0026 Math.abs(result) \u003c\u003d MAX_FOLD_NUMBER) {\n        Node newNumber \u003d Node.newNumber(result);\n        return newNumber;\n    } else if (Double.isNaN(result)) {\n        return Node.newString(Token.NAME, \"NaN\");\n    } else if (result \u003d\u003d Double.POSITIVE_INFINITY) {\n        return Node.newString(Token.NAME, \"Infinity\");\n    } else if (result \u003d\u003d Double.NEGATIVE_INFINITY) {\n        return new Node(Token.NEG, Node.newString(Token.NAME, \"Infinity\"));\n    }\n    return null;\n}",
      "path": "src/com/google/javascript/jscomp/PeepholeFoldConstants.java",
      "functionStartLine": 624,
      "functionName": "performArithmeticOp",
      "functionAnnotation": "",
      "functionDoc": "Try to fold arithmetic binary operators\n",
      "diff": "@@ -1,72 +1,63 @@\n private Node performArithmeticOp(int opType, Node left, Node right) {\n     if (opType \u003d\u003d Token.ADD \u0026\u0026 (left.getType() !\u003d Token.NUMBER || right.getType() !\u003d Token.NUMBER)) {\n         return null;\n     }\n     double result;\n     Double lValObj \u003d NodeUtil.getNumberValue(left);\n     if (lValObj \u003d\u003d null) {\n         return null;\n     }\n     Double rValObj \u003d NodeUtil.getNumberValue(right);\n     if (rValObj \u003d\u003d null) {\n         return null;\n     }\n     double lval \u003d lValObj;\n     double rval \u003d rValObj;\n     switch(opType) {\n         case Token.BITAND:\n-            if (!areValidInts(lval, rval)) {\n-                return null;\n-            }\n-            result \u003d (int) lval \u0026 (int) rval;\n+            result \u003d ScriptRuntime.toInt32(lval) \u0026 ScriptRuntime.toInt32(rval);\n             break;\n         case Token.BITOR:\n-            if (!areValidInts(lval, rval)) {\n-                return null;\n-            }\n-            result \u003d (int) lval | (int) rval;\n+            result \u003d ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);\n             break;\n         case Token.BITXOR:\n-            if (!areValidInts(lval, rval)) {\n-                return null;\n-            }\n-            result \u003d (int) lval ^ (int) rval;\n+            result \u003d ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);\n             break;\n         case Token.ADD:\n             result \u003d lval + rval;\n             break;\n         case Token.SUB:\n             result \u003d lval - rval;\n             break;\n         case Token.MUL:\n             result \u003d lval * rval;\n             break;\n         case Token.MOD:\n             if (rval \u003d\u003d 0) {\n                 error(DIVIDE_BY_0_ERROR, right);\n                 return null;\n             }\n             result \u003d lval % rval;\n             break;\n         case Token.DIV:\n             if (rval \u003d\u003d 0) {\n                 error(DIVIDE_BY_0_ERROR, right);\n                 return null;\n             }\n             result \u003d lval / rval;\n             break;\n         default:\n             throw new Error(\"Unexpected arithmetic operator\");\n     }\n     if (String.valueOf(result).length() \u003c\u003d String.valueOf(lval).length() + String.valueOf(rval).length() + 1 \u0026\u0026 Math.abs(result) \u003c\u003d MAX_FOLD_NUMBER) {\n         Node newNumber \u003d Node.newNumber(result);\n         return newNumber;\n     } else if (Double.isNaN(result)) {\n         return Node.newString(Token.NAME, \"NaN\");\n     } else if (result \u003d\u003d Double.POSITIVE_INFINITY) {\n         return Node.newString(Token.NAME, \"Infinity\");\n     } else if (result \u003d\u003d Double.NEGATIVE_INFINITY) {\n         return new Node(Token.NEG, Node.newString(Token.NAME, \"Infinity\"));\n     }\n     return null;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "685443251d5be1186e0d8abf4ad1181153bebe01": {
      "type": "Ybodychange",
      "commitMessage": "\nAdd BITXOR to the list of commutative and associative operators.\n\nR\u003dnicksantos\nDELTA\u003d21  (21 added, 0 deleted, 0 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d250\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@687 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "1/11/11, 3:59 PM",
      "commitName": "685443251d5be1186e0d8abf4ad1181153bebe01",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "12/8/10, 2:31 PM",
      "commitNameOld": "510ff24ac51a8c73ff3f2401379654c37a00546b",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 34.06,
      "commitsBetweenForRepo": 74,
      "commitsBetweenForFile": 1,
      "actualSource": "private Node performArithmeticOp(int opType, Node left, Node right) {\n    if (opType \u003d\u003d Token.ADD \u0026\u0026 (left.getType() !\u003d Token.NUMBER || right.getType() !\u003d Token.NUMBER)) {\n        return null;\n    }\n    double result;\n    Double lValObj \u003d NodeUtil.getNumberValue(left);\n    if (lValObj \u003d\u003d null) {\n        return null;\n    }\n    Double rValObj \u003d NodeUtil.getNumberValue(right);\n    if (rValObj \u003d\u003d null) {\n        return null;\n    }\n    double lval \u003d lValObj;\n    double rval \u003d rValObj;\n    switch(opType) {\n        case Token.BITAND:\n            if (!areValidInts(lval, rval)) {\n                return null;\n            }\n            result \u003d (int) lval \u0026 (int) rval;\n            break;\n        case Token.BITOR:\n            if (!areValidInts(lval, rval)) {\n                return null;\n            }\n            result \u003d (int) lval | (int) rval;\n            break;\n        case Token.BITXOR:\n            if (!areValidInts(lval, rval)) {\n                return null;\n            }\n            result \u003d (int) lval ^ (int) rval;\n            break;\n        case Token.ADD:\n            result \u003d lval + rval;\n            break;\n        case Token.SUB:\n            result \u003d lval - rval;\n            break;\n        case Token.MUL:\n            result \u003d lval * rval;\n            break;\n        case Token.MOD:\n            if (rval \u003d\u003d 0) {\n                error(DIVIDE_BY_0_ERROR, right);\n                return null;\n            }\n            result \u003d lval % rval;\n            break;\n        case Token.DIV:\n            if (rval \u003d\u003d 0) {\n                error(DIVIDE_BY_0_ERROR, right);\n                return null;\n            }\n            result \u003d lval / rval;\n            break;\n        default:\n            throw new Error(\"Unexpected arithmetic operator\");\n    }\n    if (String.valueOf(result).length() \u003c\u003d String.valueOf(lval).length() + String.valueOf(rval).length() + 1 \u0026\u0026 Math.abs(result) \u003c\u003d MAX_FOLD_NUMBER) {\n        Node newNumber \u003d Node.newNumber(result);\n        return newNumber;\n    } else if (Double.isNaN(result)) {\n        return Node.newString(Token.NAME, \"NaN\");\n    } else if (result \u003d\u003d Double.POSITIVE_INFINITY) {\n        return Node.newString(Token.NAME, \"Infinity\");\n    } else if (result \u003d\u003d Double.NEGATIVE_INFINITY) {\n        return new Node(Token.NEG, Node.newString(Token.NAME, \"Infinity\"));\n    }\n    return null;\n}",
      "path": "src/com/google/javascript/jscomp/PeepholeFoldConstants.java",
      "functionStartLine": 514,
      "functionName": "performArithmeticOp",
      "functionAnnotation": "",
      "functionDoc": "Try to fold arithmetic binary operators\n",
      "diff": "@@ -1,66 +1,72 @@\n private Node performArithmeticOp(int opType, Node left, Node right) {\n     if (opType \u003d\u003d Token.ADD \u0026\u0026 (left.getType() !\u003d Token.NUMBER || right.getType() !\u003d Token.NUMBER)) {\n         return null;\n     }\n     double result;\n     Double lValObj \u003d NodeUtil.getNumberValue(left);\n     if (lValObj \u003d\u003d null) {\n         return null;\n     }\n     Double rValObj \u003d NodeUtil.getNumberValue(right);\n     if (rValObj \u003d\u003d null) {\n         return null;\n     }\n     double lval \u003d lValObj;\n     double rval \u003d rValObj;\n     switch(opType) {\n         case Token.BITAND:\n             if (!areValidInts(lval, rval)) {\n                 return null;\n             }\n             result \u003d (int) lval \u0026 (int) rval;\n             break;\n         case Token.BITOR:\n             if (!areValidInts(lval, rval)) {\n                 return null;\n             }\n             result \u003d (int) lval | (int) rval;\n             break;\n+        case Token.BITXOR:\n+            if (!areValidInts(lval, rval)) {\n+                return null;\n+            }\n+            result \u003d (int) lval ^ (int) rval;\n+            break;\n         case Token.ADD:\n             result \u003d lval + rval;\n             break;\n         case Token.SUB:\n             result \u003d lval - rval;\n             break;\n         case Token.MUL:\n             result \u003d lval * rval;\n             break;\n         case Token.MOD:\n             if (rval \u003d\u003d 0) {\n                 error(DIVIDE_BY_0_ERROR, right);\n                 return null;\n             }\n             result \u003d lval % rval;\n             break;\n         case Token.DIV:\n             if (rval \u003d\u003d 0) {\n                 error(DIVIDE_BY_0_ERROR, right);\n                 return null;\n             }\n             result \u003d lval / rval;\n             break;\n         default:\n             throw new Error(\"Unexpected arithmetic operator\");\n     }\n     if (String.valueOf(result).length() \u003c\u003d String.valueOf(lval).length() + String.valueOf(rval).length() + 1 \u0026\u0026 Math.abs(result) \u003c\u003d MAX_FOLD_NUMBER) {\n         Node newNumber \u003d Node.newNumber(result);\n         return newNumber;\n     } else if (Double.isNaN(result)) {\n         return Node.newString(Token.NAME, \"NaN\");\n     } else if (result \u003d\u003d Double.POSITIVE_INFINITY) {\n         return Node.newString(Token.NAME, \"Infinity\");\n     } else if (result \u003d\u003d Double.NEGATIVE_INFINITY) {\n         return new Node(Token.NEG, Node.newString(Token.NAME, \"Infinity\"));\n     }\n     return null;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "510ff24ac51a8c73ff3f2401379654c37a00546b": {
      "type": "Ybodychange",
      "commitMessage": "\nFold a few more comparison cases.\n\nR\u003dnicksantos\nDELTA\u003d215  (169 added, 20 deleted, 26 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d98\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@610 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "12/8/10, 2:31 PM",
      "commitName": "510ff24ac51a8c73ff3f2401379654c37a00546b",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "11/30/10, 12:10 PM",
      "commitNameOld": "eaaa156632369f88e9667f55c7761cef8367cf57",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 8.1,
      "commitsBetweenForRepo": 31,
      "commitsBetweenForFile": 1,
      "actualSource": "private Node performArithmeticOp(int opType, Node left, Node right) {\n    if (opType \u003d\u003d Token.ADD \u0026\u0026 (left.getType() !\u003d Token.NUMBER || right.getType() !\u003d Token.NUMBER)) {\n        return null;\n    }\n    double result;\n    Double lValObj \u003d NodeUtil.getNumberValue(left);\n    if (lValObj \u003d\u003d null) {\n        return null;\n    }\n    Double rValObj \u003d NodeUtil.getNumberValue(right);\n    if (rValObj \u003d\u003d null) {\n        return null;\n    }\n    double lval \u003d lValObj;\n    double rval \u003d rValObj;\n    switch(opType) {\n        case Token.BITAND:\n            if (!areValidInts(lval, rval)) {\n                return null;\n            }\n            result \u003d (int) lval \u0026 (int) rval;\n            break;\n        case Token.BITOR:\n            if (!areValidInts(lval, rval)) {\n                return null;\n            }\n            result \u003d (int) lval | (int) rval;\n            break;\n        case Token.ADD:\n            result \u003d lval + rval;\n            break;\n        case Token.SUB:\n            result \u003d lval - rval;\n            break;\n        case Token.MUL:\n            result \u003d lval * rval;\n            break;\n        case Token.MOD:\n            if (rval \u003d\u003d 0) {\n                error(DIVIDE_BY_0_ERROR, right);\n                return null;\n            }\n            result \u003d lval % rval;\n            break;\n        case Token.DIV:\n            if (rval \u003d\u003d 0) {\n                error(DIVIDE_BY_0_ERROR, right);\n                return null;\n            }\n            result \u003d lval / rval;\n            break;\n        default:\n            throw new Error(\"Unexpected arithmetic operator\");\n    }\n    if (String.valueOf(result).length() \u003c\u003d String.valueOf(lval).length() + String.valueOf(rval).length() + 1 \u0026\u0026 Math.abs(result) \u003c\u003d MAX_FOLD_NUMBER) {\n        Node newNumber \u003d Node.newNumber(result);\n        return newNumber;\n    } else if (Double.isNaN(result)) {\n        return Node.newString(Token.NAME, \"NaN\");\n    } else if (result \u003d\u003d Double.POSITIVE_INFINITY) {\n        return Node.newString(Token.NAME, \"Infinity\");\n    } else if (result \u003d\u003d Double.NEGATIVE_INFINITY) {\n        return new Node(Token.NEG, Node.newString(Token.NAME, \"Infinity\"));\n    }\n    return null;\n}",
      "path": "src/com/google/javascript/jscomp/PeepholeFoldConstants.java",
      "functionStartLine": 513,
      "functionName": "performArithmeticOp",
      "functionAnnotation": "",
      "functionDoc": "Try to fold arithmetic binary operators\n",
      "diff": "@@ -1,51 +1,66 @@\n private Node performArithmeticOp(int opType, Node left, Node right) {\n-    Preconditions.checkState(left.getType() \u003d\u003d Token.NUMBER);\n-    Preconditions.checkState(right.getType() \u003d\u003d Token.NUMBER);\n+    if (opType \u003d\u003d Token.ADD \u0026\u0026 (left.getType() !\u003d Token.NUMBER || right.getType() !\u003d Token.NUMBER)) {\n+        return null;\n+    }\n     double result;\n-    double lval \u003d left.getDouble();\n-    double rval \u003d right.getDouble();\n+    Double lValObj \u003d NodeUtil.getNumberValue(left);\n+    if (lValObj \u003d\u003d null) {\n+        return null;\n+    }\n+    Double rValObj \u003d NodeUtil.getNumberValue(right);\n+    if (rValObj \u003d\u003d null) {\n+        return null;\n+    }\n+    double lval \u003d lValObj;\n+    double rval \u003d rValObj;\n     switch(opType) {\n         case Token.BITAND:\n             if (!areValidInts(lval, rval)) {\n                 return null;\n             }\n             result \u003d (int) lval \u0026 (int) rval;\n             break;\n         case Token.BITOR:\n             if (!areValidInts(lval, rval)) {\n                 return null;\n             }\n             result \u003d (int) lval | (int) rval;\n             break;\n         case Token.ADD:\n             result \u003d lval + rval;\n             break;\n         case Token.SUB:\n             result \u003d lval - rval;\n             break;\n         case Token.MUL:\n             result \u003d lval * rval;\n             break;\n         case Token.MOD:\n             if (rval \u003d\u003d 0) {\n                 error(DIVIDE_BY_0_ERROR, right);\n                 return null;\n             }\n             result \u003d lval % rval;\n             break;\n         case Token.DIV:\n             if (rval \u003d\u003d 0) {\n                 error(DIVIDE_BY_0_ERROR, right);\n                 return null;\n             }\n             result \u003d lval / rval;\n             break;\n         default:\n             throw new Error(\"Unexpected arithmetic operator\");\n     }\n     if (String.valueOf(result).length() \u003c\u003d String.valueOf(lval).length() + String.valueOf(rval).length() + 1 \u0026\u0026 Math.abs(result) \u003c\u003d MAX_FOLD_NUMBER) {\n         Node newNumber \u003d Node.newNumber(result);\n         return newNumber;\n+    } else if (Double.isNaN(result)) {\n+        return Node.newString(Token.NAME, \"NaN\");\n+    } else if (result \u003d\u003d Double.POSITIVE_INFINITY) {\n+        return Node.newString(Token.NAME, \"Infinity\");\n+    } else if (result \u003d\u003d Double.NEGATIVE_INFINITY) {\n+        return new Node(Token.NEG, Node.newString(Token.NAME, \"Infinity\"));\n     }\n     return null;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b14f33a0c7d07320600acdf732f16f6f52aa999c": {
      "type": "Ymultichange(Yrename,Yparameterchange,Ybodychange)",
      "commitMessage": "\nFold more associative operations.\nFixes issue 245\n\nR\u003dnicksantos\nDELTA\u003d250  (139 added, 61 deleted, 50 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d1041044\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@530 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/1/10, 9:37 AM",
      "commitName": "b14f33a0c7d07320600acdf732f16f6f52aa999c",
      "commitAuthor": "johnlenz@google.com",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "\nFold more associative operations.\nFixes issue 245\n\nR\u003dnicksantos\nDELTA\u003d250  (139 added, 61 deleted, 50 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d1041044\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@530 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "11/1/10, 9:37 AM",
          "commitName": "b14f33a0c7d07320600acdf732f16f6f52aa999c",
          "commitAuthor": "johnlenz@google.com",
          "commitDateOld": "10/25/10, 10:22 AM",
          "commitNameOld": "bbf3ed85e0f668331edb269329bf577fe27932a8",
          "commitAuthorOld": "nicksantos@google.com",
          "daysBetweenCommits": 6.97,
          "commitsBetweenForRepo": 23,
          "commitsBetweenForFile": 1,
          "actualSource": "private Node performArithmeticOp(int opType, Node left, Node right) {\n    Preconditions.checkState(left.getType() \u003d\u003d Token.NUMBER);\n    Preconditions.checkState(right.getType() \u003d\u003d Token.NUMBER);\n    double result;\n    double lval \u003d left.getDouble();\n    double rval \u003d right.getDouble();\n    switch(opType) {\n        case Token.BITAND:\n            if (!areValidInts(lval, rval)) {\n                return null;\n            }\n            result \u003d (int) lval \u0026 (int) rval;\n            break;\n        case Token.BITOR:\n            if (!areValidInts(lval, rval)) {\n                return null;\n            }\n            result \u003d (int) lval | (int) rval;\n            break;\n        case Token.ADD:\n            result \u003d lval + rval;\n            break;\n        case Token.SUB:\n            result \u003d lval - rval;\n            break;\n        case Token.MUL:\n            result \u003d lval * rval;\n            break;\n        case Token.MOD:\n            if (rval \u003d\u003d 0) {\n                error(DIVIDE_BY_0_ERROR, right);\n                return null;\n            }\n            result \u003d lval % rval;\n            break;\n        case Token.DIV:\n            if (rval \u003d\u003d 0) {\n                error(DIVIDE_BY_0_ERROR, right);\n                return null;\n            }\n            result \u003d lval / rval;\n            break;\n        default:\n            throw new Error(\"Unexpected arithmetic operator\");\n    }\n    if (String.valueOf(result).length() \u003c\u003d String.valueOf(lval).length() + String.valueOf(rval).length() + 1 \u0026\u0026 Math.abs(result) \u003c\u003d MAX_FOLD_NUMBER) {\n        Node newNumber \u003d Node.newNumber(result);\n        return newNumber;\n    }\n    return null;\n}",
          "path": "src/com/google/javascript/jscomp/PeepholeFoldConstants.java",
          "functionStartLine": 517,
          "functionName": "performArithmeticOp",
          "functionAnnotation": "",
          "functionDoc": "Try to fold arithmetic binary operators\n",
          "diff": "@@ -1,41 +1,51 @@\n-private Node tryFoldArithmetic(Node n, Node left, Node right) {\n-    if (left.getType() \u003d\u003d Token.NUMBER \u0026\u0026 right.getType() \u003d\u003d Token.NUMBER) {\n-        double result;\n-        double lval \u003d left.getDouble();\n-        double rval \u003d right.getDouble();\n-        switch(n.getType()) {\n-            case Token.ADD:\n-                result \u003d lval + rval;\n-                break;\n-            case Token.SUB:\n-                result \u003d lval - rval;\n-                break;\n-            case Token.MUL:\n-                result \u003d lval * rval;\n-                break;\n-            case Token.MOD:\n-                if (rval \u003d\u003d 0) {\n-                    error(DIVIDE_BY_0_ERROR, right);\n-                    return n;\n-                }\n-                result \u003d lval % rval;\n-                break;\n-            case Token.DIV:\n-                if (rval \u003d\u003d 0) {\n-                    error(DIVIDE_BY_0_ERROR, right);\n-                    return n;\n-                }\n-                result \u003d lval / rval;\n-                break;\n-            default:\n-                throw new Error(\"Unknown arithmetic operator\");\n-        }\n-        if (String.valueOf(result).length() \u003c\u003d String.valueOf(lval).length() + String.valueOf(rval).length() + 1 \u0026\u0026 Math.abs(result) \u003c\u003d MAX_FOLD_NUMBER) {\n-            Node newNumber \u003d Node.newNumber(result);\n-            n.getParent().replaceChild(n, newNumber);\n-            reportCodeChange();\n-            return newNumber;\n-        }\n+private Node performArithmeticOp(int opType, Node left, Node right) {\n+    Preconditions.checkState(left.getType() \u003d\u003d Token.NUMBER);\n+    Preconditions.checkState(right.getType() \u003d\u003d Token.NUMBER);\n+    double result;\n+    double lval \u003d left.getDouble();\n+    double rval \u003d right.getDouble();\n+    switch(opType) {\n+        case Token.BITAND:\n+            if (!areValidInts(lval, rval)) {\n+                return null;\n+            }\n+            result \u003d (int) lval \u0026 (int) rval;\n+            break;\n+        case Token.BITOR:\n+            if (!areValidInts(lval, rval)) {\n+                return null;\n+            }\n+            result \u003d (int) lval | (int) rval;\n+            break;\n+        case Token.ADD:\n+            result \u003d lval + rval;\n+            break;\n+        case Token.SUB:\n+            result \u003d lval - rval;\n+            break;\n+        case Token.MUL:\n+            result \u003d lval * rval;\n+            break;\n+        case Token.MOD:\n+            if (rval \u003d\u003d 0) {\n+                error(DIVIDE_BY_0_ERROR, right);\n+                return null;\n+            }\n+            result \u003d lval % rval;\n+            break;\n+        case Token.DIV:\n+            if (rval \u003d\u003d 0) {\n+                error(DIVIDE_BY_0_ERROR, right);\n+                return null;\n+            }\n+            result \u003d lval / rval;\n+            break;\n+        default:\n+            throw new Error(\"Unexpected arithmetic operator\");\n     }\n-    return n;\n+    if (String.valueOf(result).length() \u003c\u003d String.valueOf(lval).length() + String.valueOf(rval).length() + 1 \u0026\u0026 Math.abs(result) \u003c\u003d MAX_FOLD_NUMBER) {\n+        Node newNumber \u003d Node.newNumber(result);\n+        return newNumber;\n+    }\n+    return null;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "tryFoldArithmetic",
            "newValue": "performArithmeticOp"
          }
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "\nFold more associative operations.\nFixes issue 245\n\nR\u003dnicksantos\nDELTA\u003d250  (139 added, 61 deleted, 50 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d1041044\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@530 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "11/1/10, 9:37 AM",
          "commitName": "b14f33a0c7d07320600acdf732f16f6f52aa999c",
          "commitAuthor": "johnlenz@google.com",
          "commitDateOld": "10/25/10, 10:22 AM",
          "commitNameOld": "bbf3ed85e0f668331edb269329bf577fe27932a8",
          "commitAuthorOld": "nicksantos@google.com",
          "daysBetweenCommits": 6.97,
          "commitsBetweenForRepo": 23,
          "commitsBetweenForFile": 1,
          "actualSource": "private Node performArithmeticOp(int opType, Node left, Node right) {\n    Preconditions.checkState(left.getType() \u003d\u003d Token.NUMBER);\n    Preconditions.checkState(right.getType() \u003d\u003d Token.NUMBER);\n    double result;\n    double lval \u003d left.getDouble();\n    double rval \u003d right.getDouble();\n    switch(opType) {\n        case Token.BITAND:\n            if (!areValidInts(lval, rval)) {\n                return null;\n            }\n            result \u003d (int) lval \u0026 (int) rval;\n            break;\n        case Token.BITOR:\n            if (!areValidInts(lval, rval)) {\n                return null;\n            }\n            result \u003d (int) lval | (int) rval;\n            break;\n        case Token.ADD:\n            result \u003d lval + rval;\n            break;\n        case Token.SUB:\n            result \u003d lval - rval;\n            break;\n        case Token.MUL:\n            result \u003d lval * rval;\n            break;\n        case Token.MOD:\n            if (rval \u003d\u003d 0) {\n                error(DIVIDE_BY_0_ERROR, right);\n                return null;\n            }\n            result \u003d lval % rval;\n            break;\n        case Token.DIV:\n            if (rval \u003d\u003d 0) {\n                error(DIVIDE_BY_0_ERROR, right);\n                return null;\n            }\n            result \u003d lval / rval;\n            break;\n        default:\n            throw new Error(\"Unexpected arithmetic operator\");\n    }\n    if (String.valueOf(result).length() \u003c\u003d String.valueOf(lval).length() + String.valueOf(rval).length() + 1 \u0026\u0026 Math.abs(result) \u003c\u003d MAX_FOLD_NUMBER) {\n        Node newNumber \u003d Node.newNumber(result);\n        return newNumber;\n    }\n    return null;\n}",
          "path": "src/com/google/javascript/jscomp/PeepholeFoldConstants.java",
          "functionStartLine": 517,
          "functionName": "performArithmeticOp",
          "functionAnnotation": "",
          "functionDoc": "Try to fold arithmetic binary operators\n",
          "diff": "@@ -1,41 +1,51 @@\n-private Node tryFoldArithmetic(Node n, Node left, Node right) {\n-    if (left.getType() \u003d\u003d Token.NUMBER \u0026\u0026 right.getType() \u003d\u003d Token.NUMBER) {\n-        double result;\n-        double lval \u003d left.getDouble();\n-        double rval \u003d right.getDouble();\n-        switch(n.getType()) {\n-            case Token.ADD:\n-                result \u003d lval + rval;\n-                break;\n-            case Token.SUB:\n-                result \u003d lval - rval;\n-                break;\n-            case Token.MUL:\n-                result \u003d lval * rval;\n-                break;\n-            case Token.MOD:\n-                if (rval \u003d\u003d 0) {\n-                    error(DIVIDE_BY_0_ERROR, right);\n-                    return n;\n-                }\n-                result \u003d lval % rval;\n-                break;\n-            case Token.DIV:\n-                if (rval \u003d\u003d 0) {\n-                    error(DIVIDE_BY_0_ERROR, right);\n-                    return n;\n-                }\n-                result \u003d lval / rval;\n-                break;\n-            default:\n-                throw new Error(\"Unknown arithmetic operator\");\n-        }\n-        if (String.valueOf(result).length() \u003c\u003d String.valueOf(lval).length() + String.valueOf(rval).length() + 1 \u0026\u0026 Math.abs(result) \u003c\u003d MAX_FOLD_NUMBER) {\n-            Node newNumber \u003d Node.newNumber(result);\n-            n.getParent().replaceChild(n, newNumber);\n-            reportCodeChange();\n-            return newNumber;\n-        }\n+private Node performArithmeticOp(int opType, Node left, Node right) {\n+    Preconditions.checkState(left.getType() \u003d\u003d Token.NUMBER);\n+    Preconditions.checkState(right.getType() \u003d\u003d Token.NUMBER);\n+    double result;\n+    double lval \u003d left.getDouble();\n+    double rval \u003d right.getDouble();\n+    switch(opType) {\n+        case Token.BITAND:\n+            if (!areValidInts(lval, rval)) {\n+                return null;\n+            }\n+            result \u003d (int) lval \u0026 (int) rval;\n+            break;\n+        case Token.BITOR:\n+            if (!areValidInts(lval, rval)) {\n+                return null;\n+            }\n+            result \u003d (int) lval | (int) rval;\n+            break;\n+        case Token.ADD:\n+            result \u003d lval + rval;\n+            break;\n+        case Token.SUB:\n+            result \u003d lval - rval;\n+            break;\n+        case Token.MUL:\n+            result \u003d lval * rval;\n+            break;\n+        case Token.MOD:\n+            if (rval \u003d\u003d 0) {\n+                error(DIVIDE_BY_0_ERROR, right);\n+                return null;\n+            }\n+            result \u003d lval % rval;\n+            break;\n+        case Token.DIV:\n+            if (rval \u003d\u003d 0) {\n+                error(DIVIDE_BY_0_ERROR, right);\n+                return null;\n+            }\n+            result \u003d lval / rval;\n+            break;\n+        default:\n+            throw new Error(\"Unexpected arithmetic operator\");\n     }\n-    return n;\n+    if (String.valueOf(result).length() \u003c\u003d String.valueOf(lval).length() + String.valueOf(rval).length() + 1 \u0026\u0026 Math.abs(result) \u003c\u003d MAX_FOLD_NUMBER) {\n+        Node newNumber \u003d Node.newNumber(result);\n+        return newNumber;\n+    }\n+    return null;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[n-Node, left-Node, right-Node]",
            "newValue": "[opType-int, left-Node, right-Node]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "\nFold more associative operations.\nFixes issue 245\n\nR\u003dnicksantos\nDELTA\u003d250  (139 added, 61 deleted, 50 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d1041044\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@530 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "11/1/10, 9:37 AM",
          "commitName": "b14f33a0c7d07320600acdf732f16f6f52aa999c",
          "commitAuthor": "johnlenz@google.com",
          "commitDateOld": "10/25/10, 10:22 AM",
          "commitNameOld": "bbf3ed85e0f668331edb269329bf577fe27932a8",
          "commitAuthorOld": "nicksantos@google.com",
          "daysBetweenCommits": 6.97,
          "commitsBetweenForRepo": 23,
          "commitsBetweenForFile": 1,
          "actualSource": "private Node performArithmeticOp(int opType, Node left, Node right) {\n    Preconditions.checkState(left.getType() \u003d\u003d Token.NUMBER);\n    Preconditions.checkState(right.getType() \u003d\u003d Token.NUMBER);\n    double result;\n    double lval \u003d left.getDouble();\n    double rval \u003d right.getDouble();\n    switch(opType) {\n        case Token.BITAND:\n            if (!areValidInts(lval, rval)) {\n                return null;\n            }\n            result \u003d (int) lval \u0026 (int) rval;\n            break;\n        case Token.BITOR:\n            if (!areValidInts(lval, rval)) {\n                return null;\n            }\n            result \u003d (int) lval | (int) rval;\n            break;\n        case Token.ADD:\n            result \u003d lval + rval;\n            break;\n        case Token.SUB:\n            result \u003d lval - rval;\n            break;\n        case Token.MUL:\n            result \u003d lval * rval;\n            break;\n        case Token.MOD:\n            if (rval \u003d\u003d 0) {\n                error(DIVIDE_BY_0_ERROR, right);\n                return null;\n            }\n            result \u003d lval % rval;\n            break;\n        case Token.DIV:\n            if (rval \u003d\u003d 0) {\n                error(DIVIDE_BY_0_ERROR, right);\n                return null;\n            }\n            result \u003d lval / rval;\n            break;\n        default:\n            throw new Error(\"Unexpected arithmetic operator\");\n    }\n    if (String.valueOf(result).length() \u003c\u003d String.valueOf(lval).length() + String.valueOf(rval).length() + 1 \u0026\u0026 Math.abs(result) \u003c\u003d MAX_FOLD_NUMBER) {\n        Node newNumber \u003d Node.newNumber(result);\n        return newNumber;\n    }\n    return null;\n}",
          "path": "src/com/google/javascript/jscomp/PeepholeFoldConstants.java",
          "functionStartLine": 517,
          "functionName": "performArithmeticOp",
          "functionAnnotation": "",
          "functionDoc": "Try to fold arithmetic binary operators\n",
          "diff": "@@ -1,41 +1,51 @@\n-private Node tryFoldArithmetic(Node n, Node left, Node right) {\n-    if (left.getType() \u003d\u003d Token.NUMBER \u0026\u0026 right.getType() \u003d\u003d Token.NUMBER) {\n-        double result;\n-        double lval \u003d left.getDouble();\n-        double rval \u003d right.getDouble();\n-        switch(n.getType()) {\n-            case Token.ADD:\n-                result \u003d lval + rval;\n-                break;\n-            case Token.SUB:\n-                result \u003d lval - rval;\n-                break;\n-            case Token.MUL:\n-                result \u003d lval * rval;\n-                break;\n-            case Token.MOD:\n-                if (rval \u003d\u003d 0) {\n-                    error(DIVIDE_BY_0_ERROR, right);\n-                    return n;\n-                }\n-                result \u003d lval % rval;\n-                break;\n-            case Token.DIV:\n-                if (rval \u003d\u003d 0) {\n-                    error(DIVIDE_BY_0_ERROR, right);\n-                    return n;\n-                }\n-                result \u003d lval / rval;\n-                break;\n-            default:\n-                throw new Error(\"Unknown arithmetic operator\");\n-        }\n-        if (String.valueOf(result).length() \u003c\u003d String.valueOf(lval).length() + String.valueOf(rval).length() + 1 \u0026\u0026 Math.abs(result) \u003c\u003d MAX_FOLD_NUMBER) {\n-            Node newNumber \u003d Node.newNumber(result);\n-            n.getParent().replaceChild(n, newNumber);\n-            reportCodeChange();\n-            return newNumber;\n-        }\n+private Node performArithmeticOp(int opType, Node left, Node right) {\n+    Preconditions.checkState(left.getType() \u003d\u003d Token.NUMBER);\n+    Preconditions.checkState(right.getType() \u003d\u003d Token.NUMBER);\n+    double result;\n+    double lval \u003d left.getDouble();\n+    double rval \u003d right.getDouble();\n+    switch(opType) {\n+        case Token.BITAND:\n+            if (!areValidInts(lval, rval)) {\n+                return null;\n+            }\n+            result \u003d (int) lval \u0026 (int) rval;\n+            break;\n+        case Token.BITOR:\n+            if (!areValidInts(lval, rval)) {\n+                return null;\n+            }\n+            result \u003d (int) lval | (int) rval;\n+            break;\n+        case Token.ADD:\n+            result \u003d lval + rval;\n+            break;\n+        case Token.SUB:\n+            result \u003d lval - rval;\n+            break;\n+        case Token.MUL:\n+            result \u003d lval * rval;\n+            break;\n+        case Token.MOD:\n+            if (rval \u003d\u003d 0) {\n+                error(DIVIDE_BY_0_ERROR, right);\n+                return null;\n+            }\n+            result \u003d lval % rval;\n+            break;\n+        case Token.DIV:\n+            if (rval \u003d\u003d 0) {\n+                error(DIVIDE_BY_0_ERROR, right);\n+                return null;\n+            }\n+            result \u003d lval / rval;\n+            break;\n+        default:\n+            throw new Error(\"Unexpected arithmetic operator\");\n     }\n-    return n;\n+    if (String.valueOf(result).length() \u003c\u003d String.valueOf(lval).length() + String.valueOf(rval).length() + 1 \u0026\u0026 Math.abs(result) \u003c\u003d MAX_FOLD_NUMBER) {\n+        Node newNumber \u003d Node.newNumber(result);\n+        return newNumber;\n+    }\n+    return null;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "bbf3ed85e0f668331edb269329bf577fe27932a8": {
      "type": "Ybodychange",
      "commitMessage": "\nOptimize modulo like other operators.\nContributed by timwintle\nFixes issue 267\n\nRevision created by MOE tool push_codebase.\n\nR\u003djohnlenz\nDELTA\u003d11  (11 added, 0 deleted, 0 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d716028\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@507 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "10/25/10, 10:22 AM",
      "commitName": "bbf3ed85e0f668331edb269329bf577fe27932a8",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "9/21/10, 9:21 AM",
      "commitNameOld": "b7ad2fb211e62adfb260852fd03e4d17ff51226e",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 34.04,
      "commitsBetweenForRepo": 56,
      "commitsBetweenForFile": 1,
      "actualSource": "private Node tryFoldArithmetic(Node n, Node left, Node right) {\n    if (left.getType() \u003d\u003d Token.NUMBER \u0026\u0026 right.getType() \u003d\u003d Token.NUMBER) {\n        double result;\n        double lval \u003d left.getDouble();\n        double rval \u003d right.getDouble();\n        switch(n.getType()) {\n            case Token.ADD:\n                result \u003d lval + rval;\n                break;\n            case Token.SUB:\n                result \u003d lval - rval;\n                break;\n            case Token.MUL:\n                result \u003d lval * rval;\n                break;\n            case Token.MOD:\n                if (rval \u003d\u003d 0) {\n                    error(DIVIDE_BY_0_ERROR, right);\n                    return n;\n                }\n                result \u003d lval % rval;\n                break;\n            case Token.DIV:\n                if (rval \u003d\u003d 0) {\n                    error(DIVIDE_BY_0_ERROR, right);\n                    return n;\n                }\n                result \u003d lval / rval;\n                break;\n            default:\n                throw new Error(\"Unknown arithmetic operator\");\n        }\n        if (String.valueOf(result).length() \u003c\u003d String.valueOf(lval).length() + String.valueOf(rval).length() + 1 \u0026\u0026 Math.abs(result) \u003c\u003d MAX_FOLD_NUMBER) {\n            Node newNumber \u003d Node.newNumber(result);\n            n.getParent().replaceChild(n, newNumber);\n            reportCodeChange();\n            return newNumber;\n        }\n    }\n    return n;\n}",
      "path": "src/com/google/javascript/jscomp/PeepholeFoldConstants.java",
      "functionStartLine": 499,
      "functionName": "tryFoldArithmetic",
      "functionAnnotation": "",
      "functionDoc": "Try to fold arithmetic binary operators\n",
      "diff": "@@ -1,34 +1,41 @@\n private Node tryFoldArithmetic(Node n, Node left, Node right) {\n     if (left.getType() \u003d\u003d Token.NUMBER \u0026\u0026 right.getType() \u003d\u003d Token.NUMBER) {\n         double result;\n         double lval \u003d left.getDouble();\n         double rval \u003d right.getDouble();\n         switch(n.getType()) {\n             case Token.ADD:\n                 result \u003d lval + rval;\n                 break;\n             case Token.SUB:\n                 result \u003d lval - rval;\n                 break;\n             case Token.MUL:\n                 result \u003d lval * rval;\n                 break;\n+            case Token.MOD:\n+                if (rval \u003d\u003d 0) {\n+                    error(DIVIDE_BY_0_ERROR, right);\n+                    return n;\n+                }\n+                result \u003d lval % rval;\n+                break;\n             case Token.DIV:\n                 if (rval \u003d\u003d 0) {\n                     error(DIVIDE_BY_0_ERROR, right);\n                     return n;\n                 }\n                 result \u003d lval / rval;\n                 break;\n             default:\n                 throw new Error(\"Unknown arithmetic operator\");\n         }\n         if (String.valueOf(result).length() \u003c\u003d String.valueOf(lval).length() + String.valueOf(rval).length() + 1 \u0026\u0026 Math.abs(result) \u003c\u003d MAX_FOLD_NUMBER) {\n             Node newNumber \u003d Node.newNumber(result);\n             n.getParent().replaceChild(n, newNumber);\n             reportCodeChange();\n             return newNumber;\n         }\n     }\n     return n;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "83d03ec5c8b7c49896841a9386bec0f75d2697a5": {
      "type": "Ybodychange",
      "commitMessage": "\nChange on 2010/06/24 by johnlenz\n\n        Add support to ant task for manage dependencies.\n        Fixes issue 188.\n\n        R\u003dnicksantos\n        DELTA\u003d7  (7 added, 0 deleted, 0 changed)\n\nChange on 2010/06/24 by johnlenz\n\n        Add character set encoding support to the ant task.\n        Fixes issue 186.\n\n        R\u003dnicksantos\n        DELTA\u003d27  (24 added, 0 deleted, 3 changed)\n\nChange on 2010/06/24 by elnatan\n\n        Refactored: rewrote while loop as for-each loop\n\n        R\u003dnicksantos\n        DELTA\u003d7  (0 added, 5 deleted, 2 changed)\n\nChange on 2010/06/24 by nicksantos\n\n        Add IE\u0027s imeMode to the externs file, so that we can enable/disable\n        IMEs.\n\n        R\u003dshanbhag\n        DELTA\u003d6  (6 added, 0 deleted, 0 changed)\n\nChange on 2010/06/24 by nicksantos\n\n        the answer to your question about\n        inferring param types and return types is yes. :)\n\n        R\u003drjfioravanti\n        DELTA\u003d21  (21 added, 0 deleted, 0 changed)\n\nChange on 2010/06/24 by cindylau\n\n        Add experimental.cookies API to Chrome Extensions externs file.\n\n        R\u003dacleung\n        DELTA\u003d70  (70 added, 0 deleted, 0 changed)\n\nChange on 2010/06/24 by nicksantos\n\n        don\u0027t fold numbers when they get really big.\n        SanityCheck is upset because large numbers cause non-determinism\n        in compile jobs, due to fixed-point rounding errors.\n\n        R\u003dacleung\n        DELTA\u003d12  (11 added, 0 deleted, 1 changed)\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d37004\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@253 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "6/24/10, 7:36 PM",
      "commitName": "83d03ec5c8b7c49896841a9386bec0f75d2697a5",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "6/22/10, 4:00 PM",
      "commitNameOld": "c9e89727dc8063d087d28e42629606f4fd74a6e5",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 2.15,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "private Node tryFoldArithmetic(Node n, Node left, Node right) {\n    if (left.getType() \u003d\u003d Token.NUMBER \u0026\u0026 right.getType() \u003d\u003d Token.NUMBER) {\n        double result;\n        double lval \u003d left.getDouble();\n        double rval \u003d right.getDouble();\n        switch(n.getType()) {\n            case Token.ADD:\n                result \u003d lval + rval;\n                break;\n            case Token.SUB:\n                result \u003d lval - rval;\n                break;\n            case Token.MUL:\n                result \u003d lval * rval;\n                break;\n            case Token.DIV:\n                if (rval \u003d\u003d 0) {\n                    error(DIVIDE_BY_0_ERROR, right);\n                    return n;\n                }\n                result \u003d lval / rval;\n                break;\n            default:\n                throw new Error(\"Unknown arithmetic operator\");\n        }\n        if (String.valueOf(result).length() \u003c\u003d String.valueOf(lval).length() + String.valueOf(rval).length() + 1 \u0026\u0026 Math.abs(result) \u003c\u003d MAX_FOLD_NUMBER) {\n            Node newNumber \u003d Node.newNumber(result);\n            n.getParent().replaceChild(n, newNumber);\n            reportCodeChange();\n            return newNumber;\n        }\n    }\n    return n;\n}",
      "path": "src/com/google/javascript/jscomp/PeepholeFoldConstants.java",
      "functionStartLine": 533,
      "functionName": "tryFoldArithmetic",
      "functionAnnotation": "",
      "functionDoc": "Try to fold arithmetic binary operators\n",
      "diff": "@@ -1,34 +1,34 @@\n private Node tryFoldArithmetic(Node n, Node left, Node right) {\n     if (left.getType() \u003d\u003d Token.NUMBER \u0026\u0026 right.getType() \u003d\u003d Token.NUMBER) {\n         double result;\n         double lval \u003d left.getDouble();\n         double rval \u003d right.getDouble();\n         switch(n.getType()) {\n             case Token.ADD:\n                 result \u003d lval + rval;\n                 break;\n             case Token.SUB:\n                 result \u003d lval - rval;\n                 break;\n             case Token.MUL:\n                 result \u003d lval * rval;\n                 break;\n             case Token.DIV:\n                 if (rval \u003d\u003d 0) {\n                     error(DIVIDE_BY_0_ERROR, right);\n                     return n;\n                 }\n                 result \u003d lval / rval;\n                 break;\n             default:\n                 throw new Error(\"Unknown arithmetic operator\");\n         }\n-        if (String.valueOf(result).length() \u003c\u003d String.valueOf(lval).length() + String.valueOf(rval).length() + 1) {\n+        if (String.valueOf(result).length() \u003c\u003d String.valueOf(lval).length() + String.valueOf(rval).length() + 1 \u0026\u0026 Math.abs(result) \u003c\u003d MAX_FOLD_NUMBER) {\n             Node newNumber \u003d Node.newNumber(result);\n             n.getParent().replaceChild(n, newNumber);\n             reportCodeChange();\n             return newNumber;\n         }\n     }\n     return n;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c9e89727dc8063d087d28e42629606f4fd74a6e5": {
      "type": "Ymultichange(Ymovefromfile,Yreturntypechange,Ymodifierchange,Ybodychange,Yparameterchange)",
      "commitMessage": "\nChange on 2010/06/22 by nicksantos\n\n\tvariable coalescing better be run AFTER ambiguate properties, and\n\tafter denormalization.\n\n\tR\u003djohnlenz\n\tDELTA\u003d36  (20 added, 16 deleted, 0 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d34005\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@248 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "6/22/10, 4:00 PM",
      "commitName": "c9e89727dc8063d087d28e42629606f4fd74a6e5",
      "commitAuthor": "Nicholas.J.Santos",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "\nChange on 2010/06/22 by nicksantos\n\n\tvariable coalescing better be run AFTER ambiguate properties, and\n\tafter denormalization.\n\n\tR\u003djohnlenz\n\tDELTA\u003d36  (20 added, 16 deleted, 0 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d34005\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@248 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "6/22/10, 4:00 PM",
          "commitName": "c9e89727dc8063d087d28e42629606f4fd74a6e5",
          "commitAuthor": "Nicholas.J.Santos",
          "commitDateOld": "6/21/10, 12:59 PM",
          "commitNameOld": "5f09a76531fb4f6e182238411017e6fc7e74ad16",
          "commitAuthorOld": "Nicholas.J.Santos",
          "daysBetweenCommits": 1.13,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "private Node tryFoldArithmetic(Node n, Node left, Node right) {\n    if (left.getType() \u003d\u003d Token.NUMBER \u0026\u0026 right.getType() \u003d\u003d Token.NUMBER) {\n        double result;\n        double lval \u003d left.getDouble();\n        double rval \u003d right.getDouble();\n        switch(n.getType()) {\n            case Token.ADD:\n                result \u003d lval + rval;\n                break;\n            case Token.SUB:\n                result \u003d lval - rval;\n                break;\n            case Token.MUL:\n                result \u003d lval * rval;\n                break;\n            case Token.DIV:\n                if (rval \u003d\u003d 0) {\n                    error(DIVIDE_BY_0_ERROR, right);\n                    return n;\n                }\n                result \u003d lval / rval;\n                break;\n            default:\n                throw new Error(\"Unknown arithmetic operator\");\n        }\n        if (String.valueOf(result).length() \u003c\u003d String.valueOf(lval).length() + String.valueOf(rval).length() + 1) {\n            Node newNumber \u003d Node.newNumber(result);\n            n.getParent().replaceChild(n, newNumber);\n            reportCodeChange();\n            return newNumber;\n        }\n    }\n    return n;\n}",
          "path": "src/com/google/javascript/jscomp/PeepholeFoldConstants.java",
          "functionStartLine": 531,
          "functionName": "tryFoldArithmetic",
          "functionAnnotation": "",
          "functionDoc": "Try to fold arithmetic binary operators\n",
          "diff": "@@ -1,31 +1,34 @@\n-void tryFoldArithmetic(NodeTraversal t, Node n, Node left, Node right, Node parent) {\n+private Node tryFoldArithmetic(Node n, Node left, Node right) {\n     if (left.getType() \u003d\u003d Token.NUMBER \u0026\u0026 right.getType() \u003d\u003d Token.NUMBER) {\n         double result;\n         double lval \u003d left.getDouble();\n         double rval \u003d right.getDouble();\n         switch(n.getType()) {\n             case Token.ADD:\n                 result \u003d lval + rval;\n                 break;\n             case Token.SUB:\n                 result \u003d lval - rval;\n                 break;\n             case Token.MUL:\n                 result \u003d lval * rval;\n                 break;\n             case Token.DIV:\n                 if (rval \u003d\u003d 0) {\n-                    error(t, DIVIDE_BY_0_ERROR, right);\n-                    return;\n+                    error(DIVIDE_BY_0_ERROR, right);\n+                    return n;\n                 }\n                 result \u003d lval / rval;\n                 break;\n             default:\n                 throw new Error(\"Unknown arithmetic operator\");\n         }\n         if (String.valueOf(result).length() \u003c\u003d String.valueOf(lval).length() + String.valueOf(rval).length() + 1) {\n-            parent.replaceChild(n, Node.newNumber(result));\n-            t.getCompiler().reportCodeChange();\n+            Node newNumber \u003d Node.newNumber(result);\n+            n.getParent().replaceChild(n, newNumber);\n+            reportCodeChange();\n+            return newNumber;\n         }\n     }\n+    return n;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldPath": "src/com/google/javascript/jscomp/FoldConstants.java",
            "newPath": "src/com/google/javascript/jscomp/PeepholeFoldConstants.java",
            "oldMethodName": "tryFoldArithmetic",
            "newMethodName": "tryFoldArithmetic"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "\nChange on 2010/06/22 by nicksantos\n\n\tvariable coalescing better be run AFTER ambiguate properties, and\n\tafter denormalization.\n\n\tR\u003djohnlenz\n\tDELTA\u003d36  (20 added, 16 deleted, 0 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d34005\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@248 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "6/22/10, 4:00 PM",
          "commitName": "c9e89727dc8063d087d28e42629606f4fd74a6e5",
          "commitAuthor": "Nicholas.J.Santos",
          "commitDateOld": "6/21/10, 12:59 PM",
          "commitNameOld": "5f09a76531fb4f6e182238411017e6fc7e74ad16",
          "commitAuthorOld": "Nicholas.J.Santos",
          "daysBetweenCommits": 1.13,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "private Node tryFoldArithmetic(Node n, Node left, Node right) {\n    if (left.getType() \u003d\u003d Token.NUMBER \u0026\u0026 right.getType() \u003d\u003d Token.NUMBER) {\n        double result;\n        double lval \u003d left.getDouble();\n        double rval \u003d right.getDouble();\n        switch(n.getType()) {\n            case Token.ADD:\n                result \u003d lval + rval;\n                break;\n            case Token.SUB:\n                result \u003d lval - rval;\n                break;\n            case Token.MUL:\n                result \u003d lval * rval;\n                break;\n            case Token.DIV:\n                if (rval \u003d\u003d 0) {\n                    error(DIVIDE_BY_0_ERROR, right);\n                    return n;\n                }\n                result \u003d lval / rval;\n                break;\n            default:\n                throw new Error(\"Unknown arithmetic operator\");\n        }\n        if (String.valueOf(result).length() \u003c\u003d String.valueOf(lval).length() + String.valueOf(rval).length() + 1) {\n            Node newNumber \u003d Node.newNumber(result);\n            n.getParent().replaceChild(n, newNumber);\n            reportCodeChange();\n            return newNumber;\n        }\n    }\n    return n;\n}",
          "path": "src/com/google/javascript/jscomp/PeepholeFoldConstants.java",
          "functionStartLine": 531,
          "functionName": "tryFoldArithmetic",
          "functionAnnotation": "",
          "functionDoc": "Try to fold arithmetic binary operators\n",
          "diff": "@@ -1,31 +1,34 @@\n-void tryFoldArithmetic(NodeTraversal t, Node n, Node left, Node right, Node parent) {\n+private Node tryFoldArithmetic(Node n, Node left, Node right) {\n     if (left.getType() \u003d\u003d Token.NUMBER \u0026\u0026 right.getType() \u003d\u003d Token.NUMBER) {\n         double result;\n         double lval \u003d left.getDouble();\n         double rval \u003d right.getDouble();\n         switch(n.getType()) {\n             case Token.ADD:\n                 result \u003d lval + rval;\n                 break;\n             case Token.SUB:\n                 result \u003d lval - rval;\n                 break;\n             case Token.MUL:\n                 result \u003d lval * rval;\n                 break;\n             case Token.DIV:\n                 if (rval \u003d\u003d 0) {\n-                    error(t, DIVIDE_BY_0_ERROR, right);\n-                    return;\n+                    error(DIVIDE_BY_0_ERROR, right);\n+                    return n;\n                 }\n                 result \u003d lval / rval;\n                 break;\n             default:\n                 throw new Error(\"Unknown arithmetic operator\");\n         }\n         if (String.valueOf(result).length() \u003c\u003d String.valueOf(lval).length() + String.valueOf(rval).length() + 1) {\n-            parent.replaceChild(n, Node.newNumber(result));\n-            t.getCompiler().reportCodeChange();\n+            Node newNumber \u003d Node.newNumber(result);\n+            n.getParent().replaceChild(n, newNumber);\n+            reportCodeChange();\n+            return newNumber;\n         }\n     }\n+    return n;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "void",
            "newValue": "Node"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "\nChange on 2010/06/22 by nicksantos\n\n\tvariable coalescing better be run AFTER ambiguate properties, and\n\tafter denormalization.\n\n\tR\u003djohnlenz\n\tDELTA\u003d36  (20 added, 16 deleted, 0 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d34005\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@248 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "6/22/10, 4:00 PM",
          "commitName": "c9e89727dc8063d087d28e42629606f4fd74a6e5",
          "commitAuthor": "Nicholas.J.Santos",
          "commitDateOld": "6/21/10, 12:59 PM",
          "commitNameOld": "5f09a76531fb4f6e182238411017e6fc7e74ad16",
          "commitAuthorOld": "Nicholas.J.Santos",
          "daysBetweenCommits": 1.13,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "private Node tryFoldArithmetic(Node n, Node left, Node right) {\n    if (left.getType() \u003d\u003d Token.NUMBER \u0026\u0026 right.getType() \u003d\u003d Token.NUMBER) {\n        double result;\n        double lval \u003d left.getDouble();\n        double rval \u003d right.getDouble();\n        switch(n.getType()) {\n            case Token.ADD:\n                result \u003d lval + rval;\n                break;\n            case Token.SUB:\n                result \u003d lval - rval;\n                break;\n            case Token.MUL:\n                result \u003d lval * rval;\n                break;\n            case Token.DIV:\n                if (rval \u003d\u003d 0) {\n                    error(DIVIDE_BY_0_ERROR, right);\n                    return n;\n                }\n                result \u003d lval / rval;\n                break;\n            default:\n                throw new Error(\"Unknown arithmetic operator\");\n        }\n        if (String.valueOf(result).length() \u003c\u003d String.valueOf(lval).length() + String.valueOf(rval).length() + 1) {\n            Node newNumber \u003d Node.newNumber(result);\n            n.getParent().replaceChild(n, newNumber);\n            reportCodeChange();\n            return newNumber;\n        }\n    }\n    return n;\n}",
          "path": "src/com/google/javascript/jscomp/PeepholeFoldConstants.java",
          "functionStartLine": 531,
          "functionName": "tryFoldArithmetic",
          "functionAnnotation": "",
          "functionDoc": "Try to fold arithmetic binary operators\n",
          "diff": "@@ -1,31 +1,34 @@\n-void tryFoldArithmetic(NodeTraversal t, Node n, Node left, Node right, Node parent) {\n+private Node tryFoldArithmetic(Node n, Node left, Node right) {\n     if (left.getType() \u003d\u003d Token.NUMBER \u0026\u0026 right.getType() \u003d\u003d Token.NUMBER) {\n         double result;\n         double lval \u003d left.getDouble();\n         double rval \u003d right.getDouble();\n         switch(n.getType()) {\n             case Token.ADD:\n                 result \u003d lval + rval;\n                 break;\n             case Token.SUB:\n                 result \u003d lval - rval;\n                 break;\n             case Token.MUL:\n                 result \u003d lval * rval;\n                 break;\n             case Token.DIV:\n                 if (rval \u003d\u003d 0) {\n-                    error(t, DIVIDE_BY_0_ERROR, right);\n-                    return;\n+                    error(DIVIDE_BY_0_ERROR, right);\n+                    return n;\n                 }\n                 result \u003d lval / rval;\n                 break;\n             default:\n                 throw new Error(\"Unknown arithmetic operator\");\n         }\n         if (String.valueOf(result).length() \u003c\u003d String.valueOf(lval).length() + String.valueOf(rval).length() + 1) {\n-            parent.replaceChild(n, Node.newNumber(result));\n-            t.getCompiler().reportCodeChange();\n+            Node newNumber \u003d Node.newNumber(result);\n+            n.getParent().replaceChild(n, newNumber);\n+            reportCodeChange();\n+            return newNumber;\n         }\n     }\n+    return n;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[private]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "\nChange on 2010/06/22 by nicksantos\n\n\tvariable coalescing better be run AFTER ambiguate properties, and\n\tafter denormalization.\n\n\tR\u003djohnlenz\n\tDELTA\u003d36  (20 added, 16 deleted, 0 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d34005\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@248 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "6/22/10, 4:00 PM",
          "commitName": "c9e89727dc8063d087d28e42629606f4fd74a6e5",
          "commitAuthor": "Nicholas.J.Santos",
          "commitDateOld": "6/21/10, 12:59 PM",
          "commitNameOld": "5f09a76531fb4f6e182238411017e6fc7e74ad16",
          "commitAuthorOld": "Nicholas.J.Santos",
          "daysBetweenCommits": 1.13,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "private Node tryFoldArithmetic(Node n, Node left, Node right) {\n    if (left.getType() \u003d\u003d Token.NUMBER \u0026\u0026 right.getType() \u003d\u003d Token.NUMBER) {\n        double result;\n        double lval \u003d left.getDouble();\n        double rval \u003d right.getDouble();\n        switch(n.getType()) {\n            case Token.ADD:\n                result \u003d lval + rval;\n                break;\n            case Token.SUB:\n                result \u003d lval - rval;\n                break;\n            case Token.MUL:\n                result \u003d lval * rval;\n                break;\n            case Token.DIV:\n                if (rval \u003d\u003d 0) {\n                    error(DIVIDE_BY_0_ERROR, right);\n                    return n;\n                }\n                result \u003d lval / rval;\n                break;\n            default:\n                throw new Error(\"Unknown arithmetic operator\");\n        }\n        if (String.valueOf(result).length() \u003c\u003d String.valueOf(lval).length() + String.valueOf(rval).length() + 1) {\n            Node newNumber \u003d Node.newNumber(result);\n            n.getParent().replaceChild(n, newNumber);\n            reportCodeChange();\n            return newNumber;\n        }\n    }\n    return n;\n}",
          "path": "src/com/google/javascript/jscomp/PeepholeFoldConstants.java",
          "functionStartLine": 531,
          "functionName": "tryFoldArithmetic",
          "functionAnnotation": "",
          "functionDoc": "Try to fold arithmetic binary operators\n",
          "diff": "@@ -1,31 +1,34 @@\n-void tryFoldArithmetic(NodeTraversal t, Node n, Node left, Node right, Node parent) {\n+private Node tryFoldArithmetic(Node n, Node left, Node right) {\n     if (left.getType() \u003d\u003d Token.NUMBER \u0026\u0026 right.getType() \u003d\u003d Token.NUMBER) {\n         double result;\n         double lval \u003d left.getDouble();\n         double rval \u003d right.getDouble();\n         switch(n.getType()) {\n             case Token.ADD:\n                 result \u003d lval + rval;\n                 break;\n             case Token.SUB:\n                 result \u003d lval - rval;\n                 break;\n             case Token.MUL:\n                 result \u003d lval * rval;\n                 break;\n             case Token.DIV:\n                 if (rval \u003d\u003d 0) {\n-                    error(t, DIVIDE_BY_0_ERROR, right);\n-                    return;\n+                    error(DIVIDE_BY_0_ERROR, right);\n+                    return n;\n                 }\n                 result \u003d lval / rval;\n                 break;\n             default:\n                 throw new Error(\"Unknown arithmetic operator\");\n         }\n         if (String.valueOf(result).length() \u003c\u003d String.valueOf(lval).length() + String.valueOf(rval).length() + 1) {\n-            parent.replaceChild(n, Node.newNumber(result));\n-            t.getCompiler().reportCodeChange();\n+            Node newNumber \u003d Node.newNumber(result);\n+            n.getParent().replaceChild(n, newNumber);\n+            reportCodeChange();\n+            return newNumber;\n         }\n     }\n+    return n;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "\nChange on 2010/06/22 by nicksantos\n\n\tvariable coalescing better be run AFTER ambiguate properties, and\n\tafter denormalization.\n\n\tR\u003djohnlenz\n\tDELTA\u003d36  (20 added, 16 deleted, 0 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d34005\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@248 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "6/22/10, 4:00 PM",
          "commitName": "c9e89727dc8063d087d28e42629606f4fd74a6e5",
          "commitAuthor": "Nicholas.J.Santos",
          "commitDateOld": "6/21/10, 12:59 PM",
          "commitNameOld": "5f09a76531fb4f6e182238411017e6fc7e74ad16",
          "commitAuthorOld": "Nicholas.J.Santos",
          "daysBetweenCommits": 1.13,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "private Node tryFoldArithmetic(Node n, Node left, Node right) {\n    if (left.getType() \u003d\u003d Token.NUMBER \u0026\u0026 right.getType() \u003d\u003d Token.NUMBER) {\n        double result;\n        double lval \u003d left.getDouble();\n        double rval \u003d right.getDouble();\n        switch(n.getType()) {\n            case Token.ADD:\n                result \u003d lval + rval;\n                break;\n            case Token.SUB:\n                result \u003d lval - rval;\n                break;\n            case Token.MUL:\n                result \u003d lval * rval;\n                break;\n            case Token.DIV:\n                if (rval \u003d\u003d 0) {\n                    error(DIVIDE_BY_0_ERROR, right);\n                    return n;\n                }\n                result \u003d lval / rval;\n                break;\n            default:\n                throw new Error(\"Unknown arithmetic operator\");\n        }\n        if (String.valueOf(result).length() \u003c\u003d String.valueOf(lval).length() + String.valueOf(rval).length() + 1) {\n            Node newNumber \u003d Node.newNumber(result);\n            n.getParent().replaceChild(n, newNumber);\n            reportCodeChange();\n            return newNumber;\n        }\n    }\n    return n;\n}",
          "path": "src/com/google/javascript/jscomp/PeepholeFoldConstants.java",
          "functionStartLine": 531,
          "functionName": "tryFoldArithmetic",
          "functionAnnotation": "",
          "functionDoc": "Try to fold arithmetic binary operators\n",
          "diff": "@@ -1,31 +1,34 @@\n-void tryFoldArithmetic(NodeTraversal t, Node n, Node left, Node right, Node parent) {\n+private Node tryFoldArithmetic(Node n, Node left, Node right) {\n     if (left.getType() \u003d\u003d Token.NUMBER \u0026\u0026 right.getType() \u003d\u003d Token.NUMBER) {\n         double result;\n         double lval \u003d left.getDouble();\n         double rval \u003d right.getDouble();\n         switch(n.getType()) {\n             case Token.ADD:\n                 result \u003d lval + rval;\n                 break;\n             case Token.SUB:\n                 result \u003d lval - rval;\n                 break;\n             case Token.MUL:\n                 result \u003d lval * rval;\n                 break;\n             case Token.DIV:\n                 if (rval \u003d\u003d 0) {\n-                    error(t, DIVIDE_BY_0_ERROR, right);\n-                    return;\n+                    error(DIVIDE_BY_0_ERROR, right);\n+                    return n;\n                 }\n                 result \u003d lval / rval;\n                 break;\n             default:\n                 throw new Error(\"Unknown arithmetic operator\");\n         }\n         if (String.valueOf(result).length() \u003c\u003d String.valueOf(lval).length() + String.valueOf(rval).length() + 1) {\n-            parent.replaceChild(n, Node.newNumber(result));\n-            t.getCompiler().reportCodeChange();\n+            Node newNumber \u003d Node.newNumber(result);\n+            n.getParent().replaceChild(n, newNumber);\n+            reportCodeChange();\n+            return newNumber;\n         }\n     }\n+    return n;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[t-NodeTraversal, n-Node, left-Node, right-Node, parent-Node]",
            "newValue": "[n-Node, left-Node, right-Node]"
          }
        }
      ]
    },
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": {
      "type": "Yintroduced",
      "commitMessage": "Initial commit.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/3/09, 3:51 PM",
      "commitName": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "diff": "@@ -0,0 +1,31 @@\n+void tryFoldArithmetic(NodeTraversal t, Node n, Node left, Node right, Node parent) {\n+    if (left.getType() \u003d\u003d Token.NUMBER \u0026\u0026 right.getType() \u003d\u003d Token.NUMBER) {\n+        double result;\n+        double lval \u003d left.getDouble();\n+        double rval \u003d right.getDouble();\n+        switch(n.getType()) {\n+            case Token.ADD:\n+                result \u003d lval + rval;\n+                break;\n+            case Token.SUB:\n+                result \u003d lval - rval;\n+                break;\n+            case Token.MUL:\n+                result \u003d lval * rval;\n+                break;\n+            case Token.DIV:\n+                if (rval \u003d\u003d 0) {\n+                    error(t, DIVIDE_BY_0_ERROR, right);\n+                    return;\n+                }\n+                result \u003d lval / rval;\n+                break;\n+            default:\n+                throw new Error(\"Unknown arithmetic operator\");\n+        }\n+        if (String.valueOf(result).length() \u003c\u003d String.valueOf(lval).length() + String.valueOf(rval).length() + 1) {\n+            parent.replaceChild(n, Node.newNumber(result));\n+            t.getCompiler().reportCodeChange();\n+        }\n+    }\n+}\n\\ No newline at end of file\n",
      "actualSource": "void tryFoldArithmetic(NodeTraversal t, Node n, Node left, Node right, Node parent) {\n    if (left.getType() \u003d\u003d Token.NUMBER \u0026\u0026 right.getType() \u003d\u003d Token.NUMBER) {\n        double result;\n        double lval \u003d left.getDouble();\n        double rval \u003d right.getDouble();\n        switch(n.getType()) {\n            case Token.ADD:\n                result \u003d lval + rval;\n                break;\n            case Token.SUB:\n                result \u003d lval - rval;\n                break;\n            case Token.MUL:\n                result \u003d lval * rval;\n                break;\n            case Token.DIV:\n                if (rval \u003d\u003d 0) {\n                    error(t, DIVIDE_BY_0_ERROR, right);\n                    return;\n                }\n                result \u003d lval / rval;\n                break;\n            default:\n                throw new Error(\"Unknown arithmetic operator\");\n        }\n        if (String.valueOf(result).length() \u003c\u003d String.valueOf(lval).length() + String.valueOf(rval).length() + 1) {\n            parent.replaceChild(n, Node.newNumber(result));\n            t.getCompiler().reportCodeChange();\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/FoldConstants.java",
      "functionStartLine": 1061,
      "functionName": "tryFoldArithmetic",
      "functionAnnotation": "",
      "functionDoc": "Try to fold arithmetic binary operators\n"
    }
  }
}