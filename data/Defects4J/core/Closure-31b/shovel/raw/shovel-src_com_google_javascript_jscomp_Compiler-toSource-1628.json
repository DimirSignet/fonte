{
  "origin": "codeshovel",
  "repositoryName": "Closure-31b",
  "repositoryPath": "/tmp/Closure-31b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "Compiler.java",
  "functionName": "toSource",
  "functionId": "toSource___cb-CodeBuilder(modifiers-final)__inputSeqNum-int(modifiers-final)__root-Node(modifiers-final)",
  "sourceFilePath": "src/com/google/javascript/jscomp/Compiler.java",
  "functionAnnotation": "",
  "functionDoc": "Writes out js code from a root node. If printing input delimiters, this\nmethod will attach a comment to the start of the text indicating which\ninput the output derived from. If there were any preserve annotations\nwithin the root\u0027s source, they will also be printed in a block comment\nat the beginning of the output.\n",
  "functionStartLine": 1628,
  "functionEndLine": 1690,
  "numCommitsSeen": 142,
  "timeTaken": 10015,
  "changeHistory": [
    "ec324a9bb23eb78c76f537f4c4170ba88d542f1c",
    "3dc40c89e9c04b1dfecaeea3d7b1cf638bf3be52",
    "76abdf11394c0e7515ae63335676ea3657badb45",
    "9320feca198878ca9464aae089399a8891c314d7",
    "de726510af4329fb8eeb8a54b2d93d8d37c87545",
    "cd40201a2437da125ac492b21f13c8ad200b96bd",
    "e829dafb9b3365bda6b6bb80f5fa97783752d143",
    "b29d4a8bc7138f9216930edfebed29d42f0dca89",
    "a70a7c599e53a7752cf4b9e6e82b4408c3c4c04b",
    "9afca869d4236594514b8461d771af9999c8a989",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3"
  ],
  "changeHistoryShort": {
    "ec324a9bb23eb78c76f537f4c4170ba88d542f1c": "Ybodychange",
    "3dc40c89e9c04b1dfecaeea3d7b1cf638bf3be52": "Ybodychange",
    "76abdf11394c0e7515ae63335676ea3657badb45": "Ybodychange",
    "9320feca198878ca9464aae089399a8891c314d7": "Ybodychange",
    "de726510af4329fb8eeb8a54b2d93d8d37c87545": "Ybodychange",
    "cd40201a2437da125ac492b21f13c8ad200b96bd": "Ybodychange",
    "e829dafb9b3365bda6b6bb80f5fa97783752d143": "Ybodychange",
    "b29d4a8bc7138f9216930edfebed29d42f0dca89": "Yformatchange",
    "a70a7c599e53a7752cf4b9e6e82b4408c3c4c04b": "Ybodychange",
    "9afca869d4236594514b8461d771af9999c8a989": "Ybodychange",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "ec324a9bb23eb78c76f537f4c4170ba88d542f1c": {
      "type": "Ybodychange",
      "commitMessage": "\nReplace the bulk of the Node.getType() \u003d\u003d Token.XXX calls with\nNode.isXXX calls.\n\nR\u003dnicksantos\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3677\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1582 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/10/11, 8:36 AM",
      "commitName": "ec324a9bb23eb78c76f537f4c4170ba88d542f1c",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "11/3/11, 8:48 AM",
      "commitNameOld": "56b80409782adba1f2e29c66ad808098a8edcf51",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 7.03,
      "commitsBetweenForRepo": 32,
      "commitsBetweenForFile": 1,
      "actualSource": "public void toSource(final CodeBuilder cb, final int inputSeqNum, final Node root) {\n    runInCompilerThread(new Callable\u003cVoid\u003e() {\n\n        @Override\n        public Void call() throws Exception {\n            if (options.printInputDelimiter) {\n                if ((cb.getLength() \u003e 0) \u0026\u0026 !cb.endsWith(\"\\n\")) {\n                    cb.append(\"\\n\");\n                }\n                Preconditions.checkState(root.isScript());\n                String delimiter \u003d options.inputDelimiter;\n                String inputName \u003d root.getInputId().getIdName();\n                String sourceName \u003d root.getSourceFileName();\n                Preconditions.checkState(sourceName !\u003d null);\n                Preconditions.checkState(!sourceName.isEmpty());\n                delimiter \u003d delimiter.replaceAll(\"%name%\", Matcher.quoteReplacement(inputName)).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n                cb.append(delimiter).append(\"\\n\");\n            }\n            if (root.getJSDocInfo() !\u003d null \u0026\u0026 root.getJSDocInfo().getLicense() !\u003d null) {\n                cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n            }\n            if (options.sourceMapOutputPath !\u003d null) {\n                sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n            }\n            String code \u003d toSource(root, sourceMap, inputSeqNum \u003d\u003d 0);\n            if (!code.isEmpty()) {\n                cb.append(code);\n                int length \u003d code.length();\n                char lastChar \u003d code.charAt(length - 1);\n                char secondLastChar \u003d length \u003e\u003d 2 ? code.charAt(length - 2) : \u0027\\0\u0027;\n                boolean hasSemiColon \u003d lastChar \u003d\u003d \u0027;\u0027 || (lastChar \u003d\u003d \u0027\\n\u0027 \u0026\u0026 secondLastChar \u003d\u003d \u0027;\u0027);\n                if (!hasSemiColon) {\n                    cb.append(\";\");\n                }\n            }\n            return null;\n        }\n    });\n}",
      "path": "src/com/google/javascript/jscomp/Compiler.java",
      "functionStartLine": 1461,
      "functionName": "toSource",
      "functionAnnotation": "",
      "functionDoc": "Writes out js code from a root node. If printing input delimiters, this\nmethod will attach a comment to the start of the text indicating which\ninput the output derived from. If there were any preserve annotations\nwithin the root\u0027s source, they will also be printed in a block comment\nat the beginning of the output.\n",
      "diff": "@@ -1,39 +1,39 @@\n public void toSource(final CodeBuilder cb, final int inputSeqNum, final Node root) {\n     runInCompilerThread(new Callable\u003cVoid\u003e() {\n \n         @Override\n         public Void call() throws Exception {\n             if (options.printInputDelimiter) {\n                 if ((cb.getLength() \u003e 0) \u0026\u0026 !cb.endsWith(\"\\n\")) {\n                     cb.append(\"\\n\");\n                 }\n-                Preconditions.checkState(root.getType() \u003d\u003d Token.SCRIPT);\n+                Preconditions.checkState(root.isScript());\n                 String delimiter \u003d options.inputDelimiter;\n                 String inputName \u003d root.getInputId().getIdName();\n                 String sourceName \u003d root.getSourceFileName();\n                 Preconditions.checkState(sourceName !\u003d null);\n                 Preconditions.checkState(!sourceName.isEmpty());\n                 delimiter \u003d delimiter.replaceAll(\"%name%\", Matcher.quoteReplacement(inputName)).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n                 cb.append(delimiter).append(\"\\n\");\n             }\n             if (root.getJSDocInfo() !\u003d null \u0026\u0026 root.getJSDocInfo().getLicense() !\u003d null) {\n                 cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n             }\n             if (options.sourceMapOutputPath !\u003d null) {\n                 sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n             }\n             String code \u003d toSource(root, sourceMap, inputSeqNum \u003d\u003d 0);\n             if (!code.isEmpty()) {\n                 cb.append(code);\n                 int length \u003d code.length();\n                 char lastChar \u003d code.charAt(length - 1);\n                 char secondLastChar \u003d length \u003e\u003d 2 ? code.charAt(length - 2) : \u0027\\0\u0027;\n                 boolean hasSemiColon \u003d lastChar \u003d\u003d \u0027;\u0027 || (lastChar \u003d\u003d \u0027\\n\u0027 \u0026\u0026 secondLastChar \u003d\u003d \u0027;\u0027);\n                 if (!hasSemiColon) {\n                     cb.append(\";\");\n                 }\n             }\n             return null;\n         }\n     });\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3dc40c89e9c04b1dfecaeea3d7b1cf638bf3be52": {
      "type": "Ybodychange",
      "commitMessage": "\nOutput the input name and escape it when requested for input\nseperators.\n\nR\u003dacleung\nDELTA\u003d5  (3 added, 0 deleted, 2 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d2917\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1333 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "8/5/11, 11:41 AM",
      "commitName": "3dc40c89e9c04b1dfecaeea3d7b1cf638bf3be52",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "8/4/11, 11:43 AM",
      "commitNameOld": "1b8156d41fe441ab03999f1e2c5ac4537e79fc75",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 1.0,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "public void toSource(final CodeBuilder cb, final int inputSeqNum, final Node root) {\n    runInCompilerThread(new Callable\u003cVoid\u003e() {\n\n        @Override\n        public Void call() throws Exception {\n            if (options.printInputDelimiter) {\n                if ((cb.getLength() \u003e 0) \u0026\u0026 !cb.endsWith(\"\\n\")) {\n                    cb.append(\"\\n\");\n                }\n                Preconditions.checkState(root.getType() \u003d\u003d Token.SCRIPT);\n                String delimiter \u003d options.inputDelimiter;\n                String inputName \u003d root.getInputId().getIdName();\n                String sourceName \u003d root.getSourceFileName();\n                Preconditions.checkState(sourceName !\u003d null);\n                Preconditions.checkState(!sourceName.isEmpty());\n                delimiter \u003d delimiter.replaceAll(\"%name%\", Matcher.quoteReplacement(inputName)).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n                cb.append(delimiter).append(\"\\n\");\n            }\n            if (root.getJSDocInfo() !\u003d null \u0026\u0026 root.getJSDocInfo().getLicense() !\u003d null) {\n                cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n            }\n            if (options.sourceMapOutputPath !\u003d null) {\n                sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n            }\n            String code \u003d toSource(root, sourceMap, inputSeqNum \u003d\u003d 0);\n            if (!code.isEmpty()) {\n                cb.append(code);\n                int length \u003d code.length();\n                char lastChar \u003d code.charAt(length - 1);\n                char secondLastChar \u003d length \u003e\u003d 2 ? code.charAt(length - 2) : \u0027\\0\u0027;\n                boolean hasSemiColon \u003d lastChar \u003d\u003d \u0027;\u0027 || (lastChar \u003d\u003d \u0027\\n\u0027 \u0026\u0026 secondLastChar \u003d\u003d \u0027;\u0027);\n                if (!hasSemiColon) {\n                    cb.append(\";\");\n                }\n            }\n            return null;\n        }\n    });\n}",
      "path": "src/com/google/javascript/jscomp/Compiler.java",
      "functionStartLine": 1453,
      "functionName": "toSource",
      "functionAnnotation": "",
      "functionDoc": "Writes out js code from a root node. If printing input delimiters, this\nmethod will attach a comment to the start of the text indicating which\ninput the output derived from. If there were any preserve annotations\nwithin the root\u0027s source, they will also be printed in a block comment\nat the beginning of the output.\n",
      "diff": "@@ -1,38 +1,39 @@\n public void toSource(final CodeBuilder cb, final int inputSeqNum, final Node root) {\n     runInCompilerThread(new Callable\u003cVoid\u003e() {\n \n         @Override\n         public Void call() throws Exception {\n             if (options.printInputDelimiter) {\n                 if ((cb.getLength() \u003e 0) \u0026\u0026 !cb.endsWith(\"\\n\")) {\n                     cb.append(\"\\n\");\n                 }\n                 Preconditions.checkState(root.getType() \u003d\u003d Token.SCRIPT);\n                 String delimiter \u003d options.inputDelimiter;\n+                String inputName \u003d root.getInputId().getIdName();\n                 String sourceName \u003d root.getSourceFileName();\n                 Preconditions.checkState(sourceName !\u003d null);\n                 Preconditions.checkState(!sourceName.isEmpty());\n-                delimiter \u003d delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n+                delimiter \u003d delimiter.replaceAll(\"%name%\", Matcher.quoteReplacement(inputName)).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n                 cb.append(delimiter).append(\"\\n\");\n             }\n             if (root.getJSDocInfo() !\u003d null \u0026\u0026 root.getJSDocInfo().getLicense() !\u003d null) {\n                 cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n             }\n             if (options.sourceMapOutputPath !\u003d null) {\n                 sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n             }\n             String code \u003d toSource(root, sourceMap, inputSeqNum \u003d\u003d 0);\n             if (!code.isEmpty()) {\n                 cb.append(code);\n                 int length \u003d code.length();\n                 char lastChar \u003d code.charAt(length - 1);\n                 char secondLastChar \u003d length \u003e\u003d 2 ? code.charAt(length - 2) : \u0027\\0\u0027;\n                 boolean hasSemiColon \u003d lastChar \u003d\u003d \u0027;\u0027 || (lastChar \u003d\u003d \u0027\\n\u0027 \u0026\u0026 secondLastChar \u003d\u003d \u0027;\u0027);\n                 if (!hasSemiColon) {\n                     cb.append(\";\");\n                 }\n             }\n             return null;\n         }\n     });\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "76abdf11394c0e7515ae63335676ea3657badb45": {
      "type": "Ybodychange",
      "commitMessage": "\nMake our build warnings free.\n\nR\u003dacleung\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d2830\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1301 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "7/28/11, 4:19 PM",
      "commitName": "76abdf11394c0e7515ae63335676ea3657badb45",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "7/27/11, 2:43 PM",
      "commitNameOld": "02b68944372c37ff896034c803bdbce9460da893",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 1.07,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "public void toSource(final CodeBuilder cb, final int inputSeqNum, final Node root) {\n    runInCompilerThread(new Callable\u003cVoid\u003e() {\n\n        @Override\n        public Void call() throws Exception {\n            if (options.printInputDelimiter) {\n                if ((cb.getLength() \u003e 0) \u0026\u0026 !cb.endsWith(\"\\n\")) {\n                    cb.append(\"\\n\");\n                }\n                Preconditions.checkState(root.getType() \u003d\u003d Token.SCRIPT);\n                String delimiter \u003d options.inputDelimiter;\n                String sourceName \u003d root.getSourceFileName();\n                Preconditions.checkState(sourceName !\u003d null);\n                Preconditions.checkState(!sourceName.isEmpty());\n                delimiter \u003d delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n                cb.append(delimiter).append(\"\\n\");\n            }\n            if (root.getJSDocInfo() !\u003d null \u0026\u0026 root.getJSDocInfo().getLicense() !\u003d null) {\n                cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n            }\n            if (options.sourceMapOutputPath !\u003d null) {\n                sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n            }\n            String code \u003d toSource(root, sourceMap, inputSeqNum \u003d\u003d 0);\n            if (!code.isEmpty()) {\n                cb.append(code);\n                int length \u003d code.length();\n                char lastChar \u003d code.charAt(length - 1);\n                char secondLastChar \u003d length \u003e\u003d 2 ? code.charAt(length - 2) : \u0027\\0\u0027;\n                boolean hasSemiColon \u003d lastChar \u003d\u003d \u0027;\u0027 || (lastChar \u003d\u003d \u0027\\n\u0027 \u0026\u0026 secondLastChar \u003d\u003d \u0027;\u0027);\n                if (!hasSemiColon) {\n                    cb.append(\";\");\n                }\n            }\n            return null;\n        }\n    });\n}",
      "path": "src/com/google/javascript/jscomp/Compiler.java",
      "functionStartLine": 1443,
      "functionName": "toSource",
      "functionAnnotation": "",
      "functionDoc": "Writes out js code from a root node. If printing input delimiters, this\nmethod will attach a comment to the start of the text indicating which\ninput the output derived from. If there were any preserve annotations\nwithin the root\u0027s source, they will also be printed in a block comment\nat the beginning of the output.\n",
      "diff": "@@ -1,37 +1,38 @@\n public void toSource(final CodeBuilder cb, final int inputSeqNum, final Node root) {\n     runInCompilerThread(new Callable\u003cVoid\u003e() {\n \n+        @Override\n         public Void call() throws Exception {\n             if (options.printInputDelimiter) {\n                 if ((cb.getLength() \u003e 0) \u0026\u0026 !cb.endsWith(\"\\n\")) {\n                     cb.append(\"\\n\");\n                 }\n                 Preconditions.checkState(root.getType() \u003d\u003d Token.SCRIPT);\n                 String delimiter \u003d options.inputDelimiter;\n                 String sourceName \u003d root.getSourceFileName();\n                 Preconditions.checkState(sourceName !\u003d null);\n                 Preconditions.checkState(!sourceName.isEmpty());\n                 delimiter \u003d delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n                 cb.append(delimiter).append(\"\\n\");\n             }\n             if (root.getJSDocInfo() !\u003d null \u0026\u0026 root.getJSDocInfo().getLicense() !\u003d null) {\n                 cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n             }\n             if (options.sourceMapOutputPath !\u003d null) {\n                 sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n             }\n             String code \u003d toSource(root, sourceMap, inputSeqNum \u003d\u003d 0);\n             if (!code.isEmpty()) {\n                 cb.append(code);\n                 int length \u003d code.length();\n                 char lastChar \u003d code.charAt(length - 1);\n                 char secondLastChar \u003d length \u003e\u003d 2 ? code.charAt(length - 2) : \u0027\\0\u0027;\n                 boolean hasSemiColon \u003d lastChar \u003d\u003d \u0027;\u0027 || (lastChar \u003d\u003d \u0027\\n\u0027 \u0026\u0026 secondLastChar \u003d\u003d \u0027;\u0027);\n                 if (!hasSemiColon) {\n                     cb.append(\";\");\n                 }\n             }\n             return null;\n         }\n     });\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9320feca198878ca9464aae089399a8891c314d7": {
      "type": "Ybodychange",
      "commitMessage": "\nMake StaticSourceFile a property of Node\n\nR\u003djohnlenz\nDELTA\u003d183  (102 added, 25 deleted, 56 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d2496\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1236 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "6/30/11, 1:25 PM",
      "commitName": "9320feca198878ca9464aae089399a8891c314d7",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "6/17/11, 2:36 PM",
      "commitNameOld": "de726510af4329fb8eeb8a54b2d93d8d37c87545",
      "commitAuthorOld": "zhuyi@google.com",
      "daysBetweenCommits": 12.95,
      "commitsBetweenForRepo": 43,
      "commitsBetweenForFile": 1,
      "actualSource": "public void toSource(final CodeBuilder cb, final int inputSeqNum, final Node root) {\n    runInCompilerThread(new Callable\u003cVoid\u003e() {\n\n        public Void call() throws Exception {\n            if (options.printInputDelimiter) {\n                if ((cb.getLength() \u003e 0) \u0026\u0026 !cb.endsWith(\"\\n\")) {\n                    cb.append(\"\\n\");\n                }\n                Preconditions.checkState(root.getType() \u003d\u003d Token.SCRIPT);\n                String delimiter \u003d options.inputDelimiter;\n                String sourceName \u003d root.getSourceFileName();\n                Preconditions.checkState(sourceName !\u003d null);\n                Preconditions.checkState(!sourceName.isEmpty());\n                delimiter \u003d delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n                cb.append(delimiter).append(\"\\n\");\n            }\n            if (root.getJSDocInfo() !\u003d null \u0026\u0026 root.getJSDocInfo().getLicense() !\u003d null) {\n                cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n            }\n            if (options.sourceMapOutputPath !\u003d null) {\n                sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n            }\n            String code \u003d toSource(root, sourceMap, inputSeqNum \u003d\u003d 0);\n            if (!code.isEmpty()) {\n                cb.append(code);\n                int length \u003d code.length();\n                char lastChar \u003d code.charAt(length - 1);\n                char secondLastChar \u003d length \u003e\u003d 2 ? code.charAt(length - 2) : \u0027\\0\u0027;\n                boolean hasSemiColon \u003d lastChar \u003d\u003d \u0027;\u0027 || (lastChar \u003d\u003d \u0027\\n\u0027 \u0026\u0026 secondLastChar \u003d\u003d \u0027;\u0027);\n                if (!hasSemiColon) {\n                    cb.append(\";\");\n                }\n            }\n            return null;\n        }\n    });\n}",
      "path": "src/com/google/javascript/jscomp/Compiler.java",
      "functionStartLine": 1393,
      "functionName": "toSource",
      "functionAnnotation": "",
      "functionDoc": "Writes out js code from a root node. If printing input delimiters, this\nmethod will attach a comment to the start of the text indicating which\ninput the output derived from. If there were any preserve annotations\nwithin the root\u0027s source, they will also be printed in a block comment\nat the beginning of the output.\n",
      "diff": "@@ -1,37 +1,37 @@\n public void toSource(final CodeBuilder cb, final int inputSeqNum, final Node root) {\n     runInCompilerThread(new Callable\u003cVoid\u003e() {\n \n         public Void call() throws Exception {\n             if (options.printInputDelimiter) {\n                 if ((cb.getLength() \u003e 0) \u0026\u0026 !cb.endsWith(\"\\n\")) {\n                     cb.append(\"\\n\");\n                 }\n                 Preconditions.checkState(root.getType() \u003d\u003d Token.SCRIPT);\n                 String delimiter \u003d options.inputDelimiter;\n-                String sourceName \u003d (String) root.getProp(Node.SOURCENAME_PROP);\n+                String sourceName \u003d root.getSourceFileName();\n                 Preconditions.checkState(sourceName !\u003d null);\n                 Preconditions.checkState(!sourceName.isEmpty());\n                 delimiter \u003d delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n                 cb.append(delimiter).append(\"\\n\");\n             }\n             if (root.getJSDocInfo() !\u003d null \u0026\u0026 root.getJSDocInfo().getLicense() !\u003d null) {\n                 cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n             }\n             if (options.sourceMapOutputPath !\u003d null) {\n                 sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n             }\n             String code \u003d toSource(root, sourceMap, inputSeqNum \u003d\u003d 0);\n             if (!code.isEmpty()) {\n                 cb.append(code);\n                 int length \u003d code.length();\n                 char lastChar \u003d code.charAt(length - 1);\n                 char secondLastChar \u003d length \u003e\u003d 2 ? code.charAt(length - 2) : \u0027\\0\u0027;\n                 boolean hasSemiColon \u003d lastChar \u003d\u003d \u0027;\u0027 || (lastChar \u003d\u003d \u0027\\n\u0027 \u0026\u0026 secondLastChar \u003d\u003d \u0027;\u0027);\n                 if (!hasSemiColon) {\n                     cb.append(\";\");\n                 }\n             }\n             return null;\n         }\n     });\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "de726510af4329fb8eeb8a54b2d93d8d37c87545": {
      "type": "Ybodychange",
      "commitMessage": "\nWhen -language_in\u003dECMASCRIPT5_STRICT, only print \u0027use strict\u0027 in the first input file. \nFixes Issue 489.\n\nR\u003dacleung\nDELTA\u003d22  (18 added, 0 deleted, 4 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d2325\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1192 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "6/17/11, 2:36 PM",
      "commitName": "de726510af4329fb8eeb8a54b2d93d8d37c87545",
      "commitAuthor": "zhuyi@google.com",
      "commitDateOld": "5/27/11, 10:34 AM",
      "commitNameOld": "29312d9f6d01e6c1fce4da0a644881c83864549f",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 21.17,
      "commitsBetweenForRepo": 52,
      "commitsBetweenForFile": 1,
      "actualSource": "public void toSource(final CodeBuilder cb, final int inputSeqNum, final Node root) {\n    runInCompilerThread(new Callable\u003cVoid\u003e() {\n\n        public Void call() throws Exception {\n            if (options.printInputDelimiter) {\n                if ((cb.getLength() \u003e 0) \u0026\u0026 !cb.endsWith(\"\\n\")) {\n                    cb.append(\"\\n\");\n                }\n                Preconditions.checkState(root.getType() \u003d\u003d Token.SCRIPT);\n                String delimiter \u003d options.inputDelimiter;\n                String sourceName \u003d (String) root.getProp(Node.SOURCENAME_PROP);\n                Preconditions.checkState(sourceName !\u003d null);\n                Preconditions.checkState(!sourceName.isEmpty());\n                delimiter \u003d delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n                cb.append(delimiter).append(\"\\n\");\n            }\n            if (root.getJSDocInfo() !\u003d null \u0026\u0026 root.getJSDocInfo().getLicense() !\u003d null) {\n                cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n            }\n            if (options.sourceMapOutputPath !\u003d null) {\n                sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n            }\n            String code \u003d toSource(root, sourceMap, inputSeqNum \u003d\u003d 0);\n            if (!code.isEmpty()) {\n                cb.append(code);\n                int length \u003d code.length();\n                char lastChar \u003d code.charAt(length - 1);\n                char secondLastChar \u003d length \u003e\u003d 2 ? code.charAt(length - 2) : \u0027\\0\u0027;\n                boolean hasSemiColon \u003d lastChar \u003d\u003d \u0027;\u0027 || (lastChar \u003d\u003d \u0027\\n\u0027 \u0026\u0026 secondLastChar \u003d\u003d \u0027;\u0027);\n                if (!hasSemiColon) {\n                    cb.append(\";\");\n                }\n            }\n            return null;\n        }\n    });\n}",
      "path": "src/com/google/javascript/jscomp/Compiler.java",
      "functionStartLine": 1393,
      "functionName": "toSource",
      "functionAnnotation": "",
      "functionDoc": "Writes out js code from a root node. If printing input delimiters, this\nmethod will attach a comment to the start of the text indicating which\ninput the output derived from. If there were any preserve annotations\nwithin the root\u0027s source, they will also be printed in a block comment\nat the beginning of the output.\n",
      "diff": "@@ -1,37 +1,37 @@\n public void toSource(final CodeBuilder cb, final int inputSeqNum, final Node root) {\n     runInCompilerThread(new Callable\u003cVoid\u003e() {\n \n         public Void call() throws Exception {\n             if (options.printInputDelimiter) {\n                 if ((cb.getLength() \u003e 0) \u0026\u0026 !cb.endsWith(\"\\n\")) {\n                     cb.append(\"\\n\");\n                 }\n                 Preconditions.checkState(root.getType() \u003d\u003d Token.SCRIPT);\n                 String delimiter \u003d options.inputDelimiter;\n                 String sourceName \u003d (String) root.getProp(Node.SOURCENAME_PROP);\n                 Preconditions.checkState(sourceName !\u003d null);\n                 Preconditions.checkState(!sourceName.isEmpty());\n                 delimiter \u003d delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n                 cb.append(delimiter).append(\"\\n\");\n             }\n             if (root.getJSDocInfo() !\u003d null \u0026\u0026 root.getJSDocInfo().getLicense() !\u003d null) {\n                 cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n             }\n             if (options.sourceMapOutputPath !\u003d null) {\n                 sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n             }\n-            String code \u003d toSource(root, sourceMap);\n+            String code \u003d toSource(root, sourceMap, inputSeqNum \u003d\u003d 0);\n             if (!code.isEmpty()) {\n                 cb.append(code);\n                 int length \u003d code.length();\n                 char lastChar \u003d code.charAt(length - 1);\n                 char secondLastChar \u003d length \u003e\u003d 2 ? code.charAt(length - 2) : \u0027\\0\u0027;\n                 boolean hasSemiColon \u003d lastChar \u003d\u003d \u0027;\u0027 || (lastChar \u003d\u003d \u0027\\n\u0027 \u0026\u0026 secondLastChar \u003d\u003d \u0027;\u0027);\n                 if (!hasSemiColon) {\n                     cb.append(\";\");\n                 }\n             }\n             return null;\n         }\n     });\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "cd40201a2437da125ac492b21f13c8ad200b96bd": {
      "type": "Ybodychange",
      "commitMessage": "\npretty print in the ExternExportsPass, try #2\nMake sure the source file ends with a semi-colon and newline\nwhen pretty printed.\nChanges some of the printing that\u0027s\ndone in Compiler.jar (new since try #1)\nFixes issue 309\n\nR\u003djschorr\nDELTA\u003d87  (24 added, 12 deleted, 51 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d220\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@671 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "1/6/11, 5:42 PM",
      "commitName": "cd40201a2437da125ac492b21f13c8ad200b96bd",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "12/20/10, 11:36 AM",
      "commitNameOld": "4ccc7f3359019b0217393b0b22edca2e598b5597",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 17.25,
      "commitsBetweenForRepo": 21,
      "commitsBetweenForFile": 1,
      "actualSource": "public void toSource(final CodeBuilder cb, final int inputSeqNum, final Node root) {\n    runInCompilerThread(new Callable\u003cVoid\u003e() {\n\n        public Void call() throws Exception {\n            if (options.printInputDelimiter) {\n                if ((cb.getLength() \u003e 0) \u0026\u0026 !cb.endsWith(\"\\n\")) {\n                    cb.append(\"\\n\");\n                }\n                Preconditions.checkState(root.getType() \u003d\u003d Token.SCRIPT);\n                String delimiter \u003d options.inputDelimiter;\n                String sourceName \u003d (String) root.getProp(Node.SOURCENAME_PROP);\n                Preconditions.checkState(sourceName !\u003d null);\n                Preconditions.checkState(!sourceName.isEmpty());\n                delimiter \u003d delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n                cb.append(delimiter).append(\"\\n\");\n            }\n            if (root.getJSDocInfo() !\u003d null \u0026\u0026 root.getJSDocInfo().getLicense() !\u003d null) {\n                cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n            }\n            if (options.sourceMapOutputPath !\u003d null) {\n                sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n            }\n            String code \u003d toSource(root, sourceMap);\n            if (!code.isEmpty()) {\n                cb.append(code);\n                int length \u003d code.length();\n                char lastChar \u003d code.charAt(length - 1);\n                char secondLastChar \u003d length \u003e\u003d 2 ? code.charAt(length - 2) : \u0027\\0\u0027;\n                boolean hasSemiColon \u003d lastChar \u003d\u003d \u0027;\u0027 || (lastChar \u003d\u003d \u0027\\n\u0027 \u0026\u0026 secondLastChar \u003d\u003d \u0027;\u0027);\n                if (!hasSemiColon) {\n                    cb.append(\";\");\n                }\n            }\n            return null;\n        }\n    });\n}",
      "path": "src/com/google/javascript/jscomp/Compiler.java",
      "functionStartLine": 1341,
      "functionName": "toSource",
      "functionAnnotation": "",
      "functionDoc": "Writes out js code from a root node. If printing input delimiters, this\nmethod will attach a comment to the start of the text indicating which\ninput the output derived from. If there were any preserve annotations\nwithin the root\u0027s source, they will also be printed in a block comment\nat the beginning of the output.\n",
      "diff": "@@ -1,33 +1,37 @@\n public void toSource(final CodeBuilder cb, final int inputSeqNum, final Node root) {\n     runInCompilerThread(new Callable\u003cVoid\u003e() {\n \n         public Void call() throws Exception {\n             if (options.printInputDelimiter) {\n                 if ((cb.getLength() \u003e 0) \u0026\u0026 !cb.endsWith(\"\\n\")) {\n                     cb.append(\"\\n\");\n                 }\n                 Preconditions.checkState(root.getType() \u003d\u003d Token.SCRIPT);\n                 String delimiter \u003d options.inputDelimiter;\n                 String sourceName \u003d (String) root.getProp(Node.SOURCENAME_PROP);\n                 Preconditions.checkState(sourceName !\u003d null);\n                 Preconditions.checkState(!sourceName.isEmpty());\n                 delimiter \u003d delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n                 cb.append(delimiter).append(\"\\n\");\n             }\n             if (root.getJSDocInfo() !\u003d null \u0026\u0026 root.getJSDocInfo().getLicense() !\u003d null) {\n                 cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n             }\n             if (options.sourceMapOutputPath !\u003d null) {\n                 sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n             }\n             String code \u003d toSource(root, sourceMap);\n             if (!code.isEmpty()) {\n                 cb.append(code);\n-                if (!code.endsWith(\";\")) {\n+                int length \u003d code.length();\n+                char lastChar \u003d code.charAt(length - 1);\n+                char secondLastChar \u003d length \u003e\u003d 2 ? code.charAt(length - 2) : \u0027\\0\u0027;\n+                boolean hasSemiColon \u003d lastChar \u003d\u003d \u0027;\u0027 || (lastChar \u003d\u003d \u0027\\n\u0027 \u0026\u0026 secondLastChar \u003d\u003d \u0027;\u0027);\n+                if (!hasSemiColon) {\n                     cb.append(\";\");\n                 }\n             }\n             return null;\n         }\n     });\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e829dafb9b3365bda6b6bb80f5fa97783752d143": {
      "type": "Ybodychange",
      "commitMessage": "\nChange on 2010/06/17 by nicksantos\n\n        don\u0027t use Sets to build union types.\n\n        R\u003djohnlenz\n        DELTA\u003d76  (52 added, 6 deleted, 18 changed)\n\nChange on 2010/06/17 by nicksantos\n\n        fix a couple bugs in goog.scope processing\n\n        R\u003drobbyw\n        DELTA\u003d54  (42 added, 11 deleted, 1 changed)\n\n\nChange on 2010/06/17 by acleung\n\n        Disables function argument check with @notypecheck is on for the whole file.\n\n        R\u003djohnlenz\n        DELTA\u003d8  (5 added, 1 deleted, 2 changed)\n\nChange on 2010/06/17 by dcc\n\n        Fix NPE in ExportExternsPass with --check_types\u003dfalse.\n\n        R\u003dacleung\n        DELTA\u003d72  (66 added, 4 deleted, 2 changed)\n\nChange on 2010/06/17 by johnlenz\n\n        Change stub method parameters to allow sanity checks to pass with\n        CrossModuleMethodMotion.\n\n        R\u003dnicksantos\n        DELTA\u003d7  (3 added, 0 deleted, 4 changed)\n\nChange on 2010/06/18 by johnlenz\n\n        Modify AliasKeywords so passes the sanity checks: don\u0027t create coding\n        convention constants without annotation them so that the tests pass\n        when the sanity checks are on.\n\n        R\u003dnicksantos\n        DELTA\u003d18  (5 added, 0 deleted, 13 changed)\n\nChange on 2010/06/18 by johnlenz\n\n        Fix source maps when run with sanity checks.\n\n        R\u003dnicksantos\n        DELTA\u003d10  (7 added, 0 deleted, 3 changed)\n\nChange on 2010/06/18 by johnlenz\n\n        Changes to PrepareAst to make it valid to run during SanityChecks.\n\n        R\u003dnicksantos\n        DELTA\u003d18  (5 added, 0 deleted, 13 changed)\n\nChange on 2010/06/18 by nicksantos\n\n        fix constant annotations in CollapseProperties.\n\n        R\u003djohnlenz\n        DELTA\u003d61  (49 added, 1 deleted, 11 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d30002\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@246 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "6/18/10, 5:18 PM",
      "commitName": "e829dafb9b3365bda6b6bb80f5fa97783752d143",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "6/16/10, 12:33 PM",
      "commitNameOld": "e33e925eea3a8e4de958864e531e1adc4da62e18",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 2.2,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "public void toSource(final CodeBuilder cb, final int inputSeqNum, final Node root) {\n    runInCompilerThread(new Callable\u003cVoid\u003e() {\n\n        public Void call() throws Exception {\n            if (options.printInputDelimiter) {\n                if ((cb.getLength() \u003e 0) \u0026\u0026 !cb.endsWith(\"\\n\")) {\n                    cb.append(\"\\n\");\n                }\n                Preconditions.checkState(root.getType() \u003d\u003d Token.SCRIPT);\n                String delimiter \u003d options.inputDelimiter;\n                String sourceName \u003d (String) root.getProp(Node.SOURCENAME_PROP);\n                Preconditions.checkState(sourceName !\u003d null);\n                Preconditions.checkState(!sourceName.isEmpty());\n                delimiter \u003d delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n                cb.append(delimiter).append(\"\\n\");\n            }\n            if (root.getJSDocInfo() !\u003d null \u0026\u0026 root.getJSDocInfo().getLicense() !\u003d null) {\n                cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n            }\n            if (options.sourceMapOutputPath !\u003d null) {\n                sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n            }\n            String code \u003d toSource(root, sourceMap);\n            if (!code.isEmpty()) {\n                cb.append(code);\n                if (!code.endsWith(\";\")) {\n                    cb.append(\";\");\n                }\n            }\n            return null;\n        }\n    });\n}",
      "path": "src/com/google/javascript/jscomp/Compiler.java",
      "functionStartLine": 1290,
      "functionName": "toSource",
      "functionAnnotation": "",
      "functionDoc": "Writes out js code from a root node. If printing input delimiters, this\nmethod will attach a comment to the start of the text indicating which\ninput the output derived from. If there were any preserve annotations\nwithin the root\u0027s source, they will also be printed in a block comment\nat the beginning of the output.\n",
      "diff": "@@ -1,33 +1,33 @@\n public void toSource(final CodeBuilder cb, final int inputSeqNum, final Node root) {\n     runInCompilerThread(new Callable\u003cVoid\u003e() {\n \n         public Void call() throws Exception {\n             if (options.printInputDelimiter) {\n                 if ((cb.getLength() \u003e 0) \u0026\u0026 !cb.endsWith(\"\\n\")) {\n                     cb.append(\"\\n\");\n                 }\n                 Preconditions.checkState(root.getType() \u003d\u003d Token.SCRIPT);\n                 String delimiter \u003d options.inputDelimiter;\n                 String sourceName \u003d (String) root.getProp(Node.SOURCENAME_PROP);\n                 Preconditions.checkState(sourceName !\u003d null);\n                 Preconditions.checkState(!sourceName.isEmpty());\n                 delimiter \u003d delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n                 cb.append(delimiter).append(\"\\n\");\n             }\n             if (root.getJSDocInfo() !\u003d null \u0026\u0026 root.getJSDocInfo().getLicense() !\u003d null) {\n                 cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n             }\n             if (options.sourceMapOutputPath !\u003d null) {\n                 sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n             }\n-            String code \u003d toSource(root);\n+            String code \u003d toSource(root, sourceMap);\n             if (!code.isEmpty()) {\n                 cb.append(code);\n                 if (!code.endsWith(\";\")) {\n                     cb.append(\";\");\n                 }\n             }\n             return null;\n         }\n     });\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b29d4a8bc7138f9216930edfebed29d42f0dca89": {
      "type": "Yformatchange",
      "commitMessage": "\nChange on 2010/04/19 by nick\n\n        automatic source-sorting based on closure dependencies.\n\n        R\u003dalan\n        DELTA\u003d98  (89 added, 5 deleted, 4 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003dohwxnh\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@192 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/20/10, 9:00 AM",
      "commitName": "b29d4a8bc7138f9216930edfebed29d42f0dca89",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "4/15/10, 4:45 PM",
      "commitNameOld": "e3bcc1c6e7ce7e9bfc3098cd5bf57774049f5baa",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 4.68,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "public void toSource(final CodeBuilder cb, final int inputSeqNum, final Node root) {\n    runInCompilerThread(new Callable\u003cVoid\u003e() {\n\n        public Void call() throws Exception {\n            if (options.printInputDelimiter) {\n                if ((cb.getLength() \u003e 0) \u0026\u0026 !cb.endsWith(\"\\n\")) {\n                    cb.append(\"\\n\");\n                }\n                Preconditions.checkState(root.getType() \u003d\u003d Token.SCRIPT);\n                String delimiter \u003d options.inputDelimiter;\n                String sourceName \u003d (String) root.getProp(Node.SOURCENAME_PROP);\n                Preconditions.checkState(sourceName !\u003d null);\n                Preconditions.checkState(!sourceName.isEmpty());\n                delimiter \u003d delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n                cb.append(delimiter).append(\"\\n\");\n            }\n            if (root.getJSDocInfo() !\u003d null \u0026\u0026 root.getJSDocInfo().getLicense() !\u003d null) {\n                cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n            }\n            if (options.sourceMapOutputPath !\u003d null) {\n                sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n            }\n            String code \u003d toSource(root);\n            if (!code.isEmpty()) {\n                cb.append(code);\n                if (!code.endsWith(\";\")) {\n                    cb.append(\";\");\n                }\n            }\n            return null;\n        }\n    });\n}",
      "path": "src/com/google/javascript/jscomp/Compiler.java",
      "functionStartLine": 1287,
      "functionName": "toSource",
      "functionAnnotation": "",
      "functionDoc": "Writes out js code from a root node. If printing input delimiters, this\nmethod will attach a comment to the start of the text indicating which\ninput the output derived from. If there were any preserve annotations\nwithin the root\u0027s source, they will also be printed in a block comment\nat the beginning of the output.\n",
      "diff": "",
      "extendedDetails": {}
    },
    "a70a7c599e53a7752cf4b9e6e82b4408c3c4c04b": {
      "type": "Ybodychange",
      "commitMessage": "fix silly 2004-era naming conventions (Nick)\nR\u003djohn\nDELTA\u003d134  (0 added, 0 deleted, 134 changed)\n\nInsert a place holder file for any empty modules. (Alan)\nR\u003dnick\nDELTA\u003d53  (46 added, 6 deleted, 1 changed)\n\nMaps API extern update.\n(Contributed by Chad Killingsworth)\nFixes issue 121\nDELTA\u003d86  (48 added, 16 deleted, 22 changed)\n\n\nGoogle Loader API externs.\n(Contributed by Chad Killingsworth)\nFixes issue 126\nDELTA\u003d54  (54 added, 0 deleted, 0 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@149 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "3/22/10, 10:51 PM",
      "commitName": "a70a7c599e53a7752cf4b9e6e82b4408c3c4c04b",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "3/22/10, 3:55 PM",
      "commitNameOld": "b347ce3a71e23a4ab92dc0a6c07d43e2f497c953",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 0.29,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public void toSource(final CodeBuilder cb, final int inputSeqNum, final Node root) {\n    runInCompilerThread(new Callable\u003cVoid\u003e() {\n\n        public Void call() throws Exception {\n            if (options.printInputDelimiter) {\n                if ((cb.getLength() \u003e 0) \u0026\u0026 !cb.endsWith(\"\\n\")) {\n                    cb.append(\"\\n\");\n                }\n                Preconditions.checkState(root.getType() \u003d\u003d Token.SCRIPT);\n                String delimiter \u003d options.inputDelimiter;\n                String sourceName \u003d (String) root.getProp(Node.SOURCENAME_PROP);\n                Preconditions.checkState(sourceName !\u003d null);\n                Preconditions.checkState(!sourceName.isEmpty());\n                delimiter \u003d delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n                cb.append(delimiter).append(\"\\n\");\n            }\n            if (root.getJSDocInfo() !\u003d null \u0026\u0026 root.getJSDocInfo().getLicense() !\u003d null) {\n                cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n            }\n            if (options.sourceMapOutputPath !\u003d null) {\n                sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n            }\n            String code \u003d toSource(root);\n            if (!code.isEmpty()) {\n                cb.append(code);\n                if (!code.endsWith(\";\")) {\n                    cb.append(\";\");\n                }\n            }\n            return null;\n        }\n    });\n}",
      "path": "src/com/google/javascript/jscomp/Compiler.java",
      "functionStartLine": 1213,
      "functionName": "toSource",
      "functionAnnotation": "",
      "functionDoc": "Writes out js code from a root node. If printing input delimiters, this\nmethod will attach a comment to the start of the text indicating which\ninput the output derived from. If there were any preserve annotations\nwithin the root\u0027s source, they will also be printed in a block comment\nat the beginning of the output.\n",
      "diff": "@@ -1,33 +1,33 @@\n public void toSource(final CodeBuilder cb, final int inputSeqNum, final Node root) {\n     runInCompilerThread(new Callable\u003cVoid\u003e() {\n \n         public Void call() throws Exception {\n-            if (options_.printInputDelimiter) {\n+            if (options.printInputDelimiter) {\n                 if ((cb.getLength() \u003e 0) \u0026\u0026 !cb.endsWith(\"\\n\")) {\n                     cb.append(\"\\n\");\n                 }\n                 Preconditions.checkState(root.getType() \u003d\u003d Token.SCRIPT);\n-                String delimiter \u003d options_.inputDelimiter;\n+                String delimiter \u003d options.inputDelimiter;\n                 String sourceName \u003d (String) root.getProp(Node.SOURCENAME_PROP);\n                 Preconditions.checkState(sourceName !\u003d null);\n                 Preconditions.checkState(!sourceName.isEmpty());\n                 delimiter \u003d delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n                 cb.append(delimiter).append(\"\\n\");\n             }\n             if (root.getJSDocInfo() !\u003d null \u0026\u0026 root.getJSDocInfo().getLicense() !\u003d null) {\n                 cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n             }\n-            if (options_.sourceMapOutputPath !\u003d null) {\n-                sourceMap_.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n+            if (options.sourceMapOutputPath !\u003d null) {\n+                sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n             }\n             String code \u003d toSource(root);\n             if (!code.isEmpty()) {\n                 cb.append(code);\n                 if (!code.endsWith(\";\")) {\n                     cb.append(\";\");\n                 }\n             }\n             return null;\n         }\n     });\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9afca869d4236594514b8461d771af9999c8a989": {
      "type": "Ybodychange",
      "commitMessage": "Better type checking for switch/case conditions.\n\nCustomizable input delimiters.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@75 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "1/22/10, 12:29 PM",
      "commitName": "9afca869d4236594514b8461d771af9999c8a989",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "12/17/09, 4:20 PM",
      "commitNameOld": "14ddcfdc0b8d1cece3c79221b1870b84f055d419",
      "commitAuthorOld": "nicholas.j.santos@gmail.com",
      "daysBetweenCommits": 35.84,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "actualSource": "public void toSource(final CodeBuilder cb, final int inputSeqNum, final Node root) {\n    runInCompilerThread(new Callable\u003cVoid\u003e() {\n\n        public Void call() throws Exception {\n            if (options_.printInputDelimiter) {\n                if ((cb.getLength() \u003e 0) \u0026\u0026 !cb.endsWith(\"\\n\")) {\n                    cb.append(\"\\n\");\n                }\n                Preconditions.checkState(root.getType() \u003d\u003d Token.SCRIPT);\n                String delimiter \u003d options_.inputDelimiter;\n                String sourceName \u003d (String) root.getProp(Node.SOURCENAME_PROP);\n                Preconditions.checkState(sourceName !\u003d null);\n                Preconditions.checkState(!sourceName.isEmpty());\n                delimiter \u003d delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n                cb.append(delimiter).append(\"\\n\");\n            }\n            if (root.getJSDocInfo() !\u003d null \u0026\u0026 root.getJSDocInfo().getLicense() !\u003d null) {\n                cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n            }\n            if (options_.sourceMapOutputPath !\u003d null) {\n                sourceMap_.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n            }\n            String code \u003d toSource(root);\n            if (!code.isEmpty()) {\n                cb.append(code);\n                if (!code.endsWith(\";\")) {\n                    cb.append(\";\");\n                }\n            }\n            return null;\n        }\n    });\n}",
      "path": "src/com/google/javascript/jscomp/Compiler.java",
      "functionStartLine": 1158,
      "functionName": "toSource",
      "functionAnnotation": "",
      "functionDoc": "Writes out js code from a root node. If printing input delimiters, this\nmethod will attach a comment to the start of the text indicating which\ninput the output derived from. If there were any preserve annotations\nwithin the root\u0027s source, they will also be printed in a block comment\nat the beginning of the output.\n",
      "diff": "@@ -1,27 +1,33 @@\n public void toSource(final CodeBuilder cb, final int inputSeqNum, final Node root) {\n     runInCompilerThread(new Callable\u003cVoid\u003e() {\n \n         public Void call() throws Exception {\n             if (options_.printInputDelimiter) {\n                 if ((cb.getLength() \u003e 0) \u0026\u0026 !cb.endsWith(\"\\n\")) {\n                     cb.append(\"\\n\");\n                 }\n-                cb.append(\"// Input \").append(String.valueOf(inputSeqNum)).append(\"\\n\");\n+                Preconditions.checkState(root.getType() \u003d\u003d Token.SCRIPT);\n+                String delimiter \u003d options_.inputDelimiter;\n+                String sourceName \u003d (String) root.getProp(Node.SOURCENAME_PROP);\n+                Preconditions.checkState(sourceName !\u003d null);\n+                Preconditions.checkState(!sourceName.isEmpty());\n+                delimiter \u003d delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n+                cb.append(delimiter).append(\"\\n\");\n             }\n             if (root.getJSDocInfo() !\u003d null \u0026\u0026 root.getJSDocInfo().getLicense() !\u003d null) {\n                 cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n             }\n             if (options_.sourceMapOutputPath !\u003d null) {\n                 sourceMap_.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n             }\n             String code \u003d toSource(root);\n             if (!code.isEmpty()) {\n                 cb.append(code);\n                 if (!code.endsWith(\";\")) {\n                     cb.append(\";\");\n                 }\n             }\n             return null;\n         }\n     });\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": {
      "type": "Yintroduced",
      "commitMessage": "Initial commit.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/3/09, 3:51 PM",
      "commitName": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "diff": "@@ -0,0 +1,27 @@\n+public void toSource(final CodeBuilder cb, final int inputSeqNum, final Node root) {\n+    runInCompilerThread(new Callable\u003cVoid\u003e() {\n+\n+        public Void call() throws Exception {\n+            if (options_.printInputDelimiter) {\n+                if ((cb.getLength() \u003e 0) \u0026\u0026 !cb.endsWith(\"\\n\")) {\n+                    cb.append(\"\\n\");\n+                }\n+                cb.append(\"// Input \").append(String.valueOf(inputSeqNum)).append(\"\\n\");\n+            }\n+            if (root.getJSDocInfo() !\u003d null \u0026\u0026 root.getJSDocInfo().getLicense() !\u003d null) {\n+                cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n+            }\n+            if (options_.sourceMapOutputPath !\u003d null) {\n+                sourceMap_.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n+            }\n+            String code \u003d toSource(root);\n+            if (!code.isEmpty()) {\n+                cb.append(code);\n+                if (!code.endsWith(\";\")) {\n+                    cb.append(\";\");\n+                }\n+            }\n+            return null;\n+        }\n+    });\n+}\n\\ No newline at end of file\n",
      "actualSource": "public void toSource(final CodeBuilder cb, final int inputSeqNum, final Node root) {\n    runInCompilerThread(new Callable\u003cVoid\u003e() {\n\n        public Void call() throws Exception {\n            if (options_.printInputDelimiter) {\n                if ((cb.getLength() \u003e 0) \u0026\u0026 !cb.endsWith(\"\\n\")) {\n                    cb.append(\"\\n\");\n                }\n                cb.append(\"// Input \").append(String.valueOf(inputSeqNum)).append(\"\\n\");\n            }\n            if (root.getJSDocInfo() !\u003d null \u0026\u0026 root.getJSDocInfo().getLicense() !\u003d null) {\n                cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n            }\n            if (options_.sourceMapOutputPath !\u003d null) {\n                sourceMap_.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n            }\n            String code \u003d toSource(root);\n            if (!code.isEmpty()) {\n                cb.append(code);\n                if (!code.endsWith(\";\")) {\n                    cb.append(\";\");\n                }\n            }\n            return null;\n        }\n    });\n}",
      "path": "src/com/google/javascript/jscomp/Compiler.java",
      "functionStartLine": 1198,
      "functionName": "toSource",
      "functionAnnotation": "",
      "functionDoc": "Writes out js code from a root node. If printing input delimiters, this\nmethod will attach a comment to the start of the text indicating which\ninput the output derived from. If there were any preserve annotations\nwithin the root\u0027s source, they will also be printed in a block comment\nat the beginning of the output.\n"
    }
  }
}