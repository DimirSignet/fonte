{
  "origin": "codeshovel",
  "repositoryName": "Closure-2b",
  "repositoryPath": "/tmp/Closure-2b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "JSTypeRegistry.java",
  "functionName": "createFromTypeNodesInternal",
  "functionId": "createFromTypeNodesInternal___n-Node__sourceName-String__scope-StaticScope__JSType__",
  "sourceFilePath": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
  "functionAnnotation": "",
  "functionDoc": "\n@see #createFromTypeNodes(Node, String, StaticScope)\n",
  "functionStartLine": 1520,
  "functionEndLine": 1674,
  "numCommitsSeen": 104,
  "timeTaken": 4587,
  "changeHistory": [
    "5524adbda991632656059566b69cc2771ba42b7d",
    "22dd6b542acd662c55c0ebe31ba9062d3493740e",
    "5200a1c2404a424425ab2b04a7a64e08e0ee4925",
    "4434b45f18d2e74ec809a9bbeb67571b604ce6d0",
    "e9f7e6114414f68deb90f4116861d7a054365404",
    "3698fee71e3671171c587f932795a8ab8e852cd8",
    "58c3e4ce1d17ec619bcc4964bdeebc676f93567d"
  ],
  "changeHistoryShort": {
    "5524adbda991632656059566b69cc2771ba42b7d": "Ybodychange",
    "22dd6b542acd662c55c0ebe31ba9062d3493740e": "Ybodychange",
    "5200a1c2404a424425ab2b04a7a64e08e0ee4925": "Ydocchange",
    "4434b45f18d2e74ec809a9bbeb67571b604ce6d0": "Ymultichange(Yparameterchange,Ybodychange)",
    "e9f7e6114414f68deb90f4116861d7a054365404": "Ybodychange",
    "3698fee71e3671171c587f932795a8ab8e852cd8": "Ybodychange",
    "58c3e4ce1d17ec619bcc4964bdeebc676f93567d": "Yintroduced"
  },
  "changeHistoryDetails": {
    "5524adbda991632656059566b69cc2771ba42b7d": {
      "type": "Ybodychange",
      "commitMessage": "\nRename a couple of AST nodes:\nDEFAULT becomes DEFAULT_CASE\nLP becomes PARAM_LIST\nGET becomes GETTER_DEF\nSET becomes SETTER_DEF\n\nR\u003dnicksantos\nDELTA\u003d215  (40 added, 5 deleted, 170 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3695\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1590 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/11/11, 4:42 PM",
      "commitName": "5524adbda991632656059566b69cc2771ba42b7d",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "11/10/11, 12:21 PM",
      "commitNameOld": "22dd6b542acd662c55c0ebe31ba9062d3493740e",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 1.18,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "private JSType createFromTypeNodesInternal(Node n, String sourceName, StaticScope\u003cJSType\u003e scope) {\n    switch(n.getType()) {\n        case Token.LC:\n            return createRecordTypeFromNodes(n.getFirstChild(), sourceName, scope);\n        case Token.BANG:\n            return createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope).restrictByNotNullOrUndefined();\n        case Token.QMARK:\n            Node firstChild \u003d n.getFirstChild();\n            if (firstChild \u003d\u003d null) {\n                return getNativeType(UNKNOWN_TYPE);\n            }\n            return createDefaultObjectUnion(createFromTypeNodesInternal(firstChild, sourceName, scope));\n        case Token.EQUALS:\n            return createOptionalType(createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope));\n        case Token.ELLIPSIS:\n            return createOptionalType(createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope));\n        case Token.STAR:\n            return getNativeType(ALL_TYPE);\n        case Token.LB:\n            return getNativeType(ARRAY_TYPE);\n        case Token.PIPE:\n            UnionTypeBuilder builder \u003d new UnionTypeBuilder(this);\n            for (Node child \u003d n.getFirstChild(); child !\u003d null; child \u003d child.getNext()) {\n                builder.addAlternate(createFromTypeNodesInternal(child, sourceName, scope));\n            }\n            return builder.build();\n        case Token.EMPTY:\n            return getNativeType(UNKNOWN_TYPE);\n        case Token.VOID:\n            return getNativeType(VOID_TYPE);\n        case Token.STRING:\n            JSType namedType \u003d getType(scope, n.getString(), sourceName, n.getLineno(), n.getCharno());\n            if (resolveMode !\u003d ResolveMode.LAZY_NAMES) {\n                namedType \u003d namedType.resolveInternal(reporter, scope);\n            }\n            if ((namedType instanceof ObjectType) \u0026\u0026 !(nonNullableTypeNames.contains(n.getString()))) {\n                Node typeList \u003d n.getFirstChild();\n                if (typeList !\u003d null \u0026\u0026 (\"Array\".equals(n.getString()) || \"Object\".equals(n.getString()))) {\n                    JSType parameterType \u003d createFromTypeNodesInternal(typeList.getLastChild(), sourceName, scope);\n                    namedType \u003d new ParameterizedType(this, (ObjectType) namedType, parameterType);\n                    if (typeList.hasMoreThanOneChild()) {\n                        JSType indexType \u003d createFromTypeNodesInternal(typeList.getFirstChild(), sourceName, scope);\n                        namedType \u003d new IndexedType(this, (ObjectType) namedType, indexType);\n                    }\n                }\n                return createDefaultObjectUnion(namedType);\n            } else {\n                return namedType;\n            }\n        case Token.FUNCTION:\n            ObjectType thisType \u003d null;\n            boolean isConstructor \u003d false;\n            Node current \u003d n.getFirstChild();\n            if (current.getType() \u003d\u003d Token.THIS || current.getType() \u003d\u003d Token.NEW) {\n                Node contextNode \u003d current.getFirstChild();\n                thisType \u003d ObjectType.cast(createFromTypeNodesInternal(contextNode, sourceName, scope).restrictByNotNullOrUndefined());\n                if (thisType \u003d\u003d null) {\n                    reporter.warning(ScriptRuntime.getMessage0(current.getType() \u003d\u003d Token.THIS ? \"msg.jsdoc.function.thisnotobject\" : \"msg.jsdoc.function.newnotobject\"), sourceName, contextNode.getLineno(), contextNode.getCharno());\n                }\n                isConstructor \u003d current.getType() \u003d\u003d Token.NEW;\n                current \u003d current.getNext();\n            }\n            FunctionParamBuilder paramBuilder \u003d new FunctionParamBuilder(this);\n            if (current.getType() \u003d\u003d Token.PARAM_LIST) {\n                Node args \u003d current.getFirstChild();\n                for (Node arg \u003d current.getFirstChild(); arg !\u003d null; arg \u003d arg.getNext()) {\n                    if (arg.getType() \u003d\u003d Token.ELLIPSIS) {\n                        if (arg.getChildCount() \u003d\u003d 0) {\n                            paramBuilder.addVarArgs(getNativeType(UNKNOWN_TYPE));\n                        } else {\n                            paramBuilder.addVarArgs(createFromTypeNodesInternal(arg.getFirstChild(), sourceName, scope));\n                        }\n                    } else {\n                        JSType type \u003d createFromTypeNodesInternal(arg, sourceName, scope);\n                        if (arg.getType() \u003d\u003d Token.EQUALS) {\n                            boolean addSuccess \u003d paramBuilder.addOptionalParams(type);\n                            if (!addSuccess) {\n                                reporter.warning(ScriptRuntime.getMessage0(\"msg.jsdoc.function.varargs\"), sourceName, arg.getLineno(), arg.getCharno());\n                            }\n                        } else {\n                            paramBuilder.addRequiredParams(type);\n                        }\n                    }\n                }\n                current \u003d current.getNext();\n            }\n            JSType returnType \u003d createFromTypeNodesInternal(current, sourceName, scope);\n            return new FunctionBuilder(this).withParams(paramBuilder).withReturnType(returnType).withTypeOfThis(thisType).setIsConstructor(isConstructor).build();\n    }\n    throw new IllegalStateException(\"Unexpected node in type expression: \" + n.toString());\n}",
      "path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
      "functionStartLine": 1452,
      "functionName": "createFromTypeNodesInternal",
      "functionAnnotation": "",
      "functionDoc": "\n@see #createFromTypeNodes(Node, String, StaticScope)\n",
      "diff": "@@ -1,91 +1,91 @@\n private JSType createFromTypeNodesInternal(Node n, String sourceName, StaticScope\u003cJSType\u003e scope) {\n     switch(n.getType()) {\n         case Token.LC:\n             return createRecordTypeFromNodes(n.getFirstChild(), sourceName, scope);\n         case Token.BANG:\n             return createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope).restrictByNotNullOrUndefined();\n         case Token.QMARK:\n             Node firstChild \u003d n.getFirstChild();\n             if (firstChild \u003d\u003d null) {\n                 return getNativeType(UNKNOWN_TYPE);\n             }\n             return createDefaultObjectUnion(createFromTypeNodesInternal(firstChild, sourceName, scope));\n         case Token.EQUALS:\n             return createOptionalType(createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope));\n         case Token.ELLIPSIS:\n             return createOptionalType(createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope));\n         case Token.STAR:\n             return getNativeType(ALL_TYPE);\n         case Token.LB:\n             return getNativeType(ARRAY_TYPE);\n         case Token.PIPE:\n             UnionTypeBuilder builder \u003d new UnionTypeBuilder(this);\n             for (Node child \u003d n.getFirstChild(); child !\u003d null; child \u003d child.getNext()) {\n                 builder.addAlternate(createFromTypeNodesInternal(child, sourceName, scope));\n             }\n             return builder.build();\n         case Token.EMPTY:\n             return getNativeType(UNKNOWN_TYPE);\n         case Token.VOID:\n             return getNativeType(VOID_TYPE);\n         case Token.STRING:\n             JSType namedType \u003d getType(scope, n.getString(), sourceName, n.getLineno(), n.getCharno());\n             if (resolveMode !\u003d ResolveMode.LAZY_NAMES) {\n                 namedType \u003d namedType.resolveInternal(reporter, scope);\n             }\n             if ((namedType instanceof ObjectType) \u0026\u0026 !(nonNullableTypeNames.contains(n.getString()))) {\n                 Node typeList \u003d n.getFirstChild();\n                 if (typeList !\u003d null \u0026\u0026 (\"Array\".equals(n.getString()) || \"Object\".equals(n.getString()))) {\n                     JSType parameterType \u003d createFromTypeNodesInternal(typeList.getLastChild(), sourceName, scope);\n                     namedType \u003d new ParameterizedType(this, (ObjectType) namedType, parameterType);\n                     if (typeList.hasMoreThanOneChild()) {\n                         JSType indexType \u003d createFromTypeNodesInternal(typeList.getFirstChild(), sourceName, scope);\n                         namedType \u003d new IndexedType(this, (ObjectType) namedType, indexType);\n                     }\n                 }\n                 return createDefaultObjectUnion(namedType);\n             } else {\n                 return namedType;\n             }\n         case Token.FUNCTION:\n             ObjectType thisType \u003d null;\n             boolean isConstructor \u003d false;\n             Node current \u003d n.getFirstChild();\n             if (current.getType() \u003d\u003d Token.THIS || current.getType() \u003d\u003d Token.NEW) {\n                 Node contextNode \u003d current.getFirstChild();\n                 thisType \u003d ObjectType.cast(createFromTypeNodesInternal(contextNode, sourceName, scope).restrictByNotNullOrUndefined());\n                 if (thisType \u003d\u003d null) {\n                     reporter.warning(ScriptRuntime.getMessage0(current.getType() \u003d\u003d Token.THIS ? \"msg.jsdoc.function.thisnotobject\" : \"msg.jsdoc.function.newnotobject\"), sourceName, contextNode.getLineno(), contextNode.getCharno());\n                 }\n                 isConstructor \u003d current.getType() \u003d\u003d Token.NEW;\n                 current \u003d current.getNext();\n             }\n             FunctionParamBuilder paramBuilder \u003d new FunctionParamBuilder(this);\n-            if (current.getType() \u003d\u003d Token.LP) {\n+            if (current.getType() \u003d\u003d Token.PARAM_LIST) {\n                 Node args \u003d current.getFirstChild();\n                 for (Node arg \u003d current.getFirstChild(); arg !\u003d null; arg \u003d arg.getNext()) {\n                     if (arg.getType() \u003d\u003d Token.ELLIPSIS) {\n                         if (arg.getChildCount() \u003d\u003d 0) {\n                             paramBuilder.addVarArgs(getNativeType(UNKNOWN_TYPE));\n                         } else {\n                             paramBuilder.addVarArgs(createFromTypeNodesInternal(arg.getFirstChild(), sourceName, scope));\n                         }\n                     } else {\n                         JSType type \u003d createFromTypeNodesInternal(arg, sourceName, scope);\n                         if (arg.getType() \u003d\u003d Token.EQUALS) {\n                             boolean addSuccess \u003d paramBuilder.addOptionalParams(type);\n                             if (!addSuccess) {\n                                 reporter.warning(ScriptRuntime.getMessage0(\"msg.jsdoc.function.varargs\"), sourceName, arg.getLineno(), arg.getCharno());\n                             }\n                         } else {\n                             paramBuilder.addRequiredParams(type);\n                         }\n                     }\n                 }\n                 current \u003d current.getNext();\n             }\n             JSType returnType \u003d createFromTypeNodesInternal(current, sourceName, scope);\n             return new FunctionBuilder(this).withParams(paramBuilder).withReturnType(returnType).withTypeOfThis(thisType).setIsConstructor(isConstructor).build();\n     }\n     throw new IllegalStateException(\"Unexpected node in type expression: \" + n.toString());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "22dd6b542acd662c55c0ebe31ba9062d3493740e": {
      "type": "Ybodychange",
      "commitMessage": "\nSimplify the error reporter interface.\n\nR\u003dnicksantos\nDELTA\u003d47  (24 added, 5 deleted, 18 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3690\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1585 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/10/11, 12:21 PM",
      "commitName": "22dd6b542acd662c55c0ebe31ba9062d3493740e",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "11/9/11, 2:45 PM",
      "commitNameOld": "103bd46736cbbbabe6ad27ab11da10d6dbb1a8e5",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 0.9,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "private JSType createFromTypeNodesInternal(Node n, String sourceName, StaticScope\u003cJSType\u003e scope) {\n    switch(n.getType()) {\n        case Token.LC:\n            return createRecordTypeFromNodes(n.getFirstChild(), sourceName, scope);\n        case Token.BANG:\n            return createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope).restrictByNotNullOrUndefined();\n        case Token.QMARK:\n            Node firstChild \u003d n.getFirstChild();\n            if (firstChild \u003d\u003d null) {\n                return getNativeType(UNKNOWN_TYPE);\n            }\n            return createDefaultObjectUnion(createFromTypeNodesInternal(firstChild, sourceName, scope));\n        case Token.EQUALS:\n            return createOptionalType(createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope));\n        case Token.ELLIPSIS:\n            return createOptionalType(createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope));\n        case Token.STAR:\n            return getNativeType(ALL_TYPE);\n        case Token.LB:\n            return getNativeType(ARRAY_TYPE);\n        case Token.PIPE:\n            UnionTypeBuilder builder \u003d new UnionTypeBuilder(this);\n            for (Node child \u003d n.getFirstChild(); child !\u003d null; child \u003d child.getNext()) {\n                builder.addAlternate(createFromTypeNodesInternal(child, sourceName, scope));\n            }\n            return builder.build();\n        case Token.EMPTY:\n            return getNativeType(UNKNOWN_TYPE);\n        case Token.VOID:\n            return getNativeType(VOID_TYPE);\n        case Token.STRING:\n            JSType namedType \u003d getType(scope, n.getString(), sourceName, n.getLineno(), n.getCharno());\n            if (resolveMode !\u003d ResolveMode.LAZY_NAMES) {\n                namedType \u003d namedType.resolveInternal(reporter, scope);\n            }\n            if ((namedType instanceof ObjectType) \u0026\u0026 !(nonNullableTypeNames.contains(n.getString()))) {\n                Node typeList \u003d n.getFirstChild();\n                if (typeList !\u003d null \u0026\u0026 (\"Array\".equals(n.getString()) || \"Object\".equals(n.getString()))) {\n                    JSType parameterType \u003d createFromTypeNodesInternal(typeList.getLastChild(), sourceName, scope);\n                    namedType \u003d new ParameterizedType(this, (ObjectType) namedType, parameterType);\n                    if (typeList.hasMoreThanOneChild()) {\n                        JSType indexType \u003d createFromTypeNodesInternal(typeList.getFirstChild(), sourceName, scope);\n                        namedType \u003d new IndexedType(this, (ObjectType) namedType, indexType);\n                    }\n                }\n                return createDefaultObjectUnion(namedType);\n            } else {\n                return namedType;\n            }\n        case Token.FUNCTION:\n            ObjectType thisType \u003d null;\n            boolean isConstructor \u003d false;\n            Node current \u003d n.getFirstChild();\n            if (current.getType() \u003d\u003d Token.THIS || current.getType() \u003d\u003d Token.NEW) {\n                Node contextNode \u003d current.getFirstChild();\n                thisType \u003d ObjectType.cast(createFromTypeNodesInternal(contextNode, sourceName, scope).restrictByNotNullOrUndefined());\n                if (thisType \u003d\u003d null) {\n                    reporter.warning(ScriptRuntime.getMessage0(current.getType() \u003d\u003d Token.THIS ? \"msg.jsdoc.function.thisnotobject\" : \"msg.jsdoc.function.newnotobject\"), sourceName, contextNode.getLineno(), contextNode.getCharno());\n                }\n                isConstructor \u003d current.getType() \u003d\u003d Token.NEW;\n                current \u003d current.getNext();\n            }\n            FunctionParamBuilder paramBuilder \u003d new FunctionParamBuilder(this);\n            if (current.getType() \u003d\u003d Token.LP) {\n                Node args \u003d current.getFirstChild();\n                for (Node arg \u003d current.getFirstChild(); arg !\u003d null; arg \u003d arg.getNext()) {\n                    if (arg.getType() \u003d\u003d Token.ELLIPSIS) {\n                        if (arg.getChildCount() \u003d\u003d 0) {\n                            paramBuilder.addVarArgs(getNativeType(UNKNOWN_TYPE));\n                        } else {\n                            paramBuilder.addVarArgs(createFromTypeNodesInternal(arg.getFirstChild(), sourceName, scope));\n                        }\n                    } else {\n                        JSType type \u003d createFromTypeNodesInternal(arg, sourceName, scope);\n                        if (arg.getType() \u003d\u003d Token.EQUALS) {\n                            boolean addSuccess \u003d paramBuilder.addOptionalParams(type);\n                            if (!addSuccess) {\n                                reporter.warning(ScriptRuntime.getMessage0(\"msg.jsdoc.function.varargs\"), sourceName, arg.getLineno(), arg.getCharno());\n                            }\n                        } else {\n                            paramBuilder.addRequiredParams(type);\n                        }\n                    }\n                }\n                current \u003d current.getNext();\n            }\n            JSType returnType \u003d createFromTypeNodesInternal(current, sourceName, scope);\n            return new FunctionBuilder(this).withParams(paramBuilder).withReturnType(returnType).withTypeOfThis(thisType).setIsConstructor(isConstructor).build();\n    }\n    throw new IllegalStateException(\"Unexpected node in type expression: \" + n.toString());\n}",
      "path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
      "functionStartLine": 1452,
      "functionName": "createFromTypeNodesInternal",
      "functionAnnotation": "",
      "functionDoc": "\n@see #createFromTypeNodes(Node, String, StaticScope)\n",
      "diff": "@@ -1,91 +1,91 @@\n private JSType createFromTypeNodesInternal(Node n, String sourceName, StaticScope\u003cJSType\u003e scope) {\n     switch(n.getType()) {\n         case Token.LC:\n             return createRecordTypeFromNodes(n.getFirstChild(), sourceName, scope);\n         case Token.BANG:\n             return createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope).restrictByNotNullOrUndefined();\n         case Token.QMARK:\n             Node firstChild \u003d n.getFirstChild();\n             if (firstChild \u003d\u003d null) {\n                 return getNativeType(UNKNOWN_TYPE);\n             }\n             return createDefaultObjectUnion(createFromTypeNodesInternal(firstChild, sourceName, scope));\n         case Token.EQUALS:\n             return createOptionalType(createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope));\n         case Token.ELLIPSIS:\n             return createOptionalType(createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope));\n         case Token.STAR:\n             return getNativeType(ALL_TYPE);\n         case Token.LB:\n             return getNativeType(ARRAY_TYPE);\n         case Token.PIPE:\n             UnionTypeBuilder builder \u003d new UnionTypeBuilder(this);\n             for (Node child \u003d n.getFirstChild(); child !\u003d null; child \u003d child.getNext()) {\n                 builder.addAlternate(createFromTypeNodesInternal(child, sourceName, scope));\n             }\n             return builder.build();\n         case Token.EMPTY:\n             return getNativeType(UNKNOWN_TYPE);\n         case Token.VOID:\n             return getNativeType(VOID_TYPE);\n         case Token.STRING:\n             JSType namedType \u003d getType(scope, n.getString(), sourceName, n.getLineno(), n.getCharno());\n             if (resolveMode !\u003d ResolveMode.LAZY_NAMES) {\n                 namedType \u003d namedType.resolveInternal(reporter, scope);\n             }\n             if ((namedType instanceof ObjectType) \u0026\u0026 !(nonNullableTypeNames.contains(n.getString()))) {\n                 Node typeList \u003d n.getFirstChild();\n                 if (typeList !\u003d null \u0026\u0026 (\"Array\".equals(n.getString()) || \"Object\".equals(n.getString()))) {\n                     JSType parameterType \u003d createFromTypeNodesInternal(typeList.getLastChild(), sourceName, scope);\n                     namedType \u003d new ParameterizedType(this, (ObjectType) namedType, parameterType);\n                     if (typeList.hasMoreThanOneChild()) {\n                         JSType indexType \u003d createFromTypeNodesInternal(typeList.getFirstChild(), sourceName, scope);\n                         namedType \u003d new IndexedType(this, (ObjectType) namedType, indexType);\n                     }\n                 }\n                 return createDefaultObjectUnion(namedType);\n             } else {\n                 return namedType;\n             }\n         case Token.FUNCTION:\n             ObjectType thisType \u003d null;\n             boolean isConstructor \u003d false;\n             Node current \u003d n.getFirstChild();\n             if (current.getType() \u003d\u003d Token.THIS || current.getType() \u003d\u003d Token.NEW) {\n                 Node contextNode \u003d current.getFirstChild();\n                 thisType \u003d ObjectType.cast(createFromTypeNodesInternal(contextNode, sourceName, scope).restrictByNotNullOrUndefined());\n                 if (thisType \u003d\u003d null) {\n-                    reporter.warning(ScriptRuntime.getMessage0(current.getType() \u003d\u003d Token.THIS ? \"msg.jsdoc.function.thisnotobject\" : \"msg.jsdoc.function.newnotobject\"), sourceName, contextNode.getLineno(), \"\", contextNode.getCharno());\n+                    reporter.warning(ScriptRuntime.getMessage0(current.getType() \u003d\u003d Token.THIS ? \"msg.jsdoc.function.thisnotobject\" : \"msg.jsdoc.function.newnotobject\"), sourceName, contextNode.getLineno(), contextNode.getCharno());\n                 }\n                 isConstructor \u003d current.getType() \u003d\u003d Token.NEW;\n                 current \u003d current.getNext();\n             }\n             FunctionParamBuilder paramBuilder \u003d new FunctionParamBuilder(this);\n             if (current.getType() \u003d\u003d Token.LP) {\n                 Node args \u003d current.getFirstChild();\n                 for (Node arg \u003d current.getFirstChild(); arg !\u003d null; arg \u003d arg.getNext()) {\n                     if (arg.getType() \u003d\u003d Token.ELLIPSIS) {\n                         if (arg.getChildCount() \u003d\u003d 0) {\n                             paramBuilder.addVarArgs(getNativeType(UNKNOWN_TYPE));\n                         } else {\n                             paramBuilder.addVarArgs(createFromTypeNodesInternal(arg.getFirstChild(), sourceName, scope));\n                         }\n                     } else {\n                         JSType type \u003d createFromTypeNodesInternal(arg, sourceName, scope);\n                         if (arg.getType() \u003d\u003d Token.EQUALS) {\n                             boolean addSuccess \u003d paramBuilder.addOptionalParams(type);\n                             if (!addSuccess) {\n-                                reporter.warning(ScriptRuntime.getMessage0(\"msg.jsdoc.function.varargs\"), sourceName, arg.getLineno(), \"\", arg.getCharno());\n+                                reporter.warning(ScriptRuntime.getMessage0(\"msg.jsdoc.function.varargs\"), sourceName, arg.getLineno(), arg.getCharno());\n                             }\n                         } else {\n                             paramBuilder.addRequiredParams(type);\n                         }\n                     }\n                 }\n                 current \u003d current.getNext();\n             }\n             JSType returnType \u003d createFromTypeNodesInternal(current, sourceName, scope);\n             return new FunctionBuilder(this).withParams(paramBuilder).withReturnType(returnType).withTypeOfThis(thisType).setIsConstructor(isConstructor).build();\n     }\n     throw new IllegalStateException(\"Unexpected node in type expression: \" + n.toString());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5200a1c2404a424425ab2b04a7a64e08e0ee4925": {
      "type": "Ydocchange",
      "commitMessage": "\nCleanup rhino_ast warnings.\n\nR\u003dacleung\nDELTA\u003d52  (30 added, 2 deleted, 20 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d2828\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1299 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "7/28/11, 2:24 PM",
      "commitName": "5200a1c2404a424425ab2b04a7a64e08e0ee4925",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "7/27/11, 5:39 AM",
      "commitNameOld": "86b3e89e8fb19381c59845539a1c7803ded1303c",
      "commitAuthorOld": "henrywong@google.com",
      "daysBetweenCommits": 1.36,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "private JSType createFromTypeNodesInternal(Node n, String sourceName, StaticScope\u003cJSType\u003e scope) {\n    switch(n.getType()) {\n        case Token.LC:\n            return createRecordTypeFromNodes(n.getFirstChild(), sourceName, scope);\n        case Token.BANG:\n            return createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope).restrictByNotNullOrUndefined();\n        case Token.QMARK:\n            Node firstChild \u003d n.getFirstChild();\n            if (firstChild \u003d\u003d null) {\n                return getNativeType(UNKNOWN_TYPE);\n            }\n            return createDefaultObjectUnion(createFromTypeNodesInternal(firstChild, sourceName, scope));\n        case Token.EQUALS:\n            return createOptionalType(createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope));\n        case Token.ELLIPSIS:\n            return createOptionalType(createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope));\n        case Token.STAR:\n            return getNativeType(ALL_TYPE);\n        case Token.LB:\n            return getNativeType(ARRAY_TYPE);\n        case Token.PIPE:\n            UnionTypeBuilder builder \u003d new UnionTypeBuilder(this);\n            for (Node child \u003d n.getFirstChild(); child !\u003d null; child \u003d child.getNext()) {\n                builder.addAlternate(createFromTypeNodesInternal(child, sourceName, scope));\n            }\n            return builder.build();\n        case Token.EMPTY:\n            return getNativeType(UNKNOWN_TYPE);\n        case Token.VOID:\n            return getNativeType(VOID_TYPE);\n        case Token.STRING:\n            JSType namedType \u003d getType(scope, n.getString(), sourceName, n.getLineno(), n.getCharno());\n            if (resolveMode !\u003d ResolveMode.LAZY_NAMES) {\n                namedType \u003d namedType.resolveInternal(reporter, scope);\n            }\n            if ((namedType instanceof ObjectType) \u0026\u0026 !(nonNullableTypeNames.contains(n.getString()))) {\n                Node typeList \u003d n.getFirstChild();\n                if (typeList !\u003d null \u0026\u0026 (\"Array\".equals(n.getString()) || \"Object\".equals(n.getString()))) {\n                    JSType parameterType \u003d createFromTypeNodesInternal(typeList.getLastChild(), sourceName, scope);\n                    namedType \u003d new ParameterizedType(this, (ObjectType) namedType, parameterType);\n                    if (typeList.hasMoreThanOneChild()) {\n                        JSType indexType \u003d createFromTypeNodesInternal(typeList.getFirstChild(), sourceName, scope);\n                        namedType \u003d new IndexedType(this, (ObjectType) namedType, indexType);\n                    }\n                }\n                return createDefaultObjectUnion(namedType);\n            } else {\n                return namedType;\n            }\n        case Token.FUNCTION:\n            ObjectType thisType \u003d null;\n            boolean isConstructor \u003d false;\n            Node current \u003d n.getFirstChild();\n            if (current.getType() \u003d\u003d Token.THIS || current.getType() \u003d\u003d Token.NEW) {\n                Node contextNode \u003d current.getFirstChild();\n                thisType \u003d ObjectType.cast(createFromTypeNodesInternal(contextNode, sourceName, scope).restrictByNotNullOrUndefined());\n                if (thisType \u003d\u003d null) {\n                    reporter.warning(ScriptRuntime.getMessage0(current.getType() \u003d\u003d Token.THIS ? \"msg.jsdoc.function.thisnotobject\" : \"msg.jsdoc.function.newnotobject\"), sourceName, contextNode.getLineno(), \"\", contextNode.getCharno());\n                }\n                isConstructor \u003d current.getType() \u003d\u003d Token.NEW;\n                current \u003d current.getNext();\n            }\n            FunctionParamBuilder paramBuilder \u003d new FunctionParamBuilder(this);\n            if (current.getType() \u003d\u003d Token.LP) {\n                Node args \u003d current.getFirstChild();\n                for (Node arg \u003d current.getFirstChild(); arg !\u003d null; arg \u003d arg.getNext()) {\n                    if (arg.getType() \u003d\u003d Token.ELLIPSIS) {\n                        if (arg.getChildCount() \u003d\u003d 0) {\n                            paramBuilder.addVarArgs(getNativeType(UNKNOWN_TYPE));\n                        } else {\n                            paramBuilder.addVarArgs(createFromTypeNodesInternal(arg.getFirstChild(), sourceName, scope));\n                        }\n                    } else {\n                        JSType type \u003d createFromTypeNodesInternal(arg, sourceName, scope);\n                        if (arg.getType() \u003d\u003d Token.EQUALS) {\n                            boolean addSuccess \u003d paramBuilder.addOptionalParams(type);\n                            if (!addSuccess) {\n                                reporter.warning(ScriptRuntime.getMessage0(\"msg.jsdoc.function.varargs\"), sourceName, arg.getLineno(), \"\", arg.getCharno());\n                            }\n                        } else {\n                            paramBuilder.addRequiredParams(type);\n                        }\n                    }\n                }\n                current \u003d current.getNext();\n            }\n            JSType returnType \u003d createFromTypeNodesInternal(current, sourceName, scope);\n            return new FunctionBuilder(this).withParams(paramBuilder).withReturnType(returnType).withTypeOfThis(thisType).setIsConstructor(isConstructor).build();\n    }\n    throw new IllegalStateException(\"Unexpected node in type expression: \" + n.toString());\n}",
      "path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
      "functionStartLine": 1374,
      "functionName": "createFromTypeNodesInternal",
      "functionAnnotation": "",
      "functionDoc": "\n@see #createFromTypeNodes(Node, String, StaticScope)\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "\n@see #createFromTypeNodes(Node, String, StaticScope, boolean)\n",
        "newValue": "\n@see #createFromTypeNodes(Node, String, StaticScope)\n"
      }
    },
    "4434b45f18d2e74ec809a9bbeb67571b604ce6d0": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "\nUnforgiven types.\nNow that you can suppress type-parsing warnings by simply turning\noff type checking, we should just get rid of all the old forgiving\nlogic.\n\nR\u003dacleung\nDELTA\u003d128  (5 added, 86 deleted, 37 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d812\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@872 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "3/10/11, 8:26 AM",
      "commitName": "4434b45f18d2e74ec809a9bbeb67571b604ce6d0",
      "commitAuthor": "nicksantos@google.com",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "\nUnforgiven types.\nNow that you can suppress type-parsing warnings by simply turning\noff type checking, we should just get rid of all the old forgiving\nlogic.\n\nR\u003dacleung\nDELTA\u003d128  (5 added, 86 deleted, 37 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d812\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@872 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "3/10/11, 8:26 AM",
          "commitName": "4434b45f18d2e74ec809a9bbeb67571b604ce6d0",
          "commitAuthor": "nicksantos@google.com",
          "commitDateOld": "3/7/11, 5:08 PM",
          "commitNameOld": "f80152eb5a2de72e8336b26e0e78b9e6baae37d2",
          "commitAuthorOld": "nicksantos@google.com",
          "daysBetweenCommits": 2.64,
          "commitsBetweenForRepo": 10,
          "commitsBetweenForFile": 1,
          "actualSource": "private JSType createFromTypeNodesInternal(Node n, String sourceName, StaticScope\u003cJSType\u003e scope) {\n    switch(n.getType()) {\n        case Token.LC:\n            return createRecordTypeFromNodes(n.getFirstChild(), sourceName, scope);\n        case Token.BANG:\n            return createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope).restrictByNotNullOrUndefined();\n        case Token.QMARK:\n            Node firstChild \u003d n.getFirstChild();\n            if (firstChild \u003d\u003d null) {\n                return getNativeType(UNKNOWN_TYPE);\n            }\n            return createDefaultObjectUnion(createFromTypeNodesInternal(firstChild, sourceName, scope));\n        case Token.EQUALS:\n            return createOptionalType(createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope));\n        case Token.ELLIPSIS:\n            return createOptionalType(createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope));\n        case Token.STAR:\n            return getNativeType(ALL_TYPE);\n        case Token.LB:\n            return getNativeType(ARRAY_TYPE);\n        case Token.PIPE:\n            UnionTypeBuilder builder \u003d new UnionTypeBuilder(this);\n            for (Node child \u003d n.getFirstChild(); child !\u003d null; child \u003d child.getNext()) {\n                builder.addAlternate(createFromTypeNodesInternal(child, sourceName, scope));\n            }\n            return builder.build();\n        case Token.EMPTY:\n            return getNativeType(UNKNOWN_TYPE);\n        case Token.VOID:\n            return getNativeType(VOID_TYPE);\n        case Token.STRING:\n            JSType namedType \u003d getType(scope, n.getString(), sourceName, n.getLineno(), n.getCharno());\n            if (resolveMode !\u003d ResolveMode.LAZY_NAMES) {\n                namedType \u003d namedType.resolveInternal(reporter, scope);\n            }\n            if ((namedType instanceof ObjectType) \u0026\u0026 !(nonNullableTypeNames.contains(n.getString()))) {\n                Node typeList \u003d n.getFirstChild();\n                if (typeList !\u003d null \u0026\u0026 (\"Array\".equals(n.getString()) || \"Object\".equals(n.getString()))) {\n                    JSType parameterType \u003d createFromTypeNodesInternal(typeList.getLastChild(), sourceName, scope);\n                    namedType \u003d new ParameterizedType(this, (ObjectType) namedType, parameterType);\n                    if (typeList.hasMoreThanOneChild()) {\n                        JSType indexType \u003d createFromTypeNodesInternal(typeList.getFirstChild(), sourceName, scope);\n                        namedType \u003d new IndexedType(this, (ObjectType) namedType, indexType);\n                    }\n                }\n                return createDefaultObjectUnion(namedType);\n            } else {\n                return namedType;\n            }\n        case Token.FUNCTION:\n            ObjectType thisType \u003d null;\n            boolean isConstructor \u003d false;\n            Node current \u003d n.getFirstChild();\n            if (current.getType() \u003d\u003d Token.THIS || current.getType() \u003d\u003d Token.NEW) {\n                Node contextNode \u003d current.getFirstChild();\n                thisType \u003d ObjectType.cast(createFromTypeNodesInternal(contextNode, sourceName, scope).restrictByNotNullOrUndefined());\n                if (thisType \u003d\u003d null) {\n                    reporter.warning(ScriptRuntime.getMessage0(current.getType() \u003d\u003d Token.THIS ? \"msg.jsdoc.function.thisnotobject\" : \"msg.jsdoc.function.newnotobject\"), sourceName, contextNode.getLineno(), \"\", contextNode.getCharno());\n                }\n                isConstructor \u003d current.getType() \u003d\u003d Token.NEW;\n                current \u003d current.getNext();\n            }\n            FunctionParamBuilder paramBuilder \u003d new FunctionParamBuilder(this);\n            if (current.getType() \u003d\u003d Token.LP) {\n                Node args \u003d current.getFirstChild();\n                for (Node arg \u003d current.getFirstChild(); arg !\u003d null; arg \u003d arg.getNext()) {\n                    if (arg.getType() \u003d\u003d Token.ELLIPSIS) {\n                        if (arg.getChildCount() \u003d\u003d 0) {\n                            paramBuilder.addVarArgs(getNativeType(UNKNOWN_TYPE));\n                        } else {\n                            paramBuilder.addVarArgs(createFromTypeNodesInternal(arg.getFirstChild(), sourceName, scope));\n                        }\n                    } else {\n                        JSType type \u003d createFromTypeNodesInternal(arg, sourceName, scope);\n                        if (arg.getType() \u003d\u003d Token.EQUALS) {\n                            boolean addSuccess \u003d paramBuilder.addOptionalParams(type);\n                            if (!addSuccess) {\n                                reporter.warning(ScriptRuntime.getMessage0(\"msg.jsdoc.function.varargs\"), sourceName, arg.getLineno(), \"\", arg.getCharno());\n                            }\n                        } else {\n                            paramBuilder.addRequiredParams(type);\n                        }\n                    }\n                }\n                current \u003d current.getNext();\n            }\n            JSType returnType \u003d createFromTypeNodesInternal(current, sourceName, scope);\n            return new FunctionBuilder(this).withParams(paramBuilder).withReturnType(returnType).withTypeOfThis(thisType).setIsConstructor(isConstructor).build();\n    }\n    throw new IllegalStateException(\"Unexpected node in type expression: \" + n.toString());\n}",
          "path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
          "functionStartLine": 1365,
          "functionName": "createFromTypeNodesInternal",
          "functionAnnotation": "",
          "functionDoc": "\n@see #createFromTypeNodes(Node, String, StaticScope, boolean)\n",
          "diff": "@@ -1,94 +1,91 @@\n-private JSType createFromTypeNodesInternal(Node n, String sourceName, StaticScope\u003cJSType\u003e scope, boolean forgiving) {\n+private JSType createFromTypeNodesInternal(Node n, String sourceName, StaticScope\u003cJSType\u003e scope) {\n     switch(n.getType()) {\n         case Token.LC:\n             return createRecordTypeFromNodes(n.getFirstChild(), sourceName, scope);\n         case Token.BANG:\n-            return createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope, forgiving).restrictByNotNullOrUndefined();\n+            return createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope).restrictByNotNullOrUndefined();\n         case Token.QMARK:\n             Node firstChild \u003d n.getFirstChild();\n             if (firstChild \u003d\u003d null) {\n                 return getNativeType(UNKNOWN_TYPE);\n             }\n-            return createDefaultObjectUnion(createFromTypeNodesInternal(firstChild, sourceName, scope, forgiving));\n+            return createDefaultObjectUnion(createFromTypeNodesInternal(firstChild, sourceName, scope));\n         case Token.EQUALS:\n-            return createOptionalType(createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope, false));\n+            return createOptionalType(createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope));\n         case Token.ELLIPSIS:\n-            return createOptionalType(createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope, false));\n+            return createOptionalType(createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope));\n         case Token.STAR:\n             return getNativeType(ALL_TYPE);\n         case Token.LB:\n             return getNativeType(ARRAY_TYPE);\n         case Token.PIPE:\n             UnionTypeBuilder builder \u003d new UnionTypeBuilder(this);\n             for (Node child \u003d n.getFirstChild(); child !\u003d null; child \u003d child.getNext()) {\n-                builder.addAlternate(createFromTypeNodesInternal(child, sourceName, scope, false));\n+                builder.addAlternate(createFromTypeNodesInternal(child, sourceName, scope));\n             }\n             return builder.build();\n         case Token.EMPTY:\n             return getNativeType(UNKNOWN_TYPE);\n         case Token.VOID:\n             return getNativeType(VOID_TYPE);\n         case Token.STRING:\n             JSType namedType \u003d getType(scope, n.getString(), sourceName, n.getLineno(), n.getCharno());\n-            if (forgiving) {\n-                namedType.forgiveUnknownNames();\n-            }\n             if (resolveMode !\u003d ResolveMode.LAZY_NAMES) {\n                 namedType \u003d namedType.resolveInternal(reporter, scope);\n             }\n             if ((namedType instanceof ObjectType) \u0026\u0026 !(nonNullableTypeNames.contains(n.getString()))) {\n                 Node typeList \u003d n.getFirstChild();\n                 if (typeList !\u003d null \u0026\u0026 (\"Array\".equals(n.getString()) || \"Object\".equals(n.getString()))) {\n-                    JSType parameterType \u003d createFromTypeNodesInternal(typeList.getLastChild(), sourceName, scope, false);\n+                    JSType parameterType \u003d createFromTypeNodesInternal(typeList.getLastChild(), sourceName, scope);\n                     namedType \u003d new ParameterizedType(this, (ObjectType) namedType, parameterType);\n                     if (typeList.hasMoreThanOneChild()) {\n-                        JSType indexType \u003d createFromTypeNodesInternal(typeList.getFirstChild(), sourceName, scope, false);\n+                        JSType indexType \u003d createFromTypeNodesInternal(typeList.getFirstChild(), sourceName, scope);\n                         namedType \u003d new IndexedType(this, (ObjectType) namedType, indexType);\n                     }\n                 }\n                 return createDefaultObjectUnion(namedType);\n             } else {\n                 return namedType;\n             }\n         case Token.FUNCTION:\n             ObjectType thisType \u003d null;\n             boolean isConstructor \u003d false;\n             Node current \u003d n.getFirstChild();\n             if (current.getType() \u003d\u003d Token.THIS || current.getType() \u003d\u003d Token.NEW) {\n                 Node contextNode \u003d current.getFirstChild();\n-                thisType \u003d ObjectType.cast(createFromTypeNodesInternal(contextNode, sourceName, scope, false).restrictByNotNullOrUndefined());\n+                thisType \u003d ObjectType.cast(createFromTypeNodesInternal(contextNode, sourceName, scope).restrictByNotNullOrUndefined());\n                 if (thisType \u003d\u003d null) {\n                     reporter.warning(ScriptRuntime.getMessage0(current.getType() \u003d\u003d Token.THIS ? \"msg.jsdoc.function.thisnotobject\" : \"msg.jsdoc.function.newnotobject\"), sourceName, contextNode.getLineno(), \"\", contextNode.getCharno());\n                 }\n                 isConstructor \u003d current.getType() \u003d\u003d Token.NEW;\n                 current \u003d current.getNext();\n             }\n             FunctionParamBuilder paramBuilder \u003d new FunctionParamBuilder(this);\n             if (current.getType() \u003d\u003d Token.LP) {\n                 Node args \u003d current.getFirstChild();\n                 for (Node arg \u003d current.getFirstChild(); arg !\u003d null; arg \u003d arg.getNext()) {\n                     if (arg.getType() \u003d\u003d Token.ELLIPSIS) {\n                         if (arg.getChildCount() \u003d\u003d 0) {\n                             paramBuilder.addVarArgs(getNativeType(UNKNOWN_TYPE));\n                         } else {\n-                            paramBuilder.addVarArgs(createFromTypeNodesInternal(arg.getFirstChild(), sourceName, scope, false));\n+                            paramBuilder.addVarArgs(createFromTypeNodesInternal(arg.getFirstChild(), sourceName, scope));\n                         }\n                     } else {\n-                        JSType type \u003d createFromTypeNodesInternal(arg, sourceName, scope, false);\n+                        JSType type \u003d createFromTypeNodesInternal(arg, sourceName, scope);\n                         if (arg.getType() \u003d\u003d Token.EQUALS) {\n                             boolean addSuccess \u003d paramBuilder.addOptionalParams(type);\n                             if (!addSuccess) {\n                                 reporter.warning(ScriptRuntime.getMessage0(\"msg.jsdoc.function.varargs\"), sourceName, arg.getLineno(), \"\", arg.getCharno());\n                             }\n                         } else {\n                             paramBuilder.addRequiredParams(type);\n                         }\n                     }\n                 }\n                 current \u003d current.getNext();\n             }\n-            JSType returnType \u003d createFromTypeNodesInternal(current, sourceName, scope, false);\n+            JSType returnType \u003d createFromTypeNodesInternal(current, sourceName, scope);\n             return new FunctionBuilder(this).withParams(paramBuilder).withReturnType(returnType).withTypeOfThis(thisType).setIsConstructor(isConstructor).build();\n     }\n     throw new IllegalStateException(\"Unexpected node in type expression: \" + n.toString());\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[n-Node, sourceName-String, scope-StaticScope\u003cJSType\u003e, forgiving-boolean]",
            "newValue": "[n-Node, sourceName-String, scope-StaticScope\u003cJSType\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "\nUnforgiven types.\nNow that you can suppress type-parsing warnings by simply turning\noff type checking, we should just get rid of all the old forgiving\nlogic.\n\nR\u003dacleung\nDELTA\u003d128  (5 added, 86 deleted, 37 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d812\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@872 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "3/10/11, 8:26 AM",
          "commitName": "4434b45f18d2e74ec809a9bbeb67571b604ce6d0",
          "commitAuthor": "nicksantos@google.com",
          "commitDateOld": "3/7/11, 5:08 PM",
          "commitNameOld": "f80152eb5a2de72e8336b26e0e78b9e6baae37d2",
          "commitAuthorOld": "nicksantos@google.com",
          "daysBetweenCommits": 2.64,
          "commitsBetweenForRepo": 10,
          "commitsBetweenForFile": 1,
          "actualSource": "private JSType createFromTypeNodesInternal(Node n, String sourceName, StaticScope\u003cJSType\u003e scope) {\n    switch(n.getType()) {\n        case Token.LC:\n            return createRecordTypeFromNodes(n.getFirstChild(), sourceName, scope);\n        case Token.BANG:\n            return createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope).restrictByNotNullOrUndefined();\n        case Token.QMARK:\n            Node firstChild \u003d n.getFirstChild();\n            if (firstChild \u003d\u003d null) {\n                return getNativeType(UNKNOWN_TYPE);\n            }\n            return createDefaultObjectUnion(createFromTypeNodesInternal(firstChild, sourceName, scope));\n        case Token.EQUALS:\n            return createOptionalType(createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope));\n        case Token.ELLIPSIS:\n            return createOptionalType(createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope));\n        case Token.STAR:\n            return getNativeType(ALL_TYPE);\n        case Token.LB:\n            return getNativeType(ARRAY_TYPE);\n        case Token.PIPE:\n            UnionTypeBuilder builder \u003d new UnionTypeBuilder(this);\n            for (Node child \u003d n.getFirstChild(); child !\u003d null; child \u003d child.getNext()) {\n                builder.addAlternate(createFromTypeNodesInternal(child, sourceName, scope));\n            }\n            return builder.build();\n        case Token.EMPTY:\n            return getNativeType(UNKNOWN_TYPE);\n        case Token.VOID:\n            return getNativeType(VOID_TYPE);\n        case Token.STRING:\n            JSType namedType \u003d getType(scope, n.getString(), sourceName, n.getLineno(), n.getCharno());\n            if (resolveMode !\u003d ResolveMode.LAZY_NAMES) {\n                namedType \u003d namedType.resolveInternal(reporter, scope);\n            }\n            if ((namedType instanceof ObjectType) \u0026\u0026 !(nonNullableTypeNames.contains(n.getString()))) {\n                Node typeList \u003d n.getFirstChild();\n                if (typeList !\u003d null \u0026\u0026 (\"Array\".equals(n.getString()) || \"Object\".equals(n.getString()))) {\n                    JSType parameterType \u003d createFromTypeNodesInternal(typeList.getLastChild(), sourceName, scope);\n                    namedType \u003d new ParameterizedType(this, (ObjectType) namedType, parameterType);\n                    if (typeList.hasMoreThanOneChild()) {\n                        JSType indexType \u003d createFromTypeNodesInternal(typeList.getFirstChild(), sourceName, scope);\n                        namedType \u003d new IndexedType(this, (ObjectType) namedType, indexType);\n                    }\n                }\n                return createDefaultObjectUnion(namedType);\n            } else {\n                return namedType;\n            }\n        case Token.FUNCTION:\n            ObjectType thisType \u003d null;\n            boolean isConstructor \u003d false;\n            Node current \u003d n.getFirstChild();\n            if (current.getType() \u003d\u003d Token.THIS || current.getType() \u003d\u003d Token.NEW) {\n                Node contextNode \u003d current.getFirstChild();\n                thisType \u003d ObjectType.cast(createFromTypeNodesInternal(contextNode, sourceName, scope).restrictByNotNullOrUndefined());\n                if (thisType \u003d\u003d null) {\n                    reporter.warning(ScriptRuntime.getMessage0(current.getType() \u003d\u003d Token.THIS ? \"msg.jsdoc.function.thisnotobject\" : \"msg.jsdoc.function.newnotobject\"), sourceName, contextNode.getLineno(), \"\", contextNode.getCharno());\n                }\n                isConstructor \u003d current.getType() \u003d\u003d Token.NEW;\n                current \u003d current.getNext();\n            }\n            FunctionParamBuilder paramBuilder \u003d new FunctionParamBuilder(this);\n            if (current.getType() \u003d\u003d Token.LP) {\n                Node args \u003d current.getFirstChild();\n                for (Node arg \u003d current.getFirstChild(); arg !\u003d null; arg \u003d arg.getNext()) {\n                    if (arg.getType() \u003d\u003d Token.ELLIPSIS) {\n                        if (arg.getChildCount() \u003d\u003d 0) {\n                            paramBuilder.addVarArgs(getNativeType(UNKNOWN_TYPE));\n                        } else {\n                            paramBuilder.addVarArgs(createFromTypeNodesInternal(arg.getFirstChild(), sourceName, scope));\n                        }\n                    } else {\n                        JSType type \u003d createFromTypeNodesInternal(arg, sourceName, scope);\n                        if (arg.getType() \u003d\u003d Token.EQUALS) {\n                            boolean addSuccess \u003d paramBuilder.addOptionalParams(type);\n                            if (!addSuccess) {\n                                reporter.warning(ScriptRuntime.getMessage0(\"msg.jsdoc.function.varargs\"), sourceName, arg.getLineno(), \"\", arg.getCharno());\n                            }\n                        } else {\n                            paramBuilder.addRequiredParams(type);\n                        }\n                    }\n                }\n                current \u003d current.getNext();\n            }\n            JSType returnType \u003d createFromTypeNodesInternal(current, sourceName, scope);\n            return new FunctionBuilder(this).withParams(paramBuilder).withReturnType(returnType).withTypeOfThis(thisType).setIsConstructor(isConstructor).build();\n    }\n    throw new IllegalStateException(\"Unexpected node in type expression: \" + n.toString());\n}",
          "path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
          "functionStartLine": 1365,
          "functionName": "createFromTypeNodesInternal",
          "functionAnnotation": "",
          "functionDoc": "\n@see #createFromTypeNodes(Node, String, StaticScope, boolean)\n",
          "diff": "@@ -1,94 +1,91 @@\n-private JSType createFromTypeNodesInternal(Node n, String sourceName, StaticScope\u003cJSType\u003e scope, boolean forgiving) {\n+private JSType createFromTypeNodesInternal(Node n, String sourceName, StaticScope\u003cJSType\u003e scope) {\n     switch(n.getType()) {\n         case Token.LC:\n             return createRecordTypeFromNodes(n.getFirstChild(), sourceName, scope);\n         case Token.BANG:\n-            return createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope, forgiving).restrictByNotNullOrUndefined();\n+            return createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope).restrictByNotNullOrUndefined();\n         case Token.QMARK:\n             Node firstChild \u003d n.getFirstChild();\n             if (firstChild \u003d\u003d null) {\n                 return getNativeType(UNKNOWN_TYPE);\n             }\n-            return createDefaultObjectUnion(createFromTypeNodesInternal(firstChild, sourceName, scope, forgiving));\n+            return createDefaultObjectUnion(createFromTypeNodesInternal(firstChild, sourceName, scope));\n         case Token.EQUALS:\n-            return createOptionalType(createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope, false));\n+            return createOptionalType(createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope));\n         case Token.ELLIPSIS:\n-            return createOptionalType(createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope, false));\n+            return createOptionalType(createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope));\n         case Token.STAR:\n             return getNativeType(ALL_TYPE);\n         case Token.LB:\n             return getNativeType(ARRAY_TYPE);\n         case Token.PIPE:\n             UnionTypeBuilder builder \u003d new UnionTypeBuilder(this);\n             for (Node child \u003d n.getFirstChild(); child !\u003d null; child \u003d child.getNext()) {\n-                builder.addAlternate(createFromTypeNodesInternal(child, sourceName, scope, false));\n+                builder.addAlternate(createFromTypeNodesInternal(child, sourceName, scope));\n             }\n             return builder.build();\n         case Token.EMPTY:\n             return getNativeType(UNKNOWN_TYPE);\n         case Token.VOID:\n             return getNativeType(VOID_TYPE);\n         case Token.STRING:\n             JSType namedType \u003d getType(scope, n.getString(), sourceName, n.getLineno(), n.getCharno());\n-            if (forgiving) {\n-                namedType.forgiveUnknownNames();\n-            }\n             if (resolveMode !\u003d ResolveMode.LAZY_NAMES) {\n                 namedType \u003d namedType.resolveInternal(reporter, scope);\n             }\n             if ((namedType instanceof ObjectType) \u0026\u0026 !(nonNullableTypeNames.contains(n.getString()))) {\n                 Node typeList \u003d n.getFirstChild();\n                 if (typeList !\u003d null \u0026\u0026 (\"Array\".equals(n.getString()) || \"Object\".equals(n.getString()))) {\n-                    JSType parameterType \u003d createFromTypeNodesInternal(typeList.getLastChild(), sourceName, scope, false);\n+                    JSType parameterType \u003d createFromTypeNodesInternal(typeList.getLastChild(), sourceName, scope);\n                     namedType \u003d new ParameterizedType(this, (ObjectType) namedType, parameterType);\n                     if (typeList.hasMoreThanOneChild()) {\n-                        JSType indexType \u003d createFromTypeNodesInternal(typeList.getFirstChild(), sourceName, scope, false);\n+                        JSType indexType \u003d createFromTypeNodesInternal(typeList.getFirstChild(), sourceName, scope);\n                         namedType \u003d new IndexedType(this, (ObjectType) namedType, indexType);\n                     }\n                 }\n                 return createDefaultObjectUnion(namedType);\n             } else {\n                 return namedType;\n             }\n         case Token.FUNCTION:\n             ObjectType thisType \u003d null;\n             boolean isConstructor \u003d false;\n             Node current \u003d n.getFirstChild();\n             if (current.getType() \u003d\u003d Token.THIS || current.getType() \u003d\u003d Token.NEW) {\n                 Node contextNode \u003d current.getFirstChild();\n-                thisType \u003d ObjectType.cast(createFromTypeNodesInternal(contextNode, sourceName, scope, false).restrictByNotNullOrUndefined());\n+                thisType \u003d ObjectType.cast(createFromTypeNodesInternal(contextNode, sourceName, scope).restrictByNotNullOrUndefined());\n                 if (thisType \u003d\u003d null) {\n                     reporter.warning(ScriptRuntime.getMessage0(current.getType() \u003d\u003d Token.THIS ? \"msg.jsdoc.function.thisnotobject\" : \"msg.jsdoc.function.newnotobject\"), sourceName, contextNode.getLineno(), \"\", contextNode.getCharno());\n                 }\n                 isConstructor \u003d current.getType() \u003d\u003d Token.NEW;\n                 current \u003d current.getNext();\n             }\n             FunctionParamBuilder paramBuilder \u003d new FunctionParamBuilder(this);\n             if (current.getType() \u003d\u003d Token.LP) {\n                 Node args \u003d current.getFirstChild();\n                 for (Node arg \u003d current.getFirstChild(); arg !\u003d null; arg \u003d arg.getNext()) {\n                     if (arg.getType() \u003d\u003d Token.ELLIPSIS) {\n                         if (arg.getChildCount() \u003d\u003d 0) {\n                             paramBuilder.addVarArgs(getNativeType(UNKNOWN_TYPE));\n                         } else {\n-                            paramBuilder.addVarArgs(createFromTypeNodesInternal(arg.getFirstChild(), sourceName, scope, false));\n+                            paramBuilder.addVarArgs(createFromTypeNodesInternal(arg.getFirstChild(), sourceName, scope));\n                         }\n                     } else {\n-                        JSType type \u003d createFromTypeNodesInternal(arg, sourceName, scope, false);\n+                        JSType type \u003d createFromTypeNodesInternal(arg, sourceName, scope);\n                         if (arg.getType() \u003d\u003d Token.EQUALS) {\n                             boolean addSuccess \u003d paramBuilder.addOptionalParams(type);\n                             if (!addSuccess) {\n                                 reporter.warning(ScriptRuntime.getMessage0(\"msg.jsdoc.function.varargs\"), sourceName, arg.getLineno(), \"\", arg.getCharno());\n                             }\n                         } else {\n                             paramBuilder.addRequiredParams(type);\n                         }\n                     }\n                 }\n                 current \u003d current.getNext();\n             }\n-            JSType returnType \u003d createFromTypeNodesInternal(current, sourceName, scope, false);\n+            JSType returnType \u003d createFromTypeNodesInternal(current, sourceName, scope);\n             return new FunctionBuilder(this).withParams(paramBuilder).withReturnType(returnType).withTypeOfThis(thisType).setIsConstructor(isConstructor).build();\n     }\n     throw new IllegalStateException(\"Unexpected node in type expression: \" + n.toString());\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "e9f7e6114414f68deb90f4116861d7a054365404": {
      "type": "Ybodychange",
      "commitMessage": "\nAdd a syntax for constructors\n{function(new:Type)}\nfixes issue 281\n\nR\u003djschorr\nDELTA\u003d199  (73 added, 4 deleted, 122 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d133\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@630 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "12/14/10, 1:49 PM",
      "commitName": "e9f7e6114414f68deb90f4116861d7a054365404",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "12/13/10, 8:10 AM",
      "commitNameOld": "1c75a5484b515bd593295fbf0c8491e2dd1f1c45",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 1.24,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "actualSource": "private JSType createFromTypeNodesInternal(Node n, String sourceName, StaticScope\u003cJSType\u003e scope, boolean forgiving) {\n    switch(n.getType()) {\n        case Token.LC:\n            return createRecordTypeFromNodes(n.getFirstChild(), sourceName, scope);\n        case Token.BANG:\n            return createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope, forgiving).restrictByNotNullOrUndefined();\n        case Token.QMARK:\n            Node firstChild \u003d n.getFirstChild();\n            if (firstChild \u003d\u003d null) {\n                return getNativeType(UNKNOWN_TYPE);\n            }\n            return createDefaultObjectUnion(createFromTypeNodesInternal(firstChild, sourceName, scope, forgiving));\n        case Token.EQUALS:\n            return createOptionalType(createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope, false));\n        case Token.ELLIPSIS:\n            return createOptionalType(createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope, false));\n        case Token.STAR:\n            return getNativeType(ALL_TYPE);\n        case Token.LB:\n            return getNativeType(ARRAY_TYPE);\n        case Token.PIPE:\n            UnionTypeBuilder builder \u003d new UnionTypeBuilder(this);\n            for (Node child \u003d n.getFirstChild(); child !\u003d null; child \u003d child.getNext()) {\n                builder.addAlternate(createFromTypeNodesInternal(child, sourceName, scope, false));\n            }\n            return builder.build();\n        case Token.EMPTY:\n            return getNativeType(UNKNOWN_TYPE);\n        case Token.VOID:\n            return getNativeType(VOID_TYPE);\n        case Token.STRING:\n            JSType namedType \u003d getType(scope, n.getString(), sourceName, n.getLineno(), n.getCharno());\n            if (forgiving) {\n                namedType.forgiveUnknownNames();\n            }\n            if (resolveMode !\u003d ResolveMode.LAZY_NAMES) {\n                namedType \u003d namedType.resolveInternal(reporter, scope);\n            }\n            if ((namedType instanceof ObjectType) \u0026\u0026 !(nonNullableTypeNames.contains(n.getString()))) {\n                Node typeList \u003d n.getFirstChild();\n                if (typeList !\u003d null \u0026\u0026 (\"Array\".equals(n.getString()) || \"Object\".equals(n.getString()))) {\n                    JSType parameterType \u003d createFromTypeNodesInternal(typeList.getLastChild(), sourceName, scope, false);\n                    namedType \u003d new ParameterizedType(this, (ObjectType) namedType, parameterType);\n                    if (typeList.hasMoreThanOneChild()) {\n                        JSType indexType \u003d createFromTypeNodesInternal(typeList.getFirstChild(), sourceName, scope, false);\n                        namedType \u003d new IndexedType(this, (ObjectType) namedType, indexType);\n                    }\n                }\n                return createDefaultObjectUnion(namedType);\n            } else {\n                return namedType;\n            }\n        case Token.FUNCTION:\n            ObjectType thisType \u003d null;\n            boolean isConstructor \u003d false;\n            Node current \u003d n.getFirstChild();\n            if (current.getType() \u003d\u003d Token.THIS || current.getType() \u003d\u003d Token.NEW) {\n                Node contextNode \u003d current.getFirstChild();\n                thisType \u003d ObjectType.cast(createFromTypeNodesInternal(contextNode, sourceName, scope, false).restrictByNotNullOrUndefined());\n                if (thisType \u003d\u003d null) {\n                    reporter.warning(ScriptRuntime.getMessage0(current.getType() \u003d\u003d Token.THIS ? \"msg.jsdoc.function.thisnotobject\" : \"msg.jsdoc.function.newnotobject\"), sourceName, contextNode.getLineno(), \"\", contextNode.getCharno());\n                }\n                isConstructor \u003d current.getType() \u003d\u003d Token.NEW;\n                current \u003d current.getNext();\n            }\n            FunctionParamBuilder paramBuilder \u003d new FunctionParamBuilder(this);\n            if (current.getType() \u003d\u003d Token.LP) {\n                Node args \u003d current.getFirstChild();\n                for (Node arg \u003d current.getFirstChild(); arg !\u003d null; arg \u003d arg.getNext()) {\n                    if (arg.getType() \u003d\u003d Token.ELLIPSIS) {\n                        if (arg.getChildCount() \u003d\u003d 0) {\n                            paramBuilder.addVarArgs(getNativeType(UNKNOWN_TYPE));\n                        } else {\n                            paramBuilder.addVarArgs(createFromTypeNodesInternal(arg.getFirstChild(), sourceName, scope, false));\n                        }\n                    } else {\n                        JSType type \u003d createFromTypeNodesInternal(arg, sourceName, scope, false);\n                        if (arg.getType() \u003d\u003d Token.EQUALS) {\n                            boolean addSuccess \u003d paramBuilder.addOptionalParams(type);\n                            if (!addSuccess) {\n                                reporter.warning(ScriptRuntime.getMessage0(\"msg.jsdoc.function.varargs\"), sourceName, arg.getLineno(), \"\", arg.getCharno());\n                            }\n                        } else {\n                            paramBuilder.addRequiredParams(type);\n                        }\n                    }\n                }\n                current \u003d current.getNext();\n            }\n            JSType returnType \u003d createFromTypeNodesInternal(current, sourceName, scope, false);\n            return new FunctionBuilder(this).withParams(paramBuilder).withReturnType(returnType).withTypeOfThis(thisType).setIsConstructor(isConstructor).build();\n    }\n    throw new IllegalStateException(\"Unexpected node in type expression: \" + n.toString());\n}",
      "path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
      "functionStartLine": 1371,
      "functionName": "createFromTypeNodesInternal",
      "functionAnnotation": "",
      "functionDoc": "\n@see #createFromTypeNodes(Node, String, StaticScope, boolean)\n",
      "diff": "@@ -1,92 +1,94 @@\n private JSType createFromTypeNodesInternal(Node n, String sourceName, StaticScope\u003cJSType\u003e scope, boolean forgiving) {\n     switch(n.getType()) {\n         case Token.LC:\n             return createRecordTypeFromNodes(n.getFirstChild(), sourceName, scope);\n         case Token.BANG:\n             return createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope, forgiving).restrictByNotNullOrUndefined();\n         case Token.QMARK:\n             Node firstChild \u003d n.getFirstChild();\n             if (firstChild \u003d\u003d null) {\n                 return getNativeType(UNKNOWN_TYPE);\n             }\n             return createDefaultObjectUnion(createFromTypeNodesInternal(firstChild, sourceName, scope, forgiving));\n         case Token.EQUALS:\n             return createOptionalType(createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope, false));\n         case Token.ELLIPSIS:\n             return createOptionalType(createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope, false));\n         case Token.STAR:\n             return getNativeType(ALL_TYPE);\n         case Token.LB:\n             return getNativeType(ARRAY_TYPE);\n         case Token.PIPE:\n             UnionTypeBuilder builder \u003d new UnionTypeBuilder(this);\n             for (Node child \u003d n.getFirstChild(); child !\u003d null; child \u003d child.getNext()) {\n                 builder.addAlternate(createFromTypeNodesInternal(child, sourceName, scope, false));\n             }\n             return builder.build();\n         case Token.EMPTY:\n             return getNativeType(UNKNOWN_TYPE);\n         case Token.VOID:\n             return getNativeType(VOID_TYPE);\n         case Token.STRING:\n             JSType namedType \u003d getType(scope, n.getString(), sourceName, n.getLineno(), n.getCharno());\n             if (forgiving) {\n                 namedType.forgiveUnknownNames();\n             }\n             if (resolveMode !\u003d ResolveMode.LAZY_NAMES) {\n                 namedType \u003d namedType.resolveInternal(reporter, scope);\n             }\n             if ((namedType instanceof ObjectType) \u0026\u0026 !(nonNullableTypeNames.contains(n.getString()))) {\n                 Node typeList \u003d n.getFirstChild();\n                 if (typeList !\u003d null \u0026\u0026 (\"Array\".equals(n.getString()) || \"Object\".equals(n.getString()))) {\n                     JSType parameterType \u003d createFromTypeNodesInternal(typeList.getLastChild(), sourceName, scope, false);\n                     namedType \u003d new ParameterizedType(this, (ObjectType) namedType, parameterType);\n                     if (typeList.hasMoreThanOneChild()) {\n                         JSType indexType \u003d createFromTypeNodesInternal(typeList.getFirstChild(), sourceName, scope, false);\n                         namedType \u003d new IndexedType(this, (ObjectType) namedType, indexType);\n                     }\n                 }\n                 return createDefaultObjectUnion(namedType);\n             } else {\n                 return namedType;\n             }\n         case Token.FUNCTION:\n             ObjectType thisType \u003d null;\n+            boolean isConstructor \u003d false;\n             Node current \u003d n.getFirstChild();\n-            if (current.getType() \u003d\u003d Token.THIS) {\n-                Node thisNode \u003d current.getFirstChild();\n-                thisType \u003d ObjectType.cast(createFromTypeNodesInternal(thisNode, sourceName, scope, false).restrictByNotNullOrUndefined());\n+            if (current.getType() \u003d\u003d Token.THIS || current.getType() \u003d\u003d Token.NEW) {\n+                Node contextNode \u003d current.getFirstChild();\n+                thisType \u003d ObjectType.cast(createFromTypeNodesInternal(contextNode, sourceName, scope, false).restrictByNotNullOrUndefined());\n                 if (thisType \u003d\u003d null) {\n-                    reporter.warning(ScriptRuntime.getMessage0(\"msg.jsdoc.function.thisnotobject\"), sourceName, thisNode.getLineno(), \"\", thisNode.getCharno());\n+                    reporter.warning(ScriptRuntime.getMessage0(current.getType() \u003d\u003d Token.THIS ? \"msg.jsdoc.function.thisnotobject\" : \"msg.jsdoc.function.newnotobject\"), sourceName, contextNode.getLineno(), \"\", contextNode.getCharno());\n                 }\n+                isConstructor \u003d current.getType() \u003d\u003d Token.NEW;\n                 current \u003d current.getNext();\n             }\n             FunctionParamBuilder paramBuilder \u003d new FunctionParamBuilder(this);\n             if (current.getType() \u003d\u003d Token.LP) {\n                 Node args \u003d current.getFirstChild();\n                 for (Node arg \u003d current.getFirstChild(); arg !\u003d null; arg \u003d arg.getNext()) {\n                     if (arg.getType() \u003d\u003d Token.ELLIPSIS) {\n                         if (arg.getChildCount() \u003d\u003d 0) {\n                             paramBuilder.addVarArgs(getNativeType(UNKNOWN_TYPE));\n                         } else {\n                             paramBuilder.addVarArgs(createFromTypeNodesInternal(arg.getFirstChild(), sourceName, scope, false));\n                         }\n                     } else {\n                         JSType type \u003d createFromTypeNodesInternal(arg, sourceName, scope, false);\n                         if (arg.getType() \u003d\u003d Token.EQUALS) {\n                             boolean addSuccess \u003d paramBuilder.addOptionalParams(type);\n                             if (!addSuccess) {\n                                 reporter.warning(ScriptRuntime.getMessage0(\"msg.jsdoc.function.varargs\"), sourceName, arg.getLineno(), \"\", arg.getCharno());\n                             }\n                         } else {\n                             paramBuilder.addRequiredParams(type);\n                         }\n                     }\n                 }\n                 current \u003d current.getNext();\n             }\n             JSType returnType \u003d createFromTypeNodesInternal(current, sourceName, scope, false);\n-            return new FunctionBuilder(this).withParams(paramBuilder).withReturnType(returnType).withTypeOfThis(thisType).build();\n+            return new FunctionBuilder(this).withParams(paramBuilder).withReturnType(returnType).withTypeOfThis(thisType).setIsConstructor(isConstructor).build();\n     }\n     throw new IllegalStateException(\"Unexpected node in type expression: \" + n.toString());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3698fee71e3671171c587f932795a8ab8e852cd8": {
      "type": "Ybodychange",
      "commitMessage": "\nwhen deciding whether named types are nullable, let enums and\ntypedefs share the same hacky logic.\n\nR\u003djohnlenz\nDELTA\u003d83  (57 added, 0 deleted, 26 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d804008\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@520 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "10/28/10, 8:31 AM",
      "commitName": "3698fee71e3671171c587f932795a8ab8e852cd8",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "10/27/10, 9:43 AM",
      "commitNameOld": "3faef1d4959a55ebd86a09cd5395afb54ab5ec25",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 0.95,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "private JSType createFromTypeNodesInternal(Node n, String sourceName, StaticScope\u003cJSType\u003e scope, boolean forgiving) {\n    switch(n.getType()) {\n        case Token.LC:\n            return createRecordTypeFromNodes(n.getFirstChild(), sourceName, scope);\n        case Token.BANG:\n            return createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope, forgiving).restrictByNotNullOrUndefined();\n        case Token.QMARK:\n            Node firstChild \u003d n.getFirstChild();\n            if (firstChild \u003d\u003d null) {\n                return getNativeType(UNKNOWN_TYPE);\n            }\n            return createDefaultObjectUnion(createFromTypeNodesInternal(firstChild, sourceName, scope, forgiving));\n        case Token.EQUALS:\n            return createOptionalType(createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope, false));\n        case Token.ELLIPSIS:\n            return createOptionalType(createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope, false));\n        case Token.STAR:\n            return getNativeType(ALL_TYPE);\n        case Token.LB:\n            return getNativeType(ARRAY_TYPE);\n        case Token.PIPE:\n            UnionTypeBuilder builder \u003d new UnionTypeBuilder(this);\n            for (Node child \u003d n.getFirstChild(); child !\u003d null; child \u003d child.getNext()) {\n                builder.addAlternate(createFromTypeNodesInternal(child, sourceName, scope, false));\n            }\n            return builder.build();\n        case Token.EMPTY:\n            return getNativeType(UNKNOWN_TYPE);\n        case Token.VOID:\n            return getNativeType(VOID_TYPE);\n        case Token.STRING:\n            JSType namedType \u003d getType(scope, n.getString(), sourceName, n.getLineno(), n.getCharno());\n            if (forgiving) {\n                namedType.forgiveUnknownNames();\n            }\n            if (resolveMode !\u003d ResolveMode.LAZY_NAMES) {\n                namedType \u003d namedType.resolveInternal(reporter, scope);\n            }\n            if ((namedType instanceof ObjectType) \u0026\u0026 !(nonNullableTypeNames.contains(n.getString()))) {\n                Node typeList \u003d n.getFirstChild();\n                if (typeList !\u003d null \u0026\u0026 (\"Array\".equals(n.getString()) || \"Object\".equals(n.getString()))) {\n                    JSType parameterType \u003d createFromTypeNodesInternal(typeList.getLastChild(), sourceName, scope, false);\n                    namedType \u003d new ParameterizedType(this, (ObjectType) namedType, parameterType);\n                    if (typeList.hasMoreThanOneChild()) {\n                        JSType indexType \u003d createFromTypeNodesInternal(typeList.getFirstChild(), sourceName, scope, false);\n                        namedType \u003d new IndexedType(this, (ObjectType) namedType, indexType);\n                    }\n                }\n                return createDefaultObjectUnion(namedType);\n            } else {\n                return namedType;\n            }\n        case Token.FUNCTION:\n            ObjectType thisType \u003d null;\n            Node current \u003d n.getFirstChild();\n            if (current.getType() \u003d\u003d Token.THIS) {\n                Node thisNode \u003d current.getFirstChild();\n                thisType \u003d ObjectType.cast(createFromTypeNodesInternal(thisNode, sourceName, scope, false).restrictByNotNullOrUndefined());\n                if (thisType \u003d\u003d null) {\n                    reporter.warning(ScriptRuntime.getMessage0(\"msg.jsdoc.function.thisnotobject\"), sourceName, thisNode.getLineno(), \"\", thisNode.getCharno());\n                }\n                current \u003d current.getNext();\n            }\n            FunctionParamBuilder paramBuilder \u003d new FunctionParamBuilder(this);\n            if (current.getType() \u003d\u003d Token.LP) {\n                Node args \u003d current.getFirstChild();\n                for (Node arg \u003d current.getFirstChild(); arg !\u003d null; arg \u003d arg.getNext()) {\n                    if (arg.getType() \u003d\u003d Token.ELLIPSIS) {\n                        if (arg.getChildCount() \u003d\u003d 0) {\n                            paramBuilder.addVarArgs(getNativeType(UNKNOWN_TYPE));\n                        } else {\n                            paramBuilder.addVarArgs(createFromTypeNodesInternal(arg.getFirstChild(), sourceName, scope, false));\n                        }\n                    } else {\n                        JSType type \u003d createFromTypeNodesInternal(arg, sourceName, scope, false);\n                        if (arg.getType() \u003d\u003d Token.EQUALS) {\n                            boolean addSuccess \u003d paramBuilder.addOptionalParams(type);\n                            if (!addSuccess) {\n                                reporter.warning(ScriptRuntime.getMessage0(\"msg.jsdoc.function.varargs\"), sourceName, arg.getLineno(), \"\", arg.getCharno());\n                            }\n                        } else {\n                            paramBuilder.addRequiredParams(type);\n                        }\n                    }\n                }\n                current \u003d current.getNext();\n            }\n            JSType returnType \u003d createFromTypeNodesInternal(current, sourceName, scope, false);\n            return new FunctionBuilder(this).withParams(paramBuilder).withReturnType(returnType).withTypeOfThis(thisType).build();\n    }\n    throw new IllegalStateException(\"Unexpected node in type expression: \" + n.toString());\n}",
      "path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
      "functionStartLine": 1336,
      "functionName": "createFromTypeNodesInternal",
      "functionAnnotation": "",
      "functionDoc": "\n@see #createFromTypeNodes(Node, String, StaticScope, boolean)\n",
      "diff": "@@ -1,92 +1,92 @@\n private JSType createFromTypeNodesInternal(Node n, String sourceName, StaticScope\u003cJSType\u003e scope, boolean forgiving) {\n     switch(n.getType()) {\n         case Token.LC:\n             return createRecordTypeFromNodes(n.getFirstChild(), sourceName, scope);\n         case Token.BANG:\n             return createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope, forgiving).restrictByNotNullOrUndefined();\n         case Token.QMARK:\n             Node firstChild \u003d n.getFirstChild();\n             if (firstChild \u003d\u003d null) {\n                 return getNativeType(UNKNOWN_TYPE);\n             }\n             return createDefaultObjectUnion(createFromTypeNodesInternal(firstChild, sourceName, scope, forgiving));\n         case Token.EQUALS:\n             return createOptionalType(createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope, false));\n         case Token.ELLIPSIS:\n             return createOptionalType(createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope, false));\n         case Token.STAR:\n             return getNativeType(ALL_TYPE);\n         case Token.LB:\n             return getNativeType(ARRAY_TYPE);\n         case Token.PIPE:\n             UnionTypeBuilder builder \u003d new UnionTypeBuilder(this);\n             for (Node child \u003d n.getFirstChild(); child !\u003d null; child \u003d child.getNext()) {\n                 builder.addAlternate(createFromTypeNodesInternal(child, sourceName, scope, false));\n             }\n             return builder.build();\n         case Token.EMPTY:\n             return getNativeType(UNKNOWN_TYPE);\n         case Token.VOID:\n             return getNativeType(VOID_TYPE);\n         case Token.STRING:\n             JSType namedType \u003d getType(scope, n.getString(), sourceName, n.getLineno(), n.getCharno());\n             if (forgiving) {\n                 namedType.forgiveUnknownNames();\n             }\n             if (resolveMode !\u003d ResolveMode.LAZY_NAMES) {\n                 namedType \u003d namedType.resolveInternal(reporter, scope);\n             }\n-            if ((namedType instanceof ObjectType) \u0026\u0026 !(enumTypeNames.contains(n.getString()))) {\n+            if ((namedType instanceof ObjectType) \u0026\u0026 !(nonNullableTypeNames.contains(n.getString()))) {\n                 Node typeList \u003d n.getFirstChild();\n                 if (typeList !\u003d null \u0026\u0026 (\"Array\".equals(n.getString()) || \"Object\".equals(n.getString()))) {\n                     JSType parameterType \u003d createFromTypeNodesInternal(typeList.getLastChild(), sourceName, scope, false);\n                     namedType \u003d new ParameterizedType(this, (ObjectType) namedType, parameterType);\n                     if (typeList.hasMoreThanOneChild()) {\n                         JSType indexType \u003d createFromTypeNodesInternal(typeList.getFirstChild(), sourceName, scope, false);\n                         namedType \u003d new IndexedType(this, (ObjectType) namedType, indexType);\n                     }\n                 }\n                 return createDefaultObjectUnion(namedType);\n             } else {\n                 return namedType;\n             }\n         case Token.FUNCTION:\n             ObjectType thisType \u003d null;\n             Node current \u003d n.getFirstChild();\n             if (current.getType() \u003d\u003d Token.THIS) {\n                 Node thisNode \u003d current.getFirstChild();\n                 thisType \u003d ObjectType.cast(createFromTypeNodesInternal(thisNode, sourceName, scope, false).restrictByNotNullOrUndefined());\n                 if (thisType \u003d\u003d null) {\n                     reporter.warning(ScriptRuntime.getMessage0(\"msg.jsdoc.function.thisnotobject\"), sourceName, thisNode.getLineno(), \"\", thisNode.getCharno());\n                 }\n                 current \u003d current.getNext();\n             }\n             FunctionParamBuilder paramBuilder \u003d new FunctionParamBuilder(this);\n             if (current.getType() \u003d\u003d Token.LP) {\n                 Node args \u003d current.getFirstChild();\n                 for (Node arg \u003d current.getFirstChild(); arg !\u003d null; arg \u003d arg.getNext()) {\n                     if (arg.getType() \u003d\u003d Token.ELLIPSIS) {\n                         if (arg.getChildCount() \u003d\u003d 0) {\n                             paramBuilder.addVarArgs(getNativeType(UNKNOWN_TYPE));\n                         } else {\n                             paramBuilder.addVarArgs(createFromTypeNodesInternal(arg.getFirstChild(), sourceName, scope, false));\n                         }\n                     } else {\n                         JSType type \u003d createFromTypeNodesInternal(arg, sourceName, scope, false);\n                         if (arg.getType() \u003d\u003d Token.EQUALS) {\n                             boolean addSuccess \u003d paramBuilder.addOptionalParams(type);\n                             if (!addSuccess) {\n                                 reporter.warning(ScriptRuntime.getMessage0(\"msg.jsdoc.function.varargs\"), sourceName, arg.getLineno(), \"\", arg.getCharno());\n                             }\n                         } else {\n                             paramBuilder.addRequiredParams(type);\n                         }\n                     }\n                 }\n                 current \u003d current.getNext();\n             }\n             JSType returnType \u003d createFromTypeNodesInternal(current, sourceName, scope, false);\n             return new FunctionBuilder(this).withParams(paramBuilder).withReturnType(returnType).withTypeOfThis(thisType).build();\n     }\n     throw new IllegalStateException(\"Unexpected node in type expression: \" + n.toString());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "58c3e4ce1d17ec619bcc4964bdeebc676f93567d": {
      "type": "Yintroduced",
      "commitMessage": "\n\nChange on 2010/05/03 by robby\n\n        Preliminary: goog.scope support for closure-compiler\n\n        R\u003dnick,john\n        DELTA\u003d318  (318 added, 0 deleted, 0 changed)\n\nChange on 2010/05/03 by nick\n\n        Add a bit more smarts to type resolution. Also, give it a\n        \"forceResolve\" method so that it will try to resolve type names,\n        even if the registry is in a lazy mode.\n\n        R\u003drobert\n        DELTA\u003d205  (133 added, 54 deleted, 18 changed)\n\nChange on 2010/05/03 by alan\n\n        Enable Flow Sensitive Inlining by default. Passes GMail automation test.\n\n        R\u003dnick\n        DELTA\u003d1  (0 added, 0 deleted, 1 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003dcmvhwl\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@202 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "5/4/10, 7:39 AM",
      "commitName": "58c3e4ce1d17ec619bcc4964bdeebc676f93567d",
      "commitAuthor": "Nicholas.J.Santos",
      "diff": "@@ -0,0 +1,92 @@\n+private JSType createFromTypeNodesInternal(Node n, String sourceName, StaticScope\u003cJSType\u003e scope, boolean forgiving) {\n+    switch(n.getType()) {\n+        case Token.LC:\n+            return createRecordTypeFromNodes(n.getFirstChild(), sourceName, scope);\n+        case Token.BANG:\n+            return createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope, forgiving).restrictByNotNullOrUndefined();\n+        case Token.QMARK:\n+            Node firstChild \u003d n.getFirstChild();\n+            if (firstChild \u003d\u003d null) {\n+                return getNativeType(UNKNOWN_TYPE);\n+            }\n+            return createDefaultObjectUnion(createFromTypeNodesInternal(firstChild, sourceName, scope, forgiving));\n+        case Token.EQUALS:\n+            return createOptionalType(createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope, false));\n+        case Token.ELLIPSIS:\n+            return createOptionalType(createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope, false));\n+        case Token.STAR:\n+            return getNativeType(ALL_TYPE);\n+        case Token.LB:\n+            return getNativeType(ARRAY_TYPE);\n+        case Token.PIPE:\n+            UnionTypeBuilder builder \u003d new UnionTypeBuilder(this);\n+            for (Node child \u003d n.getFirstChild(); child !\u003d null; child \u003d child.getNext()) {\n+                builder.addAlternate(createFromTypeNodesInternal(child, sourceName, scope, false));\n+            }\n+            return builder.build();\n+        case Token.EMPTY:\n+            return getNativeType(UNKNOWN_TYPE);\n+        case Token.VOID:\n+            return getNativeType(VOID_TYPE);\n+        case Token.STRING:\n+            JSType namedType \u003d getType(scope, n.getString(), sourceName, n.getLineno(), n.getCharno());\n+            if (forgiving) {\n+                namedType.forgiveUnknownNames();\n+            }\n+            if (resolveMode !\u003d ResolveMode.LAZY_NAMES) {\n+                namedType \u003d namedType.resolveInternal(reporter, scope);\n+            }\n+            if ((namedType instanceof ObjectType) \u0026\u0026 !(enumTypeNames.contains(n.getString()))) {\n+                Node typeList \u003d n.getFirstChild();\n+                if (typeList !\u003d null \u0026\u0026 (\"Array\".equals(n.getString()) || \"Object\".equals(n.getString()))) {\n+                    JSType parameterType \u003d createFromTypeNodesInternal(typeList.getLastChild(), sourceName, scope, false);\n+                    namedType \u003d new ParameterizedType(this, (ObjectType) namedType, parameterType);\n+                    if (typeList.hasMoreThanOneChild()) {\n+                        JSType indexType \u003d createFromTypeNodesInternal(typeList.getFirstChild(), sourceName, scope, false);\n+                        namedType \u003d new IndexedType(this, (ObjectType) namedType, indexType);\n+                    }\n+                }\n+                return createDefaultObjectUnion(namedType);\n+            } else {\n+                return namedType;\n+            }\n+        case Token.FUNCTION:\n+            ObjectType thisType \u003d null;\n+            Node current \u003d n.getFirstChild();\n+            if (current.getType() \u003d\u003d Token.THIS) {\n+                Node thisNode \u003d current.getFirstChild();\n+                thisType \u003d ObjectType.cast(createFromTypeNodesInternal(thisNode, sourceName, scope, false).restrictByNotNullOrUndefined());\n+                if (thisType \u003d\u003d null) {\n+                    reporter.warning(ScriptRuntime.getMessage0(\"msg.jsdoc.function.thisnotobject\"), sourceName, thisNode.getLineno(), \"\", thisNode.getCharno());\n+                }\n+                current \u003d current.getNext();\n+            }\n+            FunctionParamBuilder paramBuilder \u003d new FunctionParamBuilder(this);\n+            if (current.getType() \u003d\u003d Token.LP) {\n+                Node args \u003d current.getFirstChild();\n+                for (Node arg \u003d current.getFirstChild(); arg !\u003d null; arg \u003d arg.getNext()) {\n+                    if (arg.getType() \u003d\u003d Token.ELLIPSIS) {\n+                        if (arg.getChildCount() \u003d\u003d 0) {\n+                            paramBuilder.addVarArgs(getNativeType(UNKNOWN_TYPE));\n+                        } else {\n+                            paramBuilder.addVarArgs(createFromTypeNodesInternal(arg.getFirstChild(), sourceName, scope, false));\n+                        }\n+                    } else {\n+                        JSType type \u003d createFromTypeNodesInternal(arg, sourceName, scope, false);\n+                        if (arg.getType() \u003d\u003d Token.EQUALS) {\n+                            boolean addSuccess \u003d paramBuilder.addOptionalParams(type);\n+                            if (!addSuccess) {\n+                                reporter.warning(ScriptRuntime.getMessage0(\"msg.jsdoc.function.varargs\"), sourceName, arg.getLineno(), \"\", arg.getCharno());\n+                            }\n+                        } else {\n+                            paramBuilder.addRequiredParams(type);\n+                        }\n+                    }\n+                }\n+                current \u003d current.getNext();\n+            }\n+            JSType returnType \u003d createFromTypeNodesInternal(current, sourceName, scope, false);\n+            return new FunctionBuilder(this).withParams(paramBuilder).withReturnType(returnType).withTypeOfThis(thisType).build();\n+    }\n+    throw new IllegalStateException(\"Unexpected node in type expression: \" + n.toString());\n+}\n\\ No newline at end of file\n",
      "actualSource": "private JSType createFromTypeNodesInternal(Node n, String sourceName, StaticScope\u003cJSType\u003e scope, boolean forgiving) {\n    switch(n.getType()) {\n        case Token.LC:\n            return createRecordTypeFromNodes(n.getFirstChild(), sourceName, scope);\n        case Token.BANG:\n            return createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope, forgiving).restrictByNotNullOrUndefined();\n        case Token.QMARK:\n            Node firstChild \u003d n.getFirstChild();\n            if (firstChild \u003d\u003d null) {\n                return getNativeType(UNKNOWN_TYPE);\n            }\n            return createDefaultObjectUnion(createFromTypeNodesInternal(firstChild, sourceName, scope, forgiving));\n        case Token.EQUALS:\n            return createOptionalType(createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope, false));\n        case Token.ELLIPSIS:\n            return createOptionalType(createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope, false));\n        case Token.STAR:\n            return getNativeType(ALL_TYPE);\n        case Token.LB:\n            return getNativeType(ARRAY_TYPE);\n        case Token.PIPE:\n            UnionTypeBuilder builder \u003d new UnionTypeBuilder(this);\n            for (Node child \u003d n.getFirstChild(); child !\u003d null; child \u003d child.getNext()) {\n                builder.addAlternate(createFromTypeNodesInternal(child, sourceName, scope, false));\n            }\n            return builder.build();\n        case Token.EMPTY:\n            return getNativeType(UNKNOWN_TYPE);\n        case Token.VOID:\n            return getNativeType(VOID_TYPE);\n        case Token.STRING:\n            JSType namedType \u003d getType(scope, n.getString(), sourceName, n.getLineno(), n.getCharno());\n            if (forgiving) {\n                namedType.forgiveUnknownNames();\n            }\n            if (resolveMode !\u003d ResolveMode.LAZY_NAMES) {\n                namedType \u003d namedType.resolveInternal(reporter, scope);\n            }\n            if ((namedType instanceof ObjectType) \u0026\u0026 !(enumTypeNames.contains(n.getString()))) {\n                Node typeList \u003d n.getFirstChild();\n                if (typeList !\u003d null \u0026\u0026 (\"Array\".equals(n.getString()) || \"Object\".equals(n.getString()))) {\n                    JSType parameterType \u003d createFromTypeNodesInternal(typeList.getLastChild(), sourceName, scope, false);\n                    namedType \u003d new ParameterizedType(this, (ObjectType) namedType, parameterType);\n                    if (typeList.hasMoreThanOneChild()) {\n                        JSType indexType \u003d createFromTypeNodesInternal(typeList.getFirstChild(), sourceName, scope, false);\n                        namedType \u003d new IndexedType(this, (ObjectType) namedType, indexType);\n                    }\n                }\n                return createDefaultObjectUnion(namedType);\n            } else {\n                return namedType;\n            }\n        case Token.FUNCTION:\n            ObjectType thisType \u003d null;\n            Node current \u003d n.getFirstChild();\n            if (current.getType() \u003d\u003d Token.THIS) {\n                Node thisNode \u003d current.getFirstChild();\n                thisType \u003d ObjectType.cast(createFromTypeNodesInternal(thisNode, sourceName, scope, false).restrictByNotNullOrUndefined());\n                if (thisType \u003d\u003d null) {\n                    reporter.warning(ScriptRuntime.getMessage0(\"msg.jsdoc.function.thisnotobject\"), sourceName, thisNode.getLineno(), \"\", thisNode.getCharno());\n                }\n                current \u003d current.getNext();\n            }\n            FunctionParamBuilder paramBuilder \u003d new FunctionParamBuilder(this);\n            if (current.getType() \u003d\u003d Token.LP) {\n                Node args \u003d current.getFirstChild();\n                for (Node arg \u003d current.getFirstChild(); arg !\u003d null; arg \u003d arg.getNext()) {\n                    if (arg.getType() \u003d\u003d Token.ELLIPSIS) {\n                        if (arg.getChildCount() \u003d\u003d 0) {\n                            paramBuilder.addVarArgs(getNativeType(UNKNOWN_TYPE));\n                        } else {\n                            paramBuilder.addVarArgs(createFromTypeNodesInternal(arg.getFirstChild(), sourceName, scope, false));\n                        }\n                    } else {\n                        JSType type \u003d createFromTypeNodesInternal(arg, sourceName, scope, false);\n                        if (arg.getType() \u003d\u003d Token.EQUALS) {\n                            boolean addSuccess \u003d paramBuilder.addOptionalParams(type);\n                            if (!addSuccess) {\n                                reporter.warning(ScriptRuntime.getMessage0(\"msg.jsdoc.function.varargs\"), sourceName, arg.getLineno(), \"\", arg.getCharno());\n                            }\n                        } else {\n                            paramBuilder.addRequiredParams(type);\n                        }\n                    }\n                }\n                current \u003d current.getNext();\n            }\n            JSType returnType \u003d createFromTypeNodesInternal(current, sourceName, scope, false);\n            return new FunctionBuilder(this).withParams(paramBuilder).withReturnType(returnType).withTypeOfThis(thisType).build();\n    }\n    throw new IllegalStateException(\"Unexpected node in type expression: \" + n.toString());\n}",
      "path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
      "functionStartLine": 1293,
      "functionName": "createFromTypeNodesInternal",
      "functionAnnotation": "",
      "functionDoc": "\n@see #createFromTypeNodes(Node, String, StaticScope, boolean)\n"
    }
  }
}