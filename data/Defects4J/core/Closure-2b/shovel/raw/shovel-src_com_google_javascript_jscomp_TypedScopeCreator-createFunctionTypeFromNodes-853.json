{
  "origin": "codeshovel",
  "repositoryName": "Closure-2b",
  "repositoryPath": "/tmp/Closure-2b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "TypedScopeCreator.java",
  "functionName": "createFunctionTypeFromNodes",
  "functionId": "$createFunctionTypeFromNodes___rValue-Node(annotations-@Nullable)__name-String(annotations-@Nullable)__info-JSDocInfo(annotations-@Nullable)__lvalueNode-Node(annotations-@Nullable)",
  "sourceFilePath": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
  "functionAnnotation": "",
  "functionDoc": "Creates a new function type, based on the given nodes.\n\nThis handles two cases that are semantically very different, but\nare not mutually exclusive:\n- A function literal that needs a type attached to it.\n- An assignment expression with function-type info in the JsDoc.\n\nAll parameters are optional, and we will do the best we can to create\na function type.\n\nThis function will always create a function type, so only call it if\nyou\u0027re sure that\u0027s what you want.\n\n@param rValue The function node.\n@param name the function\u0027s name\n@param info the {@link JSDocInfo} attached to the function definition\n@param lvalueNode The node where this function is being\n    assigned. For example, {@code A.prototype.foo \u003d ...} would be used to\n    determine that this function is a method of A.prototype. May be\n    null to indicate that this is not being assigned to a qualified name.\n",
  "functionStartLine": 853,
  "functionEndLine": 961,
  "numCommitsSeen": 117,
  "timeTaken": 9096,
  "changeHistory": [
    "a7f99cbb3ba646de8e19f0248099dad9cf0432a6",
    "bbf1b138e20a36ca79b2a012ae145c943929a6dd",
    "00241aa722c2245784e63dba9d444fce88134aed",
    "63e875373844bdb6cedc7be3f537baa32cbd2ec0",
    "6588923bf1f47ee23764ea41f3e73febb92e3053",
    "8d91f37d29abd8682e298a23f63b96f2f2def659",
    "70a5626922ea7e8c98747e22b6986638ba38fadc",
    "ec324a9bb23eb78c76f537f4c4170ba88d542f1c",
    "dff730a3759cad9c491f72d9905eee93962d3d35",
    "a2dd1662d90524a12a99a9fa7d4308568938d963",
    "bd9c7b620384fe5a98772729001ed56304459bc6",
    "01d1238a2a577d8988a72c29304a3283ca05a29a",
    "fc0798047ad3aac58a54ea65f9f1c8857745419f",
    "072fa2d047573d2d1f0187ba4bf76b1afa75031c",
    "2ea78e73e6ace693e18d535560606dfd49c3f9bc"
  ],
  "changeHistoryShort": {
    "a7f99cbb3ba646de8e19f0248099dad9cf0432a6": "Ybodychange",
    "bbf1b138e20a36ca79b2a012ae145c943929a6dd": "Yformatchange",
    "00241aa722c2245784e63dba9d444fce88134aed": "Yformatchange",
    "63e875373844bdb6cedc7be3f537baa32cbd2ec0": "Yformatchange",
    "6588923bf1f47ee23764ea41f3e73febb92e3053": "Ybodychange",
    "8d91f37d29abd8682e298a23f63b96f2f2def659": "Ybodychange",
    "70a5626922ea7e8c98747e22b6986638ba38fadc": "Ydocchange",
    "ec324a9bb23eb78c76f537f4c4170ba88d542f1c": "Ybodychange",
    "dff730a3759cad9c491f72d9905eee93962d3d35": "Ybodychange",
    "a2dd1662d90524a12a99a9fa7d4308568938d963": "Ybodychange",
    "bd9c7b620384fe5a98772729001ed56304459bc6": "Ybodychange",
    "01d1238a2a577d8988a72c29304a3283ca05a29a": "Ybodychange",
    "fc0798047ad3aac58a54ea65f9f1c8857745419f": "Ybodychange",
    "072fa2d047573d2d1f0187ba4bf76b1afa75031c": "Yformatchange",
    "2ea78e73e6ace693e18d535560606dfd49c3f9bc": "Yintroduced"
  },
  "changeHistoryDetails": {
    "a7f99cbb3ba646de8e19f0248099dad9cf0432a6": {
      "type": "Ybodychange",
      "commitMessage": "\nAlternate proposal for handling IIFEs\nFixes issue 61\n\nR\u003ddimvar\nDELTA\u003d243  (149 added, 31 deleted, 63 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d5594\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2240 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "10/4/12, 11:18 AM",
      "commitName": "a7f99cbb3ba646de8e19f0248099dad9cf0432a6",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "9/24/12, 11:13 AM",
      "commitNameOld": "10c0c9ff36fb717223facd60efec8cf4ad97824f",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 10.0,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "actualSource": "private FunctionType createFunctionTypeFromNodes(@Nullable Node rValue, @Nullable String name, @Nullable JSDocInfo info, @Nullable Node lvalueNode) {\n    FunctionType functionType \u003d null;\n    if (rValue !\u003d null \u0026\u0026 rValue.isQualifiedName() \u0026\u0026 scope.isGlobal()) {\n        Var var \u003d scope.getVar(rValue.getQualifiedName());\n        if (var !\u003d null \u0026\u0026 var.getType() !\u003d null \u0026\u0026 var.getType().isFunctionType()) {\n            FunctionType aliasedType \u003d var.getType().toMaybeFunctionType();\n            if ((aliasedType.isConstructor() || aliasedType.isInterface()) \u0026\u0026 !aliasedType.isNativeObjectType()) {\n                functionType \u003d aliasedType;\n                if (name !\u003d null \u0026\u0026 scope.isGlobal()) {\n                    typeRegistry.declareType(name, functionType.getInstanceType());\n                }\n            }\n        }\n    }\n    if (functionType \u003d\u003d null) {\n        Node errorRoot \u003d rValue \u003d\u003d null ? lvalueNode : rValue;\n        boolean isFnLiteral \u003d rValue !\u003d null \u0026\u0026 rValue.isFunction();\n        Node fnRoot \u003d isFnLiteral ? rValue : null;\n        Node parametersNode \u003d isFnLiteral ? rValue.getFirstChild().getNext() : null;\n        Node fnBlock \u003d isFnLiteral ? parametersNode.getNext() : null;\n        if (info !\u003d null \u0026\u0026 info.hasType()) {\n            JSType type \u003d info.getType().evaluate(scope, typeRegistry);\n            type \u003d type.restrictByNotNullOrUndefined();\n            if (type.isFunctionType()) {\n                functionType \u003d type.toMaybeFunctionType();\n                functionType.setJSDocInfo(info);\n            }\n        }\n        if (functionType \u003d\u003d null) {\n            Node ownerNode \u003d NodeUtil.getBestLValueOwner(lvalueNode);\n            String ownerName \u003d NodeUtil.getBestLValueName(ownerNode);\n            Var ownerVar \u003d null;\n            String propName \u003d null;\n            ObjectType ownerType \u003d null;\n            if (ownerName !\u003d null) {\n                ownerVar \u003d scope.getVar(ownerName);\n                if (ownerVar !\u003d null) {\n                    ownerType \u003d ObjectType.cast(ownerVar.getType());\n                }\n                if (name !\u003d null) {\n                    propName \u003d name.substring(ownerName.length() + 1);\n                }\n            }\n            FunctionType overriddenType \u003d null;\n            if (ownerType !\u003d null \u0026\u0026 propName !\u003d null) {\n                overriddenType \u003d findOverriddenFunction(ownerType, propName);\n            }\n            FunctionTypeBuilder builder \u003d new FunctionTypeBuilder(name, compiler, errorRoot, sourceName, scope).setContents(getFunctionAnalysisResults(fnRoot)).inferFromOverriddenFunction(overriddenType, parametersNode).inferTemplateTypeName(info).inferReturnType(info).inferInheritance(info);\n            boolean searchedForThisType \u003d false;\n            if (ownerType !\u003d null \u0026\u0026 ownerType.isFunctionPrototypeType() \u0026\u0026 ownerType.getOwnerFunction().hasInstanceType()) {\n                builder.inferThisType(info, ownerType.getOwnerFunction().getInstanceType());\n                searchedForThisType \u003d true;\n            } else if (ownerNode !\u003d null \u0026\u0026 ownerNode.isThis()) {\n                JSType injectedThisType \u003d ownerNode.getJSType();\n                builder.inferThisType(info, injectedThisType \u003d\u003d null ? scope.getTypeOfThis() : injectedThisType);\n                searchedForThisType \u003d true;\n            }\n            if (!searchedForThisType) {\n                builder.inferThisType(info);\n            }\n            functionType \u003d builder.inferParameterTypes(parametersNode, info).buildAndRegister();\n        }\n    }\n    return functionType;\n}",
      "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
      "functionStartLine": 853,
      "functionName": "createFunctionTypeFromNodes",
      "functionAnnotation": "",
      "functionDoc": "Creates a new function type, based on the given nodes.\n\nThis handles two cases that are semantically very different, but\nare not mutually exclusive:\n- A function literal that needs a type attached to it.\n- An assignment expression with function-type info in the JsDoc.\n\nAll parameters are optional, and we will do the best we can to create\na function type.\n\nThis function will always create a function type, so only call it if\nyou\u0027re sure that\u0027s what you want.\n\n@param rValue The function node.\n@param name the function\u0027s name\n@param info the {@link JSDocInfo} attached to the function definition\n@param lvalueNode The node where this function is being\n    assigned. For example, {@code A.prototype.foo \u003d ...} would be used to\n    determine that this function is a method of A.prototype. May be\n    null to indicate that this is not being assigned to a qualified name.\n",
      "diff": "@@ -1,65 +1,65 @@\n private FunctionType createFunctionTypeFromNodes(@Nullable Node rValue, @Nullable String name, @Nullable JSDocInfo info, @Nullable Node lvalueNode) {\n     FunctionType functionType \u003d null;\n     if (rValue !\u003d null \u0026\u0026 rValue.isQualifiedName() \u0026\u0026 scope.isGlobal()) {\n         Var var \u003d scope.getVar(rValue.getQualifiedName());\n         if (var !\u003d null \u0026\u0026 var.getType() !\u003d null \u0026\u0026 var.getType().isFunctionType()) {\n             FunctionType aliasedType \u003d var.getType().toMaybeFunctionType();\n             if ((aliasedType.isConstructor() || aliasedType.isInterface()) \u0026\u0026 !aliasedType.isNativeObjectType()) {\n                 functionType \u003d aliasedType;\n                 if (name !\u003d null \u0026\u0026 scope.isGlobal()) {\n                     typeRegistry.declareType(name, functionType.getInstanceType());\n                 }\n             }\n         }\n     }\n     if (functionType \u003d\u003d null) {\n         Node errorRoot \u003d rValue \u003d\u003d null ? lvalueNode : rValue;\n         boolean isFnLiteral \u003d rValue !\u003d null \u0026\u0026 rValue.isFunction();\n         Node fnRoot \u003d isFnLiteral ? rValue : null;\n         Node parametersNode \u003d isFnLiteral ? rValue.getFirstChild().getNext() : null;\n         Node fnBlock \u003d isFnLiteral ? parametersNode.getNext() : null;\n         if (info !\u003d null \u0026\u0026 info.hasType()) {\n             JSType type \u003d info.getType().evaluate(scope, typeRegistry);\n             type \u003d type.restrictByNotNullOrUndefined();\n             if (type.isFunctionType()) {\n                 functionType \u003d type.toMaybeFunctionType();\n                 functionType.setJSDocInfo(info);\n             }\n         }\n         if (functionType \u003d\u003d null) {\n             Node ownerNode \u003d NodeUtil.getBestLValueOwner(lvalueNode);\n             String ownerName \u003d NodeUtil.getBestLValueName(ownerNode);\n             Var ownerVar \u003d null;\n             String propName \u003d null;\n             ObjectType ownerType \u003d null;\n             if (ownerName !\u003d null) {\n                 ownerVar \u003d scope.getVar(ownerName);\n                 if (ownerVar !\u003d null) {\n                     ownerType \u003d ObjectType.cast(ownerVar.getType());\n                 }\n                 if (name !\u003d null) {\n                     propName \u003d name.substring(ownerName.length() + 1);\n                 }\n             }\n-            FunctionType overriddenPropType \u003d null;\n+            FunctionType overriddenType \u003d null;\n             if (ownerType !\u003d null \u0026\u0026 propName !\u003d null) {\n-                overriddenPropType \u003d findOverriddenFunction(ownerType, propName);\n+                overriddenType \u003d findOverriddenFunction(ownerType, propName);\n             }\n-            FunctionTypeBuilder builder \u003d new FunctionTypeBuilder(name, compiler, errorRoot, sourceName, scope).setContents(getFunctionAnalysisResults(fnRoot)).inferFromOverriddenFunction(overriddenPropType, parametersNode).inferTemplateTypeName(info).inferReturnType(info).inferInheritance(info);\n+            FunctionTypeBuilder builder \u003d new FunctionTypeBuilder(name, compiler, errorRoot, sourceName, scope).setContents(getFunctionAnalysisResults(fnRoot)).inferFromOverriddenFunction(overriddenType, parametersNode).inferTemplateTypeName(info).inferReturnType(info).inferInheritance(info);\n             boolean searchedForThisType \u003d false;\n             if (ownerType !\u003d null \u0026\u0026 ownerType.isFunctionPrototypeType() \u0026\u0026 ownerType.getOwnerFunction().hasInstanceType()) {\n                 builder.inferThisType(info, ownerType.getOwnerFunction().getInstanceType());\n                 searchedForThisType \u003d true;\n             } else if (ownerNode !\u003d null \u0026\u0026 ownerNode.isThis()) {\n                 JSType injectedThisType \u003d ownerNode.getJSType();\n                 builder.inferThisType(info, injectedThisType \u003d\u003d null ? scope.getTypeOfThis() : injectedThisType);\n                 searchedForThisType \u003d true;\n             }\n             if (!searchedForThisType) {\n                 builder.inferThisType(info);\n             }\n             functionType \u003d builder.inferParameterTypes(parametersNode, info).buildAndRegister();\n         }\n     }\n     return functionType;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "bbf1b138e20a36ca79b2a012ae145c943929a6dd": {
      "type": "Yformatchange",
      "commitMessage": "\nAutomated g4 rollback\n\n*** Reason for rollback ***\n\nFailures don\u0027t seem related to jscompiler. Resubmitting for now.\n\n*** Original change description ***\n\nAutomated g4 rollback\n\n*** Reason for rollback ***\n\nChange caused tests to stop building.\n\n*** Original change description ***\n\nNew @struct and @dict annotations for constructors.\nWith these annotations, one can enforce only dot or only bracket access on object properties.\n\nR\u003dnicksantos\nDELTA\u003d476  (391 added, 34 deleted, 51 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d5491\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2184 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "9/11/12, 4:17 PM",
      "commitName": "bbf1b138e20a36ca79b2a012ae145c943929a6dd",
      "commitAuthor": "dimvar@google.com",
      "commitDateOld": "9/11/12, 11:52 AM",
      "commitNameOld": "00241aa722c2245784e63dba9d444fce88134aed",
      "commitAuthorOld": "dimvar@google.com",
      "daysBetweenCommits": 0.18,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "private FunctionType createFunctionTypeFromNodes(@Nullable Node rValue, @Nullable String name, @Nullable JSDocInfo info, @Nullable Node lvalueNode) {\n    FunctionType functionType \u003d null;\n    if (rValue !\u003d null \u0026\u0026 rValue.isQualifiedName() \u0026\u0026 scope.isGlobal()) {\n        Var var \u003d scope.getVar(rValue.getQualifiedName());\n        if (var !\u003d null \u0026\u0026 var.getType() !\u003d null \u0026\u0026 var.getType().isFunctionType()) {\n            FunctionType aliasedType \u003d var.getType().toMaybeFunctionType();\n            if ((aliasedType.isConstructor() || aliasedType.isInterface()) \u0026\u0026 !aliasedType.isNativeObjectType()) {\n                functionType \u003d aliasedType;\n                if (name !\u003d null \u0026\u0026 scope.isGlobal()) {\n                    typeRegistry.declareType(name, functionType.getInstanceType());\n                }\n            }\n        }\n    }\n    if (functionType \u003d\u003d null) {\n        Node errorRoot \u003d rValue \u003d\u003d null ? lvalueNode : rValue;\n        boolean isFnLiteral \u003d rValue !\u003d null \u0026\u0026 rValue.isFunction();\n        Node fnRoot \u003d isFnLiteral ? rValue : null;\n        Node parametersNode \u003d isFnLiteral ? rValue.getFirstChild().getNext() : null;\n        Node fnBlock \u003d isFnLiteral ? parametersNode.getNext() : null;\n        if (info !\u003d null \u0026\u0026 info.hasType()) {\n            JSType type \u003d info.getType().evaluate(scope, typeRegistry);\n            type \u003d type.restrictByNotNullOrUndefined();\n            if (type.isFunctionType()) {\n                functionType \u003d type.toMaybeFunctionType();\n                functionType.setJSDocInfo(info);\n            }\n        }\n        if (functionType \u003d\u003d null) {\n            Node ownerNode \u003d NodeUtil.getBestLValueOwner(lvalueNode);\n            String ownerName \u003d NodeUtil.getBestLValueName(ownerNode);\n            Var ownerVar \u003d null;\n            String propName \u003d null;\n            ObjectType ownerType \u003d null;\n            if (ownerName !\u003d null) {\n                ownerVar \u003d scope.getVar(ownerName);\n                if (ownerVar !\u003d null) {\n                    ownerType \u003d ObjectType.cast(ownerVar.getType());\n                }\n                if (name !\u003d null) {\n                    propName \u003d name.substring(ownerName.length() + 1);\n                }\n            }\n            FunctionType overriddenPropType \u003d null;\n            if (ownerType !\u003d null \u0026\u0026 propName !\u003d null) {\n                overriddenPropType \u003d findOverriddenFunction(ownerType, propName);\n            }\n            FunctionTypeBuilder builder \u003d new FunctionTypeBuilder(name, compiler, errorRoot, sourceName, scope).setContents(getFunctionAnalysisResults(fnRoot)).inferFromOverriddenFunction(overriddenPropType, parametersNode).inferTemplateTypeName(info).inferReturnType(info).inferInheritance(info);\n            boolean searchedForThisType \u003d false;\n            if (ownerType !\u003d null \u0026\u0026 ownerType.isFunctionPrototypeType() \u0026\u0026 ownerType.getOwnerFunction().hasInstanceType()) {\n                builder.inferThisType(info, ownerType.getOwnerFunction().getInstanceType());\n                searchedForThisType \u003d true;\n            } else if (ownerNode !\u003d null \u0026\u0026 ownerNode.isThis()) {\n                JSType injectedThisType \u003d ownerNode.getJSType();\n                builder.inferThisType(info, injectedThisType \u003d\u003d null ? scope.getTypeOfThis() : injectedThisType);\n                searchedForThisType \u003d true;\n            }\n            if (!searchedForThisType) {\n                builder.inferThisType(info);\n            }\n            functionType \u003d builder.inferParameterTypes(parametersNode, info).buildAndRegister();\n        }\n    }\n    return functionType;\n}",
      "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
      "functionStartLine": 841,
      "functionName": "createFunctionTypeFromNodes",
      "functionAnnotation": "",
      "functionDoc": "Creates a new function type, based on the given nodes.\n\nThis handles two cases that are semantically very different, but\nare not mutually exclusive:\n- A function literal that needs a type attached to it.\n- An assignment expression with function-type info in the JsDoc.\n\nAll parameters are optional, and we will do the best we can to create\na function type.\n\nThis function will always create a function type, so only call it if\nyou\u0027re sure that\u0027s what you want.\n\n@param rValue The function node.\n@param name the function\u0027s name\n@param info the {@link JSDocInfo} attached to the function definition\n@param lvalueNode The node where this function is being\n    assigned. For example, {@code A.prototype.foo \u003d ...} would be used to\n    determine that this function is a method of A.prototype. May be\n    null to indicate that this is not being assigned to a qualified name.\n",
      "diff": "",
      "extendedDetails": {}
    },
    "00241aa722c2245784e63dba9d444fce88134aed": {
      "type": "Yformatchange",
      "commitMessage": "\nAutomated g4 rollback\n\n*** Reason for rollback ***\n\nChange caused tests to stop building.\n\n*** Original change description ***\n\nNew @struct and @dict annotations for constructors.\nWith these annotations, one can enforce only dot or only bracket access on object properties.\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d5489\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2182 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "9/11/12, 11:52 AM",
      "commitName": "00241aa722c2245784e63dba9d444fce88134aed",
      "commitAuthor": "dimvar@google.com",
      "commitDateOld": "9/11/12, 11:10 AM",
      "commitNameOld": "63e875373844bdb6cedc7be3f537baa32cbd2ec0",
      "commitAuthorOld": "dimvar@google.com",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private FunctionType createFunctionTypeFromNodes(@Nullable Node rValue, @Nullable String name, @Nullable JSDocInfo info, @Nullable Node lvalueNode) {\n    FunctionType functionType \u003d null;\n    if (rValue !\u003d null \u0026\u0026 rValue.isQualifiedName() \u0026\u0026 scope.isGlobal()) {\n        Var var \u003d scope.getVar(rValue.getQualifiedName());\n        if (var !\u003d null \u0026\u0026 var.getType() !\u003d null \u0026\u0026 var.getType().isFunctionType()) {\n            FunctionType aliasedType \u003d var.getType().toMaybeFunctionType();\n            if ((aliasedType.isConstructor() || aliasedType.isInterface()) \u0026\u0026 !aliasedType.isNativeObjectType()) {\n                functionType \u003d aliasedType;\n                if (name !\u003d null \u0026\u0026 scope.isGlobal()) {\n                    typeRegistry.declareType(name, functionType.getInstanceType());\n                }\n            }\n        }\n    }\n    if (functionType \u003d\u003d null) {\n        Node errorRoot \u003d rValue \u003d\u003d null ? lvalueNode : rValue;\n        boolean isFnLiteral \u003d rValue !\u003d null \u0026\u0026 rValue.isFunction();\n        Node fnRoot \u003d isFnLiteral ? rValue : null;\n        Node parametersNode \u003d isFnLiteral ? rValue.getFirstChild().getNext() : null;\n        Node fnBlock \u003d isFnLiteral ? parametersNode.getNext() : null;\n        if (info !\u003d null \u0026\u0026 info.hasType()) {\n            JSType type \u003d info.getType().evaluate(scope, typeRegistry);\n            type \u003d type.restrictByNotNullOrUndefined();\n            if (type.isFunctionType()) {\n                functionType \u003d type.toMaybeFunctionType();\n                functionType.setJSDocInfo(info);\n            }\n        }\n        if (functionType \u003d\u003d null) {\n            Node ownerNode \u003d NodeUtil.getBestLValueOwner(lvalueNode);\n            String ownerName \u003d NodeUtil.getBestLValueName(ownerNode);\n            Var ownerVar \u003d null;\n            String propName \u003d null;\n            ObjectType ownerType \u003d null;\n            if (ownerName !\u003d null) {\n                ownerVar \u003d scope.getVar(ownerName);\n                if (ownerVar !\u003d null) {\n                    ownerType \u003d ObjectType.cast(ownerVar.getType());\n                }\n                if (name !\u003d null) {\n                    propName \u003d name.substring(ownerName.length() + 1);\n                }\n            }\n            FunctionType overriddenPropType \u003d null;\n            if (ownerType !\u003d null \u0026\u0026 propName !\u003d null) {\n                overriddenPropType \u003d findOverriddenFunction(ownerType, propName);\n            }\n            FunctionTypeBuilder builder \u003d new FunctionTypeBuilder(name, compiler, errorRoot, sourceName, scope).setContents(getFunctionAnalysisResults(fnRoot)).inferFromOverriddenFunction(overriddenPropType, parametersNode).inferTemplateTypeName(info).inferReturnType(info).inferInheritance(info);\n            boolean searchedForThisType \u003d false;\n            if (ownerType !\u003d null \u0026\u0026 ownerType.isFunctionPrototypeType() \u0026\u0026 ownerType.getOwnerFunction().hasInstanceType()) {\n                builder.inferThisType(info, ownerType.getOwnerFunction().getInstanceType());\n                searchedForThisType \u003d true;\n            } else if (ownerNode !\u003d null \u0026\u0026 ownerNode.isThis()) {\n                JSType injectedThisType \u003d ownerNode.getJSType();\n                builder.inferThisType(info, injectedThisType \u003d\u003d null ? scope.getTypeOfThis() : injectedThisType);\n                searchedForThisType \u003d true;\n            }\n            if (!searchedForThisType) {\n                builder.inferThisType(info);\n            }\n            functionType \u003d builder.inferParameterTypes(parametersNode, info).buildAndRegister();\n        }\n    }\n    return functionType;\n}",
      "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
      "functionStartLine": 842,
      "functionName": "createFunctionTypeFromNodes",
      "functionAnnotation": "",
      "functionDoc": "Creates a new function type, based on the given nodes.\n\nThis handles two cases that are semantically very different, but\nare not mutually exclusive:\n- A function literal that needs a type attached to it.\n- An assignment expression with function-type info in the JsDoc.\n\nAll parameters are optional, and we will do the best we can to create\na function type.\n\nThis function will always create a function type, so only call it if\nyou\u0027re sure that\u0027s what you want.\n\n@param rValue The function node.\n@param name the function\u0027s name\n@param info the {@link JSDocInfo} attached to the function definition\n@param lvalueNode The node where this function is being\n    assigned. For example, {@code A.prototype.foo \u003d ...} would be used to\n    determine that this function is a method of A.prototype. May be\n    null to indicate that this is not being assigned to a qualified name.\n",
      "diff": "",
      "extendedDetails": {}
    },
    "63e875373844bdb6cedc7be3f537baa32cbd2ec0": {
      "type": "Yformatchange",
      "commitMessage": "\nNew @struct and @dict annotations for constructors.\nWith these annotations, one can enforce only dot or only bracket access on object properties.\n\nR\u003dnicksantos\nDELTA\u003d476  (391 added, 34 deleted, 51 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d5488\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2181 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "9/11/12, 11:10 AM",
      "commitName": "63e875373844bdb6cedc7be3f537baa32cbd2ec0",
      "commitAuthor": "dimvar@google.com",
      "commitDateOld": "8/22/12, 12:20 PM",
      "commitNameOld": "d0f6017ead696c8bc68f01b167d9e9bb4b091921",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 19.95,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "actualSource": "private FunctionType createFunctionTypeFromNodes(@Nullable Node rValue, @Nullable String name, @Nullable JSDocInfo info, @Nullable Node lvalueNode) {\n    FunctionType functionType \u003d null;\n    if (rValue !\u003d null \u0026\u0026 rValue.isQualifiedName() \u0026\u0026 scope.isGlobal()) {\n        Var var \u003d scope.getVar(rValue.getQualifiedName());\n        if (var !\u003d null \u0026\u0026 var.getType() !\u003d null \u0026\u0026 var.getType().isFunctionType()) {\n            FunctionType aliasedType \u003d var.getType().toMaybeFunctionType();\n            if ((aliasedType.isConstructor() || aliasedType.isInterface()) \u0026\u0026 !aliasedType.isNativeObjectType()) {\n                functionType \u003d aliasedType;\n                if (name !\u003d null \u0026\u0026 scope.isGlobal()) {\n                    typeRegistry.declareType(name, functionType.getInstanceType());\n                }\n            }\n        }\n    }\n    if (functionType \u003d\u003d null) {\n        Node errorRoot \u003d rValue \u003d\u003d null ? lvalueNode : rValue;\n        boolean isFnLiteral \u003d rValue !\u003d null \u0026\u0026 rValue.isFunction();\n        Node fnRoot \u003d isFnLiteral ? rValue : null;\n        Node parametersNode \u003d isFnLiteral ? rValue.getFirstChild().getNext() : null;\n        Node fnBlock \u003d isFnLiteral ? parametersNode.getNext() : null;\n        if (info !\u003d null \u0026\u0026 info.hasType()) {\n            JSType type \u003d info.getType().evaluate(scope, typeRegistry);\n            type \u003d type.restrictByNotNullOrUndefined();\n            if (type.isFunctionType()) {\n                functionType \u003d type.toMaybeFunctionType();\n                functionType.setJSDocInfo(info);\n            }\n        }\n        if (functionType \u003d\u003d null) {\n            Node ownerNode \u003d NodeUtil.getBestLValueOwner(lvalueNode);\n            String ownerName \u003d NodeUtil.getBestLValueName(ownerNode);\n            Var ownerVar \u003d null;\n            String propName \u003d null;\n            ObjectType ownerType \u003d null;\n            if (ownerName !\u003d null) {\n                ownerVar \u003d scope.getVar(ownerName);\n                if (ownerVar !\u003d null) {\n                    ownerType \u003d ObjectType.cast(ownerVar.getType());\n                }\n                if (name !\u003d null) {\n                    propName \u003d name.substring(ownerName.length() + 1);\n                }\n            }\n            FunctionType overriddenPropType \u003d null;\n            if (ownerType !\u003d null \u0026\u0026 propName !\u003d null) {\n                overriddenPropType \u003d findOverriddenFunction(ownerType, propName);\n            }\n            FunctionTypeBuilder builder \u003d new FunctionTypeBuilder(name, compiler, errorRoot, sourceName, scope).setContents(getFunctionAnalysisResults(fnRoot)).inferFromOverriddenFunction(overriddenPropType, parametersNode).inferTemplateTypeName(info).inferReturnType(info).inferInheritance(info);\n            boolean searchedForThisType \u003d false;\n            if (ownerType !\u003d null \u0026\u0026 ownerType.isFunctionPrototypeType() \u0026\u0026 ownerType.getOwnerFunction().hasInstanceType()) {\n                builder.inferThisType(info, ownerType.getOwnerFunction().getInstanceType());\n                searchedForThisType \u003d true;\n            } else if (ownerNode !\u003d null \u0026\u0026 ownerNode.isThis()) {\n                JSType injectedThisType \u003d ownerNode.getJSType();\n                builder.inferThisType(info, injectedThisType \u003d\u003d null ? scope.getTypeOfThis() : injectedThisType);\n                searchedForThisType \u003d true;\n            }\n            if (!searchedForThisType) {\n                builder.inferThisType(info);\n            }\n            functionType \u003d builder.inferParameterTypes(parametersNode, info).buildAndRegister();\n        }\n    }\n    return functionType;\n}",
      "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
      "functionStartLine": 841,
      "functionName": "createFunctionTypeFromNodes",
      "functionAnnotation": "",
      "functionDoc": "Creates a new function type, based on the given nodes.\n\nThis handles two cases that are semantically very different, but\nare not mutually exclusive:\n- A function literal that needs a type attached to it.\n- An assignment expression with function-type info in the JsDoc.\n\nAll parameters are optional, and we will do the best we can to create\na function type.\n\nThis function will always create a function type, so only call it if\nyou\u0027re sure that\u0027s what you want.\n\n@param rValue The function node.\n@param name the function\u0027s name\n@param info the {@link JSDocInfo} attached to the function definition\n@param lvalueNode The node where this function is being\n    assigned. For example, {@code A.prototype.foo \u003d ...} would be used to\n    determine that this function is a method of A.prototype. May be\n    null to indicate that this is not being assigned to a qualified name.\n",
      "diff": "",
      "extendedDetails": {}
    },
    "6588923bf1f47ee23764ea41f3e73febb92e3053": {
      "type": "Ybodychange",
      "commitMessage": "\nFix a compiler crash for a rare case when type-checking\nunannotated code.\nAlso, now that source info is attached to nodes,\nuse that for source info in exceptions when available.\n\nR\u003djohnlenz\nDELTA\u003d34  (27 added, 0 deleted, 7 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d5282\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2113 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "7/30/12, 3:33 PM",
      "commitName": "6588923bf1f47ee23764ea41f3e73febb92e3053",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "7/9/12, 9:00 AM",
      "commitNameOld": "33ab4df84afbdb36216b8a1ea3a526c438615e26",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 21.27,
      "commitsBetweenForRepo": 32,
      "commitsBetweenForFile": 1,
      "actualSource": "private FunctionType createFunctionTypeFromNodes(@Nullable Node rValue, @Nullable String name, @Nullable JSDocInfo info, @Nullable Node lvalueNode) {\n    FunctionType functionType \u003d null;\n    if (rValue !\u003d null \u0026\u0026 rValue.isQualifiedName() \u0026\u0026 scope.isGlobal()) {\n        Var var \u003d scope.getVar(rValue.getQualifiedName());\n        if (var !\u003d null \u0026\u0026 var.getType() !\u003d null \u0026\u0026 var.getType().isFunctionType()) {\n            FunctionType aliasedType \u003d var.getType().toMaybeFunctionType();\n            if ((aliasedType.isConstructor() || aliasedType.isInterface()) \u0026\u0026 !aliasedType.isNativeObjectType()) {\n                functionType \u003d aliasedType;\n                if (name !\u003d null \u0026\u0026 scope.isGlobal()) {\n                    typeRegistry.declareType(name, functionType.getInstanceType());\n                }\n            }\n        }\n    }\n    if (functionType \u003d\u003d null) {\n        Node errorRoot \u003d rValue \u003d\u003d null ? lvalueNode : rValue;\n        boolean isFnLiteral \u003d rValue !\u003d null \u0026\u0026 rValue.isFunction();\n        Node fnRoot \u003d isFnLiteral ? rValue : null;\n        Node parametersNode \u003d isFnLiteral ? rValue.getFirstChild().getNext() : null;\n        Node fnBlock \u003d isFnLiteral ? parametersNode.getNext() : null;\n        if (info !\u003d null \u0026\u0026 info.hasType()) {\n            JSType type \u003d info.getType().evaluate(scope, typeRegistry);\n            type \u003d type.restrictByNotNullOrUndefined();\n            if (type.isFunctionType()) {\n                functionType \u003d type.toMaybeFunctionType();\n                functionType.setJSDocInfo(info);\n            }\n        }\n        if (functionType \u003d\u003d null) {\n            Node ownerNode \u003d NodeUtil.getBestLValueOwner(lvalueNode);\n            String ownerName \u003d NodeUtil.getBestLValueName(ownerNode);\n            Var ownerVar \u003d null;\n            String propName \u003d null;\n            ObjectType ownerType \u003d null;\n            if (ownerName !\u003d null) {\n                ownerVar \u003d scope.getVar(ownerName);\n                if (ownerVar !\u003d null) {\n                    ownerType \u003d ObjectType.cast(ownerVar.getType());\n                }\n                if (name !\u003d null) {\n                    propName \u003d name.substring(ownerName.length() + 1);\n                }\n            }\n            FunctionType overriddenPropType \u003d null;\n            if (ownerType !\u003d null \u0026\u0026 propName !\u003d null) {\n                overriddenPropType \u003d findOverriddenFunction(ownerType, propName);\n            }\n            FunctionTypeBuilder builder \u003d new FunctionTypeBuilder(name, compiler, errorRoot, sourceName, scope).setContents(getFunctionAnalysisResults(fnRoot)).inferFromOverriddenFunction(overriddenPropType, parametersNode).inferTemplateTypeName(info).inferReturnType(info).inferInheritance(info);\n            boolean searchedForThisType \u003d false;\n            if (ownerType !\u003d null \u0026\u0026 ownerType.isFunctionPrototypeType() \u0026\u0026 ownerType.getOwnerFunction().hasInstanceType()) {\n                builder.inferThisType(info, ownerType.getOwnerFunction().getInstanceType());\n                searchedForThisType \u003d true;\n            } else if (ownerNode !\u003d null \u0026\u0026 ownerNode.isThis()) {\n                JSType injectedThisType \u003d ownerNode.getJSType();\n                builder.inferThisType(info, injectedThisType \u003d\u003d null ? scope.getTypeOfThis() : injectedThisType);\n                searchedForThisType \u003d true;\n            }\n            if (!searchedForThisType) {\n                builder.inferThisType(info);\n            }\n            functionType \u003d builder.inferParameterTypes(parametersNode, info).buildAndRegister();\n        }\n    }\n    return functionType;\n}",
      "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
      "functionStartLine": 841,
      "functionName": "createFunctionTypeFromNodes",
      "functionAnnotation": "",
      "functionDoc": "Creates a new function type, based on the given nodes.\n\nThis handles two cases that are semantically very different, but\nare not mutually exclusive:\n- A function literal that needs a type attached to it.\n- An assignment expression with function-type info in the JsDoc.\n\nAll parameters are optional, and we will do the best we can to create\na function type.\n\nThis function will always create a function type, so only call it if\nyou\u0027re sure that\u0027s what you want.\n\n@param rValue The function node.\n@param name the function\u0027s name\n@param info the {@link JSDocInfo} attached to the function definition\n@param lvalueNode The node where this function is being\n    assigned. For example, {@code A.prototype.foo \u003d ...} would be used to\n    determine that this function is a method of A.prototype. May be\n    null to indicate that this is not being assigned to a qualified name.\n",
      "diff": "@@ -1,65 +1,65 @@\n private FunctionType createFunctionTypeFromNodes(@Nullable Node rValue, @Nullable String name, @Nullable JSDocInfo info, @Nullable Node lvalueNode) {\n     FunctionType functionType \u003d null;\n     if (rValue !\u003d null \u0026\u0026 rValue.isQualifiedName() \u0026\u0026 scope.isGlobal()) {\n         Var var \u003d scope.getVar(rValue.getQualifiedName());\n         if (var !\u003d null \u0026\u0026 var.getType() !\u003d null \u0026\u0026 var.getType().isFunctionType()) {\n             FunctionType aliasedType \u003d var.getType().toMaybeFunctionType();\n             if ((aliasedType.isConstructor() || aliasedType.isInterface()) \u0026\u0026 !aliasedType.isNativeObjectType()) {\n                 functionType \u003d aliasedType;\n                 if (name !\u003d null \u0026\u0026 scope.isGlobal()) {\n                     typeRegistry.declareType(name, functionType.getInstanceType());\n                 }\n             }\n         }\n     }\n     if (functionType \u003d\u003d null) {\n         Node errorRoot \u003d rValue \u003d\u003d null ? lvalueNode : rValue;\n         boolean isFnLiteral \u003d rValue !\u003d null \u0026\u0026 rValue.isFunction();\n         Node fnRoot \u003d isFnLiteral ? rValue : null;\n         Node parametersNode \u003d isFnLiteral ? rValue.getFirstChild().getNext() : null;\n         Node fnBlock \u003d isFnLiteral ? parametersNode.getNext() : null;\n         if (info !\u003d null \u0026\u0026 info.hasType()) {\n             JSType type \u003d info.getType().evaluate(scope, typeRegistry);\n             type \u003d type.restrictByNotNullOrUndefined();\n             if (type.isFunctionType()) {\n                 functionType \u003d type.toMaybeFunctionType();\n                 functionType.setJSDocInfo(info);\n             }\n         }\n         if (functionType \u003d\u003d null) {\n             Node ownerNode \u003d NodeUtil.getBestLValueOwner(lvalueNode);\n             String ownerName \u003d NodeUtil.getBestLValueName(ownerNode);\n             Var ownerVar \u003d null;\n             String propName \u003d null;\n             ObjectType ownerType \u003d null;\n             if (ownerName !\u003d null) {\n                 ownerVar \u003d scope.getVar(ownerName);\n                 if (ownerVar !\u003d null) {\n                     ownerType \u003d ObjectType.cast(ownerVar.getType());\n                 }\n                 if (name !\u003d null) {\n                     propName \u003d name.substring(ownerName.length() + 1);\n                 }\n             }\n             FunctionType overriddenPropType \u003d null;\n             if (ownerType !\u003d null \u0026\u0026 propName !\u003d null) {\n                 overriddenPropType \u003d findOverriddenFunction(ownerType, propName);\n             }\n             FunctionTypeBuilder builder \u003d new FunctionTypeBuilder(name, compiler, errorRoot, sourceName, scope).setContents(getFunctionAnalysisResults(fnRoot)).inferFromOverriddenFunction(overriddenPropType, parametersNode).inferTemplateTypeName(info).inferReturnType(info).inferInheritance(info);\n             boolean searchedForThisType \u003d false;\n-            if (ownerType !\u003d null \u0026\u0026 ownerType.isFunctionPrototypeType()) {\n+            if (ownerType !\u003d null \u0026\u0026 ownerType.isFunctionPrototypeType() \u0026\u0026 ownerType.getOwnerFunction().hasInstanceType()) {\n                 builder.inferThisType(info, ownerType.getOwnerFunction().getInstanceType());\n                 searchedForThisType \u003d true;\n             } else if (ownerNode !\u003d null \u0026\u0026 ownerNode.isThis()) {\n                 JSType injectedThisType \u003d ownerNode.getJSType();\n                 builder.inferThisType(info, injectedThisType \u003d\u003d null ? scope.getTypeOfThis() : injectedThisType);\n                 searchedForThisType \u003d true;\n             }\n             if (!searchedForThisType) {\n                 builder.inferThisType(info);\n             }\n             functionType \u003d builder.inferParameterTypes(parametersNode, info).buildAndRegister();\n         }\n     }\n     return functionType;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8d91f37d29abd8682e298a23f63b96f2f2def659": {
      "type": "Ybodychange",
      "commitMessage": "\nImprove inference for functions defined in constructors\n\nFixes issue 765\n\nR\u003dacleung\nDELTA\u003d132  (88 added, 20 deleted, 24 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d5093\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2070 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "6/27/12, 3:57 PM",
      "commitName": "8d91f37d29abd8682e298a23f63b96f2f2def659",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "5/23/12, 9:49 AM",
      "commitNameOld": "59aac0b247db74ec7047132f368953935edd81b8",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 35.26,
      "commitsBetweenForRepo": 78,
      "commitsBetweenForFile": 1,
      "actualSource": "private FunctionType createFunctionTypeFromNodes(@Nullable Node rValue, @Nullable String name, @Nullable JSDocInfo info, @Nullable Node lvalueNode) {\n    FunctionType functionType \u003d null;\n    if (rValue !\u003d null \u0026\u0026 rValue.isQualifiedName() \u0026\u0026 scope.isGlobal()) {\n        Var var \u003d scope.getVar(rValue.getQualifiedName());\n        if (var !\u003d null \u0026\u0026 var.getType() !\u003d null \u0026\u0026 var.getType().isFunctionType()) {\n            FunctionType aliasedType \u003d var.getType().toMaybeFunctionType();\n            if ((aliasedType.isConstructor() || aliasedType.isInterface()) \u0026\u0026 !aliasedType.isNativeObjectType()) {\n                functionType \u003d aliasedType;\n                if (name !\u003d null \u0026\u0026 scope.isGlobal()) {\n                    typeRegistry.declareType(name, functionType.getInstanceType());\n                }\n            }\n        }\n    }\n    if (functionType \u003d\u003d null) {\n        Node errorRoot \u003d rValue \u003d\u003d null ? lvalueNode : rValue;\n        boolean isFnLiteral \u003d rValue !\u003d null \u0026\u0026 rValue.isFunction();\n        Node fnRoot \u003d isFnLiteral ? rValue : null;\n        Node parametersNode \u003d isFnLiteral ? rValue.getFirstChild().getNext() : null;\n        Node fnBlock \u003d isFnLiteral ? parametersNode.getNext() : null;\n        if (info !\u003d null \u0026\u0026 info.hasType()) {\n            JSType type \u003d info.getType().evaluate(scope, typeRegistry);\n            type \u003d type.restrictByNotNullOrUndefined();\n            if (type.isFunctionType()) {\n                functionType \u003d type.toMaybeFunctionType();\n                functionType.setJSDocInfo(info);\n            }\n        }\n        if (functionType \u003d\u003d null) {\n            Node ownerNode \u003d NodeUtil.getBestLValueOwner(lvalueNode);\n            String ownerName \u003d NodeUtil.getBestLValueName(ownerNode);\n            Var ownerVar \u003d null;\n            String propName \u003d null;\n            ObjectType ownerType \u003d null;\n            if (ownerName !\u003d null) {\n                ownerVar \u003d scope.getVar(ownerName);\n                if (ownerVar !\u003d null) {\n                    ownerType \u003d ObjectType.cast(ownerVar.getType());\n                }\n                if (name !\u003d null) {\n                    propName \u003d name.substring(ownerName.length() + 1);\n                }\n            }\n            FunctionType overriddenPropType \u003d null;\n            if (ownerType !\u003d null \u0026\u0026 propName !\u003d null) {\n                overriddenPropType \u003d findOverriddenFunction(ownerType, propName);\n            }\n            FunctionTypeBuilder builder \u003d new FunctionTypeBuilder(name, compiler, errorRoot, sourceName, scope).setContents(getFunctionAnalysisResults(fnRoot)).inferFromOverriddenFunction(overriddenPropType, parametersNode).inferTemplateTypeName(info).inferReturnType(info).inferInheritance(info);\n            boolean searchedForThisType \u003d false;\n            if (ownerType !\u003d null \u0026\u0026 ownerType.isFunctionPrototypeType()) {\n                builder.inferThisType(info, ownerType.getOwnerFunction().getInstanceType());\n                searchedForThisType \u003d true;\n            } else if (ownerNode !\u003d null \u0026\u0026 ownerNode.isThis()) {\n                JSType injectedThisType \u003d ownerNode.getJSType();\n                builder.inferThisType(info, injectedThisType \u003d\u003d null ? scope.getTypeOfThis() : injectedThisType);\n                searchedForThisType \u003d true;\n            }\n            if (!searchedForThisType) {\n                builder.inferThisType(info);\n            }\n            functionType \u003d builder.inferParameterTypes(parametersNode, info).buildAndRegister();\n        }\n    }\n    return functionType;\n}",
      "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
      "functionStartLine": 841,
      "functionName": "createFunctionTypeFromNodes",
      "functionAnnotation": "",
      "functionDoc": "Creates a new function type, based on the given nodes.\n\nThis handles two cases that are semantically very different, but\nare not mutually exclusive:\n- A function literal that needs a type attached to it.\n- An assignment expression with function-type info in the JsDoc.\n\nAll parameters are optional, and we will do the best we can to create\na function type.\n\nThis function will always create a function type, so only call it if\nyou\u0027re sure that\u0027s what you want.\n\n@param rValue The function node.\n@param name the function\u0027s name\n@param info the {@link JSDocInfo} attached to the function definition\n@param lvalueNode The node where this function is being\n    assigned. For example, {@code A.prototype.foo \u003d ...} would be used to\n    determine that this function is a method of A.prototype. May be\n    null to indicate that this is not being assigned to a qualified name.\n",
      "diff": "@@ -1,64 +1,65 @@\n private FunctionType createFunctionTypeFromNodes(@Nullable Node rValue, @Nullable String name, @Nullable JSDocInfo info, @Nullable Node lvalueNode) {\n     FunctionType functionType \u003d null;\n     if (rValue !\u003d null \u0026\u0026 rValue.isQualifiedName() \u0026\u0026 scope.isGlobal()) {\n         Var var \u003d scope.getVar(rValue.getQualifiedName());\n         if (var !\u003d null \u0026\u0026 var.getType() !\u003d null \u0026\u0026 var.getType().isFunctionType()) {\n             FunctionType aliasedType \u003d var.getType().toMaybeFunctionType();\n             if ((aliasedType.isConstructor() || aliasedType.isInterface()) \u0026\u0026 !aliasedType.isNativeObjectType()) {\n                 functionType \u003d aliasedType;\n                 if (name !\u003d null \u0026\u0026 scope.isGlobal()) {\n                     typeRegistry.declareType(name, functionType.getInstanceType());\n                 }\n             }\n         }\n     }\n     if (functionType \u003d\u003d null) {\n         Node errorRoot \u003d rValue \u003d\u003d null ? lvalueNode : rValue;\n         boolean isFnLiteral \u003d rValue !\u003d null \u0026\u0026 rValue.isFunction();\n         Node fnRoot \u003d isFnLiteral ? rValue : null;\n         Node parametersNode \u003d isFnLiteral ? rValue.getFirstChild().getNext() : null;\n         Node fnBlock \u003d isFnLiteral ? parametersNode.getNext() : null;\n         if (info !\u003d null \u0026\u0026 info.hasType()) {\n             JSType type \u003d info.getType().evaluate(scope, typeRegistry);\n             type \u003d type.restrictByNotNullOrUndefined();\n             if (type.isFunctionType()) {\n                 functionType \u003d type.toMaybeFunctionType();\n                 functionType.setJSDocInfo(info);\n             }\n         }\n         if (functionType \u003d\u003d null) {\n             Node ownerNode \u003d NodeUtil.getBestLValueOwner(lvalueNode);\n             String ownerName \u003d NodeUtil.getBestLValueName(ownerNode);\n             Var ownerVar \u003d null;\n             String propName \u003d null;\n             ObjectType ownerType \u003d null;\n             if (ownerName !\u003d null) {\n                 ownerVar \u003d scope.getVar(ownerName);\n                 if (ownerVar !\u003d null) {\n                     ownerType \u003d ObjectType.cast(ownerVar.getType());\n                 }\n                 if (name !\u003d null) {\n                     propName \u003d name.substring(ownerName.length() + 1);\n                 }\n             }\n             FunctionType overriddenPropType \u003d null;\n             if (ownerType !\u003d null \u0026\u0026 propName !\u003d null) {\n                 overriddenPropType \u003d findOverriddenFunction(ownerType, propName);\n             }\n             FunctionTypeBuilder builder \u003d new FunctionTypeBuilder(name, compiler, errorRoot, sourceName, scope).setContents(getFunctionAnalysisResults(fnRoot)).inferFromOverriddenFunction(overriddenPropType, parametersNode).inferTemplateTypeName(info).inferReturnType(info).inferInheritance(info);\n             boolean searchedForThisType \u003d false;\n             if (ownerType !\u003d null \u0026\u0026 ownerType.isFunctionPrototypeType()) {\n                 builder.inferThisType(info, ownerType.getOwnerFunction().getInstanceType());\n                 searchedForThisType \u003d true;\n             } else if (ownerNode !\u003d null \u0026\u0026 ownerNode.isThis()) {\n-                builder.inferThisType(info, ownerNode.getJSType());\n+                JSType injectedThisType \u003d ownerNode.getJSType();\n+                builder.inferThisType(info, injectedThisType \u003d\u003d null ? scope.getTypeOfThis() : injectedThisType);\n                 searchedForThisType \u003d true;\n             }\n             if (!searchedForThisType) {\n                 builder.inferThisType(info);\n             }\n             functionType \u003d builder.inferParameterTypes(parametersNode, info).buildAndRegister();\n         }\n     }\n     return functionType;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "70a5626922ea7e8c98747e22b6986638ba38fadc": {
      "type": "Ydocchange",
      "commitMessage": "\nFix various typos, spelling and grammar errors.\nFixes issue 734. \nContributed by Robert Gust Bardon\n\nR\u003dnicksantos\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d4827\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1979 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "5/18/12, 11:09 AM",
      "commitName": "70a5626922ea7e8c98747e22b6986638ba38fadc",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "4/25/12, 1:34 PM",
      "commitNameOld": "f412f0c0efd54842b30207c845d65cb826217fd6",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 22.9,
      "commitsBetweenForRepo": 51,
      "commitsBetweenForFile": 1,
      "actualSource": "private FunctionType createFunctionTypeFromNodes(@Nullable Node rValue, @Nullable String name, @Nullable JSDocInfo info, @Nullable Node lvalueNode) {\n    FunctionType functionType \u003d null;\n    if (rValue !\u003d null \u0026\u0026 rValue.isQualifiedName() \u0026\u0026 scope.isGlobal()) {\n        Var var \u003d scope.getVar(rValue.getQualifiedName());\n        if (var !\u003d null \u0026\u0026 var.getType() !\u003d null \u0026\u0026 var.getType().isFunctionType()) {\n            FunctionType aliasedType \u003d var.getType().toMaybeFunctionType();\n            if ((aliasedType.isConstructor() || aliasedType.isInterface()) \u0026\u0026 !aliasedType.isNativeObjectType()) {\n                functionType \u003d aliasedType;\n                if (name !\u003d null \u0026\u0026 scope.isGlobal()) {\n                    typeRegistry.declareType(name, functionType.getInstanceType());\n                }\n            }\n        }\n    }\n    if (functionType \u003d\u003d null) {\n        Node errorRoot \u003d rValue \u003d\u003d null ? lvalueNode : rValue;\n        boolean isFnLiteral \u003d rValue !\u003d null \u0026\u0026 rValue.isFunction();\n        Node fnRoot \u003d isFnLiteral ? rValue : null;\n        Node parametersNode \u003d isFnLiteral ? rValue.getFirstChild().getNext() : null;\n        Node fnBlock \u003d isFnLiteral ? parametersNode.getNext() : null;\n        if (info !\u003d null \u0026\u0026 info.hasType()) {\n            JSType type \u003d info.getType().evaluate(scope, typeRegistry);\n            type \u003d type.restrictByNotNullOrUndefined();\n            if (type.isFunctionType()) {\n                functionType \u003d type.toMaybeFunctionType();\n                functionType.setJSDocInfo(info);\n            }\n        }\n        if (functionType \u003d\u003d null) {\n            Node ownerNode \u003d NodeUtil.getBestLValueOwner(lvalueNode);\n            String ownerName \u003d NodeUtil.getBestLValueName(ownerNode);\n            Var ownerVar \u003d null;\n            String propName \u003d null;\n            ObjectType ownerType \u003d null;\n            if (ownerName !\u003d null) {\n                ownerVar \u003d scope.getVar(ownerName);\n                if (ownerVar !\u003d null) {\n                    ownerType \u003d ObjectType.cast(ownerVar.getType());\n                }\n                if (name !\u003d null) {\n                    propName \u003d name.substring(ownerName.length() + 1);\n                }\n            }\n            FunctionType overriddenPropType \u003d null;\n            if (ownerType !\u003d null \u0026\u0026 propName !\u003d null) {\n                overriddenPropType \u003d findOverriddenFunction(ownerType, propName);\n            }\n            FunctionTypeBuilder builder \u003d new FunctionTypeBuilder(name, compiler, errorRoot, sourceName, scope).setContents(getFunctionAnalysisResults(fnRoot)).inferFromOverriddenFunction(overriddenPropType, parametersNode).inferTemplateTypeName(info).inferReturnType(info).inferInheritance(info);\n            boolean searchedForThisType \u003d false;\n            if (ownerType !\u003d null \u0026\u0026 ownerType.isFunctionPrototypeType()) {\n                builder.inferThisType(info, ownerType.getOwnerFunction().getInstanceType());\n                searchedForThisType \u003d true;\n            } else if (ownerNode !\u003d null \u0026\u0026 ownerNode.isThis()) {\n                builder.inferThisType(info, ownerNode.getJSType());\n                searchedForThisType \u003d true;\n            }\n            if (!searchedForThisType) {\n                builder.inferThisType(info);\n            }\n            functionType \u003d builder.inferParameterTypes(parametersNode, info).buildAndRegister();\n        }\n    }\n    return functionType;\n}",
      "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
      "functionStartLine": 841,
      "functionName": "createFunctionTypeFromNodes",
      "functionAnnotation": "",
      "functionDoc": "Creates a new function type, based on the given nodes.\n\nThis handles two cases that are semantically very different, but\nare not mutually exclusive:\n- A function literal that needs a type attached to it.\n- An assignment expression with function-type info in the JsDoc.\n\nAll parameters are optional, and we will do the best we can to create\na function type.\n\nThis function will always create a function type, so only call it if\nyou\u0027re sure that\u0027s what you want.\n\n@param rValue The function node.\n@param name the function\u0027s name\n@param info the {@link JSDocInfo} attached to the function definition\n@param lvalueNode The node where this function is being\n    assigned. For example, {@code A.prototype.foo \u003d ...} would be used to\n    determine that this function is a method of A.prototype. May be\n    null to indicate that this is not being assigned to a qualified name.\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "Creates a new function type, based on the given nodes.\n\nThis handles two cases that are semantically very different, but\nare not mutually exclusive:\n- A function literal that needs a type attached to it.\n- An assignment expression with function-type info in the jsdoc.\n\nAll parameters are optional, and we will do the best we can to create\na function type.\n\nThis function will always create a function type, so only call it if\nyou\u0027re sure that\u0027s what you want.\n\n@param rValue The function node.\n@param name the function\u0027s name\n@param info the {@link JSDocInfo} attached to the function definition\n@param lvalueNode The node where this function is being\n    assigned. For example, {@code A.prototype.foo \u003d ...} would be used to\n    determine that this function is a method of A.prototype. May be\n    null to indicate that this is not being assigned to a qualified name.\n",
        "newValue": "Creates a new function type, based on the given nodes.\n\nThis handles two cases that are semantically very different, but\nare not mutually exclusive:\n- A function literal that needs a type attached to it.\n- An assignment expression with function-type info in the JsDoc.\n\nAll parameters are optional, and we will do the best we can to create\na function type.\n\nThis function will always create a function type, so only call it if\nyou\u0027re sure that\u0027s what you want.\n\n@param rValue The function node.\n@param name the function\u0027s name\n@param info the {@link JSDocInfo} attached to the function definition\n@param lvalueNode The node where this function is being\n    assigned. For example, {@code A.prototype.foo \u003d ...} would be used to\n    determine that this function is a method of A.prototype. May be\n    null to indicate that this is not being assigned to a qualified name.\n"
      }
    },
    "ec324a9bb23eb78c76f537f4c4170ba88d542f1c": {
      "type": "Ybodychange",
      "commitMessage": "\nReplace the bulk of the Node.getType() \u003d\u003d Token.XXX calls with\nNode.isXXX calls.\n\nR\u003dnicksantos\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3677\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1582 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/10/11, 8:36 AM",
      "commitName": "ec324a9bb23eb78c76f537f4c4170ba88d542f1c",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "11/9/11, 2:45 PM",
      "commitNameOld": "103bd46736cbbbabe6ad27ab11da10d6dbb1a8e5",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 0.74,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "private FunctionType createFunctionTypeFromNodes(@Nullable Node rValue, @Nullable String name, @Nullable JSDocInfo info, @Nullable Node lvalueNode) {\n    FunctionType functionType \u003d null;\n    if (rValue !\u003d null \u0026\u0026 rValue.isQualifiedName() \u0026\u0026 scope.isGlobal()) {\n        Var var \u003d scope.getVar(rValue.getQualifiedName());\n        if (var !\u003d null \u0026\u0026 var.getType() !\u003d null \u0026\u0026 var.getType().isFunctionType()) {\n            FunctionType aliasedType \u003d var.getType().toMaybeFunctionType();\n            if ((aliasedType.isConstructor() || aliasedType.isInterface()) \u0026\u0026 !aliasedType.isNativeObjectType()) {\n                functionType \u003d aliasedType;\n                if (name !\u003d null \u0026\u0026 scope.isGlobal()) {\n                    typeRegistry.declareType(name, functionType.getInstanceType());\n                }\n            }\n        }\n    }\n    if (functionType \u003d\u003d null) {\n        Node errorRoot \u003d rValue \u003d\u003d null ? lvalueNode : rValue;\n        boolean isFnLiteral \u003d rValue !\u003d null \u0026\u0026 rValue.isFunction();\n        Node fnRoot \u003d isFnLiteral ? rValue : null;\n        Node parametersNode \u003d isFnLiteral ? rValue.getFirstChild().getNext() : null;\n        Node fnBlock \u003d isFnLiteral ? parametersNode.getNext() : null;\n        if (info !\u003d null \u0026\u0026 info.hasType()) {\n            JSType type \u003d info.getType().evaluate(scope, typeRegistry);\n            type \u003d type.restrictByNotNullOrUndefined();\n            if (type.isFunctionType()) {\n                functionType \u003d type.toMaybeFunctionType();\n                functionType.setJSDocInfo(info);\n            }\n        }\n        if (functionType \u003d\u003d null) {\n            Node ownerNode \u003d NodeUtil.getBestLValueOwner(lvalueNode);\n            String ownerName \u003d NodeUtil.getBestLValueName(ownerNode);\n            Var ownerVar \u003d null;\n            String propName \u003d null;\n            ObjectType ownerType \u003d null;\n            if (ownerName !\u003d null) {\n                ownerVar \u003d scope.getVar(ownerName);\n                if (ownerVar !\u003d null) {\n                    ownerType \u003d ObjectType.cast(ownerVar.getType());\n                }\n                if (name !\u003d null) {\n                    propName \u003d name.substring(ownerName.length() + 1);\n                }\n            }\n            FunctionType overriddenPropType \u003d null;\n            if (ownerType !\u003d null \u0026\u0026 propName !\u003d null) {\n                overriddenPropType \u003d findOverriddenFunction(ownerType, propName);\n            }\n            FunctionTypeBuilder builder \u003d new FunctionTypeBuilder(name, compiler, errorRoot, sourceName, scope).setContents(getFunctionAnalysisResults(fnRoot)).inferFromOverriddenFunction(overriddenPropType, parametersNode).inferTemplateTypeName(info).inferReturnType(info).inferInheritance(info);\n            boolean searchedForThisType \u003d false;\n            if (ownerType !\u003d null \u0026\u0026 ownerType.isFunctionPrototypeType()) {\n                builder.inferThisType(info, ownerType.getOwnerFunction().getInstanceType());\n                searchedForThisType \u003d true;\n            } else if (ownerNode !\u003d null \u0026\u0026 ownerNode.isThis()) {\n                builder.inferThisType(info, ownerNode.getJSType());\n                searchedForThisType \u003d true;\n            }\n            if (!searchedForThisType) {\n                builder.inferThisType(info);\n            }\n            functionType \u003d builder.inferParameterTypes(parametersNode, info).buildAndRegister();\n        }\n    }\n    return functionType;\n}",
      "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
      "functionStartLine": 813,
      "functionName": "createFunctionTypeFromNodes",
      "functionAnnotation": "",
      "functionDoc": "Creates a new function type, based on the given nodes.\n\nThis handles two cases that are semantically very different, but\nare not mutually exclusive:\n- A function literal that needs a type attached to it.\n- An assignment expression with function-type info in the jsdoc.\n\nAll parameters are optional, and we will do the best we can to create\na function type.\n\nThis function will always create a function type, so only call it if\nyou\u0027re sure that\u0027s what you want.\n\n@param rValue The function node.\n@param name the function\u0027s name\n@param info the {@link JSDocInfo} attached to the function definition\n@param lvalueNode The node where this function is being\n    assigned. For example, {@code A.prototype.foo \u003d ...} would be used to\n    determine that this function is a method of A.prototype. May be\n    null to indicate that this is not being assigned to a qualified name.\n",
      "diff": "@@ -1,64 +1,64 @@\n private FunctionType createFunctionTypeFromNodes(@Nullable Node rValue, @Nullable String name, @Nullable JSDocInfo info, @Nullable Node lvalueNode) {\n     FunctionType functionType \u003d null;\n     if (rValue !\u003d null \u0026\u0026 rValue.isQualifiedName() \u0026\u0026 scope.isGlobal()) {\n         Var var \u003d scope.getVar(rValue.getQualifiedName());\n         if (var !\u003d null \u0026\u0026 var.getType() !\u003d null \u0026\u0026 var.getType().isFunctionType()) {\n             FunctionType aliasedType \u003d var.getType().toMaybeFunctionType();\n             if ((aliasedType.isConstructor() || aliasedType.isInterface()) \u0026\u0026 !aliasedType.isNativeObjectType()) {\n                 functionType \u003d aliasedType;\n                 if (name !\u003d null \u0026\u0026 scope.isGlobal()) {\n                     typeRegistry.declareType(name, functionType.getInstanceType());\n                 }\n             }\n         }\n     }\n     if (functionType \u003d\u003d null) {\n         Node errorRoot \u003d rValue \u003d\u003d null ? lvalueNode : rValue;\n-        boolean isFnLiteral \u003d rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.FUNCTION;\n+        boolean isFnLiteral \u003d rValue !\u003d null \u0026\u0026 rValue.isFunction();\n         Node fnRoot \u003d isFnLiteral ? rValue : null;\n         Node parametersNode \u003d isFnLiteral ? rValue.getFirstChild().getNext() : null;\n         Node fnBlock \u003d isFnLiteral ? parametersNode.getNext() : null;\n         if (info !\u003d null \u0026\u0026 info.hasType()) {\n             JSType type \u003d info.getType().evaluate(scope, typeRegistry);\n             type \u003d type.restrictByNotNullOrUndefined();\n             if (type.isFunctionType()) {\n                 functionType \u003d type.toMaybeFunctionType();\n                 functionType.setJSDocInfo(info);\n             }\n         }\n         if (functionType \u003d\u003d null) {\n             Node ownerNode \u003d NodeUtil.getBestLValueOwner(lvalueNode);\n             String ownerName \u003d NodeUtil.getBestLValueName(ownerNode);\n             Var ownerVar \u003d null;\n             String propName \u003d null;\n             ObjectType ownerType \u003d null;\n             if (ownerName !\u003d null) {\n                 ownerVar \u003d scope.getVar(ownerName);\n                 if (ownerVar !\u003d null) {\n                     ownerType \u003d ObjectType.cast(ownerVar.getType());\n                 }\n                 if (name !\u003d null) {\n                     propName \u003d name.substring(ownerName.length() + 1);\n                 }\n             }\n             FunctionType overriddenPropType \u003d null;\n             if (ownerType !\u003d null \u0026\u0026 propName !\u003d null) {\n                 overriddenPropType \u003d findOverriddenFunction(ownerType, propName);\n             }\n             FunctionTypeBuilder builder \u003d new FunctionTypeBuilder(name, compiler, errorRoot, sourceName, scope).setContents(getFunctionAnalysisResults(fnRoot)).inferFromOverriddenFunction(overriddenPropType, parametersNode).inferTemplateTypeName(info).inferReturnType(info).inferInheritance(info);\n             boolean searchedForThisType \u003d false;\n             if (ownerType !\u003d null \u0026\u0026 ownerType.isFunctionPrototypeType()) {\n                 builder.inferThisType(info, ownerType.getOwnerFunction().getInstanceType());\n                 searchedForThisType \u003d true;\n-            } else if (ownerNode !\u003d null \u0026\u0026 ownerNode.getType() \u003d\u003d Token.THIS) {\n+            } else if (ownerNode !\u003d null \u0026\u0026 ownerNode.isThis()) {\n                 builder.inferThisType(info, ownerNode.getJSType());\n                 searchedForThisType \u003d true;\n             }\n             if (!searchedForThisType) {\n                 builder.inferThisType(info);\n             }\n             functionType \u003d builder.inferParameterTypes(parametersNode, info).buildAndRegister();\n         }\n     }\n     return functionType;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "dff730a3759cad9c491f72d9905eee93962d3d35": {
      "type": "Ybodychange",
      "commitMessage": "\nBreak out basic function analysis into a separate pass, rather\nthan trying to do it as we go.\nThere should be no functional change, but this should make it\na lot easier to move things around in the future.\n\nR\u003dacleung\nDELTA\u003d332  (224 added, 89 deleted, 19 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3318\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1460 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "9/21/11, 5:18 PM",
      "commitName": "dff730a3759cad9c491f72d9905eee93962d3d35",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "9/14/11, 2:04 PM",
      "commitNameOld": "87a4a3c27a5e60e95df3ec398272d499d9915b56",
      "commitAuthorOld": "tylerg@google.com",
      "daysBetweenCommits": 7.13,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "actualSource": "private FunctionType createFunctionTypeFromNodes(@Nullable Node rValue, @Nullable String name, @Nullable JSDocInfo info, @Nullable Node lvalueNode) {\n    FunctionType functionType \u003d null;\n    if (rValue !\u003d null \u0026\u0026 rValue.isQualifiedName() \u0026\u0026 scope.isGlobal()) {\n        Var var \u003d scope.getVar(rValue.getQualifiedName());\n        if (var !\u003d null \u0026\u0026 var.getType() !\u003d null \u0026\u0026 var.getType().isFunctionType()) {\n            FunctionType aliasedType \u003d var.getType().toMaybeFunctionType();\n            if ((aliasedType.isConstructor() || aliasedType.isInterface()) \u0026\u0026 !aliasedType.isNativeObjectType()) {\n                functionType \u003d aliasedType;\n                if (name !\u003d null \u0026\u0026 scope.isGlobal()) {\n                    typeRegistry.declareType(name, functionType.getInstanceType());\n                }\n            }\n        }\n    }\n    if (functionType \u003d\u003d null) {\n        Node errorRoot \u003d rValue \u003d\u003d null ? lvalueNode : rValue;\n        boolean isFnLiteral \u003d rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.FUNCTION;\n        Node fnRoot \u003d isFnLiteral ? rValue : null;\n        Node parametersNode \u003d isFnLiteral ? rValue.getFirstChild().getNext() : null;\n        Node fnBlock \u003d isFnLiteral ? parametersNode.getNext() : null;\n        if (info !\u003d null \u0026\u0026 info.hasType()) {\n            JSType type \u003d info.getType().evaluate(scope, typeRegistry);\n            type \u003d type.restrictByNotNullOrUndefined();\n            if (type.isFunctionType()) {\n                functionType \u003d type.toMaybeFunctionType();\n                functionType.setJSDocInfo(info);\n            }\n        }\n        if (functionType \u003d\u003d null) {\n            Node ownerNode \u003d NodeUtil.getBestLValueOwner(lvalueNode);\n            String ownerName \u003d NodeUtil.getBestLValueName(ownerNode);\n            Var ownerVar \u003d null;\n            String propName \u003d null;\n            ObjectType ownerType \u003d null;\n            if (ownerName !\u003d null) {\n                ownerVar \u003d scope.getVar(ownerName);\n                if (ownerVar !\u003d null) {\n                    ownerType \u003d ObjectType.cast(ownerVar.getType());\n                }\n                if (name !\u003d null) {\n                    propName \u003d name.substring(ownerName.length() + 1);\n                }\n            }\n            FunctionType overriddenPropType \u003d null;\n            if (ownerType !\u003d null \u0026\u0026 propName !\u003d null) {\n                overriddenPropType \u003d findOverriddenFunction(ownerType, propName);\n            }\n            FunctionTypeBuilder builder \u003d new FunctionTypeBuilder(name, compiler, errorRoot, sourceName, scope).setContents(getFunctionAnalysisResults(fnRoot)).inferFromOverriddenFunction(overriddenPropType, parametersNode).inferTemplateTypeName(info).inferReturnType(info).inferInheritance(info);\n            boolean searchedForThisType \u003d false;\n            if (ownerType !\u003d null \u0026\u0026 ownerType.isFunctionPrototypeType()) {\n                builder.inferThisType(info, ownerType.getOwnerFunction().getInstanceType());\n                searchedForThisType \u003d true;\n            } else if (ownerNode !\u003d null \u0026\u0026 ownerNode.getType() \u003d\u003d Token.THIS) {\n                builder.inferThisType(info, ownerNode.getJSType());\n                searchedForThisType \u003d true;\n            }\n            if (!searchedForThisType) {\n                builder.inferThisType(info);\n            }\n            functionType \u003d builder.inferParameterTypes(parametersNode, info).buildAndRegister();\n        }\n    }\n    return functionType;\n}",
      "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
      "functionStartLine": 811,
      "functionName": "createFunctionTypeFromNodes",
      "functionAnnotation": "",
      "functionDoc": "Creates a new function type, based on the given nodes.\n\nThis handles two cases that are semantically very different, but\nare not mutually exclusive:\n- A function literal that needs a type attached to it.\n- An assignment expression with function-type info in the jsdoc.\n\nAll parameters are optional, and we will do the best we can to create\na function type.\n\nThis function will always create a function type, so only call it if\nyou\u0027re sure that\u0027s what you want.\n\n@param rValue The function node.\n@param name the function\u0027s name\n@param info the {@link JSDocInfo} attached to the function definition\n@param lvalueNode The node where this function is being\n    assigned. For example, {@code A.prototype.foo \u003d ...} would be used to\n    determine that this function is a method of A.prototype. May be\n    null to indicate that this is not being assigned to a qualified name.\n",
      "diff": "@@ -1,64 +1,64 @@\n private FunctionType createFunctionTypeFromNodes(@Nullable Node rValue, @Nullable String name, @Nullable JSDocInfo info, @Nullable Node lvalueNode) {\n     FunctionType functionType \u003d null;\n     if (rValue !\u003d null \u0026\u0026 rValue.isQualifiedName() \u0026\u0026 scope.isGlobal()) {\n         Var var \u003d scope.getVar(rValue.getQualifiedName());\n         if (var !\u003d null \u0026\u0026 var.getType() !\u003d null \u0026\u0026 var.getType().isFunctionType()) {\n             FunctionType aliasedType \u003d var.getType().toMaybeFunctionType();\n             if ((aliasedType.isConstructor() || aliasedType.isInterface()) \u0026\u0026 !aliasedType.isNativeObjectType()) {\n                 functionType \u003d aliasedType;\n                 if (name !\u003d null \u0026\u0026 scope.isGlobal()) {\n                     typeRegistry.declareType(name, functionType.getInstanceType());\n                 }\n             }\n         }\n     }\n     if (functionType \u003d\u003d null) {\n         Node errorRoot \u003d rValue \u003d\u003d null ? lvalueNode : rValue;\n         boolean isFnLiteral \u003d rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.FUNCTION;\n         Node fnRoot \u003d isFnLiteral ? rValue : null;\n         Node parametersNode \u003d isFnLiteral ? rValue.getFirstChild().getNext() : null;\n         Node fnBlock \u003d isFnLiteral ? parametersNode.getNext() : null;\n         if (info !\u003d null \u0026\u0026 info.hasType()) {\n             JSType type \u003d info.getType().evaluate(scope, typeRegistry);\n             type \u003d type.restrictByNotNullOrUndefined();\n             if (type.isFunctionType()) {\n                 functionType \u003d type.toMaybeFunctionType();\n                 functionType.setJSDocInfo(info);\n             }\n         }\n         if (functionType \u003d\u003d null) {\n             Node ownerNode \u003d NodeUtil.getBestLValueOwner(lvalueNode);\n             String ownerName \u003d NodeUtil.getBestLValueName(ownerNode);\n             Var ownerVar \u003d null;\n             String propName \u003d null;\n             ObjectType ownerType \u003d null;\n             if (ownerName !\u003d null) {\n                 ownerVar \u003d scope.getVar(ownerName);\n                 if (ownerVar !\u003d null) {\n                     ownerType \u003d ObjectType.cast(ownerVar.getType());\n                 }\n                 if (name !\u003d null) {\n                     propName \u003d name.substring(ownerName.length() + 1);\n                 }\n             }\n             FunctionType overriddenPropType \u003d null;\n             if (ownerType !\u003d null \u0026\u0026 propName !\u003d null) {\n                 overriddenPropType \u003d findOverriddenFunction(ownerType, propName);\n             }\n-            FunctionTypeBuilder builder \u003d new FunctionTypeBuilder(name, compiler, errorRoot, sourceName, scope).setSourceNode(fnRoot).inferFromOverriddenFunction(overriddenPropType, parametersNode).inferTemplateTypeName(info).inferReturnType(info).inferInheritance(info);\n+            FunctionTypeBuilder builder \u003d new FunctionTypeBuilder(name, compiler, errorRoot, sourceName, scope).setContents(getFunctionAnalysisResults(fnRoot)).inferFromOverriddenFunction(overriddenPropType, parametersNode).inferTemplateTypeName(info).inferReturnType(info).inferInheritance(info);\n             boolean searchedForThisType \u003d false;\n             if (ownerType !\u003d null \u0026\u0026 ownerType.isFunctionPrototypeType()) {\n                 builder.inferThisType(info, ownerType.getOwnerFunction().getInstanceType());\n                 searchedForThisType \u003d true;\n             } else if (ownerNode !\u003d null \u0026\u0026 ownerNode.getType() \u003d\u003d Token.THIS) {\n                 builder.inferThisType(info, ownerNode.getJSType());\n                 searchedForThisType \u003d true;\n             }\n             if (!searchedForThisType) {\n                 builder.inferThisType(info);\n             }\n-            functionType \u003d builder.inferParameterTypes(parametersNode, info).inferReturnStatementsAsLastResort(fnBlock).buildAndRegister();\n+            functionType \u003d builder.inferParameterTypes(parametersNode, info).buildAndRegister();\n         }\n     }\n     return functionType;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a2dd1662d90524a12a99a9fa7d4308568938d963": {
      "type": "Ybodychange",
      "commitMessage": "\nDo much better at \"this\" inference.\n\n\nTested:\nyes\n\nR\u003dacleung\nDELTA\u003d119  (64 added, 37 deleted, 18 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3171\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1399 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "8/31/11, 8:11 AM",
      "commitName": "a2dd1662d90524a12a99a9fa7d4308568938d963",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "8/18/11, 3:46 PM",
      "commitNameOld": "bd9c7b620384fe5a98772729001ed56304459bc6",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 12.68,
      "commitsBetweenForRepo": 31,
      "commitsBetweenForFile": 1,
      "actualSource": "private FunctionType createFunctionTypeFromNodes(@Nullable Node rValue, @Nullable String name, @Nullable JSDocInfo info, @Nullable Node lvalueNode) {\n    FunctionType functionType \u003d null;\n    if (rValue !\u003d null \u0026\u0026 rValue.isQualifiedName() \u0026\u0026 scope.isGlobal()) {\n        Var var \u003d scope.getVar(rValue.getQualifiedName());\n        if (var !\u003d null \u0026\u0026 var.getType() !\u003d null \u0026\u0026 var.getType().isFunctionType()) {\n            FunctionType aliasedType \u003d var.getType().toMaybeFunctionType();\n            if ((aliasedType.isConstructor() || aliasedType.isInterface()) \u0026\u0026 !aliasedType.isNativeObjectType()) {\n                functionType \u003d aliasedType;\n                if (name !\u003d null \u0026\u0026 scope.isGlobal()) {\n                    typeRegistry.declareType(name, functionType.getInstanceType());\n                }\n            }\n        }\n    }\n    if (functionType \u003d\u003d null) {\n        Node errorRoot \u003d rValue \u003d\u003d null ? lvalueNode : rValue;\n        boolean isFnLiteral \u003d rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.FUNCTION;\n        Node fnRoot \u003d isFnLiteral ? rValue : null;\n        Node parametersNode \u003d isFnLiteral ? rValue.getFirstChild().getNext() : null;\n        Node fnBlock \u003d isFnLiteral ? parametersNode.getNext() : null;\n        if (info !\u003d null \u0026\u0026 info.hasType()) {\n            JSType type \u003d info.getType().evaluate(scope, typeRegistry);\n            type \u003d type.restrictByNotNullOrUndefined();\n            if (type.isFunctionType()) {\n                functionType \u003d type.toMaybeFunctionType();\n                functionType.setJSDocInfo(info);\n            }\n        }\n        if (functionType \u003d\u003d null) {\n            Node ownerNode \u003d NodeUtil.getBestLValueOwner(lvalueNode);\n            String ownerName \u003d NodeUtil.getBestLValueName(ownerNode);\n            Var ownerVar \u003d null;\n            String propName \u003d null;\n            ObjectType ownerType \u003d null;\n            if (ownerName !\u003d null) {\n                ownerVar \u003d scope.getVar(ownerName);\n                if (ownerVar !\u003d null) {\n                    ownerType \u003d ObjectType.cast(ownerVar.getType());\n                }\n                if (name !\u003d null) {\n                    propName \u003d name.substring(ownerName.length() + 1);\n                }\n            }\n            FunctionType overriddenPropType \u003d null;\n            if (ownerType !\u003d null \u0026\u0026 propName !\u003d null) {\n                overriddenPropType \u003d findOverriddenFunction(ownerType, propName);\n            }\n            FunctionTypeBuilder builder \u003d new FunctionTypeBuilder(name, compiler, errorRoot, sourceName, scope).setSourceNode(fnRoot).inferFromOverriddenFunction(overriddenPropType, parametersNode).inferTemplateTypeName(info).inferReturnType(info).inferInheritance(info);\n            boolean searchedForThisType \u003d false;\n            if (ownerType !\u003d null \u0026\u0026 ownerType.isFunctionPrototypeType()) {\n                builder.inferThisType(info, ownerType.getOwnerFunction().getInstanceType());\n                searchedForThisType \u003d true;\n            } else if (ownerNode !\u003d null \u0026\u0026 ownerNode.getType() \u003d\u003d Token.THIS) {\n                builder.inferThisType(info, ownerNode.getJSType());\n                searchedForThisType \u003d true;\n            }\n            if (!searchedForThisType) {\n                builder.inferThisType(info);\n            }\n            functionType \u003d builder.inferParameterTypes(parametersNode, info).inferReturnStatementsAsLastResort(fnBlock).buildAndRegister();\n        }\n    }\n    return functionType;\n}",
      "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
      "functionStartLine": 795,
      "functionName": "createFunctionTypeFromNodes",
      "functionAnnotation": "",
      "functionDoc": "Creates a new function type, based on the given nodes.\n\nThis handles two cases that are semantically very different, but\nare not mutually exclusive:\n- A function literal that needs a type attached to it.\n- An assignment expression with function-type info in the jsdoc.\n\nAll parameters are optional, and we will do the best we can to create\na function type.\n\nThis function will always create a function type, so only call it if\nyou\u0027re sure that\u0027s what you want.\n\n@param rValue The function node.\n@param name the function\u0027s name\n@param info the {@link JSDocInfo} attached to the function definition\n@param lvalueNode The node where this function is being\n    assigned. For example, {@code A.prototype.foo \u003d ...} would be used to\n    determine that this function is a method of A.prototype. May be\n    null to indicate that this is not being assigned to a qualified name.\n",
      "diff": "@@ -1,60 +1,64 @@\n private FunctionType createFunctionTypeFromNodes(@Nullable Node rValue, @Nullable String name, @Nullable JSDocInfo info, @Nullable Node lvalueNode) {\n     FunctionType functionType \u003d null;\n     if (rValue !\u003d null \u0026\u0026 rValue.isQualifiedName() \u0026\u0026 scope.isGlobal()) {\n         Var var \u003d scope.getVar(rValue.getQualifiedName());\n         if (var !\u003d null \u0026\u0026 var.getType() !\u003d null \u0026\u0026 var.getType().isFunctionType()) {\n             FunctionType aliasedType \u003d var.getType().toMaybeFunctionType();\n             if ((aliasedType.isConstructor() || aliasedType.isInterface()) \u0026\u0026 !aliasedType.isNativeObjectType()) {\n                 functionType \u003d aliasedType;\n                 if (name !\u003d null \u0026\u0026 scope.isGlobal()) {\n                     typeRegistry.declareType(name, functionType.getInstanceType());\n                 }\n             }\n         }\n     }\n     if (functionType \u003d\u003d null) {\n         Node errorRoot \u003d rValue \u003d\u003d null ? lvalueNode : rValue;\n         boolean isFnLiteral \u003d rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.FUNCTION;\n         Node fnRoot \u003d isFnLiteral ? rValue : null;\n         Node parametersNode \u003d isFnLiteral ? rValue.getFirstChild().getNext() : null;\n         Node fnBlock \u003d isFnLiteral ? parametersNode.getNext() : null;\n         if (info !\u003d null \u0026\u0026 info.hasType()) {\n             JSType type \u003d info.getType().evaluate(scope, typeRegistry);\n             type \u003d type.restrictByNotNullOrUndefined();\n             if (type.isFunctionType()) {\n                 functionType \u003d type.toMaybeFunctionType();\n                 functionType.setJSDocInfo(info);\n             }\n         }\n         if (functionType \u003d\u003d null) {\n-            FunctionType overriddenPropType \u003d null;\n-            if (lvalueNode !\u003d null \u0026\u0026 lvalueNode.getType() \u003d\u003d Token.GETPROP \u0026\u0026 lvalueNode.isQualifiedName()) {\n-                Var var \u003d scope.getVar(lvalueNode.getFirstChild().getQualifiedName());\n-                if (var !\u003d null) {\n-                    ObjectType ownerType \u003d ObjectType.cast(var.getType());\n-                    if (ownerType !\u003d null) {\n-                        String propName \u003d lvalueNode.getLastChild().getString();\n-                        overriddenPropType \u003d findOverriddenFunction(ownerType, propName);\n-                    }\n+            Node ownerNode \u003d NodeUtil.getBestLValueOwner(lvalueNode);\n+            String ownerName \u003d NodeUtil.getBestLValueName(ownerNode);\n+            Var ownerVar \u003d null;\n+            String propName \u003d null;\n+            ObjectType ownerType \u003d null;\n+            if (ownerName !\u003d null) {\n+                ownerVar \u003d scope.getVar(ownerName);\n+                if (ownerVar !\u003d null) {\n+                    ownerType \u003d ObjectType.cast(ownerVar.getType());\n                 }\n+                if (name !\u003d null) {\n+                    propName \u003d name.substring(ownerName.length() + 1);\n+                }\n+            }\n+            FunctionType overriddenPropType \u003d null;\n+            if (ownerType !\u003d null \u0026\u0026 propName !\u003d null) {\n+                overriddenPropType \u003d findOverriddenFunction(ownerType, propName);\n             }\n             FunctionTypeBuilder builder \u003d new FunctionTypeBuilder(name, compiler, errorRoot, sourceName, scope).setSourceNode(fnRoot).inferFromOverriddenFunction(overriddenPropType, parametersNode).inferTemplateTypeName(info).inferReturnType(info).inferInheritance(info);\n             boolean searchedForThisType \u003d false;\n-            if (lvalueNode !\u003d null \u0026\u0026 lvalueNode.getType() \u003d\u003d Token.GETPROP) {\n-                Node objNode \u003d lvalueNode.getFirstChild();\n-                if (objNode.getType() \u003d\u003d Token.GETPROP \u0026\u0026 objNode.getLastChild().getString().equals(\"prototype\")) {\n-                    builder.inferThisType(info, objNode.getFirstChild());\n-                    searchedForThisType \u003d true;\n-                } else if (objNode.getType() \u003d\u003d Token.THIS) {\n-                    builder.inferThisType(info, objNode.getJSType());\n-                    searchedForThisType \u003d true;\n-                }\n+            if (ownerType !\u003d null \u0026\u0026 ownerType.isFunctionPrototypeType()) {\n+                builder.inferThisType(info, ownerType.getOwnerFunction().getInstanceType());\n+                searchedForThisType \u003d true;\n+            } else if (ownerNode !\u003d null \u0026\u0026 ownerNode.getType() \u003d\u003d Token.THIS) {\n+                builder.inferThisType(info, ownerNode.getJSType());\n+                searchedForThisType \u003d true;\n             }\n             if (!searchedForThisType) {\n-                builder.inferThisType(info, (Node) null);\n+                builder.inferThisType(info);\n             }\n             functionType \u003d builder.inferParameterTypes(parametersNode, info).inferReturnStatementsAsLastResort(fnBlock).buildAndRegister();\n         }\n     }\n     return functionType;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "bd9c7b620384fe5a98772729001ed56304459bc6": {
      "type": "Ybodychange",
      "commitMessage": "\nAdd toMaybeFunctionType/toMaybeEnumElementType.\ntry #2. the bugs in jstestc were fixed. this cl is exactly\nthe same as the original\n\nR\u003djohnlenz\nDELTA\u003d317  (79 added, 47 deleted, 191 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3078\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1367 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "8/18/11, 3:46 PM",
      "commitName": "bd9c7b620384fe5a98772729001ed56304459bc6",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "8/18/11, 10:40 AM",
      "commitNameOld": "01d1238a2a577d8988a72c29304a3283ca05a29a",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 0.21,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "private FunctionType createFunctionTypeFromNodes(@Nullable Node rValue, @Nullable String name, @Nullable JSDocInfo info, @Nullable Node lvalueNode) {\n    FunctionType functionType \u003d null;\n    if (rValue !\u003d null \u0026\u0026 rValue.isQualifiedName() \u0026\u0026 scope.isGlobal()) {\n        Var var \u003d scope.getVar(rValue.getQualifiedName());\n        if (var !\u003d null \u0026\u0026 var.getType() !\u003d null \u0026\u0026 var.getType().isFunctionType()) {\n            FunctionType aliasedType \u003d var.getType().toMaybeFunctionType();\n            if ((aliasedType.isConstructor() || aliasedType.isInterface()) \u0026\u0026 !aliasedType.isNativeObjectType()) {\n                functionType \u003d aliasedType;\n                if (name !\u003d null \u0026\u0026 scope.isGlobal()) {\n                    typeRegistry.declareType(name, functionType.getInstanceType());\n                }\n            }\n        }\n    }\n    if (functionType \u003d\u003d null) {\n        Node errorRoot \u003d rValue \u003d\u003d null ? lvalueNode : rValue;\n        boolean isFnLiteral \u003d rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.FUNCTION;\n        Node fnRoot \u003d isFnLiteral ? rValue : null;\n        Node parametersNode \u003d isFnLiteral ? rValue.getFirstChild().getNext() : null;\n        Node fnBlock \u003d isFnLiteral ? parametersNode.getNext() : null;\n        if (info !\u003d null \u0026\u0026 info.hasType()) {\n            JSType type \u003d info.getType().evaluate(scope, typeRegistry);\n            type \u003d type.restrictByNotNullOrUndefined();\n            if (type.isFunctionType()) {\n                functionType \u003d type.toMaybeFunctionType();\n                functionType.setJSDocInfo(info);\n            }\n        }\n        if (functionType \u003d\u003d null) {\n            FunctionType overriddenPropType \u003d null;\n            if (lvalueNode !\u003d null \u0026\u0026 lvalueNode.getType() \u003d\u003d Token.GETPROP \u0026\u0026 lvalueNode.isQualifiedName()) {\n                Var var \u003d scope.getVar(lvalueNode.getFirstChild().getQualifiedName());\n                if (var !\u003d null) {\n                    ObjectType ownerType \u003d ObjectType.cast(var.getType());\n                    if (ownerType !\u003d null) {\n                        String propName \u003d lvalueNode.getLastChild().getString();\n                        overriddenPropType \u003d findOverriddenFunction(ownerType, propName);\n                    }\n                }\n            }\n            FunctionTypeBuilder builder \u003d new FunctionTypeBuilder(name, compiler, errorRoot, sourceName, scope).setSourceNode(fnRoot).inferFromOverriddenFunction(overriddenPropType, parametersNode).inferTemplateTypeName(info).inferReturnType(info).inferInheritance(info);\n            boolean searchedForThisType \u003d false;\n            if (lvalueNode !\u003d null \u0026\u0026 lvalueNode.getType() \u003d\u003d Token.GETPROP) {\n                Node objNode \u003d lvalueNode.getFirstChild();\n                if (objNode.getType() \u003d\u003d Token.GETPROP \u0026\u0026 objNode.getLastChild().getString().equals(\"prototype\")) {\n                    builder.inferThisType(info, objNode.getFirstChild());\n                    searchedForThisType \u003d true;\n                } else if (objNode.getType() \u003d\u003d Token.THIS) {\n                    builder.inferThisType(info, objNode.getJSType());\n                    searchedForThisType \u003d true;\n                }\n            }\n            if (!searchedForThisType) {\n                builder.inferThisType(info, (Node) null);\n            }\n            functionType \u003d builder.inferParameterTypes(parametersNode, info).inferReturnStatementsAsLastResort(fnBlock).buildAndRegister();\n        }\n    }\n    return functionType;\n}",
      "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
      "functionStartLine": 795,
      "functionName": "createFunctionTypeFromNodes",
      "functionAnnotation": "",
      "functionDoc": "Creates a new function type, based on the given nodes.\n\nThis handles two cases that are semantically very different, but\nare not mutually exclusive:\n- A function literal that needs a type attached to it.\n- An assignment expression with function-type info in the jsdoc.\n\nAll parameters are optional, and we will do the best we can to create\na function type.\n\nThis function will always create a function type, so only call it if\nyou\u0027re sure that\u0027s what you want.\n\n@param rValue The function node.\n@param name the function\u0027s name\n@param info the {@link JSDocInfo} attached to the function definition\n@param lvalueNode The node where this function is being\n    assigned. For example, {@code A.prototype.foo \u003d ...} would be used to\n    determine that this function is a method of A.prototype. May be\n    null to indicate that this is not being assigned to a qualified name.\n",
      "diff": "@@ -1,60 +1,60 @@\n private FunctionType createFunctionTypeFromNodes(@Nullable Node rValue, @Nullable String name, @Nullable JSDocInfo info, @Nullable Node lvalueNode) {\n     FunctionType functionType \u003d null;\n     if (rValue !\u003d null \u0026\u0026 rValue.isQualifiedName() \u0026\u0026 scope.isGlobal()) {\n         Var var \u003d scope.getVar(rValue.getQualifiedName());\n-        if (var !\u003d null \u0026\u0026 var.getType() instanceof FunctionType) {\n-            FunctionType aliasedType \u003d (FunctionType) var.getType();\n+        if (var !\u003d null \u0026\u0026 var.getType() !\u003d null \u0026\u0026 var.getType().isFunctionType()) {\n+            FunctionType aliasedType \u003d var.getType().toMaybeFunctionType();\n             if ((aliasedType.isConstructor() || aliasedType.isInterface()) \u0026\u0026 !aliasedType.isNativeObjectType()) {\n                 functionType \u003d aliasedType;\n                 if (name !\u003d null \u0026\u0026 scope.isGlobal()) {\n                     typeRegistry.declareType(name, functionType.getInstanceType());\n                 }\n             }\n         }\n     }\n     if (functionType \u003d\u003d null) {\n         Node errorRoot \u003d rValue \u003d\u003d null ? lvalueNode : rValue;\n         boolean isFnLiteral \u003d rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.FUNCTION;\n         Node fnRoot \u003d isFnLiteral ? rValue : null;\n         Node parametersNode \u003d isFnLiteral ? rValue.getFirstChild().getNext() : null;\n         Node fnBlock \u003d isFnLiteral ? parametersNode.getNext() : null;\n         if (info !\u003d null \u0026\u0026 info.hasType()) {\n             JSType type \u003d info.getType().evaluate(scope, typeRegistry);\n             type \u003d type.restrictByNotNullOrUndefined();\n             if (type.isFunctionType()) {\n-                functionType \u003d (FunctionType) type;\n+                functionType \u003d type.toMaybeFunctionType();\n                 functionType.setJSDocInfo(info);\n             }\n         }\n         if (functionType \u003d\u003d null) {\n             FunctionType overriddenPropType \u003d null;\n             if (lvalueNode !\u003d null \u0026\u0026 lvalueNode.getType() \u003d\u003d Token.GETPROP \u0026\u0026 lvalueNode.isQualifiedName()) {\n                 Var var \u003d scope.getVar(lvalueNode.getFirstChild().getQualifiedName());\n                 if (var !\u003d null) {\n                     ObjectType ownerType \u003d ObjectType.cast(var.getType());\n                     if (ownerType !\u003d null) {\n                         String propName \u003d lvalueNode.getLastChild().getString();\n                         overriddenPropType \u003d findOverriddenFunction(ownerType, propName);\n                     }\n                 }\n             }\n             FunctionTypeBuilder builder \u003d new FunctionTypeBuilder(name, compiler, errorRoot, sourceName, scope).setSourceNode(fnRoot).inferFromOverriddenFunction(overriddenPropType, parametersNode).inferTemplateTypeName(info).inferReturnType(info).inferInheritance(info);\n             boolean searchedForThisType \u003d false;\n             if (lvalueNode !\u003d null \u0026\u0026 lvalueNode.getType() \u003d\u003d Token.GETPROP) {\n                 Node objNode \u003d lvalueNode.getFirstChild();\n                 if (objNode.getType() \u003d\u003d Token.GETPROP \u0026\u0026 objNode.getLastChild().getString().equals(\"prototype\")) {\n                     builder.inferThisType(info, objNode.getFirstChild());\n                     searchedForThisType \u003d true;\n                 } else if (objNode.getType() \u003d\u003d Token.THIS) {\n                     builder.inferThisType(info, objNode.getJSType());\n                     searchedForThisType \u003d true;\n                 }\n             }\n             if (!searchedForThisType) {\n                 builder.inferThisType(info, (Node) null);\n             }\n             functionType \u003d builder.inferParameterTypes(parametersNode, info).inferReturnStatementsAsLastResort(fnBlock).buildAndRegister();\n         }\n     }\n     return functionType;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "01d1238a2a577d8988a72c29304a3283ca05a29a": {
      "type": "Ybodychange",
      "commitMessage": "\nAutomated g4 rollback.\n\n*** Reason for rollback ***\n\nbroke some tests\n\n*** Original change description ***\n\nAdd toMaybeFunctionType/toMaybeEnumElementType.\nwow, nullability is annoying!\n\nDELTA\u003d318  (48 added, 79 deleted, 191 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3075\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1364 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "8/18/11, 10:40 AM",
      "commitName": "01d1238a2a577d8988a72c29304a3283ca05a29a",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "8/18/11, 9:38 AM",
      "commitNameOld": "fc0798047ad3aac58a54ea65f9f1c8857745419f",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private FunctionType createFunctionTypeFromNodes(@Nullable Node rValue, @Nullable String name, @Nullable JSDocInfo info, @Nullable Node lvalueNode) {\n    FunctionType functionType \u003d null;\n    if (rValue !\u003d null \u0026\u0026 rValue.isQualifiedName() \u0026\u0026 scope.isGlobal()) {\n        Var var \u003d scope.getVar(rValue.getQualifiedName());\n        if (var !\u003d null \u0026\u0026 var.getType() instanceof FunctionType) {\n            FunctionType aliasedType \u003d (FunctionType) var.getType();\n            if ((aliasedType.isConstructor() || aliasedType.isInterface()) \u0026\u0026 !aliasedType.isNativeObjectType()) {\n                functionType \u003d aliasedType;\n                if (name !\u003d null \u0026\u0026 scope.isGlobal()) {\n                    typeRegistry.declareType(name, functionType.getInstanceType());\n                }\n            }\n        }\n    }\n    if (functionType \u003d\u003d null) {\n        Node errorRoot \u003d rValue \u003d\u003d null ? lvalueNode : rValue;\n        boolean isFnLiteral \u003d rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.FUNCTION;\n        Node fnRoot \u003d isFnLiteral ? rValue : null;\n        Node parametersNode \u003d isFnLiteral ? rValue.getFirstChild().getNext() : null;\n        Node fnBlock \u003d isFnLiteral ? parametersNode.getNext() : null;\n        if (info !\u003d null \u0026\u0026 info.hasType()) {\n            JSType type \u003d info.getType().evaluate(scope, typeRegistry);\n            type \u003d type.restrictByNotNullOrUndefined();\n            if (type.isFunctionType()) {\n                functionType \u003d (FunctionType) type;\n                functionType.setJSDocInfo(info);\n            }\n        }\n        if (functionType \u003d\u003d null) {\n            FunctionType overriddenPropType \u003d null;\n            if (lvalueNode !\u003d null \u0026\u0026 lvalueNode.getType() \u003d\u003d Token.GETPROP \u0026\u0026 lvalueNode.isQualifiedName()) {\n                Var var \u003d scope.getVar(lvalueNode.getFirstChild().getQualifiedName());\n                if (var !\u003d null) {\n                    ObjectType ownerType \u003d ObjectType.cast(var.getType());\n                    if (ownerType !\u003d null) {\n                        String propName \u003d lvalueNode.getLastChild().getString();\n                        overriddenPropType \u003d findOverriddenFunction(ownerType, propName);\n                    }\n                }\n            }\n            FunctionTypeBuilder builder \u003d new FunctionTypeBuilder(name, compiler, errorRoot, sourceName, scope).setSourceNode(fnRoot).inferFromOverriddenFunction(overriddenPropType, parametersNode).inferTemplateTypeName(info).inferReturnType(info).inferInheritance(info);\n            boolean searchedForThisType \u003d false;\n            if (lvalueNode !\u003d null \u0026\u0026 lvalueNode.getType() \u003d\u003d Token.GETPROP) {\n                Node objNode \u003d lvalueNode.getFirstChild();\n                if (objNode.getType() \u003d\u003d Token.GETPROP \u0026\u0026 objNode.getLastChild().getString().equals(\"prototype\")) {\n                    builder.inferThisType(info, objNode.getFirstChild());\n                    searchedForThisType \u003d true;\n                } else if (objNode.getType() \u003d\u003d Token.THIS) {\n                    builder.inferThisType(info, objNode.getJSType());\n                    searchedForThisType \u003d true;\n                }\n            }\n            if (!searchedForThisType) {\n                builder.inferThisType(info, (Node) null);\n            }\n            functionType \u003d builder.inferParameterTypes(parametersNode, info).inferReturnStatementsAsLastResort(fnBlock).buildAndRegister();\n        }\n    }\n    return functionType;\n}",
      "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
      "functionStartLine": 795,
      "functionName": "createFunctionTypeFromNodes",
      "functionAnnotation": "",
      "functionDoc": "Creates a new function type, based on the given nodes.\n\nThis handles two cases that are semantically very different, but\nare not mutually exclusive:\n- A function literal that needs a type attached to it.\n- An assignment expression with function-type info in the jsdoc.\n\nAll parameters are optional, and we will do the best we can to create\na function type.\n\nThis function will always create a function type, so only call it if\nyou\u0027re sure that\u0027s what you want.\n\n@param rValue The function node.\n@param name the function\u0027s name\n@param info the {@link JSDocInfo} attached to the function definition\n@param lvalueNode The node where this function is being\n    assigned. For example, {@code A.prototype.foo \u003d ...} would be used to\n    determine that this function is a method of A.prototype. May be\n    null to indicate that this is not being assigned to a qualified name.\n",
      "diff": "@@ -1,60 +1,60 @@\n private FunctionType createFunctionTypeFromNodes(@Nullable Node rValue, @Nullable String name, @Nullable JSDocInfo info, @Nullable Node lvalueNode) {\n     FunctionType functionType \u003d null;\n     if (rValue !\u003d null \u0026\u0026 rValue.isQualifiedName() \u0026\u0026 scope.isGlobal()) {\n         Var var \u003d scope.getVar(rValue.getQualifiedName());\n-        if (var !\u003d null \u0026\u0026 var.getType() !\u003d null \u0026\u0026 var.getType().isFunctionType()) {\n-            FunctionType aliasedType \u003d var.getType().toMaybeFunctionType();\n+        if (var !\u003d null \u0026\u0026 var.getType() instanceof FunctionType) {\n+            FunctionType aliasedType \u003d (FunctionType) var.getType();\n             if ((aliasedType.isConstructor() || aliasedType.isInterface()) \u0026\u0026 !aliasedType.isNativeObjectType()) {\n                 functionType \u003d aliasedType;\n                 if (name !\u003d null \u0026\u0026 scope.isGlobal()) {\n                     typeRegistry.declareType(name, functionType.getInstanceType());\n                 }\n             }\n         }\n     }\n     if (functionType \u003d\u003d null) {\n         Node errorRoot \u003d rValue \u003d\u003d null ? lvalueNode : rValue;\n         boolean isFnLiteral \u003d rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.FUNCTION;\n         Node fnRoot \u003d isFnLiteral ? rValue : null;\n         Node parametersNode \u003d isFnLiteral ? rValue.getFirstChild().getNext() : null;\n         Node fnBlock \u003d isFnLiteral ? parametersNode.getNext() : null;\n         if (info !\u003d null \u0026\u0026 info.hasType()) {\n             JSType type \u003d info.getType().evaluate(scope, typeRegistry);\n             type \u003d type.restrictByNotNullOrUndefined();\n             if (type.isFunctionType()) {\n-                functionType \u003d type.toMaybeFunctionType();\n+                functionType \u003d (FunctionType) type;\n                 functionType.setJSDocInfo(info);\n             }\n         }\n         if (functionType \u003d\u003d null) {\n             FunctionType overriddenPropType \u003d null;\n             if (lvalueNode !\u003d null \u0026\u0026 lvalueNode.getType() \u003d\u003d Token.GETPROP \u0026\u0026 lvalueNode.isQualifiedName()) {\n                 Var var \u003d scope.getVar(lvalueNode.getFirstChild().getQualifiedName());\n                 if (var !\u003d null) {\n                     ObjectType ownerType \u003d ObjectType.cast(var.getType());\n                     if (ownerType !\u003d null) {\n                         String propName \u003d lvalueNode.getLastChild().getString();\n                         overriddenPropType \u003d findOverriddenFunction(ownerType, propName);\n                     }\n                 }\n             }\n             FunctionTypeBuilder builder \u003d new FunctionTypeBuilder(name, compiler, errorRoot, sourceName, scope).setSourceNode(fnRoot).inferFromOverriddenFunction(overriddenPropType, parametersNode).inferTemplateTypeName(info).inferReturnType(info).inferInheritance(info);\n             boolean searchedForThisType \u003d false;\n             if (lvalueNode !\u003d null \u0026\u0026 lvalueNode.getType() \u003d\u003d Token.GETPROP) {\n                 Node objNode \u003d lvalueNode.getFirstChild();\n                 if (objNode.getType() \u003d\u003d Token.GETPROP \u0026\u0026 objNode.getLastChild().getString().equals(\"prototype\")) {\n                     builder.inferThisType(info, objNode.getFirstChild());\n                     searchedForThisType \u003d true;\n                 } else if (objNode.getType() \u003d\u003d Token.THIS) {\n                     builder.inferThisType(info, objNode.getJSType());\n                     searchedForThisType \u003d true;\n                 }\n             }\n             if (!searchedForThisType) {\n                 builder.inferThisType(info, (Node) null);\n             }\n             functionType \u003d builder.inferParameterTypes(parametersNode, info).inferReturnStatementsAsLastResort(fnBlock).buildAndRegister();\n         }\n     }\n     return functionType;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fc0798047ad3aac58a54ea65f9f1c8857745419f": {
      "type": "Ybodychange",
      "commitMessage": "\nAdd toMaybeFunctionType/toMaybeEnumElementType.\nwow, nullability is annoying!\n\nR\u003djohnlenz\nDELTA\u003d318  (79 added, 48 deleted, 191 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3074\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1363 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "8/18/11, 9:38 AM",
      "commitName": "fc0798047ad3aac58a54ea65f9f1c8857745419f",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "8/12/11, 9:46 AM",
      "commitNameOld": "7ab44a5f66e5889e71bb56bb91eb29066cf82530",
      "commitAuthorOld": "pdoyle@google.com",
      "daysBetweenCommits": 5.99,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "actualSource": "private FunctionType createFunctionTypeFromNodes(@Nullable Node rValue, @Nullable String name, @Nullable JSDocInfo info, @Nullable Node lvalueNode) {\n    FunctionType functionType \u003d null;\n    if (rValue !\u003d null \u0026\u0026 rValue.isQualifiedName() \u0026\u0026 scope.isGlobal()) {\n        Var var \u003d scope.getVar(rValue.getQualifiedName());\n        if (var !\u003d null \u0026\u0026 var.getType() !\u003d null \u0026\u0026 var.getType().isFunctionType()) {\n            FunctionType aliasedType \u003d var.getType().toMaybeFunctionType();\n            if ((aliasedType.isConstructor() || aliasedType.isInterface()) \u0026\u0026 !aliasedType.isNativeObjectType()) {\n                functionType \u003d aliasedType;\n                if (name !\u003d null \u0026\u0026 scope.isGlobal()) {\n                    typeRegistry.declareType(name, functionType.getInstanceType());\n                }\n            }\n        }\n    }\n    if (functionType \u003d\u003d null) {\n        Node errorRoot \u003d rValue \u003d\u003d null ? lvalueNode : rValue;\n        boolean isFnLiteral \u003d rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.FUNCTION;\n        Node fnRoot \u003d isFnLiteral ? rValue : null;\n        Node parametersNode \u003d isFnLiteral ? rValue.getFirstChild().getNext() : null;\n        Node fnBlock \u003d isFnLiteral ? parametersNode.getNext() : null;\n        if (info !\u003d null \u0026\u0026 info.hasType()) {\n            JSType type \u003d info.getType().evaluate(scope, typeRegistry);\n            type \u003d type.restrictByNotNullOrUndefined();\n            if (type.isFunctionType()) {\n                functionType \u003d type.toMaybeFunctionType();\n                functionType.setJSDocInfo(info);\n            }\n        }\n        if (functionType \u003d\u003d null) {\n            FunctionType overriddenPropType \u003d null;\n            if (lvalueNode !\u003d null \u0026\u0026 lvalueNode.getType() \u003d\u003d Token.GETPROP \u0026\u0026 lvalueNode.isQualifiedName()) {\n                Var var \u003d scope.getVar(lvalueNode.getFirstChild().getQualifiedName());\n                if (var !\u003d null) {\n                    ObjectType ownerType \u003d ObjectType.cast(var.getType());\n                    if (ownerType !\u003d null) {\n                        String propName \u003d lvalueNode.getLastChild().getString();\n                        overriddenPropType \u003d findOverriddenFunction(ownerType, propName);\n                    }\n                }\n            }\n            FunctionTypeBuilder builder \u003d new FunctionTypeBuilder(name, compiler, errorRoot, sourceName, scope).setSourceNode(fnRoot).inferFromOverriddenFunction(overriddenPropType, parametersNode).inferTemplateTypeName(info).inferReturnType(info).inferInheritance(info);\n            boolean searchedForThisType \u003d false;\n            if (lvalueNode !\u003d null \u0026\u0026 lvalueNode.getType() \u003d\u003d Token.GETPROP) {\n                Node objNode \u003d lvalueNode.getFirstChild();\n                if (objNode.getType() \u003d\u003d Token.GETPROP \u0026\u0026 objNode.getLastChild().getString().equals(\"prototype\")) {\n                    builder.inferThisType(info, objNode.getFirstChild());\n                    searchedForThisType \u003d true;\n                } else if (objNode.getType() \u003d\u003d Token.THIS) {\n                    builder.inferThisType(info, objNode.getJSType());\n                    searchedForThisType \u003d true;\n                }\n            }\n            if (!searchedForThisType) {\n                builder.inferThisType(info, (Node) null);\n            }\n            functionType \u003d builder.inferParameterTypes(parametersNode, info).inferReturnStatementsAsLastResort(fnBlock).buildAndRegister();\n        }\n    }\n    return functionType;\n}",
      "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
      "functionStartLine": 795,
      "functionName": "createFunctionTypeFromNodes",
      "functionAnnotation": "",
      "functionDoc": "Creates a new function type, based on the given nodes.\n\nThis handles two cases that are semantically very different, but\nare not mutually exclusive:\n- A function literal that needs a type attached to it.\n- An assignment expression with function-type info in the jsdoc.\n\nAll parameters are optional, and we will do the best we can to create\na function type.\n\nThis function will always create a function type, so only call it if\nyou\u0027re sure that\u0027s what you want.\n\n@param rValue The function node.\n@param name the function\u0027s name\n@param info the {@link JSDocInfo} attached to the function definition\n@param lvalueNode The node where this function is being\n    assigned. For example, {@code A.prototype.foo \u003d ...} would be used to\n    determine that this function is a method of A.prototype. May be\n    null to indicate that this is not being assigned to a qualified name.\n",
      "diff": "@@ -1,60 +1,60 @@\n private FunctionType createFunctionTypeFromNodes(@Nullable Node rValue, @Nullable String name, @Nullable JSDocInfo info, @Nullable Node lvalueNode) {\n     FunctionType functionType \u003d null;\n     if (rValue !\u003d null \u0026\u0026 rValue.isQualifiedName() \u0026\u0026 scope.isGlobal()) {\n         Var var \u003d scope.getVar(rValue.getQualifiedName());\n-        if (var !\u003d null \u0026\u0026 var.getType() instanceof FunctionType) {\n-            FunctionType aliasedType \u003d (FunctionType) var.getType();\n+        if (var !\u003d null \u0026\u0026 var.getType() !\u003d null \u0026\u0026 var.getType().isFunctionType()) {\n+            FunctionType aliasedType \u003d var.getType().toMaybeFunctionType();\n             if ((aliasedType.isConstructor() || aliasedType.isInterface()) \u0026\u0026 !aliasedType.isNativeObjectType()) {\n                 functionType \u003d aliasedType;\n                 if (name !\u003d null \u0026\u0026 scope.isGlobal()) {\n                     typeRegistry.declareType(name, functionType.getInstanceType());\n                 }\n             }\n         }\n     }\n     if (functionType \u003d\u003d null) {\n         Node errorRoot \u003d rValue \u003d\u003d null ? lvalueNode : rValue;\n         boolean isFnLiteral \u003d rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.FUNCTION;\n         Node fnRoot \u003d isFnLiteral ? rValue : null;\n         Node parametersNode \u003d isFnLiteral ? rValue.getFirstChild().getNext() : null;\n         Node fnBlock \u003d isFnLiteral ? parametersNode.getNext() : null;\n         if (info !\u003d null \u0026\u0026 info.hasType()) {\n             JSType type \u003d info.getType().evaluate(scope, typeRegistry);\n             type \u003d type.restrictByNotNullOrUndefined();\n             if (type.isFunctionType()) {\n-                functionType \u003d (FunctionType) type;\n+                functionType \u003d type.toMaybeFunctionType();\n                 functionType.setJSDocInfo(info);\n             }\n         }\n         if (functionType \u003d\u003d null) {\n             FunctionType overriddenPropType \u003d null;\n             if (lvalueNode !\u003d null \u0026\u0026 lvalueNode.getType() \u003d\u003d Token.GETPROP \u0026\u0026 lvalueNode.isQualifiedName()) {\n                 Var var \u003d scope.getVar(lvalueNode.getFirstChild().getQualifiedName());\n                 if (var !\u003d null) {\n                     ObjectType ownerType \u003d ObjectType.cast(var.getType());\n                     if (ownerType !\u003d null) {\n                         String propName \u003d lvalueNode.getLastChild().getString();\n                         overriddenPropType \u003d findOverriddenFunction(ownerType, propName);\n                     }\n                 }\n             }\n             FunctionTypeBuilder builder \u003d new FunctionTypeBuilder(name, compiler, errorRoot, sourceName, scope).setSourceNode(fnRoot).inferFromOverriddenFunction(overriddenPropType, parametersNode).inferTemplateTypeName(info).inferReturnType(info).inferInheritance(info);\n             boolean searchedForThisType \u003d false;\n             if (lvalueNode !\u003d null \u0026\u0026 lvalueNode.getType() \u003d\u003d Token.GETPROP) {\n                 Node objNode \u003d lvalueNode.getFirstChild();\n                 if (objNode.getType() \u003d\u003d Token.GETPROP \u0026\u0026 objNode.getLastChild().getString().equals(\"prototype\")) {\n                     builder.inferThisType(info, objNode.getFirstChild());\n                     searchedForThisType \u003d true;\n                 } else if (objNode.getType() \u003d\u003d Token.THIS) {\n                     builder.inferThisType(info, objNode.getJSType());\n                     searchedForThisType \u003d true;\n                 }\n             }\n             if (!searchedForThisType) {\n                 builder.inferThisType(info, (Node) null);\n             }\n             functionType \u003d builder.inferParameterTypes(parametersNode, info).inferReturnStatementsAsLastResort(fnBlock).buildAndRegister();\n         }\n     }\n     return functionType;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "072fa2d047573d2d1f0187ba4bf76b1afa75031c": {
      "type": "Yformatchange",
      "commitMessage": "\nWhen a property of a named object literal is declared,\ndeclare the qualified name of that property.\n\nR\u003djohnlenz\nDELTA\u003d82  (58 added, 3 deleted, 21 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d546\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@793 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "2/16/11, 8:38 PM",
      "commitName": "072fa2d047573d2d1f0187ba4bf76b1afa75031c",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "2/1/11, 11:22 AM",
      "commitNameOld": "7675b68dbd7cfc37b1359fd40be9fdf0b618bc95",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 15.39,
      "commitsBetweenForRepo": 49,
      "commitsBetweenForFile": 1,
      "actualSource": "private FunctionType createFunctionTypeFromNodes(@Nullable Node rValue, @Nullable String name, @Nullable JSDocInfo info, @Nullable Node lvalueNode) {\n    FunctionType functionType \u003d null;\n    if (rValue !\u003d null \u0026\u0026 rValue.isQualifiedName() \u0026\u0026 scope.isGlobal()) {\n        Var var \u003d scope.getVar(rValue.getQualifiedName());\n        if (var !\u003d null \u0026\u0026 var.getType() instanceof FunctionType) {\n            FunctionType aliasedType \u003d (FunctionType) var.getType();\n            if ((aliasedType.isConstructor() || aliasedType.isInterface()) \u0026\u0026 !aliasedType.isNativeObjectType()) {\n                functionType \u003d aliasedType;\n                if (name !\u003d null \u0026\u0026 scope.isGlobal()) {\n                    typeRegistry.declareType(name, functionType.getInstanceType());\n                }\n            }\n        }\n    }\n    if (functionType \u003d\u003d null) {\n        Node errorRoot \u003d rValue \u003d\u003d null ? lvalueNode : rValue;\n        boolean isFnLiteral \u003d rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.FUNCTION;\n        Node fnRoot \u003d isFnLiteral ? rValue : null;\n        Node parametersNode \u003d isFnLiteral ? rValue.getFirstChild().getNext() : null;\n        Node fnBlock \u003d isFnLiteral ? parametersNode.getNext() : null;\n        if (info !\u003d null \u0026\u0026 info.hasType()) {\n            JSType type \u003d info.getType().evaluate(scope, typeRegistry);\n            type \u003d type.restrictByNotNullOrUndefined();\n            if (type.isFunctionType()) {\n                functionType \u003d (FunctionType) type;\n                functionType.setJSDocInfo(info);\n            }\n        }\n        if (functionType \u003d\u003d null) {\n            FunctionType overriddenPropType \u003d null;\n            if (lvalueNode !\u003d null \u0026\u0026 lvalueNode.getType() \u003d\u003d Token.GETPROP \u0026\u0026 lvalueNode.isQualifiedName()) {\n                Var var \u003d scope.getVar(lvalueNode.getFirstChild().getQualifiedName());\n                if (var !\u003d null) {\n                    ObjectType ownerType \u003d ObjectType.cast(var.getType());\n                    if (ownerType !\u003d null) {\n                        String propName \u003d lvalueNode.getLastChild().getString();\n                        overriddenPropType \u003d findOverriddenFunction(ownerType, propName);\n                    }\n                }\n            }\n            FunctionTypeBuilder builder \u003d new FunctionTypeBuilder(name, compiler, errorRoot, sourceName, scope).setSourceNode(fnRoot).inferFromOverriddenFunction(overriddenPropType, parametersNode).inferTemplateTypeName(info).inferReturnType(info).inferInheritance(info);\n            boolean searchedForThisType \u003d false;\n            if (lvalueNode !\u003d null \u0026\u0026 lvalueNode.getType() \u003d\u003d Token.GETPROP) {\n                Node objNode \u003d lvalueNode.getFirstChild();\n                if (objNode.getType() \u003d\u003d Token.GETPROP \u0026\u0026 objNode.getLastChild().getString().equals(\"prototype\")) {\n                    builder.inferThisType(info, objNode.getFirstChild());\n                    searchedForThisType \u003d true;\n                } else if (objNode.getType() \u003d\u003d Token.THIS) {\n                    builder.inferThisType(info, objNode.getJSType());\n                    searchedForThisType \u003d true;\n                }\n            }\n            if (!searchedForThisType) {\n                builder.inferThisType(info, (Node) null);\n            }\n            functionType \u003d builder.inferParameterTypes(parametersNode, info).inferReturnStatementsAsLastResort(fnBlock).buildAndRegister();\n        }\n    }\n    return functionType;\n}",
      "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
      "functionStartLine": 781,
      "functionName": "createFunctionTypeFromNodes",
      "functionAnnotation": "",
      "functionDoc": "Creates a new function type, based on the given nodes.\n\nThis handles two cases that are semantically very different, but\nare not mutually exclusive:\n- A function literal that needs a type attached to it.\n- An assignment expression with function-type info in the jsdoc.\n\nAll parameters are optional, and we will do the best we can to create\na function type.\n\nThis function will always create a function type, so only call it if\nyou\u0027re sure that\u0027s what you want.\n\n@param rValue The function node.\n@param name the function\u0027s name\n@param info the {@link JSDocInfo} attached to the function definition\n@param lvalueNode The node where this function is being\n    assigned. For example, {@code A.prototype.foo \u003d ...} would be used to\n    determine that this function is a method of A.prototype. May be\n    null to indicate that this is not being assigned to a qualified name.\n",
      "diff": "",
      "extendedDetails": {}
    },
    "2ea78e73e6ace693e18d535560606dfd49c3f9bc": {
      "type": "Yintroduced",
      "commitMessage": "\nClean up type discovery by refactoring to the following algorithm.\n1) When we see a function literal, create the authoritative\ntype for it.\n2) When we see an object literal, create the authoritative\ntype for it.\n3) When we declare a symbol, check to see if it\u0027s assigned to\nan object or function literal, and use that type if it\nmake sense to do so. Otherwise, fall back on the JSDoc info.\nThis should make it a lot easier to give accurate types to object\nliteral properties.\nI didn\u0027t intend to create any functional changes in this CL,\nbut some minor ones were inevitable.\n\nR\u003djohnlenz\nDELTA\u003d618  (320 added, 249 deleted, 49 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d392\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@739 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "1/31/11, 8:08 AM",
      "commitName": "2ea78e73e6ace693e18d535560606dfd49c3f9bc",
      "commitAuthor": "nicksantos@google.com",
      "diff": "@@ -0,0 +1,60 @@\n+private FunctionType createFunctionTypeFromNodes(@Nullable Node rValue, @Nullable String name, @Nullable JSDocInfo info, @Nullable Node lvalueNode) {\n+    FunctionType functionType \u003d null;\n+    if (rValue !\u003d null \u0026\u0026 rValue.isQualifiedName() \u0026\u0026 scope.isGlobal()) {\n+        Var var \u003d scope.getVar(rValue.getQualifiedName());\n+        if (var !\u003d null \u0026\u0026 var.getType() instanceof FunctionType) {\n+            FunctionType aliasedType \u003d (FunctionType) var.getType();\n+            if ((aliasedType.isConstructor() || aliasedType.isInterface()) \u0026\u0026 !aliasedType.isNativeObjectType()) {\n+                functionType \u003d aliasedType;\n+                if (name !\u003d null \u0026\u0026 scope.isGlobal()) {\n+                    typeRegistry.declareType(name, functionType.getInstanceType());\n+                }\n+            }\n+        }\n+    }\n+    if (functionType \u003d\u003d null) {\n+        Node errorRoot \u003d rValue \u003d\u003d null ? lvalueNode : rValue;\n+        boolean isFnLiteral \u003d rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.FUNCTION;\n+        Node fnRoot \u003d isFnLiteral ? rValue : null;\n+        Node parametersNode \u003d isFnLiteral ? rValue.getFirstChild().getNext() : null;\n+        Node fnBlock \u003d isFnLiteral ? parametersNode.getNext() : null;\n+        if (info !\u003d null \u0026\u0026 info.hasType()) {\n+            JSType type \u003d info.getType().evaluate(scope, typeRegistry);\n+            type \u003d type.restrictByNotNullOrUndefined();\n+            if (type.isFunctionType()) {\n+                functionType \u003d (FunctionType) type;\n+                functionType.setJSDocInfo(info);\n+            }\n+        }\n+        if (functionType \u003d\u003d null) {\n+            FunctionType overriddenPropType \u003d null;\n+            if (lvalueNode !\u003d null \u0026\u0026 lvalueNode.getType() \u003d\u003d Token.GETPROP \u0026\u0026 lvalueNode.isQualifiedName()) {\n+                Var var \u003d scope.getVar(lvalueNode.getFirstChild().getQualifiedName());\n+                if (var !\u003d null) {\n+                    ObjectType ownerType \u003d ObjectType.cast(var.getType());\n+                    if (ownerType !\u003d null) {\n+                        String propName \u003d lvalueNode.getLastChild().getString();\n+                        overriddenPropType \u003d findOverriddenFunction(ownerType, propName);\n+                    }\n+                }\n+            }\n+            FunctionTypeBuilder builder \u003d new FunctionTypeBuilder(name, compiler, errorRoot, sourceName, scope).setSourceNode(fnRoot).inferFromOverriddenFunction(overriddenPropType, parametersNode).inferTemplateTypeName(info).inferReturnType(info).inferInheritance(info);\n+            boolean searchedForThisType \u003d false;\n+            if (lvalueNode !\u003d null \u0026\u0026 lvalueNode.getType() \u003d\u003d Token.GETPROP) {\n+                Node objNode \u003d lvalueNode.getFirstChild();\n+                if (objNode.getType() \u003d\u003d Token.GETPROP \u0026\u0026 objNode.getLastChild().getString().equals(\"prototype\")) {\n+                    builder.inferThisType(info, objNode.getFirstChild());\n+                    searchedForThisType \u003d true;\n+                } else if (objNode.getType() \u003d\u003d Token.THIS) {\n+                    builder.inferThisType(info, objNode.getJSType());\n+                    searchedForThisType \u003d true;\n+                }\n+            }\n+            if (!searchedForThisType) {\n+                builder.inferThisType(info, (Node) null);\n+            }\n+            functionType \u003d builder.inferParameterTypes(parametersNode, info).inferReturnStatementsAsLastResort(fnBlock).buildAndRegister();\n+        }\n+    }\n+    return functionType;\n+}\n\\ No newline at end of file\n",
      "actualSource": "private FunctionType createFunctionTypeFromNodes(@Nullable Node rValue, @Nullable String name, @Nullable JSDocInfo info, @Nullable Node lvalueNode) {\n    FunctionType functionType \u003d null;\n    if (rValue !\u003d null \u0026\u0026 rValue.isQualifiedName() \u0026\u0026 scope.isGlobal()) {\n        Var var \u003d scope.getVar(rValue.getQualifiedName());\n        if (var !\u003d null \u0026\u0026 var.getType() instanceof FunctionType) {\n            FunctionType aliasedType \u003d (FunctionType) var.getType();\n            if ((aliasedType.isConstructor() || aliasedType.isInterface()) \u0026\u0026 !aliasedType.isNativeObjectType()) {\n                functionType \u003d aliasedType;\n                if (name !\u003d null \u0026\u0026 scope.isGlobal()) {\n                    typeRegistry.declareType(name, functionType.getInstanceType());\n                }\n            }\n        }\n    }\n    if (functionType \u003d\u003d null) {\n        Node errorRoot \u003d rValue \u003d\u003d null ? lvalueNode : rValue;\n        boolean isFnLiteral \u003d rValue !\u003d null \u0026\u0026 rValue.getType() \u003d\u003d Token.FUNCTION;\n        Node fnRoot \u003d isFnLiteral ? rValue : null;\n        Node parametersNode \u003d isFnLiteral ? rValue.getFirstChild().getNext() : null;\n        Node fnBlock \u003d isFnLiteral ? parametersNode.getNext() : null;\n        if (info !\u003d null \u0026\u0026 info.hasType()) {\n            JSType type \u003d info.getType().evaluate(scope, typeRegistry);\n            type \u003d type.restrictByNotNullOrUndefined();\n            if (type.isFunctionType()) {\n                functionType \u003d (FunctionType) type;\n                functionType.setJSDocInfo(info);\n            }\n        }\n        if (functionType \u003d\u003d null) {\n            FunctionType overriddenPropType \u003d null;\n            if (lvalueNode !\u003d null \u0026\u0026 lvalueNode.getType() \u003d\u003d Token.GETPROP \u0026\u0026 lvalueNode.isQualifiedName()) {\n                Var var \u003d scope.getVar(lvalueNode.getFirstChild().getQualifiedName());\n                if (var !\u003d null) {\n                    ObjectType ownerType \u003d ObjectType.cast(var.getType());\n                    if (ownerType !\u003d null) {\n                        String propName \u003d lvalueNode.getLastChild().getString();\n                        overriddenPropType \u003d findOverriddenFunction(ownerType, propName);\n                    }\n                }\n            }\n            FunctionTypeBuilder builder \u003d new FunctionTypeBuilder(name, compiler, errorRoot, sourceName, scope).setSourceNode(fnRoot).inferFromOverriddenFunction(overriddenPropType, parametersNode).inferTemplateTypeName(info).inferReturnType(info).inferInheritance(info);\n            boolean searchedForThisType \u003d false;\n            if (lvalueNode !\u003d null \u0026\u0026 lvalueNode.getType() \u003d\u003d Token.GETPROP) {\n                Node objNode \u003d lvalueNode.getFirstChild();\n                if (objNode.getType() \u003d\u003d Token.GETPROP \u0026\u0026 objNode.getLastChild().getString().equals(\"prototype\")) {\n                    builder.inferThisType(info, objNode.getFirstChild());\n                    searchedForThisType \u003d true;\n                } else if (objNode.getType() \u003d\u003d Token.THIS) {\n                    builder.inferThisType(info, objNode.getJSType());\n                    searchedForThisType \u003d true;\n                }\n            }\n            if (!searchedForThisType) {\n                builder.inferThisType(info, (Node) null);\n            }\n            functionType \u003d builder.inferParameterTypes(parametersNode, info).inferReturnStatementsAsLastResort(fnBlock).buildAndRegister();\n        }\n    }\n    return functionType;\n}",
      "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
      "functionStartLine": 761,
      "functionName": "createFunctionTypeFromNodes",
      "functionAnnotation": "",
      "functionDoc": "Creates a new function type, based on the given nodes.\n\nThis handles two cases that are semantically very different, but\nare not mutually exclusive:\n- A function literal that needs a type attached to it.\n- An assignment expression with function-type info in the jsdoc.\n\nAll parameters are optional, and we will do the best we can to create\na function type.\n\nThis function will always create a function type, so only call it if\nyou\u0027re sure that\u0027s what you want.\n\n@param rValue The function node.\n@param name the function\u0027s name\n@param info the {@link JSDocInfo} attached to the function definition\n@param lvalueNode The node where this function is being\n    assigned. For example, {@code A.prototype.foo \u003d ...} would be used to\n    determine that this function is a method of A.prototype. May be\n    null to indicate that this is not being assigned to a qualified name.\n"
    }
  }
}