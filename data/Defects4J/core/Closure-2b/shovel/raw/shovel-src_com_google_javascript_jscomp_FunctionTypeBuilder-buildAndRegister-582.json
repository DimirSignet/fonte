{
  "origin": "codeshovel",
  "repositoryName": "Closure-2b",
  "repositoryPath": "/tmp/Closure-2b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FunctionTypeBuilder.java",
  "functionName": "buildAndRegister",
  "functionId": "buildAndRegister",
  "sourceFilePath": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
  "functionAnnotation": "",
  "functionDoc": "Builds the function type, and puts it in the registry.\n",
  "functionStartLine": 582,
  "functionEndLine": 644,
  "numCommitsSeen": 59,
  "timeTaken": 2759,
  "changeHistory": [
    "177d001a30c568037141e555d84f9bd28d3d2d86",
    "16a9c4d210fea92c24ff05aa2d6767e3f5ceb362",
    "c26da905cc06126658ba25f037d77d9ce6c02b45",
    "dff730a3759cad9c491f72d9905eee93962d3d35",
    "c438dfd06013f82daa648d23b864842ff1881695",
    "2851a41947bed8b8e100c7dac7d1edbc1c909d24",
    "a36a61a9027c5bca5752b0ecca7c609c07e568bb",
    "e7ad2425c384dcb18a34bec8e147a91c658d5118",
    "465282f1ca28a208b06c47b55fd292d4631c55da",
    "e3bcc1c6e7ce7e9bfc3098cd5bf57774049f5baa",
    "43859717972907dd1ecebd8dca6e05036386e28b",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3"
  ],
  "changeHistoryShort": {
    "177d001a30c568037141e555d84f9bd28d3d2d86": "Ybodychange",
    "16a9c4d210fea92c24ff05aa2d6767e3f5ceb362": "Ybodychange",
    "c26da905cc06126658ba25f037d77d9ce6c02b45": "Ybodychange",
    "dff730a3759cad9c491f72d9905eee93962d3d35": "Ybodychange",
    "c438dfd06013f82daa648d23b864842ff1881695": "Ybodychange",
    "2851a41947bed8b8e100c7dac7d1edbc1c909d24": "Ybodychange",
    "a36a61a9027c5bca5752b0ecca7c609c07e568bb": "Ybodychange",
    "e7ad2425c384dcb18a34bec8e147a91c658d5118": "Ybodychange",
    "465282f1ca28a208b06c47b55fd292d4631c55da": "Ybodychange",
    "e3bcc1c6e7ce7e9bfc3098cd5bf57774049f5baa": "Ybodychange",
    "43859717972907dd1ecebd8dca6e05036386e28b": "Ybodychange",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "177d001a30c568037141e555d84f9bd28d3d2d86": {
      "type": "Ybodychange",
      "commitMessage": "\nAdds basic support for template keys and templatized types to the base JSType. Array and Object will be converted to this templatized type system.\n\nR\u003ddimvar,nicksantos\nDELTA\u003d324  (225 added, 17 deleted, 82 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d5698\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2278 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "10/24/12, 2:07 PM",
      "commitName": "177d001a30c568037141e555d84f9bd28d3d2d86",
      "commitAuthor": "izaakr@google.com",
      "commitDateOld": "10/2/12, 3:54 PM",
      "commitNameOld": "5222108be8ce0536b4f95d1743be406110afcb4b",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 21.93,
      "commitsBetweenForRepo": 42,
      "commitsBetweenForFile": 1,
      "actualSource": "FunctionType buildAndRegister() {\n    if (returnType \u003d\u003d null) {\n        if (!contents.mayHaveNonEmptyReturns() \u0026\u0026 !contents.mayHaveSingleThrow() \u0026\u0026 !contents.mayBeFromExterns()) {\n            returnType \u003d typeRegistry.getNativeType(VOID_TYPE);\n            returnTypeInferred \u003d true;\n        }\n    }\n    if (returnType \u003d\u003d null) {\n        returnType \u003d typeRegistry.getNativeType(UNKNOWN_TYPE);\n    }\n    if (parametersNode \u003d\u003d null) {\n        throw new IllegalStateException(\"All Function types must have params and a return type\");\n    }\n    FunctionType fnType;\n    if (isConstructor) {\n        fnType \u003d getOrCreateConstructor();\n    } else if (isInterface) {\n        fnType \u003d typeRegistry.createInterfaceType(fnName, contents.getSourceNode());\n        if (getScopeDeclaredIn().isGlobal() \u0026\u0026 !fnName.isEmpty()) {\n            typeRegistry.declareType(fnName, fnType.getInstanceType());\n        }\n        maybeSetBaseType(fnType);\n    } else {\n        fnType \u003d new FunctionBuilder(typeRegistry).withName(fnName).withSourceNode(contents.getSourceNode()).withParamsNode(parametersNode).withReturnType(returnType, returnTypeInferred).withTypeOfThis(thisType).withTemplateKeys(templateTypeNames).build();\n        maybeSetBaseType(fnType);\n    }\n    if (implementedInterfaces !\u003d null) {\n        fnType.setImplementedInterfaces(implementedInterfaces);\n    }\n    if (extendedInterfaces !\u003d null) {\n        fnType.setExtendedInterfaces(extendedInterfaces);\n    }\n    typeRegistry.clearTemplateTypeNames();\n    return fnType;\n}",
      "path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
      "functionStartLine": 599,
      "functionName": "buildAndRegister",
      "functionAnnotation": "",
      "functionDoc": "Builds the function type, and puts it in the registry.\n",
      "diff": "@@ -1,35 +1,35 @@\n FunctionType buildAndRegister() {\n     if (returnType \u003d\u003d null) {\n         if (!contents.mayHaveNonEmptyReturns() \u0026\u0026 !contents.mayHaveSingleThrow() \u0026\u0026 !contents.mayBeFromExterns()) {\n             returnType \u003d typeRegistry.getNativeType(VOID_TYPE);\n             returnTypeInferred \u003d true;\n         }\n     }\n     if (returnType \u003d\u003d null) {\n         returnType \u003d typeRegistry.getNativeType(UNKNOWN_TYPE);\n     }\n     if (parametersNode \u003d\u003d null) {\n         throw new IllegalStateException(\"All Function types must have params and a return type\");\n     }\n     FunctionType fnType;\n     if (isConstructor) {\n         fnType \u003d getOrCreateConstructor();\n     } else if (isInterface) {\n         fnType \u003d typeRegistry.createInterfaceType(fnName, contents.getSourceNode());\n         if (getScopeDeclaredIn().isGlobal() \u0026\u0026 !fnName.isEmpty()) {\n             typeRegistry.declareType(fnName, fnType.getInstanceType());\n         }\n         maybeSetBaseType(fnType);\n     } else {\n-        fnType \u003d new FunctionBuilder(typeRegistry).withName(fnName).withSourceNode(contents.getSourceNode()).withParamsNode(parametersNode).withReturnType(returnType, returnTypeInferred).withTypeOfThis(thisType).withTemplateNames(templateTypeNames).build();\n+        fnType \u003d new FunctionBuilder(typeRegistry).withName(fnName).withSourceNode(contents.getSourceNode()).withParamsNode(parametersNode).withReturnType(returnType, returnTypeInferred).withTypeOfThis(thisType).withTemplateKeys(templateTypeNames).build();\n         maybeSetBaseType(fnType);\n     }\n     if (implementedInterfaces !\u003d null) {\n         fnType.setImplementedInterfaces(implementedInterfaces);\n     }\n     if (extendedInterfaces !\u003d null) {\n         fnType.setExtendedInterfaces(extendedInterfaces);\n     }\n     typeRegistry.clearTemplateTypeNames();\n     return fnType;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "16a9c4d210fea92c24ff05aa2d6767e3f5ceb362": {
      "type": "Ybodychange",
      "commitMessage": "\nChange @template to be a repeatable JSDoc tag.\n\nR\u003dnicksantos\nDELTA\u003d67  (18 added, 6 deleted, 43 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d4910\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2008 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "5/31/12, 2:10 PM",
      "commitName": "16a9c4d210fea92c24ff05aa2d6767e3f5ceb362",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "5/18/12, 11:09 AM",
      "commitNameOld": "70a5626922ea7e8c98747e22b6986638ba38fadc",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 13.13,
      "commitsBetweenForRepo": 29,
      "commitsBetweenForFile": 1,
      "actualSource": "FunctionType buildAndRegister() {\n    if (returnType \u003d\u003d null) {\n        if (!contents.mayHaveNonEmptyReturns() \u0026\u0026 !contents.mayHaveSingleThrow() \u0026\u0026 !contents.mayBeFromExterns()) {\n            returnType \u003d typeRegistry.getNativeType(VOID_TYPE);\n            returnTypeInferred \u003d true;\n        }\n    }\n    if (returnType \u003d\u003d null) {\n        returnType \u003d typeRegistry.getNativeType(UNKNOWN_TYPE);\n    }\n    if (parametersNode \u003d\u003d null) {\n        throw new IllegalStateException(\"All Function types must have params and a return type\");\n    }\n    FunctionType fnType;\n    if (isConstructor) {\n        fnType \u003d getOrCreateConstructor();\n    } else if (isInterface) {\n        fnType \u003d typeRegistry.createInterfaceType(fnName, contents.getSourceNode());\n        if (getScopeDeclaredIn().isGlobal() \u0026\u0026 !fnName.isEmpty()) {\n            typeRegistry.declareType(fnName, fnType.getInstanceType());\n        }\n        maybeSetBaseType(fnType);\n    } else {\n        fnType \u003d new FunctionBuilder(typeRegistry).withName(fnName).withSourceNode(contents.getSourceNode()).withParamsNode(parametersNode).withReturnType(returnType, returnTypeInferred).withTypeOfThis(thisType).withTemplateNames(templateTypeNames).build();\n        maybeSetBaseType(fnType);\n    }\n    if (implementedInterfaces !\u003d null) {\n        fnType.setImplementedInterfaces(implementedInterfaces);\n    }\n    if (extendedInterfaces !\u003d null) {\n        fnType.setExtendedInterfaces(extendedInterfaces);\n    }\n    typeRegistry.clearTemplateTypeNames();\n    return fnType;\n}",
      "path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
      "functionStartLine": 592,
      "functionName": "buildAndRegister",
      "functionAnnotation": "",
      "functionDoc": "Builds the function type, and puts it in the registry.\n",
      "diff": "@@ -1,35 +1,35 @@\n FunctionType buildAndRegister() {\n     if (returnType \u003d\u003d null) {\n         if (!contents.mayHaveNonEmptyReturns() \u0026\u0026 !contents.mayHaveSingleThrow() \u0026\u0026 !contents.mayBeFromExterns()) {\n             returnType \u003d typeRegistry.getNativeType(VOID_TYPE);\n             returnTypeInferred \u003d true;\n         }\n     }\n     if (returnType \u003d\u003d null) {\n         returnType \u003d typeRegistry.getNativeType(UNKNOWN_TYPE);\n     }\n     if (parametersNode \u003d\u003d null) {\n         throw new IllegalStateException(\"All Function types must have params and a return type\");\n     }\n     FunctionType fnType;\n     if (isConstructor) {\n         fnType \u003d getOrCreateConstructor();\n     } else if (isInterface) {\n         fnType \u003d typeRegistry.createInterfaceType(fnName, contents.getSourceNode());\n         if (getScopeDeclaredIn().isGlobal() \u0026\u0026 !fnName.isEmpty()) {\n             typeRegistry.declareType(fnName, fnType.getInstanceType());\n         }\n         maybeSetBaseType(fnType);\n     } else {\n-        fnType \u003d new FunctionBuilder(typeRegistry).withName(fnName).withSourceNode(contents.getSourceNode()).withParamsNode(parametersNode).withReturnType(returnType, returnTypeInferred).withTypeOfThis(thisType).withTemplateName(templateTypeName).build();\n+        fnType \u003d new FunctionBuilder(typeRegistry).withName(fnName).withSourceNode(contents.getSourceNode()).withParamsNode(parametersNode).withReturnType(returnType, returnTypeInferred).withTypeOfThis(thisType).withTemplateNames(templateTypeNames).build();\n         maybeSetBaseType(fnType);\n     }\n     if (implementedInterfaces !\u003d null) {\n         fnType.setImplementedInterfaces(implementedInterfaces);\n     }\n     if (extendedInterfaces !\u003d null) {\n         fnType.setExtendedInterfaces(extendedInterfaces);\n     }\n-    typeRegistry.clearTemplateTypeName();\n+    typeRegistry.clearTemplateTypeNames();\n     return fnType;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c26da905cc06126658ba25f037d77d9ce6c02b45": {
      "type": "Ybodychange",
      "commitMessage": "\nback off a little bit on function return type inference\n\nR\u003dacleung\nDELTA\u003d42  (37 added, 0 deleted, 5 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d4480\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1867 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/4/12, 2:38 PM",
      "commitName": "c26da905cc06126658ba25f037d77d9ce6c02b45",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "3/28/12, 12:21 PM",
      "commitNameOld": "8f01ae1412b9da415ddbeb25c9da4f4a19cb06aa",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 7.1,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "actualSource": "FunctionType buildAndRegister() {\n    if (returnType \u003d\u003d null) {\n        if (!contents.mayHaveNonEmptyReturns() \u0026\u0026 !contents.mayHaveSingleThrow() \u0026\u0026 !contents.mayBeFromExterns()) {\n            returnType \u003d typeRegistry.getNativeType(VOID_TYPE);\n            returnTypeInferred \u003d true;\n        }\n    }\n    if (returnType \u003d\u003d null) {\n        returnType \u003d typeRegistry.getNativeType(UNKNOWN_TYPE);\n    }\n    if (parametersNode \u003d\u003d null) {\n        throw new IllegalStateException(\"All Function types must have params and a return type\");\n    }\n    FunctionType fnType;\n    if (isConstructor) {\n        fnType \u003d getOrCreateConstructor();\n    } else if (isInterface) {\n        fnType \u003d typeRegistry.createInterfaceType(fnName, contents.getSourceNode());\n        if (getScopeDeclaredIn().isGlobal() \u0026\u0026 !fnName.isEmpty()) {\n            typeRegistry.declareType(fnName, fnType.getInstanceType());\n        }\n        maybeSetBaseType(fnType);\n    } else {\n        fnType \u003d new FunctionBuilder(typeRegistry).withName(fnName).withSourceNode(contents.getSourceNode()).withParamsNode(parametersNode).withReturnType(returnType, returnTypeInferred).withTypeOfThis(thisType).withTemplateName(templateTypeName).build();\n        maybeSetBaseType(fnType);\n    }\n    if (implementedInterfaces !\u003d null) {\n        fnType.setImplementedInterfaces(implementedInterfaces);\n    }\n    if (extendedInterfaces !\u003d null) {\n        fnType.setExtendedInterfaces(extendedInterfaces);\n    }\n    typeRegistry.clearTemplateTypeName();\n    return fnType;\n}",
      "path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
      "functionStartLine": 592,
      "functionName": "buildAndRegister",
      "functionAnnotation": "",
      "functionDoc": "Builds the function type, and puts it in the registry.\n",
      "diff": "@@ -1,33 +1,35 @@\n FunctionType buildAndRegister() {\n-    if (returnType \u003d\u003d null \u0026\u0026 !contents.mayHaveNonEmptyReturns() \u0026\u0026 !contents.mayBeFromExterns()) {\n-        returnType \u003d typeRegistry.getNativeType(VOID_TYPE);\n-        returnTypeInferred \u003d true;\n+    if (returnType \u003d\u003d null) {\n+        if (!contents.mayHaveNonEmptyReturns() \u0026\u0026 !contents.mayHaveSingleThrow() \u0026\u0026 !contents.mayBeFromExterns()) {\n+            returnType \u003d typeRegistry.getNativeType(VOID_TYPE);\n+            returnTypeInferred \u003d true;\n+        }\n     }\n     if (returnType \u003d\u003d null) {\n         returnType \u003d typeRegistry.getNativeType(UNKNOWN_TYPE);\n     }\n     if (parametersNode \u003d\u003d null) {\n         throw new IllegalStateException(\"All Function types must have params and a return type\");\n     }\n     FunctionType fnType;\n     if (isConstructor) {\n         fnType \u003d getOrCreateConstructor();\n     } else if (isInterface) {\n         fnType \u003d typeRegistry.createInterfaceType(fnName, contents.getSourceNode());\n         if (getScopeDeclaredIn().isGlobal() \u0026\u0026 !fnName.isEmpty()) {\n             typeRegistry.declareType(fnName, fnType.getInstanceType());\n         }\n         maybeSetBaseType(fnType);\n     } else {\n         fnType \u003d new FunctionBuilder(typeRegistry).withName(fnName).withSourceNode(contents.getSourceNode()).withParamsNode(parametersNode).withReturnType(returnType, returnTypeInferred).withTypeOfThis(thisType).withTemplateName(templateTypeName).build();\n         maybeSetBaseType(fnType);\n     }\n     if (implementedInterfaces !\u003d null) {\n         fnType.setImplementedInterfaces(implementedInterfaces);\n     }\n     if (extendedInterfaces !\u003d null) {\n         fnType.setExtendedInterfaces(extendedInterfaces);\n     }\n     typeRegistry.clearTemplateTypeName();\n     return fnType;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "dff730a3759cad9c491f72d9905eee93962d3d35": {
      "type": "Ybodychange",
      "commitMessage": "\nBreak out basic function analysis into a separate pass, rather\nthan trying to do it as we go.\nThere should be no functional change, but this should make it\na lot easier to move things around in the future.\n\nR\u003dacleung\nDELTA\u003d332  (224 added, 89 deleted, 19 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3318\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1460 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "9/21/11, 5:18 PM",
      "commitName": "dff730a3759cad9c491f72d9905eee93962d3d35",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "9/7/11, 8:05 AM",
      "commitNameOld": "46bf070288b2bc34b324e9bbacd293083cb97c6e",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 14.38,
      "commitsBetweenForRepo": 46,
      "commitsBetweenForFile": 1,
      "actualSource": "FunctionType buildAndRegister() {\n    if (returnType \u003d\u003d null \u0026\u0026 !contents.mayHaveNonEmptyReturns() \u0026\u0026 !contents.mayBeFromExterns()) {\n        returnType \u003d typeRegistry.getNativeType(VOID_TYPE);\n        returnTypeInferred \u003d true;\n    }\n    if (returnType \u003d\u003d null) {\n        returnType \u003d typeRegistry.getNativeType(UNKNOWN_TYPE);\n    }\n    if (parametersNode \u003d\u003d null) {\n        throw new IllegalStateException(\"All Function types must have params and a return type\");\n    }\n    FunctionType fnType;\n    if (isConstructor) {\n        fnType \u003d getOrCreateConstructor();\n    } else if (isInterface) {\n        fnType \u003d typeRegistry.createInterfaceType(fnName, contents.getSourceNode());\n        if (getScopeDeclaredIn().isGlobal() \u0026\u0026 !fnName.isEmpty()) {\n            typeRegistry.declareType(fnName, fnType.getInstanceType());\n        }\n        maybeSetBaseType(fnType);\n    } else {\n        fnType \u003d new FunctionBuilder(typeRegistry).withName(fnName).withSourceNode(contents.getSourceNode()).withParamsNode(parametersNode).withReturnType(returnType, returnTypeInferred).withTypeOfThis(thisType).withTemplateName(templateTypeName).build();\n        maybeSetBaseType(fnType);\n    }\n    if (implementedInterfaces !\u003d null) {\n        fnType.setImplementedInterfaces(implementedInterfaces);\n    }\n    if (extendedInterfaces !\u003d null) {\n        fnType.setExtendedInterfaces(extendedInterfaces);\n    }\n    typeRegistry.clearTemplateTypeName();\n    return fnType;\n}",
      "path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
      "functionStartLine": 574,
      "functionName": "buildAndRegister",
      "functionAnnotation": "",
      "functionDoc": "Builds the function type, and puts it in the registry.\n",
      "diff": "@@ -1,29 +1,33 @@\n FunctionType buildAndRegister() {\n+    if (returnType \u003d\u003d null \u0026\u0026 !contents.mayHaveNonEmptyReturns() \u0026\u0026 !contents.mayBeFromExterns()) {\n+        returnType \u003d typeRegistry.getNativeType(VOID_TYPE);\n+        returnTypeInferred \u003d true;\n+    }\n     if (returnType \u003d\u003d null) {\n         returnType \u003d typeRegistry.getNativeType(UNKNOWN_TYPE);\n     }\n     if (parametersNode \u003d\u003d null) {\n         throw new IllegalStateException(\"All Function types must have params and a return type\");\n     }\n     FunctionType fnType;\n     if (isConstructor) {\n         fnType \u003d getOrCreateConstructor();\n     } else if (isInterface) {\n-        fnType \u003d typeRegistry.createInterfaceType(fnName, sourceNode);\n+        fnType \u003d typeRegistry.createInterfaceType(fnName, contents.getSourceNode());\n         if (getScopeDeclaredIn().isGlobal() \u0026\u0026 !fnName.isEmpty()) {\n             typeRegistry.declareType(fnName, fnType.getInstanceType());\n         }\n         maybeSetBaseType(fnType);\n     } else {\n-        fnType \u003d new FunctionBuilder(typeRegistry).withName(fnName).withSourceNode(sourceNode).withParamsNode(parametersNode).withReturnType(returnType, returnTypeInferred).withTypeOfThis(thisType).withTemplateName(templateTypeName).build();\n+        fnType \u003d new FunctionBuilder(typeRegistry).withName(fnName).withSourceNode(contents.getSourceNode()).withParamsNode(parametersNode).withReturnType(returnType, returnTypeInferred).withTypeOfThis(thisType).withTemplateName(templateTypeName).build();\n         maybeSetBaseType(fnType);\n     }\n     if (implementedInterfaces !\u003d null) {\n         fnType.setImplementedInterfaces(implementedInterfaces);\n     }\n     if (extendedInterfaces !\u003d null) {\n         fnType.setExtendedInterfaces(extendedInterfaces);\n     }\n     typeRegistry.clearTemplateTypeName();\n     return fnType;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c438dfd06013f82daa648d23b864842ff1881695": {
      "type": "Ybodychange",
      "commitMessage": "\nImplement multiple extends for interfaces\n\nR\u003dnicksantos\nDELTA\u003d711  (635 added, 41 deleted, 35 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d1917\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1105 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "5/16/11, 12:57 PM",
      "commitName": "c438dfd06013f82daa648d23b864842ff1881695",
      "commitAuthor": "zhuyi@google.com",
      "commitDateOld": "5/10/11, 2:34 PM",
      "commitNameOld": "2851a41947bed8b8e100c7dac7d1edbc1c909d24",
      "commitAuthorOld": "zhuyi@google.com",
      "daysBetweenCommits": 5.93,
      "commitsBetweenForRepo": 25,
      "commitsBetweenForFile": 1,
      "actualSource": "FunctionType buildAndRegister() {\n    if (returnType \u003d\u003d null) {\n        returnType \u003d typeRegistry.getNativeType(UNKNOWN_TYPE);\n    }\n    if (parametersNode \u003d\u003d null) {\n        throw new IllegalStateException(\"All Function types must have params and a return type\");\n    }\n    FunctionType fnType;\n    if (isConstructor) {\n        fnType \u003d getOrCreateConstructor();\n    } else if (isInterface) {\n        fnType \u003d typeRegistry.createInterfaceType(fnName, sourceNode);\n        if (getScopeDeclaredIn().isGlobal() \u0026\u0026 !fnName.isEmpty()) {\n            typeRegistry.declareType(fnName, fnType.getInstanceType());\n        }\n        maybeSetBaseType(fnType);\n    } else {\n        fnType \u003d new FunctionBuilder(typeRegistry).withName(fnName).withSourceNode(sourceNode).withParamsNode(parametersNode).withReturnType(returnType, returnTypeInferred).withTypeOfThis(thisType).withTemplateName(templateTypeName).build();\n        maybeSetBaseType(fnType);\n    }\n    if (implementedInterfaces !\u003d null) {\n        fnType.setImplementedInterfaces(implementedInterfaces);\n    }\n    if (extendedInterfaces !\u003d null) {\n        fnType.setExtendedInterfaces(extendedInterfaces);\n    }\n    typeRegistry.clearTemplateTypeName();\n    return fnType;\n}",
      "path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
      "functionStartLine": 630,
      "functionName": "buildAndRegister",
      "functionAnnotation": "",
      "functionDoc": "Builds the function type, and puts it in the registry.\n",
      "diff": "@@ -1,26 +1,29 @@\n FunctionType buildAndRegister() {\n     if (returnType \u003d\u003d null) {\n         returnType \u003d typeRegistry.getNativeType(UNKNOWN_TYPE);\n     }\n     if (parametersNode \u003d\u003d null) {\n         throw new IllegalStateException(\"All Function types must have params and a return type\");\n     }\n     FunctionType fnType;\n     if (isConstructor) {\n         fnType \u003d getOrCreateConstructor();\n     } else if (isInterface) {\n         fnType \u003d typeRegistry.createInterfaceType(fnName, sourceNode);\n         if (getScopeDeclaredIn().isGlobal() \u0026\u0026 !fnName.isEmpty()) {\n             typeRegistry.declareType(fnName, fnType.getInstanceType());\n         }\n         maybeSetBaseType(fnType);\n     } else {\n         fnType \u003d new FunctionBuilder(typeRegistry).withName(fnName).withSourceNode(sourceNode).withParamsNode(parametersNode).withReturnType(returnType, returnTypeInferred).withTypeOfThis(thisType).withTemplateName(templateTypeName).build();\n         maybeSetBaseType(fnType);\n     }\n     if (implementedInterfaces !\u003d null) {\n         fnType.setImplementedInterfaces(implementedInterfaces);\n     }\n+    if (extendedInterfaces !\u003d null) {\n+        fnType.setExtendedInterfaces(extendedInterfaces);\n+    }\n     typeRegistry.clearTemplateTypeName();\n     return fnType;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2851a41947bed8b8e100c7dac7d1edbc1c909d24": {
      "type": "Ybodychange",
      "commitMessage": "\nAutomated g4 rollback.\n\n*** Reason for rollback ***\n\nGot multiple cases broken from different teams.\n\n*** Original change description ***\n\nImplement multi extends for interfaces\n\nR\u003dnicksantos\nDELTA\u003d635  (41 added, 560 deleted, 34 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d1813\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1077 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "5/10/11, 2:34 PM",
      "commitName": "2851a41947bed8b8e100c7dac7d1edbc1c909d24",
      "commitAuthor": "zhuyi@google.com",
      "commitDateOld": "5/10/11, 1:26 PM",
      "commitNameOld": "a36a61a9027c5bca5752b0ecca7c609c07e568bb",
      "commitAuthorOld": "zhuyi@google.com",
      "daysBetweenCommits": 0.05,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "FunctionType buildAndRegister() {\n    if (returnType \u003d\u003d null) {\n        returnType \u003d typeRegistry.getNativeType(UNKNOWN_TYPE);\n    }\n    if (parametersNode \u003d\u003d null) {\n        throw new IllegalStateException(\"All Function types must have params and a return type\");\n    }\n    FunctionType fnType;\n    if (isConstructor) {\n        fnType \u003d getOrCreateConstructor();\n    } else if (isInterface) {\n        fnType \u003d typeRegistry.createInterfaceType(fnName, sourceNode);\n        if (getScopeDeclaredIn().isGlobal() \u0026\u0026 !fnName.isEmpty()) {\n            typeRegistry.declareType(fnName, fnType.getInstanceType());\n        }\n        maybeSetBaseType(fnType);\n    } else {\n        fnType \u003d new FunctionBuilder(typeRegistry).withName(fnName).withSourceNode(sourceNode).withParamsNode(parametersNode).withReturnType(returnType, returnTypeInferred).withTypeOfThis(thisType).withTemplateName(templateTypeName).build();\n        maybeSetBaseType(fnType);\n    }\n    if (implementedInterfaces !\u003d null) {\n        fnType.setImplementedInterfaces(implementedInterfaces);\n    }\n    typeRegistry.clearTemplateTypeName();\n    return fnType;\n}",
      "path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
      "functionStartLine": 625,
      "functionName": "buildAndRegister",
      "functionAnnotation": "",
      "functionDoc": "Builds the function type, and puts it in the registry.\n",
      "diff": "@@ -1,29 +1,26 @@\n FunctionType buildAndRegister() {\n     if (returnType \u003d\u003d null) {\n         returnType \u003d typeRegistry.getNativeType(UNKNOWN_TYPE);\n     }\n     if (parametersNode \u003d\u003d null) {\n         throw new IllegalStateException(\"All Function types must have params and a return type\");\n     }\n     FunctionType fnType;\n     if (isConstructor) {\n         fnType \u003d getOrCreateConstructor();\n     } else if (isInterface) {\n         fnType \u003d typeRegistry.createInterfaceType(fnName, sourceNode);\n         if (getScopeDeclaredIn().isGlobal() \u0026\u0026 !fnName.isEmpty()) {\n             typeRegistry.declareType(fnName, fnType.getInstanceType());\n         }\n         maybeSetBaseType(fnType);\n     } else {\n         fnType \u003d new FunctionBuilder(typeRegistry).withName(fnName).withSourceNode(sourceNode).withParamsNode(parametersNode).withReturnType(returnType, returnTypeInferred).withTypeOfThis(thisType).withTemplateName(templateTypeName).build();\n         maybeSetBaseType(fnType);\n     }\n     if (implementedInterfaces !\u003d null) {\n         fnType.setImplementedInterfaces(implementedInterfaces);\n     }\n-    if (extendedInterfaces !\u003d null) {\n-        fnType.setExtendedInterfaces(extendedInterfaces);\n-    }\n     typeRegistry.clearTemplateTypeName();\n     return fnType;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a36a61a9027c5bca5752b0ecca7c609c07e568bb": {
      "type": "Ybodychange",
      "commitMessage": "\nImplement multi extends for interfaces\n\nR\u003dnicksantos\nDELTA\u003d635  (560 added, 41 deleted, 34 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d1810\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1074 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "5/10/11, 1:26 PM",
      "commitName": "a36a61a9027c5bca5752b0ecca7c609c07e568bb",
      "commitAuthor": "zhuyi@google.com",
      "commitDateOld": "4/12/11, 12:15 PM",
      "commitNameOld": "f322be0e576d5e2114cb59c0a6537197997b9c59",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 28.05,
      "commitsBetweenForRepo": 74,
      "commitsBetweenForFile": 1,
      "actualSource": "FunctionType buildAndRegister() {\n    if (returnType \u003d\u003d null) {\n        returnType \u003d typeRegistry.getNativeType(UNKNOWN_TYPE);\n    }\n    if (parametersNode \u003d\u003d null) {\n        throw new IllegalStateException(\"All Function types must have params and a return type\");\n    }\n    FunctionType fnType;\n    if (isConstructor) {\n        fnType \u003d getOrCreateConstructor();\n    } else if (isInterface) {\n        fnType \u003d typeRegistry.createInterfaceType(fnName, sourceNode);\n        if (getScopeDeclaredIn().isGlobal() \u0026\u0026 !fnName.isEmpty()) {\n            typeRegistry.declareType(fnName, fnType.getInstanceType());\n        }\n        maybeSetBaseType(fnType);\n    } else {\n        fnType \u003d new FunctionBuilder(typeRegistry).withName(fnName).withSourceNode(sourceNode).withParamsNode(parametersNode).withReturnType(returnType, returnTypeInferred).withTypeOfThis(thisType).withTemplateName(templateTypeName).build();\n        maybeSetBaseType(fnType);\n    }\n    if (implementedInterfaces !\u003d null) {\n        fnType.setImplementedInterfaces(implementedInterfaces);\n    }\n    if (extendedInterfaces !\u003d null) {\n        fnType.setExtendedInterfaces(extendedInterfaces);\n    }\n    typeRegistry.clearTemplateTypeName();\n    return fnType;\n}",
      "path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
      "functionStartLine": 630,
      "functionName": "buildAndRegister",
      "functionAnnotation": "",
      "functionDoc": "Builds the function type, and puts it in the registry.\n",
      "diff": "@@ -1,26 +1,29 @@\n FunctionType buildAndRegister() {\n     if (returnType \u003d\u003d null) {\n         returnType \u003d typeRegistry.getNativeType(UNKNOWN_TYPE);\n     }\n     if (parametersNode \u003d\u003d null) {\n         throw new IllegalStateException(\"All Function types must have params and a return type\");\n     }\n     FunctionType fnType;\n     if (isConstructor) {\n         fnType \u003d getOrCreateConstructor();\n     } else if (isInterface) {\n         fnType \u003d typeRegistry.createInterfaceType(fnName, sourceNode);\n         if (getScopeDeclaredIn().isGlobal() \u0026\u0026 !fnName.isEmpty()) {\n             typeRegistry.declareType(fnName, fnType.getInstanceType());\n         }\n         maybeSetBaseType(fnType);\n     } else {\n         fnType \u003d new FunctionBuilder(typeRegistry).withName(fnName).withSourceNode(sourceNode).withParamsNode(parametersNode).withReturnType(returnType, returnTypeInferred).withTypeOfThis(thisType).withTemplateName(templateTypeName).build();\n         maybeSetBaseType(fnType);\n     }\n     if (implementedInterfaces !\u003d null) {\n         fnType.setImplementedInterfaces(implementedInterfaces);\n     }\n+    if (extendedInterfaces !\u003d null) {\n+        fnType.setExtendedInterfaces(extendedInterfaces);\n+    }\n     typeRegistry.clearTemplateTypeName();\n     return fnType;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e7ad2425c384dcb18a34bec8e147a91c658d5118": {
      "type": "Ybodychange",
      "commitMessage": "\nBe a bit better about constructors defined in local scopes on\nglobal objects.\n\nR\u003djohnlenz\nDELTA\u003d74  (72 added, 0 deleted, 2 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d29\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@579 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/30/10, 5:12 PM",
      "commitName": "e7ad2425c384dcb18a34bec8e147a91c658d5118",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "11/12/10, 1:38 PM",
      "commitNameOld": "25904fa3b61c1d6ef494dd7839eae1d1f49ff38d",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 18.15,
      "commitsBetweenForRepo": 28,
      "commitsBetweenForFile": 1,
      "actualSource": "FunctionType buildAndRegister() {\n    if (returnType \u003d\u003d null) {\n        returnType \u003d typeRegistry.getNativeType(UNKNOWN_TYPE);\n    }\n    if (parametersNode \u003d\u003d null) {\n        throw new IllegalStateException(\"All Function types must have params and a return type\");\n    }\n    FunctionType fnType;\n    if (isConstructor) {\n        fnType \u003d getOrCreateConstructor();\n    } else if (isInterface) {\n        fnType \u003d typeRegistry.createInterfaceType(fnName, sourceNode);\n        if (getScopeDeclaredIn().isGlobal() \u0026\u0026 !fnName.isEmpty()) {\n            typeRegistry.declareType(fnName, fnType.getInstanceType());\n        }\n        maybeSetBaseType(fnType);\n    } else {\n        fnType \u003d new FunctionBuilder(typeRegistry).withName(fnName).withSourceNode(sourceNode).withParamsNode(parametersNode).withReturnType(returnType, returnTypeInferred).withTypeOfThis(thisType).withTemplateName(templateTypeName).build();\n        maybeSetBaseType(fnType);\n    }\n    if (implementedInterfaces !\u003d null) {\n        fnType.setImplementedInterfaces(implementedInterfaces);\n    }\n    typeRegistry.clearTemplateTypeName();\n    return fnType;\n}",
      "path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
      "functionStartLine": 613,
      "functionName": "buildAndRegister",
      "functionAnnotation": "",
      "functionDoc": "Builds the function type, and puts it in the registry.\n",
      "diff": "@@ -1,26 +1,26 @@\n FunctionType buildAndRegister() {\n     if (returnType \u003d\u003d null) {\n         returnType \u003d typeRegistry.getNativeType(UNKNOWN_TYPE);\n     }\n     if (parametersNode \u003d\u003d null) {\n         throw new IllegalStateException(\"All Function types must have params and a return type\");\n     }\n     FunctionType fnType;\n     if (isConstructor) {\n         fnType \u003d getOrCreateConstructor();\n     } else if (isInterface) {\n         fnType \u003d typeRegistry.createInterfaceType(fnName, sourceNode);\n-        if (scope.isGlobal() \u0026\u0026 !fnName.isEmpty()) {\n+        if (getScopeDeclaredIn().isGlobal() \u0026\u0026 !fnName.isEmpty()) {\n             typeRegistry.declareType(fnName, fnType.getInstanceType());\n         }\n         maybeSetBaseType(fnType);\n     } else {\n         fnType \u003d new FunctionBuilder(typeRegistry).withName(fnName).withSourceNode(sourceNode).withParamsNode(parametersNode).withReturnType(returnType, returnTypeInferred).withTypeOfThis(thisType).withTemplateName(templateTypeName).build();\n         maybeSetBaseType(fnType);\n     }\n     if (implementedInterfaces !\u003d null) {\n         fnType.setImplementedInterfaces(implementedInterfaces);\n     }\n     typeRegistry.clearTemplateTypeName();\n     return fnType;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "465282f1ca28a208b06c47b55fd292d4631c55da": {
      "type": "Ybodychange",
      "commitMessage": "\nChange on 2010/06/22 by nicksantos\n\n        Inferred return types. \n        Fixes issue 143.\n        I eventually decided that it was wrong for the subtype\u0027s method\n        to affect the supertype\u0027s method, since this will make incremental\n        compilation a lot harder in the long run.\n\n        R\u003dmoedinger\n        DELTA\u003d481  (313 added, 38 deleted, 130 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d34007\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@249 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "6/22/10, 5:19 PM",
      "commitName": "465282f1ca28a208b06c47b55fd292d4631c55da",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "4/15/10, 4:45 PM",
      "commitNameOld": "e3bcc1c6e7ce7e9bfc3098cd5bf57774049f5baa",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 68.02,
      "commitsBetweenForRepo": 50,
      "commitsBetweenForFile": 1,
      "actualSource": "FunctionType buildAndRegister() {\n    if (returnType \u003d\u003d null) {\n        returnType \u003d typeRegistry.getNativeType(UNKNOWN_TYPE);\n    }\n    if (parametersNode \u003d\u003d null) {\n        throw new IllegalStateException(\"All Function types must have params and a return type\");\n    }\n    FunctionType fnType;\n    if (isConstructor) {\n        fnType \u003d getOrCreateConstructor();\n    } else if (isInterface) {\n        fnType \u003d typeRegistry.createInterfaceType(fnName, sourceNode);\n        if (scope.isGlobal() \u0026\u0026 !fnName.isEmpty()) {\n            typeRegistry.declareType(fnName, fnType.getInstanceType());\n        }\n        maybeSetBaseType(fnType);\n    } else {\n        fnType \u003d new FunctionBuilder(typeRegistry).withName(fnName).withSourceNode(sourceNode).withParamsNode(parametersNode).withReturnType(returnType, returnTypeInferred).withTypeOfThis(thisType).withTemplateName(templateTypeName).build();\n        maybeSetBaseType(fnType);\n    }\n    if (implementedInterfaces !\u003d null) {\n        fnType.setImplementedInterfaces(implementedInterfaces);\n    }\n    typeRegistry.clearTemplateTypeName();\n    return fnType;\n}",
      "path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
      "functionStartLine": 503,
      "functionName": "buildAndRegister",
      "functionAnnotation": "",
      "functionDoc": "Builds the function type, and puts it in the registry.\n",
      "diff": "@@ -1,23 +1,26 @@\n FunctionType buildAndRegister() {\n-    if (returnType \u003d\u003d null || parametersNode \u003d\u003d null) {\n+    if (returnType \u003d\u003d null) {\n+        returnType \u003d typeRegistry.getNativeType(UNKNOWN_TYPE);\n+    }\n+    if (parametersNode \u003d\u003d null) {\n         throw new IllegalStateException(\"All Function types must have params and a return type\");\n     }\n     FunctionType fnType;\n     if (isConstructor) {\n         fnType \u003d getOrCreateConstructor();\n     } else if (isInterface) {\n         fnType \u003d typeRegistry.createInterfaceType(fnName, sourceNode);\n         if (scope.isGlobal() \u0026\u0026 !fnName.isEmpty()) {\n             typeRegistry.declareType(fnName, fnType.getInstanceType());\n         }\n         maybeSetBaseType(fnType);\n     } else {\n-        fnType \u003d new FunctionBuilder(typeRegistry).withName(fnName).withSourceNode(sourceNode).withParamsNode(parametersNode).withReturnType(returnType).withTypeOfThis(thisType).withTemplateName(templateTypeName).build();\n+        fnType \u003d new FunctionBuilder(typeRegistry).withName(fnName).withSourceNode(sourceNode).withParamsNode(parametersNode).withReturnType(returnType, returnTypeInferred).withTypeOfThis(thisType).withTemplateName(templateTypeName).build();\n         maybeSetBaseType(fnType);\n     }\n     if (implementedInterfaces !\u003d null) {\n         fnType.setImplementedInterfaces(implementedInterfaces);\n     }\n     typeRegistry.clearTemplateTypeName();\n     return fnType;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e3bcc1c6e7ce7e9bfc3098cd5bf57774049f5baa": {
      "type": "Ybodychange",
      "commitMessage": "\nChange on 2010/04/15 by nick\n\n        Move the construction of ArrowTypes out of FunctionType.\n\n        R\u003djohn\n        DELTA\u003d197  (79 added, 27 deleted, 91 changed)\n\nChange on 2010/04/15 by nick\n\n        if a file is marked as an @extern, then make it an extern.\n\n        R\u003drobert\n        DELTA\u003d51  (46 added, 0 deleted, 5 changed)\n\nChange on 2010/04/15 by john\n\n        Maintain source information.\n\n        R\u003dalan\n        DELTA\u003d60  (28 added, 7 deleted, 25 changed)\n\nChange on 2010/04/15 by john\n\n        Fix overly aggressive RegExp check.\n\n        R\u003dalan\n        DELTA\u003d15  (12 added, 0 deleted, 3 changed)\n\nChange on 2010/04/15 by nick\n\n        more fun with function-type building.\n\n        R\u003djohn\n        DELTA\u003d432  (206 added, 142 deleted, 84 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003doqlcyn\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@186 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/15/10, 4:45 PM",
      "commitName": "e3bcc1c6e7ce7e9bfc3098cd5bf57774049f5baa",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "4/14/10, 4:53 PM",
      "commitNameOld": "43859717972907dd1ecebd8dca6e05036386e28b",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 0.99,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "FunctionType buildAndRegister() {\n    if (returnType \u003d\u003d null || parametersNode \u003d\u003d null) {\n        throw new IllegalStateException(\"All Function types must have params and a return type\");\n    }\n    FunctionType fnType;\n    if (isConstructor) {\n        fnType \u003d getOrCreateConstructor();\n    } else if (isInterface) {\n        fnType \u003d typeRegistry.createInterfaceType(fnName, sourceNode);\n        if (scope.isGlobal() \u0026\u0026 !fnName.isEmpty()) {\n            typeRegistry.declareType(fnName, fnType.getInstanceType());\n        }\n        maybeSetBaseType(fnType);\n    } else {\n        fnType \u003d new FunctionBuilder(typeRegistry).withName(fnName).withSourceNode(sourceNode).withParamsNode(parametersNode).withReturnType(returnType).withTypeOfThis(thisType).withTemplateName(templateTypeName).build();\n        maybeSetBaseType(fnType);\n    }\n    if (implementedInterfaces !\u003d null) {\n        fnType.setImplementedInterfaces(implementedInterfaces);\n    }\n    typeRegistry.clearTemplateTypeName();\n    return fnType;\n}",
      "path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
      "functionStartLine": 465,
      "functionName": "buildAndRegister",
      "functionAnnotation": "",
      "functionDoc": "Builds the function type, and puts it in the registry.\n",
      "diff": "@@ -1,23 +1,23 @@\n FunctionType buildAndRegister() {\n     if (returnType \u003d\u003d null || parametersNode \u003d\u003d null) {\n         throw new IllegalStateException(\"All Function types must have params and a return type\");\n     }\n     FunctionType fnType;\n     if (isConstructor) {\n         fnType \u003d getOrCreateConstructor();\n     } else if (isInterface) {\n         fnType \u003d typeRegistry.createInterfaceType(fnName, sourceNode);\n         if (scope.isGlobal() \u0026\u0026 !fnName.isEmpty()) {\n             typeRegistry.declareType(fnName, fnType.getInstanceType());\n         }\n         maybeSetBaseType(fnType);\n     } else {\n-        fnType \u003d typeRegistry.createMethodTypeWithTypeTemplate(fnName, sourceNode, parametersNode, returnType, thisType, templateTypeName);\n+        fnType \u003d new FunctionBuilder(typeRegistry).withName(fnName).withSourceNode(sourceNode).withParamsNode(parametersNode).withReturnType(returnType).withTypeOfThis(thisType).withTemplateName(templateTypeName).build();\n         maybeSetBaseType(fnType);\n     }\n     if (implementedInterfaces !\u003d null) {\n         fnType.setImplementedInterfaces(implementedInterfaces);\n     }\n     typeRegistry.clearTemplateTypeName();\n     return fnType;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "43859717972907dd1ecebd8dca6e05036386e28b": {
      "type": "Ybodychange",
      "commitMessage": "\nChange on 2010/04/14 by john\n\n        Stop creating specialized Node types for FUNCTION and SCRIPT as the added functionality isn\u0027t used anywhere.\n\n        Also correct some formatting issue with Node (as it won\u0027t need to be merged with anything else anymore).\n\n        R\u003dsteve,robert\n        DELTA\u003d3969  (1913 added, 1925 deleted, 131 changed)\n\nChange on 2010/04/14 by john\n\n        Fix source information in MinimizeExitPoints.\n\n        R\u003drobert\n        DELTA\u003d10  (5 added, 2 deleted, 3 changed)\n\nChange on 2010/04/14 by john\n\n        Maintain source information.\n\n        R\u003dantonio\n        DELTA\u003d17  (11 added, 0 deleted, 6 changed)\n\nChange on 2010/04/14 by john\n\n        Maintain source information through FoldConstants.\n\n        R\u003drobert\n        DELTA\u003d42  (22 added, 0 deleted, 20 changed)\n\nChange on 2010/04/14 by nick\n\n        lock down function type construction\n\n        R\u003djohn\n        DELTA\u003d111  (83 added, 9 deleted, 19 changed)\n\nChange on 2010/04/14 by john\n\n        Fix source info in CollapseProperties.\n\n        R\u003dnick\n        DELTA\u003d17  (8 added, 3 deleted, 6 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003dmbevwz\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@184 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/14/10, 4:53 PM",
      "commitName": "43859717972907dd1ecebd8dca6e05036386e28b",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "4/14/10, 9:15 AM",
      "commitNameOld": "c764a46abf211d4677fadc33f7d466e5b14fa088",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 0.32,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "FunctionType buildAndRegister() {\n    if (returnType \u003d\u003d null || parametersNode \u003d\u003d null) {\n        throw new IllegalStateException(\"All Function types must have params and a return type\");\n    }\n    FunctionType fnType;\n    if (isConstructor) {\n        fnType \u003d getOrCreateConstructor();\n    } else if (isInterface) {\n        fnType \u003d typeRegistry.createInterfaceType(fnName, sourceNode);\n        if (scope.isGlobal() \u0026\u0026 !fnName.isEmpty()) {\n            typeRegistry.declareType(fnName, fnType.getInstanceType());\n        }\n        maybeSetBaseType(fnType);\n    } else {\n        fnType \u003d typeRegistry.createMethodTypeWithTypeTemplate(fnName, sourceNode, parametersNode, returnType, thisType, templateTypeName);\n        maybeSetBaseType(fnType);\n    }\n    if (implementedInterfaces !\u003d null) {\n        fnType.setImplementedInterfaces(implementedInterfaces);\n    }\n    typeRegistry.clearTemplateTypeName();\n    return fnType;\n}",
      "path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
      "functionStartLine": 464,
      "functionName": "buildAndRegister",
      "functionAnnotation": "",
      "functionDoc": "Builds the function type, and puts it in the registry.\n",
      "diff": "@@ -1,23 +1,23 @@\n FunctionType buildAndRegister() {\n     if (returnType \u003d\u003d null || parametersNode \u003d\u003d null) {\n         throw new IllegalStateException(\"All Function types must have params and a return type\");\n     }\n     FunctionType fnType;\n     if (isConstructor) {\n         fnType \u003d getOrCreateConstructor();\n     } else if (isInterface) {\n         fnType \u003d typeRegistry.createInterfaceType(fnName, sourceNode);\n         if (scope.isGlobal() \u0026\u0026 !fnName.isEmpty()) {\n             typeRegistry.declareType(fnName, fnType.getInstanceType());\n         }\n         maybeSetBaseType(fnType);\n     } else {\n-        fnType \u003d new FunctionType(typeRegistry, fnName, sourceNode, parametersNode, returnType, thisType, templateTypeName);\n+        fnType \u003d typeRegistry.createMethodTypeWithTypeTemplate(fnName, sourceNode, parametersNode, returnType, thisType, templateTypeName);\n         maybeSetBaseType(fnType);\n     }\n     if (implementedInterfaces !\u003d null) {\n         fnType.setImplementedInterfaces(implementedInterfaces);\n     }\n     typeRegistry.clearTemplateTypeName();\n     return fnType;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": {
      "type": "Yintroduced",
      "commitMessage": "Initial commit.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/3/09, 3:51 PM",
      "commitName": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "diff": "@@ -0,0 +1,23 @@\n+FunctionType buildAndRegister() {\n+    if (returnType \u003d\u003d null || parametersNode \u003d\u003d null) {\n+        throw new IllegalStateException(\"All Function types must have params and a return type\");\n+    }\n+    FunctionType fnType;\n+    if (isConstructor) {\n+        fnType \u003d getOrCreateConstructor();\n+    } else if (isInterface) {\n+        fnType \u003d typeRegistry.createInterfaceType(fnName, sourceNode);\n+        if (scope.isGlobal() \u0026\u0026 !fnName.isEmpty()) {\n+            typeRegistry.declareType(fnName, fnType.getInstanceType());\n+        }\n+        maybeSetBaseType(fnType);\n+    } else {\n+        fnType \u003d new FunctionType(typeRegistry, fnName, sourceNode, parametersNode, returnType, thisType, templateTypeName);\n+        maybeSetBaseType(fnType);\n+    }\n+    if (implementedInterfaces !\u003d null) {\n+        fnType.setImplementedInterfaces(implementedInterfaces);\n+    }\n+    typeRegistry.clearTemplateTypeName();\n+    return fnType;\n+}\n\\ No newline at end of file\n",
      "actualSource": "FunctionType buildAndRegister() {\n    if (returnType \u003d\u003d null || parametersNode \u003d\u003d null) {\n        throw new IllegalStateException(\"All Function types must have params and a return type\");\n    }\n    FunctionType fnType;\n    if (isConstructor) {\n        fnType \u003d getOrCreateConstructor();\n    } else if (isInterface) {\n        fnType \u003d typeRegistry.createInterfaceType(fnName, sourceNode);\n        if (scope.isGlobal() \u0026\u0026 !fnName.isEmpty()) {\n            typeRegistry.declareType(fnName, fnType.getInstanceType());\n        }\n        maybeSetBaseType(fnType);\n    } else {\n        fnType \u003d new FunctionType(typeRegistry, fnName, sourceNode, parametersNode, returnType, thisType, templateTypeName);\n        maybeSetBaseType(fnType);\n    }\n    if (implementedInterfaces !\u003d null) {\n        fnType.setImplementedInterfaces(implementedInterfaces);\n    }\n    typeRegistry.clearTemplateTypeName();\n    return fnType;\n}",
      "path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
      "functionStartLine": 471,
      "functionName": "buildAndRegister",
      "functionAnnotation": "",
      "functionDoc": "Builds the function type, and puts it in the registry.\n"
    }
  }
}