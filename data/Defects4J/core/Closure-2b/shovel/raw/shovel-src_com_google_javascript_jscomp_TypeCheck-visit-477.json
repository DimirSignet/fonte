{
  "origin": "codeshovel",
  "repositoryName": "Closure-2b",
  "repositoryPath": "/tmp/Closure-2b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "TypeCheck.java",
  "functionName": "visit",
  "functionId": "visit___t-NodeTraversal__n-Node__parent-Node",
  "sourceFilePath": "src/com/google/javascript/jscomp/TypeCheck.java",
  "functionAnnotation": "@Override",
  "functionDoc": "This is the meat of the type checking.  It is basically one big switch,\nwith each case representing one type of parse tree node.  The individual\ncases are usually pretty straightforward.\n\n@param t The node traversal object that supplies context, such as the\nscope chain to use in name lookups as well as error reporting.\n@param n The node being visited.\n@param parent The parent of the node n.\n",
  "functionStartLine": 477,
  "functionEndLine": 853,
  "numCommitsSeen": 101,
  "timeTaken": 10161,
  "changeHistory": [
    "51b1e6ea99b59e4e7fb593679502f567a7364379",
    "0b054d7d1b185b02c595c646bc0f11a6d809c934",
    "24fd842a5380a350bcde0bed60287053bc9b37f0",
    "5428589fcac11bb899a44ef827e12a253e29d323",
    "d93f2d5aaf346749eaa6ae1641a171aeb177de5d",
    "e237d2643b102fbea616717806391f48e2ce506a",
    "bbf1b138e20a36ca79b2a012ae145c943929a6dd",
    "00241aa722c2245784e63dba9d444fce88134aed",
    "63e875373844bdb6cedc7be3f537baa32cbd2ec0",
    "4f663a93dcdc8130cf92c3ad31ce8a8ac1fd0804",
    "2e823fbd0b74b1a0877f6c4474e8e1c5c42029c0",
    "23a670113ef854291ae5e3d7209657d372fefd8e",
    "9f0375c73c77ef134000d980a32f46f6085db042",
    "cd25d5c37ab839090a74c2ed49f924e22de13057",
    "f412f0c0efd54842b30207c845d65cb826217fd6",
    "5f8b6f54294ce8b454f78165f5230b3759d11e37",
    "925a8f78c8c6a407435e6fb4513ad96d617643a3",
    "39f629a8cfaab37da55288010640d7e516000b1f",
    "5524adbda991632656059566b69cc2771ba42b7d",
    "ec324a9bb23eb78c76f537f4c4170ba88d542f1c",
    "6641663fa9970c4d7bcdd96a6f31b83b18c3ee3d",
    "76abdf11394c0e7515ae63335676ea3657badb45",
    "0235adc719d0858653861b8ced39a1d057cf93a0",
    "59a30b48325cccadabae8687fdf603d72e26c157",
    "75aa5f653b08995428743f6951a99ad101e73e37",
    "70f817ae4f80ac11dd2dfe97babf5896c690fb48",
    "9d9957fdd23ff13d187d4b8832d580bf8622baf6",
    "0895c28861ee4a1969acc858f1a703ab11ddc64c",
    "222eafd303155b3eac5cd244584b2cb3c4c11975",
    "f01925cbf7a39a885e51865208368e861d25a0c1",
    "8c5eb247cb5361a6ffa2d86aa4c2de17c234bda7",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3"
  ],
  "changeHistoryShort": {
    "51b1e6ea99b59e4e7fb593679502f567a7364379": "Ybodychange",
    "0b054d7d1b185b02c595c646bc0f11a6d809c934": "Ybodychange",
    "24fd842a5380a350bcde0bed60287053bc9b37f0": "Ybodychange",
    "5428589fcac11bb899a44ef827e12a253e29d323": "Ybodychange",
    "d93f2d5aaf346749eaa6ae1641a171aeb177de5d": "Ybodychange",
    "e237d2643b102fbea616717806391f48e2ce506a": "Ybodychange",
    "bbf1b138e20a36ca79b2a012ae145c943929a6dd": "Ybodychange",
    "00241aa722c2245784e63dba9d444fce88134aed": "Ybodychange",
    "63e875373844bdb6cedc7be3f537baa32cbd2ec0": "Ybodychange",
    "4f663a93dcdc8130cf92c3ad31ce8a8ac1fd0804": "Ybodychange",
    "2e823fbd0b74b1a0877f6c4474e8e1c5c42029c0": "Ybodychange",
    "23a670113ef854291ae5e3d7209657d372fefd8e": "Ybodychange",
    "9f0375c73c77ef134000d980a32f46f6085db042": "Ybodychange",
    "cd25d5c37ab839090a74c2ed49f924e22de13057": "Ybodychange",
    "f412f0c0efd54842b30207c845d65cb826217fd6": "Ybodychange",
    "5f8b6f54294ce8b454f78165f5230b3759d11e37": "Ybodychange",
    "925a8f78c8c6a407435e6fb4513ad96d617643a3": "Ybodychange",
    "39f629a8cfaab37da55288010640d7e516000b1f": "Ybodychange",
    "5524adbda991632656059566b69cc2771ba42b7d": "Ybodychange",
    "ec324a9bb23eb78c76f537f4c4170ba88d542f1c": "Ybodychange",
    "6641663fa9970c4d7bcdd96a6f31b83b18c3ee3d": "Ybodychange",
    "76abdf11394c0e7515ae63335676ea3657badb45": "Yannotationchange",
    "0235adc719d0858653861b8ced39a1d057cf93a0": "Ybodychange",
    "59a30b48325cccadabae8687fdf603d72e26c157": "Ybodychange",
    "75aa5f653b08995428743f6951a99ad101e73e37": "Ybodychange",
    "70f817ae4f80ac11dd2dfe97babf5896c690fb48": "Ybodychange",
    "9d9957fdd23ff13d187d4b8832d580bf8622baf6": "Ybodychange",
    "0895c28861ee4a1969acc858f1a703ab11ddc64c": "Ybodychange",
    "222eafd303155b3eac5cd244584b2cb3c4c11975": "Ybodychange",
    "f01925cbf7a39a885e51865208368e861d25a0c1": "Ybodychange",
    "8c5eb247cb5361a6ffa2d86aa4c2de17c234bda7": "Ybodychange",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "51b1e6ea99b59e4e7fb593679502f567a7364379": {
      "type": "Ybodychange",
      "commitMessage": "\nBugfix for object literals that are structs or dicts.\n\nR\u003dnicksantos\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d6027\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2413 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "12/19/12, 10:43 AM",
      "commitName": "51b1e6ea99b59e4e7fb593679502f567a7364379",
      "commitAuthor": "dimvar@google.com",
      "commitDateOld": "12/12/12, 5:18 PM",
      "commitNameOld": "0b054d7d1b185b02c595c646bc0f11a6d809c934",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 6.73,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    boolean typeable \u003d true;\n    switch(n.getType()) {\n        case Token.CAST:\n            Node expr \u003d n.getFirstChild();\n            ensureTyped(t, n, getJSType(expr));\n            JSType castType \u003d getJSType(n);\n            JSType exprType \u003d getJSType(expr);\n            if (castType.isSubtype(exprType)) {\n                expr.setJSType(castType);\n            }\n            break;\n        case Token.NAME:\n            typeable \u003d visitName(t, n, parent);\n            break;\n        case Token.PARAM_LIST:\n            typeable \u003d false;\n            break;\n        case Token.COMMA:\n            ensureTyped(t, n, getJSType(n.getLastChild()));\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.THIS:\n            ensureTyped(t, n, t.getScope().getTypeOfThis());\n            break;\n        case Token.NULL:\n            ensureTyped(t, n, NULL_TYPE);\n            break;\n        case Token.NUMBER:\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.STRING:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.STRING_KEY:\n            typeable \u003d false;\n            break;\n        case Token.GETTER_DEF:\n        case Token.SETTER_DEF:\n            break;\n        case Token.ARRAYLIT:\n            ensureTyped(t, n, ARRAY_TYPE);\n            break;\n        case Token.REGEXP:\n            ensureTyped(t, n, REGEXP_TYPE);\n            break;\n        case Token.GETPROP:\n            visitGetProp(t, n, parent);\n            typeable \u003d !(parent.isAssign() \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n            break;\n        case Token.GETELEM:\n            visitGetElem(t, n);\n            typeable \u003d false;\n            break;\n        case Token.VAR:\n            visitVar(t, n);\n            typeable \u003d false;\n            break;\n        case Token.NEW:\n            visitNew(t, n);\n            break;\n        case Token.CALL:\n            visitCall(t, n);\n            typeable \u003d !parent.isExprResult();\n            break;\n        case Token.RETURN:\n            visitReturn(t, n);\n            typeable \u003d false;\n            break;\n        case Token.DEC:\n        case Token.INC:\n            left \u003d n.getFirstChild();\n            checkPropCreation(t, left);\n            validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.NOT:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.VOID:\n            ensureTyped(t, n, VOID_TYPE);\n            break;\n        case Token.TYPEOF:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.BITNOT:\n            childType \u003d getJSType(n.getFirstChild());\n            if (!childType.matchesInt32Context()) {\n                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n            }\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.EQ:\n        case Token.NE:\n        case Token.SHEQ:\n        case Token.SHNE:\n            {\n                left \u003d n.getFirstChild();\n                right \u003d n.getLastChild();\n                if (left.isTypeOf()) {\n                    if (right.isString()) {\n                        checkTypeofString(t, right, right.getString());\n                    }\n                } else if (right.isTypeOf() \u0026\u0026 left.isString()) {\n                    checkTypeofString(t, left, left.getString());\n                }\n                leftType \u003d getJSType(left);\n                rightType \u003d getJSType(right);\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                TernaryValue result \u003d TernaryValue.UNKNOWN;\n                if (n.getType() \u003d\u003d Token.EQ || n.getType() \u003d\u003d Token.NE) {\n                    result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                    if (n.isNE()) {\n                        result \u003d result.not();\n                    }\n                } else {\n                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                        result \u003d n.getType() \u003d\u003d Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;\n                    }\n                }\n                if (result !\u003d TernaryValue.UNKNOWN) {\n                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n            leftType \u003d getJSType(n.getFirstChild());\n            rightType \u003d getJSType(n.getLastChild());\n            if (rightType.isNumber()) {\n                validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n            } else if (leftType.isNumber()) {\n                validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n            } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n            } else {\n                String message \u003d \"left side of comparison\";\n                validator.expectString(t, n, leftType, message);\n                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                message \u003d \"right side of comparison\";\n                validator.expectString(t, n, rightType, message);\n                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.IN:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            rightType \u003d getJSType(right);\n            validator.expectString(t, left, getJSType(left), \"left side of \u0027in\u0027\");\n            validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n            if (rightType.isStruct()) {\n                report(t, right, IN_USED_WITH_STRUCT);\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.INSTANCEOF:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n            validator.expectAnyObject(t, left, getJSType(left), \"deterministic instanceof yields false\");\n            validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.ASSIGN:\n            visitAssign(t, n);\n            typeable \u003d false;\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.ASSIGN_URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_SUB:\n        case Token.ASSIGN_ADD:\n        case Token.ASSIGN_MUL:\n            checkPropCreation(t, n.getFirstChild());\n        case Token.LSH:\n        case Token.RSH:\n        case Token.URSH:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITOR:\n        case Token.BITXOR:\n        case Token.BITAND:\n        case Token.SUB:\n        case Token.ADD:\n        case Token.MUL:\n            visitBinaryOperator(n.getType(), t, n);\n            break;\n        case Token.DELPROP:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.CASE:\n            JSType switchType \u003d getJSType(parent.getFirstChild());\n            JSType caseType \u003d getJSType(n.getFirstChild());\n            validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n            typeable \u003d false;\n            break;\n        case Token.WITH:\n            {\n                Node child \u003d n.getFirstChild();\n                childType \u003d getJSType(child);\n                validator.expectObject(t, child, childType, \"with requires an object\");\n                typeable \u003d false;\n                break;\n            }\n        case Token.FUNCTION:\n            visitFunction(t, n);\n            break;\n        case Token.LABEL:\n        case Token.LABEL_NAME:\n        case Token.SWITCH:\n        case Token.BREAK:\n        case Token.CATCH:\n        case Token.TRY:\n        case Token.SCRIPT:\n        case Token.EXPR_RESULT:\n        case Token.BLOCK:\n        case Token.EMPTY:\n        case Token.DEFAULT_CASE:\n        case Token.CONTINUE:\n        case Token.DEBUGGER:\n        case Token.THROW:\n            typeable \u003d false;\n            break;\n        case Token.DO:\n        case Token.IF:\n        case Token.WHILE:\n            typeable \u003d false;\n            break;\n        case Token.FOR:\n            if (NodeUtil.isForIn(n)) {\n                Node obj \u003d n.getChildAtIndex(1);\n                if (getJSType(obj).isStruct()) {\n                    report(t, obj, IN_USED_WITH_STRUCT);\n                }\n            }\n            typeable \u003d false;\n            break;\n        case Token.AND:\n        case Token.HOOK:\n        case Token.OBJECTLIT:\n        case Token.OR:\n            if (n.getJSType() !\u003d null) {\n                ensureTyped(t, n);\n            } else {\n                if ((n.isObjectLit()) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                    ensureTyped(t, n, parent.getJSType());\n                } else {\n                    ensureTyped(t, n);\n                }\n            }\n            if (n.isObjectLit()) {\n                JSType typ \u003d getJSType(n);\n                for (Node key : n.children()) {\n                    visitObjLitKey(t, key, n, typ);\n                }\n            }\n            break;\n        default:\n            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n            ensureTyped(t, n);\n            break;\n    }\n    typeable \u003d typeable \u0026\u0026 !inExterns;\n    if (typeable) {\n        doPercentTypedAccounting(t, n);\n    }\n    checkNoTypeCheckSection(n, false);\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 477,
      "functionName": "visit",
      "functionAnnotation": "@Override",
      "functionDoc": "This is the meat of the type checking.  It is basically one big switch,\nwith each case representing one type of parse tree node.  The individual\ncases are usually pretty straightforward.\n\n@param t The node traversal object that supplies context, such as the\nscope chain to use in name lookups as well as error reporting.\n@param n The node being visited.\n@param parent The parent of the node n.\n",
      "diff": "@@ -1,289 +1,290 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n     JSType childType;\n     JSType leftType, rightType;\n     Node left, right;\n     boolean typeable \u003d true;\n     switch(n.getType()) {\n         case Token.CAST:\n             Node expr \u003d n.getFirstChild();\n             ensureTyped(t, n, getJSType(expr));\n             JSType castType \u003d getJSType(n);\n             JSType exprType \u003d getJSType(expr);\n             if (castType.isSubtype(exprType)) {\n                 expr.setJSType(castType);\n             }\n             break;\n         case Token.NAME:\n             typeable \u003d visitName(t, n, parent);\n             break;\n         case Token.PARAM_LIST:\n             typeable \u003d false;\n             break;\n         case Token.COMMA:\n             ensureTyped(t, n, getJSType(n.getLastChild()));\n             break;\n         case Token.TRUE:\n         case Token.FALSE:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.THIS:\n             ensureTyped(t, n, t.getScope().getTypeOfThis());\n             break;\n         case Token.NULL:\n             ensureTyped(t, n, NULL_TYPE);\n             break;\n         case Token.NUMBER:\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.STRING:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.STRING_KEY:\n             typeable \u003d false;\n             break;\n         case Token.GETTER_DEF:\n         case Token.SETTER_DEF:\n             break;\n         case Token.ARRAYLIT:\n             ensureTyped(t, n, ARRAY_TYPE);\n             break;\n         case Token.REGEXP:\n             ensureTyped(t, n, REGEXP_TYPE);\n             break;\n         case Token.GETPROP:\n             visitGetProp(t, n, parent);\n             typeable \u003d !(parent.isAssign() \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n             break;\n         case Token.GETELEM:\n             visitGetElem(t, n);\n             typeable \u003d false;\n             break;\n         case Token.VAR:\n             visitVar(t, n);\n             typeable \u003d false;\n             break;\n         case Token.NEW:\n             visitNew(t, n);\n             break;\n         case Token.CALL:\n             visitCall(t, n);\n             typeable \u003d !parent.isExprResult();\n             break;\n         case Token.RETURN:\n             visitReturn(t, n);\n             typeable \u003d false;\n             break;\n         case Token.DEC:\n         case Token.INC:\n             left \u003d n.getFirstChild();\n             checkPropCreation(t, left);\n             validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.NOT:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.VOID:\n             ensureTyped(t, n, VOID_TYPE);\n             break;\n         case Token.TYPEOF:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.BITNOT:\n             childType \u003d getJSType(n.getFirstChild());\n             if (!childType.matchesInt32Context()) {\n                 report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n             }\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.POS:\n         case Token.NEG:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.EQ:\n         case Token.NE:\n         case Token.SHEQ:\n         case Token.SHNE:\n             {\n                 left \u003d n.getFirstChild();\n                 right \u003d n.getLastChild();\n                 if (left.isTypeOf()) {\n                     if (right.isString()) {\n                         checkTypeofString(t, right, right.getString());\n                     }\n                 } else if (right.isTypeOf() \u0026\u0026 left.isString()) {\n                     checkTypeofString(t, left, left.getString());\n                 }\n                 leftType \u003d getJSType(left);\n                 rightType \u003d getJSType(right);\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 TernaryValue result \u003d TernaryValue.UNKNOWN;\n                 if (n.getType() \u003d\u003d Token.EQ || n.getType() \u003d\u003d Token.NE) {\n                     result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                     if (n.isNE()) {\n                         result \u003d result.not();\n                     }\n                 } else {\n                     if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                         result \u003d n.getType() \u003d\u003d Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;\n                     }\n                 }\n                 if (result !\u003d TernaryValue.UNKNOWN) {\n                     report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.LT:\n         case Token.LE:\n         case Token.GT:\n         case Token.GE:\n             leftType \u003d getJSType(n.getFirstChild());\n             rightType \u003d getJSType(n.getLastChild());\n             if (rightType.isNumber()) {\n                 validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n             } else if (leftType.isNumber()) {\n                 validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n             } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n             } else {\n                 String message \u003d \"left side of comparison\";\n                 validator.expectString(t, n, leftType, message);\n                 validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                 message \u003d \"right side of comparison\";\n                 validator.expectString(t, n, rightType, message);\n                 validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.IN:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             rightType \u003d getJSType(right);\n             validator.expectString(t, left, getJSType(left), \"left side of \u0027in\u0027\");\n             validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n             if (rightType.isStruct()) {\n                 report(t, right, IN_USED_WITH_STRUCT);\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.INSTANCEOF:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n             validator.expectAnyObject(t, left, getJSType(left), \"deterministic instanceof yields false\");\n             validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.ASSIGN:\n             visitAssign(t, n);\n             typeable \u003d false;\n             break;\n         case Token.ASSIGN_LSH:\n         case Token.ASSIGN_RSH:\n         case Token.ASSIGN_URSH:\n         case Token.ASSIGN_DIV:\n         case Token.ASSIGN_MOD:\n         case Token.ASSIGN_BITOR:\n         case Token.ASSIGN_BITXOR:\n         case Token.ASSIGN_BITAND:\n         case Token.ASSIGN_SUB:\n         case Token.ASSIGN_ADD:\n         case Token.ASSIGN_MUL:\n             checkPropCreation(t, n.getFirstChild());\n         case Token.LSH:\n         case Token.RSH:\n         case Token.URSH:\n         case Token.DIV:\n         case Token.MOD:\n         case Token.BITOR:\n         case Token.BITXOR:\n         case Token.BITAND:\n         case Token.SUB:\n         case Token.ADD:\n         case Token.MUL:\n             visitBinaryOperator(n.getType(), t, n);\n             break;\n         case Token.DELPROP:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.CASE:\n             JSType switchType \u003d getJSType(parent.getFirstChild());\n             JSType caseType \u003d getJSType(n.getFirstChild());\n             validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n             typeable \u003d false;\n             break;\n         case Token.WITH:\n             {\n                 Node child \u003d n.getFirstChild();\n                 childType \u003d getJSType(child);\n                 validator.expectObject(t, child, childType, \"with requires an object\");\n                 typeable \u003d false;\n                 break;\n             }\n         case Token.FUNCTION:\n             visitFunction(t, n);\n             break;\n         case Token.LABEL:\n         case Token.LABEL_NAME:\n         case Token.SWITCH:\n         case Token.BREAK:\n         case Token.CATCH:\n         case Token.TRY:\n         case Token.SCRIPT:\n         case Token.EXPR_RESULT:\n         case Token.BLOCK:\n         case Token.EMPTY:\n         case Token.DEFAULT_CASE:\n         case Token.CONTINUE:\n         case Token.DEBUGGER:\n         case Token.THROW:\n             typeable \u003d false;\n             break;\n         case Token.DO:\n         case Token.IF:\n         case Token.WHILE:\n             typeable \u003d false;\n             break;\n         case Token.FOR:\n             if (NodeUtil.isForIn(n)) {\n                 Node obj \u003d n.getChildAtIndex(1);\n                 if (getJSType(obj).isStruct()) {\n                     report(t, obj, IN_USED_WITH_STRUCT);\n                 }\n             }\n             typeable \u003d false;\n             break;\n         case Token.AND:\n         case Token.HOOK:\n         case Token.OBJECTLIT:\n         case Token.OR:\n             if (n.getJSType() !\u003d null) {\n                 ensureTyped(t, n);\n             } else {\n                 if ((n.isObjectLit()) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                     ensureTyped(t, n, parent.getJSType());\n                 } else {\n                     ensureTyped(t, n);\n                 }\n             }\n             if (n.isObjectLit()) {\n+                JSType typ \u003d getJSType(n);\n                 for (Node key : n.children()) {\n-                    visitObjLitKey(t, key, n);\n+                    visitObjLitKey(t, key, n, typ);\n                 }\n             }\n             break;\n         default:\n             report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n             ensureTyped(t, n);\n             break;\n     }\n     typeable \u003d typeable \u0026\u0026 !inExterns;\n     if (typeable) {\n         doPercentTypedAccounting(t, n);\n     }\n     checkNoTypeCheckSection(n, false);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0b054d7d1b185b02c595c646bc0f11a6d809c934": {
      "type": "Ybodychange",
      "commitMessage": "\nAutomated g4 rollback\n\n*** Reason for rollback ***\n\nDisable cast warnings by default. Most projects however have\nit turn up to ERROR.\n\n*** Original change description ***\n\nAutomated g4 rollback.\n\n*** Reason for rollback ***\n\nbreaks various projects without whitelists\n\n*** Original change description ***\n\nIntroduced a CAST ast node\n\nR\u003dnicksantos\nDELTA\u003d1968  (1746 added, 44 deleted, 178 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d5970\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2394 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "12/12/12, 5:18 PM",
      "commitName": "0b054d7d1b185b02c595c646bc0f11a6d809c934",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "12/3/12, 9:30 AM",
      "commitNameOld": "b2430d29987b54e977a5e5e8db9242f4486c750b",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 9.33,
      "commitsBetweenForRepo": 29,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    boolean typeable \u003d true;\n    switch(n.getType()) {\n        case Token.CAST:\n            Node expr \u003d n.getFirstChild();\n            ensureTyped(t, n, getJSType(expr));\n            JSType castType \u003d getJSType(n);\n            JSType exprType \u003d getJSType(expr);\n            if (castType.isSubtype(exprType)) {\n                expr.setJSType(castType);\n            }\n            break;\n        case Token.NAME:\n            typeable \u003d visitName(t, n, parent);\n            break;\n        case Token.PARAM_LIST:\n            typeable \u003d false;\n            break;\n        case Token.COMMA:\n            ensureTyped(t, n, getJSType(n.getLastChild()));\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.THIS:\n            ensureTyped(t, n, t.getScope().getTypeOfThis());\n            break;\n        case Token.NULL:\n            ensureTyped(t, n, NULL_TYPE);\n            break;\n        case Token.NUMBER:\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.STRING:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.STRING_KEY:\n            typeable \u003d false;\n            break;\n        case Token.GETTER_DEF:\n        case Token.SETTER_DEF:\n            break;\n        case Token.ARRAYLIT:\n            ensureTyped(t, n, ARRAY_TYPE);\n            break;\n        case Token.REGEXP:\n            ensureTyped(t, n, REGEXP_TYPE);\n            break;\n        case Token.GETPROP:\n            visitGetProp(t, n, parent);\n            typeable \u003d !(parent.isAssign() \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n            break;\n        case Token.GETELEM:\n            visitGetElem(t, n);\n            typeable \u003d false;\n            break;\n        case Token.VAR:\n            visitVar(t, n);\n            typeable \u003d false;\n            break;\n        case Token.NEW:\n            visitNew(t, n);\n            break;\n        case Token.CALL:\n            visitCall(t, n);\n            typeable \u003d !parent.isExprResult();\n            break;\n        case Token.RETURN:\n            visitReturn(t, n);\n            typeable \u003d false;\n            break;\n        case Token.DEC:\n        case Token.INC:\n            left \u003d n.getFirstChild();\n            checkPropCreation(t, left);\n            validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.NOT:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.VOID:\n            ensureTyped(t, n, VOID_TYPE);\n            break;\n        case Token.TYPEOF:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.BITNOT:\n            childType \u003d getJSType(n.getFirstChild());\n            if (!childType.matchesInt32Context()) {\n                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n            }\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.EQ:\n        case Token.NE:\n        case Token.SHEQ:\n        case Token.SHNE:\n            {\n                left \u003d n.getFirstChild();\n                right \u003d n.getLastChild();\n                if (left.isTypeOf()) {\n                    if (right.isString()) {\n                        checkTypeofString(t, right, right.getString());\n                    }\n                } else if (right.isTypeOf() \u0026\u0026 left.isString()) {\n                    checkTypeofString(t, left, left.getString());\n                }\n                leftType \u003d getJSType(left);\n                rightType \u003d getJSType(right);\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                TernaryValue result \u003d TernaryValue.UNKNOWN;\n                if (n.getType() \u003d\u003d Token.EQ || n.getType() \u003d\u003d Token.NE) {\n                    result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                    if (n.isNE()) {\n                        result \u003d result.not();\n                    }\n                } else {\n                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                        result \u003d n.getType() \u003d\u003d Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;\n                    }\n                }\n                if (result !\u003d TernaryValue.UNKNOWN) {\n                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n            leftType \u003d getJSType(n.getFirstChild());\n            rightType \u003d getJSType(n.getLastChild());\n            if (rightType.isNumber()) {\n                validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n            } else if (leftType.isNumber()) {\n                validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n            } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n            } else {\n                String message \u003d \"left side of comparison\";\n                validator.expectString(t, n, leftType, message);\n                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                message \u003d \"right side of comparison\";\n                validator.expectString(t, n, rightType, message);\n                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.IN:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            rightType \u003d getJSType(right);\n            validator.expectString(t, left, getJSType(left), \"left side of \u0027in\u0027\");\n            validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n            if (rightType.isStruct()) {\n                report(t, right, IN_USED_WITH_STRUCT);\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.INSTANCEOF:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n            validator.expectAnyObject(t, left, getJSType(left), \"deterministic instanceof yields false\");\n            validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.ASSIGN:\n            visitAssign(t, n);\n            typeable \u003d false;\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.ASSIGN_URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_SUB:\n        case Token.ASSIGN_ADD:\n        case Token.ASSIGN_MUL:\n            checkPropCreation(t, n.getFirstChild());\n        case Token.LSH:\n        case Token.RSH:\n        case Token.URSH:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITOR:\n        case Token.BITXOR:\n        case Token.BITAND:\n        case Token.SUB:\n        case Token.ADD:\n        case Token.MUL:\n            visitBinaryOperator(n.getType(), t, n);\n            break;\n        case Token.DELPROP:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.CASE:\n            JSType switchType \u003d getJSType(parent.getFirstChild());\n            JSType caseType \u003d getJSType(n.getFirstChild());\n            validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n            typeable \u003d false;\n            break;\n        case Token.WITH:\n            {\n                Node child \u003d n.getFirstChild();\n                childType \u003d getJSType(child);\n                validator.expectObject(t, child, childType, \"with requires an object\");\n                typeable \u003d false;\n                break;\n            }\n        case Token.FUNCTION:\n            visitFunction(t, n);\n            break;\n        case Token.LABEL:\n        case Token.LABEL_NAME:\n        case Token.SWITCH:\n        case Token.BREAK:\n        case Token.CATCH:\n        case Token.TRY:\n        case Token.SCRIPT:\n        case Token.EXPR_RESULT:\n        case Token.BLOCK:\n        case Token.EMPTY:\n        case Token.DEFAULT_CASE:\n        case Token.CONTINUE:\n        case Token.DEBUGGER:\n        case Token.THROW:\n            typeable \u003d false;\n            break;\n        case Token.DO:\n        case Token.IF:\n        case Token.WHILE:\n            typeable \u003d false;\n            break;\n        case Token.FOR:\n            if (NodeUtil.isForIn(n)) {\n                Node obj \u003d n.getChildAtIndex(1);\n                if (getJSType(obj).isStruct()) {\n                    report(t, obj, IN_USED_WITH_STRUCT);\n                }\n            }\n            typeable \u003d false;\n            break;\n        case Token.AND:\n        case Token.HOOK:\n        case Token.OBJECTLIT:\n        case Token.OR:\n            if (n.getJSType() !\u003d null) {\n                ensureTyped(t, n);\n            } else {\n                if ((n.isObjectLit()) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                    ensureTyped(t, n, parent.getJSType());\n                } else {\n                    ensureTyped(t, n);\n                }\n            }\n            if (n.isObjectLit()) {\n                for (Node key : n.children()) {\n                    visitObjLitKey(t, key, n);\n                }\n            }\n            break;\n        default:\n            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n            ensureTyped(t, n);\n            break;\n    }\n    typeable \u003d typeable \u0026\u0026 !inExterns;\n    if (typeable) {\n        doPercentTypedAccounting(t, n);\n    }\n    checkNoTypeCheckSection(n, false);\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 471,
      "functionName": "visit",
      "functionAnnotation": "@Override",
      "functionDoc": "This is the meat of the type checking.  It is basically one big switch,\nwith each case representing one type of parse tree node.  The individual\ncases are usually pretty straightforward.\n\n@param t The node traversal object that supplies context, such as the\nscope chain to use in name lookups as well as error reporting.\n@param n The node being visited.\n@param parent The parent of the node n.\n",
      "diff": "@@ -1,280 +1,289 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n     JSType childType;\n     JSType leftType, rightType;\n     Node left, right;\n     boolean typeable \u003d true;\n     switch(n.getType()) {\n+        case Token.CAST:\n+            Node expr \u003d n.getFirstChild();\n+            ensureTyped(t, n, getJSType(expr));\n+            JSType castType \u003d getJSType(n);\n+            JSType exprType \u003d getJSType(expr);\n+            if (castType.isSubtype(exprType)) {\n+                expr.setJSType(castType);\n+            }\n+            break;\n         case Token.NAME:\n             typeable \u003d visitName(t, n, parent);\n             break;\n         case Token.PARAM_LIST:\n             typeable \u003d false;\n             break;\n         case Token.COMMA:\n             ensureTyped(t, n, getJSType(n.getLastChild()));\n             break;\n         case Token.TRUE:\n         case Token.FALSE:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.THIS:\n             ensureTyped(t, n, t.getScope().getTypeOfThis());\n             break;\n         case Token.NULL:\n             ensureTyped(t, n, NULL_TYPE);\n             break;\n         case Token.NUMBER:\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.STRING:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.STRING_KEY:\n             typeable \u003d false;\n             break;\n         case Token.GETTER_DEF:\n         case Token.SETTER_DEF:\n             break;\n         case Token.ARRAYLIT:\n             ensureTyped(t, n, ARRAY_TYPE);\n             break;\n         case Token.REGEXP:\n             ensureTyped(t, n, REGEXP_TYPE);\n             break;\n         case Token.GETPROP:\n             visitGetProp(t, n, parent);\n             typeable \u003d !(parent.isAssign() \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n             break;\n         case Token.GETELEM:\n             visitGetElem(t, n);\n             typeable \u003d false;\n             break;\n         case Token.VAR:\n             visitVar(t, n);\n             typeable \u003d false;\n             break;\n         case Token.NEW:\n             visitNew(t, n);\n             break;\n         case Token.CALL:\n             visitCall(t, n);\n             typeable \u003d !parent.isExprResult();\n             break;\n         case Token.RETURN:\n             visitReturn(t, n);\n             typeable \u003d false;\n             break;\n         case Token.DEC:\n         case Token.INC:\n             left \u003d n.getFirstChild();\n             checkPropCreation(t, left);\n             validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.NOT:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.VOID:\n             ensureTyped(t, n, VOID_TYPE);\n             break;\n         case Token.TYPEOF:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.BITNOT:\n             childType \u003d getJSType(n.getFirstChild());\n             if (!childType.matchesInt32Context()) {\n                 report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n             }\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.POS:\n         case Token.NEG:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.EQ:\n         case Token.NE:\n         case Token.SHEQ:\n         case Token.SHNE:\n             {\n                 left \u003d n.getFirstChild();\n                 right \u003d n.getLastChild();\n                 if (left.isTypeOf()) {\n                     if (right.isString()) {\n                         checkTypeofString(t, right, right.getString());\n                     }\n                 } else if (right.isTypeOf() \u0026\u0026 left.isString()) {\n                     checkTypeofString(t, left, left.getString());\n                 }\n                 leftType \u003d getJSType(left);\n                 rightType \u003d getJSType(right);\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 TernaryValue result \u003d TernaryValue.UNKNOWN;\n                 if (n.getType() \u003d\u003d Token.EQ || n.getType() \u003d\u003d Token.NE) {\n                     result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                     if (n.isNE()) {\n                         result \u003d result.not();\n                     }\n                 } else {\n                     if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                         result \u003d n.getType() \u003d\u003d Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;\n                     }\n                 }\n                 if (result !\u003d TernaryValue.UNKNOWN) {\n                     report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.LT:\n         case Token.LE:\n         case Token.GT:\n         case Token.GE:\n             leftType \u003d getJSType(n.getFirstChild());\n             rightType \u003d getJSType(n.getLastChild());\n             if (rightType.isNumber()) {\n                 validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n             } else if (leftType.isNumber()) {\n                 validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n             } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n             } else {\n                 String message \u003d \"left side of comparison\";\n                 validator.expectString(t, n, leftType, message);\n                 validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                 message \u003d \"right side of comparison\";\n                 validator.expectString(t, n, rightType, message);\n                 validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.IN:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             rightType \u003d getJSType(right);\n             validator.expectString(t, left, getJSType(left), \"left side of \u0027in\u0027\");\n             validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n             if (rightType.isStruct()) {\n                 report(t, right, IN_USED_WITH_STRUCT);\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.INSTANCEOF:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n             validator.expectAnyObject(t, left, getJSType(left), \"deterministic instanceof yields false\");\n             validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.ASSIGN:\n             visitAssign(t, n);\n             typeable \u003d false;\n             break;\n         case Token.ASSIGN_LSH:\n         case Token.ASSIGN_RSH:\n         case Token.ASSIGN_URSH:\n         case Token.ASSIGN_DIV:\n         case Token.ASSIGN_MOD:\n         case Token.ASSIGN_BITOR:\n         case Token.ASSIGN_BITXOR:\n         case Token.ASSIGN_BITAND:\n         case Token.ASSIGN_SUB:\n         case Token.ASSIGN_ADD:\n         case Token.ASSIGN_MUL:\n             checkPropCreation(t, n.getFirstChild());\n         case Token.LSH:\n         case Token.RSH:\n         case Token.URSH:\n         case Token.DIV:\n         case Token.MOD:\n         case Token.BITOR:\n         case Token.BITXOR:\n         case Token.BITAND:\n         case Token.SUB:\n         case Token.ADD:\n         case Token.MUL:\n             visitBinaryOperator(n.getType(), t, n);\n             break;\n         case Token.DELPROP:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.CASE:\n             JSType switchType \u003d getJSType(parent.getFirstChild());\n             JSType caseType \u003d getJSType(n.getFirstChild());\n             validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n             typeable \u003d false;\n             break;\n         case Token.WITH:\n             {\n                 Node child \u003d n.getFirstChild();\n                 childType \u003d getJSType(child);\n                 validator.expectObject(t, child, childType, \"with requires an object\");\n                 typeable \u003d false;\n                 break;\n             }\n         case Token.FUNCTION:\n             visitFunction(t, n);\n             break;\n         case Token.LABEL:\n         case Token.LABEL_NAME:\n         case Token.SWITCH:\n         case Token.BREAK:\n         case Token.CATCH:\n         case Token.TRY:\n         case Token.SCRIPT:\n         case Token.EXPR_RESULT:\n         case Token.BLOCK:\n         case Token.EMPTY:\n         case Token.DEFAULT_CASE:\n         case Token.CONTINUE:\n         case Token.DEBUGGER:\n         case Token.THROW:\n             typeable \u003d false;\n             break;\n         case Token.DO:\n         case Token.IF:\n         case Token.WHILE:\n             typeable \u003d false;\n             break;\n         case Token.FOR:\n             if (NodeUtil.isForIn(n)) {\n                 Node obj \u003d n.getChildAtIndex(1);\n                 if (getJSType(obj).isStruct()) {\n                     report(t, obj, IN_USED_WITH_STRUCT);\n                 }\n             }\n             typeable \u003d false;\n             break;\n         case Token.AND:\n         case Token.HOOK:\n         case Token.OBJECTLIT:\n         case Token.OR:\n             if (n.getJSType() !\u003d null) {\n                 ensureTyped(t, n);\n             } else {\n                 if ((n.isObjectLit()) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                     ensureTyped(t, n, parent.getJSType());\n                 } else {\n                     ensureTyped(t, n);\n                 }\n             }\n             if (n.isObjectLit()) {\n                 for (Node key : n.children()) {\n                     visitObjLitKey(t, key, n);\n                 }\n             }\n             break;\n         default:\n             report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n             ensureTyped(t, n);\n             break;\n     }\n     typeable \u003d typeable \u0026\u0026 !inExterns;\n     if (typeable) {\n         doPercentTypedAccounting(t, n);\n     }\n     checkNoTypeCheckSection(n, false);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "24fd842a5380a350bcde0bed60287053bc9b37f0": {
      "type": "Ybodychange",
      "commitMessage": "\nAutomated g4 rollback \n\n*** Reason for rollback ***\n\nbreaks various projects without whitelists\n\n*** Original change description ***\n\nIntroduced a CAST ast node\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d5848\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2334 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/19/12, 3:19 PM",
      "commitName": "24fd842a5380a350bcde0bed60287053bc9b37f0",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "11/19/12, 1:47 PM",
      "commitNameOld": "5428589fcac11bb899a44ef827e12a253e29d323",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 0.06,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    boolean typeable \u003d true;\n    switch(n.getType()) {\n        case Token.NAME:\n            typeable \u003d visitName(t, n, parent);\n            break;\n        case Token.PARAM_LIST:\n            typeable \u003d false;\n            break;\n        case Token.COMMA:\n            ensureTyped(t, n, getJSType(n.getLastChild()));\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.THIS:\n            ensureTyped(t, n, t.getScope().getTypeOfThis());\n            break;\n        case Token.NULL:\n            ensureTyped(t, n, NULL_TYPE);\n            break;\n        case Token.NUMBER:\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.STRING:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.STRING_KEY:\n            typeable \u003d false;\n            break;\n        case Token.GETTER_DEF:\n        case Token.SETTER_DEF:\n            break;\n        case Token.ARRAYLIT:\n            ensureTyped(t, n, ARRAY_TYPE);\n            break;\n        case Token.REGEXP:\n            ensureTyped(t, n, REGEXP_TYPE);\n            break;\n        case Token.GETPROP:\n            visitGetProp(t, n, parent);\n            typeable \u003d !(parent.isAssign() \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n            break;\n        case Token.GETELEM:\n            visitGetElem(t, n);\n            typeable \u003d false;\n            break;\n        case Token.VAR:\n            visitVar(t, n);\n            typeable \u003d false;\n            break;\n        case Token.NEW:\n            visitNew(t, n);\n            break;\n        case Token.CALL:\n            visitCall(t, n);\n            typeable \u003d !parent.isExprResult();\n            break;\n        case Token.RETURN:\n            visitReturn(t, n);\n            typeable \u003d false;\n            break;\n        case Token.DEC:\n        case Token.INC:\n            left \u003d n.getFirstChild();\n            checkPropCreation(t, left);\n            validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.NOT:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.VOID:\n            ensureTyped(t, n, VOID_TYPE);\n            break;\n        case Token.TYPEOF:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.BITNOT:\n            childType \u003d getJSType(n.getFirstChild());\n            if (!childType.matchesInt32Context()) {\n                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n            }\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.EQ:\n        case Token.NE:\n        case Token.SHEQ:\n        case Token.SHNE:\n            {\n                left \u003d n.getFirstChild();\n                right \u003d n.getLastChild();\n                if (left.isTypeOf()) {\n                    if (right.isString()) {\n                        checkTypeofString(t, right, right.getString());\n                    }\n                } else if (right.isTypeOf() \u0026\u0026 left.isString()) {\n                    checkTypeofString(t, left, left.getString());\n                }\n                leftType \u003d getJSType(left);\n                rightType \u003d getJSType(right);\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                TernaryValue result \u003d TernaryValue.UNKNOWN;\n                if (n.getType() \u003d\u003d Token.EQ || n.getType() \u003d\u003d Token.NE) {\n                    result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                    if (n.isNE()) {\n                        result \u003d result.not();\n                    }\n                } else {\n                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                        result \u003d n.getType() \u003d\u003d Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;\n                    }\n                }\n                if (result !\u003d TernaryValue.UNKNOWN) {\n                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n            leftType \u003d getJSType(n.getFirstChild());\n            rightType \u003d getJSType(n.getLastChild());\n            if (rightType.isNumber()) {\n                validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n            } else if (leftType.isNumber()) {\n                validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n            } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n            } else {\n                String message \u003d \"left side of comparison\";\n                validator.expectString(t, n, leftType, message);\n                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                message \u003d \"right side of comparison\";\n                validator.expectString(t, n, rightType, message);\n                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.IN:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            rightType \u003d getJSType(right);\n            validator.expectString(t, left, getJSType(left), \"left side of \u0027in\u0027\");\n            validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n            if (rightType.isStruct()) {\n                report(t, right, IN_USED_WITH_STRUCT);\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.INSTANCEOF:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n            validator.expectAnyObject(t, left, getJSType(left), \"deterministic instanceof yields false\");\n            validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.ASSIGN:\n            visitAssign(t, n);\n            typeable \u003d false;\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.ASSIGN_URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_SUB:\n        case Token.ASSIGN_ADD:\n        case Token.ASSIGN_MUL:\n            checkPropCreation(t, n.getFirstChild());\n        case Token.LSH:\n        case Token.RSH:\n        case Token.URSH:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITOR:\n        case Token.BITXOR:\n        case Token.BITAND:\n        case Token.SUB:\n        case Token.ADD:\n        case Token.MUL:\n            visitBinaryOperator(n.getType(), t, n);\n            break;\n        case Token.DELPROP:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.CASE:\n            JSType switchType \u003d getJSType(parent.getFirstChild());\n            JSType caseType \u003d getJSType(n.getFirstChild());\n            validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n            typeable \u003d false;\n            break;\n        case Token.WITH:\n            {\n                Node child \u003d n.getFirstChild();\n                childType \u003d getJSType(child);\n                validator.expectObject(t, child, childType, \"with requires an object\");\n                typeable \u003d false;\n                break;\n            }\n        case Token.FUNCTION:\n            visitFunction(t, n);\n            break;\n        case Token.LABEL:\n        case Token.LABEL_NAME:\n        case Token.SWITCH:\n        case Token.BREAK:\n        case Token.CATCH:\n        case Token.TRY:\n        case Token.SCRIPT:\n        case Token.EXPR_RESULT:\n        case Token.BLOCK:\n        case Token.EMPTY:\n        case Token.DEFAULT_CASE:\n        case Token.CONTINUE:\n        case Token.DEBUGGER:\n        case Token.THROW:\n            typeable \u003d false;\n            break;\n        case Token.DO:\n        case Token.IF:\n        case Token.WHILE:\n            typeable \u003d false;\n            break;\n        case Token.FOR:\n            if (NodeUtil.isForIn(n)) {\n                Node obj \u003d n.getChildAtIndex(1);\n                if (getJSType(obj).isStruct()) {\n                    report(t, obj, IN_USED_WITH_STRUCT);\n                }\n            }\n            typeable \u003d false;\n            break;\n        case Token.AND:\n        case Token.HOOK:\n        case Token.OBJECTLIT:\n        case Token.OR:\n            if (n.getJSType() !\u003d null) {\n                ensureTyped(t, n);\n            } else {\n                if ((n.isObjectLit()) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                    ensureTyped(t, n, parent.getJSType());\n                } else {\n                    ensureTyped(t, n);\n                }\n            }\n            if (n.isObjectLit()) {\n                for (Node key : n.children()) {\n                    visitObjLitKey(t, key, n);\n                }\n            }\n            break;\n        default:\n            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n            ensureTyped(t, n);\n            break;\n    }\n    typeable \u003d typeable \u0026\u0026 !inExterns;\n    if (typeable) {\n        doPercentTypedAccounting(t, n);\n    }\n    checkNoTypeCheckSection(n, false);\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 471,
      "functionName": "visit",
      "functionAnnotation": "@Override",
      "functionDoc": "This is the meat of the type checking.  It is basically one big switch,\nwith each case representing one type of parse tree node.  The individual\ncases are usually pretty straightforward.\n\n@param t The node traversal object that supplies context, such as the\nscope chain to use in name lookups as well as error reporting.\n@param n The node being visited.\n@param parent The parent of the node n.\n",
      "diff": "@@ -1,289 +1,280 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n     JSType childType;\n     JSType leftType, rightType;\n     Node left, right;\n     boolean typeable \u003d true;\n     switch(n.getType()) {\n-        case Token.CAST:\n-            Node expr \u003d n.getFirstChild();\n-            ensureTyped(t, n, getJSType(expr));\n-            JSType castType \u003d getJSType(n);\n-            JSType exprType \u003d getJSType(expr);\n-            if (castType.isSubtype(exprType)) {\n-                expr.setJSType(castType);\n-            }\n-            break;\n         case Token.NAME:\n             typeable \u003d visitName(t, n, parent);\n             break;\n         case Token.PARAM_LIST:\n             typeable \u003d false;\n             break;\n         case Token.COMMA:\n             ensureTyped(t, n, getJSType(n.getLastChild()));\n             break;\n         case Token.TRUE:\n         case Token.FALSE:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.THIS:\n             ensureTyped(t, n, t.getScope().getTypeOfThis());\n             break;\n         case Token.NULL:\n             ensureTyped(t, n, NULL_TYPE);\n             break;\n         case Token.NUMBER:\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.STRING:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.STRING_KEY:\n             typeable \u003d false;\n             break;\n         case Token.GETTER_DEF:\n         case Token.SETTER_DEF:\n             break;\n         case Token.ARRAYLIT:\n             ensureTyped(t, n, ARRAY_TYPE);\n             break;\n         case Token.REGEXP:\n             ensureTyped(t, n, REGEXP_TYPE);\n             break;\n         case Token.GETPROP:\n             visitGetProp(t, n, parent);\n             typeable \u003d !(parent.isAssign() \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n             break;\n         case Token.GETELEM:\n             visitGetElem(t, n);\n             typeable \u003d false;\n             break;\n         case Token.VAR:\n             visitVar(t, n);\n             typeable \u003d false;\n             break;\n         case Token.NEW:\n             visitNew(t, n);\n             break;\n         case Token.CALL:\n             visitCall(t, n);\n             typeable \u003d !parent.isExprResult();\n             break;\n         case Token.RETURN:\n             visitReturn(t, n);\n             typeable \u003d false;\n             break;\n         case Token.DEC:\n         case Token.INC:\n             left \u003d n.getFirstChild();\n             checkPropCreation(t, left);\n             validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.NOT:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.VOID:\n             ensureTyped(t, n, VOID_TYPE);\n             break;\n         case Token.TYPEOF:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.BITNOT:\n             childType \u003d getJSType(n.getFirstChild());\n             if (!childType.matchesInt32Context()) {\n                 report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n             }\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.POS:\n         case Token.NEG:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.EQ:\n         case Token.NE:\n         case Token.SHEQ:\n         case Token.SHNE:\n             {\n                 left \u003d n.getFirstChild();\n                 right \u003d n.getLastChild();\n                 if (left.isTypeOf()) {\n                     if (right.isString()) {\n                         checkTypeofString(t, right, right.getString());\n                     }\n                 } else if (right.isTypeOf() \u0026\u0026 left.isString()) {\n                     checkTypeofString(t, left, left.getString());\n                 }\n                 leftType \u003d getJSType(left);\n                 rightType \u003d getJSType(right);\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 TernaryValue result \u003d TernaryValue.UNKNOWN;\n                 if (n.getType() \u003d\u003d Token.EQ || n.getType() \u003d\u003d Token.NE) {\n                     result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                     if (n.isNE()) {\n                         result \u003d result.not();\n                     }\n                 } else {\n                     if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                         result \u003d n.getType() \u003d\u003d Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;\n                     }\n                 }\n                 if (result !\u003d TernaryValue.UNKNOWN) {\n                     report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.LT:\n         case Token.LE:\n         case Token.GT:\n         case Token.GE:\n             leftType \u003d getJSType(n.getFirstChild());\n             rightType \u003d getJSType(n.getLastChild());\n             if (rightType.isNumber()) {\n                 validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n             } else if (leftType.isNumber()) {\n                 validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n             } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n             } else {\n                 String message \u003d \"left side of comparison\";\n                 validator.expectString(t, n, leftType, message);\n                 validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                 message \u003d \"right side of comparison\";\n                 validator.expectString(t, n, rightType, message);\n                 validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.IN:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             rightType \u003d getJSType(right);\n             validator.expectString(t, left, getJSType(left), \"left side of \u0027in\u0027\");\n             validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n             if (rightType.isStruct()) {\n                 report(t, right, IN_USED_WITH_STRUCT);\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.INSTANCEOF:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n             validator.expectAnyObject(t, left, getJSType(left), \"deterministic instanceof yields false\");\n             validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.ASSIGN:\n             visitAssign(t, n);\n             typeable \u003d false;\n             break;\n         case Token.ASSIGN_LSH:\n         case Token.ASSIGN_RSH:\n         case Token.ASSIGN_URSH:\n         case Token.ASSIGN_DIV:\n         case Token.ASSIGN_MOD:\n         case Token.ASSIGN_BITOR:\n         case Token.ASSIGN_BITXOR:\n         case Token.ASSIGN_BITAND:\n         case Token.ASSIGN_SUB:\n         case Token.ASSIGN_ADD:\n         case Token.ASSIGN_MUL:\n             checkPropCreation(t, n.getFirstChild());\n         case Token.LSH:\n         case Token.RSH:\n         case Token.URSH:\n         case Token.DIV:\n         case Token.MOD:\n         case Token.BITOR:\n         case Token.BITXOR:\n         case Token.BITAND:\n         case Token.SUB:\n         case Token.ADD:\n         case Token.MUL:\n             visitBinaryOperator(n.getType(), t, n);\n             break;\n         case Token.DELPROP:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.CASE:\n             JSType switchType \u003d getJSType(parent.getFirstChild());\n             JSType caseType \u003d getJSType(n.getFirstChild());\n             validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n             typeable \u003d false;\n             break;\n         case Token.WITH:\n             {\n                 Node child \u003d n.getFirstChild();\n                 childType \u003d getJSType(child);\n                 validator.expectObject(t, child, childType, \"with requires an object\");\n                 typeable \u003d false;\n                 break;\n             }\n         case Token.FUNCTION:\n             visitFunction(t, n);\n             break;\n         case Token.LABEL:\n         case Token.LABEL_NAME:\n         case Token.SWITCH:\n         case Token.BREAK:\n         case Token.CATCH:\n         case Token.TRY:\n         case Token.SCRIPT:\n         case Token.EXPR_RESULT:\n         case Token.BLOCK:\n         case Token.EMPTY:\n         case Token.DEFAULT_CASE:\n         case Token.CONTINUE:\n         case Token.DEBUGGER:\n         case Token.THROW:\n             typeable \u003d false;\n             break;\n         case Token.DO:\n         case Token.IF:\n         case Token.WHILE:\n             typeable \u003d false;\n             break;\n         case Token.FOR:\n             if (NodeUtil.isForIn(n)) {\n                 Node obj \u003d n.getChildAtIndex(1);\n                 if (getJSType(obj).isStruct()) {\n                     report(t, obj, IN_USED_WITH_STRUCT);\n                 }\n             }\n             typeable \u003d false;\n             break;\n         case Token.AND:\n         case Token.HOOK:\n         case Token.OBJECTLIT:\n         case Token.OR:\n             if (n.getJSType() !\u003d null) {\n                 ensureTyped(t, n);\n             } else {\n                 if ((n.isObjectLit()) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                     ensureTyped(t, n, parent.getJSType());\n                 } else {\n                     ensureTyped(t, n);\n                 }\n             }\n             if (n.isObjectLit()) {\n                 for (Node key : n.children()) {\n                     visitObjLitKey(t, key, n);\n                 }\n             }\n             break;\n         default:\n             report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n             ensureTyped(t, n);\n             break;\n     }\n     typeable \u003d typeable \u0026\u0026 !inExterns;\n     if (typeable) {\n         doPercentTypedAccounting(t, n);\n     }\n     checkNoTypeCheckSection(n, false);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5428589fcac11bb899a44ef827e12a253e29d323": {
      "type": "Ybodychange",
      "commitMessage": "\nIntroduced a CAST ast node\n\nR\u003dnicksantos,dimvar\nDELTA\u003d2832  (2746 added, 13 deleted, 73 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d5846\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2332 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/19/12, 1:47 PM",
      "commitName": "5428589fcac11bb899a44ef827e12a253e29d323",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "11/5/12, 12:49 PM",
      "commitNameOld": "8eac7e1fa30f431056d01c9603b5337a4003244c",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 14.04,
      "commitsBetweenForRepo": 31,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    boolean typeable \u003d true;\n    switch(n.getType()) {\n        case Token.CAST:\n            Node expr \u003d n.getFirstChild();\n            ensureTyped(t, n, getJSType(expr));\n            JSType castType \u003d getJSType(n);\n            JSType exprType \u003d getJSType(expr);\n            if (castType.isSubtype(exprType)) {\n                expr.setJSType(castType);\n            }\n            break;\n        case Token.NAME:\n            typeable \u003d visitName(t, n, parent);\n            break;\n        case Token.PARAM_LIST:\n            typeable \u003d false;\n            break;\n        case Token.COMMA:\n            ensureTyped(t, n, getJSType(n.getLastChild()));\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.THIS:\n            ensureTyped(t, n, t.getScope().getTypeOfThis());\n            break;\n        case Token.NULL:\n            ensureTyped(t, n, NULL_TYPE);\n            break;\n        case Token.NUMBER:\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.STRING:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.STRING_KEY:\n            typeable \u003d false;\n            break;\n        case Token.GETTER_DEF:\n        case Token.SETTER_DEF:\n            break;\n        case Token.ARRAYLIT:\n            ensureTyped(t, n, ARRAY_TYPE);\n            break;\n        case Token.REGEXP:\n            ensureTyped(t, n, REGEXP_TYPE);\n            break;\n        case Token.GETPROP:\n            visitGetProp(t, n, parent);\n            typeable \u003d !(parent.isAssign() \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n            break;\n        case Token.GETELEM:\n            visitGetElem(t, n);\n            typeable \u003d false;\n            break;\n        case Token.VAR:\n            visitVar(t, n);\n            typeable \u003d false;\n            break;\n        case Token.NEW:\n            visitNew(t, n);\n            break;\n        case Token.CALL:\n            visitCall(t, n);\n            typeable \u003d !parent.isExprResult();\n            break;\n        case Token.RETURN:\n            visitReturn(t, n);\n            typeable \u003d false;\n            break;\n        case Token.DEC:\n        case Token.INC:\n            left \u003d n.getFirstChild();\n            checkPropCreation(t, left);\n            validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.NOT:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.VOID:\n            ensureTyped(t, n, VOID_TYPE);\n            break;\n        case Token.TYPEOF:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.BITNOT:\n            childType \u003d getJSType(n.getFirstChild());\n            if (!childType.matchesInt32Context()) {\n                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n            }\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.EQ:\n        case Token.NE:\n        case Token.SHEQ:\n        case Token.SHNE:\n            {\n                left \u003d n.getFirstChild();\n                right \u003d n.getLastChild();\n                if (left.isTypeOf()) {\n                    if (right.isString()) {\n                        checkTypeofString(t, right, right.getString());\n                    }\n                } else if (right.isTypeOf() \u0026\u0026 left.isString()) {\n                    checkTypeofString(t, left, left.getString());\n                }\n                leftType \u003d getJSType(left);\n                rightType \u003d getJSType(right);\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                TernaryValue result \u003d TernaryValue.UNKNOWN;\n                if (n.getType() \u003d\u003d Token.EQ || n.getType() \u003d\u003d Token.NE) {\n                    result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                    if (n.isNE()) {\n                        result \u003d result.not();\n                    }\n                } else {\n                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                        result \u003d n.getType() \u003d\u003d Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;\n                    }\n                }\n                if (result !\u003d TernaryValue.UNKNOWN) {\n                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n            leftType \u003d getJSType(n.getFirstChild());\n            rightType \u003d getJSType(n.getLastChild());\n            if (rightType.isNumber()) {\n                validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n            } else if (leftType.isNumber()) {\n                validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n            } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n            } else {\n                String message \u003d \"left side of comparison\";\n                validator.expectString(t, n, leftType, message);\n                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                message \u003d \"right side of comparison\";\n                validator.expectString(t, n, rightType, message);\n                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.IN:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            rightType \u003d getJSType(right);\n            validator.expectString(t, left, getJSType(left), \"left side of \u0027in\u0027\");\n            validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n            if (rightType.isStruct()) {\n                report(t, right, IN_USED_WITH_STRUCT);\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.INSTANCEOF:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n            validator.expectAnyObject(t, left, getJSType(left), \"deterministic instanceof yields false\");\n            validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.ASSIGN:\n            visitAssign(t, n);\n            typeable \u003d false;\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.ASSIGN_URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_SUB:\n        case Token.ASSIGN_ADD:\n        case Token.ASSIGN_MUL:\n            checkPropCreation(t, n.getFirstChild());\n        case Token.LSH:\n        case Token.RSH:\n        case Token.URSH:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITOR:\n        case Token.BITXOR:\n        case Token.BITAND:\n        case Token.SUB:\n        case Token.ADD:\n        case Token.MUL:\n            visitBinaryOperator(n.getType(), t, n);\n            break;\n        case Token.DELPROP:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.CASE:\n            JSType switchType \u003d getJSType(parent.getFirstChild());\n            JSType caseType \u003d getJSType(n.getFirstChild());\n            validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n            typeable \u003d false;\n            break;\n        case Token.WITH:\n            {\n                Node child \u003d n.getFirstChild();\n                childType \u003d getJSType(child);\n                validator.expectObject(t, child, childType, \"with requires an object\");\n                typeable \u003d false;\n                break;\n            }\n        case Token.FUNCTION:\n            visitFunction(t, n);\n            break;\n        case Token.LABEL:\n        case Token.LABEL_NAME:\n        case Token.SWITCH:\n        case Token.BREAK:\n        case Token.CATCH:\n        case Token.TRY:\n        case Token.SCRIPT:\n        case Token.EXPR_RESULT:\n        case Token.BLOCK:\n        case Token.EMPTY:\n        case Token.DEFAULT_CASE:\n        case Token.CONTINUE:\n        case Token.DEBUGGER:\n        case Token.THROW:\n            typeable \u003d false;\n            break;\n        case Token.DO:\n        case Token.IF:\n        case Token.WHILE:\n            typeable \u003d false;\n            break;\n        case Token.FOR:\n            if (NodeUtil.isForIn(n)) {\n                Node obj \u003d n.getChildAtIndex(1);\n                if (getJSType(obj).isStruct()) {\n                    report(t, obj, IN_USED_WITH_STRUCT);\n                }\n            }\n            typeable \u003d false;\n            break;\n        case Token.AND:\n        case Token.HOOK:\n        case Token.OBJECTLIT:\n        case Token.OR:\n            if (n.getJSType() !\u003d null) {\n                ensureTyped(t, n);\n            } else {\n                if ((n.isObjectLit()) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                    ensureTyped(t, n, parent.getJSType());\n                } else {\n                    ensureTyped(t, n);\n                }\n            }\n            if (n.isObjectLit()) {\n                for (Node key : n.children()) {\n                    visitObjLitKey(t, key, n);\n                }\n            }\n            break;\n        default:\n            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n            ensureTyped(t, n);\n            break;\n    }\n    typeable \u003d typeable \u0026\u0026 !inExterns;\n    if (typeable) {\n        doPercentTypedAccounting(t, n);\n    }\n    checkNoTypeCheckSection(n, false);\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 471,
      "functionName": "visit",
      "functionAnnotation": "@Override",
      "functionDoc": "This is the meat of the type checking.  It is basically one big switch,\nwith each case representing one type of parse tree node.  The individual\ncases are usually pretty straightforward.\n\n@param t The node traversal object that supplies context, such as the\nscope chain to use in name lookups as well as error reporting.\n@param n The node being visited.\n@param parent The parent of the node n.\n",
      "diff": "@@ -1,280 +1,289 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n     JSType childType;\n     JSType leftType, rightType;\n     Node left, right;\n     boolean typeable \u003d true;\n     switch(n.getType()) {\n+        case Token.CAST:\n+            Node expr \u003d n.getFirstChild();\n+            ensureTyped(t, n, getJSType(expr));\n+            JSType castType \u003d getJSType(n);\n+            JSType exprType \u003d getJSType(expr);\n+            if (castType.isSubtype(exprType)) {\n+                expr.setJSType(castType);\n+            }\n+            break;\n         case Token.NAME:\n             typeable \u003d visitName(t, n, parent);\n             break;\n         case Token.PARAM_LIST:\n             typeable \u003d false;\n             break;\n         case Token.COMMA:\n             ensureTyped(t, n, getJSType(n.getLastChild()));\n             break;\n         case Token.TRUE:\n         case Token.FALSE:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.THIS:\n             ensureTyped(t, n, t.getScope().getTypeOfThis());\n             break;\n         case Token.NULL:\n             ensureTyped(t, n, NULL_TYPE);\n             break;\n         case Token.NUMBER:\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.STRING:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.STRING_KEY:\n             typeable \u003d false;\n             break;\n         case Token.GETTER_DEF:\n         case Token.SETTER_DEF:\n             break;\n         case Token.ARRAYLIT:\n             ensureTyped(t, n, ARRAY_TYPE);\n             break;\n         case Token.REGEXP:\n             ensureTyped(t, n, REGEXP_TYPE);\n             break;\n         case Token.GETPROP:\n             visitGetProp(t, n, parent);\n             typeable \u003d !(parent.isAssign() \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n             break;\n         case Token.GETELEM:\n             visitGetElem(t, n);\n             typeable \u003d false;\n             break;\n         case Token.VAR:\n             visitVar(t, n);\n             typeable \u003d false;\n             break;\n         case Token.NEW:\n             visitNew(t, n);\n             break;\n         case Token.CALL:\n             visitCall(t, n);\n             typeable \u003d !parent.isExprResult();\n             break;\n         case Token.RETURN:\n             visitReturn(t, n);\n             typeable \u003d false;\n             break;\n         case Token.DEC:\n         case Token.INC:\n             left \u003d n.getFirstChild();\n             checkPropCreation(t, left);\n             validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.NOT:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.VOID:\n             ensureTyped(t, n, VOID_TYPE);\n             break;\n         case Token.TYPEOF:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.BITNOT:\n             childType \u003d getJSType(n.getFirstChild());\n             if (!childType.matchesInt32Context()) {\n                 report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n             }\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.POS:\n         case Token.NEG:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.EQ:\n         case Token.NE:\n         case Token.SHEQ:\n         case Token.SHNE:\n             {\n                 left \u003d n.getFirstChild();\n                 right \u003d n.getLastChild();\n                 if (left.isTypeOf()) {\n                     if (right.isString()) {\n                         checkTypeofString(t, right, right.getString());\n                     }\n                 } else if (right.isTypeOf() \u0026\u0026 left.isString()) {\n                     checkTypeofString(t, left, left.getString());\n                 }\n                 leftType \u003d getJSType(left);\n                 rightType \u003d getJSType(right);\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 TernaryValue result \u003d TernaryValue.UNKNOWN;\n                 if (n.getType() \u003d\u003d Token.EQ || n.getType() \u003d\u003d Token.NE) {\n                     result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                     if (n.isNE()) {\n                         result \u003d result.not();\n                     }\n                 } else {\n                     if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                         result \u003d n.getType() \u003d\u003d Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;\n                     }\n                 }\n                 if (result !\u003d TernaryValue.UNKNOWN) {\n                     report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.LT:\n         case Token.LE:\n         case Token.GT:\n         case Token.GE:\n             leftType \u003d getJSType(n.getFirstChild());\n             rightType \u003d getJSType(n.getLastChild());\n             if (rightType.isNumber()) {\n                 validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n             } else if (leftType.isNumber()) {\n                 validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n             } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n             } else {\n                 String message \u003d \"left side of comparison\";\n                 validator.expectString(t, n, leftType, message);\n                 validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                 message \u003d \"right side of comparison\";\n                 validator.expectString(t, n, rightType, message);\n                 validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.IN:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             rightType \u003d getJSType(right);\n             validator.expectString(t, left, getJSType(left), \"left side of \u0027in\u0027\");\n             validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n             if (rightType.isStruct()) {\n                 report(t, right, IN_USED_WITH_STRUCT);\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.INSTANCEOF:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n             validator.expectAnyObject(t, left, getJSType(left), \"deterministic instanceof yields false\");\n             validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.ASSIGN:\n             visitAssign(t, n);\n             typeable \u003d false;\n             break;\n         case Token.ASSIGN_LSH:\n         case Token.ASSIGN_RSH:\n         case Token.ASSIGN_URSH:\n         case Token.ASSIGN_DIV:\n         case Token.ASSIGN_MOD:\n         case Token.ASSIGN_BITOR:\n         case Token.ASSIGN_BITXOR:\n         case Token.ASSIGN_BITAND:\n         case Token.ASSIGN_SUB:\n         case Token.ASSIGN_ADD:\n         case Token.ASSIGN_MUL:\n             checkPropCreation(t, n.getFirstChild());\n         case Token.LSH:\n         case Token.RSH:\n         case Token.URSH:\n         case Token.DIV:\n         case Token.MOD:\n         case Token.BITOR:\n         case Token.BITXOR:\n         case Token.BITAND:\n         case Token.SUB:\n         case Token.ADD:\n         case Token.MUL:\n             visitBinaryOperator(n.getType(), t, n);\n             break;\n         case Token.DELPROP:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.CASE:\n             JSType switchType \u003d getJSType(parent.getFirstChild());\n             JSType caseType \u003d getJSType(n.getFirstChild());\n             validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n             typeable \u003d false;\n             break;\n         case Token.WITH:\n             {\n                 Node child \u003d n.getFirstChild();\n                 childType \u003d getJSType(child);\n                 validator.expectObject(t, child, childType, \"with requires an object\");\n                 typeable \u003d false;\n                 break;\n             }\n         case Token.FUNCTION:\n             visitFunction(t, n);\n             break;\n         case Token.LABEL:\n         case Token.LABEL_NAME:\n         case Token.SWITCH:\n         case Token.BREAK:\n         case Token.CATCH:\n         case Token.TRY:\n         case Token.SCRIPT:\n         case Token.EXPR_RESULT:\n         case Token.BLOCK:\n         case Token.EMPTY:\n         case Token.DEFAULT_CASE:\n         case Token.CONTINUE:\n         case Token.DEBUGGER:\n         case Token.THROW:\n             typeable \u003d false;\n             break;\n         case Token.DO:\n         case Token.IF:\n         case Token.WHILE:\n             typeable \u003d false;\n             break;\n         case Token.FOR:\n             if (NodeUtil.isForIn(n)) {\n                 Node obj \u003d n.getChildAtIndex(1);\n                 if (getJSType(obj).isStruct()) {\n                     report(t, obj, IN_USED_WITH_STRUCT);\n                 }\n             }\n             typeable \u003d false;\n             break;\n         case Token.AND:\n         case Token.HOOK:\n         case Token.OBJECTLIT:\n         case Token.OR:\n             if (n.getJSType() !\u003d null) {\n                 ensureTyped(t, n);\n             } else {\n                 if ((n.isObjectLit()) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                     ensureTyped(t, n, parent.getJSType());\n                 } else {\n                     ensureTyped(t, n);\n                 }\n             }\n             if (n.isObjectLit()) {\n                 for (Node key : n.children()) {\n                     visitObjLitKey(t, key, n);\n                 }\n             }\n             break;\n         default:\n             report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n             ensureTyped(t, n);\n             break;\n     }\n     typeable \u003d typeable \u0026\u0026 !inExterns;\n     if (typeable) {\n         doPercentTypedAccounting(t, n);\n     }\n     checkNoTypeCheckSection(n, false);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d93f2d5aaf346749eaa6ae1641a171aeb177de5d": {
      "type": "Ybodychange",
      "commitMessage": "\nSeal struct instances.\n\nR\u003dnicksantos\nDELTA\u003d189  (157 added, 15 deleted, 17 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d5655\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2261 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "10/16/12, 3:17 PM",
      "commitName": "d93f2d5aaf346749eaa6ae1641a171aeb177de5d",
      "commitAuthor": "dimvar@google.com",
      "commitDateOld": "10/4/12, 11:18 AM",
      "commitNameOld": "a7f99cbb3ba646de8e19f0248099dad9cf0432a6",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 12.17,
      "commitsBetweenForRepo": 21,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    boolean typeable \u003d true;\n    switch(n.getType()) {\n        case Token.NAME:\n            typeable \u003d visitName(t, n, parent);\n            break;\n        case Token.PARAM_LIST:\n            typeable \u003d false;\n            break;\n        case Token.COMMA:\n            ensureTyped(t, n, getJSType(n.getLastChild()));\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.THIS:\n            ensureTyped(t, n, t.getScope().getTypeOfThis());\n            break;\n        case Token.NULL:\n            ensureTyped(t, n, NULL_TYPE);\n            break;\n        case Token.NUMBER:\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.STRING:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.STRING_KEY:\n            typeable \u003d false;\n            break;\n        case Token.GETTER_DEF:\n        case Token.SETTER_DEF:\n            break;\n        case Token.ARRAYLIT:\n            ensureTyped(t, n, ARRAY_TYPE);\n            break;\n        case Token.REGEXP:\n            ensureTyped(t, n, REGEXP_TYPE);\n            break;\n        case Token.GETPROP:\n            visitGetProp(t, n, parent);\n            typeable \u003d !(parent.isAssign() \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n            break;\n        case Token.GETELEM:\n            visitGetElem(t, n);\n            typeable \u003d false;\n            break;\n        case Token.VAR:\n            visitVar(t, n);\n            typeable \u003d false;\n            break;\n        case Token.NEW:\n            visitNew(t, n);\n            break;\n        case Token.CALL:\n            visitCall(t, n);\n            typeable \u003d !parent.isExprResult();\n            break;\n        case Token.RETURN:\n            visitReturn(t, n);\n            typeable \u003d false;\n            break;\n        case Token.DEC:\n        case Token.INC:\n            left \u003d n.getFirstChild();\n            checkPropCreation(t, left);\n            validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.NOT:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.VOID:\n            ensureTyped(t, n, VOID_TYPE);\n            break;\n        case Token.TYPEOF:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.BITNOT:\n            childType \u003d getJSType(n.getFirstChild());\n            if (!childType.matchesInt32Context()) {\n                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n            }\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.EQ:\n        case Token.NE:\n        case Token.SHEQ:\n        case Token.SHNE:\n            {\n                left \u003d n.getFirstChild();\n                right \u003d n.getLastChild();\n                if (left.isTypeOf()) {\n                    if (right.isString()) {\n                        checkTypeofString(t, right, right.getString());\n                    }\n                } else if (right.isTypeOf() \u0026\u0026 left.isString()) {\n                    checkTypeofString(t, left, left.getString());\n                }\n                leftType \u003d getJSType(left);\n                rightType \u003d getJSType(right);\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                TernaryValue result \u003d TernaryValue.UNKNOWN;\n                if (n.getType() \u003d\u003d Token.EQ || n.getType() \u003d\u003d Token.NE) {\n                    result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                    if (n.isNE()) {\n                        result \u003d result.not();\n                    }\n                } else {\n                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                        result \u003d n.getType() \u003d\u003d Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;\n                    }\n                }\n                if (result !\u003d TernaryValue.UNKNOWN) {\n                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n            leftType \u003d getJSType(n.getFirstChild());\n            rightType \u003d getJSType(n.getLastChild());\n            if (rightType.isNumber()) {\n                validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n            } else if (leftType.isNumber()) {\n                validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n            } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n            } else {\n                String message \u003d \"left side of comparison\";\n                validator.expectString(t, n, leftType, message);\n                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                message \u003d \"right side of comparison\";\n                validator.expectString(t, n, rightType, message);\n                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.IN:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            rightType \u003d getJSType(right);\n            validator.expectString(t, left, getJSType(left), \"left side of \u0027in\u0027\");\n            validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n            if (rightType.isStruct()) {\n                report(t, right, IN_USED_WITH_STRUCT);\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.INSTANCEOF:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n            validator.expectAnyObject(t, left, getJSType(left), \"deterministic instanceof yields false\");\n            validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.ASSIGN:\n            visitAssign(t, n);\n            typeable \u003d false;\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.ASSIGN_URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_SUB:\n        case Token.ASSIGN_ADD:\n        case Token.ASSIGN_MUL:\n            checkPropCreation(t, n.getFirstChild());\n        case Token.LSH:\n        case Token.RSH:\n        case Token.URSH:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITOR:\n        case Token.BITXOR:\n        case Token.BITAND:\n        case Token.SUB:\n        case Token.ADD:\n        case Token.MUL:\n            visitBinaryOperator(n.getType(), t, n);\n            break;\n        case Token.DELPROP:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.CASE:\n            JSType switchType \u003d getJSType(parent.getFirstChild());\n            JSType caseType \u003d getJSType(n.getFirstChild());\n            validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n            typeable \u003d false;\n            break;\n        case Token.WITH:\n            {\n                Node child \u003d n.getFirstChild();\n                childType \u003d getJSType(child);\n                validator.expectObject(t, child, childType, \"with requires an object\");\n                typeable \u003d false;\n                break;\n            }\n        case Token.FUNCTION:\n            visitFunction(t, n);\n            break;\n        case Token.LABEL:\n        case Token.LABEL_NAME:\n        case Token.SWITCH:\n        case Token.BREAK:\n        case Token.CATCH:\n        case Token.TRY:\n        case Token.SCRIPT:\n        case Token.EXPR_RESULT:\n        case Token.BLOCK:\n        case Token.EMPTY:\n        case Token.DEFAULT_CASE:\n        case Token.CONTINUE:\n        case Token.DEBUGGER:\n        case Token.THROW:\n            typeable \u003d false;\n            break;\n        case Token.DO:\n        case Token.IF:\n        case Token.WHILE:\n            typeable \u003d false;\n            break;\n        case Token.FOR:\n            if (NodeUtil.isForIn(n)) {\n                Node obj \u003d n.getChildAtIndex(1);\n                if (getJSType(obj).isStruct()) {\n                    report(t, obj, IN_USED_WITH_STRUCT);\n                }\n            }\n            typeable \u003d false;\n            break;\n        case Token.AND:\n        case Token.HOOK:\n        case Token.OBJECTLIT:\n        case Token.OR:\n            if (n.getJSType() !\u003d null) {\n                ensureTyped(t, n);\n            } else {\n                if ((n.isObjectLit()) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                    ensureTyped(t, n, parent.getJSType());\n                } else {\n                    ensureTyped(t, n);\n                }\n            }\n            if (n.isObjectLit()) {\n                for (Node key : n.children()) {\n                    visitObjLitKey(t, key, n);\n                }\n            }\n            break;\n        default:\n            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n            ensureTyped(t, n);\n            break;\n    }\n    typeable \u003d typeable \u0026\u0026 !inExterns;\n    if (typeable) {\n        doPercentTypedAccounting(t, n);\n    }\n    checkNoTypeCheckSection(n, false);\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 471,
      "functionName": "visit",
      "functionAnnotation": "@Override",
      "functionDoc": "This is the meat of the type checking.  It is basically one big switch,\nwith each case representing one type of parse tree node.  The individual\ncases are usually pretty straightforward.\n\n@param t The node traversal object that supplies context, such as the\nscope chain to use in name lookups as well as error reporting.\n@param n The node being visited.\n@param parent The parent of the node n.\n",
      "diff": "@@ -1,278 +1,280 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n     JSType childType;\n     JSType leftType, rightType;\n     Node left, right;\n     boolean typeable \u003d true;\n     switch(n.getType()) {\n         case Token.NAME:\n             typeable \u003d visitName(t, n, parent);\n             break;\n         case Token.PARAM_LIST:\n             typeable \u003d false;\n             break;\n         case Token.COMMA:\n             ensureTyped(t, n, getJSType(n.getLastChild()));\n             break;\n         case Token.TRUE:\n         case Token.FALSE:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.THIS:\n             ensureTyped(t, n, t.getScope().getTypeOfThis());\n             break;\n         case Token.NULL:\n             ensureTyped(t, n, NULL_TYPE);\n             break;\n         case Token.NUMBER:\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.STRING:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.STRING_KEY:\n             typeable \u003d false;\n             break;\n         case Token.GETTER_DEF:\n         case Token.SETTER_DEF:\n             break;\n         case Token.ARRAYLIT:\n             ensureTyped(t, n, ARRAY_TYPE);\n             break;\n         case Token.REGEXP:\n             ensureTyped(t, n, REGEXP_TYPE);\n             break;\n         case Token.GETPROP:\n             visitGetProp(t, n, parent);\n             typeable \u003d !(parent.isAssign() \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n             break;\n         case Token.GETELEM:\n             visitGetElem(t, n);\n             typeable \u003d false;\n             break;\n         case Token.VAR:\n             visitVar(t, n);\n             typeable \u003d false;\n             break;\n         case Token.NEW:\n             visitNew(t, n);\n             break;\n         case Token.CALL:\n             visitCall(t, n);\n             typeable \u003d !parent.isExprResult();\n             break;\n         case Token.RETURN:\n             visitReturn(t, n);\n             typeable \u003d false;\n             break;\n         case Token.DEC:\n         case Token.INC:\n             left \u003d n.getFirstChild();\n+            checkPropCreation(t, left);\n             validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.NOT:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.VOID:\n             ensureTyped(t, n, VOID_TYPE);\n             break;\n         case Token.TYPEOF:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.BITNOT:\n             childType \u003d getJSType(n.getFirstChild());\n             if (!childType.matchesInt32Context()) {\n                 report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n             }\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.POS:\n         case Token.NEG:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.EQ:\n         case Token.NE:\n         case Token.SHEQ:\n         case Token.SHNE:\n             {\n                 left \u003d n.getFirstChild();\n                 right \u003d n.getLastChild();\n                 if (left.isTypeOf()) {\n                     if (right.isString()) {\n                         checkTypeofString(t, right, right.getString());\n                     }\n                 } else if (right.isTypeOf() \u0026\u0026 left.isString()) {\n                     checkTypeofString(t, left, left.getString());\n                 }\n                 leftType \u003d getJSType(left);\n                 rightType \u003d getJSType(right);\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 TernaryValue result \u003d TernaryValue.UNKNOWN;\n                 if (n.getType() \u003d\u003d Token.EQ || n.getType() \u003d\u003d Token.NE) {\n                     result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                     if (n.isNE()) {\n                         result \u003d result.not();\n                     }\n                 } else {\n                     if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                         result \u003d n.getType() \u003d\u003d Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;\n                     }\n                 }\n                 if (result !\u003d TernaryValue.UNKNOWN) {\n                     report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.LT:\n         case Token.LE:\n         case Token.GT:\n         case Token.GE:\n             leftType \u003d getJSType(n.getFirstChild());\n             rightType \u003d getJSType(n.getLastChild());\n             if (rightType.isNumber()) {\n                 validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n             } else if (leftType.isNumber()) {\n                 validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n             } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n             } else {\n                 String message \u003d \"left side of comparison\";\n                 validator.expectString(t, n, leftType, message);\n                 validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                 message \u003d \"right side of comparison\";\n                 validator.expectString(t, n, rightType, message);\n                 validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.IN:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             rightType \u003d getJSType(right);\n             validator.expectString(t, left, getJSType(left), \"left side of \u0027in\u0027\");\n             validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n             if (rightType.isStruct()) {\n                 report(t, right, IN_USED_WITH_STRUCT);\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.INSTANCEOF:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n             validator.expectAnyObject(t, left, getJSType(left), \"deterministic instanceof yields false\");\n             validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.ASSIGN:\n             visitAssign(t, n);\n             typeable \u003d false;\n             break;\n         case Token.ASSIGN_LSH:\n         case Token.ASSIGN_RSH:\n         case Token.ASSIGN_URSH:\n         case Token.ASSIGN_DIV:\n         case Token.ASSIGN_MOD:\n         case Token.ASSIGN_BITOR:\n         case Token.ASSIGN_BITXOR:\n         case Token.ASSIGN_BITAND:\n         case Token.ASSIGN_SUB:\n         case Token.ASSIGN_ADD:\n         case Token.ASSIGN_MUL:\n+            checkPropCreation(t, n.getFirstChild());\n         case Token.LSH:\n         case Token.RSH:\n         case Token.URSH:\n         case Token.DIV:\n         case Token.MOD:\n         case Token.BITOR:\n         case Token.BITXOR:\n         case Token.BITAND:\n         case Token.SUB:\n         case Token.ADD:\n         case Token.MUL:\n             visitBinaryOperator(n.getType(), t, n);\n             break;\n         case Token.DELPROP:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.CASE:\n             JSType switchType \u003d getJSType(parent.getFirstChild());\n             JSType caseType \u003d getJSType(n.getFirstChild());\n             validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n             typeable \u003d false;\n             break;\n         case Token.WITH:\n             {\n                 Node child \u003d n.getFirstChild();\n                 childType \u003d getJSType(child);\n                 validator.expectObject(t, child, childType, \"with requires an object\");\n                 typeable \u003d false;\n                 break;\n             }\n         case Token.FUNCTION:\n             visitFunction(t, n);\n             break;\n         case Token.LABEL:\n         case Token.LABEL_NAME:\n         case Token.SWITCH:\n         case Token.BREAK:\n         case Token.CATCH:\n         case Token.TRY:\n         case Token.SCRIPT:\n         case Token.EXPR_RESULT:\n         case Token.BLOCK:\n         case Token.EMPTY:\n         case Token.DEFAULT_CASE:\n         case Token.CONTINUE:\n         case Token.DEBUGGER:\n         case Token.THROW:\n             typeable \u003d false;\n             break;\n         case Token.DO:\n         case Token.IF:\n         case Token.WHILE:\n             typeable \u003d false;\n             break;\n         case Token.FOR:\n             if (NodeUtil.isForIn(n)) {\n                 Node obj \u003d n.getChildAtIndex(1);\n                 if (getJSType(obj).isStruct()) {\n                     report(t, obj, IN_USED_WITH_STRUCT);\n                 }\n             }\n             typeable \u003d false;\n             break;\n         case Token.AND:\n         case Token.HOOK:\n         case Token.OBJECTLIT:\n         case Token.OR:\n             if (n.getJSType() !\u003d null) {\n                 ensureTyped(t, n);\n             } else {\n                 if ((n.isObjectLit()) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                     ensureTyped(t, n, parent.getJSType());\n                 } else {\n                     ensureTyped(t, n);\n                 }\n             }\n             if (n.isObjectLit()) {\n                 for (Node key : n.children()) {\n                     visitObjLitKey(t, key, n);\n                 }\n             }\n             break;\n         default:\n             report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n             ensureTyped(t, n);\n             break;\n     }\n     typeable \u003d typeable \u0026\u0026 !inExterns;\n     if (typeable) {\n         doPercentTypedAccounting(t, n);\n     }\n     checkNoTypeCheckSection(n, false);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e237d2643b102fbea616717806391f48e2ce506a": {
      "type": "Ybodychange",
      "commitMessage": "\nWarn when structs are used with IN or FOR/IN\n\nR\u003dnicksantos\nDELTA\u003d44  (41 added, 3 deleted, 0 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d5569\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2225 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "9/28/12, 10:31 AM",
      "commitName": "e237d2643b102fbea616717806391f48e2ce506a",
      "commitAuthor": "dimvar@google.com",
      "commitDateOld": "9/12/12, 3:16 PM",
      "commitNameOld": "482b767639e6eec7c30d8898851560c41b66d885",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 15.8,
      "commitsBetweenForRepo": 36,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    boolean typeable \u003d true;\n    switch(n.getType()) {\n        case Token.NAME:\n            typeable \u003d visitName(t, n, parent);\n            break;\n        case Token.PARAM_LIST:\n            typeable \u003d false;\n            break;\n        case Token.COMMA:\n            ensureTyped(t, n, getJSType(n.getLastChild()));\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.THIS:\n            ensureTyped(t, n, t.getScope().getTypeOfThis());\n            break;\n        case Token.NULL:\n            ensureTyped(t, n, NULL_TYPE);\n            break;\n        case Token.NUMBER:\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.STRING:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.STRING_KEY:\n            typeable \u003d false;\n            break;\n        case Token.GETTER_DEF:\n        case Token.SETTER_DEF:\n            break;\n        case Token.ARRAYLIT:\n            ensureTyped(t, n, ARRAY_TYPE);\n            break;\n        case Token.REGEXP:\n            ensureTyped(t, n, REGEXP_TYPE);\n            break;\n        case Token.GETPROP:\n            visitGetProp(t, n, parent);\n            typeable \u003d !(parent.isAssign() \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n            break;\n        case Token.GETELEM:\n            visitGetElem(t, n);\n            typeable \u003d false;\n            break;\n        case Token.VAR:\n            visitVar(t, n);\n            typeable \u003d false;\n            break;\n        case Token.NEW:\n            visitNew(t, n);\n            break;\n        case Token.CALL:\n            visitCall(t, n);\n            typeable \u003d !parent.isExprResult();\n            break;\n        case Token.RETURN:\n            visitReturn(t, n);\n            typeable \u003d false;\n            break;\n        case Token.DEC:\n        case Token.INC:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.NOT:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.VOID:\n            ensureTyped(t, n, VOID_TYPE);\n            break;\n        case Token.TYPEOF:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.BITNOT:\n            childType \u003d getJSType(n.getFirstChild());\n            if (!childType.matchesInt32Context()) {\n                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n            }\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.EQ:\n        case Token.NE:\n        case Token.SHEQ:\n        case Token.SHNE:\n            {\n                left \u003d n.getFirstChild();\n                right \u003d n.getLastChild();\n                if (left.isTypeOf()) {\n                    if (right.isString()) {\n                        checkTypeofString(t, right, right.getString());\n                    }\n                } else if (right.isTypeOf() \u0026\u0026 left.isString()) {\n                    checkTypeofString(t, left, left.getString());\n                }\n                leftType \u003d getJSType(left);\n                rightType \u003d getJSType(right);\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                TernaryValue result \u003d TernaryValue.UNKNOWN;\n                if (n.getType() \u003d\u003d Token.EQ || n.getType() \u003d\u003d Token.NE) {\n                    result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                    if (n.isNE()) {\n                        result \u003d result.not();\n                    }\n                } else {\n                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                        result \u003d n.getType() \u003d\u003d Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;\n                    }\n                }\n                if (result !\u003d TernaryValue.UNKNOWN) {\n                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n            leftType \u003d getJSType(n.getFirstChild());\n            rightType \u003d getJSType(n.getLastChild());\n            if (rightType.isNumber()) {\n                validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n            } else if (leftType.isNumber()) {\n                validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n            } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n            } else {\n                String message \u003d \"left side of comparison\";\n                validator.expectString(t, n, leftType, message);\n                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                message \u003d \"right side of comparison\";\n                validator.expectString(t, n, rightType, message);\n                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.IN:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            rightType \u003d getJSType(right);\n            validator.expectString(t, left, getJSType(left), \"left side of \u0027in\u0027\");\n            validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n            if (rightType.isStruct()) {\n                report(t, right, IN_USED_WITH_STRUCT);\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.INSTANCEOF:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n            validator.expectAnyObject(t, left, getJSType(left), \"deterministic instanceof yields false\");\n            validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.ASSIGN:\n            visitAssign(t, n);\n            typeable \u003d false;\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.ASSIGN_URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_SUB:\n        case Token.ASSIGN_ADD:\n        case Token.ASSIGN_MUL:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.URSH:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITOR:\n        case Token.BITXOR:\n        case Token.BITAND:\n        case Token.SUB:\n        case Token.ADD:\n        case Token.MUL:\n            visitBinaryOperator(n.getType(), t, n);\n            break;\n        case Token.DELPROP:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.CASE:\n            JSType switchType \u003d getJSType(parent.getFirstChild());\n            JSType caseType \u003d getJSType(n.getFirstChild());\n            validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n            typeable \u003d false;\n            break;\n        case Token.WITH:\n            {\n                Node child \u003d n.getFirstChild();\n                childType \u003d getJSType(child);\n                validator.expectObject(t, child, childType, \"with requires an object\");\n                typeable \u003d false;\n                break;\n            }\n        case Token.FUNCTION:\n            visitFunction(t, n);\n            break;\n        case Token.LABEL:\n        case Token.LABEL_NAME:\n        case Token.SWITCH:\n        case Token.BREAK:\n        case Token.CATCH:\n        case Token.TRY:\n        case Token.SCRIPT:\n        case Token.EXPR_RESULT:\n        case Token.BLOCK:\n        case Token.EMPTY:\n        case Token.DEFAULT_CASE:\n        case Token.CONTINUE:\n        case Token.DEBUGGER:\n        case Token.THROW:\n            typeable \u003d false;\n            break;\n        case Token.DO:\n        case Token.IF:\n        case Token.WHILE:\n            typeable \u003d false;\n            break;\n        case Token.FOR:\n            if (NodeUtil.isForIn(n)) {\n                Node obj \u003d n.getChildAtIndex(1);\n                if (getJSType(obj).isStruct()) {\n                    report(t, obj, IN_USED_WITH_STRUCT);\n                }\n            }\n            typeable \u003d false;\n            break;\n        case Token.AND:\n        case Token.HOOK:\n        case Token.OBJECTLIT:\n        case Token.OR:\n            if (n.getJSType() !\u003d null) {\n                ensureTyped(t, n);\n            } else {\n                if ((n.isObjectLit()) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                    ensureTyped(t, n, parent.getJSType());\n                } else {\n                    ensureTyped(t, n);\n                }\n            }\n            if (n.isObjectLit()) {\n                for (Node key : n.children()) {\n                    visitObjLitKey(t, key, n);\n                }\n            }\n            break;\n        default:\n            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n            ensureTyped(t, n);\n            break;\n    }\n    typeable \u003d typeable \u0026\u0026 !inExterns;\n    if (typeable) {\n        doPercentTypedAccounting(t, n);\n    }\n    checkNoTypeCheckSection(n, false);\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 465,
      "functionName": "visit",
      "functionAnnotation": "@Override",
      "functionDoc": "This is the meat of the type checking.  It is basically one big switch,\nwith each case representing one type of parse tree node.  The individual\ncases are usually pretty straightforward.\n\n@param t The node traversal object that supplies context, such as the\nscope chain to use in name lookups as well as error reporting.\n@param n The node being visited.\n@param parent The parent of the node n.\n",
      "diff": "@@ -1,265 +1,278 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n     JSType childType;\n     JSType leftType, rightType;\n     Node left, right;\n     boolean typeable \u003d true;\n     switch(n.getType()) {\n         case Token.NAME:\n             typeable \u003d visitName(t, n, parent);\n             break;\n         case Token.PARAM_LIST:\n             typeable \u003d false;\n             break;\n         case Token.COMMA:\n             ensureTyped(t, n, getJSType(n.getLastChild()));\n             break;\n         case Token.TRUE:\n         case Token.FALSE:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.THIS:\n             ensureTyped(t, n, t.getScope().getTypeOfThis());\n             break;\n         case Token.NULL:\n             ensureTyped(t, n, NULL_TYPE);\n             break;\n         case Token.NUMBER:\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.STRING:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.STRING_KEY:\n             typeable \u003d false;\n             break;\n         case Token.GETTER_DEF:\n         case Token.SETTER_DEF:\n             break;\n         case Token.ARRAYLIT:\n             ensureTyped(t, n, ARRAY_TYPE);\n             break;\n         case Token.REGEXP:\n             ensureTyped(t, n, REGEXP_TYPE);\n             break;\n         case Token.GETPROP:\n             visitGetProp(t, n, parent);\n             typeable \u003d !(parent.isAssign() \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n             break;\n         case Token.GETELEM:\n             visitGetElem(t, n);\n             typeable \u003d false;\n             break;\n         case Token.VAR:\n             visitVar(t, n);\n             typeable \u003d false;\n             break;\n         case Token.NEW:\n             visitNew(t, n);\n             break;\n         case Token.CALL:\n             visitCall(t, n);\n             typeable \u003d !parent.isExprResult();\n             break;\n         case Token.RETURN:\n             visitReturn(t, n);\n             typeable \u003d false;\n             break;\n         case Token.DEC:\n         case Token.INC:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.NOT:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.VOID:\n             ensureTyped(t, n, VOID_TYPE);\n             break;\n         case Token.TYPEOF:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.BITNOT:\n             childType \u003d getJSType(n.getFirstChild());\n             if (!childType.matchesInt32Context()) {\n                 report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n             }\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.POS:\n         case Token.NEG:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.EQ:\n         case Token.NE:\n         case Token.SHEQ:\n         case Token.SHNE:\n             {\n                 left \u003d n.getFirstChild();\n                 right \u003d n.getLastChild();\n                 if (left.isTypeOf()) {\n                     if (right.isString()) {\n                         checkTypeofString(t, right, right.getString());\n                     }\n                 } else if (right.isTypeOf() \u0026\u0026 left.isString()) {\n                     checkTypeofString(t, left, left.getString());\n                 }\n                 leftType \u003d getJSType(left);\n                 rightType \u003d getJSType(right);\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 TernaryValue result \u003d TernaryValue.UNKNOWN;\n                 if (n.getType() \u003d\u003d Token.EQ || n.getType() \u003d\u003d Token.NE) {\n                     result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                     if (n.isNE()) {\n                         result \u003d result.not();\n                     }\n                 } else {\n                     if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                         result \u003d n.getType() \u003d\u003d Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;\n                     }\n                 }\n                 if (result !\u003d TernaryValue.UNKNOWN) {\n                     report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.LT:\n         case Token.LE:\n         case Token.GT:\n         case Token.GE:\n             leftType \u003d getJSType(n.getFirstChild());\n             rightType \u003d getJSType(n.getLastChild());\n             if (rightType.isNumber()) {\n                 validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n             } else if (leftType.isNumber()) {\n                 validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n             } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n             } else {\n                 String message \u003d \"left side of comparison\";\n                 validator.expectString(t, n, leftType, message);\n                 validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                 message \u003d \"right side of comparison\";\n                 validator.expectString(t, n, rightType, message);\n                 validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.IN:\n-            validator.expectObject(t, n, getJSType(n.getLastChild()), \"\u0027in\u0027 requires an object\");\n             left \u003d n.getFirstChild();\n+            right \u003d n.getLastChild();\n+            rightType \u003d getJSType(right);\n             validator.expectString(t, left, getJSType(left), \"left side of \u0027in\u0027\");\n+            validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n+            if (rightType.isStruct()) {\n+                report(t, right, IN_USED_WITH_STRUCT);\n+            }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.INSTANCEOF:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n             validator.expectAnyObject(t, left, getJSType(left), \"deterministic instanceof yields false\");\n             validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.ASSIGN:\n             visitAssign(t, n);\n             typeable \u003d false;\n             break;\n         case Token.ASSIGN_LSH:\n         case Token.ASSIGN_RSH:\n         case Token.ASSIGN_URSH:\n         case Token.ASSIGN_DIV:\n         case Token.ASSIGN_MOD:\n         case Token.ASSIGN_BITOR:\n         case Token.ASSIGN_BITXOR:\n         case Token.ASSIGN_BITAND:\n         case Token.ASSIGN_SUB:\n         case Token.ASSIGN_ADD:\n         case Token.ASSIGN_MUL:\n         case Token.LSH:\n         case Token.RSH:\n         case Token.URSH:\n         case Token.DIV:\n         case Token.MOD:\n         case Token.BITOR:\n         case Token.BITXOR:\n         case Token.BITAND:\n         case Token.SUB:\n         case Token.ADD:\n         case Token.MUL:\n             visitBinaryOperator(n.getType(), t, n);\n             break;\n         case Token.DELPROP:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.CASE:\n             JSType switchType \u003d getJSType(parent.getFirstChild());\n             JSType caseType \u003d getJSType(n.getFirstChild());\n             validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n             typeable \u003d false;\n             break;\n         case Token.WITH:\n             {\n                 Node child \u003d n.getFirstChild();\n                 childType \u003d getJSType(child);\n                 validator.expectObject(t, child, childType, \"with requires an object\");\n                 typeable \u003d false;\n                 break;\n             }\n         case Token.FUNCTION:\n             visitFunction(t, n);\n             break;\n         case Token.LABEL:\n         case Token.LABEL_NAME:\n         case Token.SWITCH:\n         case Token.BREAK:\n         case Token.CATCH:\n         case Token.TRY:\n         case Token.SCRIPT:\n         case Token.EXPR_RESULT:\n         case Token.BLOCK:\n         case Token.EMPTY:\n         case Token.DEFAULT_CASE:\n         case Token.CONTINUE:\n         case Token.DEBUGGER:\n         case Token.THROW:\n             typeable \u003d false;\n             break;\n         case Token.DO:\n-        case Token.FOR:\n         case Token.IF:\n         case Token.WHILE:\n             typeable \u003d false;\n             break;\n+        case Token.FOR:\n+            if (NodeUtil.isForIn(n)) {\n+                Node obj \u003d n.getChildAtIndex(1);\n+                if (getJSType(obj).isStruct()) {\n+                    report(t, obj, IN_USED_WITH_STRUCT);\n+                }\n+            }\n+            typeable \u003d false;\n+            break;\n         case Token.AND:\n         case Token.HOOK:\n         case Token.OBJECTLIT:\n         case Token.OR:\n             if (n.getJSType() !\u003d null) {\n                 ensureTyped(t, n);\n             } else {\n                 if ((n.isObjectLit()) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                     ensureTyped(t, n, parent.getJSType());\n                 } else {\n                     ensureTyped(t, n);\n                 }\n             }\n             if (n.isObjectLit()) {\n                 for (Node key : n.children()) {\n                     visitObjLitKey(t, key, n);\n                 }\n             }\n             break;\n         default:\n             report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n             ensureTyped(t, n);\n             break;\n     }\n     typeable \u003d typeable \u0026\u0026 !inExterns;\n     if (typeable) {\n         doPercentTypedAccounting(t, n);\n     }\n     checkNoTypeCheckSection(n, false);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "bbf1b138e20a36ca79b2a012ae145c943929a6dd": {
      "type": "Ybodychange",
      "commitMessage": "\nAutomated g4 rollback\n\n*** Reason for rollback ***\n\nFailures don\u0027t seem related to jscompiler. Resubmitting for now.\n\n*** Original change description ***\n\nAutomated g4 rollback\n\n*** Reason for rollback ***\n\nChange caused tests to stop building.\n\n*** Original change description ***\n\nNew @struct and @dict annotations for constructors.\nWith these annotations, one can enforce only dot or only bracket access on object properties.\n\nR\u003dnicksantos\nDELTA\u003d476  (391 added, 34 deleted, 51 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d5491\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2184 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "9/11/12, 4:17 PM",
      "commitName": "bbf1b138e20a36ca79b2a012ae145c943929a6dd",
      "commitAuthor": "dimvar@google.com",
      "commitDateOld": "9/11/12, 11:52 AM",
      "commitNameOld": "00241aa722c2245784e63dba9d444fce88134aed",
      "commitAuthorOld": "dimvar@google.com",
      "daysBetweenCommits": 0.18,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    boolean typeable \u003d true;\n    switch(n.getType()) {\n        case Token.NAME:\n            typeable \u003d visitName(t, n, parent);\n            break;\n        case Token.PARAM_LIST:\n            typeable \u003d false;\n            break;\n        case Token.COMMA:\n            ensureTyped(t, n, getJSType(n.getLastChild()));\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.THIS:\n            ensureTyped(t, n, t.getScope().getTypeOfThis());\n            break;\n        case Token.NULL:\n            ensureTyped(t, n, NULL_TYPE);\n            break;\n        case Token.NUMBER:\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.STRING:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.STRING_KEY:\n            typeable \u003d false;\n            break;\n        case Token.GETTER_DEF:\n        case Token.SETTER_DEF:\n            break;\n        case Token.ARRAYLIT:\n            ensureTyped(t, n, ARRAY_TYPE);\n            break;\n        case Token.REGEXP:\n            ensureTyped(t, n, REGEXP_TYPE);\n            break;\n        case Token.GETPROP:\n            visitGetProp(t, n, parent);\n            typeable \u003d !(parent.isAssign() \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n            break;\n        case Token.GETELEM:\n            visitGetElem(t, n);\n            typeable \u003d false;\n            break;\n        case Token.VAR:\n            visitVar(t, n);\n            typeable \u003d false;\n            break;\n        case Token.NEW:\n            visitNew(t, n);\n            break;\n        case Token.CALL:\n            visitCall(t, n);\n            typeable \u003d !parent.isExprResult();\n            break;\n        case Token.RETURN:\n            visitReturn(t, n);\n            typeable \u003d false;\n            break;\n        case Token.DEC:\n        case Token.INC:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.NOT:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.VOID:\n            ensureTyped(t, n, VOID_TYPE);\n            break;\n        case Token.TYPEOF:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.BITNOT:\n            childType \u003d getJSType(n.getFirstChild());\n            if (!childType.matchesInt32Context()) {\n                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n            }\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.EQ:\n        case Token.NE:\n        case Token.SHEQ:\n        case Token.SHNE:\n            {\n                left \u003d n.getFirstChild();\n                right \u003d n.getLastChild();\n                if (left.isTypeOf()) {\n                    if (right.isString()) {\n                        checkTypeofString(t, right, right.getString());\n                    }\n                } else if (right.isTypeOf() \u0026\u0026 left.isString()) {\n                    checkTypeofString(t, left, left.getString());\n                }\n                leftType \u003d getJSType(left);\n                rightType \u003d getJSType(right);\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                TernaryValue result \u003d TernaryValue.UNKNOWN;\n                if (n.getType() \u003d\u003d Token.EQ || n.getType() \u003d\u003d Token.NE) {\n                    result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                    if (n.isNE()) {\n                        result \u003d result.not();\n                    }\n                } else {\n                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                        result \u003d n.getType() \u003d\u003d Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;\n                    }\n                }\n                if (result !\u003d TernaryValue.UNKNOWN) {\n                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n            leftType \u003d getJSType(n.getFirstChild());\n            rightType \u003d getJSType(n.getLastChild());\n            if (rightType.isNumber()) {\n                validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n            } else if (leftType.isNumber()) {\n                validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n            } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n            } else {\n                String message \u003d \"left side of comparison\";\n                validator.expectString(t, n, leftType, message);\n                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                message \u003d \"right side of comparison\";\n                validator.expectString(t, n, rightType, message);\n                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.IN:\n            validator.expectObject(t, n, getJSType(n.getLastChild()), \"\u0027in\u0027 requires an object\");\n            left \u003d n.getFirstChild();\n            validator.expectString(t, left, getJSType(left), \"left side of \u0027in\u0027\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.INSTANCEOF:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n            validator.expectAnyObject(t, left, getJSType(left), \"deterministic instanceof yields false\");\n            validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.ASSIGN:\n            visitAssign(t, n);\n            typeable \u003d false;\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.ASSIGN_URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_SUB:\n        case Token.ASSIGN_ADD:\n        case Token.ASSIGN_MUL:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.URSH:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITOR:\n        case Token.BITXOR:\n        case Token.BITAND:\n        case Token.SUB:\n        case Token.ADD:\n        case Token.MUL:\n            visitBinaryOperator(n.getType(), t, n);\n            break;\n        case Token.DELPROP:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.CASE:\n            JSType switchType \u003d getJSType(parent.getFirstChild());\n            JSType caseType \u003d getJSType(n.getFirstChild());\n            validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n            typeable \u003d false;\n            break;\n        case Token.WITH:\n            {\n                Node child \u003d n.getFirstChild();\n                childType \u003d getJSType(child);\n                validator.expectObject(t, child, childType, \"with requires an object\");\n                typeable \u003d false;\n                break;\n            }\n        case Token.FUNCTION:\n            visitFunction(t, n);\n            break;\n        case Token.LABEL:\n        case Token.LABEL_NAME:\n        case Token.SWITCH:\n        case Token.BREAK:\n        case Token.CATCH:\n        case Token.TRY:\n        case Token.SCRIPT:\n        case Token.EXPR_RESULT:\n        case Token.BLOCK:\n        case Token.EMPTY:\n        case Token.DEFAULT_CASE:\n        case Token.CONTINUE:\n        case Token.DEBUGGER:\n        case Token.THROW:\n            typeable \u003d false;\n            break;\n        case Token.DO:\n        case Token.FOR:\n        case Token.IF:\n        case Token.WHILE:\n            typeable \u003d false;\n            break;\n        case Token.AND:\n        case Token.HOOK:\n        case Token.OBJECTLIT:\n        case Token.OR:\n            if (n.getJSType() !\u003d null) {\n                ensureTyped(t, n);\n            } else {\n                if ((n.isObjectLit()) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                    ensureTyped(t, n, parent.getJSType());\n                } else {\n                    ensureTyped(t, n);\n                }\n            }\n            if (n.isObjectLit()) {\n                for (Node key : n.children()) {\n                    visitObjLitKey(t, key, n);\n                }\n            }\n            break;\n        default:\n            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n            ensureTyped(t, n);\n            break;\n    }\n    typeable \u003d typeable \u0026\u0026 !inExterns;\n    if (typeable) {\n        doPercentTypedAccounting(t, n);\n    }\n    checkNoTypeCheckSection(n, false);\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 460,
      "functionName": "visit",
      "functionAnnotation": "@Override",
      "functionDoc": "This is the meat of the type checking.  It is basically one big switch,\nwith each case representing one type of parse tree node.  The individual\ncases are usually pretty straightforward.\n\n@param t The node traversal object that supplies context, such as the\nscope chain to use in name lookups as well as error reporting.\n@param n The node being visited.\n@param parent The parent of the node n.\n",
      "diff": "@@ -1,269 +1,265 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n     JSType childType;\n     JSType leftType, rightType;\n     Node left, right;\n     boolean typeable \u003d true;\n     switch(n.getType()) {\n         case Token.NAME:\n             typeable \u003d visitName(t, n, parent);\n             break;\n         case Token.PARAM_LIST:\n             typeable \u003d false;\n             break;\n         case Token.COMMA:\n             ensureTyped(t, n, getJSType(n.getLastChild()));\n             break;\n         case Token.TRUE:\n         case Token.FALSE:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.THIS:\n             ensureTyped(t, n, t.getScope().getTypeOfThis());\n             break;\n         case Token.NULL:\n             ensureTyped(t, n, NULL_TYPE);\n             break;\n         case Token.NUMBER:\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.STRING:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.STRING_KEY:\n             typeable \u003d false;\n             break;\n         case Token.GETTER_DEF:\n         case Token.SETTER_DEF:\n             break;\n         case Token.ARRAYLIT:\n             ensureTyped(t, n, ARRAY_TYPE);\n             break;\n         case Token.REGEXP:\n             ensureTyped(t, n, REGEXP_TYPE);\n             break;\n         case Token.GETPROP:\n             visitGetProp(t, n, parent);\n             typeable \u003d !(parent.isAssign() \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n             break;\n         case Token.GETELEM:\n             visitGetElem(t, n);\n             typeable \u003d false;\n             break;\n         case Token.VAR:\n             visitVar(t, n);\n             typeable \u003d false;\n             break;\n         case Token.NEW:\n             visitNew(t, n);\n             break;\n         case Token.CALL:\n             visitCall(t, n);\n             typeable \u003d !parent.isExprResult();\n             break;\n         case Token.RETURN:\n             visitReturn(t, n);\n             typeable \u003d false;\n             break;\n         case Token.DEC:\n         case Token.INC:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.NOT:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.VOID:\n             ensureTyped(t, n, VOID_TYPE);\n             break;\n         case Token.TYPEOF:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.BITNOT:\n             childType \u003d getJSType(n.getFirstChild());\n             if (!childType.matchesInt32Context()) {\n                 report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n             }\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.POS:\n         case Token.NEG:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.EQ:\n         case Token.NE:\n         case Token.SHEQ:\n         case Token.SHNE:\n             {\n                 left \u003d n.getFirstChild();\n                 right \u003d n.getLastChild();\n                 if (left.isTypeOf()) {\n                     if (right.isString()) {\n                         checkTypeofString(t, right, right.getString());\n                     }\n                 } else if (right.isTypeOf() \u0026\u0026 left.isString()) {\n                     checkTypeofString(t, left, left.getString());\n                 }\n                 leftType \u003d getJSType(left);\n                 rightType \u003d getJSType(right);\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 TernaryValue result \u003d TernaryValue.UNKNOWN;\n                 if (n.getType() \u003d\u003d Token.EQ || n.getType() \u003d\u003d Token.NE) {\n                     result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                     if (n.isNE()) {\n                         result \u003d result.not();\n                     }\n                 } else {\n                     if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                         result \u003d n.getType() \u003d\u003d Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;\n                     }\n                 }\n                 if (result !\u003d TernaryValue.UNKNOWN) {\n                     report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.LT:\n         case Token.LE:\n         case Token.GT:\n         case Token.GE:\n             leftType \u003d getJSType(n.getFirstChild());\n             rightType \u003d getJSType(n.getLastChild());\n             if (rightType.isNumber()) {\n                 validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n             } else if (leftType.isNumber()) {\n                 validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n             } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n             } else {\n                 String message \u003d \"left side of comparison\";\n                 validator.expectString(t, n, leftType, message);\n                 validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                 message \u003d \"right side of comparison\";\n                 validator.expectString(t, n, rightType, message);\n                 validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.IN:\n+            validator.expectObject(t, n, getJSType(n.getLastChild()), \"\u0027in\u0027 requires an object\");\n             left \u003d n.getFirstChild();\n-            right \u003d n.getLastChild();\n-            leftType \u003d getJSType(left);\n-            rightType \u003d getJSType(right);\n-            validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n-            validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n+            validator.expectString(t, left, getJSType(left), \"left side of \u0027in\u0027\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.INSTANCEOF:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n-            leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n-            validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n+            validator.expectAnyObject(t, left, getJSType(left), \"deterministic instanceof yields false\");\n             validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.ASSIGN:\n             visitAssign(t, n);\n             typeable \u003d false;\n             break;\n         case Token.ASSIGN_LSH:\n         case Token.ASSIGN_RSH:\n         case Token.ASSIGN_URSH:\n         case Token.ASSIGN_DIV:\n         case Token.ASSIGN_MOD:\n         case Token.ASSIGN_BITOR:\n         case Token.ASSIGN_BITXOR:\n         case Token.ASSIGN_BITAND:\n         case Token.ASSIGN_SUB:\n         case Token.ASSIGN_ADD:\n         case Token.ASSIGN_MUL:\n         case Token.LSH:\n         case Token.RSH:\n         case Token.URSH:\n         case Token.DIV:\n         case Token.MOD:\n         case Token.BITOR:\n         case Token.BITXOR:\n         case Token.BITAND:\n         case Token.SUB:\n         case Token.ADD:\n         case Token.MUL:\n             visitBinaryOperator(n.getType(), t, n);\n             break;\n         case Token.DELPROP:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.CASE:\n             JSType switchType \u003d getJSType(parent.getFirstChild());\n             JSType caseType \u003d getJSType(n.getFirstChild());\n             validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n             typeable \u003d false;\n             break;\n         case Token.WITH:\n             {\n                 Node child \u003d n.getFirstChild();\n                 childType \u003d getJSType(child);\n                 validator.expectObject(t, child, childType, \"with requires an object\");\n                 typeable \u003d false;\n                 break;\n             }\n         case Token.FUNCTION:\n             visitFunction(t, n);\n             break;\n         case Token.LABEL:\n         case Token.LABEL_NAME:\n         case Token.SWITCH:\n         case Token.BREAK:\n         case Token.CATCH:\n         case Token.TRY:\n         case Token.SCRIPT:\n         case Token.EXPR_RESULT:\n         case Token.BLOCK:\n         case Token.EMPTY:\n         case Token.DEFAULT_CASE:\n         case Token.CONTINUE:\n         case Token.DEBUGGER:\n         case Token.THROW:\n             typeable \u003d false;\n             break;\n         case Token.DO:\n         case Token.FOR:\n         case Token.IF:\n         case Token.WHILE:\n             typeable \u003d false;\n             break;\n         case Token.AND:\n         case Token.HOOK:\n         case Token.OBJECTLIT:\n         case Token.OR:\n             if (n.getJSType() !\u003d null) {\n                 ensureTyped(t, n);\n             } else {\n                 if ((n.isObjectLit()) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                     ensureTyped(t, n, parent.getJSType());\n                 } else {\n                     ensureTyped(t, n);\n                 }\n             }\n             if (n.isObjectLit()) {\n                 for (Node key : n.children()) {\n                     visitObjLitKey(t, key, n);\n                 }\n             }\n             break;\n         default:\n             report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n             ensureTyped(t, n);\n             break;\n     }\n     typeable \u003d typeable \u0026\u0026 !inExterns;\n     if (typeable) {\n         doPercentTypedAccounting(t, n);\n     }\n     checkNoTypeCheckSection(n, false);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "00241aa722c2245784e63dba9d444fce88134aed": {
      "type": "Ybodychange",
      "commitMessage": "\nAutomated g4 rollback\n\n*** Reason for rollback ***\n\nChange caused tests to stop building.\n\n*** Original change description ***\n\nNew @struct and @dict annotations for constructors.\nWith these annotations, one can enforce only dot or only bracket access on object properties.\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d5489\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2182 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "9/11/12, 11:52 AM",
      "commitName": "00241aa722c2245784e63dba9d444fce88134aed",
      "commitAuthor": "dimvar@google.com",
      "commitDateOld": "9/11/12, 11:10 AM",
      "commitNameOld": "63e875373844bdb6cedc7be3f537baa32cbd2ec0",
      "commitAuthorOld": "dimvar@google.com",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    boolean typeable \u003d true;\n    switch(n.getType()) {\n        case Token.NAME:\n            typeable \u003d visitName(t, n, parent);\n            break;\n        case Token.PARAM_LIST:\n            typeable \u003d false;\n            break;\n        case Token.COMMA:\n            ensureTyped(t, n, getJSType(n.getLastChild()));\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.THIS:\n            ensureTyped(t, n, t.getScope().getTypeOfThis());\n            break;\n        case Token.NULL:\n            ensureTyped(t, n, NULL_TYPE);\n            break;\n        case Token.NUMBER:\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.STRING:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.STRING_KEY:\n            typeable \u003d false;\n            break;\n        case Token.GETTER_DEF:\n        case Token.SETTER_DEF:\n            break;\n        case Token.ARRAYLIT:\n            ensureTyped(t, n, ARRAY_TYPE);\n            break;\n        case Token.REGEXP:\n            ensureTyped(t, n, REGEXP_TYPE);\n            break;\n        case Token.GETPROP:\n            visitGetProp(t, n, parent);\n            typeable \u003d !(parent.isAssign() \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n            break;\n        case Token.GETELEM:\n            visitGetElem(t, n);\n            typeable \u003d false;\n            break;\n        case Token.VAR:\n            visitVar(t, n);\n            typeable \u003d false;\n            break;\n        case Token.NEW:\n            visitNew(t, n);\n            break;\n        case Token.CALL:\n            visitCall(t, n);\n            typeable \u003d !parent.isExprResult();\n            break;\n        case Token.RETURN:\n            visitReturn(t, n);\n            typeable \u003d false;\n            break;\n        case Token.DEC:\n        case Token.INC:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.NOT:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.VOID:\n            ensureTyped(t, n, VOID_TYPE);\n            break;\n        case Token.TYPEOF:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.BITNOT:\n            childType \u003d getJSType(n.getFirstChild());\n            if (!childType.matchesInt32Context()) {\n                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n            }\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.EQ:\n        case Token.NE:\n        case Token.SHEQ:\n        case Token.SHNE:\n            {\n                left \u003d n.getFirstChild();\n                right \u003d n.getLastChild();\n                if (left.isTypeOf()) {\n                    if (right.isString()) {\n                        checkTypeofString(t, right, right.getString());\n                    }\n                } else if (right.isTypeOf() \u0026\u0026 left.isString()) {\n                    checkTypeofString(t, left, left.getString());\n                }\n                leftType \u003d getJSType(left);\n                rightType \u003d getJSType(right);\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                TernaryValue result \u003d TernaryValue.UNKNOWN;\n                if (n.getType() \u003d\u003d Token.EQ || n.getType() \u003d\u003d Token.NE) {\n                    result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                    if (n.isNE()) {\n                        result \u003d result.not();\n                    }\n                } else {\n                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                        result \u003d n.getType() \u003d\u003d Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;\n                    }\n                }\n                if (result !\u003d TernaryValue.UNKNOWN) {\n                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n            leftType \u003d getJSType(n.getFirstChild());\n            rightType \u003d getJSType(n.getLastChild());\n            if (rightType.isNumber()) {\n                validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n            } else if (leftType.isNumber()) {\n                validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n            } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n            } else {\n                String message \u003d \"left side of comparison\";\n                validator.expectString(t, n, leftType, message);\n                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                message \u003d \"right side of comparison\";\n                validator.expectString(t, n, rightType, message);\n                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.IN:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right);\n            validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n            validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.INSTANCEOF:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n            validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n            validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.ASSIGN:\n            visitAssign(t, n);\n            typeable \u003d false;\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.ASSIGN_URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_SUB:\n        case Token.ASSIGN_ADD:\n        case Token.ASSIGN_MUL:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.URSH:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITOR:\n        case Token.BITXOR:\n        case Token.BITAND:\n        case Token.SUB:\n        case Token.ADD:\n        case Token.MUL:\n            visitBinaryOperator(n.getType(), t, n);\n            break;\n        case Token.DELPROP:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.CASE:\n            JSType switchType \u003d getJSType(parent.getFirstChild());\n            JSType caseType \u003d getJSType(n.getFirstChild());\n            validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n            typeable \u003d false;\n            break;\n        case Token.WITH:\n            {\n                Node child \u003d n.getFirstChild();\n                childType \u003d getJSType(child);\n                validator.expectObject(t, child, childType, \"with requires an object\");\n                typeable \u003d false;\n                break;\n            }\n        case Token.FUNCTION:\n            visitFunction(t, n);\n            break;\n        case Token.LABEL:\n        case Token.LABEL_NAME:\n        case Token.SWITCH:\n        case Token.BREAK:\n        case Token.CATCH:\n        case Token.TRY:\n        case Token.SCRIPT:\n        case Token.EXPR_RESULT:\n        case Token.BLOCK:\n        case Token.EMPTY:\n        case Token.DEFAULT_CASE:\n        case Token.CONTINUE:\n        case Token.DEBUGGER:\n        case Token.THROW:\n            typeable \u003d false;\n            break;\n        case Token.DO:\n        case Token.FOR:\n        case Token.IF:\n        case Token.WHILE:\n            typeable \u003d false;\n            break;\n        case Token.AND:\n        case Token.HOOK:\n        case Token.OBJECTLIT:\n        case Token.OR:\n            if (n.getJSType() !\u003d null) {\n                ensureTyped(t, n);\n            } else {\n                if ((n.isObjectLit()) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                    ensureTyped(t, n, parent.getJSType());\n                } else {\n                    ensureTyped(t, n);\n                }\n            }\n            if (n.isObjectLit()) {\n                for (Node key : n.children()) {\n                    visitObjLitKey(t, key, n);\n                }\n            }\n            break;\n        default:\n            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n            ensureTyped(t, n);\n            break;\n    }\n    typeable \u003d typeable \u0026\u0026 !inExterns;\n    if (typeable) {\n        doPercentTypedAccounting(t, n);\n    }\n    checkNoTypeCheckSection(n, false);\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 462,
      "functionName": "visit",
      "functionAnnotation": "@Override",
      "functionDoc": "This is the meat of the type checking.  It is basically one big switch,\nwith each case representing one type of parse tree node.  The individual\ncases are usually pretty straightforward.\n\n@param t The node traversal object that supplies context, such as the\nscope chain to use in name lookups as well as error reporting.\n@param n The node being visited.\n@param parent The parent of the node n.\n",
      "diff": "@@ -1,265 +1,269 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n     JSType childType;\n     JSType leftType, rightType;\n     Node left, right;\n     boolean typeable \u003d true;\n     switch(n.getType()) {\n         case Token.NAME:\n             typeable \u003d visitName(t, n, parent);\n             break;\n         case Token.PARAM_LIST:\n             typeable \u003d false;\n             break;\n         case Token.COMMA:\n             ensureTyped(t, n, getJSType(n.getLastChild()));\n             break;\n         case Token.TRUE:\n         case Token.FALSE:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.THIS:\n             ensureTyped(t, n, t.getScope().getTypeOfThis());\n             break;\n         case Token.NULL:\n             ensureTyped(t, n, NULL_TYPE);\n             break;\n         case Token.NUMBER:\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.STRING:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.STRING_KEY:\n             typeable \u003d false;\n             break;\n         case Token.GETTER_DEF:\n         case Token.SETTER_DEF:\n             break;\n         case Token.ARRAYLIT:\n             ensureTyped(t, n, ARRAY_TYPE);\n             break;\n         case Token.REGEXP:\n             ensureTyped(t, n, REGEXP_TYPE);\n             break;\n         case Token.GETPROP:\n             visitGetProp(t, n, parent);\n             typeable \u003d !(parent.isAssign() \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n             break;\n         case Token.GETELEM:\n             visitGetElem(t, n);\n             typeable \u003d false;\n             break;\n         case Token.VAR:\n             visitVar(t, n);\n             typeable \u003d false;\n             break;\n         case Token.NEW:\n             visitNew(t, n);\n             break;\n         case Token.CALL:\n             visitCall(t, n);\n             typeable \u003d !parent.isExprResult();\n             break;\n         case Token.RETURN:\n             visitReturn(t, n);\n             typeable \u003d false;\n             break;\n         case Token.DEC:\n         case Token.INC:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.NOT:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.VOID:\n             ensureTyped(t, n, VOID_TYPE);\n             break;\n         case Token.TYPEOF:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.BITNOT:\n             childType \u003d getJSType(n.getFirstChild());\n             if (!childType.matchesInt32Context()) {\n                 report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n             }\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.POS:\n         case Token.NEG:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.EQ:\n         case Token.NE:\n         case Token.SHEQ:\n         case Token.SHNE:\n             {\n                 left \u003d n.getFirstChild();\n                 right \u003d n.getLastChild();\n                 if (left.isTypeOf()) {\n                     if (right.isString()) {\n                         checkTypeofString(t, right, right.getString());\n                     }\n                 } else if (right.isTypeOf() \u0026\u0026 left.isString()) {\n                     checkTypeofString(t, left, left.getString());\n                 }\n                 leftType \u003d getJSType(left);\n                 rightType \u003d getJSType(right);\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 TernaryValue result \u003d TernaryValue.UNKNOWN;\n                 if (n.getType() \u003d\u003d Token.EQ || n.getType() \u003d\u003d Token.NE) {\n                     result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                     if (n.isNE()) {\n                         result \u003d result.not();\n                     }\n                 } else {\n                     if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                         result \u003d n.getType() \u003d\u003d Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;\n                     }\n                 }\n                 if (result !\u003d TernaryValue.UNKNOWN) {\n                     report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.LT:\n         case Token.LE:\n         case Token.GT:\n         case Token.GE:\n             leftType \u003d getJSType(n.getFirstChild());\n             rightType \u003d getJSType(n.getLastChild());\n             if (rightType.isNumber()) {\n                 validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n             } else if (leftType.isNumber()) {\n                 validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n             } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n             } else {\n                 String message \u003d \"left side of comparison\";\n                 validator.expectString(t, n, leftType, message);\n                 validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                 message \u003d \"right side of comparison\";\n                 validator.expectString(t, n, rightType, message);\n                 validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.IN:\n-            validator.expectObject(t, n, getJSType(n.getLastChild()), \"\u0027in\u0027 requires an object\");\n             left \u003d n.getFirstChild();\n-            validator.expectString(t, left, getJSType(left), \"left side of \u0027in\u0027\");\n+            right \u003d n.getLastChild();\n+            leftType \u003d getJSType(left);\n+            rightType \u003d getJSType(right);\n+            validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n+            validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.INSTANCEOF:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n+            leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n-            validator.expectAnyObject(t, left, getJSType(left), \"deterministic instanceof yields false\");\n+            validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n             validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.ASSIGN:\n             visitAssign(t, n);\n             typeable \u003d false;\n             break;\n         case Token.ASSIGN_LSH:\n         case Token.ASSIGN_RSH:\n         case Token.ASSIGN_URSH:\n         case Token.ASSIGN_DIV:\n         case Token.ASSIGN_MOD:\n         case Token.ASSIGN_BITOR:\n         case Token.ASSIGN_BITXOR:\n         case Token.ASSIGN_BITAND:\n         case Token.ASSIGN_SUB:\n         case Token.ASSIGN_ADD:\n         case Token.ASSIGN_MUL:\n         case Token.LSH:\n         case Token.RSH:\n         case Token.URSH:\n         case Token.DIV:\n         case Token.MOD:\n         case Token.BITOR:\n         case Token.BITXOR:\n         case Token.BITAND:\n         case Token.SUB:\n         case Token.ADD:\n         case Token.MUL:\n             visitBinaryOperator(n.getType(), t, n);\n             break;\n         case Token.DELPROP:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.CASE:\n             JSType switchType \u003d getJSType(parent.getFirstChild());\n             JSType caseType \u003d getJSType(n.getFirstChild());\n             validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n             typeable \u003d false;\n             break;\n         case Token.WITH:\n             {\n                 Node child \u003d n.getFirstChild();\n                 childType \u003d getJSType(child);\n                 validator.expectObject(t, child, childType, \"with requires an object\");\n                 typeable \u003d false;\n                 break;\n             }\n         case Token.FUNCTION:\n             visitFunction(t, n);\n             break;\n         case Token.LABEL:\n         case Token.LABEL_NAME:\n         case Token.SWITCH:\n         case Token.BREAK:\n         case Token.CATCH:\n         case Token.TRY:\n         case Token.SCRIPT:\n         case Token.EXPR_RESULT:\n         case Token.BLOCK:\n         case Token.EMPTY:\n         case Token.DEFAULT_CASE:\n         case Token.CONTINUE:\n         case Token.DEBUGGER:\n         case Token.THROW:\n             typeable \u003d false;\n             break;\n         case Token.DO:\n         case Token.FOR:\n         case Token.IF:\n         case Token.WHILE:\n             typeable \u003d false;\n             break;\n         case Token.AND:\n         case Token.HOOK:\n         case Token.OBJECTLIT:\n         case Token.OR:\n             if (n.getJSType() !\u003d null) {\n                 ensureTyped(t, n);\n             } else {\n                 if ((n.isObjectLit()) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                     ensureTyped(t, n, parent.getJSType());\n                 } else {\n                     ensureTyped(t, n);\n                 }\n             }\n             if (n.isObjectLit()) {\n                 for (Node key : n.children()) {\n                     visitObjLitKey(t, key, n);\n                 }\n             }\n             break;\n         default:\n             report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n             ensureTyped(t, n);\n             break;\n     }\n     typeable \u003d typeable \u0026\u0026 !inExterns;\n     if (typeable) {\n         doPercentTypedAccounting(t, n);\n     }\n     checkNoTypeCheckSection(n, false);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "63e875373844bdb6cedc7be3f537baa32cbd2ec0": {
      "type": "Ybodychange",
      "commitMessage": "\nNew @struct and @dict annotations for constructors.\nWith these annotations, one can enforce only dot or only bracket access on object properties.\n\nR\u003dnicksantos\nDELTA\u003d476  (391 added, 34 deleted, 51 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d5488\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2181 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "9/11/12, 11:10 AM",
      "commitName": "63e875373844bdb6cedc7be3f537baa32cbd2ec0",
      "commitAuthor": "dimvar@google.com",
      "commitDateOld": "8/22/12, 12:20 PM",
      "commitNameOld": "d0f6017ead696c8bc68f01b167d9e9bb4b091921",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 19.95,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    boolean typeable \u003d true;\n    switch(n.getType()) {\n        case Token.NAME:\n            typeable \u003d visitName(t, n, parent);\n            break;\n        case Token.PARAM_LIST:\n            typeable \u003d false;\n            break;\n        case Token.COMMA:\n            ensureTyped(t, n, getJSType(n.getLastChild()));\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.THIS:\n            ensureTyped(t, n, t.getScope().getTypeOfThis());\n            break;\n        case Token.NULL:\n            ensureTyped(t, n, NULL_TYPE);\n            break;\n        case Token.NUMBER:\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.STRING:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.STRING_KEY:\n            typeable \u003d false;\n            break;\n        case Token.GETTER_DEF:\n        case Token.SETTER_DEF:\n            break;\n        case Token.ARRAYLIT:\n            ensureTyped(t, n, ARRAY_TYPE);\n            break;\n        case Token.REGEXP:\n            ensureTyped(t, n, REGEXP_TYPE);\n            break;\n        case Token.GETPROP:\n            visitGetProp(t, n, parent);\n            typeable \u003d !(parent.isAssign() \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n            break;\n        case Token.GETELEM:\n            visitGetElem(t, n);\n            typeable \u003d false;\n            break;\n        case Token.VAR:\n            visitVar(t, n);\n            typeable \u003d false;\n            break;\n        case Token.NEW:\n            visitNew(t, n);\n            break;\n        case Token.CALL:\n            visitCall(t, n);\n            typeable \u003d !parent.isExprResult();\n            break;\n        case Token.RETURN:\n            visitReturn(t, n);\n            typeable \u003d false;\n            break;\n        case Token.DEC:\n        case Token.INC:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.NOT:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.VOID:\n            ensureTyped(t, n, VOID_TYPE);\n            break;\n        case Token.TYPEOF:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.BITNOT:\n            childType \u003d getJSType(n.getFirstChild());\n            if (!childType.matchesInt32Context()) {\n                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n            }\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.EQ:\n        case Token.NE:\n        case Token.SHEQ:\n        case Token.SHNE:\n            {\n                left \u003d n.getFirstChild();\n                right \u003d n.getLastChild();\n                if (left.isTypeOf()) {\n                    if (right.isString()) {\n                        checkTypeofString(t, right, right.getString());\n                    }\n                } else if (right.isTypeOf() \u0026\u0026 left.isString()) {\n                    checkTypeofString(t, left, left.getString());\n                }\n                leftType \u003d getJSType(left);\n                rightType \u003d getJSType(right);\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                TernaryValue result \u003d TernaryValue.UNKNOWN;\n                if (n.getType() \u003d\u003d Token.EQ || n.getType() \u003d\u003d Token.NE) {\n                    result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                    if (n.isNE()) {\n                        result \u003d result.not();\n                    }\n                } else {\n                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                        result \u003d n.getType() \u003d\u003d Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;\n                    }\n                }\n                if (result !\u003d TernaryValue.UNKNOWN) {\n                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n            leftType \u003d getJSType(n.getFirstChild());\n            rightType \u003d getJSType(n.getLastChild());\n            if (rightType.isNumber()) {\n                validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n            } else if (leftType.isNumber()) {\n                validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n            } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n            } else {\n                String message \u003d \"left side of comparison\";\n                validator.expectString(t, n, leftType, message);\n                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                message \u003d \"right side of comparison\";\n                validator.expectString(t, n, rightType, message);\n                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.IN:\n            validator.expectObject(t, n, getJSType(n.getLastChild()), \"\u0027in\u0027 requires an object\");\n            left \u003d n.getFirstChild();\n            validator.expectString(t, left, getJSType(left), \"left side of \u0027in\u0027\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.INSTANCEOF:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n            validator.expectAnyObject(t, left, getJSType(left), \"deterministic instanceof yields false\");\n            validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.ASSIGN:\n            visitAssign(t, n);\n            typeable \u003d false;\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.ASSIGN_URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_SUB:\n        case Token.ASSIGN_ADD:\n        case Token.ASSIGN_MUL:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.URSH:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITOR:\n        case Token.BITXOR:\n        case Token.BITAND:\n        case Token.SUB:\n        case Token.ADD:\n        case Token.MUL:\n            visitBinaryOperator(n.getType(), t, n);\n            break;\n        case Token.DELPROP:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.CASE:\n            JSType switchType \u003d getJSType(parent.getFirstChild());\n            JSType caseType \u003d getJSType(n.getFirstChild());\n            validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n            typeable \u003d false;\n            break;\n        case Token.WITH:\n            {\n                Node child \u003d n.getFirstChild();\n                childType \u003d getJSType(child);\n                validator.expectObject(t, child, childType, \"with requires an object\");\n                typeable \u003d false;\n                break;\n            }\n        case Token.FUNCTION:\n            visitFunction(t, n);\n            break;\n        case Token.LABEL:\n        case Token.LABEL_NAME:\n        case Token.SWITCH:\n        case Token.BREAK:\n        case Token.CATCH:\n        case Token.TRY:\n        case Token.SCRIPT:\n        case Token.EXPR_RESULT:\n        case Token.BLOCK:\n        case Token.EMPTY:\n        case Token.DEFAULT_CASE:\n        case Token.CONTINUE:\n        case Token.DEBUGGER:\n        case Token.THROW:\n            typeable \u003d false;\n            break;\n        case Token.DO:\n        case Token.FOR:\n        case Token.IF:\n        case Token.WHILE:\n            typeable \u003d false;\n            break;\n        case Token.AND:\n        case Token.HOOK:\n        case Token.OBJECTLIT:\n        case Token.OR:\n            if (n.getJSType() !\u003d null) {\n                ensureTyped(t, n);\n            } else {\n                if ((n.isObjectLit()) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                    ensureTyped(t, n, parent.getJSType());\n                } else {\n                    ensureTyped(t, n);\n                }\n            }\n            if (n.isObjectLit()) {\n                for (Node key : n.children()) {\n                    visitObjLitKey(t, key, n);\n                }\n            }\n            break;\n        default:\n            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n            ensureTyped(t, n);\n            break;\n    }\n    typeable \u003d typeable \u0026\u0026 !inExterns;\n    if (typeable) {\n        doPercentTypedAccounting(t, n);\n    }\n    checkNoTypeCheckSection(n, false);\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 460,
      "functionName": "visit",
      "functionAnnotation": "@Override",
      "functionDoc": "This is the meat of the type checking.  It is basically one big switch,\nwith each case representing one type of parse tree node.  The individual\ncases are usually pretty straightforward.\n\n@param t The node traversal object that supplies context, such as the\nscope chain to use in name lookups as well as error reporting.\n@param n The node being visited.\n@param parent The parent of the node n.\n",
      "diff": "@@ -1,269 +1,265 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n     JSType childType;\n     JSType leftType, rightType;\n     Node left, right;\n     boolean typeable \u003d true;\n     switch(n.getType()) {\n         case Token.NAME:\n             typeable \u003d visitName(t, n, parent);\n             break;\n         case Token.PARAM_LIST:\n             typeable \u003d false;\n             break;\n         case Token.COMMA:\n             ensureTyped(t, n, getJSType(n.getLastChild()));\n             break;\n         case Token.TRUE:\n         case Token.FALSE:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.THIS:\n             ensureTyped(t, n, t.getScope().getTypeOfThis());\n             break;\n         case Token.NULL:\n             ensureTyped(t, n, NULL_TYPE);\n             break;\n         case Token.NUMBER:\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.STRING:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.STRING_KEY:\n             typeable \u003d false;\n             break;\n         case Token.GETTER_DEF:\n         case Token.SETTER_DEF:\n             break;\n         case Token.ARRAYLIT:\n             ensureTyped(t, n, ARRAY_TYPE);\n             break;\n         case Token.REGEXP:\n             ensureTyped(t, n, REGEXP_TYPE);\n             break;\n         case Token.GETPROP:\n             visitGetProp(t, n, parent);\n             typeable \u003d !(parent.isAssign() \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n             break;\n         case Token.GETELEM:\n             visitGetElem(t, n);\n             typeable \u003d false;\n             break;\n         case Token.VAR:\n             visitVar(t, n);\n             typeable \u003d false;\n             break;\n         case Token.NEW:\n             visitNew(t, n);\n             break;\n         case Token.CALL:\n             visitCall(t, n);\n             typeable \u003d !parent.isExprResult();\n             break;\n         case Token.RETURN:\n             visitReturn(t, n);\n             typeable \u003d false;\n             break;\n         case Token.DEC:\n         case Token.INC:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.NOT:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.VOID:\n             ensureTyped(t, n, VOID_TYPE);\n             break;\n         case Token.TYPEOF:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.BITNOT:\n             childType \u003d getJSType(n.getFirstChild());\n             if (!childType.matchesInt32Context()) {\n                 report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n             }\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.POS:\n         case Token.NEG:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.EQ:\n         case Token.NE:\n         case Token.SHEQ:\n         case Token.SHNE:\n             {\n                 left \u003d n.getFirstChild();\n                 right \u003d n.getLastChild();\n                 if (left.isTypeOf()) {\n                     if (right.isString()) {\n                         checkTypeofString(t, right, right.getString());\n                     }\n                 } else if (right.isTypeOf() \u0026\u0026 left.isString()) {\n                     checkTypeofString(t, left, left.getString());\n                 }\n                 leftType \u003d getJSType(left);\n                 rightType \u003d getJSType(right);\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 TernaryValue result \u003d TernaryValue.UNKNOWN;\n                 if (n.getType() \u003d\u003d Token.EQ || n.getType() \u003d\u003d Token.NE) {\n                     result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                     if (n.isNE()) {\n                         result \u003d result.not();\n                     }\n                 } else {\n                     if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                         result \u003d n.getType() \u003d\u003d Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;\n                     }\n                 }\n                 if (result !\u003d TernaryValue.UNKNOWN) {\n                     report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.LT:\n         case Token.LE:\n         case Token.GT:\n         case Token.GE:\n             leftType \u003d getJSType(n.getFirstChild());\n             rightType \u003d getJSType(n.getLastChild());\n             if (rightType.isNumber()) {\n                 validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n             } else if (leftType.isNumber()) {\n                 validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n             } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n             } else {\n                 String message \u003d \"left side of comparison\";\n                 validator.expectString(t, n, leftType, message);\n                 validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                 message \u003d \"right side of comparison\";\n                 validator.expectString(t, n, rightType, message);\n                 validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.IN:\n+            validator.expectObject(t, n, getJSType(n.getLastChild()), \"\u0027in\u0027 requires an object\");\n             left \u003d n.getFirstChild();\n-            right \u003d n.getLastChild();\n-            leftType \u003d getJSType(left);\n-            rightType \u003d getJSType(right);\n-            validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n-            validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n+            validator.expectString(t, left, getJSType(left), \"left side of \u0027in\u0027\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.INSTANCEOF:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n-            leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n-            validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n+            validator.expectAnyObject(t, left, getJSType(left), \"deterministic instanceof yields false\");\n             validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.ASSIGN:\n             visitAssign(t, n);\n             typeable \u003d false;\n             break;\n         case Token.ASSIGN_LSH:\n         case Token.ASSIGN_RSH:\n         case Token.ASSIGN_URSH:\n         case Token.ASSIGN_DIV:\n         case Token.ASSIGN_MOD:\n         case Token.ASSIGN_BITOR:\n         case Token.ASSIGN_BITXOR:\n         case Token.ASSIGN_BITAND:\n         case Token.ASSIGN_SUB:\n         case Token.ASSIGN_ADD:\n         case Token.ASSIGN_MUL:\n         case Token.LSH:\n         case Token.RSH:\n         case Token.URSH:\n         case Token.DIV:\n         case Token.MOD:\n         case Token.BITOR:\n         case Token.BITXOR:\n         case Token.BITAND:\n         case Token.SUB:\n         case Token.ADD:\n         case Token.MUL:\n             visitBinaryOperator(n.getType(), t, n);\n             break;\n         case Token.DELPROP:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.CASE:\n             JSType switchType \u003d getJSType(parent.getFirstChild());\n             JSType caseType \u003d getJSType(n.getFirstChild());\n             validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n             typeable \u003d false;\n             break;\n         case Token.WITH:\n             {\n                 Node child \u003d n.getFirstChild();\n                 childType \u003d getJSType(child);\n                 validator.expectObject(t, child, childType, \"with requires an object\");\n                 typeable \u003d false;\n                 break;\n             }\n         case Token.FUNCTION:\n             visitFunction(t, n);\n             break;\n         case Token.LABEL:\n         case Token.LABEL_NAME:\n         case Token.SWITCH:\n         case Token.BREAK:\n         case Token.CATCH:\n         case Token.TRY:\n         case Token.SCRIPT:\n         case Token.EXPR_RESULT:\n         case Token.BLOCK:\n         case Token.EMPTY:\n         case Token.DEFAULT_CASE:\n         case Token.CONTINUE:\n         case Token.DEBUGGER:\n         case Token.THROW:\n             typeable \u003d false;\n             break;\n         case Token.DO:\n         case Token.FOR:\n         case Token.IF:\n         case Token.WHILE:\n             typeable \u003d false;\n             break;\n         case Token.AND:\n         case Token.HOOK:\n         case Token.OBJECTLIT:\n         case Token.OR:\n             if (n.getJSType() !\u003d null) {\n                 ensureTyped(t, n);\n             } else {\n                 if ((n.isObjectLit()) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                     ensureTyped(t, n, parent.getJSType());\n                 } else {\n                     ensureTyped(t, n);\n                 }\n             }\n             if (n.isObjectLit()) {\n                 for (Node key : n.children()) {\n                     visitObjLitKey(t, key, n);\n                 }\n             }\n             break;\n         default:\n             report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n             ensureTyped(t, n);\n             break;\n     }\n     typeable \u003d typeable \u0026\u0026 !inExterns;\n     if (typeable) {\n         doPercentTypedAccounting(t, n);\n     }\n     checkNoTypeCheckSection(n, false);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4f663a93dcdc8130cf92c3ad31ce8a8ac1fd0804": {
      "type": "Ybodychange",
      "commitMessage": "\nSome small things I noticed in TypeCheck.java while working on issue 370.\n\nparam_list in visit:\nA param_list is always under a function, otherwise we\u0027d have a parsing error.\n\nnew:\ntypeable is set to true at the beginning of visit, and visitNew can\u0027t mutate it.\n\nvisitReturn:\nMisplaced returns can\u0027t happen, they\u0027d have been caught during parsing.\n\nR\u003dnicksantos,johnlenz\nDELTA\u003d18  (0 added, 15 deleted, 3 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d5292\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2116 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "8/1/12, 11:39 AM",
      "commitName": "4f663a93dcdc8130cf92c3ad31ce8a8ac1fd0804",
      "commitAuthor": "dimvar@google.com",
      "commitDateOld": "8/1/12, 9:36 AM",
      "commitNameOld": "2e823fbd0b74b1a0877f6c4474e8e1c5c42029c0",
      "commitAuthorOld": "dimvar@google.com",
      "daysBetweenCommits": 0.09,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    boolean typeable \u003d true;\n    switch(n.getType()) {\n        case Token.NAME:\n            typeable \u003d visitName(t, n, parent);\n            break;\n        case Token.PARAM_LIST:\n            typeable \u003d false;\n            break;\n        case Token.COMMA:\n            ensureTyped(t, n, getJSType(n.getLastChild()));\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.THIS:\n            ensureTyped(t, n, t.getScope().getTypeOfThis());\n            break;\n        case Token.NULL:\n            ensureTyped(t, n, NULL_TYPE);\n            break;\n        case Token.NUMBER:\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.STRING:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.STRING_KEY:\n            typeable \u003d false;\n            break;\n        case Token.GETTER_DEF:\n        case Token.SETTER_DEF:\n            break;\n        case Token.ARRAYLIT:\n            ensureTyped(t, n, ARRAY_TYPE);\n            break;\n        case Token.REGEXP:\n            ensureTyped(t, n, REGEXP_TYPE);\n            break;\n        case Token.GETPROP:\n            visitGetProp(t, n, parent);\n            typeable \u003d !(parent.isAssign() \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n            break;\n        case Token.GETELEM:\n            visitGetElem(t, n);\n            typeable \u003d false;\n            break;\n        case Token.VAR:\n            visitVar(t, n);\n            typeable \u003d false;\n            break;\n        case Token.NEW:\n            visitNew(t, n);\n            break;\n        case Token.CALL:\n            visitCall(t, n);\n            typeable \u003d !parent.isExprResult();\n            break;\n        case Token.RETURN:\n            visitReturn(t, n);\n            typeable \u003d false;\n            break;\n        case Token.DEC:\n        case Token.INC:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.NOT:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.VOID:\n            ensureTyped(t, n, VOID_TYPE);\n            break;\n        case Token.TYPEOF:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.BITNOT:\n            childType \u003d getJSType(n.getFirstChild());\n            if (!childType.matchesInt32Context()) {\n                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n            }\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.EQ:\n        case Token.NE:\n        case Token.SHEQ:\n        case Token.SHNE:\n            {\n                left \u003d n.getFirstChild();\n                right \u003d n.getLastChild();\n                if (left.isTypeOf()) {\n                    if (right.isString()) {\n                        checkTypeofString(t, right, right.getString());\n                    }\n                } else if (right.isTypeOf() \u0026\u0026 left.isString()) {\n                    checkTypeofString(t, left, left.getString());\n                }\n                leftType \u003d getJSType(left);\n                rightType \u003d getJSType(right);\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                TernaryValue result \u003d TernaryValue.UNKNOWN;\n                if (n.getType() \u003d\u003d Token.EQ || n.getType() \u003d\u003d Token.NE) {\n                    result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                    if (n.isNE()) {\n                        result \u003d result.not();\n                    }\n                } else {\n                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                        result \u003d n.getType() \u003d\u003d Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;\n                    }\n                }\n                if (result !\u003d TernaryValue.UNKNOWN) {\n                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n            leftType \u003d getJSType(n.getFirstChild());\n            rightType \u003d getJSType(n.getLastChild());\n            if (rightType.isNumber()) {\n                validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n            } else if (leftType.isNumber()) {\n                validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n            } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n            } else {\n                String message \u003d \"left side of comparison\";\n                validator.expectString(t, n, leftType, message);\n                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                message \u003d \"right side of comparison\";\n                validator.expectString(t, n, rightType, message);\n                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.IN:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right);\n            validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n            validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.INSTANCEOF:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n            validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n            validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.ASSIGN:\n            visitAssign(t, n);\n            typeable \u003d false;\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.ASSIGN_URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_SUB:\n        case Token.ASSIGN_ADD:\n        case Token.ASSIGN_MUL:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.URSH:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITOR:\n        case Token.BITXOR:\n        case Token.BITAND:\n        case Token.SUB:\n        case Token.ADD:\n        case Token.MUL:\n            visitBinaryOperator(n.getType(), t, n);\n            break;\n        case Token.DELPROP:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.CASE:\n            JSType switchType \u003d getJSType(parent.getFirstChild());\n            JSType caseType \u003d getJSType(n.getFirstChild());\n            validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n            typeable \u003d false;\n            break;\n        case Token.WITH:\n            {\n                Node child \u003d n.getFirstChild();\n                childType \u003d getJSType(child);\n                validator.expectObject(t, child, childType, \"with requires an object\");\n                typeable \u003d false;\n                break;\n            }\n        case Token.FUNCTION:\n            visitFunction(t, n);\n            break;\n        case Token.LABEL:\n        case Token.LABEL_NAME:\n        case Token.SWITCH:\n        case Token.BREAK:\n        case Token.CATCH:\n        case Token.TRY:\n        case Token.SCRIPT:\n        case Token.EXPR_RESULT:\n        case Token.BLOCK:\n        case Token.EMPTY:\n        case Token.DEFAULT_CASE:\n        case Token.CONTINUE:\n        case Token.DEBUGGER:\n        case Token.THROW:\n            typeable \u003d false;\n            break;\n        case Token.DO:\n        case Token.FOR:\n        case Token.IF:\n        case Token.WHILE:\n            typeable \u003d false;\n            break;\n        case Token.AND:\n        case Token.HOOK:\n        case Token.OBJECTLIT:\n        case Token.OR:\n            if (n.getJSType() !\u003d null) {\n                ensureTyped(t, n);\n            } else {\n                if ((n.isObjectLit()) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                    ensureTyped(t, n, parent.getJSType());\n                } else {\n                    ensureTyped(t, n);\n                }\n            }\n            if (n.isObjectLit()) {\n                for (Node key : n.children()) {\n                    visitObjLitKey(t, key, n);\n                }\n            }\n            break;\n        default:\n            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n            ensureTyped(t, n);\n            break;\n    }\n    typeable \u003d typeable \u0026\u0026 !inExterns;\n    if (typeable) {\n        doPercentTypedAccounting(t, n);\n    }\n    checkNoTypeCheckSection(n, false);\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 462,
      "functionName": "visit",
      "functionAnnotation": "@Override",
      "functionDoc": "This is the meat of the type checking.  It is basically one big switch,\nwith each case representing one type of parse tree node.  The individual\ncases are usually pretty straightforward.\n\n@param t The node traversal object that supplies context, such as the\nscope chain to use in name lookups as well as error reporting.\n@param n The node being visited.\n@param parent The parent of the node n.\n",
      "diff": "@@ -1,274 +1,269 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n     JSType childType;\n     JSType leftType, rightType;\n     Node left, right;\n     boolean typeable \u003d true;\n     switch(n.getType()) {\n         case Token.NAME:\n             typeable \u003d visitName(t, n, parent);\n             break;\n         case Token.PARAM_LIST:\n-            if (!parent.isFunction()) {\n-                ensureTyped(t, n, getJSType(n.getFirstChild()));\n-            } else {\n-                typeable \u003d false;\n-            }\n+            typeable \u003d false;\n             break;\n         case Token.COMMA:\n             ensureTyped(t, n, getJSType(n.getLastChild()));\n             break;\n         case Token.TRUE:\n         case Token.FALSE:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.THIS:\n             ensureTyped(t, n, t.getScope().getTypeOfThis());\n             break;\n         case Token.NULL:\n             ensureTyped(t, n, NULL_TYPE);\n             break;\n         case Token.NUMBER:\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.STRING:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.STRING_KEY:\n             typeable \u003d false;\n             break;\n         case Token.GETTER_DEF:\n         case Token.SETTER_DEF:\n             break;\n         case Token.ARRAYLIT:\n             ensureTyped(t, n, ARRAY_TYPE);\n             break;\n         case Token.REGEXP:\n             ensureTyped(t, n, REGEXP_TYPE);\n             break;\n         case Token.GETPROP:\n             visitGetProp(t, n, parent);\n             typeable \u003d !(parent.isAssign() \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n             break;\n         case Token.GETELEM:\n             visitGetElem(t, n);\n             typeable \u003d false;\n             break;\n         case Token.VAR:\n             visitVar(t, n);\n             typeable \u003d false;\n             break;\n         case Token.NEW:\n             visitNew(t, n);\n-            typeable \u003d true;\n             break;\n         case Token.CALL:\n             visitCall(t, n);\n             typeable \u003d !parent.isExprResult();\n             break;\n         case Token.RETURN:\n             visitReturn(t, n);\n             typeable \u003d false;\n             break;\n         case Token.DEC:\n         case Token.INC:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.NOT:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.VOID:\n             ensureTyped(t, n, VOID_TYPE);\n             break;\n         case Token.TYPEOF:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.BITNOT:\n             childType \u003d getJSType(n.getFirstChild());\n             if (!childType.matchesInt32Context()) {\n                 report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n             }\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.POS:\n         case Token.NEG:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.EQ:\n         case Token.NE:\n         case Token.SHEQ:\n         case Token.SHNE:\n             {\n                 left \u003d n.getFirstChild();\n                 right \u003d n.getLastChild();\n                 if (left.isTypeOf()) {\n                     if (right.isString()) {\n                         checkTypeofString(t, right, right.getString());\n                     }\n                 } else if (right.isTypeOf() \u0026\u0026 left.isString()) {\n                     checkTypeofString(t, left, left.getString());\n                 }\n                 leftType \u003d getJSType(left);\n                 rightType \u003d getJSType(right);\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 TernaryValue result \u003d TernaryValue.UNKNOWN;\n                 if (n.getType() \u003d\u003d Token.EQ || n.getType() \u003d\u003d Token.NE) {\n                     result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                     if (n.isNE()) {\n                         result \u003d result.not();\n                     }\n                 } else {\n                     if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                         result \u003d n.getType() \u003d\u003d Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;\n                     }\n                 }\n                 if (result !\u003d TernaryValue.UNKNOWN) {\n                     report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.LT:\n         case Token.LE:\n         case Token.GT:\n         case Token.GE:\n             leftType \u003d getJSType(n.getFirstChild());\n             rightType \u003d getJSType(n.getLastChild());\n             if (rightType.isNumber()) {\n                 validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n             } else if (leftType.isNumber()) {\n                 validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n             } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n             } else {\n                 String message \u003d \"left side of comparison\";\n                 validator.expectString(t, n, leftType, message);\n                 validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                 message \u003d \"right side of comparison\";\n                 validator.expectString(t, n, rightType, message);\n                 validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.IN:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right);\n             validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n             validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.INSTANCEOF:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n             validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n             validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.ASSIGN:\n             visitAssign(t, n);\n             typeable \u003d false;\n             break;\n         case Token.ASSIGN_LSH:\n         case Token.ASSIGN_RSH:\n         case Token.ASSIGN_URSH:\n         case Token.ASSIGN_DIV:\n         case Token.ASSIGN_MOD:\n         case Token.ASSIGN_BITOR:\n         case Token.ASSIGN_BITXOR:\n         case Token.ASSIGN_BITAND:\n         case Token.ASSIGN_SUB:\n         case Token.ASSIGN_ADD:\n         case Token.ASSIGN_MUL:\n         case Token.LSH:\n         case Token.RSH:\n         case Token.URSH:\n         case Token.DIV:\n         case Token.MOD:\n         case Token.BITOR:\n         case Token.BITXOR:\n         case Token.BITAND:\n         case Token.SUB:\n         case Token.ADD:\n         case Token.MUL:\n             visitBinaryOperator(n.getType(), t, n);\n             break;\n         case Token.DELPROP:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.CASE:\n             JSType switchType \u003d getJSType(parent.getFirstChild());\n             JSType caseType \u003d getJSType(n.getFirstChild());\n             validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n             typeable \u003d false;\n             break;\n         case Token.WITH:\n             {\n                 Node child \u003d n.getFirstChild();\n                 childType \u003d getJSType(child);\n                 validator.expectObject(t, child, childType, \"with requires an object\");\n                 typeable \u003d false;\n                 break;\n             }\n         case Token.FUNCTION:\n             visitFunction(t, n);\n             break;\n         case Token.LABEL:\n         case Token.LABEL_NAME:\n         case Token.SWITCH:\n         case Token.BREAK:\n         case Token.CATCH:\n         case Token.TRY:\n         case Token.SCRIPT:\n         case Token.EXPR_RESULT:\n         case Token.BLOCK:\n         case Token.EMPTY:\n         case Token.DEFAULT_CASE:\n         case Token.CONTINUE:\n         case Token.DEBUGGER:\n         case Token.THROW:\n             typeable \u003d false;\n             break;\n         case Token.DO:\n         case Token.FOR:\n         case Token.IF:\n         case Token.WHILE:\n             typeable \u003d false;\n             break;\n         case Token.AND:\n         case Token.HOOK:\n         case Token.OBJECTLIT:\n         case Token.OR:\n             if (n.getJSType() !\u003d null) {\n                 ensureTyped(t, n);\n             } else {\n                 if ((n.isObjectLit()) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                     ensureTyped(t, n, parent.getJSType());\n                 } else {\n                     ensureTyped(t, n);\n                 }\n             }\n             if (n.isObjectLit()) {\n                 for (Node key : n.children()) {\n                     visitObjLitKey(t, key, n);\n                 }\n             }\n             break;\n         default:\n             report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n             ensureTyped(t, n);\n             break;\n     }\n     typeable \u003d typeable \u0026\u0026 !inExterns;\n     if (typeable) {\n         doPercentTypedAccounting(t, n);\n     }\n     checkNoTypeCheckSection(n, false);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2e823fbd0b74b1a0877f6c4474e8e1c5c42029c0": {
      "type": "Ybodychange",
      "commitMessage": "\nFixes issue 370\nhttp://code.google.com/p/closure-compiler/issues/detail?id\u003d370\nWarn when comparing the result of a TYPEOF to a string that does not correspond to a type name.\nNote that the TYPEOF can be arbitrarily far from the mistyped string, and in this case we won\u0027t emit a warning, eg,\nvar s \u003d typeof 123;\nif (s \u003d\u003d \u0027numbr\u0027) ...\n\nThe earliest this error can be detected is in caseTypeof in SemanticReverseAbstractInterpreter.java. However, all warnings are emitted during the type-checking phase, so I perform the test there in order to have access to the validator.\n\nR\u003dnicksantos,johnlenz\nDELTA\u003d37  (32 added, 1 deleted, 4 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d5284\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2115 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "8/1/12, 9:36 AM",
      "commitName": "2e823fbd0b74b1a0877f6c4474e8e1c5c42029c0",
      "commitAuthor": "dimvar@google.com",
      "commitDateOld": "6/6/12, 8:42 AM",
      "commitNameOld": "8caec1a47007acc8b827aa273c065ce698468b27",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 56.04,
      "commitsBetweenForRepo": 85,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    boolean typeable \u003d true;\n    switch(n.getType()) {\n        case Token.NAME:\n            typeable \u003d visitName(t, n, parent);\n            break;\n        case Token.PARAM_LIST:\n            if (!parent.isFunction()) {\n                ensureTyped(t, n, getJSType(n.getFirstChild()));\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.COMMA:\n            ensureTyped(t, n, getJSType(n.getLastChild()));\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.THIS:\n            ensureTyped(t, n, t.getScope().getTypeOfThis());\n            break;\n        case Token.NULL:\n            ensureTyped(t, n, NULL_TYPE);\n            break;\n        case Token.NUMBER:\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.STRING:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.STRING_KEY:\n            typeable \u003d false;\n            break;\n        case Token.GETTER_DEF:\n        case Token.SETTER_DEF:\n            break;\n        case Token.ARRAYLIT:\n            ensureTyped(t, n, ARRAY_TYPE);\n            break;\n        case Token.REGEXP:\n            ensureTyped(t, n, REGEXP_TYPE);\n            break;\n        case Token.GETPROP:\n            visitGetProp(t, n, parent);\n            typeable \u003d !(parent.isAssign() \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n            break;\n        case Token.GETELEM:\n            visitGetElem(t, n);\n            typeable \u003d false;\n            break;\n        case Token.VAR:\n            visitVar(t, n);\n            typeable \u003d false;\n            break;\n        case Token.NEW:\n            visitNew(t, n);\n            typeable \u003d true;\n            break;\n        case Token.CALL:\n            visitCall(t, n);\n            typeable \u003d !parent.isExprResult();\n            break;\n        case Token.RETURN:\n            visitReturn(t, n);\n            typeable \u003d false;\n            break;\n        case Token.DEC:\n        case Token.INC:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.NOT:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.VOID:\n            ensureTyped(t, n, VOID_TYPE);\n            break;\n        case Token.TYPEOF:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.BITNOT:\n            childType \u003d getJSType(n.getFirstChild());\n            if (!childType.matchesInt32Context()) {\n                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n            }\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.EQ:\n        case Token.NE:\n        case Token.SHEQ:\n        case Token.SHNE:\n            {\n                left \u003d n.getFirstChild();\n                right \u003d n.getLastChild();\n                if (left.isTypeOf()) {\n                    if (right.isString()) {\n                        checkTypeofString(t, right, right.getString());\n                    }\n                } else if (right.isTypeOf() \u0026\u0026 left.isString()) {\n                    checkTypeofString(t, left, left.getString());\n                }\n                leftType \u003d getJSType(left);\n                rightType \u003d getJSType(right);\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                TernaryValue result \u003d TernaryValue.UNKNOWN;\n                if (n.getType() \u003d\u003d Token.EQ || n.getType() \u003d\u003d Token.NE) {\n                    result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                    if (n.isNE()) {\n                        result \u003d result.not();\n                    }\n                } else {\n                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                        result \u003d n.getType() \u003d\u003d Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;\n                    }\n                }\n                if (result !\u003d TernaryValue.UNKNOWN) {\n                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n            leftType \u003d getJSType(n.getFirstChild());\n            rightType \u003d getJSType(n.getLastChild());\n            if (rightType.isNumber()) {\n                validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n            } else if (leftType.isNumber()) {\n                validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n            } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n            } else {\n                String message \u003d \"left side of comparison\";\n                validator.expectString(t, n, leftType, message);\n                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                message \u003d \"right side of comparison\";\n                validator.expectString(t, n, rightType, message);\n                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.IN:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right);\n            validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n            validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.INSTANCEOF:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n            validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n            validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.ASSIGN:\n            visitAssign(t, n);\n            typeable \u003d false;\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.ASSIGN_URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_SUB:\n        case Token.ASSIGN_ADD:\n        case Token.ASSIGN_MUL:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.URSH:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITOR:\n        case Token.BITXOR:\n        case Token.BITAND:\n        case Token.SUB:\n        case Token.ADD:\n        case Token.MUL:\n            visitBinaryOperator(n.getType(), t, n);\n            break;\n        case Token.DELPROP:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.CASE:\n            JSType switchType \u003d getJSType(parent.getFirstChild());\n            JSType caseType \u003d getJSType(n.getFirstChild());\n            validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n            typeable \u003d false;\n            break;\n        case Token.WITH:\n            {\n                Node child \u003d n.getFirstChild();\n                childType \u003d getJSType(child);\n                validator.expectObject(t, child, childType, \"with requires an object\");\n                typeable \u003d false;\n                break;\n            }\n        case Token.FUNCTION:\n            visitFunction(t, n);\n            break;\n        case Token.LABEL:\n        case Token.LABEL_NAME:\n        case Token.SWITCH:\n        case Token.BREAK:\n        case Token.CATCH:\n        case Token.TRY:\n        case Token.SCRIPT:\n        case Token.EXPR_RESULT:\n        case Token.BLOCK:\n        case Token.EMPTY:\n        case Token.DEFAULT_CASE:\n        case Token.CONTINUE:\n        case Token.DEBUGGER:\n        case Token.THROW:\n            typeable \u003d false;\n            break;\n        case Token.DO:\n        case Token.FOR:\n        case Token.IF:\n        case Token.WHILE:\n            typeable \u003d false;\n            break;\n        case Token.AND:\n        case Token.HOOK:\n        case Token.OBJECTLIT:\n        case Token.OR:\n            if (n.getJSType() !\u003d null) {\n                ensureTyped(t, n);\n            } else {\n                if ((n.isObjectLit()) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                    ensureTyped(t, n, parent.getJSType());\n                } else {\n                    ensureTyped(t, n);\n                }\n            }\n            if (n.isObjectLit()) {\n                for (Node key : n.children()) {\n                    visitObjLitKey(t, key, n);\n                }\n            }\n            break;\n        default:\n            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n            ensureTyped(t, n);\n            break;\n    }\n    typeable \u003d typeable \u0026\u0026 !inExterns;\n    if (typeable) {\n        doPercentTypedAccounting(t, n);\n    }\n    checkNoTypeCheckSection(n, false);\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 462,
      "functionName": "visit",
      "functionAnnotation": "@Override",
      "functionDoc": "This is the meat of the type checking.  It is basically one big switch,\nwith each case representing one type of parse tree node.  The individual\ncases are usually pretty straightforward.\n\n@param t The node traversal object that supplies context, such as the\nscope chain to use in name lookups as well as error reporting.\n@param n The node being visited.\n@param parent The parent of the node n.\n",
      "diff": "@@ -1,265 +1,274 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n     JSType childType;\n     JSType leftType, rightType;\n     Node left, right;\n     boolean typeable \u003d true;\n     switch(n.getType()) {\n         case Token.NAME:\n             typeable \u003d visitName(t, n, parent);\n             break;\n         case Token.PARAM_LIST:\n             if (!parent.isFunction()) {\n                 ensureTyped(t, n, getJSType(n.getFirstChild()));\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.COMMA:\n             ensureTyped(t, n, getJSType(n.getLastChild()));\n             break;\n         case Token.TRUE:\n         case Token.FALSE:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.THIS:\n             ensureTyped(t, n, t.getScope().getTypeOfThis());\n             break;\n         case Token.NULL:\n             ensureTyped(t, n, NULL_TYPE);\n             break;\n         case Token.NUMBER:\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.STRING:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.STRING_KEY:\n             typeable \u003d false;\n             break;\n         case Token.GETTER_DEF:\n         case Token.SETTER_DEF:\n             break;\n         case Token.ARRAYLIT:\n             ensureTyped(t, n, ARRAY_TYPE);\n             break;\n         case Token.REGEXP:\n             ensureTyped(t, n, REGEXP_TYPE);\n             break;\n         case Token.GETPROP:\n             visitGetProp(t, n, parent);\n             typeable \u003d !(parent.isAssign() \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n             break;\n         case Token.GETELEM:\n             visitGetElem(t, n);\n             typeable \u003d false;\n             break;\n         case Token.VAR:\n             visitVar(t, n);\n             typeable \u003d false;\n             break;\n         case Token.NEW:\n             visitNew(t, n);\n             typeable \u003d true;\n             break;\n         case Token.CALL:\n             visitCall(t, n);\n             typeable \u003d !parent.isExprResult();\n             break;\n         case Token.RETURN:\n             visitReturn(t, n);\n             typeable \u003d false;\n             break;\n         case Token.DEC:\n         case Token.INC:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.NOT:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.VOID:\n             ensureTyped(t, n, VOID_TYPE);\n             break;\n         case Token.TYPEOF:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.BITNOT:\n             childType \u003d getJSType(n.getFirstChild());\n             if (!childType.matchesInt32Context()) {\n                 report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n             }\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.POS:\n         case Token.NEG:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.EQ:\n         case Token.NE:\n         case Token.SHEQ:\n         case Token.SHNE:\n             {\n-                leftType \u003d getJSType(n.getFirstChild());\n-                rightType \u003d getJSType(n.getLastChild());\n+                left \u003d n.getFirstChild();\n+                right \u003d n.getLastChild();\n+                if (left.isTypeOf()) {\n+                    if (right.isString()) {\n+                        checkTypeofString(t, right, right.getString());\n+                    }\n+                } else if (right.isTypeOf() \u0026\u0026 left.isString()) {\n+                    checkTypeofString(t, left, left.getString());\n+                }\n+                leftType \u003d getJSType(left);\n+                rightType \u003d getJSType(right);\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 TernaryValue result \u003d TernaryValue.UNKNOWN;\n                 if (n.getType() \u003d\u003d Token.EQ || n.getType() \u003d\u003d Token.NE) {\n                     result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                     if (n.isNE()) {\n                         result \u003d result.not();\n                     }\n                 } else {\n                     if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                         result \u003d n.getType() \u003d\u003d Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;\n                     }\n                 }\n                 if (result !\u003d TernaryValue.UNKNOWN) {\n                     report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.LT:\n         case Token.LE:\n         case Token.GT:\n         case Token.GE:\n             leftType \u003d getJSType(n.getFirstChild());\n             rightType \u003d getJSType(n.getLastChild());\n             if (rightType.isNumber()) {\n                 validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n             } else if (leftType.isNumber()) {\n                 validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n             } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n             } else {\n                 String message \u003d \"left side of comparison\";\n                 validator.expectString(t, n, leftType, message);\n                 validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                 message \u003d \"right side of comparison\";\n                 validator.expectString(t, n, rightType, message);\n                 validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.IN:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right);\n             validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n             validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.INSTANCEOF:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n             validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n             validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.ASSIGN:\n             visitAssign(t, n);\n             typeable \u003d false;\n             break;\n         case Token.ASSIGN_LSH:\n         case Token.ASSIGN_RSH:\n         case Token.ASSIGN_URSH:\n         case Token.ASSIGN_DIV:\n         case Token.ASSIGN_MOD:\n         case Token.ASSIGN_BITOR:\n         case Token.ASSIGN_BITXOR:\n         case Token.ASSIGN_BITAND:\n         case Token.ASSIGN_SUB:\n         case Token.ASSIGN_ADD:\n         case Token.ASSIGN_MUL:\n         case Token.LSH:\n         case Token.RSH:\n         case Token.URSH:\n         case Token.DIV:\n         case Token.MOD:\n         case Token.BITOR:\n         case Token.BITXOR:\n         case Token.BITAND:\n         case Token.SUB:\n         case Token.ADD:\n         case Token.MUL:\n             visitBinaryOperator(n.getType(), t, n);\n             break;\n         case Token.DELPROP:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.CASE:\n             JSType switchType \u003d getJSType(parent.getFirstChild());\n             JSType caseType \u003d getJSType(n.getFirstChild());\n             validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n             typeable \u003d false;\n             break;\n         case Token.WITH:\n             {\n                 Node child \u003d n.getFirstChild();\n                 childType \u003d getJSType(child);\n                 validator.expectObject(t, child, childType, \"with requires an object\");\n                 typeable \u003d false;\n                 break;\n             }\n         case Token.FUNCTION:\n             visitFunction(t, n);\n             break;\n         case Token.LABEL:\n         case Token.LABEL_NAME:\n         case Token.SWITCH:\n         case Token.BREAK:\n         case Token.CATCH:\n         case Token.TRY:\n         case Token.SCRIPT:\n         case Token.EXPR_RESULT:\n         case Token.BLOCK:\n         case Token.EMPTY:\n         case Token.DEFAULT_CASE:\n         case Token.CONTINUE:\n         case Token.DEBUGGER:\n         case Token.THROW:\n             typeable \u003d false;\n             break;\n         case Token.DO:\n         case Token.FOR:\n         case Token.IF:\n         case Token.WHILE:\n             typeable \u003d false;\n             break;\n         case Token.AND:\n         case Token.HOOK:\n         case Token.OBJECTLIT:\n         case Token.OR:\n             if (n.getJSType() !\u003d null) {\n                 ensureTyped(t, n);\n             } else {\n                 if ((n.isObjectLit()) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                     ensureTyped(t, n, parent.getJSType());\n                 } else {\n                     ensureTyped(t, n);\n                 }\n             }\n             if (n.isObjectLit()) {\n                 for (Node key : n.children()) {\n                     visitObjLitKey(t, key, n);\n                 }\n             }\n             break;\n         default:\n             report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n             ensureTyped(t, n);\n             break;\n     }\n     typeable \u003d typeable \u0026\u0026 !inExterns;\n     if (typeable) {\n         doPercentTypedAccounting(t, n);\n     }\n     checkNoTypeCheckSection(n, false);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "23a670113ef854291ae5e3d7209657d372fefd8e": {
      "type": "Ybodychange",
      "commitMessage": "\nFix type checking for the \u003d\u003d\u003d and !\u003d\u003d relationship.\ntry #2, papering over some bugs in the inf() relation on function types\n\nR\u003djohnlenz\nDELTA\u003d100  (72 added, 18 deleted, 10 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d4938\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2019 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "6/4/12, 11:45 AM",
      "commitName": "23a670113ef854291ae5e3d7209657d372fefd8e",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "6/1/12, 3:23 PM",
      "commitNameOld": "9f0375c73c77ef134000d980a32f46f6085db042",
      "commitAuthorOld": "tjblasi@google.com",
      "daysBetweenCommits": 2.85,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    boolean typeable \u003d true;\n    switch(n.getType()) {\n        case Token.NAME:\n            typeable \u003d visitName(t, n, parent);\n            break;\n        case Token.PARAM_LIST:\n            if (!parent.isFunction()) {\n                ensureTyped(t, n, getJSType(n.getFirstChild()));\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.COMMA:\n            ensureTyped(t, n, getJSType(n.getLastChild()));\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.THIS:\n            ensureTyped(t, n, t.getScope().getTypeOfThis());\n            break;\n        case Token.NULL:\n            ensureTyped(t, n, NULL_TYPE);\n            break;\n        case Token.NUMBER:\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.STRING:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.STRING_KEY:\n            typeable \u003d false;\n            break;\n        case Token.GETTER_DEF:\n        case Token.SETTER_DEF:\n            break;\n        case Token.ARRAYLIT:\n            ensureTyped(t, n, ARRAY_TYPE);\n            break;\n        case Token.REGEXP:\n            ensureTyped(t, n, REGEXP_TYPE);\n            break;\n        case Token.GETPROP:\n            visitGetProp(t, n, parent);\n            typeable \u003d !(parent.isAssign() \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n            break;\n        case Token.GETELEM:\n            visitGetElem(t, n);\n            typeable \u003d false;\n            break;\n        case Token.VAR:\n            visitVar(t, n);\n            typeable \u003d false;\n            break;\n        case Token.NEW:\n            visitNew(t, n);\n            typeable \u003d true;\n            break;\n        case Token.CALL:\n            visitCall(t, n);\n            typeable \u003d !parent.isExprResult();\n            break;\n        case Token.RETURN:\n            visitReturn(t, n);\n            typeable \u003d false;\n            break;\n        case Token.DEC:\n        case Token.INC:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.NOT:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.VOID:\n            ensureTyped(t, n, VOID_TYPE);\n            break;\n        case Token.TYPEOF:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.BITNOT:\n            childType \u003d getJSType(n.getFirstChild());\n            if (!childType.matchesInt32Context()) {\n                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n            }\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.EQ:\n        case Token.NE:\n        case Token.SHEQ:\n        case Token.SHNE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                TernaryValue result \u003d TernaryValue.UNKNOWN;\n                if (n.getType() \u003d\u003d Token.EQ || n.getType() \u003d\u003d Token.NE) {\n                    result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                    if (n.isNE()) {\n                        result \u003d result.not();\n                    }\n                } else {\n                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                        result \u003d n.getType() \u003d\u003d Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;\n                    }\n                }\n                if (result !\u003d TernaryValue.UNKNOWN) {\n                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n            leftType \u003d getJSType(n.getFirstChild());\n            rightType \u003d getJSType(n.getLastChild());\n            if (rightType.isNumber()) {\n                validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n            } else if (leftType.isNumber()) {\n                validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n            } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n            } else {\n                String message \u003d \"left side of comparison\";\n                validator.expectString(t, n, leftType, message);\n                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                message \u003d \"right side of comparison\";\n                validator.expectString(t, n, rightType, message);\n                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.IN:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right);\n            validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n            validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.INSTANCEOF:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n            validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n            validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.ASSIGN:\n            visitAssign(t, n);\n            typeable \u003d false;\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.ASSIGN_URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_SUB:\n        case Token.ASSIGN_ADD:\n        case Token.ASSIGN_MUL:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.URSH:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITOR:\n        case Token.BITXOR:\n        case Token.BITAND:\n        case Token.SUB:\n        case Token.ADD:\n        case Token.MUL:\n            visitBinaryOperator(n.getType(), t, n);\n            break;\n        case Token.DELPROP:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.CASE:\n            JSType switchType \u003d getJSType(parent.getFirstChild());\n            JSType caseType \u003d getJSType(n.getFirstChild());\n            validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n            typeable \u003d false;\n            break;\n        case Token.WITH:\n            {\n                Node child \u003d n.getFirstChild();\n                childType \u003d getJSType(child);\n                validator.expectObject(t, child, childType, \"with requires an object\");\n                typeable \u003d false;\n                break;\n            }\n        case Token.FUNCTION:\n            visitFunction(t, n);\n            break;\n        case Token.LABEL:\n        case Token.LABEL_NAME:\n        case Token.SWITCH:\n        case Token.BREAK:\n        case Token.CATCH:\n        case Token.TRY:\n        case Token.SCRIPT:\n        case Token.EXPR_RESULT:\n        case Token.BLOCK:\n        case Token.EMPTY:\n        case Token.DEFAULT_CASE:\n        case Token.CONTINUE:\n        case Token.DEBUGGER:\n        case Token.THROW:\n            typeable \u003d false;\n            break;\n        case Token.DO:\n        case Token.FOR:\n        case Token.IF:\n        case Token.WHILE:\n            typeable \u003d false;\n            break;\n        case Token.AND:\n        case Token.HOOK:\n        case Token.OBJECTLIT:\n        case Token.OR:\n            if (n.getJSType() !\u003d null) {\n                ensureTyped(t, n);\n            } else {\n                if ((n.isObjectLit()) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                    ensureTyped(t, n, parent.getJSType());\n                } else {\n                    ensureTyped(t, n);\n                }\n            }\n            if (n.isObjectLit()) {\n                for (Node key : n.children()) {\n                    visitObjLitKey(t, key, n);\n                }\n            }\n            break;\n        default:\n            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n            ensureTyped(t, n);\n            break;\n    }\n    typeable \u003d typeable \u0026\u0026 !inExterns;\n    if (typeable) {\n        doPercentTypedAccounting(t, n);\n    }\n    checkNoTypeCheckSection(n, false);\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 462,
      "functionName": "visit",
      "functionAnnotation": "@Override",
      "functionDoc": "This is the meat of the type checking.  It is basically one big switch,\nwith each case representing one type of parse tree node.  The individual\ncases are usually pretty straightforward.\n\n@param t The node traversal object that supplies context, such as the\nscope chain to use in name lookups as well as error reporting.\n@param n The node being visited.\n@param parent The parent of the node n.\n",
      "diff": "@@ -1,269 +1,265 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n     JSType childType;\n     JSType leftType, rightType;\n     Node left, right;\n     boolean typeable \u003d true;\n     switch(n.getType()) {\n         case Token.NAME:\n             typeable \u003d visitName(t, n, parent);\n             break;\n         case Token.PARAM_LIST:\n             if (!parent.isFunction()) {\n                 ensureTyped(t, n, getJSType(n.getFirstChild()));\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.COMMA:\n             ensureTyped(t, n, getJSType(n.getLastChild()));\n             break;\n         case Token.TRUE:\n         case Token.FALSE:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.THIS:\n             ensureTyped(t, n, t.getScope().getTypeOfThis());\n             break;\n         case Token.NULL:\n             ensureTyped(t, n, NULL_TYPE);\n             break;\n         case Token.NUMBER:\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.STRING:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.STRING_KEY:\n             typeable \u003d false;\n             break;\n         case Token.GETTER_DEF:\n         case Token.SETTER_DEF:\n             break;\n         case Token.ARRAYLIT:\n             ensureTyped(t, n, ARRAY_TYPE);\n             break;\n         case Token.REGEXP:\n             ensureTyped(t, n, REGEXP_TYPE);\n             break;\n         case Token.GETPROP:\n             visitGetProp(t, n, parent);\n             typeable \u003d !(parent.isAssign() \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n             break;\n         case Token.GETELEM:\n             visitGetElem(t, n);\n             typeable \u003d false;\n             break;\n         case Token.VAR:\n             visitVar(t, n);\n             typeable \u003d false;\n             break;\n         case Token.NEW:\n             visitNew(t, n);\n             typeable \u003d true;\n             break;\n         case Token.CALL:\n             visitCall(t, n);\n             typeable \u003d !parent.isExprResult();\n             break;\n         case Token.RETURN:\n             visitReturn(t, n);\n             typeable \u003d false;\n             break;\n         case Token.DEC:\n         case Token.INC:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.NOT:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.VOID:\n             ensureTyped(t, n, VOID_TYPE);\n             break;\n         case Token.TYPEOF:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.BITNOT:\n             childType \u003d getJSType(n.getFirstChild());\n             if (!childType.matchesInt32Context()) {\n                 report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n             }\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.POS:\n         case Token.NEG:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.EQ:\n         case Token.NE:\n-            {\n-                leftType \u003d getJSType(n.getFirstChild());\n-                rightType \u003d getJSType(n.getLastChild());\n-                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n-                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n-                TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n-                if (result !\u003d TernaryValue.UNKNOWN) {\n-                    if (n.isNE()) {\n-                        result \u003d result.not();\n-                    }\n-                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n-                }\n-                ensureTyped(t, n, BOOLEAN_TYPE);\n-                break;\n-            }\n         case Token.SHEQ:\n         case Token.SHNE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n-                if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n-                    report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n+                TernaryValue result \u003d TernaryValue.UNKNOWN;\n+                if (n.getType() \u003d\u003d Token.EQ || n.getType() \u003d\u003d Token.NE) {\n+                    result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n+                    if (n.isNE()) {\n+                        result \u003d result.not();\n+                    }\n+                } else {\n+                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n+                        result \u003d n.getType() \u003d\u003d Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;\n+                    }\n+                }\n+                if (result !\u003d TernaryValue.UNKNOWN) {\n+                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.LT:\n         case Token.LE:\n         case Token.GT:\n         case Token.GE:\n             leftType \u003d getJSType(n.getFirstChild());\n             rightType \u003d getJSType(n.getLastChild());\n             if (rightType.isNumber()) {\n                 validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n             } else if (leftType.isNumber()) {\n                 validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n             } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n             } else {\n                 String message \u003d \"left side of comparison\";\n                 validator.expectString(t, n, leftType, message);\n                 validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                 message \u003d \"right side of comparison\";\n                 validator.expectString(t, n, rightType, message);\n                 validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.IN:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right);\n             validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n             validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.INSTANCEOF:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n             validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n             validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.ASSIGN:\n             visitAssign(t, n);\n             typeable \u003d false;\n             break;\n         case Token.ASSIGN_LSH:\n         case Token.ASSIGN_RSH:\n         case Token.ASSIGN_URSH:\n         case Token.ASSIGN_DIV:\n         case Token.ASSIGN_MOD:\n         case Token.ASSIGN_BITOR:\n         case Token.ASSIGN_BITXOR:\n         case Token.ASSIGN_BITAND:\n         case Token.ASSIGN_SUB:\n         case Token.ASSIGN_ADD:\n         case Token.ASSIGN_MUL:\n         case Token.LSH:\n         case Token.RSH:\n         case Token.URSH:\n         case Token.DIV:\n         case Token.MOD:\n         case Token.BITOR:\n         case Token.BITXOR:\n         case Token.BITAND:\n         case Token.SUB:\n         case Token.ADD:\n         case Token.MUL:\n             visitBinaryOperator(n.getType(), t, n);\n             break;\n         case Token.DELPROP:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.CASE:\n             JSType switchType \u003d getJSType(parent.getFirstChild());\n             JSType caseType \u003d getJSType(n.getFirstChild());\n             validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n             typeable \u003d false;\n             break;\n         case Token.WITH:\n             {\n                 Node child \u003d n.getFirstChild();\n                 childType \u003d getJSType(child);\n                 validator.expectObject(t, child, childType, \"with requires an object\");\n                 typeable \u003d false;\n                 break;\n             }\n         case Token.FUNCTION:\n             visitFunction(t, n);\n             break;\n         case Token.LABEL:\n         case Token.LABEL_NAME:\n         case Token.SWITCH:\n         case Token.BREAK:\n         case Token.CATCH:\n         case Token.TRY:\n         case Token.SCRIPT:\n         case Token.EXPR_RESULT:\n         case Token.BLOCK:\n         case Token.EMPTY:\n         case Token.DEFAULT_CASE:\n         case Token.CONTINUE:\n         case Token.DEBUGGER:\n         case Token.THROW:\n             typeable \u003d false;\n             break;\n         case Token.DO:\n         case Token.FOR:\n         case Token.IF:\n         case Token.WHILE:\n             typeable \u003d false;\n             break;\n         case Token.AND:\n         case Token.HOOK:\n         case Token.OBJECTLIT:\n         case Token.OR:\n             if (n.getJSType() !\u003d null) {\n                 ensureTyped(t, n);\n             } else {\n                 if ((n.isObjectLit()) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                     ensureTyped(t, n, parent.getJSType());\n                 } else {\n                     ensureTyped(t, n);\n                 }\n             }\n             if (n.isObjectLit()) {\n                 for (Node key : n.children()) {\n                     visitObjLitKey(t, key, n);\n                 }\n             }\n             break;\n         default:\n             report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n             ensureTyped(t, n);\n             break;\n     }\n     typeable \u003d typeable \u0026\u0026 !inExterns;\n     if (typeable) {\n         doPercentTypedAccounting(t, n);\n     }\n     checkNoTypeCheckSection(n, false);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9f0375c73c77ef134000d980a32f46f6085db042": {
      "type": "Ybodychange",
      "commitMessage": "\nAutomated g4 rollback \n\n*** Reason for rollback ***\n\nBreaks some tests\n\n*** Original change description ***\n\nFix type checking for the \u003d\u003d\u003d and !\u003d\u003d relationship.\n\nR\u003djohnlenz\nDELTA\u003d70  (18 added, 42 deleted, 10 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d4927\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2013 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "6/1/12, 3:23 PM",
      "commitName": "9f0375c73c77ef134000d980a32f46f6085db042",
      "commitAuthor": "tjblasi@google.com",
      "commitDateOld": "6/1/12, 1:45 PM",
      "commitNameOld": "cd25d5c37ab839090a74c2ed49f924e22de13057",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 0.07,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    boolean typeable \u003d true;\n    switch(n.getType()) {\n        case Token.NAME:\n            typeable \u003d visitName(t, n, parent);\n            break;\n        case Token.PARAM_LIST:\n            if (!parent.isFunction()) {\n                ensureTyped(t, n, getJSType(n.getFirstChild()));\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.COMMA:\n            ensureTyped(t, n, getJSType(n.getLastChild()));\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.THIS:\n            ensureTyped(t, n, t.getScope().getTypeOfThis());\n            break;\n        case Token.NULL:\n            ensureTyped(t, n, NULL_TYPE);\n            break;\n        case Token.NUMBER:\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.STRING:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.STRING_KEY:\n            typeable \u003d false;\n            break;\n        case Token.GETTER_DEF:\n        case Token.SETTER_DEF:\n            break;\n        case Token.ARRAYLIT:\n            ensureTyped(t, n, ARRAY_TYPE);\n            break;\n        case Token.REGEXP:\n            ensureTyped(t, n, REGEXP_TYPE);\n            break;\n        case Token.GETPROP:\n            visitGetProp(t, n, parent);\n            typeable \u003d !(parent.isAssign() \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n            break;\n        case Token.GETELEM:\n            visitGetElem(t, n);\n            typeable \u003d false;\n            break;\n        case Token.VAR:\n            visitVar(t, n);\n            typeable \u003d false;\n            break;\n        case Token.NEW:\n            visitNew(t, n);\n            typeable \u003d true;\n            break;\n        case Token.CALL:\n            visitCall(t, n);\n            typeable \u003d !parent.isExprResult();\n            break;\n        case Token.RETURN:\n            visitReturn(t, n);\n            typeable \u003d false;\n            break;\n        case Token.DEC:\n        case Token.INC:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.NOT:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.VOID:\n            ensureTyped(t, n, VOID_TYPE);\n            break;\n        case Token.TYPEOF:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.BITNOT:\n            childType \u003d getJSType(n.getFirstChild());\n            if (!childType.matchesInt32Context()) {\n                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n            }\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.EQ:\n        case Token.NE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                if (result !\u003d TernaryValue.UNKNOWN) {\n                    if (n.isNE()) {\n                        result \u003d result.not();\n                    }\n                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.SHEQ:\n        case Token.SHNE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                    report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n            leftType \u003d getJSType(n.getFirstChild());\n            rightType \u003d getJSType(n.getLastChild());\n            if (rightType.isNumber()) {\n                validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n            } else if (leftType.isNumber()) {\n                validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n            } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n            } else {\n                String message \u003d \"left side of comparison\";\n                validator.expectString(t, n, leftType, message);\n                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                message \u003d \"right side of comparison\";\n                validator.expectString(t, n, rightType, message);\n                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.IN:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right);\n            validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n            validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.INSTANCEOF:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n            validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n            validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.ASSIGN:\n            visitAssign(t, n);\n            typeable \u003d false;\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.ASSIGN_URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_SUB:\n        case Token.ASSIGN_ADD:\n        case Token.ASSIGN_MUL:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.URSH:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITOR:\n        case Token.BITXOR:\n        case Token.BITAND:\n        case Token.SUB:\n        case Token.ADD:\n        case Token.MUL:\n            visitBinaryOperator(n.getType(), t, n);\n            break;\n        case Token.DELPROP:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.CASE:\n            JSType switchType \u003d getJSType(parent.getFirstChild());\n            JSType caseType \u003d getJSType(n.getFirstChild());\n            validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n            typeable \u003d false;\n            break;\n        case Token.WITH:\n            {\n                Node child \u003d n.getFirstChild();\n                childType \u003d getJSType(child);\n                validator.expectObject(t, child, childType, \"with requires an object\");\n                typeable \u003d false;\n                break;\n            }\n        case Token.FUNCTION:\n            visitFunction(t, n);\n            break;\n        case Token.LABEL:\n        case Token.LABEL_NAME:\n        case Token.SWITCH:\n        case Token.BREAK:\n        case Token.CATCH:\n        case Token.TRY:\n        case Token.SCRIPT:\n        case Token.EXPR_RESULT:\n        case Token.BLOCK:\n        case Token.EMPTY:\n        case Token.DEFAULT_CASE:\n        case Token.CONTINUE:\n        case Token.DEBUGGER:\n        case Token.THROW:\n            typeable \u003d false;\n            break;\n        case Token.DO:\n        case Token.FOR:\n        case Token.IF:\n        case Token.WHILE:\n            typeable \u003d false;\n            break;\n        case Token.AND:\n        case Token.HOOK:\n        case Token.OBJECTLIT:\n        case Token.OR:\n            if (n.getJSType() !\u003d null) {\n                ensureTyped(t, n);\n            } else {\n                if ((n.isObjectLit()) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                    ensureTyped(t, n, parent.getJSType());\n                } else {\n                    ensureTyped(t, n);\n                }\n            }\n            if (n.isObjectLit()) {\n                for (Node key : n.children()) {\n                    visitObjLitKey(t, key, n);\n                }\n            }\n            break;\n        default:\n            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n            ensureTyped(t, n);\n            break;\n    }\n    typeable \u003d typeable \u0026\u0026 !inExterns;\n    if (typeable) {\n        doPercentTypedAccounting(t, n);\n    }\n    checkNoTypeCheckSection(n, false);\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 462,
      "functionName": "visit",
      "functionAnnotation": "@Override",
      "functionDoc": "This is the meat of the type checking.  It is basically one big switch,\nwith each case representing one type of parse tree node.  The individual\ncases are usually pretty straightforward.\n\n@param t The node traversal object that supplies context, such as the\nscope chain to use in name lookups as well as error reporting.\n@param n The node being visited.\n@param parent The parent of the node n.\n",
      "diff": "@@ -1,265 +1,269 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n     JSType childType;\n     JSType leftType, rightType;\n     Node left, right;\n     boolean typeable \u003d true;\n     switch(n.getType()) {\n         case Token.NAME:\n             typeable \u003d visitName(t, n, parent);\n             break;\n         case Token.PARAM_LIST:\n             if (!parent.isFunction()) {\n                 ensureTyped(t, n, getJSType(n.getFirstChild()));\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.COMMA:\n             ensureTyped(t, n, getJSType(n.getLastChild()));\n             break;\n         case Token.TRUE:\n         case Token.FALSE:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.THIS:\n             ensureTyped(t, n, t.getScope().getTypeOfThis());\n             break;\n         case Token.NULL:\n             ensureTyped(t, n, NULL_TYPE);\n             break;\n         case Token.NUMBER:\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.STRING:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.STRING_KEY:\n             typeable \u003d false;\n             break;\n         case Token.GETTER_DEF:\n         case Token.SETTER_DEF:\n             break;\n         case Token.ARRAYLIT:\n             ensureTyped(t, n, ARRAY_TYPE);\n             break;\n         case Token.REGEXP:\n             ensureTyped(t, n, REGEXP_TYPE);\n             break;\n         case Token.GETPROP:\n             visitGetProp(t, n, parent);\n             typeable \u003d !(parent.isAssign() \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n             break;\n         case Token.GETELEM:\n             visitGetElem(t, n);\n             typeable \u003d false;\n             break;\n         case Token.VAR:\n             visitVar(t, n);\n             typeable \u003d false;\n             break;\n         case Token.NEW:\n             visitNew(t, n);\n             typeable \u003d true;\n             break;\n         case Token.CALL:\n             visitCall(t, n);\n             typeable \u003d !parent.isExprResult();\n             break;\n         case Token.RETURN:\n             visitReturn(t, n);\n             typeable \u003d false;\n             break;\n         case Token.DEC:\n         case Token.INC:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.NOT:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.VOID:\n             ensureTyped(t, n, VOID_TYPE);\n             break;\n         case Token.TYPEOF:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.BITNOT:\n             childType \u003d getJSType(n.getFirstChild());\n             if (!childType.matchesInt32Context()) {\n                 report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n             }\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.POS:\n         case Token.NEG:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.EQ:\n         case Token.NE:\n+            {\n+                leftType \u003d getJSType(n.getFirstChild());\n+                rightType \u003d getJSType(n.getLastChild());\n+                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n+                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n+                TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n+                if (result !\u003d TernaryValue.UNKNOWN) {\n+                    if (n.isNE()) {\n+                        result \u003d result.not();\n+                    }\n+                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n+                }\n+                ensureTyped(t, n, BOOLEAN_TYPE);\n+                break;\n+            }\n         case Token.SHEQ:\n         case Token.SHNE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n-                TernaryValue result \u003d TernaryValue.UNKNOWN;\n-                if (n.getType() \u003d\u003d Token.EQ || n.getType() \u003d\u003d Token.NE) {\n-                    result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n-                    if (n.isNE()) {\n-                        result \u003d result.not();\n-                    }\n-                } else {\n-                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n-                        result \u003d n.getType() \u003d\u003d Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;\n-                    }\n-                }\n-                if (result !\u003d TernaryValue.UNKNOWN) {\n-                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n+                if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n+                    report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.LT:\n         case Token.LE:\n         case Token.GT:\n         case Token.GE:\n             leftType \u003d getJSType(n.getFirstChild());\n             rightType \u003d getJSType(n.getLastChild());\n             if (rightType.isNumber()) {\n                 validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n             } else if (leftType.isNumber()) {\n                 validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n             } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n             } else {\n                 String message \u003d \"left side of comparison\";\n                 validator.expectString(t, n, leftType, message);\n                 validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                 message \u003d \"right side of comparison\";\n                 validator.expectString(t, n, rightType, message);\n                 validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.IN:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right);\n             validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n             validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.INSTANCEOF:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n             validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n             validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.ASSIGN:\n             visitAssign(t, n);\n             typeable \u003d false;\n             break;\n         case Token.ASSIGN_LSH:\n         case Token.ASSIGN_RSH:\n         case Token.ASSIGN_URSH:\n         case Token.ASSIGN_DIV:\n         case Token.ASSIGN_MOD:\n         case Token.ASSIGN_BITOR:\n         case Token.ASSIGN_BITXOR:\n         case Token.ASSIGN_BITAND:\n         case Token.ASSIGN_SUB:\n         case Token.ASSIGN_ADD:\n         case Token.ASSIGN_MUL:\n         case Token.LSH:\n         case Token.RSH:\n         case Token.URSH:\n         case Token.DIV:\n         case Token.MOD:\n         case Token.BITOR:\n         case Token.BITXOR:\n         case Token.BITAND:\n         case Token.SUB:\n         case Token.ADD:\n         case Token.MUL:\n             visitBinaryOperator(n.getType(), t, n);\n             break;\n         case Token.DELPROP:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.CASE:\n             JSType switchType \u003d getJSType(parent.getFirstChild());\n             JSType caseType \u003d getJSType(n.getFirstChild());\n             validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n             typeable \u003d false;\n             break;\n         case Token.WITH:\n             {\n                 Node child \u003d n.getFirstChild();\n                 childType \u003d getJSType(child);\n                 validator.expectObject(t, child, childType, \"with requires an object\");\n                 typeable \u003d false;\n                 break;\n             }\n         case Token.FUNCTION:\n             visitFunction(t, n);\n             break;\n         case Token.LABEL:\n         case Token.LABEL_NAME:\n         case Token.SWITCH:\n         case Token.BREAK:\n         case Token.CATCH:\n         case Token.TRY:\n         case Token.SCRIPT:\n         case Token.EXPR_RESULT:\n         case Token.BLOCK:\n         case Token.EMPTY:\n         case Token.DEFAULT_CASE:\n         case Token.CONTINUE:\n         case Token.DEBUGGER:\n         case Token.THROW:\n             typeable \u003d false;\n             break;\n         case Token.DO:\n         case Token.FOR:\n         case Token.IF:\n         case Token.WHILE:\n             typeable \u003d false;\n             break;\n         case Token.AND:\n         case Token.HOOK:\n         case Token.OBJECTLIT:\n         case Token.OR:\n             if (n.getJSType() !\u003d null) {\n                 ensureTyped(t, n);\n             } else {\n                 if ((n.isObjectLit()) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                     ensureTyped(t, n, parent.getJSType());\n                 } else {\n                     ensureTyped(t, n);\n                 }\n             }\n             if (n.isObjectLit()) {\n                 for (Node key : n.children()) {\n                     visitObjLitKey(t, key, n);\n                 }\n             }\n             break;\n         default:\n             report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n             ensureTyped(t, n);\n             break;\n     }\n     typeable \u003d typeable \u0026\u0026 !inExterns;\n     if (typeable) {\n         doPercentTypedAccounting(t, n);\n     }\n     checkNoTypeCheckSection(n, false);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "cd25d5c37ab839090a74c2ed49f924e22de13057": {
      "type": "Ybodychange",
      "commitMessage": "\nFix type checking for the \u003d\u003d\u003d and !\u003d\u003d relationship.\n\nR\u003djohnlenz\nDELTA\u003d70  (42 added, 18 deleted, 10 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d4926\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2012 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "6/1/12, 1:45 PM",
      "commitName": "cd25d5c37ab839090a74c2ed49f924e22de13057",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "5/18/12, 11:09 AM",
      "commitNameOld": "70a5626922ea7e8c98747e22b6986638ba38fadc",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 14.11,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    boolean typeable \u003d true;\n    switch(n.getType()) {\n        case Token.NAME:\n            typeable \u003d visitName(t, n, parent);\n            break;\n        case Token.PARAM_LIST:\n            if (!parent.isFunction()) {\n                ensureTyped(t, n, getJSType(n.getFirstChild()));\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.COMMA:\n            ensureTyped(t, n, getJSType(n.getLastChild()));\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.THIS:\n            ensureTyped(t, n, t.getScope().getTypeOfThis());\n            break;\n        case Token.NULL:\n            ensureTyped(t, n, NULL_TYPE);\n            break;\n        case Token.NUMBER:\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.STRING:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.STRING_KEY:\n            typeable \u003d false;\n            break;\n        case Token.GETTER_DEF:\n        case Token.SETTER_DEF:\n            break;\n        case Token.ARRAYLIT:\n            ensureTyped(t, n, ARRAY_TYPE);\n            break;\n        case Token.REGEXP:\n            ensureTyped(t, n, REGEXP_TYPE);\n            break;\n        case Token.GETPROP:\n            visitGetProp(t, n, parent);\n            typeable \u003d !(parent.isAssign() \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n            break;\n        case Token.GETELEM:\n            visitGetElem(t, n);\n            typeable \u003d false;\n            break;\n        case Token.VAR:\n            visitVar(t, n);\n            typeable \u003d false;\n            break;\n        case Token.NEW:\n            visitNew(t, n);\n            typeable \u003d true;\n            break;\n        case Token.CALL:\n            visitCall(t, n);\n            typeable \u003d !parent.isExprResult();\n            break;\n        case Token.RETURN:\n            visitReturn(t, n);\n            typeable \u003d false;\n            break;\n        case Token.DEC:\n        case Token.INC:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.NOT:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.VOID:\n            ensureTyped(t, n, VOID_TYPE);\n            break;\n        case Token.TYPEOF:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.BITNOT:\n            childType \u003d getJSType(n.getFirstChild());\n            if (!childType.matchesInt32Context()) {\n                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n            }\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.EQ:\n        case Token.NE:\n        case Token.SHEQ:\n        case Token.SHNE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                TernaryValue result \u003d TernaryValue.UNKNOWN;\n                if (n.getType() \u003d\u003d Token.EQ || n.getType() \u003d\u003d Token.NE) {\n                    result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                    if (n.isNE()) {\n                        result \u003d result.not();\n                    }\n                } else {\n                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                        result \u003d n.getType() \u003d\u003d Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;\n                    }\n                }\n                if (result !\u003d TernaryValue.UNKNOWN) {\n                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n            leftType \u003d getJSType(n.getFirstChild());\n            rightType \u003d getJSType(n.getLastChild());\n            if (rightType.isNumber()) {\n                validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n            } else if (leftType.isNumber()) {\n                validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n            } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n            } else {\n                String message \u003d \"left side of comparison\";\n                validator.expectString(t, n, leftType, message);\n                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                message \u003d \"right side of comparison\";\n                validator.expectString(t, n, rightType, message);\n                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.IN:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right);\n            validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n            validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.INSTANCEOF:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n            validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n            validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.ASSIGN:\n            visitAssign(t, n);\n            typeable \u003d false;\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.ASSIGN_URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_SUB:\n        case Token.ASSIGN_ADD:\n        case Token.ASSIGN_MUL:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.URSH:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITOR:\n        case Token.BITXOR:\n        case Token.BITAND:\n        case Token.SUB:\n        case Token.ADD:\n        case Token.MUL:\n            visitBinaryOperator(n.getType(), t, n);\n            break;\n        case Token.DELPROP:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.CASE:\n            JSType switchType \u003d getJSType(parent.getFirstChild());\n            JSType caseType \u003d getJSType(n.getFirstChild());\n            validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n            typeable \u003d false;\n            break;\n        case Token.WITH:\n            {\n                Node child \u003d n.getFirstChild();\n                childType \u003d getJSType(child);\n                validator.expectObject(t, child, childType, \"with requires an object\");\n                typeable \u003d false;\n                break;\n            }\n        case Token.FUNCTION:\n            visitFunction(t, n);\n            break;\n        case Token.LABEL:\n        case Token.LABEL_NAME:\n        case Token.SWITCH:\n        case Token.BREAK:\n        case Token.CATCH:\n        case Token.TRY:\n        case Token.SCRIPT:\n        case Token.EXPR_RESULT:\n        case Token.BLOCK:\n        case Token.EMPTY:\n        case Token.DEFAULT_CASE:\n        case Token.CONTINUE:\n        case Token.DEBUGGER:\n        case Token.THROW:\n            typeable \u003d false;\n            break;\n        case Token.DO:\n        case Token.FOR:\n        case Token.IF:\n        case Token.WHILE:\n            typeable \u003d false;\n            break;\n        case Token.AND:\n        case Token.HOOK:\n        case Token.OBJECTLIT:\n        case Token.OR:\n            if (n.getJSType() !\u003d null) {\n                ensureTyped(t, n);\n            } else {\n                if ((n.isObjectLit()) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                    ensureTyped(t, n, parent.getJSType());\n                } else {\n                    ensureTyped(t, n);\n                }\n            }\n            if (n.isObjectLit()) {\n                for (Node key : n.children()) {\n                    visitObjLitKey(t, key, n);\n                }\n            }\n            break;\n        default:\n            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n            ensureTyped(t, n);\n            break;\n    }\n    typeable \u003d typeable \u0026\u0026 !inExterns;\n    if (typeable) {\n        doPercentTypedAccounting(t, n);\n    }\n    checkNoTypeCheckSection(n, false);\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 462,
      "functionName": "visit",
      "functionAnnotation": "@Override",
      "functionDoc": "This is the meat of the type checking.  It is basically one big switch,\nwith each case representing one type of parse tree node.  The individual\ncases are usually pretty straightforward.\n\n@param t The node traversal object that supplies context, such as the\nscope chain to use in name lookups as well as error reporting.\n@param n The node being visited.\n@param parent The parent of the node n.\n",
      "diff": "@@ -1,269 +1,265 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n     JSType childType;\n     JSType leftType, rightType;\n     Node left, right;\n     boolean typeable \u003d true;\n     switch(n.getType()) {\n         case Token.NAME:\n             typeable \u003d visitName(t, n, parent);\n             break;\n         case Token.PARAM_LIST:\n             if (!parent.isFunction()) {\n                 ensureTyped(t, n, getJSType(n.getFirstChild()));\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.COMMA:\n             ensureTyped(t, n, getJSType(n.getLastChild()));\n             break;\n         case Token.TRUE:\n         case Token.FALSE:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.THIS:\n             ensureTyped(t, n, t.getScope().getTypeOfThis());\n             break;\n         case Token.NULL:\n             ensureTyped(t, n, NULL_TYPE);\n             break;\n         case Token.NUMBER:\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.STRING:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.STRING_KEY:\n             typeable \u003d false;\n             break;\n         case Token.GETTER_DEF:\n         case Token.SETTER_DEF:\n             break;\n         case Token.ARRAYLIT:\n             ensureTyped(t, n, ARRAY_TYPE);\n             break;\n         case Token.REGEXP:\n             ensureTyped(t, n, REGEXP_TYPE);\n             break;\n         case Token.GETPROP:\n             visitGetProp(t, n, parent);\n             typeable \u003d !(parent.isAssign() \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n             break;\n         case Token.GETELEM:\n             visitGetElem(t, n);\n             typeable \u003d false;\n             break;\n         case Token.VAR:\n             visitVar(t, n);\n             typeable \u003d false;\n             break;\n         case Token.NEW:\n             visitNew(t, n);\n             typeable \u003d true;\n             break;\n         case Token.CALL:\n             visitCall(t, n);\n             typeable \u003d !parent.isExprResult();\n             break;\n         case Token.RETURN:\n             visitReturn(t, n);\n             typeable \u003d false;\n             break;\n         case Token.DEC:\n         case Token.INC:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.NOT:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.VOID:\n             ensureTyped(t, n, VOID_TYPE);\n             break;\n         case Token.TYPEOF:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.BITNOT:\n             childType \u003d getJSType(n.getFirstChild());\n             if (!childType.matchesInt32Context()) {\n                 report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n             }\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.POS:\n         case Token.NEG:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.EQ:\n         case Token.NE:\n-            {\n-                leftType \u003d getJSType(n.getFirstChild());\n-                rightType \u003d getJSType(n.getLastChild());\n-                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n-                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n-                TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n-                if (result !\u003d TernaryValue.UNKNOWN) {\n-                    if (n.isNE()) {\n-                        result \u003d result.not();\n-                    }\n-                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n-                }\n-                ensureTyped(t, n, BOOLEAN_TYPE);\n-                break;\n-            }\n         case Token.SHEQ:\n         case Token.SHNE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n-                if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n-                    report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n+                TernaryValue result \u003d TernaryValue.UNKNOWN;\n+                if (n.getType() \u003d\u003d Token.EQ || n.getType() \u003d\u003d Token.NE) {\n+                    result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n+                    if (n.isNE()) {\n+                        result \u003d result.not();\n+                    }\n+                } else {\n+                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n+                        result \u003d n.getType() \u003d\u003d Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;\n+                    }\n+                }\n+                if (result !\u003d TernaryValue.UNKNOWN) {\n+                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.LT:\n         case Token.LE:\n         case Token.GT:\n         case Token.GE:\n             leftType \u003d getJSType(n.getFirstChild());\n             rightType \u003d getJSType(n.getLastChild());\n             if (rightType.isNumber()) {\n                 validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n             } else if (leftType.isNumber()) {\n                 validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n             } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n             } else {\n                 String message \u003d \"left side of comparison\";\n                 validator.expectString(t, n, leftType, message);\n                 validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                 message \u003d \"right side of comparison\";\n                 validator.expectString(t, n, rightType, message);\n                 validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.IN:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right);\n             validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n             validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.INSTANCEOF:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n             validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n             validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.ASSIGN:\n             visitAssign(t, n);\n             typeable \u003d false;\n             break;\n         case Token.ASSIGN_LSH:\n         case Token.ASSIGN_RSH:\n         case Token.ASSIGN_URSH:\n         case Token.ASSIGN_DIV:\n         case Token.ASSIGN_MOD:\n         case Token.ASSIGN_BITOR:\n         case Token.ASSIGN_BITXOR:\n         case Token.ASSIGN_BITAND:\n         case Token.ASSIGN_SUB:\n         case Token.ASSIGN_ADD:\n         case Token.ASSIGN_MUL:\n         case Token.LSH:\n         case Token.RSH:\n         case Token.URSH:\n         case Token.DIV:\n         case Token.MOD:\n         case Token.BITOR:\n         case Token.BITXOR:\n         case Token.BITAND:\n         case Token.SUB:\n         case Token.ADD:\n         case Token.MUL:\n             visitBinaryOperator(n.getType(), t, n);\n             break;\n         case Token.DELPROP:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.CASE:\n             JSType switchType \u003d getJSType(parent.getFirstChild());\n             JSType caseType \u003d getJSType(n.getFirstChild());\n             validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n             typeable \u003d false;\n             break;\n         case Token.WITH:\n             {\n                 Node child \u003d n.getFirstChild();\n                 childType \u003d getJSType(child);\n                 validator.expectObject(t, child, childType, \"with requires an object\");\n                 typeable \u003d false;\n                 break;\n             }\n         case Token.FUNCTION:\n             visitFunction(t, n);\n             break;\n         case Token.LABEL:\n         case Token.LABEL_NAME:\n         case Token.SWITCH:\n         case Token.BREAK:\n         case Token.CATCH:\n         case Token.TRY:\n         case Token.SCRIPT:\n         case Token.EXPR_RESULT:\n         case Token.BLOCK:\n         case Token.EMPTY:\n         case Token.DEFAULT_CASE:\n         case Token.CONTINUE:\n         case Token.DEBUGGER:\n         case Token.THROW:\n             typeable \u003d false;\n             break;\n         case Token.DO:\n         case Token.FOR:\n         case Token.IF:\n         case Token.WHILE:\n             typeable \u003d false;\n             break;\n         case Token.AND:\n         case Token.HOOK:\n         case Token.OBJECTLIT:\n         case Token.OR:\n             if (n.getJSType() !\u003d null) {\n                 ensureTyped(t, n);\n             } else {\n                 if ((n.isObjectLit()) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                     ensureTyped(t, n, parent.getJSType());\n                 } else {\n                     ensureTyped(t, n);\n                 }\n             }\n             if (n.isObjectLit()) {\n                 for (Node key : n.children()) {\n                     visitObjLitKey(t, key, n);\n                 }\n             }\n             break;\n         default:\n             report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n             ensureTyped(t, n);\n             break;\n     }\n     typeable \u003d typeable \u0026\u0026 !inExterns;\n     if (typeable) {\n         doPercentTypedAccounting(t, n);\n     }\n     checkNoTypeCheckSection(n, false);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f412f0c0efd54842b30207c845d65cb826217fd6": {
      "type": "Ybodychange",
      "commitMessage": "\nCreate a separate token for object literal keys.\ni was surprised how easy this was\n\nR\u003dacleung,johnlenz\nDELTA\u003d139  (52 added, 26 deleted, 61 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d4618\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1922 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/25/12, 1:34 PM",
      "commitName": "f412f0c0efd54842b30207c845d65cb826217fd6",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "4/3/12, 5:11 PM",
      "commitNameOld": "06c4d2f84718b7ad601a1429420d000911192d80",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 21.85,
      "commitsBetweenForRepo": 48,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    boolean typeable \u003d true;\n    switch(n.getType()) {\n        case Token.NAME:\n            typeable \u003d visitName(t, n, parent);\n            break;\n        case Token.PARAM_LIST:\n            if (!parent.isFunction()) {\n                ensureTyped(t, n, getJSType(n.getFirstChild()));\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.COMMA:\n            ensureTyped(t, n, getJSType(n.getLastChild()));\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.THIS:\n            ensureTyped(t, n, t.getScope().getTypeOfThis());\n            break;\n        case Token.NULL:\n            ensureTyped(t, n, NULL_TYPE);\n            break;\n        case Token.NUMBER:\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.STRING:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.STRING_KEY:\n            typeable \u003d false;\n            break;\n        case Token.GETTER_DEF:\n        case Token.SETTER_DEF:\n            break;\n        case Token.ARRAYLIT:\n            ensureTyped(t, n, ARRAY_TYPE);\n            break;\n        case Token.REGEXP:\n            ensureTyped(t, n, REGEXP_TYPE);\n            break;\n        case Token.GETPROP:\n            visitGetProp(t, n, parent);\n            typeable \u003d !(parent.isAssign() \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n            break;\n        case Token.GETELEM:\n            visitGetElem(t, n);\n            typeable \u003d false;\n            break;\n        case Token.VAR:\n            visitVar(t, n);\n            typeable \u003d false;\n            break;\n        case Token.NEW:\n            visitNew(t, n);\n            typeable \u003d true;\n            break;\n        case Token.CALL:\n            visitCall(t, n);\n            typeable \u003d !parent.isExprResult();\n            break;\n        case Token.RETURN:\n            visitReturn(t, n);\n            typeable \u003d false;\n            break;\n        case Token.DEC:\n        case Token.INC:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.NOT:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.VOID:\n            ensureTyped(t, n, VOID_TYPE);\n            break;\n        case Token.TYPEOF:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.BITNOT:\n            childType \u003d getJSType(n.getFirstChild());\n            if (!childType.matchesInt32Context()) {\n                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n            }\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.EQ:\n        case Token.NE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                if (result !\u003d TernaryValue.UNKNOWN) {\n                    if (n.isNE()) {\n                        result \u003d result.not();\n                    }\n                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.SHEQ:\n        case Token.SHNE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                    report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n            leftType \u003d getJSType(n.getFirstChild());\n            rightType \u003d getJSType(n.getLastChild());\n            if (rightType.isNumber()) {\n                validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n            } else if (leftType.isNumber()) {\n                validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n            } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n            } else {\n                String message \u003d \"left side of comparison\";\n                validator.expectString(t, n, leftType, message);\n                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                message \u003d \"right side of comparison\";\n                validator.expectString(t, n, rightType, message);\n                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.IN:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right);\n            validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n            validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.INSTANCEOF:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n            validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n            validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.ASSIGN:\n            visitAssign(t, n);\n            typeable \u003d false;\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.ASSIGN_URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_SUB:\n        case Token.ASSIGN_ADD:\n        case Token.ASSIGN_MUL:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.URSH:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITOR:\n        case Token.BITXOR:\n        case Token.BITAND:\n        case Token.SUB:\n        case Token.ADD:\n        case Token.MUL:\n            visitBinaryOperator(n.getType(), t, n);\n            break;\n        case Token.DELPROP:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.CASE:\n            JSType switchType \u003d getJSType(parent.getFirstChild());\n            JSType caseType \u003d getJSType(n.getFirstChild());\n            validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n            typeable \u003d false;\n            break;\n        case Token.WITH:\n            {\n                Node child \u003d n.getFirstChild();\n                childType \u003d getJSType(child);\n                validator.expectObject(t, child, childType, \"with requires an object\");\n                typeable \u003d false;\n                break;\n            }\n        case Token.FUNCTION:\n            visitFunction(t, n);\n            break;\n        case Token.LABEL:\n        case Token.LABEL_NAME:\n        case Token.SWITCH:\n        case Token.BREAK:\n        case Token.CATCH:\n        case Token.TRY:\n        case Token.SCRIPT:\n        case Token.EXPR_RESULT:\n        case Token.BLOCK:\n        case Token.EMPTY:\n        case Token.DEFAULT_CASE:\n        case Token.CONTINUE:\n        case Token.DEBUGGER:\n        case Token.THROW:\n            typeable \u003d false;\n            break;\n        case Token.DO:\n        case Token.FOR:\n        case Token.IF:\n        case Token.WHILE:\n            typeable \u003d false;\n            break;\n        case Token.AND:\n        case Token.HOOK:\n        case Token.OBJECTLIT:\n        case Token.OR:\n            if (n.getJSType() !\u003d null) {\n                ensureTyped(t, n);\n            } else {\n                if ((n.isObjectLit()) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                    ensureTyped(t, n, parent.getJSType());\n                } else {\n                    ensureTyped(t, n);\n                }\n            }\n            if (n.isObjectLit()) {\n                for (Node key : n.children()) {\n                    visitObjLitKey(t, key, n);\n                }\n            }\n            break;\n        default:\n            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n            ensureTyped(t, n);\n            break;\n    }\n    typeable \u003d typeable \u0026\u0026 !inExterns;\n    if (typeable) {\n        doPercentTypedAccounting(t, n);\n    }\n    checkNoTypeCheckSection(n, false);\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 462,
      "functionName": "visit",
      "functionAnnotation": "@Override",
      "functionDoc": "This is the meat of the type checking.  It is basically one big switch,\nwith each case representing one type of parse tree node.  The individual\ncases are usually pretty straightforward.\n\n@param t The node traversal object that supplies context, such as the\nscope chain to use in name lookups as well as error reporting.\n@param n The node being visited.\n@param parent The parent of the node n.\n",
      "diff": "@@ -1,270 +1,269 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n     JSType childType;\n     JSType leftType, rightType;\n     Node left, right;\n     boolean typeable \u003d true;\n     switch(n.getType()) {\n         case Token.NAME:\n             typeable \u003d visitName(t, n, parent);\n             break;\n         case Token.PARAM_LIST:\n             if (!parent.isFunction()) {\n                 ensureTyped(t, n, getJSType(n.getFirstChild()));\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.COMMA:\n             ensureTyped(t, n, getJSType(n.getLastChild()));\n             break;\n         case Token.TRUE:\n         case Token.FALSE:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.THIS:\n             ensureTyped(t, n, t.getScope().getTypeOfThis());\n             break;\n         case Token.NULL:\n             ensureTyped(t, n, NULL_TYPE);\n             break;\n         case Token.NUMBER:\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.STRING:\n-            if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n-                ensureTyped(t, n, STRING_TYPE);\n-            } else {\n-                typeable \u003d false;\n-            }\n+            ensureTyped(t, n, STRING_TYPE);\n+            break;\n+        case Token.STRING_KEY:\n+            typeable \u003d false;\n             break;\n         case Token.GETTER_DEF:\n         case Token.SETTER_DEF:\n             break;\n         case Token.ARRAYLIT:\n             ensureTyped(t, n, ARRAY_TYPE);\n             break;\n         case Token.REGEXP:\n             ensureTyped(t, n, REGEXP_TYPE);\n             break;\n         case Token.GETPROP:\n             visitGetProp(t, n, parent);\n             typeable \u003d !(parent.isAssign() \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n             break;\n         case Token.GETELEM:\n             visitGetElem(t, n);\n             typeable \u003d false;\n             break;\n         case Token.VAR:\n             visitVar(t, n);\n             typeable \u003d false;\n             break;\n         case Token.NEW:\n             visitNew(t, n);\n             typeable \u003d true;\n             break;\n         case Token.CALL:\n             visitCall(t, n);\n             typeable \u003d !parent.isExprResult();\n             break;\n         case Token.RETURN:\n             visitReturn(t, n);\n             typeable \u003d false;\n             break;\n         case Token.DEC:\n         case Token.INC:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.NOT:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.VOID:\n             ensureTyped(t, n, VOID_TYPE);\n             break;\n         case Token.TYPEOF:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.BITNOT:\n             childType \u003d getJSType(n.getFirstChild());\n             if (!childType.matchesInt32Context()) {\n                 report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n             }\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.POS:\n         case Token.NEG:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.EQ:\n         case Token.NE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                 if (result !\u003d TernaryValue.UNKNOWN) {\n                     if (n.isNE()) {\n                         result \u003d result.not();\n                     }\n                     report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.SHEQ:\n         case Token.SHNE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                     report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.LT:\n         case Token.LE:\n         case Token.GT:\n         case Token.GE:\n             leftType \u003d getJSType(n.getFirstChild());\n             rightType \u003d getJSType(n.getLastChild());\n             if (rightType.isNumber()) {\n                 validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n             } else if (leftType.isNumber()) {\n                 validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n             } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n             } else {\n                 String message \u003d \"left side of comparison\";\n                 validator.expectString(t, n, leftType, message);\n                 validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                 message \u003d \"right side of comparison\";\n                 validator.expectString(t, n, rightType, message);\n                 validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.IN:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right);\n             validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n             validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.INSTANCEOF:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n             validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n             validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.ASSIGN:\n             visitAssign(t, n);\n             typeable \u003d false;\n             break;\n         case Token.ASSIGN_LSH:\n         case Token.ASSIGN_RSH:\n         case Token.ASSIGN_URSH:\n         case Token.ASSIGN_DIV:\n         case Token.ASSIGN_MOD:\n         case Token.ASSIGN_BITOR:\n         case Token.ASSIGN_BITXOR:\n         case Token.ASSIGN_BITAND:\n         case Token.ASSIGN_SUB:\n         case Token.ASSIGN_ADD:\n         case Token.ASSIGN_MUL:\n         case Token.LSH:\n         case Token.RSH:\n         case Token.URSH:\n         case Token.DIV:\n         case Token.MOD:\n         case Token.BITOR:\n         case Token.BITXOR:\n         case Token.BITAND:\n         case Token.SUB:\n         case Token.ADD:\n         case Token.MUL:\n             visitBinaryOperator(n.getType(), t, n);\n             break;\n         case Token.DELPROP:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.CASE:\n             JSType switchType \u003d getJSType(parent.getFirstChild());\n             JSType caseType \u003d getJSType(n.getFirstChild());\n             validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n             typeable \u003d false;\n             break;\n         case Token.WITH:\n             {\n                 Node child \u003d n.getFirstChild();\n                 childType \u003d getJSType(child);\n                 validator.expectObject(t, child, childType, \"with requires an object\");\n                 typeable \u003d false;\n                 break;\n             }\n         case Token.FUNCTION:\n             visitFunction(t, n);\n             break;\n         case Token.LABEL:\n         case Token.LABEL_NAME:\n         case Token.SWITCH:\n         case Token.BREAK:\n         case Token.CATCH:\n         case Token.TRY:\n         case Token.SCRIPT:\n         case Token.EXPR_RESULT:\n         case Token.BLOCK:\n         case Token.EMPTY:\n         case Token.DEFAULT_CASE:\n         case Token.CONTINUE:\n         case Token.DEBUGGER:\n         case Token.THROW:\n             typeable \u003d false;\n             break;\n         case Token.DO:\n         case Token.FOR:\n         case Token.IF:\n         case Token.WHILE:\n             typeable \u003d false;\n             break;\n         case Token.AND:\n         case Token.HOOK:\n         case Token.OBJECTLIT:\n         case Token.OR:\n             if (n.getJSType() !\u003d null) {\n                 ensureTyped(t, n);\n             } else {\n                 if ((n.isObjectLit()) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                     ensureTyped(t, n, parent.getJSType());\n                 } else {\n                     ensureTyped(t, n);\n                 }\n             }\n             if (n.isObjectLit()) {\n                 for (Node key : n.children()) {\n                     visitObjLitKey(t, key, n);\n                 }\n             }\n             break;\n         default:\n             report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n             ensureTyped(t, n);\n             break;\n     }\n     typeable \u003d typeable \u0026\u0026 !inExterns;\n     if (typeable) {\n         doPercentTypedAccounting(t, n);\n     }\n     checkNoTypeCheckSection(n, false);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5f8b6f54294ce8b454f78165f5230b3759d11e37": {
      "type": "Ybodychange",
      "commitMessage": "\nInline NodeUtil.isExpressionNode\n\nR\u003dnicksantos\nDELTA\u003d37  (0 added, 4 deleted, 33 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d4037\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1702 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "1/4/12, 11:53 AM",
      "commitName": "5f8b6f54294ce8b454f78165f5230b3759d11e37",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "11/17/11, 10:08 AM",
      "commitNameOld": "4e976ac213f448bab78f5c1432340c489b533d7b",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 48.07,
      "commitsBetweenForRepo": 77,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    boolean typeable \u003d true;\n    switch(n.getType()) {\n        case Token.NAME:\n            typeable \u003d visitName(t, n, parent);\n            break;\n        case Token.PARAM_LIST:\n            if (!parent.isFunction()) {\n                ensureTyped(t, n, getJSType(n.getFirstChild()));\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.COMMA:\n            ensureTyped(t, n, getJSType(n.getLastChild()));\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.THIS:\n            ensureTyped(t, n, t.getScope().getTypeOfThis());\n            break;\n        case Token.NULL:\n            ensureTyped(t, n, NULL_TYPE);\n            break;\n        case Token.NUMBER:\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.STRING:\n            if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n                ensureTyped(t, n, STRING_TYPE);\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.GETTER_DEF:\n        case Token.SETTER_DEF:\n            break;\n        case Token.ARRAYLIT:\n            ensureTyped(t, n, ARRAY_TYPE);\n            break;\n        case Token.REGEXP:\n            ensureTyped(t, n, REGEXP_TYPE);\n            break;\n        case Token.GETPROP:\n            visitGetProp(t, n, parent);\n            typeable \u003d !(parent.isAssign() \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n            break;\n        case Token.GETELEM:\n            visitGetElem(t, n);\n            typeable \u003d false;\n            break;\n        case Token.VAR:\n            visitVar(t, n);\n            typeable \u003d false;\n            break;\n        case Token.NEW:\n            visitNew(t, n);\n            typeable \u003d true;\n            break;\n        case Token.CALL:\n            visitCall(t, n);\n            typeable \u003d !parent.isExprResult();\n            break;\n        case Token.RETURN:\n            visitReturn(t, n);\n            typeable \u003d false;\n            break;\n        case Token.DEC:\n        case Token.INC:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.NOT:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.VOID:\n            ensureTyped(t, n, VOID_TYPE);\n            break;\n        case Token.TYPEOF:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.BITNOT:\n            childType \u003d getJSType(n.getFirstChild());\n            if (!childType.matchesInt32Context()) {\n                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n            }\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.EQ:\n        case Token.NE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                if (result !\u003d TernaryValue.UNKNOWN) {\n                    if (n.isNE()) {\n                        result \u003d result.not();\n                    }\n                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.SHEQ:\n        case Token.SHNE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                    report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n            leftType \u003d getJSType(n.getFirstChild());\n            rightType \u003d getJSType(n.getLastChild());\n            if (rightType.isNumber()) {\n                validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n            } else if (leftType.isNumber()) {\n                validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n            } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n            } else {\n                String message \u003d \"left side of comparison\";\n                validator.expectString(t, n, leftType, message);\n                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                message \u003d \"right side of comparison\";\n                validator.expectString(t, n, rightType, message);\n                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.IN:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right);\n            validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n            validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.INSTANCEOF:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n            validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n            validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.ASSIGN:\n            visitAssign(t, n);\n            typeable \u003d false;\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.ASSIGN_URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_SUB:\n        case Token.ASSIGN_ADD:\n        case Token.ASSIGN_MUL:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.URSH:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITOR:\n        case Token.BITXOR:\n        case Token.BITAND:\n        case Token.SUB:\n        case Token.ADD:\n        case Token.MUL:\n            visitBinaryOperator(n.getType(), t, n);\n            break;\n        case Token.DELPROP:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.CASE:\n            JSType switchType \u003d getJSType(parent.getFirstChild());\n            JSType caseType \u003d getJSType(n.getFirstChild());\n            validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n            typeable \u003d false;\n            break;\n        case Token.WITH:\n            {\n                Node child \u003d n.getFirstChild();\n                childType \u003d getJSType(child);\n                validator.expectObject(t, child, childType, \"with requires an object\");\n                typeable \u003d false;\n                break;\n            }\n        case Token.FUNCTION:\n            visitFunction(t, n);\n            break;\n        case Token.LABEL:\n        case Token.LABEL_NAME:\n        case Token.SWITCH:\n        case Token.BREAK:\n        case Token.CATCH:\n        case Token.TRY:\n        case Token.SCRIPT:\n        case Token.EXPR_RESULT:\n        case Token.BLOCK:\n        case Token.EMPTY:\n        case Token.DEFAULT_CASE:\n        case Token.CONTINUE:\n        case Token.DEBUGGER:\n        case Token.THROW:\n            typeable \u003d false;\n            break;\n        case Token.DO:\n        case Token.FOR:\n        case Token.IF:\n        case Token.WHILE:\n            typeable \u003d false;\n            break;\n        case Token.AND:\n        case Token.HOOK:\n        case Token.OBJECTLIT:\n        case Token.OR:\n            if (n.getJSType() !\u003d null) {\n                ensureTyped(t, n);\n            } else {\n                if ((n.isObjectLit()) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                    ensureTyped(t, n, parent.getJSType());\n                } else {\n                    ensureTyped(t, n);\n                }\n            }\n            if (n.isObjectLit()) {\n                for (Node key : n.children()) {\n                    visitObjLitKey(t, key, n);\n                }\n            }\n            break;\n        default:\n            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n            ensureTyped(t, n);\n            break;\n    }\n    typeable \u003d typeable \u0026\u0026 !inExterns;\n    if (typeable) {\n        doPercentTypedAccounting(t, n);\n    }\n    checkNoTypeCheckSection(n, false);\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 461,
      "functionName": "visit",
      "functionAnnotation": "@Override",
      "functionDoc": "This is the meat of the type checking.  It is basically one big switch,\nwith each case representing one type of parse tree node.  The individual\ncases are usually pretty straightforward.\n\n@param t The node traversal object that supplies context, such as the\nscope chain to use in name lookups as well as error reporting.\n@param n The node being visited.\n@param parent The parent of the node n.\n",
      "diff": "@@ -1,270 +1,270 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n     JSType childType;\n     JSType leftType, rightType;\n     Node left, right;\n     boolean typeable \u003d true;\n     switch(n.getType()) {\n         case Token.NAME:\n             typeable \u003d visitName(t, n, parent);\n             break;\n         case Token.PARAM_LIST:\n             if (!parent.isFunction()) {\n                 ensureTyped(t, n, getJSType(n.getFirstChild()));\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.COMMA:\n             ensureTyped(t, n, getJSType(n.getLastChild()));\n             break;\n         case Token.TRUE:\n         case Token.FALSE:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.THIS:\n             ensureTyped(t, n, t.getScope().getTypeOfThis());\n             break;\n         case Token.NULL:\n             ensureTyped(t, n, NULL_TYPE);\n             break;\n         case Token.NUMBER:\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.STRING:\n             if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n                 ensureTyped(t, n, STRING_TYPE);\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.GETTER_DEF:\n         case Token.SETTER_DEF:\n             break;\n         case Token.ARRAYLIT:\n             ensureTyped(t, n, ARRAY_TYPE);\n             break;\n         case Token.REGEXP:\n             ensureTyped(t, n, REGEXP_TYPE);\n             break;\n         case Token.GETPROP:\n             visitGetProp(t, n, parent);\n             typeable \u003d !(parent.isAssign() \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n             break;\n         case Token.GETELEM:\n             visitGetElem(t, n);\n             typeable \u003d false;\n             break;\n         case Token.VAR:\n             visitVar(t, n);\n             typeable \u003d false;\n             break;\n         case Token.NEW:\n             visitNew(t, n);\n             typeable \u003d true;\n             break;\n         case Token.CALL:\n             visitCall(t, n);\n-            typeable \u003d !NodeUtil.isExpressionNode(parent);\n+            typeable \u003d !parent.isExprResult();\n             break;\n         case Token.RETURN:\n             visitReturn(t, n);\n             typeable \u003d false;\n             break;\n         case Token.DEC:\n         case Token.INC:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.NOT:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.VOID:\n             ensureTyped(t, n, VOID_TYPE);\n             break;\n         case Token.TYPEOF:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.BITNOT:\n             childType \u003d getJSType(n.getFirstChild());\n             if (!childType.matchesInt32Context()) {\n                 report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n             }\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.POS:\n         case Token.NEG:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.EQ:\n         case Token.NE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                 if (result !\u003d TernaryValue.UNKNOWN) {\n                     if (n.isNE()) {\n                         result \u003d result.not();\n                     }\n                     report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.SHEQ:\n         case Token.SHNE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                     report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.LT:\n         case Token.LE:\n         case Token.GT:\n         case Token.GE:\n             leftType \u003d getJSType(n.getFirstChild());\n             rightType \u003d getJSType(n.getLastChild());\n             if (rightType.isNumber()) {\n                 validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n             } else if (leftType.isNumber()) {\n                 validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n             } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n             } else {\n                 String message \u003d \"left side of comparison\";\n                 validator.expectString(t, n, leftType, message);\n                 validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                 message \u003d \"right side of comparison\";\n                 validator.expectString(t, n, rightType, message);\n                 validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.IN:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right);\n             validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n             validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.INSTANCEOF:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n             validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n             validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.ASSIGN:\n             visitAssign(t, n);\n             typeable \u003d false;\n             break;\n         case Token.ASSIGN_LSH:\n         case Token.ASSIGN_RSH:\n         case Token.ASSIGN_URSH:\n         case Token.ASSIGN_DIV:\n         case Token.ASSIGN_MOD:\n         case Token.ASSIGN_BITOR:\n         case Token.ASSIGN_BITXOR:\n         case Token.ASSIGN_BITAND:\n         case Token.ASSIGN_SUB:\n         case Token.ASSIGN_ADD:\n         case Token.ASSIGN_MUL:\n         case Token.LSH:\n         case Token.RSH:\n         case Token.URSH:\n         case Token.DIV:\n         case Token.MOD:\n         case Token.BITOR:\n         case Token.BITXOR:\n         case Token.BITAND:\n         case Token.SUB:\n         case Token.ADD:\n         case Token.MUL:\n             visitBinaryOperator(n.getType(), t, n);\n             break;\n         case Token.DELPROP:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.CASE:\n             JSType switchType \u003d getJSType(parent.getFirstChild());\n             JSType caseType \u003d getJSType(n.getFirstChild());\n             validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n             typeable \u003d false;\n             break;\n         case Token.WITH:\n             {\n                 Node child \u003d n.getFirstChild();\n                 childType \u003d getJSType(child);\n                 validator.expectObject(t, child, childType, \"with requires an object\");\n                 typeable \u003d false;\n                 break;\n             }\n         case Token.FUNCTION:\n             visitFunction(t, n);\n             break;\n         case Token.LABEL:\n         case Token.LABEL_NAME:\n         case Token.SWITCH:\n         case Token.BREAK:\n         case Token.CATCH:\n         case Token.TRY:\n         case Token.SCRIPT:\n         case Token.EXPR_RESULT:\n         case Token.BLOCK:\n         case Token.EMPTY:\n         case Token.DEFAULT_CASE:\n         case Token.CONTINUE:\n         case Token.DEBUGGER:\n         case Token.THROW:\n             typeable \u003d false;\n             break;\n         case Token.DO:\n         case Token.FOR:\n         case Token.IF:\n         case Token.WHILE:\n             typeable \u003d false;\n             break;\n         case Token.AND:\n         case Token.HOOK:\n         case Token.OBJECTLIT:\n         case Token.OR:\n             if (n.getJSType() !\u003d null) {\n                 ensureTyped(t, n);\n             } else {\n                 if ((n.isObjectLit()) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                     ensureTyped(t, n, parent.getJSType());\n                 } else {\n                     ensureTyped(t, n);\n                 }\n             }\n             if (n.isObjectLit()) {\n                 for (Node key : n.children()) {\n                     visitObjLitKey(t, key, n);\n                 }\n             }\n             break;\n         default:\n             report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n             ensureTyped(t, n);\n             break;\n     }\n     typeable \u003d typeable \u0026\u0026 !inExterns;\n     if (typeable) {\n         doPercentTypedAccounting(t, n);\n     }\n     checkNoTypeCheckSection(n, false);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "925a8f78c8c6a407435e6fb4513ad96d617643a3": {
      "type": "Ybodychange",
      "commitMessage": "\nReplace some straggler \"n.isType() \u003d\u003d Token.XX\" calls.\n\nR\u003dnicksantos\nDELTA\u003d70  (36 added, 6 deleted, 28 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3725\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1601 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/15/11, 5:35 PM",
      "commitName": "925a8f78c8c6a407435e6fb4513ad96d617643a3",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "11/14/11, 6:13 PM",
      "commitNameOld": "39f629a8cfaab37da55288010640d7e516000b1f",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 0.97,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    boolean typeable \u003d true;\n    switch(n.getType()) {\n        case Token.NAME:\n            typeable \u003d visitName(t, n, parent);\n            break;\n        case Token.PARAM_LIST:\n            if (!parent.isFunction()) {\n                ensureTyped(t, n, getJSType(n.getFirstChild()));\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.COMMA:\n            ensureTyped(t, n, getJSType(n.getLastChild()));\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.THIS:\n            ensureTyped(t, n, t.getScope().getTypeOfThis());\n            break;\n        case Token.NULL:\n            ensureTyped(t, n, NULL_TYPE);\n            break;\n        case Token.NUMBER:\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.STRING:\n            if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n                ensureTyped(t, n, STRING_TYPE);\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.GETTER_DEF:\n        case Token.SETTER_DEF:\n            break;\n        case Token.ARRAYLIT:\n            ensureTyped(t, n, ARRAY_TYPE);\n            break;\n        case Token.REGEXP:\n            ensureTyped(t, n, REGEXP_TYPE);\n            break;\n        case Token.GETPROP:\n            visitGetProp(t, n, parent);\n            typeable \u003d !(parent.isAssign() \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n            break;\n        case Token.GETELEM:\n            visitGetElem(t, n);\n            typeable \u003d false;\n            break;\n        case Token.VAR:\n            visitVar(t, n);\n            typeable \u003d false;\n            break;\n        case Token.NEW:\n            visitNew(t, n);\n            typeable \u003d true;\n            break;\n        case Token.CALL:\n            visitCall(t, n);\n            typeable \u003d !NodeUtil.isExpressionNode(parent);\n            break;\n        case Token.RETURN:\n            visitReturn(t, n);\n            typeable \u003d false;\n            break;\n        case Token.DEC:\n        case Token.INC:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.NOT:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.VOID:\n            ensureTyped(t, n, VOID_TYPE);\n            break;\n        case Token.TYPEOF:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.BITNOT:\n            childType \u003d getJSType(n.getFirstChild());\n            if (!childType.matchesInt32Context()) {\n                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n            }\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.EQ:\n        case Token.NE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                if (result !\u003d TernaryValue.UNKNOWN) {\n                    if (n.isNE()) {\n                        result \u003d result.not();\n                    }\n                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.SHEQ:\n        case Token.SHNE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                    report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n            leftType \u003d getJSType(n.getFirstChild());\n            rightType \u003d getJSType(n.getLastChild());\n            if (rightType.isNumber()) {\n                validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n            } else if (leftType.isNumber()) {\n                validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n            } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n            } else {\n                String message \u003d \"left side of comparison\";\n                validator.expectString(t, n, leftType, message);\n                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                message \u003d \"right side of comparison\";\n                validator.expectString(t, n, rightType, message);\n                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.IN:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right);\n            validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n            validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.INSTANCEOF:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n            validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n            validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.ASSIGN:\n            visitAssign(t, n);\n            typeable \u003d false;\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.ASSIGN_URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_SUB:\n        case Token.ASSIGN_ADD:\n        case Token.ASSIGN_MUL:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.URSH:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITOR:\n        case Token.BITXOR:\n        case Token.BITAND:\n        case Token.SUB:\n        case Token.ADD:\n        case Token.MUL:\n            visitBinaryOperator(n.getType(), t, n);\n            break;\n        case Token.DELPROP:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.CASE:\n            JSType switchType \u003d getJSType(parent.getFirstChild());\n            JSType caseType \u003d getJSType(n.getFirstChild());\n            validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n            typeable \u003d false;\n            break;\n        case Token.WITH:\n            {\n                Node child \u003d n.getFirstChild();\n                childType \u003d getJSType(child);\n                validator.expectObject(t, child, childType, \"with requires an object\");\n                typeable \u003d false;\n                break;\n            }\n        case Token.FUNCTION:\n            visitFunction(t, n);\n            break;\n        case Token.LABEL:\n        case Token.LABEL_NAME:\n        case Token.SWITCH:\n        case Token.BREAK:\n        case Token.CATCH:\n        case Token.TRY:\n        case Token.SCRIPT:\n        case Token.EXPR_RESULT:\n        case Token.BLOCK:\n        case Token.EMPTY:\n        case Token.DEFAULT_CASE:\n        case Token.CONTINUE:\n        case Token.DEBUGGER:\n        case Token.THROW:\n            typeable \u003d false;\n            break;\n        case Token.DO:\n        case Token.FOR:\n        case Token.IF:\n        case Token.WHILE:\n            typeable \u003d false;\n            break;\n        case Token.AND:\n        case Token.HOOK:\n        case Token.OBJECTLIT:\n        case Token.OR:\n            if (n.getJSType() !\u003d null) {\n                ensureTyped(t, n);\n            } else {\n                if ((n.isObjectLit()) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                    ensureTyped(t, n, parent.getJSType());\n                } else {\n                    ensureTyped(t, n);\n                }\n            }\n            if (n.isObjectLit()) {\n                for (Node key : n.children()) {\n                    visitObjLitKey(t, key, n);\n                }\n            }\n            break;\n        default:\n            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n            ensureTyped(t, n);\n            break;\n    }\n    typeable \u003d typeable \u0026\u0026 !inExterns;\n    if (typeable) {\n        doPercentTypedAccounting(t, n);\n    }\n    checkNoTypeCheckSection(n, false);\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 461,
      "functionName": "visit",
      "functionAnnotation": "@Override",
      "functionDoc": "This is the meat of the type checking.  It is basically one big switch,\nwith each case representing one type of parse tree node.  The individual\ncases are usually pretty straightforward.\n\n@param t The node traversal object that supplies context, such as the\nscope chain to use in name lookups as well as error reporting.\n@param n The node being visited.\n@param parent The parent of the node n.\n",
      "diff": "@@ -1,270 +1,270 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n     JSType childType;\n     JSType leftType, rightType;\n     Node left, right;\n     boolean typeable \u003d true;\n     switch(n.getType()) {\n         case Token.NAME:\n             typeable \u003d visitName(t, n, parent);\n             break;\n         case Token.PARAM_LIST:\n             if (!parent.isFunction()) {\n                 ensureTyped(t, n, getJSType(n.getFirstChild()));\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.COMMA:\n             ensureTyped(t, n, getJSType(n.getLastChild()));\n             break;\n         case Token.TRUE:\n         case Token.FALSE:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.THIS:\n             ensureTyped(t, n, t.getScope().getTypeOfThis());\n             break;\n         case Token.NULL:\n             ensureTyped(t, n, NULL_TYPE);\n             break;\n         case Token.NUMBER:\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.STRING:\n             if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n                 ensureTyped(t, n, STRING_TYPE);\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.GETTER_DEF:\n         case Token.SETTER_DEF:\n             break;\n         case Token.ARRAYLIT:\n             ensureTyped(t, n, ARRAY_TYPE);\n             break;\n         case Token.REGEXP:\n             ensureTyped(t, n, REGEXP_TYPE);\n             break;\n         case Token.GETPROP:\n             visitGetProp(t, n, parent);\n             typeable \u003d !(parent.isAssign() \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n             break;\n         case Token.GETELEM:\n             visitGetElem(t, n);\n             typeable \u003d false;\n             break;\n         case Token.VAR:\n             visitVar(t, n);\n             typeable \u003d false;\n             break;\n         case Token.NEW:\n             visitNew(t, n);\n             typeable \u003d true;\n             break;\n         case Token.CALL:\n             visitCall(t, n);\n             typeable \u003d !NodeUtil.isExpressionNode(parent);\n             break;\n         case Token.RETURN:\n             visitReturn(t, n);\n             typeable \u003d false;\n             break;\n         case Token.DEC:\n         case Token.INC:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.NOT:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.VOID:\n             ensureTyped(t, n, VOID_TYPE);\n             break;\n         case Token.TYPEOF:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.BITNOT:\n             childType \u003d getJSType(n.getFirstChild());\n             if (!childType.matchesInt32Context()) {\n                 report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n             }\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.POS:\n         case Token.NEG:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.EQ:\n         case Token.NE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                 if (result !\u003d TernaryValue.UNKNOWN) {\n-                    if (n.getType() \u003d\u003d Token.NE) {\n+                    if (n.isNE()) {\n                         result \u003d result.not();\n                     }\n                     report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.SHEQ:\n         case Token.SHNE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                     report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.LT:\n         case Token.LE:\n         case Token.GT:\n         case Token.GE:\n             leftType \u003d getJSType(n.getFirstChild());\n             rightType \u003d getJSType(n.getLastChild());\n             if (rightType.isNumber()) {\n                 validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n             } else if (leftType.isNumber()) {\n                 validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n             } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n             } else {\n                 String message \u003d \"left side of comparison\";\n                 validator.expectString(t, n, leftType, message);\n                 validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                 message \u003d \"right side of comparison\";\n                 validator.expectString(t, n, rightType, message);\n                 validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.IN:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right);\n             validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n             validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.INSTANCEOF:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n             validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n             validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.ASSIGN:\n             visitAssign(t, n);\n             typeable \u003d false;\n             break;\n         case Token.ASSIGN_LSH:\n         case Token.ASSIGN_RSH:\n         case Token.ASSIGN_URSH:\n         case Token.ASSIGN_DIV:\n         case Token.ASSIGN_MOD:\n         case Token.ASSIGN_BITOR:\n         case Token.ASSIGN_BITXOR:\n         case Token.ASSIGN_BITAND:\n         case Token.ASSIGN_SUB:\n         case Token.ASSIGN_ADD:\n         case Token.ASSIGN_MUL:\n         case Token.LSH:\n         case Token.RSH:\n         case Token.URSH:\n         case Token.DIV:\n         case Token.MOD:\n         case Token.BITOR:\n         case Token.BITXOR:\n         case Token.BITAND:\n         case Token.SUB:\n         case Token.ADD:\n         case Token.MUL:\n             visitBinaryOperator(n.getType(), t, n);\n             break;\n         case Token.DELPROP:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.CASE:\n             JSType switchType \u003d getJSType(parent.getFirstChild());\n             JSType caseType \u003d getJSType(n.getFirstChild());\n             validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n             typeable \u003d false;\n             break;\n         case Token.WITH:\n             {\n                 Node child \u003d n.getFirstChild();\n                 childType \u003d getJSType(child);\n                 validator.expectObject(t, child, childType, \"with requires an object\");\n                 typeable \u003d false;\n                 break;\n             }\n         case Token.FUNCTION:\n             visitFunction(t, n);\n             break;\n         case Token.LABEL:\n         case Token.LABEL_NAME:\n         case Token.SWITCH:\n         case Token.BREAK:\n         case Token.CATCH:\n         case Token.TRY:\n         case Token.SCRIPT:\n         case Token.EXPR_RESULT:\n         case Token.BLOCK:\n         case Token.EMPTY:\n         case Token.DEFAULT_CASE:\n         case Token.CONTINUE:\n         case Token.DEBUGGER:\n         case Token.THROW:\n             typeable \u003d false;\n             break;\n         case Token.DO:\n         case Token.FOR:\n         case Token.IF:\n         case Token.WHILE:\n             typeable \u003d false;\n             break;\n         case Token.AND:\n         case Token.HOOK:\n         case Token.OBJECTLIT:\n         case Token.OR:\n             if (n.getJSType() !\u003d null) {\n                 ensureTyped(t, n);\n             } else {\n                 if ((n.isObjectLit()) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                     ensureTyped(t, n, parent.getJSType());\n                 } else {\n                     ensureTyped(t, n);\n                 }\n             }\n             if (n.isObjectLit()) {\n                 for (Node key : n.children()) {\n                     visitObjLitKey(t, key, n);\n                 }\n             }\n             break;\n         default:\n             report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n             ensureTyped(t, n);\n             break;\n     }\n     typeable \u003d typeable \u0026\u0026 !inExterns;\n     if (typeable) {\n         doPercentTypedAccounting(t, n);\n     }\n     checkNoTypeCheckSection(n, false);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "39f629a8cfaab37da55288010640d7e516000b1f": {
      "type": "Ybodychange",
      "commitMessage": "\nReplace calls of the form \"Node.getType() !\u003d Token.XX\" with\n\"!Node.isXX()\" calls.\n\nR\u003dnicksantos\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3706\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1598 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/14/11, 6:13 PM",
      "commitName": "39f629a8cfaab37da55288010640d7e516000b1f",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "11/11/11, 4:42 PM",
      "commitNameOld": "5524adbda991632656059566b69cc2771ba42b7d",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 3.06,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    boolean typeable \u003d true;\n    switch(n.getType()) {\n        case Token.NAME:\n            typeable \u003d visitName(t, n, parent);\n            break;\n        case Token.PARAM_LIST:\n            if (!parent.isFunction()) {\n                ensureTyped(t, n, getJSType(n.getFirstChild()));\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.COMMA:\n            ensureTyped(t, n, getJSType(n.getLastChild()));\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.THIS:\n            ensureTyped(t, n, t.getScope().getTypeOfThis());\n            break;\n        case Token.NULL:\n            ensureTyped(t, n, NULL_TYPE);\n            break;\n        case Token.NUMBER:\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.STRING:\n            if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n                ensureTyped(t, n, STRING_TYPE);\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.GETTER_DEF:\n        case Token.SETTER_DEF:\n            break;\n        case Token.ARRAYLIT:\n            ensureTyped(t, n, ARRAY_TYPE);\n            break;\n        case Token.REGEXP:\n            ensureTyped(t, n, REGEXP_TYPE);\n            break;\n        case Token.GETPROP:\n            visitGetProp(t, n, parent);\n            typeable \u003d !(parent.isAssign() \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n            break;\n        case Token.GETELEM:\n            visitGetElem(t, n);\n            typeable \u003d false;\n            break;\n        case Token.VAR:\n            visitVar(t, n);\n            typeable \u003d false;\n            break;\n        case Token.NEW:\n            visitNew(t, n);\n            typeable \u003d true;\n            break;\n        case Token.CALL:\n            visitCall(t, n);\n            typeable \u003d !NodeUtil.isExpressionNode(parent);\n            break;\n        case Token.RETURN:\n            visitReturn(t, n);\n            typeable \u003d false;\n            break;\n        case Token.DEC:\n        case Token.INC:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.NOT:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.VOID:\n            ensureTyped(t, n, VOID_TYPE);\n            break;\n        case Token.TYPEOF:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.BITNOT:\n            childType \u003d getJSType(n.getFirstChild());\n            if (!childType.matchesInt32Context()) {\n                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n            }\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.EQ:\n        case Token.NE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                if (result !\u003d TernaryValue.UNKNOWN) {\n                    if (n.getType() \u003d\u003d Token.NE) {\n                        result \u003d result.not();\n                    }\n                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.SHEQ:\n        case Token.SHNE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                    report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n            leftType \u003d getJSType(n.getFirstChild());\n            rightType \u003d getJSType(n.getLastChild());\n            if (rightType.isNumber()) {\n                validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n            } else if (leftType.isNumber()) {\n                validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n            } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n            } else {\n                String message \u003d \"left side of comparison\";\n                validator.expectString(t, n, leftType, message);\n                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                message \u003d \"right side of comparison\";\n                validator.expectString(t, n, rightType, message);\n                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.IN:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right);\n            validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n            validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.INSTANCEOF:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n            validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n            validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.ASSIGN:\n            visitAssign(t, n);\n            typeable \u003d false;\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.ASSIGN_URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_SUB:\n        case Token.ASSIGN_ADD:\n        case Token.ASSIGN_MUL:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.URSH:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITOR:\n        case Token.BITXOR:\n        case Token.BITAND:\n        case Token.SUB:\n        case Token.ADD:\n        case Token.MUL:\n            visitBinaryOperator(n.getType(), t, n);\n            break;\n        case Token.DELPROP:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.CASE:\n            JSType switchType \u003d getJSType(parent.getFirstChild());\n            JSType caseType \u003d getJSType(n.getFirstChild());\n            validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n            typeable \u003d false;\n            break;\n        case Token.WITH:\n            {\n                Node child \u003d n.getFirstChild();\n                childType \u003d getJSType(child);\n                validator.expectObject(t, child, childType, \"with requires an object\");\n                typeable \u003d false;\n                break;\n            }\n        case Token.FUNCTION:\n            visitFunction(t, n);\n            break;\n        case Token.LABEL:\n        case Token.LABEL_NAME:\n        case Token.SWITCH:\n        case Token.BREAK:\n        case Token.CATCH:\n        case Token.TRY:\n        case Token.SCRIPT:\n        case Token.EXPR_RESULT:\n        case Token.BLOCK:\n        case Token.EMPTY:\n        case Token.DEFAULT_CASE:\n        case Token.CONTINUE:\n        case Token.DEBUGGER:\n        case Token.THROW:\n            typeable \u003d false;\n            break;\n        case Token.DO:\n        case Token.FOR:\n        case Token.IF:\n        case Token.WHILE:\n            typeable \u003d false;\n            break;\n        case Token.AND:\n        case Token.HOOK:\n        case Token.OBJECTLIT:\n        case Token.OR:\n            if (n.getJSType() !\u003d null) {\n                ensureTyped(t, n);\n            } else {\n                if ((n.isObjectLit()) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                    ensureTyped(t, n, parent.getJSType());\n                } else {\n                    ensureTyped(t, n);\n                }\n            }\n            if (n.isObjectLit()) {\n                for (Node key : n.children()) {\n                    visitObjLitKey(t, key, n);\n                }\n            }\n            break;\n        default:\n            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n            ensureTyped(t, n);\n            break;\n    }\n    typeable \u003d typeable \u0026\u0026 !inExterns;\n    if (typeable) {\n        doPercentTypedAccounting(t, n);\n    }\n    checkNoTypeCheckSection(n, false);\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 461,
      "functionName": "visit",
      "functionAnnotation": "@Override",
      "functionDoc": "This is the meat of the type checking.  It is basically one big switch,\nwith each case representing one type of parse tree node.  The individual\ncases are usually pretty straightforward.\n\n@param t The node traversal object that supplies context, such as the\nscope chain to use in name lookups as well as error reporting.\n@param n The node being visited.\n@param parent The parent of the node n.\n",
      "diff": "@@ -1,270 +1,270 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n     JSType childType;\n     JSType leftType, rightType;\n     Node left, right;\n     boolean typeable \u003d true;\n     switch(n.getType()) {\n         case Token.NAME:\n             typeable \u003d visitName(t, n, parent);\n             break;\n         case Token.PARAM_LIST:\n-            if (parent.getType() !\u003d Token.FUNCTION) {\n+            if (!parent.isFunction()) {\n                 ensureTyped(t, n, getJSType(n.getFirstChild()));\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.COMMA:\n             ensureTyped(t, n, getJSType(n.getLastChild()));\n             break;\n         case Token.TRUE:\n         case Token.FALSE:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.THIS:\n             ensureTyped(t, n, t.getScope().getTypeOfThis());\n             break;\n         case Token.NULL:\n             ensureTyped(t, n, NULL_TYPE);\n             break;\n         case Token.NUMBER:\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.STRING:\n             if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n                 ensureTyped(t, n, STRING_TYPE);\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.GETTER_DEF:\n         case Token.SETTER_DEF:\n             break;\n         case Token.ARRAYLIT:\n             ensureTyped(t, n, ARRAY_TYPE);\n             break;\n         case Token.REGEXP:\n             ensureTyped(t, n, REGEXP_TYPE);\n             break;\n         case Token.GETPROP:\n             visitGetProp(t, n, parent);\n             typeable \u003d !(parent.isAssign() \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n             break;\n         case Token.GETELEM:\n             visitGetElem(t, n);\n             typeable \u003d false;\n             break;\n         case Token.VAR:\n             visitVar(t, n);\n             typeable \u003d false;\n             break;\n         case Token.NEW:\n             visitNew(t, n);\n             typeable \u003d true;\n             break;\n         case Token.CALL:\n             visitCall(t, n);\n             typeable \u003d !NodeUtil.isExpressionNode(parent);\n             break;\n         case Token.RETURN:\n             visitReturn(t, n);\n             typeable \u003d false;\n             break;\n         case Token.DEC:\n         case Token.INC:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.NOT:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.VOID:\n             ensureTyped(t, n, VOID_TYPE);\n             break;\n         case Token.TYPEOF:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.BITNOT:\n             childType \u003d getJSType(n.getFirstChild());\n             if (!childType.matchesInt32Context()) {\n                 report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n             }\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.POS:\n         case Token.NEG:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.EQ:\n         case Token.NE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                 if (result !\u003d TernaryValue.UNKNOWN) {\n                     if (n.getType() \u003d\u003d Token.NE) {\n                         result \u003d result.not();\n                     }\n                     report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.SHEQ:\n         case Token.SHNE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                     report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.LT:\n         case Token.LE:\n         case Token.GT:\n         case Token.GE:\n             leftType \u003d getJSType(n.getFirstChild());\n             rightType \u003d getJSType(n.getLastChild());\n             if (rightType.isNumber()) {\n                 validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n             } else if (leftType.isNumber()) {\n                 validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n             } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n             } else {\n                 String message \u003d \"left side of comparison\";\n                 validator.expectString(t, n, leftType, message);\n                 validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                 message \u003d \"right side of comparison\";\n                 validator.expectString(t, n, rightType, message);\n                 validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.IN:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right);\n             validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n             validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.INSTANCEOF:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n             validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n             validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.ASSIGN:\n             visitAssign(t, n);\n             typeable \u003d false;\n             break;\n         case Token.ASSIGN_LSH:\n         case Token.ASSIGN_RSH:\n         case Token.ASSIGN_URSH:\n         case Token.ASSIGN_DIV:\n         case Token.ASSIGN_MOD:\n         case Token.ASSIGN_BITOR:\n         case Token.ASSIGN_BITXOR:\n         case Token.ASSIGN_BITAND:\n         case Token.ASSIGN_SUB:\n         case Token.ASSIGN_ADD:\n         case Token.ASSIGN_MUL:\n         case Token.LSH:\n         case Token.RSH:\n         case Token.URSH:\n         case Token.DIV:\n         case Token.MOD:\n         case Token.BITOR:\n         case Token.BITXOR:\n         case Token.BITAND:\n         case Token.SUB:\n         case Token.ADD:\n         case Token.MUL:\n             visitBinaryOperator(n.getType(), t, n);\n             break;\n         case Token.DELPROP:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.CASE:\n             JSType switchType \u003d getJSType(parent.getFirstChild());\n             JSType caseType \u003d getJSType(n.getFirstChild());\n             validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n             typeable \u003d false;\n             break;\n         case Token.WITH:\n             {\n                 Node child \u003d n.getFirstChild();\n                 childType \u003d getJSType(child);\n                 validator.expectObject(t, child, childType, \"with requires an object\");\n                 typeable \u003d false;\n                 break;\n             }\n         case Token.FUNCTION:\n             visitFunction(t, n);\n             break;\n         case Token.LABEL:\n         case Token.LABEL_NAME:\n         case Token.SWITCH:\n         case Token.BREAK:\n         case Token.CATCH:\n         case Token.TRY:\n         case Token.SCRIPT:\n         case Token.EXPR_RESULT:\n         case Token.BLOCK:\n         case Token.EMPTY:\n         case Token.DEFAULT_CASE:\n         case Token.CONTINUE:\n         case Token.DEBUGGER:\n         case Token.THROW:\n             typeable \u003d false;\n             break;\n         case Token.DO:\n         case Token.FOR:\n         case Token.IF:\n         case Token.WHILE:\n             typeable \u003d false;\n             break;\n         case Token.AND:\n         case Token.HOOK:\n         case Token.OBJECTLIT:\n         case Token.OR:\n             if (n.getJSType() !\u003d null) {\n                 ensureTyped(t, n);\n             } else {\n                 if ((n.isObjectLit()) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                     ensureTyped(t, n, parent.getJSType());\n                 } else {\n                     ensureTyped(t, n);\n                 }\n             }\n             if (n.isObjectLit()) {\n                 for (Node key : n.children()) {\n                     visitObjLitKey(t, key, n);\n                 }\n             }\n             break;\n         default:\n             report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n             ensureTyped(t, n);\n             break;\n     }\n     typeable \u003d typeable \u0026\u0026 !inExterns;\n     if (typeable) {\n         doPercentTypedAccounting(t, n);\n     }\n     checkNoTypeCheckSection(n, false);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5524adbda991632656059566b69cc2771ba42b7d": {
      "type": "Ybodychange",
      "commitMessage": "\nRename a couple of AST nodes:\nDEFAULT becomes DEFAULT_CASE\nLP becomes PARAM_LIST\nGET becomes GETTER_DEF\nSET becomes SETTER_DEF\n\nR\u003dnicksantos\nDELTA\u003d215  (40 added, 5 deleted, 170 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3695\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1590 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/11/11, 4:42 PM",
      "commitName": "5524adbda991632656059566b69cc2771ba42b7d",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "11/11/11, 9:57 AM",
      "commitNameOld": "3517e9bad4eceb4aefaa9f3a999ec83f2db33f25",
      "commitAuthorOld": "tylerg@google.com",
      "daysBetweenCommits": 0.28,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    boolean typeable \u003d true;\n    switch(n.getType()) {\n        case Token.NAME:\n            typeable \u003d visitName(t, n, parent);\n            break;\n        case Token.PARAM_LIST:\n            if (parent.getType() !\u003d Token.FUNCTION) {\n                ensureTyped(t, n, getJSType(n.getFirstChild()));\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.COMMA:\n            ensureTyped(t, n, getJSType(n.getLastChild()));\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.THIS:\n            ensureTyped(t, n, t.getScope().getTypeOfThis());\n            break;\n        case Token.NULL:\n            ensureTyped(t, n, NULL_TYPE);\n            break;\n        case Token.NUMBER:\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.STRING:\n            if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n                ensureTyped(t, n, STRING_TYPE);\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.GETTER_DEF:\n        case Token.SETTER_DEF:\n            break;\n        case Token.ARRAYLIT:\n            ensureTyped(t, n, ARRAY_TYPE);\n            break;\n        case Token.REGEXP:\n            ensureTyped(t, n, REGEXP_TYPE);\n            break;\n        case Token.GETPROP:\n            visitGetProp(t, n, parent);\n            typeable \u003d !(parent.isAssign() \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n            break;\n        case Token.GETELEM:\n            visitGetElem(t, n);\n            typeable \u003d false;\n            break;\n        case Token.VAR:\n            visitVar(t, n);\n            typeable \u003d false;\n            break;\n        case Token.NEW:\n            visitNew(t, n);\n            typeable \u003d true;\n            break;\n        case Token.CALL:\n            visitCall(t, n);\n            typeable \u003d !NodeUtil.isExpressionNode(parent);\n            break;\n        case Token.RETURN:\n            visitReturn(t, n);\n            typeable \u003d false;\n            break;\n        case Token.DEC:\n        case Token.INC:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.NOT:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.VOID:\n            ensureTyped(t, n, VOID_TYPE);\n            break;\n        case Token.TYPEOF:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.BITNOT:\n            childType \u003d getJSType(n.getFirstChild());\n            if (!childType.matchesInt32Context()) {\n                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n            }\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.EQ:\n        case Token.NE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                if (result !\u003d TernaryValue.UNKNOWN) {\n                    if (n.getType() \u003d\u003d Token.NE) {\n                        result \u003d result.not();\n                    }\n                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.SHEQ:\n        case Token.SHNE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                    report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n            leftType \u003d getJSType(n.getFirstChild());\n            rightType \u003d getJSType(n.getLastChild());\n            if (rightType.isNumber()) {\n                validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n            } else if (leftType.isNumber()) {\n                validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n            } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n            } else {\n                String message \u003d \"left side of comparison\";\n                validator.expectString(t, n, leftType, message);\n                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                message \u003d \"right side of comparison\";\n                validator.expectString(t, n, rightType, message);\n                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.IN:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right);\n            validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n            validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.INSTANCEOF:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n            validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n            validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.ASSIGN:\n            visitAssign(t, n);\n            typeable \u003d false;\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.ASSIGN_URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_SUB:\n        case Token.ASSIGN_ADD:\n        case Token.ASSIGN_MUL:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.URSH:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITOR:\n        case Token.BITXOR:\n        case Token.BITAND:\n        case Token.SUB:\n        case Token.ADD:\n        case Token.MUL:\n            visitBinaryOperator(n.getType(), t, n);\n            break;\n        case Token.DELPROP:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.CASE:\n            JSType switchType \u003d getJSType(parent.getFirstChild());\n            JSType caseType \u003d getJSType(n.getFirstChild());\n            validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n            typeable \u003d false;\n            break;\n        case Token.WITH:\n            {\n                Node child \u003d n.getFirstChild();\n                childType \u003d getJSType(child);\n                validator.expectObject(t, child, childType, \"with requires an object\");\n                typeable \u003d false;\n                break;\n            }\n        case Token.FUNCTION:\n            visitFunction(t, n);\n            break;\n        case Token.LABEL:\n        case Token.LABEL_NAME:\n        case Token.SWITCH:\n        case Token.BREAK:\n        case Token.CATCH:\n        case Token.TRY:\n        case Token.SCRIPT:\n        case Token.EXPR_RESULT:\n        case Token.BLOCK:\n        case Token.EMPTY:\n        case Token.DEFAULT_CASE:\n        case Token.CONTINUE:\n        case Token.DEBUGGER:\n        case Token.THROW:\n            typeable \u003d false;\n            break;\n        case Token.DO:\n        case Token.FOR:\n        case Token.IF:\n        case Token.WHILE:\n            typeable \u003d false;\n            break;\n        case Token.AND:\n        case Token.HOOK:\n        case Token.OBJECTLIT:\n        case Token.OR:\n            if (n.getJSType() !\u003d null) {\n                ensureTyped(t, n);\n            } else {\n                if ((n.isObjectLit()) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                    ensureTyped(t, n, parent.getJSType());\n                } else {\n                    ensureTyped(t, n);\n                }\n            }\n            if (n.isObjectLit()) {\n                for (Node key : n.children()) {\n                    visitObjLitKey(t, key, n);\n                }\n            }\n            break;\n        default:\n            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n            ensureTyped(t, n);\n            break;\n    }\n    typeable \u003d typeable \u0026\u0026 !inExterns;\n    if (typeable) {\n        doPercentTypedAccounting(t, n);\n    }\n    checkNoTypeCheckSection(n, false);\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 461,
      "functionName": "visit",
      "functionAnnotation": "@Override",
      "functionDoc": "This is the meat of the type checking.  It is basically one big switch,\nwith each case representing one type of parse tree node.  The individual\ncases are usually pretty straightforward.\n\n@param t The node traversal object that supplies context, such as the\nscope chain to use in name lookups as well as error reporting.\n@param n The node being visited.\n@param parent The parent of the node n.\n",
      "diff": "@@ -1,270 +1,270 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n     JSType childType;\n     JSType leftType, rightType;\n     Node left, right;\n     boolean typeable \u003d true;\n     switch(n.getType()) {\n         case Token.NAME:\n             typeable \u003d visitName(t, n, parent);\n             break;\n-        case Token.LP:\n+        case Token.PARAM_LIST:\n             if (parent.getType() !\u003d Token.FUNCTION) {\n                 ensureTyped(t, n, getJSType(n.getFirstChild()));\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.COMMA:\n             ensureTyped(t, n, getJSType(n.getLastChild()));\n             break;\n         case Token.TRUE:\n         case Token.FALSE:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.THIS:\n             ensureTyped(t, n, t.getScope().getTypeOfThis());\n             break;\n         case Token.NULL:\n             ensureTyped(t, n, NULL_TYPE);\n             break;\n         case Token.NUMBER:\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.STRING:\n             if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n                 ensureTyped(t, n, STRING_TYPE);\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n-        case Token.GET:\n-        case Token.SET:\n+        case Token.GETTER_DEF:\n+        case Token.SETTER_DEF:\n             break;\n         case Token.ARRAYLIT:\n             ensureTyped(t, n, ARRAY_TYPE);\n             break;\n         case Token.REGEXP:\n             ensureTyped(t, n, REGEXP_TYPE);\n             break;\n         case Token.GETPROP:\n             visitGetProp(t, n, parent);\n             typeable \u003d !(parent.isAssign() \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n             break;\n         case Token.GETELEM:\n             visitGetElem(t, n);\n             typeable \u003d false;\n             break;\n         case Token.VAR:\n             visitVar(t, n);\n             typeable \u003d false;\n             break;\n         case Token.NEW:\n             visitNew(t, n);\n             typeable \u003d true;\n             break;\n         case Token.CALL:\n             visitCall(t, n);\n             typeable \u003d !NodeUtil.isExpressionNode(parent);\n             break;\n         case Token.RETURN:\n             visitReturn(t, n);\n             typeable \u003d false;\n             break;\n         case Token.DEC:\n         case Token.INC:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.NOT:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.VOID:\n             ensureTyped(t, n, VOID_TYPE);\n             break;\n         case Token.TYPEOF:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.BITNOT:\n             childType \u003d getJSType(n.getFirstChild());\n             if (!childType.matchesInt32Context()) {\n                 report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n             }\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.POS:\n         case Token.NEG:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.EQ:\n         case Token.NE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                 if (result !\u003d TernaryValue.UNKNOWN) {\n                     if (n.getType() \u003d\u003d Token.NE) {\n                         result \u003d result.not();\n                     }\n                     report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.SHEQ:\n         case Token.SHNE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                     report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.LT:\n         case Token.LE:\n         case Token.GT:\n         case Token.GE:\n             leftType \u003d getJSType(n.getFirstChild());\n             rightType \u003d getJSType(n.getLastChild());\n             if (rightType.isNumber()) {\n                 validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n             } else if (leftType.isNumber()) {\n                 validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n             } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n             } else {\n                 String message \u003d \"left side of comparison\";\n                 validator.expectString(t, n, leftType, message);\n                 validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                 message \u003d \"right side of comparison\";\n                 validator.expectString(t, n, rightType, message);\n                 validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.IN:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right);\n             validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n             validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.INSTANCEOF:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n             validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n             validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.ASSIGN:\n             visitAssign(t, n);\n             typeable \u003d false;\n             break;\n         case Token.ASSIGN_LSH:\n         case Token.ASSIGN_RSH:\n         case Token.ASSIGN_URSH:\n         case Token.ASSIGN_DIV:\n         case Token.ASSIGN_MOD:\n         case Token.ASSIGN_BITOR:\n         case Token.ASSIGN_BITXOR:\n         case Token.ASSIGN_BITAND:\n         case Token.ASSIGN_SUB:\n         case Token.ASSIGN_ADD:\n         case Token.ASSIGN_MUL:\n         case Token.LSH:\n         case Token.RSH:\n         case Token.URSH:\n         case Token.DIV:\n         case Token.MOD:\n         case Token.BITOR:\n         case Token.BITXOR:\n         case Token.BITAND:\n         case Token.SUB:\n         case Token.ADD:\n         case Token.MUL:\n             visitBinaryOperator(n.getType(), t, n);\n             break;\n         case Token.DELPROP:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.CASE:\n             JSType switchType \u003d getJSType(parent.getFirstChild());\n             JSType caseType \u003d getJSType(n.getFirstChild());\n             validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n             typeable \u003d false;\n             break;\n         case Token.WITH:\n             {\n                 Node child \u003d n.getFirstChild();\n                 childType \u003d getJSType(child);\n                 validator.expectObject(t, child, childType, \"with requires an object\");\n                 typeable \u003d false;\n                 break;\n             }\n         case Token.FUNCTION:\n             visitFunction(t, n);\n             break;\n         case Token.LABEL:\n         case Token.LABEL_NAME:\n         case Token.SWITCH:\n         case Token.BREAK:\n         case Token.CATCH:\n         case Token.TRY:\n         case Token.SCRIPT:\n         case Token.EXPR_RESULT:\n         case Token.BLOCK:\n         case Token.EMPTY:\n-        case Token.DEFAULT:\n+        case Token.DEFAULT_CASE:\n         case Token.CONTINUE:\n         case Token.DEBUGGER:\n         case Token.THROW:\n             typeable \u003d false;\n             break;\n         case Token.DO:\n         case Token.FOR:\n         case Token.IF:\n         case Token.WHILE:\n             typeable \u003d false;\n             break;\n         case Token.AND:\n         case Token.HOOK:\n         case Token.OBJECTLIT:\n         case Token.OR:\n             if (n.getJSType() !\u003d null) {\n                 ensureTyped(t, n);\n             } else {\n                 if ((n.isObjectLit()) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                     ensureTyped(t, n, parent.getJSType());\n                 } else {\n                     ensureTyped(t, n);\n                 }\n             }\n             if (n.isObjectLit()) {\n                 for (Node key : n.children()) {\n                     visitObjLitKey(t, key, n);\n                 }\n             }\n             break;\n         default:\n             report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n             ensureTyped(t, n);\n             break;\n     }\n     typeable \u003d typeable \u0026\u0026 !inExterns;\n     if (typeable) {\n         doPercentTypedAccounting(t, n);\n     }\n     checkNoTypeCheckSection(n, false);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ec324a9bb23eb78c76f537f4c4170ba88d542f1c": {
      "type": "Ybodychange",
      "commitMessage": "\nReplace the bulk of the Node.getType() \u003d\u003d Token.XXX calls with\nNode.isXXX calls.\n\nR\u003dnicksantos\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3677\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1582 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/10/11, 8:36 AM",
      "commitName": "ec324a9bb23eb78c76f537f4c4170ba88d542f1c",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "11/8/11, 12:25 PM",
      "commitNameOld": "9d8201624c22636577d47a40aa03de44363b695b",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 1.84,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    boolean typeable \u003d true;\n    switch(n.getType()) {\n        case Token.NAME:\n            typeable \u003d visitName(t, n, parent);\n            break;\n        case Token.LP:\n            if (parent.getType() !\u003d Token.FUNCTION) {\n                ensureTyped(t, n, getJSType(n.getFirstChild()));\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.COMMA:\n            ensureTyped(t, n, getJSType(n.getLastChild()));\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.THIS:\n            ensureTyped(t, n, t.getScope().getTypeOfThis());\n            break;\n        case Token.NULL:\n            ensureTyped(t, n, NULL_TYPE);\n            break;\n        case Token.NUMBER:\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.STRING:\n            if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n                ensureTyped(t, n, STRING_TYPE);\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.GET:\n        case Token.SET:\n            break;\n        case Token.ARRAYLIT:\n            ensureTyped(t, n, ARRAY_TYPE);\n            break;\n        case Token.REGEXP:\n            ensureTyped(t, n, REGEXP_TYPE);\n            break;\n        case Token.GETPROP:\n            visitGetProp(t, n, parent);\n            typeable \u003d !(parent.isAssign() \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n            break;\n        case Token.GETELEM:\n            visitGetElem(t, n);\n            typeable \u003d false;\n            break;\n        case Token.VAR:\n            visitVar(t, n);\n            typeable \u003d false;\n            break;\n        case Token.NEW:\n            visitNew(t, n);\n            typeable \u003d true;\n            break;\n        case Token.CALL:\n            visitCall(t, n);\n            typeable \u003d !NodeUtil.isExpressionNode(parent);\n            break;\n        case Token.RETURN:\n            visitReturn(t, n);\n            typeable \u003d false;\n            break;\n        case Token.DEC:\n        case Token.INC:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.NOT:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.VOID:\n            ensureTyped(t, n, VOID_TYPE);\n            break;\n        case Token.TYPEOF:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.BITNOT:\n            childType \u003d getJSType(n.getFirstChild());\n            if (!childType.matchesInt32Context()) {\n                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n            }\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.EQ:\n        case Token.NE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                if (result !\u003d TernaryValue.UNKNOWN) {\n                    if (n.getType() \u003d\u003d Token.NE) {\n                        result \u003d result.not();\n                    }\n                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.SHEQ:\n        case Token.SHNE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                    report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n            leftType \u003d getJSType(n.getFirstChild());\n            rightType \u003d getJSType(n.getLastChild());\n            if (rightType.isNumber()) {\n                validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n            } else if (leftType.isNumber()) {\n                validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n            } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n            } else {\n                String message \u003d \"left side of comparison\";\n                validator.expectString(t, n, leftType, message);\n                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                message \u003d \"right side of comparison\";\n                validator.expectString(t, n, rightType, message);\n                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.IN:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right);\n            validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n            validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.INSTANCEOF:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n            validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n            validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.ASSIGN:\n            visitAssign(t, n);\n            typeable \u003d false;\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.ASSIGN_URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_SUB:\n        case Token.ASSIGN_ADD:\n        case Token.ASSIGN_MUL:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.URSH:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITOR:\n        case Token.BITXOR:\n        case Token.BITAND:\n        case Token.SUB:\n        case Token.ADD:\n        case Token.MUL:\n            visitBinaryOperator(n.getType(), t, n);\n            break;\n        case Token.DELPROP:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.CASE:\n            JSType switchType \u003d getJSType(parent.getFirstChild());\n            JSType caseType \u003d getJSType(n.getFirstChild());\n            validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n            typeable \u003d false;\n            break;\n        case Token.WITH:\n            {\n                Node child \u003d n.getFirstChild();\n                childType \u003d getJSType(child);\n                validator.expectObject(t, child, childType, \"with requires an object\");\n                typeable \u003d false;\n                break;\n            }\n        case Token.FUNCTION:\n            visitFunction(t, n);\n            break;\n        case Token.LABEL:\n        case Token.LABEL_NAME:\n        case Token.SWITCH:\n        case Token.BREAK:\n        case Token.CATCH:\n        case Token.TRY:\n        case Token.SCRIPT:\n        case Token.EXPR_RESULT:\n        case Token.BLOCK:\n        case Token.EMPTY:\n        case Token.DEFAULT:\n        case Token.CONTINUE:\n        case Token.DEBUGGER:\n        case Token.THROW:\n            typeable \u003d false;\n            break;\n        case Token.DO:\n        case Token.FOR:\n        case Token.IF:\n        case Token.WHILE:\n            typeable \u003d false;\n            break;\n        case Token.AND:\n        case Token.HOOK:\n        case Token.OBJECTLIT:\n        case Token.OR:\n            if (n.getJSType() !\u003d null) {\n                ensureTyped(t, n);\n            } else {\n                if ((n.isObjectLit()) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                    ensureTyped(t, n, parent.getJSType());\n                } else {\n                    ensureTyped(t, n);\n                }\n            }\n            if (n.isObjectLit()) {\n                for (Node key : n.children()) {\n                    visitObjLitKey(t, key, n);\n                }\n            }\n            break;\n        default:\n            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n            ensureTyped(t, n);\n            break;\n    }\n    typeable \u003d typeable \u0026\u0026 !inExterns;\n    if (typeable) {\n        doPercentTypedAccounting(t, n);\n    }\n    checkNoTypeCheckSection(n, false);\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 461,
      "functionName": "visit",
      "functionAnnotation": "@Override",
      "functionDoc": "This is the meat of the type checking.  It is basically one big switch,\nwith each case representing one type of parse tree node.  The individual\ncases are usually pretty straightforward.\n\n@param t The node traversal object that supplies context, such as the\nscope chain to use in name lookups as well as error reporting.\n@param n The node being visited.\n@param parent The parent of the node n.\n",
      "diff": "@@ -1,270 +1,270 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n     JSType childType;\n     JSType leftType, rightType;\n     Node left, right;\n     boolean typeable \u003d true;\n     switch(n.getType()) {\n         case Token.NAME:\n             typeable \u003d visitName(t, n, parent);\n             break;\n         case Token.LP:\n             if (parent.getType() !\u003d Token.FUNCTION) {\n                 ensureTyped(t, n, getJSType(n.getFirstChild()));\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.COMMA:\n             ensureTyped(t, n, getJSType(n.getLastChild()));\n             break;\n         case Token.TRUE:\n         case Token.FALSE:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.THIS:\n             ensureTyped(t, n, t.getScope().getTypeOfThis());\n             break;\n         case Token.NULL:\n             ensureTyped(t, n, NULL_TYPE);\n             break;\n         case Token.NUMBER:\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.STRING:\n             if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n                 ensureTyped(t, n, STRING_TYPE);\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.GET:\n         case Token.SET:\n             break;\n         case Token.ARRAYLIT:\n             ensureTyped(t, n, ARRAY_TYPE);\n             break;\n         case Token.REGEXP:\n             ensureTyped(t, n, REGEXP_TYPE);\n             break;\n         case Token.GETPROP:\n             visitGetProp(t, n, parent);\n-            typeable \u003d !(parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n+            typeable \u003d !(parent.isAssign() \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n             break;\n         case Token.GETELEM:\n             visitGetElem(t, n);\n             typeable \u003d false;\n             break;\n         case Token.VAR:\n             visitVar(t, n);\n             typeable \u003d false;\n             break;\n         case Token.NEW:\n             visitNew(t, n);\n             typeable \u003d true;\n             break;\n         case Token.CALL:\n             visitCall(t, n);\n             typeable \u003d !NodeUtil.isExpressionNode(parent);\n             break;\n         case Token.RETURN:\n             visitReturn(t, n);\n             typeable \u003d false;\n             break;\n         case Token.DEC:\n         case Token.INC:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.NOT:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.VOID:\n             ensureTyped(t, n, VOID_TYPE);\n             break;\n         case Token.TYPEOF:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.BITNOT:\n             childType \u003d getJSType(n.getFirstChild());\n             if (!childType.matchesInt32Context()) {\n                 report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n             }\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.POS:\n         case Token.NEG:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.EQ:\n         case Token.NE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                 if (result !\u003d TernaryValue.UNKNOWN) {\n                     if (n.getType() \u003d\u003d Token.NE) {\n                         result \u003d result.not();\n                     }\n                     report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.SHEQ:\n         case Token.SHNE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                     report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.LT:\n         case Token.LE:\n         case Token.GT:\n         case Token.GE:\n             leftType \u003d getJSType(n.getFirstChild());\n             rightType \u003d getJSType(n.getLastChild());\n             if (rightType.isNumber()) {\n                 validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n             } else if (leftType.isNumber()) {\n                 validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n             } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n             } else {\n                 String message \u003d \"left side of comparison\";\n                 validator.expectString(t, n, leftType, message);\n                 validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                 message \u003d \"right side of comparison\";\n                 validator.expectString(t, n, rightType, message);\n                 validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.IN:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right);\n             validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n             validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.INSTANCEOF:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n             validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n             validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.ASSIGN:\n             visitAssign(t, n);\n             typeable \u003d false;\n             break;\n         case Token.ASSIGN_LSH:\n         case Token.ASSIGN_RSH:\n         case Token.ASSIGN_URSH:\n         case Token.ASSIGN_DIV:\n         case Token.ASSIGN_MOD:\n         case Token.ASSIGN_BITOR:\n         case Token.ASSIGN_BITXOR:\n         case Token.ASSIGN_BITAND:\n         case Token.ASSIGN_SUB:\n         case Token.ASSIGN_ADD:\n         case Token.ASSIGN_MUL:\n         case Token.LSH:\n         case Token.RSH:\n         case Token.URSH:\n         case Token.DIV:\n         case Token.MOD:\n         case Token.BITOR:\n         case Token.BITXOR:\n         case Token.BITAND:\n         case Token.SUB:\n         case Token.ADD:\n         case Token.MUL:\n             visitBinaryOperator(n.getType(), t, n);\n             break;\n         case Token.DELPROP:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.CASE:\n             JSType switchType \u003d getJSType(parent.getFirstChild());\n             JSType caseType \u003d getJSType(n.getFirstChild());\n             validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n             typeable \u003d false;\n             break;\n         case Token.WITH:\n             {\n                 Node child \u003d n.getFirstChild();\n                 childType \u003d getJSType(child);\n                 validator.expectObject(t, child, childType, \"with requires an object\");\n                 typeable \u003d false;\n                 break;\n             }\n         case Token.FUNCTION:\n             visitFunction(t, n);\n             break;\n         case Token.LABEL:\n         case Token.LABEL_NAME:\n         case Token.SWITCH:\n         case Token.BREAK:\n         case Token.CATCH:\n         case Token.TRY:\n         case Token.SCRIPT:\n         case Token.EXPR_RESULT:\n         case Token.BLOCK:\n         case Token.EMPTY:\n         case Token.DEFAULT:\n         case Token.CONTINUE:\n         case Token.DEBUGGER:\n         case Token.THROW:\n             typeable \u003d false;\n             break;\n         case Token.DO:\n         case Token.FOR:\n         case Token.IF:\n         case Token.WHILE:\n             typeable \u003d false;\n             break;\n         case Token.AND:\n         case Token.HOOK:\n         case Token.OBJECTLIT:\n         case Token.OR:\n             if (n.getJSType() !\u003d null) {\n                 ensureTyped(t, n);\n             } else {\n-                if ((n.getType() \u003d\u003d Token.OBJECTLIT) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n+                if ((n.isObjectLit()) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                     ensureTyped(t, n, parent.getJSType());\n                 } else {\n                     ensureTyped(t, n);\n                 }\n             }\n-            if (n.getType() \u003d\u003d Token.OBJECTLIT) {\n+            if (n.isObjectLit()) {\n                 for (Node key : n.children()) {\n                     visitObjLitKey(t, key, n);\n                 }\n             }\n             break;\n         default:\n             report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n             ensureTyped(t, n);\n             break;\n     }\n     typeable \u003d typeable \u0026\u0026 !inExterns;\n     if (typeable) {\n         doPercentTypedAccounting(t, n);\n     }\n     checkNoTypeCheckSection(n, false);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6641663fa9970c4d7bcdd96a6f31b83b18c3ee3d": {
      "type": "Ybodychange",
      "commitMessage": "\nRemove unused Token ids.\n\nR\u003dnicksantos\nDELTA\u003d1258  (4 added, 1244 deleted, 10 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3647\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1562 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/7/11, 2:21 PM",
      "commitName": "6641663fa9970c4d7bcdd96a6f31b83b18c3ee3d",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "10/12/11, 8:07 PM",
      "commitNameOld": "9614c7c0ffe2418359fe91be2a0e61400142237d",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 25.8,
      "commitsBetweenForRepo": 43,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    boolean typeable \u003d true;\n    switch(n.getType()) {\n        case Token.NAME:\n            typeable \u003d visitName(t, n, parent);\n            break;\n        case Token.LP:\n            if (parent.getType() !\u003d Token.FUNCTION) {\n                ensureTyped(t, n, getJSType(n.getFirstChild()));\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.COMMA:\n            ensureTyped(t, n, getJSType(n.getLastChild()));\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.THIS:\n            ensureTyped(t, n, t.getScope().getTypeOfThis());\n            break;\n        case Token.NULL:\n            ensureTyped(t, n, NULL_TYPE);\n            break;\n        case Token.NUMBER:\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.STRING:\n            if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n                ensureTyped(t, n, STRING_TYPE);\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.GET:\n        case Token.SET:\n            break;\n        case Token.ARRAYLIT:\n            ensureTyped(t, n, ARRAY_TYPE);\n            break;\n        case Token.REGEXP:\n            ensureTyped(t, n, REGEXP_TYPE);\n            break;\n        case Token.GETPROP:\n            visitGetProp(t, n, parent);\n            typeable \u003d !(parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n            break;\n        case Token.GETELEM:\n            visitGetElem(t, n);\n            typeable \u003d false;\n            break;\n        case Token.VAR:\n            visitVar(t, n);\n            typeable \u003d false;\n            break;\n        case Token.NEW:\n            visitNew(t, n);\n            typeable \u003d true;\n            break;\n        case Token.CALL:\n            visitCall(t, n);\n            typeable \u003d !NodeUtil.isExpressionNode(parent);\n            break;\n        case Token.RETURN:\n            visitReturn(t, n);\n            typeable \u003d false;\n            break;\n        case Token.DEC:\n        case Token.INC:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.NOT:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.VOID:\n            ensureTyped(t, n, VOID_TYPE);\n            break;\n        case Token.TYPEOF:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.BITNOT:\n            childType \u003d getJSType(n.getFirstChild());\n            if (!childType.matchesInt32Context()) {\n                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n            }\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.EQ:\n        case Token.NE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                if (result !\u003d TernaryValue.UNKNOWN) {\n                    if (n.getType() \u003d\u003d Token.NE) {\n                        result \u003d result.not();\n                    }\n                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.SHEQ:\n        case Token.SHNE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                    report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n            leftType \u003d getJSType(n.getFirstChild());\n            rightType \u003d getJSType(n.getLastChild());\n            if (rightType.isNumber()) {\n                validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n            } else if (leftType.isNumber()) {\n                validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n            } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n            } else {\n                String message \u003d \"left side of comparison\";\n                validator.expectString(t, n, leftType, message);\n                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                message \u003d \"right side of comparison\";\n                validator.expectString(t, n, rightType, message);\n                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.IN:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right);\n            validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n            validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.INSTANCEOF:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n            validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n            validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.ASSIGN:\n            visitAssign(t, n);\n            typeable \u003d false;\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.ASSIGN_URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_SUB:\n        case Token.ASSIGN_ADD:\n        case Token.ASSIGN_MUL:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.URSH:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITOR:\n        case Token.BITXOR:\n        case Token.BITAND:\n        case Token.SUB:\n        case Token.ADD:\n        case Token.MUL:\n            visitBinaryOperator(n.getType(), t, n);\n            break;\n        case Token.DELPROP:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.CASE:\n            JSType switchType \u003d getJSType(parent.getFirstChild());\n            JSType caseType \u003d getJSType(n.getFirstChild());\n            validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n            typeable \u003d false;\n            break;\n        case Token.WITH:\n            {\n                Node child \u003d n.getFirstChild();\n                childType \u003d getJSType(child);\n                validator.expectObject(t, child, childType, \"with requires an object\");\n                typeable \u003d false;\n                break;\n            }\n        case Token.FUNCTION:\n            visitFunction(t, n);\n            break;\n        case Token.LABEL:\n        case Token.LABEL_NAME:\n        case Token.SWITCH:\n        case Token.BREAK:\n        case Token.CATCH:\n        case Token.TRY:\n        case Token.SCRIPT:\n        case Token.EXPR_RESULT:\n        case Token.BLOCK:\n        case Token.EMPTY:\n        case Token.DEFAULT:\n        case Token.CONTINUE:\n        case Token.DEBUGGER:\n        case Token.THROW:\n            typeable \u003d false;\n            break;\n        case Token.DO:\n        case Token.FOR:\n        case Token.IF:\n        case Token.WHILE:\n            typeable \u003d false;\n            break;\n        case Token.AND:\n        case Token.HOOK:\n        case Token.OBJECTLIT:\n        case Token.OR:\n            if (n.getJSType() !\u003d null) {\n                ensureTyped(t, n);\n            } else {\n                if ((n.getType() \u003d\u003d Token.OBJECTLIT) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                    ensureTyped(t, n, parent.getJSType());\n                } else {\n                    ensureTyped(t, n);\n                }\n            }\n            if (n.getType() \u003d\u003d Token.OBJECTLIT) {\n                for (Node key : n.children()) {\n                    visitObjLitKey(t, key, n);\n                }\n            }\n            break;\n        default:\n            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n            ensureTyped(t, n);\n            break;\n    }\n    typeable \u003d typeable \u0026\u0026 !inExterns;\n    if (typeable) {\n        doPercentTypedAccounting(t, n);\n    }\n    checkNoTypeCheckSection(n, false);\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 461,
      "functionName": "visit",
      "functionAnnotation": "@Override",
      "functionDoc": "This is the meat of the type checking.  It is basically one big switch,\nwith each case representing one type of parse tree node.  The individual\ncases are usually pretty straightforward.\n\n@param t The node traversal object that supplies context, such as the\nscope chain to use in name lookups as well as error reporting.\n@param n The node being visited.\n@param parent The parent of the node n.\n",
      "diff": "@@ -1,276 +1,270 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n     JSType childType;\n     JSType leftType, rightType;\n     Node left, right;\n     boolean typeable \u003d true;\n     switch(n.getType()) {\n         case Token.NAME:\n             typeable \u003d visitName(t, n, parent);\n             break;\n         case Token.LP:\n             if (parent.getType() !\u003d Token.FUNCTION) {\n                 ensureTyped(t, n, getJSType(n.getFirstChild()));\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.COMMA:\n             ensureTyped(t, n, getJSType(n.getLastChild()));\n             break;\n         case Token.TRUE:\n         case Token.FALSE:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.THIS:\n             ensureTyped(t, n, t.getScope().getTypeOfThis());\n             break;\n-        case Token.REF_SPECIAL:\n-            ensureTyped(t, n);\n-            break;\n-        case Token.GET_REF:\n-            ensureTyped(t, n, getJSType(n.getFirstChild()));\n-            break;\n         case Token.NULL:\n             ensureTyped(t, n, NULL_TYPE);\n             break;\n         case Token.NUMBER:\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.STRING:\n             if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n                 ensureTyped(t, n, STRING_TYPE);\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.GET:\n         case Token.SET:\n             break;\n         case Token.ARRAYLIT:\n             ensureTyped(t, n, ARRAY_TYPE);\n             break;\n         case Token.REGEXP:\n             ensureTyped(t, n, REGEXP_TYPE);\n             break;\n         case Token.GETPROP:\n             visitGetProp(t, n, parent);\n             typeable \u003d !(parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n             break;\n         case Token.GETELEM:\n             visitGetElem(t, n);\n             typeable \u003d false;\n             break;\n         case Token.VAR:\n             visitVar(t, n);\n             typeable \u003d false;\n             break;\n         case Token.NEW:\n             visitNew(t, n);\n             typeable \u003d true;\n             break;\n         case Token.CALL:\n             visitCall(t, n);\n             typeable \u003d !NodeUtil.isExpressionNode(parent);\n             break;\n         case Token.RETURN:\n             visitReturn(t, n);\n             typeable \u003d false;\n             break;\n         case Token.DEC:\n         case Token.INC:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.NOT:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.VOID:\n             ensureTyped(t, n, VOID_TYPE);\n             break;\n         case Token.TYPEOF:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.BITNOT:\n             childType \u003d getJSType(n.getFirstChild());\n             if (!childType.matchesInt32Context()) {\n                 report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n             }\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.POS:\n         case Token.NEG:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.EQ:\n         case Token.NE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                 if (result !\u003d TernaryValue.UNKNOWN) {\n                     if (n.getType() \u003d\u003d Token.NE) {\n                         result \u003d result.not();\n                     }\n                     report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.SHEQ:\n         case Token.SHNE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                     report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.LT:\n         case Token.LE:\n         case Token.GT:\n         case Token.GE:\n             leftType \u003d getJSType(n.getFirstChild());\n             rightType \u003d getJSType(n.getLastChild());\n             if (rightType.isNumber()) {\n                 validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n             } else if (leftType.isNumber()) {\n                 validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n             } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n             } else {\n                 String message \u003d \"left side of comparison\";\n                 validator.expectString(t, n, leftType, message);\n                 validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                 message \u003d \"right side of comparison\";\n                 validator.expectString(t, n, rightType, message);\n                 validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.IN:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right);\n             validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n             validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.INSTANCEOF:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n             validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n             validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.ASSIGN:\n             visitAssign(t, n);\n             typeable \u003d false;\n             break;\n         case Token.ASSIGN_LSH:\n         case Token.ASSIGN_RSH:\n         case Token.ASSIGN_URSH:\n         case Token.ASSIGN_DIV:\n         case Token.ASSIGN_MOD:\n         case Token.ASSIGN_BITOR:\n         case Token.ASSIGN_BITXOR:\n         case Token.ASSIGN_BITAND:\n         case Token.ASSIGN_SUB:\n         case Token.ASSIGN_ADD:\n         case Token.ASSIGN_MUL:\n         case Token.LSH:\n         case Token.RSH:\n         case Token.URSH:\n         case Token.DIV:\n         case Token.MOD:\n         case Token.BITOR:\n         case Token.BITXOR:\n         case Token.BITAND:\n         case Token.SUB:\n         case Token.ADD:\n         case Token.MUL:\n             visitBinaryOperator(n.getType(), t, n);\n             break;\n         case Token.DELPROP:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.CASE:\n             JSType switchType \u003d getJSType(parent.getFirstChild());\n             JSType caseType \u003d getJSType(n.getFirstChild());\n             validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n             typeable \u003d false;\n             break;\n         case Token.WITH:\n             {\n                 Node child \u003d n.getFirstChild();\n                 childType \u003d getJSType(child);\n                 validator.expectObject(t, child, childType, \"with requires an object\");\n                 typeable \u003d false;\n                 break;\n             }\n         case Token.FUNCTION:\n             visitFunction(t, n);\n             break;\n         case Token.LABEL:\n         case Token.LABEL_NAME:\n         case Token.SWITCH:\n         case Token.BREAK:\n         case Token.CATCH:\n         case Token.TRY:\n         case Token.SCRIPT:\n         case Token.EXPR_RESULT:\n         case Token.BLOCK:\n         case Token.EMPTY:\n         case Token.DEFAULT:\n         case Token.CONTINUE:\n         case Token.DEBUGGER:\n         case Token.THROW:\n             typeable \u003d false;\n             break;\n         case Token.DO:\n         case Token.FOR:\n         case Token.IF:\n         case Token.WHILE:\n             typeable \u003d false;\n             break;\n         case Token.AND:\n         case Token.HOOK:\n         case Token.OBJECTLIT:\n         case Token.OR:\n             if (n.getJSType() !\u003d null) {\n                 ensureTyped(t, n);\n             } else {\n                 if ((n.getType() \u003d\u003d Token.OBJECTLIT) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                     ensureTyped(t, n, parent.getJSType());\n                 } else {\n                     ensureTyped(t, n);\n                 }\n             }\n             if (n.getType() \u003d\u003d Token.OBJECTLIT) {\n                 for (Node key : n.children()) {\n                     visitObjLitKey(t, key, n);\n                 }\n             }\n             break;\n         default:\n             report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n             ensureTyped(t, n);\n             break;\n     }\n     typeable \u003d typeable \u0026\u0026 !inExterns;\n     if (typeable) {\n         doPercentTypedAccounting(t, n);\n     }\n     checkNoTypeCheckSection(n, false);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "76abdf11394c0e7515ae63335676ea3657badb45": {
      "type": "Yannotationchange",
      "commitMessage": "\nMake our build warnings free.\n\nR\u003dacleung\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d2830\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1301 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "7/28/11, 4:19 PM",
      "commitName": "76abdf11394c0e7515ae63335676ea3657badb45",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "6/9/11, 12:01 PM",
      "commitNameOld": "0235adc719d0858653861b8ced39a1d057cf93a0",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 49.18,
      "commitsBetweenForRepo": 124,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    boolean typeable \u003d true;\n    switch(n.getType()) {\n        case Token.NAME:\n            typeable \u003d visitName(t, n, parent);\n            break;\n        case Token.LP:\n            if (parent.getType() !\u003d Token.FUNCTION) {\n                ensureTyped(t, n, getJSType(n.getFirstChild()));\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.COMMA:\n            ensureTyped(t, n, getJSType(n.getLastChild()));\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.THIS:\n            ensureTyped(t, n, t.getScope().getTypeOfThis());\n            break;\n        case Token.REF_SPECIAL:\n            ensureTyped(t, n);\n            break;\n        case Token.GET_REF:\n            ensureTyped(t, n, getJSType(n.getFirstChild()));\n            break;\n        case Token.NULL:\n            ensureTyped(t, n, NULL_TYPE);\n            break;\n        case Token.NUMBER:\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.STRING:\n            if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n                ensureTyped(t, n, STRING_TYPE);\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.GET:\n        case Token.SET:\n            break;\n        case Token.ARRAYLIT:\n            ensureTyped(t, n, ARRAY_TYPE);\n            break;\n        case Token.REGEXP:\n            ensureTyped(t, n, REGEXP_TYPE);\n            break;\n        case Token.GETPROP:\n            visitGetProp(t, n, parent);\n            typeable \u003d !(parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n            break;\n        case Token.GETELEM:\n            visitGetElem(t, n);\n            typeable \u003d false;\n            break;\n        case Token.VAR:\n            visitVar(t, n);\n            typeable \u003d false;\n            break;\n        case Token.NEW:\n            visitNew(t, n);\n            typeable \u003d true;\n            break;\n        case Token.CALL:\n            visitCall(t, n);\n            typeable \u003d !NodeUtil.isExpressionNode(parent);\n            break;\n        case Token.RETURN:\n            visitReturn(t, n);\n            typeable \u003d false;\n            break;\n        case Token.DEC:\n        case Token.INC:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.NOT:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.VOID:\n            ensureTyped(t, n, VOID_TYPE);\n            break;\n        case Token.TYPEOF:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.BITNOT:\n            childType \u003d getJSType(n.getFirstChild());\n            if (!childType.matchesInt32Context()) {\n                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n            }\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.EQ:\n        case Token.NE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                if (result !\u003d TernaryValue.UNKNOWN) {\n                    if (n.getType() \u003d\u003d Token.NE) {\n                        result \u003d result.not();\n                    }\n                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.SHEQ:\n        case Token.SHNE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                    report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n            leftType \u003d getJSType(n.getFirstChild());\n            rightType \u003d getJSType(n.getLastChild());\n            if (rightType.isNumber()) {\n                validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n            } else if (leftType.isNumber()) {\n                validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n            } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n            } else {\n                String message \u003d \"left side of comparison\";\n                validator.expectString(t, n, leftType, message);\n                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                message \u003d \"right side of comparison\";\n                validator.expectString(t, n, rightType, message);\n                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.IN:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right);\n            validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n            validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.INSTANCEOF:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n            validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n            validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.ASSIGN:\n            visitAssign(t, n);\n            typeable \u003d false;\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.ASSIGN_URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_SUB:\n        case Token.ASSIGN_ADD:\n        case Token.ASSIGN_MUL:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.URSH:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITOR:\n        case Token.BITXOR:\n        case Token.BITAND:\n        case Token.SUB:\n        case Token.ADD:\n        case Token.MUL:\n            visitBinaryOperator(n.getType(), t, n);\n            break;\n        case Token.DELPROP:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.CASE:\n            JSType switchType \u003d getJSType(parent.getFirstChild());\n            JSType caseType \u003d getJSType(n.getFirstChild());\n            validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n            typeable \u003d false;\n            break;\n        case Token.WITH:\n            {\n                Node child \u003d n.getFirstChild();\n                childType \u003d getJSType(child);\n                validator.expectObject(t, child, childType, \"with requires an object\");\n                typeable \u003d false;\n                break;\n            }\n        case Token.FUNCTION:\n            visitFunction(t, n);\n            break;\n        case Token.LABEL:\n        case Token.LABEL_NAME:\n        case Token.SWITCH:\n        case Token.BREAK:\n        case Token.CATCH:\n        case Token.TRY:\n        case Token.SCRIPT:\n        case Token.EXPR_RESULT:\n        case Token.BLOCK:\n        case Token.EMPTY:\n        case Token.DEFAULT:\n        case Token.CONTINUE:\n        case Token.DEBUGGER:\n        case Token.THROW:\n            typeable \u003d false;\n            break;\n        case Token.DO:\n        case Token.FOR:\n        case Token.IF:\n        case Token.WHILE:\n            typeable \u003d false;\n            break;\n        case Token.AND:\n        case Token.HOOK:\n        case Token.OBJECTLIT:\n        case Token.OR:\n            if (n.getJSType() !\u003d null) {\n                ensureTyped(t, n);\n            } else {\n                if ((n.getType() \u003d\u003d Token.OBJECTLIT) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                    ensureTyped(t, n, parent.getJSType());\n                } else {\n                    ensureTyped(t, n);\n                }\n            }\n            if (n.getType() \u003d\u003d Token.OBJECTLIT) {\n                for (Node key : n.children()) {\n                    visitObjLitKey(t, key, n);\n                }\n            }\n            break;\n        default:\n            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n            ensureTyped(t, n);\n            break;\n    }\n    typeable \u003d typeable \u0026\u0026 !inExterns;\n    if (typeable) {\n        doPercentTypedAccounting(t, n);\n    }\n    checkNoTypeCheckSection(n, false);\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 464,
      "functionName": "visit",
      "functionAnnotation": "@Override",
      "functionDoc": "This is the meat of the type checking.  It is basically one big switch,\nwith each case representing one type of parse tree node.  The individual\ncases are usually pretty straightforward.\n\n@param t The node traversal object that supplies context, such as the\nscope chain to use in name lookups as well as error reporting.\n@param n The node being visited.\n@param parent The parent of the node n.\n",
      "diff": "@@ -1,275 +1,276 @@\n+@Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n     JSType childType;\n     JSType leftType, rightType;\n     Node left, right;\n     boolean typeable \u003d true;\n     switch(n.getType()) {\n         case Token.NAME:\n             typeable \u003d visitName(t, n, parent);\n             break;\n         case Token.LP:\n             if (parent.getType() !\u003d Token.FUNCTION) {\n                 ensureTyped(t, n, getJSType(n.getFirstChild()));\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.COMMA:\n             ensureTyped(t, n, getJSType(n.getLastChild()));\n             break;\n         case Token.TRUE:\n         case Token.FALSE:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.THIS:\n             ensureTyped(t, n, t.getScope().getTypeOfThis());\n             break;\n         case Token.REF_SPECIAL:\n             ensureTyped(t, n);\n             break;\n         case Token.GET_REF:\n             ensureTyped(t, n, getJSType(n.getFirstChild()));\n             break;\n         case Token.NULL:\n             ensureTyped(t, n, NULL_TYPE);\n             break;\n         case Token.NUMBER:\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.STRING:\n             if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n                 ensureTyped(t, n, STRING_TYPE);\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.GET:\n         case Token.SET:\n             break;\n         case Token.ARRAYLIT:\n             ensureTyped(t, n, ARRAY_TYPE);\n             break;\n         case Token.REGEXP:\n             ensureTyped(t, n, REGEXP_TYPE);\n             break;\n         case Token.GETPROP:\n             visitGetProp(t, n, parent);\n             typeable \u003d !(parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n             break;\n         case Token.GETELEM:\n             visitGetElem(t, n);\n             typeable \u003d false;\n             break;\n         case Token.VAR:\n             visitVar(t, n);\n             typeable \u003d false;\n             break;\n         case Token.NEW:\n             visitNew(t, n);\n             typeable \u003d true;\n             break;\n         case Token.CALL:\n             visitCall(t, n);\n             typeable \u003d !NodeUtil.isExpressionNode(parent);\n             break;\n         case Token.RETURN:\n             visitReturn(t, n);\n             typeable \u003d false;\n             break;\n         case Token.DEC:\n         case Token.INC:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.NOT:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.VOID:\n             ensureTyped(t, n, VOID_TYPE);\n             break;\n         case Token.TYPEOF:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.BITNOT:\n             childType \u003d getJSType(n.getFirstChild());\n             if (!childType.matchesInt32Context()) {\n                 report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n             }\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.POS:\n         case Token.NEG:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.EQ:\n         case Token.NE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                 if (result !\u003d TernaryValue.UNKNOWN) {\n                     if (n.getType() \u003d\u003d Token.NE) {\n                         result \u003d result.not();\n                     }\n                     report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.SHEQ:\n         case Token.SHNE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                     report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.LT:\n         case Token.LE:\n         case Token.GT:\n         case Token.GE:\n             leftType \u003d getJSType(n.getFirstChild());\n             rightType \u003d getJSType(n.getLastChild());\n             if (rightType.isNumber()) {\n                 validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n             } else if (leftType.isNumber()) {\n                 validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n             } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n             } else {\n                 String message \u003d \"left side of comparison\";\n                 validator.expectString(t, n, leftType, message);\n                 validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                 message \u003d \"right side of comparison\";\n                 validator.expectString(t, n, rightType, message);\n                 validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.IN:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right);\n             validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n             validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.INSTANCEOF:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n             validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n             validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.ASSIGN:\n             visitAssign(t, n);\n             typeable \u003d false;\n             break;\n         case Token.ASSIGN_LSH:\n         case Token.ASSIGN_RSH:\n         case Token.ASSIGN_URSH:\n         case Token.ASSIGN_DIV:\n         case Token.ASSIGN_MOD:\n         case Token.ASSIGN_BITOR:\n         case Token.ASSIGN_BITXOR:\n         case Token.ASSIGN_BITAND:\n         case Token.ASSIGN_SUB:\n         case Token.ASSIGN_ADD:\n         case Token.ASSIGN_MUL:\n         case Token.LSH:\n         case Token.RSH:\n         case Token.URSH:\n         case Token.DIV:\n         case Token.MOD:\n         case Token.BITOR:\n         case Token.BITXOR:\n         case Token.BITAND:\n         case Token.SUB:\n         case Token.ADD:\n         case Token.MUL:\n             visitBinaryOperator(n.getType(), t, n);\n             break;\n         case Token.DELPROP:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.CASE:\n             JSType switchType \u003d getJSType(parent.getFirstChild());\n             JSType caseType \u003d getJSType(n.getFirstChild());\n             validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n             typeable \u003d false;\n             break;\n         case Token.WITH:\n             {\n                 Node child \u003d n.getFirstChild();\n                 childType \u003d getJSType(child);\n                 validator.expectObject(t, child, childType, \"with requires an object\");\n                 typeable \u003d false;\n                 break;\n             }\n         case Token.FUNCTION:\n             visitFunction(t, n);\n             break;\n         case Token.LABEL:\n         case Token.LABEL_NAME:\n         case Token.SWITCH:\n         case Token.BREAK:\n         case Token.CATCH:\n         case Token.TRY:\n         case Token.SCRIPT:\n         case Token.EXPR_RESULT:\n         case Token.BLOCK:\n         case Token.EMPTY:\n         case Token.DEFAULT:\n         case Token.CONTINUE:\n         case Token.DEBUGGER:\n         case Token.THROW:\n             typeable \u003d false;\n             break;\n         case Token.DO:\n         case Token.FOR:\n         case Token.IF:\n         case Token.WHILE:\n             typeable \u003d false;\n             break;\n         case Token.AND:\n         case Token.HOOK:\n         case Token.OBJECTLIT:\n         case Token.OR:\n             if (n.getJSType() !\u003d null) {\n                 ensureTyped(t, n);\n             } else {\n                 if ((n.getType() \u003d\u003d Token.OBJECTLIT) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                     ensureTyped(t, n, parent.getJSType());\n                 } else {\n                     ensureTyped(t, n);\n                 }\n             }\n             if (n.getType() \u003d\u003d Token.OBJECTLIT) {\n                 for (Node key : n.children()) {\n                     visitObjLitKey(t, key, n);\n                 }\n             }\n             break;\n         default:\n             report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n             ensureTyped(t, n);\n             break;\n     }\n     typeable \u003d typeable \u0026\u0026 !inExterns;\n     if (typeable) {\n         doPercentTypedAccounting(t, n);\n     }\n     checkNoTypeCheckSection(n, false);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "",
        "newValue": "@Override"
      }
    },
    "0235adc719d0858653861b8ced39a1d057cf93a0": {
      "type": "Ybodychange",
      "commitMessage": "\nMake DELPROP of a non-reference a parser error\n\nR\u003dacleung\nDELTA\u003d73  (30 added, 39 deleted, 4 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d2230\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1169 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "6/9/11, 12:01 PM",
      "commitName": "0235adc719d0858653861b8ced39a1d057cf93a0",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "6/8/11, 1:18 PM",
      "commitNameOld": "59a30b48325cccadabae8687fdf603d72e26c157",
      "commitAuthorOld": "zhuyi@google.com",
      "daysBetweenCommits": 0.95,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "public void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    boolean typeable \u003d true;\n    switch(n.getType()) {\n        case Token.NAME:\n            typeable \u003d visitName(t, n, parent);\n            break;\n        case Token.LP:\n            if (parent.getType() !\u003d Token.FUNCTION) {\n                ensureTyped(t, n, getJSType(n.getFirstChild()));\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.COMMA:\n            ensureTyped(t, n, getJSType(n.getLastChild()));\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.THIS:\n            ensureTyped(t, n, t.getScope().getTypeOfThis());\n            break;\n        case Token.REF_SPECIAL:\n            ensureTyped(t, n);\n            break;\n        case Token.GET_REF:\n            ensureTyped(t, n, getJSType(n.getFirstChild()));\n            break;\n        case Token.NULL:\n            ensureTyped(t, n, NULL_TYPE);\n            break;\n        case Token.NUMBER:\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.STRING:\n            if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n                ensureTyped(t, n, STRING_TYPE);\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.GET:\n        case Token.SET:\n            break;\n        case Token.ARRAYLIT:\n            ensureTyped(t, n, ARRAY_TYPE);\n            break;\n        case Token.REGEXP:\n            ensureTyped(t, n, REGEXP_TYPE);\n            break;\n        case Token.GETPROP:\n            visitGetProp(t, n, parent);\n            typeable \u003d !(parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n            break;\n        case Token.GETELEM:\n            visitGetElem(t, n);\n            typeable \u003d false;\n            break;\n        case Token.VAR:\n            visitVar(t, n);\n            typeable \u003d false;\n            break;\n        case Token.NEW:\n            visitNew(t, n);\n            typeable \u003d true;\n            break;\n        case Token.CALL:\n            visitCall(t, n);\n            typeable \u003d !NodeUtil.isExpressionNode(parent);\n            break;\n        case Token.RETURN:\n            visitReturn(t, n);\n            typeable \u003d false;\n            break;\n        case Token.DEC:\n        case Token.INC:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.NOT:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.VOID:\n            ensureTyped(t, n, VOID_TYPE);\n            break;\n        case Token.TYPEOF:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.BITNOT:\n            childType \u003d getJSType(n.getFirstChild());\n            if (!childType.matchesInt32Context()) {\n                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n            }\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.EQ:\n        case Token.NE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                if (result !\u003d TernaryValue.UNKNOWN) {\n                    if (n.getType() \u003d\u003d Token.NE) {\n                        result \u003d result.not();\n                    }\n                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.SHEQ:\n        case Token.SHNE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                    report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n            leftType \u003d getJSType(n.getFirstChild());\n            rightType \u003d getJSType(n.getLastChild());\n            if (rightType.isNumber()) {\n                validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n            } else if (leftType.isNumber()) {\n                validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n            } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n            } else {\n                String message \u003d \"left side of comparison\";\n                validator.expectString(t, n, leftType, message);\n                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                message \u003d \"right side of comparison\";\n                validator.expectString(t, n, rightType, message);\n                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.IN:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right);\n            validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n            validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.INSTANCEOF:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n            validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n            validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.ASSIGN:\n            visitAssign(t, n);\n            typeable \u003d false;\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.ASSIGN_URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_SUB:\n        case Token.ASSIGN_ADD:\n        case Token.ASSIGN_MUL:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.URSH:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITOR:\n        case Token.BITXOR:\n        case Token.BITAND:\n        case Token.SUB:\n        case Token.ADD:\n        case Token.MUL:\n            visitBinaryOperator(n.getType(), t, n);\n            break;\n        case Token.DELPROP:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.CASE:\n            JSType switchType \u003d getJSType(parent.getFirstChild());\n            JSType caseType \u003d getJSType(n.getFirstChild());\n            validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n            typeable \u003d false;\n            break;\n        case Token.WITH:\n            {\n                Node child \u003d n.getFirstChild();\n                childType \u003d getJSType(child);\n                validator.expectObject(t, child, childType, \"with requires an object\");\n                typeable \u003d false;\n                break;\n            }\n        case Token.FUNCTION:\n            visitFunction(t, n);\n            break;\n        case Token.LABEL:\n        case Token.LABEL_NAME:\n        case Token.SWITCH:\n        case Token.BREAK:\n        case Token.CATCH:\n        case Token.TRY:\n        case Token.SCRIPT:\n        case Token.EXPR_RESULT:\n        case Token.BLOCK:\n        case Token.EMPTY:\n        case Token.DEFAULT:\n        case Token.CONTINUE:\n        case Token.DEBUGGER:\n        case Token.THROW:\n            typeable \u003d false;\n            break;\n        case Token.DO:\n        case Token.FOR:\n        case Token.IF:\n        case Token.WHILE:\n            typeable \u003d false;\n            break;\n        case Token.AND:\n        case Token.HOOK:\n        case Token.OBJECTLIT:\n        case Token.OR:\n            if (n.getJSType() !\u003d null) {\n                ensureTyped(t, n);\n            } else {\n                if ((n.getType() \u003d\u003d Token.OBJECTLIT) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                    ensureTyped(t, n, parent.getJSType());\n                } else {\n                    ensureTyped(t, n);\n                }\n            }\n            if (n.getType() \u003d\u003d Token.OBJECTLIT) {\n                for (Node key : n.children()) {\n                    visitObjLitKey(t, key, n);\n                }\n            }\n            break;\n        default:\n            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n            ensureTyped(t, n);\n            break;\n    }\n    typeable \u003d typeable \u0026\u0026 !inExterns;\n    if (typeable) {\n        doPercentTypedAccounting(t, n);\n    }\n    checkNoTypeCheckSection(n, false);\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 461,
      "functionName": "visit",
      "functionAnnotation": "",
      "functionDoc": "This is the meat of the type checking.  It is basically one big switch,\nwith each case representing one type of parse tree node.  The individual\ncases are usually pretty straightforward.\n\n@param t The node traversal object that supplies context, such as the\nscope chain to use in name lookups as well as error reporting.\n@param n The node being visited.\n@param parent The parent of the node n.\n",
      "diff": "@@ -1,278 +1,275 @@\n public void visit(NodeTraversal t, Node n, Node parent) {\n     JSType childType;\n     JSType leftType, rightType;\n     Node left, right;\n     boolean typeable \u003d true;\n     switch(n.getType()) {\n         case Token.NAME:\n             typeable \u003d visitName(t, n, parent);\n             break;\n         case Token.LP:\n             if (parent.getType() !\u003d Token.FUNCTION) {\n                 ensureTyped(t, n, getJSType(n.getFirstChild()));\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.COMMA:\n             ensureTyped(t, n, getJSType(n.getLastChild()));\n             break;\n         case Token.TRUE:\n         case Token.FALSE:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.THIS:\n             ensureTyped(t, n, t.getScope().getTypeOfThis());\n             break;\n         case Token.REF_SPECIAL:\n             ensureTyped(t, n);\n             break;\n         case Token.GET_REF:\n             ensureTyped(t, n, getJSType(n.getFirstChild()));\n             break;\n         case Token.NULL:\n             ensureTyped(t, n, NULL_TYPE);\n             break;\n         case Token.NUMBER:\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.STRING:\n             if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n                 ensureTyped(t, n, STRING_TYPE);\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.GET:\n         case Token.SET:\n             break;\n         case Token.ARRAYLIT:\n             ensureTyped(t, n, ARRAY_TYPE);\n             break;\n         case Token.REGEXP:\n             ensureTyped(t, n, REGEXP_TYPE);\n             break;\n         case Token.GETPROP:\n             visitGetProp(t, n, parent);\n             typeable \u003d !(parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n             break;\n         case Token.GETELEM:\n             visitGetElem(t, n);\n             typeable \u003d false;\n             break;\n         case Token.VAR:\n             visitVar(t, n);\n             typeable \u003d false;\n             break;\n         case Token.NEW:\n             visitNew(t, n);\n             typeable \u003d true;\n             break;\n         case Token.CALL:\n             visitCall(t, n);\n             typeable \u003d !NodeUtil.isExpressionNode(parent);\n             break;\n         case Token.RETURN:\n             visitReturn(t, n);\n             typeable \u003d false;\n             break;\n         case Token.DEC:\n         case Token.INC:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.NOT:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.VOID:\n             ensureTyped(t, n, VOID_TYPE);\n             break;\n         case Token.TYPEOF:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.BITNOT:\n             childType \u003d getJSType(n.getFirstChild());\n             if (!childType.matchesInt32Context()) {\n                 report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n             }\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.POS:\n         case Token.NEG:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.EQ:\n         case Token.NE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                 if (result !\u003d TernaryValue.UNKNOWN) {\n                     if (n.getType() \u003d\u003d Token.NE) {\n                         result \u003d result.not();\n                     }\n                     report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.SHEQ:\n         case Token.SHNE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                     report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.LT:\n         case Token.LE:\n         case Token.GT:\n         case Token.GE:\n             leftType \u003d getJSType(n.getFirstChild());\n             rightType \u003d getJSType(n.getLastChild());\n             if (rightType.isNumber()) {\n                 validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n             } else if (leftType.isNumber()) {\n                 validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n             } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n             } else {\n                 String message \u003d \"left side of comparison\";\n                 validator.expectString(t, n, leftType, message);\n                 validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                 message \u003d \"right side of comparison\";\n                 validator.expectString(t, n, rightType, message);\n                 validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.IN:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right);\n             validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n             validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.INSTANCEOF:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n             validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n             validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.ASSIGN:\n             visitAssign(t, n);\n             typeable \u003d false;\n             break;\n         case Token.ASSIGN_LSH:\n         case Token.ASSIGN_RSH:\n         case Token.ASSIGN_URSH:\n         case Token.ASSIGN_DIV:\n         case Token.ASSIGN_MOD:\n         case Token.ASSIGN_BITOR:\n         case Token.ASSIGN_BITXOR:\n         case Token.ASSIGN_BITAND:\n         case Token.ASSIGN_SUB:\n         case Token.ASSIGN_ADD:\n         case Token.ASSIGN_MUL:\n         case Token.LSH:\n         case Token.RSH:\n         case Token.URSH:\n         case Token.DIV:\n         case Token.MOD:\n         case Token.BITOR:\n         case Token.BITXOR:\n         case Token.BITAND:\n         case Token.SUB:\n         case Token.ADD:\n         case Token.MUL:\n             visitBinaryOperator(n.getType(), t, n);\n             break;\n         case Token.DELPROP:\n-            if (!isReference(n.getFirstChild())) {\n-                report(t, n, BAD_DELETE);\n-            }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.CASE:\n             JSType switchType \u003d getJSType(parent.getFirstChild());\n             JSType caseType \u003d getJSType(n.getFirstChild());\n             validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n             typeable \u003d false;\n             break;\n         case Token.WITH:\n             {\n                 Node child \u003d n.getFirstChild();\n                 childType \u003d getJSType(child);\n                 validator.expectObject(t, child, childType, \"with requires an object\");\n                 typeable \u003d false;\n                 break;\n             }\n         case Token.FUNCTION:\n             visitFunction(t, n);\n             break;\n         case Token.LABEL:\n         case Token.LABEL_NAME:\n         case Token.SWITCH:\n         case Token.BREAK:\n         case Token.CATCH:\n         case Token.TRY:\n         case Token.SCRIPT:\n         case Token.EXPR_RESULT:\n         case Token.BLOCK:\n         case Token.EMPTY:\n         case Token.DEFAULT:\n         case Token.CONTINUE:\n         case Token.DEBUGGER:\n         case Token.THROW:\n             typeable \u003d false;\n             break;\n         case Token.DO:\n         case Token.FOR:\n         case Token.IF:\n         case Token.WHILE:\n             typeable \u003d false;\n             break;\n         case Token.AND:\n         case Token.HOOK:\n         case Token.OBJECTLIT:\n         case Token.OR:\n             if (n.getJSType() !\u003d null) {\n                 ensureTyped(t, n);\n             } else {\n                 if ((n.getType() \u003d\u003d Token.OBJECTLIT) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                     ensureTyped(t, n, parent.getJSType());\n                 } else {\n                     ensureTyped(t, n);\n                 }\n             }\n             if (n.getType() \u003d\u003d Token.OBJECTLIT) {\n                 for (Node key : n.children()) {\n                     visitObjLitKey(t, key, n);\n                 }\n             }\n             break;\n         default:\n             report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n             ensureTyped(t, n);\n             break;\n     }\n     typeable \u003d typeable \u0026\u0026 !inExterns;\n     if (typeable) {\n         doPercentTypedAccounting(t, n);\n     }\n     checkNoTypeCheckSection(n, false);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "59a30b48325cccadabae8687fdf603d72e26c157": {
      "type": "Ybodychange",
      "commitMessage": "\nFixes Issue 482\nIn percent typed counting, ignore the nodes of Enum elements\n\nR\u003dacleung\nDELTA\u003d13  (13 added, 0 deleted, 0 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d2202\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1167 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "6/8/11, 1:18 PM",
      "commitName": "59a30b48325cccadabae8687fdf603d72e26c157",
      "commitAuthor": "zhuyi@google.com",
      "commitDateOld": "5/31/11, 8:14 AM",
      "commitNameOld": "63df133d0850805818d1e280ba47dcefc9763c89",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 8.21,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "actualSource": "public void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    boolean typeable \u003d true;\n    switch(n.getType()) {\n        case Token.NAME:\n            typeable \u003d visitName(t, n, parent);\n            break;\n        case Token.LP:\n            if (parent.getType() !\u003d Token.FUNCTION) {\n                ensureTyped(t, n, getJSType(n.getFirstChild()));\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.COMMA:\n            ensureTyped(t, n, getJSType(n.getLastChild()));\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.THIS:\n            ensureTyped(t, n, t.getScope().getTypeOfThis());\n            break;\n        case Token.REF_SPECIAL:\n            ensureTyped(t, n);\n            break;\n        case Token.GET_REF:\n            ensureTyped(t, n, getJSType(n.getFirstChild()));\n            break;\n        case Token.NULL:\n            ensureTyped(t, n, NULL_TYPE);\n            break;\n        case Token.NUMBER:\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.STRING:\n            if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n                ensureTyped(t, n, STRING_TYPE);\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.GET:\n        case Token.SET:\n            break;\n        case Token.ARRAYLIT:\n            ensureTyped(t, n, ARRAY_TYPE);\n            break;\n        case Token.REGEXP:\n            ensureTyped(t, n, REGEXP_TYPE);\n            break;\n        case Token.GETPROP:\n            visitGetProp(t, n, parent);\n            typeable \u003d !(parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n            break;\n        case Token.GETELEM:\n            visitGetElem(t, n);\n            typeable \u003d false;\n            break;\n        case Token.VAR:\n            visitVar(t, n);\n            typeable \u003d false;\n            break;\n        case Token.NEW:\n            visitNew(t, n);\n            typeable \u003d true;\n            break;\n        case Token.CALL:\n            visitCall(t, n);\n            typeable \u003d !NodeUtil.isExpressionNode(parent);\n            break;\n        case Token.RETURN:\n            visitReturn(t, n);\n            typeable \u003d false;\n            break;\n        case Token.DEC:\n        case Token.INC:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.NOT:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.VOID:\n            ensureTyped(t, n, VOID_TYPE);\n            break;\n        case Token.TYPEOF:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.BITNOT:\n            childType \u003d getJSType(n.getFirstChild());\n            if (!childType.matchesInt32Context()) {\n                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n            }\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.EQ:\n        case Token.NE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                if (result !\u003d TernaryValue.UNKNOWN) {\n                    if (n.getType() \u003d\u003d Token.NE) {\n                        result \u003d result.not();\n                    }\n                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.SHEQ:\n        case Token.SHNE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                    report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n            leftType \u003d getJSType(n.getFirstChild());\n            rightType \u003d getJSType(n.getLastChild());\n            if (rightType.isNumber()) {\n                validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n            } else if (leftType.isNumber()) {\n                validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n            } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n            } else {\n                String message \u003d \"left side of comparison\";\n                validator.expectString(t, n, leftType, message);\n                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                message \u003d \"right side of comparison\";\n                validator.expectString(t, n, rightType, message);\n                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.IN:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right);\n            validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n            validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.INSTANCEOF:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n            validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n            validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.ASSIGN:\n            visitAssign(t, n);\n            typeable \u003d false;\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.ASSIGN_URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_SUB:\n        case Token.ASSIGN_ADD:\n        case Token.ASSIGN_MUL:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.URSH:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITOR:\n        case Token.BITXOR:\n        case Token.BITAND:\n        case Token.SUB:\n        case Token.ADD:\n        case Token.MUL:\n            visitBinaryOperator(n.getType(), t, n);\n            break;\n        case Token.DELPROP:\n            if (!isReference(n.getFirstChild())) {\n                report(t, n, BAD_DELETE);\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.CASE:\n            JSType switchType \u003d getJSType(parent.getFirstChild());\n            JSType caseType \u003d getJSType(n.getFirstChild());\n            validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n            typeable \u003d false;\n            break;\n        case Token.WITH:\n            {\n                Node child \u003d n.getFirstChild();\n                childType \u003d getJSType(child);\n                validator.expectObject(t, child, childType, \"with requires an object\");\n                typeable \u003d false;\n                break;\n            }\n        case Token.FUNCTION:\n            visitFunction(t, n);\n            break;\n        case Token.LABEL:\n        case Token.LABEL_NAME:\n        case Token.SWITCH:\n        case Token.BREAK:\n        case Token.CATCH:\n        case Token.TRY:\n        case Token.SCRIPT:\n        case Token.EXPR_RESULT:\n        case Token.BLOCK:\n        case Token.EMPTY:\n        case Token.DEFAULT:\n        case Token.CONTINUE:\n        case Token.DEBUGGER:\n        case Token.THROW:\n            typeable \u003d false;\n            break;\n        case Token.DO:\n        case Token.FOR:\n        case Token.IF:\n        case Token.WHILE:\n            typeable \u003d false;\n            break;\n        case Token.AND:\n        case Token.HOOK:\n        case Token.OBJECTLIT:\n        case Token.OR:\n            if (n.getJSType() !\u003d null) {\n                ensureTyped(t, n);\n            } else {\n                if ((n.getType() \u003d\u003d Token.OBJECTLIT) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                    ensureTyped(t, n, parent.getJSType());\n                } else {\n                    ensureTyped(t, n);\n                }\n            }\n            if (n.getType() \u003d\u003d Token.OBJECTLIT) {\n                for (Node key : n.children()) {\n                    visitObjLitKey(t, key, n);\n                }\n            }\n            break;\n        default:\n            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n            ensureTyped(t, n);\n            break;\n    }\n    typeable \u003d typeable \u0026\u0026 !inExterns;\n    if (typeable) {\n        doPercentTypedAccounting(t, n);\n    }\n    checkNoTypeCheckSection(n, false);\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 461,
      "functionName": "visit",
      "functionAnnotation": "",
      "functionDoc": "This is the meat of the type checking.  It is basically one big switch,\nwith each case representing one type of parse tree node.  The individual\ncases are usually pretty straightforward.\n\n@param t The node traversal object that supplies context, such as the\nscope chain to use in name lookups as well as error reporting.\n@param n The node being visited.\n@param parent The parent of the node n.\n",
      "diff": "@@ -1,276 +1,278 @@\n public void visit(NodeTraversal t, Node n, Node parent) {\n     JSType childType;\n     JSType leftType, rightType;\n     Node left, right;\n     boolean typeable \u003d true;\n     switch(n.getType()) {\n         case Token.NAME:\n             typeable \u003d visitName(t, n, parent);\n             break;\n         case Token.LP:\n             if (parent.getType() !\u003d Token.FUNCTION) {\n                 ensureTyped(t, n, getJSType(n.getFirstChild()));\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.COMMA:\n             ensureTyped(t, n, getJSType(n.getLastChild()));\n             break;\n         case Token.TRUE:\n         case Token.FALSE:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.THIS:\n             ensureTyped(t, n, t.getScope().getTypeOfThis());\n             break;\n         case Token.REF_SPECIAL:\n             ensureTyped(t, n);\n             break;\n         case Token.GET_REF:\n             ensureTyped(t, n, getJSType(n.getFirstChild()));\n             break;\n         case Token.NULL:\n             ensureTyped(t, n, NULL_TYPE);\n             break;\n         case Token.NUMBER:\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.STRING:\n             if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n                 ensureTyped(t, n, STRING_TYPE);\n+            } else {\n+                typeable \u003d false;\n             }\n             break;\n         case Token.GET:\n         case Token.SET:\n             break;\n         case Token.ARRAYLIT:\n             ensureTyped(t, n, ARRAY_TYPE);\n             break;\n         case Token.REGEXP:\n             ensureTyped(t, n, REGEXP_TYPE);\n             break;\n         case Token.GETPROP:\n             visitGetProp(t, n, parent);\n             typeable \u003d !(parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n             break;\n         case Token.GETELEM:\n             visitGetElem(t, n);\n             typeable \u003d false;\n             break;\n         case Token.VAR:\n             visitVar(t, n);\n             typeable \u003d false;\n             break;\n         case Token.NEW:\n             visitNew(t, n);\n             typeable \u003d true;\n             break;\n         case Token.CALL:\n             visitCall(t, n);\n             typeable \u003d !NodeUtil.isExpressionNode(parent);\n             break;\n         case Token.RETURN:\n             visitReturn(t, n);\n             typeable \u003d false;\n             break;\n         case Token.DEC:\n         case Token.INC:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.NOT:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.VOID:\n             ensureTyped(t, n, VOID_TYPE);\n             break;\n         case Token.TYPEOF:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.BITNOT:\n             childType \u003d getJSType(n.getFirstChild());\n             if (!childType.matchesInt32Context()) {\n                 report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n             }\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.POS:\n         case Token.NEG:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.EQ:\n         case Token.NE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                 if (result !\u003d TernaryValue.UNKNOWN) {\n                     if (n.getType() \u003d\u003d Token.NE) {\n                         result \u003d result.not();\n                     }\n                     report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.SHEQ:\n         case Token.SHNE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                     report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.LT:\n         case Token.LE:\n         case Token.GT:\n         case Token.GE:\n             leftType \u003d getJSType(n.getFirstChild());\n             rightType \u003d getJSType(n.getLastChild());\n             if (rightType.isNumber()) {\n                 validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n             } else if (leftType.isNumber()) {\n                 validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n             } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n             } else {\n                 String message \u003d \"left side of comparison\";\n                 validator.expectString(t, n, leftType, message);\n                 validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                 message \u003d \"right side of comparison\";\n                 validator.expectString(t, n, rightType, message);\n                 validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.IN:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right);\n             validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n             validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.INSTANCEOF:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n             validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n             validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.ASSIGN:\n             visitAssign(t, n);\n             typeable \u003d false;\n             break;\n         case Token.ASSIGN_LSH:\n         case Token.ASSIGN_RSH:\n         case Token.ASSIGN_URSH:\n         case Token.ASSIGN_DIV:\n         case Token.ASSIGN_MOD:\n         case Token.ASSIGN_BITOR:\n         case Token.ASSIGN_BITXOR:\n         case Token.ASSIGN_BITAND:\n         case Token.ASSIGN_SUB:\n         case Token.ASSIGN_ADD:\n         case Token.ASSIGN_MUL:\n         case Token.LSH:\n         case Token.RSH:\n         case Token.URSH:\n         case Token.DIV:\n         case Token.MOD:\n         case Token.BITOR:\n         case Token.BITXOR:\n         case Token.BITAND:\n         case Token.SUB:\n         case Token.ADD:\n         case Token.MUL:\n             visitBinaryOperator(n.getType(), t, n);\n             break;\n         case Token.DELPROP:\n             if (!isReference(n.getFirstChild())) {\n                 report(t, n, BAD_DELETE);\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.CASE:\n             JSType switchType \u003d getJSType(parent.getFirstChild());\n             JSType caseType \u003d getJSType(n.getFirstChild());\n             validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n             typeable \u003d false;\n             break;\n         case Token.WITH:\n             {\n                 Node child \u003d n.getFirstChild();\n                 childType \u003d getJSType(child);\n                 validator.expectObject(t, child, childType, \"with requires an object\");\n                 typeable \u003d false;\n                 break;\n             }\n         case Token.FUNCTION:\n             visitFunction(t, n);\n             break;\n         case Token.LABEL:\n         case Token.LABEL_NAME:\n         case Token.SWITCH:\n         case Token.BREAK:\n         case Token.CATCH:\n         case Token.TRY:\n         case Token.SCRIPT:\n         case Token.EXPR_RESULT:\n         case Token.BLOCK:\n         case Token.EMPTY:\n         case Token.DEFAULT:\n         case Token.CONTINUE:\n         case Token.DEBUGGER:\n         case Token.THROW:\n             typeable \u003d false;\n             break;\n         case Token.DO:\n         case Token.FOR:\n         case Token.IF:\n         case Token.WHILE:\n             typeable \u003d false;\n             break;\n         case Token.AND:\n         case Token.HOOK:\n         case Token.OBJECTLIT:\n         case Token.OR:\n             if (n.getJSType() !\u003d null) {\n                 ensureTyped(t, n);\n             } else {\n                 if ((n.getType() \u003d\u003d Token.OBJECTLIT) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                     ensureTyped(t, n, parent.getJSType());\n                 } else {\n                     ensureTyped(t, n);\n                 }\n             }\n             if (n.getType() \u003d\u003d Token.OBJECTLIT) {\n                 for (Node key : n.children()) {\n                     visitObjLitKey(t, key, n);\n                 }\n             }\n             break;\n         default:\n             report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n             ensureTyped(t, n);\n             break;\n     }\n     typeable \u003d typeable \u0026\u0026 !inExterns;\n     if (typeable) {\n         doPercentTypedAccounting(t, n);\n     }\n     checkNoTypeCheckSection(n, false);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "75aa5f653b08995428743f6951a99ad101e73e37": {
      "type": "Ybodychange",
      "commitMessage": "\nCleanup obsolete handling of NUMBER keys of OBJECTLIT.\n\nR\u003dnicksantos\nDELTA\u003d109  (3 added, 48 deleted, 58 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d1253\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@967 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/4/11, 2:40 PM",
      "commitName": "75aa5f653b08995428743f6951a99ad101e73e37",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "3/23/11, 3:36 PM",
      "commitNameOld": "fdce3fde269834d9907127955701fc6d783fb3bc",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 11.96,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "actualSource": "public void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    boolean typeable \u003d true;\n    switch(n.getType()) {\n        case Token.NAME:\n            typeable \u003d visitName(t, n, parent);\n            break;\n        case Token.LP:\n            if (parent.getType() !\u003d Token.FUNCTION) {\n                ensureTyped(t, n, getJSType(n.getFirstChild()));\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.COMMA:\n            ensureTyped(t, n, getJSType(n.getLastChild()));\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.THIS:\n            ensureTyped(t, n, t.getScope().getTypeOfThis());\n            break;\n        case Token.REF_SPECIAL:\n            ensureTyped(t, n);\n            break;\n        case Token.GET_REF:\n            ensureTyped(t, n, getJSType(n.getFirstChild()));\n            break;\n        case Token.NULL:\n            ensureTyped(t, n, NULL_TYPE);\n            break;\n        case Token.NUMBER:\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.STRING:\n            if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n                ensureTyped(t, n, STRING_TYPE);\n            }\n            break;\n        case Token.GET:\n        case Token.SET:\n            break;\n        case Token.ARRAYLIT:\n            ensureTyped(t, n, ARRAY_TYPE);\n            break;\n        case Token.REGEXP:\n            ensureTyped(t, n, REGEXP_TYPE);\n            break;\n        case Token.GETPROP:\n            visitGetProp(t, n, parent);\n            typeable \u003d !(parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n            break;\n        case Token.GETELEM:\n            visitGetElem(t, n);\n            typeable \u003d false;\n            break;\n        case Token.VAR:\n            visitVar(t, n);\n            typeable \u003d false;\n            break;\n        case Token.NEW:\n            visitNew(t, n);\n            typeable \u003d true;\n            break;\n        case Token.CALL:\n            visitCall(t, n);\n            typeable \u003d !NodeUtil.isExpressionNode(parent);\n            break;\n        case Token.RETURN:\n            visitReturn(t, n);\n            typeable \u003d false;\n            break;\n        case Token.DEC:\n        case Token.INC:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.NOT:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.VOID:\n            ensureTyped(t, n, VOID_TYPE);\n            break;\n        case Token.TYPEOF:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.BITNOT:\n            childType \u003d getJSType(n.getFirstChild());\n            if (!childType.matchesInt32Context()) {\n                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n            }\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.EQ:\n        case Token.NE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                if (result !\u003d TernaryValue.UNKNOWN) {\n                    if (n.getType() \u003d\u003d Token.NE) {\n                        result \u003d result.not();\n                    }\n                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.SHEQ:\n        case Token.SHNE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                    report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n            leftType \u003d getJSType(n.getFirstChild());\n            rightType \u003d getJSType(n.getLastChild());\n            if (rightType.isNumber()) {\n                validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n            } else if (leftType.isNumber()) {\n                validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n            } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n            } else {\n                String message \u003d \"left side of comparison\";\n                validator.expectString(t, n, leftType, message);\n                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                message \u003d \"right side of comparison\";\n                validator.expectString(t, n, rightType, message);\n                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.IN:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right);\n            validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n            validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.INSTANCEOF:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n            validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n            validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.ASSIGN:\n            visitAssign(t, n);\n            typeable \u003d false;\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.ASSIGN_URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_SUB:\n        case Token.ASSIGN_ADD:\n        case Token.ASSIGN_MUL:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.URSH:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITOR:\n        case Token.BITXOR:\n        case Token.BITAND:\n        case Token.SUB:\n        case Token.ADD:\n        case Token.MUL:\n            visitBinaryOperator(n.getType(), t, n);\n            break;\n        case Token.DELPROP:\n            if (!isReference(n.getFirstChild())) {\n                report(t, n, BAD_DELETE);\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.CASE:\n            JSType switchType \u003d getJSType(parent.getFirstChild());\n            JSType caseType \u003d getJSType(n.getFirstChild());\n            validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n            typeable \u003d false;\n            break;\n        case Token.WITH:\n            {\n                Node child \u003d n.getFirstChild();\n                childType \u003d getJSType(child);\n                validator.expectObject(t, child, childType, \"with requires an object\");\n                typeable \u003d false;\n                break;\n            }\n        case Token.FUNCTION:\n            visitFunction(t, n);\n            break;\n        case Token.LABEL:\n        case Token.LABEL_NAME:\n        case Token.SWITCH:\n        case Token.BREAK:\n        case Token.CATCH:\n        case Token.TRY:\n        case Token.SCRIPT:\n        case Token.EXPR_RESULT:\n        case Token.BLOCK:\n        case Token.EMPTY:\n        case Token.DEFAULT:\n        case Token.CONTINUE:\n        case Token.DEBUGGER:\n        case Token.THROW:\n            typeable \u003d false;\n            break;\n        case Token.DO:\n        case Token.FOR:\n        case Token.IF:\n        case Token.WHILE:\n            typeable \u003d false;\n            break;\n        case Token.AND:\n        case Token.HOOK:\n        case Token.OBJECTLIT:\n        case Token.OR:\n            if (n.getJSType() !\u003d null) {\n                ensureTyped(t, n);\n            } else {\n                if ((n.getType() \u003d\u003d Token.OBJECTLIT) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                    ensureTyped(t, n, parent.getJSType());\n                } else {\n                    ensureTyped(t, n);\n                }\n            }\n            if (n.getType() \u003d\u003d Token.OBJECTLIT) {\n                for (Node key : n.children()) {\n                    visitObjLitKey(t, key, n);\n                }\n            }\n            break;\n        default:\n            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n            ensureTyped(t, n);\n            break;\n    }\n    typeable \u003d typeable \u0026\u0026 !inExterns;\n    if (typeable) {\n        doPercentTypedAccounting(t, n);\n    }\n    checkNoTypeCheckSection(n, false);\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 439,
      "functionName": "visit",
      "functionAnnotation": "",
      "functionDoc": "This is the meat of the type checking.  It is basically one big switch,\nwith each case representing one type of parse tree node.  The individual\ncases are usually pretty straightforward.\n\n@param t The node traversal object that supplies context, such as the\nscope chain to use in name lookups as well as error reporting.\n@param n The node being visited.\n@param parent The parent of the node n.\n",
      "diff": "@@ -1,278 +1,276 @@\n public void visit(NodeTraversal t, Node n, Node parent) {\n     JSType childType;\n     JSType leftType, rightType;\n     Node left, right;\n     boolean typeable \u003d true;\n     switch(n.getType()) {\n         case Token.NAME:\n             typeable \u003d visitName(t, n, parent);\n             break;\n         case Token.LP:\n             if (parent.getType() !\u003d Token.FUNCTION) {\n                 ensureTyped(t, n, getJSType(n.getFirstChild()));\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.COMMA:\n             ensureTyped(t, n, getJSType(n.getLastChild()));\n             break;\n         case Token.TRUE:\n         case Token.FALSE:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.THIS:\n             ensureTyped(t, n, t.getScope().getTypeOfThis());\n             break;\n         case Token.REF_SPECIAL:\n             ensureTyped(t, n);\n             break;\n         case Token.GET_REF:\n             ensureTyped(t, n, getJSType(n.getFirstChild()));\n             break;\n         case Token.NULL:\n             ensureTyped(t, n, NULL_TYPE);\n             break;\n         case Token.NUMBER:\n-            if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n-                ensureTyped(t, n, NUMBER_TYPE);\n-            }\n+            ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.STRING:\n             if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n                 ensureTyped(t, n, STRING_TYPE);\n             }\n             break;\n         case Token.GET:\n         case Token.SET:\n             break;\n         case Token.ARRAYLIT:\n             ensureTyped(t, n, ARRAY_TYPE);\n             break;\n         case Token.REGEXP:\n             ensureTyped(t, n, REGEXP_TYPE);\n             break;\n         case Token.GETPROP:\n             visitGetProp(t, n, parent);\n             typeable \u003d !(parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n             break;\n         case Token.GETELEM:\n             visitGetElem(t, n);\n             typeable \u003d false;\n             break;\n         case Token.VAR:\n             visitVar(t, n);\n             typeable \u003d false;\n             break;\n         case Token.NEW:\n             visitNew(t, n);\n             typeable \u003d true;\n             break;\n         case Token.CALL:\n             visitCall(t, n);\n             typeable \u003d !NodeUtil.isExpressionNode(parent);\n             break;\n         case Token.RETURN:\n             visitReturn(t, n);\n             typeable \u003d false;\n             break;\n         case Token.DEC:\n         case Token.INC:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.NOT:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.VOID:\n             ensureTyped(t, n, VOID_TYPE);\n             break;\n         case Token.TYPEOF:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.BITNOT:\n             childType \u003d getJSType(n.getFirstChild());\n             if (!childType.matchesInt32Context()) {\n                 report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n             }\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.POS:\n         case Token.NEG:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.EQ:\n         case Token.NE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                 if (result !\u003d TernaryValue.UNKNOWN) {\n                     if (n.getType() \u003d\u003d Token.NE) {\n                         result \u003d result.not();\n                     }\n                     report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.SHEQ:\n         case Token.SHNE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                     report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.LT:\n         case Token.LE:\n         case Token.GT:\n         case Token.GE:\n             leftType \u003d getJSType(n.getFirstChild());\n             rightType \u003d getJSType(n.getLastChild());\n             if (rightType.isNumber()) {\n                 validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n             } else if (leftType.isNumber()) {\n                 validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n             } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n             } else {\n                 String message \u003d \"left side of comparison\";\n                 validator.expectString(t, n, leftType, message);\n                 validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                 message \u003d \"right side of comparison\";\n                 validator.expectString(t, n, rightType, message);\n                 validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.IN:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right);\n             validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n             validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.INSTANCEOF:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n             validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n             validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.ASSIGN:\n             visitAssign(t, n);\n             typeable \u003d false;\n             break;\n         case Token.ASSIGN_LSH:\n         case Token.ASSIGN_RSH:\n         case Token.ASSIGN_URSH:\n         case Token.ASSIGN_DIV:\n         case Token.ASSIGN_MOD:\n         case Token.ASSIGN_BITOR:\n         case Token.ASSIGN_BITXOR:\n         case Token.ASSIGN_BITAND:\n         case Token.ASSIGN_SUB:\n         case Token.ASSIGN_ADD:\n         case Token.ASSIGN_MUL:\n         case Token.LSH:\n         case Token.RSH:\n         case Token.URSH:\n         case Token.DIV:\n         case Token.MOD:\n         case Token.BITOR:\n         case Token.BITXOR:\n         case Token.BITAND:\n         case Token.SUB:\n         case Token.ADD:\n         case Token.MUL:\n             visitBinaryOperator(n.getType(), t, n);\n             break;\n         case Token.DELPROP:\n             if (!isReference(n.getFirstChild())) {\n                 report(t, n, BAD_DELETE);\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.CASE:\n             JSType switchType \u003d getJSType(parent.getFirstChild());\n             JSType caseType \u003d getJSType(n.getFirstChild());\n             validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n             typeable \u003d false;\n             break;\n         case Token.WITH:\n             {\n                 Node child \u003d n.getFirstChild();\n                 childType \u003d getJSType(child);\n                 validator.expectObject(t, child, childType, \"with requires an object\");\n                 typeable \u003d false;\n                 break;\n             }\n         case Token.FUNCTION:\n             visitFunction(t, n);\n             break;\n         case Token.LABEL:\n         case Token.LABEL_NAME:\n         case Token.SWITCH:\n         case Token.BREAK:\n         case Token.CATCH:\n         case Token.TRY:\n         case Token.SCRIPT:\n         case Token.EXPR_RESULT:\n         case Token.BLOCK:\n         case Token.EMPTY:\n         case Token.DEFAULT:\n         case Token.CONTINUE:\n         case Token.DEBUGGER:\n         case Token.THROW:\n             typeable \u003d false;\n             break;\n         case Token.DO:\n         case Token.FOR:\n         case Token.IF:\n         case Token.WHILE:\n             typeable \u003d false;\n             break;\n         case Token.AND:\n         case Token.HOOK:\n         case Token.OBJECTLIT:\n         case Token.OR:\n             if (n.getJSType() !\u003d null) {\n                 ensureTyped(t, n);\n             } else {\n                 if ((n.getType() \u003d\u003d Token.OBJECTLIT) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                     ensureTyped(t, n, parent.getJSType());\n                 } else {\n                     ensureTyped(t, n);\n                 }\n             }\n             if (n.getType() \u003d\u003d Token.OBJECTLIT) {\n                 for (Node key : n.children()) {\n                     visitObjLitKey(t, key, n);\n                 }\n             }\n             break;\n         default:\n             report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n             ensureTyped(t, n);\n             break;\n     }\n     typeable \u003d typeable \u0026\u0026 !inExterns;\n     if (typeable) {\n         doPercentTypedAccounting(t, n);\n     }\n     checkNoTypeCheckSection(n, false);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "70f817ae4f80ac11dd2dfe97babf5896c690fb48": {
      "type": "Ybodychange",
      "commitMessage": "\nAdd basic getters and setters support to TypeInference.\n\nR\u003dnicksantos\nDELTA\u003d573  (533 added, 15 deleted, 25 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d366\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@735 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "1/27/11, 10:33 AM",
      "commitName": "70f817ae4f80ac11dd2dfe97babf5896c690fb48",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "1/26/11, 8:30 AM",
      "commitNameOld": "043a352c2e85815a90a1926d112902d924bab6c1",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 1.09,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "public void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    boolean typeable \u003d true;\n    switch(n.getType()) {\n        case Token.NAME:\n            typeable \u003d visitName(t, n, parent);\n            break;\n        case Token.LP:\n            if (parent.getType() !\u003d Token.FUNCTION) {\n                ensureTyped(t, n, getJSType(n.getFirstChild()));\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.COMMA:\n            ensureTyped(t, n, getJSType(n.getLastChild()));\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.THIS:\n            ensureTyped(t, n, t.getScope().getTypeOfThis());\n            break;\n        case Token.REF_SPECIAL:\n            ensureTyped(t, n);\n            break;\n        case Token.GET_REF:\n            ensureTyped(t, n, getJSType(n.getFirstChild()));\n            break;\n        case Token.NULL:\n            ensureTyped(t, n, NULL_TYPE);\n            break;\n        case Token.NUMBER:\n            if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n                ensureTyped(t, n, NUMBER_TYPE);\n            }\n            break;\n        case Token.STRING:\n            if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n                ensureTyped(t, n, STRING_TYPE);\n            }\n            break;\n        case Token.GET:\n        case Token.SET:\n            break;\n        case Token.ARRAYLIT:\n            ensureTyped(t, n, ARRAY_TYPE);\n            break;\n        case Token.REGEXP:\n            ensureTyped(t, n, REGEXP_TYPE);\n            break;\n        case Token.GETPROP:\n            visitGetProp(t, n, parent);\n            typeable \u003d !(parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n            break;\n        case Token.GETELEM:\n            visitGetElem(t, n);\n            typeable \u003d false;\n            break;\n        case Token.VAR:\n            visitVar(t, n);\n            typeable \u003d false;\n            break;\n        case Token.NEW:\n            visitNew(t, n);\n            typeable \u003d true;\n            break;\n        case Token.CALL:\n            visitCall(t, n);\n            typeable \u003d !NodeUtil.isExpressionNode(parent);\n            break;\n        case Token.RETURN:\n            visitReturn(t, n);\n            typeable \u003d false;\n            break;\n        case Token.DEC:\n        case Token.INC:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.NOT:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.VOID:\n            ensureTyped(t, n, VOID_TYPE);\n            break;\n        case Token.TYPEOF:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.BITNOT:\n            childType \u003d getJSType(n.getFirstChild());\n            if (!childType.matchesInt32Context()) {\n                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n            }\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.EQ:\n        case Token.NE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                if (result !\u003d TernaryValue.UNKNOWN) {\n                    if (n.getType() \u003d\u003d Token.NE) {\n                        result \u003d result.not();\n                    }\n                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.SHEQ:\n        case Token.SHNE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                    report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n            leftType \u003d getJSType(n.getFirstChild());\n            rightType \u003d getJSType(n.getLastChild());\n            if (rightType.isNumber()) {\n                validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n            } else if (leftType.isNumber()) {\n                validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n            } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n            } else {\n                String message \u003d \"left side of comparison\";\n                validator.expectString(t, n, leftType, message);\n                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                message \u003d \"right side of comparison\";\n                validator.expectString(t, n, rightType, message);\n                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.IN:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right);\n            validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n            validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.INSTANCEOF:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n            validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n            validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.ASSIGN:\n            visitAssign(t, n);\n            typeable \u003d false;\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.ASSIGN_URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_SUB:\n        case Token.ASSIGN_ADD:\n        case Token.ASSIGN_MUL:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.URSH:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITOR:\n        case Token.BITXOR:\n        case Token.BITAND:\n        case Token.SUB:\n        case Token.ADD:\n        case Token.MUL:\n            visitBinaryOperator(n.getType(), t, n);\n            break;\n        case Token.DELPROP:\n            if (!isReference(n.getFirstChild())) {\n                report(t, n, BAD_DELETE);\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.CASE:\n            JSType switchType \u003d getJSType(parent.getFirstChild());\n            JSType caseType \u003d getJSType(n.getFirstChild());\n            validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n            typeable \u003d false;\n            break;\n        case Token.WITH:\n            {\n                Node child \u003d n.getFirstChild();\n                childType \u003d getJSType(child);\n                validator.expectObject(t, child, childType, \"with requires an object\");\n                typeable \u003d false;\n                break;\n            }\n        case Token.FUNCTION:\n            visitFunction(t, n);\n            break;\n        case Token.LABEL:\n        case Token.LABEL_NAME:\n        case Token.SWITCH:\n        case Token.BREAK:\n        case Token.CATCH:\n        case Token.TRY:\n        case Token.SCRIPT:\n        case Token.EXPR_RESULT:\n        case Token.BLOCK:\n        case Token.EMPTY:\n        case Token.DEFAULT:\n        case Token.CONTINUE:\n        case Token.DEBUGGER:\n        case Token.THROW:\n            typeable \u003d false;\n            break;\n        case Token.DO:\n        case Token.FOR:\n        case Token.IF:\n        case Token.WHILE:\n            typeable \u003d false;\n            break;\n        case Token.AND:\n        case Token.HOOK:\n        case Token.OBJECTLIT:\n        case Token.OR:\n            if (n.getJSType() !\u003d null) {\n                ensureTyped(t, n);\n            } else {\n                if ((n.getType() \u003d\u003d Token.OBJECTLIT) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                    ensureTyped(t, n, parent.getJSType());\n                } else {\n                    ensureTyped(t, n);\n                }\n            }\n            if (n.getType() \u003d\u003d Token.OBJECTLIT) {\n                for (Node key : n.children()) {\n                    visitObjLitKey(t, key, n);\n                }\n            }\n            break;\n        default:\n            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n            ensureTyped(t, n);\n            break;\n    }\n    typeable \u003d typeable \u0026\u0026 !inExterns;\n    if (typeable) {\n        doPercentTypedAccounting(t, n);\n    }\n    checkNoTypeCheckSection(n, false);\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 447,
      "functionName": "visit",
      "functionAnnotation": "",
      "functionDoc": "This is the meat of the type checking.  It is basically one big switch,\nwith each case representing one type of parse tree node.  The individual\ncases are usually pretty straightforward.\n\n@param t The node traversal object that supplies context, such as the\nscope chain to use in name lookups as well as error reporting.\n@param n The node being visited.\n@param parent The parent of the node n.\n",
      "diff": "@@ -1,274 +1,278 @@\n public void visit(NodeTraversal t, Node n, Node parent) {\n     JSType childType;\n     JSType leftType, rightType;\n     Node left, right;\n     boolean typeable \u003d true;\n     switch(n.getType()) {\n         case Token.NAME:\n             typeable \u003d visitName(t, n, parent);\n             break;\n         case Token.LP:\n             if (parent.getType() !\u003d Token.FUNCTION) {\n                 ensureTyped(t, n, getJSType(n.getFirstChild()));\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.COMMA:\n             ensureTyped(t, n, getJSType(n.getLastChild()));\n             break;\n         case Token.TRUE:\n         case Token.FALSE:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.THIS:\n             ensureTyped(t, n, t.getScope().getTypeOfThis());\n             break;\n         case Token.REF_SPECIAL:\n             ensureTyped(t, n);\n             break;\n         case Token.GET_REF:\n             ensureTyped(t, n, getJSType(n.getFirstChild()));\n             break;\n         case Token.NULL:\n             ensureTyped(t, n, NULL_TYPE);\n             break;\n         case Token.NUMBER:\n-            if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n+            if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n                 ensureTyped(t, n, NUMBER_TYPE);\n-            } else {\n-                typeable \u003d false;\n             }\n             break;\n+        case Token.STRING:\n+            if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n+                ensureTyped(t, n, STRING_TYPE);\n+            }\n+            break;\n+        case Token.GET:\n+        case Token.SET:\n+            break;\n         case Token.ARRAYLIT:\n             ensureTyped(t, n, ARRAY_TYPE);\n             break;\n-        case Token.STRING:\n-            if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n-                ensureTyped(t, n, STRING_TYPE);\n-            } else {\n-                typeable \u003d false;\n-            }\n-            break;\n         case Token.REGEXP:\n             ensureTyped(t, n, REGEXP_TYPE);\n             break;\n         case Token.GETPROP:\n             visitGetProp(t, n, parent);\n             typeable \u003d !(parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n             break;\n         case Token.GETELEM:\n             visitGetElem(t, n);\n             typeable \u003d false;\n             break;\n         case Token.VAR:\n             visitVar(t, n);\n             typeable \u003d false;\n             break;\n         case Token.NEW:\n             visitNew(t, n);\n             typeable \u003d true;\n             break;\n         case Token.CALL:\n             visitCall(t, n);\n             typeable \u003d !NodeUtil.isExpressionNode(parent);\n             break;\n         case Token.RETURN:\n             visitReturn(t, n);\n             typeable \u003d false;\n             break;\n         case Token.DEC:\n         case Token.INC:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.NOT:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.VOID:\n             ensureTyped(t, n, VOID_TYPE);\n             break;\n         case Token.TYPEOF:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.BITNOT:\n             childType \u003d getJSType(n.getFirstChild());\n             if (!childType.matchesInt32Context()) {\n                 report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n             }\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.POS:\n         case Token.NEG:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.EQ:\n         case Token.NE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                 if (result !\u003d TernaryValue.UNKNOWN) {\n                     if (n.getType() \u003d\u003d Token.NE) {\n                         result \u003d result.not();\n                     }\n                     report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.SHEQ:\n         case Token.SHNE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                     report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.LT:\n         case Token.LE:\n         case Token.GT:\n         case Token.GE:\n             leftType \u003d getJSType(n.getFirstChild());\n             rightType \u003d getJSType(n.getLastChild());\n             if (rightType.isNumber()) {\n                 validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n             } else if (leftType.isNumber()) {\n                 validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n             } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n             } else {\n                 String message \u003d \"left side of comparison\";\n                 validator.expectString(t, n, leftType, message);\n                 validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                 message \u003d \"right side of comparison\";\n                 validator.expectString(t, n, rightType, message);\n                 validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.IN:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right);\n             validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n             validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.INSTANCEOF:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n             validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n             validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.ASSIGN:\n             visitAssign(t, n);\n             typeable \u003d false;\n             break;\n         case Token.ASSIGN_LSH:\n         case Token.ASSIGN_RSH:\n         case Token.ASSIGN_URSH:\n         case Token.ASSIGN_DIV:\n         case Token.ASSIGN_MOD:\n         case Token.ASSIGN_BITOR:\n         case Token.ASSIGN_BITXOR:\n         case Token.ASSIGN_BITAND:\n         case Token.ASSIGN_SUB:\n         case Token.ASSIGN_ADD:\n         case Token.ASSIGN_MUL:\n         case Token.LSH:\n         case Token.RSH:\n         case Token.URSH:\n         case Token.DIV:\n         case Token.MOD:\n         case Token.BITOR:\n         case Token.BITXOR:\n         case Token.BITAND:\n         case Token.SUB:\n         case Token.ADD:\n         case Token.MUL:\n             visitBinaryOperator(n.getType(), t, n);\n             break;\n         case Token.DELPROP:\n             if (!isReference(n.getFirstChild())) {\n                 report(t, n, BAD_DELETE);\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.CASE:\n             JSType switchType \u003d getJSType(parent.getFirstChild());\n             JSType caseType \u003d getJSType(n.getFirstChild());\n             validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n             typeable \u003d false;\n             break;\n         case Token.WITH:\n             {\n                 Node child \u003d n.getFirstChild();\n                 childType \u003d getJSType(child);\n                 validator.expectObject(t, child, childType, \"with requires an object\");\n                 typeable \u003d false;\n                 break;\n             }\n         case Token.FUNCTION:\n             visitFunction(t, n);\n             break;\n         case Token.LABEL:\n         case Token.LABEL_NAME:\n         case Token.SWITCH:\n         case Token.BREAK:\n         case Token.CATCH:\n         case Token.TRY:\n         case Token.SCRIPT:\n         case Token.EXPR_RESULT:\n         case Token.BLOCK:\n         case Token.EMPTY:\n         case Token.DEFAULT:\n         case Token.CONTINUE:\n         case Token.DEBUGGER:\n         case Token.THROW:\n             typeable \u003d false;\n             break;\n         case Token.DO:\n         case Token.FOR:\n         case Token.IF:\n         case Token.WHILE:\n             typeable \u003d false;\n             break;\n         case Token.AND:\n         case Token.HOOK:\n         case Token.OBJECTLIT:\n         case Token.OR:\n             if (n.getJSType() !\u003d null) {\n                 ensureTyped(t, n);\n             } else {\n                 if ((n.getType() \u003d\u003d Token.OBJECTLIT) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                     ensureTyped(t, n, parent.getJSType());\n                 } else {\n                     ensureTyped(t, n);\n                 }\n             }\n+            if (n.getType() \u003d\u003d Token.OBJECTLIT) {\n+                for (Node key : n.children()) {\n+                    visitObjLitKey(t, key, n);\n+                }\n+            }\n             break;\n         default:\n             report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n             ensureTyped(t, n);\n             break;\n     }\n     typeable \u003d typeable \u0026\u0026 !inExterns;\n     if (typeable) {\n         doPercentTypedAccounting(t, n);\n     }\n     checkNoTypeCheckSection(n, false);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9d9957fdd23ff13d187d4b8832d580bf8622baf6": {
      "type": "Ybodychange",
      "commitMessage": "\nFlag null pointer exceptions that are provable at compile time.\n\nR\u003djohnlenz\nDELTA\u003d48  (38 added, 0 deleted, 10 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d236\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@682 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "1/10/11, 12:54 PM",
      "commitName": "9d9957fdd23ff13d187d4b8832d580bf8622baf6",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "12/2/10, 12:04 PM",
      "commitNameOld": "a83c4868dbc0f3229d31af5ff1b8554c44908459",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 39.03,
      "commitsBetweenForRepo": 94,
      "commitsBetweenForFile": 1,
      "actualSource": "public void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    boolean typeable \u003d true;\n    switch(n.getType()) {\n        case Token.NAME:\n            typeable \u003d visitName(t, n, parent);\n            break;\n        case Token.LP:\n            if (parent.getType() !\u003d Token.FUNCTION) {\n                ensureTyped(t, n, getJSType(n.getFirstChild()));\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.COMMA:\n            ensureTyped(t, n, getJSType(n.getLastChild()));\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.THIS:\n            ensureTyped(t, n, t.getScope().getTypeOfThis());\n            break;\n        case Token.REF_SPECIAL:\n            ensureTyped(t, n);\n            break;\n        case Token.GET_REF:\n            ensureTyped(t, n, getJSType(n.getFirstChild()));\n            break;\n        case Token.NULL:\n            ensureTyped(t, n, NULL_TYPE);\n            break;\n        case Token.NUMBER:\n            if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n                ensureTyped(t, n, NUMBER_TYPE);\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.ARRAYLIT:\n            ensureTyped(t, n, ARRAY_TYPE);\n            break;\n        case Token.STRING:\n            if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n                ensureTyped(t, n, STRING_TYPE);\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.REGEXP:\n            ensureTyped(t, n, REGEXP_TYPE);\n            break;\n        case Token.GETPROP:\n            visitGetProp(t, n, parent);\n            typeable \u003d !(parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n            break;\n        case Token.GETELEM:\n            visitGetElem(t, n);\n            typeable \u003d false;\n            break;\n        case Token.VAR:\n            visitVar(t, n);\n            typeable \u003d false;\n            break;\n        case Token.NEW:\n            visitNew(t, n);\n            typeable \u003d true;\n            break;\n        case Token.CALL:\n            visitCall(t, n);\n            typeable \u003d !NodeUtil.isExpressionNode(parent);\n            break;\n        case Token.RETURN:\n            visitReturn(t, n);\n            typeable \u003d false;\n            break;\n        case Token.DEC:\n        case Token.INC:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.NOT:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.VOID:\n            ensureTyped(t, n, VOID_TYPE);\n            break;\n        case Token.TYPEOF:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.BITNOT:\n            childType \u003d getJSType(n.getFirstChild());\n            if (!childType.matchesInt32Context()) {\n                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n            }\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.EQ:\n        case Token.NE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                if (result !\u003d TernaryValue.UNKNOWN) {\n                    if (n.getType() \u003d\u003d Token.NE) {\n                        result \u003d result.not();\n                    }\n                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.SHEQ:\n        case Token.SHNE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                    report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n            leftType \u003d getJSType(n.getFirstChild());\n            rightType \u003d getJSType(n.getLastChild());\n            if (rightType.isNumber()) {\n                validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n            } else if (leftType.isNumber()) {\n                validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n            } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n            } else {\n                String message \u003d \"left side of comparison\";\n                validator.expectString(t, n, leftType, message);\n                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                message \u003d \"right side of comparison\";\n                validator.expectString(t, n, rightType, message);\n                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.IN:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right);\n            validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n            validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.INSTANCEOF:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n            validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n            validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.ASSIGN:\n            visitAssign(t, n);\n            typeable \u003d false;\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.ASSIGN_URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_SUB:\n        case Token.ASSIGN_ADD:\n        case Token.ASSIGN_MUL:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.URSH:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITOR:\n        case Token.BITXOR:\n        case Token.BITAND:\n        case Token.SUB:\n        case Token.ADD:\n        case Token.MUL:\n            visitBinaryOperator(n.getType(), t, n);\n            break;\n        case Token.DELPROP:\n            if (!isReference(n.getFirstChild())) {\n                report(t, n, BAD_DELETE);\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.CASE:\n            JSType switchType \u003d getJSType(parent.getFirstChild());\n            JSType caseType \u003d getJSType(n.getFirstChild());\n            validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n            typeable \u003d false;\n            break;\n        case Token.WITH:\n            {\n                Node child \u003d n.getFirstChild();\n                childType \u003d getJSType(child);\n                validator.expectObject(t, child, childType, \"with requires an object\");\n                typeable \u003d false;\n                break;\n            }\n        case Token.FUNCTION:\n            visitFunction(t, n);\n            break;\n        case Token.LABEL:\n        case Token.LABEL_NAME:\n        case Token.SWITCH:\n        case Token.BREAK:\n        case Token.CATCH:\n        case Token.TRY:\n        case Token.SCRIPT:\n        case Token.EXPR_RESULT:\n        case Token.BLOCK:\n        case Token.EMPTY:\n        case Token.DEFAULT:\n        case Token.CONTINUE:\n        case Token.DEBUGGER:\n        case Token.THROW:\n            typeable \u003d false;\n            break;\n        case Token.DO:\n        case Token.FOR:\n        case Token.IF:\n        case Token.WHILE:\n            typeable \u003d false;\n            break;\n        case Token.AND:\n        case Token.HOOK:\n        case Token.OBJECTLIT:\n        case Token.OR:\n            if (n.getJSType() !\u003d null) {\n                ensureTyped(t, n);\n            } else {\n                if ((n.getType() \u003d\u003d Token.OBJECTLIT) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                    ensureTyped(t, n, parent.getJSType());\n                } else {\n                    ensureTyped(t, n);\n                }\n            }\n            break;\n        default:\n            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n            ensureTyped(t, n);\n            break;\n    }\n    typeable \u003d typeable \u0026\u0026 !inExterns;\n    if (typeable) {\n        doPercentTypedAccounting(t, n);\n    }\n    checkNoTypeCheckSection(n, false);\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 447,
      "functionName": "visit",
      "functionAnnotation": "",
      "functionDoc": "This is the meat of the type checking.  It is basically one big switch,\nwith each case representing one type of parse tree node.  The individual\ncases are usually pretty straightforward.\n\n@param t The node traversal object that supplies context, such as the\nscope chain to use in name lookups as well as error reporting.\n@param n The node being visited.\n@param parent The parent of the node n.\n",
      "diff": "@@ -1,274 +1,274 @@\n public void visit(NodeTraversal t, Node n, Node parent) {\n     JSType childType;\n     JSType leftType, rightType;\n     Node left, right;\n     boolean typeable \u003d true;\n     switch(n.getType()) {\n         case Token.NAME:\n             typeable \u003d visitName(t, n, parent);\n             break;\n         case Token.LP:\n             if (parent.getType() !\u003d Token.FUNCTION) {\n                 ensureTyped(t, n, getJSType(n.getFirstChild()));\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.COMMA:\n             ensureTyped(t, n, getJSType(n.getLastChild()));\n             break;\n         case Token.TRUE:\n         case Token.FALSE:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.THIS:\n             ensureTyped(t, n, t.getScope().getTypeOfThis());\n             break;\n         case Token.REF_SPECIAL:\n             ensureTyped(t, n);\n             break;\n         case Token.GET_REF:\n             ensureTyped(t, n, getJSType(n.getFirstChild()));\n             break;\n         case Token.NULL:\n             ensureTyped(t, n, NULL_TYPE);\n             break;\n         case Token.NUMBER:\n             if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n                 ensureTyped(t, n, NUMBER_TYPE);\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.ARRAYLIT:\n             ensureTyped(t, n, ARRAY_TYPE);\n             break;\n         case Token.STRING:\n             if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n                 ensureTyped(t, n, STRING_TYPE);\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.REGEXP:\n             ensureTyped(t, n, REGEXP_TYPE);\n             break;\n         case Token.GETPROP:\n             visitGetProp(t, n, parent);\n             typeable \u003d !(parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n             break;\n         case Token.GETELEM:\n             visitGetElem(t, n);\n             typeable \u003d false;\n             break;\n         case Token.VAR:\n             visitVar(t, n);\n             typeable \u003d false;\n             break;\n         case Token.NEW:\n             visitNew(t, n);\n             typeable \u003d true;\n             break;\n         case Token.CALL:\n             visitCall(t, n);\n             typeable \u003d !NodeUtil.isExpressionNode(parent);\n             break;\n         case Token.RETURN:\n             visitReturn(t, n);\n             typeable \u003d false;\n             break;\n         case Token.DEC:\n         case Token.INC:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.NOT:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.VOID:\n             ensureTyped(t, n, VOID_TYPE);\n             break;\n         case Token.TYPEOF:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.BITNOT:\n             childType \u003d getJSType(n.getFirstChild());\n             if (!childType.matchesInt32Context()) {\n                 report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n             }\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.POS:\n         case Token.NEG:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.EQ:\n         case Token.NE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                 if (result !\u003d TernaryValue.UNKNOWN) {\n                     if (n.getType() \u003d\u003d Token.NE) {\n                         result \u003d result.not();\n                     }\n                     report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.SHEQ:\n         case Token.SHNE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                     report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.LT:\n         case Token.LE:\n         case Token.GT:\n         case Token.GE:\n             leftType \u003d getJSType(n.getFirstChild());\n             rightType \u003d getJSType(n.getLastChild());\n             if (rightType.isNumber()) {\n                 validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n             } else if (leftType.isNumber()) {\n                 validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n             } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n             } else {\n                 String message \u003d \"left side of comparison\";\n                 validator.expectString(t, n, leftType, message);\n-                validator.expectNotVoid(t, n, leftType, message, getNativeType(STRING_TYPE));\n+                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\n                 message \u003d \"right side of comparison\";\n                 validator.expectString(t, n, rightType, message);\n-                validator.expectNotVoid(t, n, rightType, message, getNativeType(STRING_TYPE));\n+                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.IN:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right);\n             validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n             validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.INSTANCEOF:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n             validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n             validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.ASSIGN:\n             visitAssign(t, n);\n             typeable \u003d false;\n             break;\n         case Token.ASSIGN_LSH:\n         case Token.ASSIGN_RSH:\n         case Token.ASSIGN_URSH:\n         case Token.ASSIGN_DIV:\n         case Token.ASSIGN_MOD:\n         case Token.ASSIGN_BITOR:\n         case Token.ASSIGN_BITXOR:\n         case Token.ASSIGN_BITAND:\n         case Token.ASSIGN_SUB:\n         case Token.ASSIGN_ADD:\n         case Token.ASSIGN_MUL:\n         case Token.LSH:\n         case Token.RSH:\n         case Token.URSH:\n         case Token.DIV:\n         case Token.MOD:\n         case Token.BITOR:\n         case Token.BITXOR:\n         case Token.BITAND:\n         case Token.SUB:\n         case Token.ADD:\n         case Token.MUL:\n             visitBinaryOperator(n.getType(), t, n);\n             break;\n         case Token.DELPROP:\n             if (!isReference(n.getFirstChild())) {\n                 report(t, n, BAD_DELETE);\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.CASE:\n             JSType switchType \u003d getJSType(parent.getFirstChild());\n             JSType caseType \u003d getJSType(n.getFirstChild());\n             validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n             typeable \u003d false;\n             break;\n         case Token.WITH:\n             {\n                 Node child \u003d n.getFirstChild();\n                 childType \u003d getJSType(child);\n                 validator.expectObject(t, child, childType, \"with requires an object\");\n                 typeable \u003d false;\n                 break;\n             }\n         case Token.FUNCTION:\n             visitFunction(t, n);\n             break;\n         case Token.LABEL:\n         case Token.LABEL_NAME:\n         case Token.SWITCH:\n         case Token.BREAK:\n         case Token.CATCH:\n         case Token.TRY:\n         case Token.SCRIPT:\n         case Token.EXPR_RESULT:\n         case Token.BLOCK:\n         case Token.EMPTY:\n         case Token.DEFAULT:\n         case Token.CONTINUE:\n         case Token.DEBUGGER:\n         case Token.THROW:\n             typeable \u003d false;\n             break;\n         case Token.DO:\n         case Token.FOR:\n         case Token.IF:\n         case Token.WHILE:\n             typeable \u003d false;\n             break;\n         case Token.AND:\n         case Token.HOOK:\n         case Token.OBJECTLIT:\n         case Token.OR:\n             if (n.getJSType() !\u003d null) {\n                 ensureTyped(t, n);\n             } else {\n                 if ((n.getType() \u003d\u003d Token.OBJECTLIT) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                     ensureTyped(t, n, parent.getJSType());\n                 } else {\n                     ensureTyped(t, n);\n                 }\n             }\n             break;\n         default:\n             report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n             ensureTyped(t, n);\n             break;\n     }\n     typeable \u003d typeable \u0026\u0026 !inExterns;\n     if (typeable) {\n         doPercentTypedAccounting(t, n);\n     }\n     checkNoTypeCheckSection(n, false);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0895c28861ee4a1969acc858f1a703ab11ddc64c": {
      "type": "Ybodychange",
      "commitMessage": "\n\nChange on 2010/06/16 by johnlenz\n\n        Remove unused member variable.\n\n        R\u003dacleung\n        DELTA\u003d17  (0 added, 12 deleted, 5 changed)\n\nChange on 2010/06/16 by acleung\n\n        Make @notypecheck behaves like it is doing typechecking except for reporting errors.\n\n        R\u003djohnlenz\n        DELTA\u003d144  (89 added, 17 deleted, 38 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d28012\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@245 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "6/17/10, 10:16 AM",
      "commitName": "0895c28861ee4a1969acc858f1a703ab11ddc64c",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "5/3/10, 7:03 AM",
      "commitNameOld": "9147da9979fb00599efd700fa5e0cccfa93d25a5",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 45.13,
      "commitsBetweenForRepo": 32,
      "commitsBetweenForFile": 1,
      "actualSource": "public void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    boolean typeable \u003d true;\n    switch(n.getType()) {\n        case Token.NAME:\n            typeable \u003d visitName(t, n, parent);\n            break;\n        case Token.LP:\n            if (parent.getType() !\u003d Token.FUNCTION) {\n                ensureTyped(t, n, getJSType(n.getFirstChild()));\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.COMMA:\n            ensureTyped(t, n, getJSType(n.getLastChild()));\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.THIS:\n            ensureTyped(t, n, t.getScope().getTypeOfThis());\n            break;\n        case Token.REF_SPECIAL:\n            ensureTyped(t, n);\n            break;\n        case Token.GET_REF:\n            ensureTyped(t, n, getJSType(n.getFirstChild()));\n            break;\n        case Token.NULL:\n            ensureTyped(t, n, NULL_TYPE);\n            break;\n        case Token.NUMBER:\n            if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n                ensureTyped(t, n, NUMBER_TYPE);\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.ARRAYLIT:\n            ensureTyped(t, n, ARRAY_TYPE);\n            break;\n        case Token.STRING:\n            if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n                ensureTyped(t, n, STRING_TYPE);\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.REGEXP:\n            ensureTyped(t, n, REGEXP_TYPE);\n            break;\n        case Token.GETPROP:\n            visitGetProp(t, n, parent);\n            typeable \u003d !(parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n            break;\n        case Token.GETELEM:\n            visitGetElem(t, n);\n            typeable \u003d false;\n            break;\n        case Token.VAR:\n            visitVar(t, n);\n            typeable \u003d false;\n            break;\n        case Token.NEW:\n            visitNew(t, n);\n            typeable \u003d true;\n            break;\n        case Token.CALL:\n            visitCall(t, n);\n            typeable \u003d !NodeUtil.isExpressionNode(parent);\n            break;\n        case Token.RETURN:\n            visitReturn(t, n);\n            typeable \u003d false;\n            break;\n        case Token.DEC:\n        case Token.INC:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.NOT:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.VOID:\n            ensureTyped(t, n, VOID_TYPE);\n            break;\n        case Token.TYPEOF:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.BITNOT:\n            childType \u003d getJSType(n.getFirstChild());\n            if (!childType.matchesInt32Context()) {\n                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n            }\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.EQ:\n        case Token.NE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                if (result !\u003d TernaryValue.UNKNOWN) {\n                    if (n.getType() \u003d\u003d Token.NE) {\n                        result \u003d result.not();\n                    }\n                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.SHEQ:\n        case Token.SHNE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                    report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n            leftType \u003d getJSType(n.getFirstChild());\n            rightType \u003d getJSType(n.getLastChild());\n            if (rightType.isNumber()) {\n                validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n            } else if (leftType.isNumber()) {\n                validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n            } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n            } else {\n                String message \u003d \"left side of comparison\";\n                validator.expectString(t, n, leftType, message);\n                validator.expectNotVoid(t, n, leftType, message, getNativeType(STRING_TYPE));\n                message \u003d \"right side of comparison\";\n                validator.expectString(t, n, rightType, message);\n                validator.expectNotVoid(t, n, rightType, message, getNativeType(STRING_TYPE));\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.IN:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right);\n            validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n            validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.INSTANCEOF:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n            validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n            validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.ASSIGN:\n            visitAssign(t, n);\n            typeable \u003d false;\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.ASSIGN_URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_SUB:\n        case Token.ASSIGN_ADD:\n        case Token.ASSIGN_MUL:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.URSH:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITOR:\n        case Token.BITXOR:\n        case Token.BITAND:\n        case Token.SUB:\n        case Token.ADD:\n        case Token.MUL:\n            visitBinaryOperator(n.getType(), t, n);\n            break;\n        case Token.DELPROP:\n            if (!isReference(n.getFirstChild())) {\n                report(t, n, BAD_DELETE);\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.CASE:\n            JSType switchType \u003d getJSType(parent.getFirstChild());\n            JSType caseType \u003d getJSType(n.getFirstChild());\n            validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n            typeable \u003d false;\n            break;\n        case Token.WITH:\n            {\n                Node child \u003d n.getFirstChild();\n                childType \u003d getJSType(child);\n                validator.expectObject(t, child, childType, \"with requires an object\");\n                typeable \u003d false;\n                break;\n            }\n        case Token.FUNCTION:\n            visitFunction(t, n);\n            break;\n        case Token.LABEL:\n        case Token.LABEL_NAME:\n        case Token.SWITCH:\n        case Token.BREAK:\n        case Token.CATCH:\n        case Token.TRY:\n        case Token.SCRIPT:\n        case Token.EXPR_RESULT:\n        case Token.BLOCK:\n        case Token.EMPTY:\n        case Token.DEFAULT:\n        case Token.CONTINUE:\n        case Token.DEBUGGER:\n        case Token.THROW:\n            typeable \u003d false;\n            break;\n        case Token.DO:\n        case Token.FOR:\n        case Token.IF:\n        case Token.WHILE:\n            typeable \u003d false;\n            break;\n        case Token.AND:\n        case Token.HOOK:\n        case Token.OBJECTLIT:\n        case Token.OR:\n            if (n.getJSType() !\u003d null) {\n                ensureTyped(t, n);\n            } else {\n                if ((n.getType() \u003d\u003d Token.OBJECTLIT) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                    ensureTyped(t, n, parent.getJSType());\n                } else {\n                    ensureTyped(t, n);\n                }\n            }\n            break;\n        default:\n            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n            ensureTyped(t, n);\n            break;\n    }\n    typeable \u003d typeable \u0026\u0026 !inExterns;\n    if (typeable) {\n        doPercentTypedAccounting(t, n);\n    }\n    checkNoTypeCheckSection(n, false);\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 444,
      "functionName": "visit",
      "functionAnnotation": "",
      "functionDoc": "This is the meat of the type checking.  It is basically one big switch,\nwith each case representing one type of parse tree node.  The individual\ncases are usually pretty straightforward.\n\n@param t The node traversal object that supplies context, such as the\nscope chain to use in name lookups as well as error reporting.\n@param n The node being visited.\n@param parent The parent of the node n.\n",
      "diff": "@@ -1,273 +1,274 @@\n public void visit(NodeTraversal t, Node n, Node parent) {\n     JSType childType;\n     JSType leftType, rightType;\n     Node left, right;\n     boolean typeable \u003d true;\n     switch(n.getType()) {\n         case Token.NAME:\n             typeable \u003d visitName(t, n, parent);\n             break;\n         case Token.LP:\n             if (parent.getType() !\u003d Token.FUNCTION) {\n                 ensureTyped(t, n, getJSType(n.getFirstChild()));\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.COMMA:\n             ensureTyped(t, n, getJSType(n.getLastChild()));\n             break;\n         case Token.TRUE:\n         case Token.FALSE:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.THIS:\n             ensureTyped(t, n, t.getScope().getTypeOfThis());\n             break;\n         case Token.REF_SPECIAL:\n             ensureTyped(t, n);\n             break;\n         case Token.GET_REF:\n             ensureTyped(t, n, getJSType(n.getFirstChild()));\n             break;\n         case Token.NULL:\n             ensureTyped(t, n, NULL_TYPE);\n             break;\n         case Token.NUMBER:\n             if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n                 ensureTyped(t, n, NUMBER_TYPE);\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.ARRAYLIT:\n             ensureTyped(t, n, ARRAY_TYPE);\n             break;\n         case Token.STRING:\n             if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n                 ensureTyped(t, n, STRING_TYPE);\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.REGEXP:\n             ensureTyped(t, n, REGEXP_TYPE);\n             break;\n         case Token.GETPROP:\n             visitGetProp(t, n, parent);\n             typeable \u003d !(parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n             break;\n         case Token.GETELEM:\n             visitGetElem(t, n);\n             typeable \u003d false;\n             break;\n         case Token.VAR:\n             visitVar(t, n);\n             typeable \u003d false;\n             break;\n         case Token.NEW:\n             visitNew(t, n);\n             typeable \u003d true;\n             break;\n         case Token.CALL:\n             visitCall(t, n);\n             typeable \u003d !NodeUtil.isExpressionNode(parent);\n             break;\n         case Token.RETURN:\n             visitReturn(t, n);\n             typeable \u003d false;\n             break;\n         case Token.DEC:\n         case Token.INC:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.NOT:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.VOID:\n             ensureTyped(t, n, VOID_TYPE);\n             break;\n         case Token.TYPEOF:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.BITNOT:\n             childType \u003d getJSType(n.getFirstChild());\n             if (!childType.matchesInt32Context()) {\n-                t.report(n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n+                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n             }\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.POS:\n         case Token.NEG:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.EQ:\n         case Token.NE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                 if (result !\u003d TernaryValue.UNKNOWN) {\n                     if (n.getType() \u003d\u003d Token.NE) {\n                         result \u003d result.not();\n                     }\n-                    t.report(n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n+                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.SHEQ:\n         case Token.SHNE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n-                    t.report(n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n+                    report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.LT:\n         case Token.LE:\n         case Token.GT:\n         case Token.GE:\n             leftType \u003d getJSType(n.getFirstChild());\n             rightType \u003d getJSType(n.getLastChild());\n             if (rightType.isNumber()) {\n                 validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n             } else if (leftType.isNumber()) {\n                 validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n             } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n             } else {\n                 String message \u003d \"left side of comparison\";\n                 validator.expectString(t, n, leftType, message);\n                 validator.expectNotVoid(t, n, leftType, message, getNativeType(STRING_TYPE));\n                 message \u003d \"right side of comparison\";\n                 validator.expectString(t, n, rightType, message);\n                 validator.expectNotVoid(t, n, rightType, message, getNativeType(STRING_TYPE));\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.IN:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right);\n             validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n             validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.INSTANCEOF:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n             validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n             validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.ASSIGN:\n             visitAssign(t, n);\n             typeable \u003d false;\n             break;\n         case Token.ASSIGN_LSH:\n         case Token.ASSIGN_RSH:\n         case Token.ASSIGN_URSH:\n         case Token.ASSIGN_DIV:\n         case Token.ASSIGN_MOD:\n         case Token.ASSIGN_BITOR:\n         case Token.ASSIGN_BITXOR:\n         case Token.ASSIGN_BITAND:\n         case Token.ASSIGN_SUB:\n         case Token.ASSIGN_ADD:\n         case Token.ASSIGN_MUL:\n         case Token.LSH:\n         case Token.RSH:\n         case Token.URSH:\n         case Token.DIV:\n         case Token.MOD:\n         case Token.BITOR:\n         case Token.BITXOR:\n         case Token.BITAND:\n         case Token.SUB:\n         case Token.ADD:\n         case Token.MUL:\n             visitBinaryOperator(n.getType(), t, n);\n             break;\n         case Token.DELPROP:\n             if (!isReference(n.getFirstChild())) {\n-                t.report(n, BAD_DELETE);\n+                report(t, n, BAD_DELETE);\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.CASE:\n             JSType switchType \u003d getJSType(parent.getFirstChild());\n             JSType caseType \u003d getJSType(n.getFirstChild());\n             validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n             typeable \u003d false;\n             break;\n         case Token.WITH:\n             {\n                 Node child \u003d n.getFirstChild();\n                 childType \u003d getJSType(child);\n                 validator.expectObject(t, child, childType, \"with requires an object\");\n                 typeable \u003d false;\n                 break;\n             }\n         case Token.FUNCTION:\n             visitFunction(t, n);\n             break;\n         case Token.LABEL:\n         case Token.LABEL_NAME:\n         case Token.SWITCH:\n         case Token.BREAK:\n         case Token.CATCH:\n         case Token.TRY:\n         case Token.SCRIPT:\n         case Token.EXPR_RESULT:\n         case Token.BLOCK:\n         case Token.EMPTY:\n         case Token.DEFAULT:\n         case Token.CONTINUE:\n         case Token.DEBUGGER:\n         case Token.THROW:\n             typeable \u003d false;\n             break;\n         case Token.DO:\n         case Token.FOR:\n         case Token.IF:\n         case Token.WHILE:\n             typeable \u003d false;\n             break;\n         case Token.AND:\n         case Token.HOOK:\n         case Token.OBJECTLIT:\n         case Token.OR:\n             if (n.getJSType() !\u003d null) {\n                 ensureTyped(t, n);\n             } else {\n                 if ((n.getType() \u003d\u003d Token.OBJECTLIT) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                     ensureTyped(t, n, parent.getJSType());\n                 } else {\n                     ensureTyped(t, n);\n                 }\n             }\n             break;\n         default:\n-            t.report(n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n+            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n             ensureTyped(t, n);\n             break;\n     }\n     typeable \u003d typeable \u0026\u0026 !inExterns;\n     if (typeable) {\n         doPercentTypedAccounting(t, n);\n     }\n+    checkNoTypeCheckSection(n, false);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "222eafd303155b3eac5cd244584b2cb3c4c11975": {
      "type": "Ybodychange",
      "commitMessage": "tighten up some types. (Nick)\nR\u003dalan\nDELTA\u003d4  (2 added, 0 deleted, 2 changed)\n\nDon\u0027t use NAME for label names, introduce LABEL_NAME. This improves the correctness of the compiler as many passes don\u0027t distinguish between label names and variable names appropriately. (John)\nR\u003drobert\n\nRemove now unneeded checks for label names when inspecting NAME nodes. (John)\nR\u003drobert\n\nTweak code generator to break after blocks for better pretty printing. (John)\nR\u003drobert\nDELTA\u003d196  (160 added, 0 deleted, 36 changed)\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003dktmses\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@170 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/5/10, 12:30 PM",
      "commitName": "222eafd303155b3eac5cd244584b2cb3c4c11975",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "4/1/10, 7:32 PM",
      "commitNameOld": "f01925cbf7a39a885e51865208368e861d25a0c1",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 3.71,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "public void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    boolean typeable \u003d true;\n    switch(n.getType()) {\n        case Token.NAME:\n            typeable \u003d visitName(t, n, parent);\n            break;\n        case Token.LP:\n            if (parent.getType() !\u003d Token.FUNCTION) {\n                ensureTyped(t, n, getJSType(n.getFirstChild()));\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.COMMA:\n            ensureTyped(t, n, getJSType(n.getLastChild()));\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.THIS:\n            ensureTyped(t, n, t.getScope().getTypeOfThis());\n            break;\n        case Token.REF_SPECIAL:\n            ensureTyped(t, n);\n            break;\n        case Token.GET_REF:\n            ensureTyped(t, n, getJSType(n.getFirstChild()));\n            break;\n        case Token.NULL:\n            ensureTyped(t, n, NULL_TYPE);\n            break;\n        case Token.NUMBER:\n            if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n                ensureTyped(t, n, NUMBER_TYPE);\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.ARRAYLIT:\n            ensureTyped(t, n, ARRAY_TYPE);\n            break;\n        case Token.STRING:\n            if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n                ensureTyped(t, n, STRING_TYPE);\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.REGEXP:\n            ensureTyped(t, n, REGEXP_TYPE);\n            break;\n        case Token.GETPROP:\n            visitGetProp(t, n, parent);\n            typeable \u003d !(parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n            break;\n        case Token.GETELEM:\n            visitGetElem(t, n);\n            typeable \u003d false;\n            break;\n        case Token.VAR:\n            visitVar(t, n);\n            typeable \u003d false;\n            break;\n        case Token.NEW:\n            visitNew(t, n);\n            typeable \u003d true;\n            break;\n        case Token.CALL:\n            visitCall(t, n);\n            typeable \u003d !NodeUtil.isExpressionNode(parent);\n            break;\n        case Token.RETURN:\n            visitReturn(t, n);\n            typeable \u003d false;\n            break;\n        case Token.DEC:\n        case Token.INC:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.NOT:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.VOID:\n            ensureTyped(t, n, VOID_TYPE);\n            break;\n        case Token.TYPEOF:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.BITNOT:\n            childType \u003d getJSType(n.getFirstChild());\n            if (!childType.matchesInt32Context()) {\n                t.report(n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n            }\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.EQ:\n        case Token.NE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                if (result !\u003d TernaryValue.UNKNOWN) {\n                    if (n.getType() \u003d\u003d Token.NE) {\n                        result \u003d result.not();\n                    }\n                    t.report(n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.SHEQ:\n        case Token.SHNE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                    t.report(n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n            leftType \u003d getJSType(n.getFirstChild());\n            rightType \u003d getJSType(n.getLastChild());\n            if (rightType.isNumber()) {\n                validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n            } else if (leftType.isNumber()) {\n                validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n            } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n            } else {\n                String message \u003d \"left side of comparison\";\n                validator.expectString(t, n, leftType, message);\n                validator.expectNotVoid(t, n, leftType, message, getNativeType(STRING_TYPE));\n                message \u003d \"right side of comparison\";\n                validator.expectString(t, n, rightType, message);\n                validator.expectNotVoid(t, n, rightType, message, getNativeType(STRING_TYPE));\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.IN:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right);\n            validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n            validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.INSTANCEOF:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n            validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n            validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.ASSIGN:\n            visitAssign(t, n);\n            typeable \u003d false;\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.ASSIGN_URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_SUB:\n        case Token.ASSIGN_ADD:\n        case Token.ASSIGN_MUL:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.URSH:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITOR:\n        case Token.BITXOR:\n        case Token.BITAND:\n        case Token.SUB:\n        case Token.ADD:\n        case Token.MUL:\n            visitBinaryOperator(n.getType(), t, n);\n            break;\n        case Token.DELPROP:\n            if (!isReference(n.getFirstChild())) {\n                t.report(n, BAD_DELETE);\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.CASE:\n            JSType switchType \u003d getJSType(parent.getFirstChild());\n            JSType caseType \u003d getJSType(n.getFirstChild());\n            validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n            typeable \u003d false;\n            break;\n        case Token.WITH:\n            {\n                Node child \u003d n.getFirstChild();\n                childType \u003d getJSType(child);\n                validator.expectObject(t, child, childType, \"with requires an object\");\n                typeable \u003d false;\n                break;\n            }\n        case Token.FUNCTION:\n            visitFunction(t, n);\n            break;\n        case Token.LABEL:\n        case Token.LABEL_NAME:\n        case Token.SWITCH:\n        case Token.BREAK:\n        case Token.CATCH:\n        case Token.TRY:\n        case Token.SCRIPT:\n        case Token.EXPR_RESULT:\n        case Token.BLOCK:\n        case Token.EMPTY:\n        case Token.DEFAULT:\n        case Token.CONTINUE:\n        case Token.DEBUGGER:\n        case Token.THROW:\n            typeable \u003d false;\n            break;\n        case Token.DO:\n        case Token.FOR:\n        case Token.IF:\n        case Token.WHILE:\n            typeable \u003d false;\n            break;\n        case Token.AND:\n        case Token.HOOK:\n        case Token.OBJECTLIT:\n        case Token.OR:\n            if (n.getJSType() !\u003d null) {\n                ensureTyped(t, n);\n            } else {\n                if ((n.getType() \u003d\u003d Token.OBJECTLIT) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                    ensureTyped(t, n, parent.getJSType());\n                } else {\n                    ensureTyped(t, n);\n                }\n            }\n            break;\n        default:\n            t.report(n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n            ensureTyped(t, n);\n            break;\n    }\n    typeable \u003d typeable \u0026\u0026 !inExterns;\n    if (typeable) {\n        doPercentTypedAccounting(t, n);\n    }\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 436,
      "functionName": "visit",
      "functionAnnotation": "",
      "functionDoc": "This is the meat of the type checking.  It is basically one big switch,\nwith each case representing one type of parse tree node.  The individual\ncases are usually pretty straightforward.\n\n@param t The node traversal object that supplies context, such as the\nscope chain to use in name lookups as well as error reporting.\n@param n The node being visited.\n@param parent The parent of the node n.\n",
      "diff": "@@ -1,272 +1,273 @@\n public void visit(NodeTraversal t, Node n, Node parent) {\n     JSType childType;\n     JSType leftType, rightType;\n     Node left, right;\n     boolean typeable \u003d true;\n     switch(n.getType()) {\n         case Token.NAME:\n             typeable \u003d visitName(t, n, parent);\n             break;\n         case Token.LP:\n             if (parent.getType() !\u003d Token.FUNCTION) {\n                 ensureTyped(t, n, getJSType(n.getFirstChild()));\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.COMMA:\n             ensureTyped(t, n, getJSType(n.getLastChild()));\n             break;\n         case Token.TRUE:\n         case Token.FALSE:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.THIS:\n             ensureTyped(t, n, t.getScope().getTypeOfThis());\n             break;\n         case Token.REF_SPECIAL:\n             ensureTyped(t, n);\n             break;\n         case Token.GET_REF:\n             ensureTyped(t, n, getJSType(n.getFirstChild()));\n             break;\n         case Token.NULL:\n             ensureTyped(t, n, NULL_TYPE);\n             break;\n         case Token.NUMBER:\n             if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n                 ensureTyped(t, n, NUMBER_TYPE);\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.ARRAYLIT:\n             ensureTyped(t, n, ARRAY_TYPE);\n             break;\n         case Token.STRING:\n             if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n                 ensureTyped(t, n, STRING_TYPE);\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.REGEXP:\n             ensureTyped(t, n, REGEXP_TYPE);\n             break;\n         case Token.GETPROP:\n             visitGetProp(t, n, parent);\n             typeable \u003d !(parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n             break;\n         case Token.GETELEM:\n             visitGetElem(t, n);\n             typeable \u003d false;\n             break;\n         case Token.VAR:\n             visitVar(t, n);\n             typeable \u003d false;\n             break;\n         case Token.NEW:\n             visitNew(t, n);\n             typeable \u003d true;\n             break;\n         case Token.CALL:\n             visitCall(t, n);\n             typeable \u003d !NodeUtil.isExpressionNode(parent);\n             break;\n         case Token.RETURN:\n             visitReturn(t, n);\n             typeable \u003d false;\n             break;\n         case Token.DEC:\n         case Token.INC:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.NOT:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.VOID:\n             ensureTyped(t, n, VOID_TYPE);\n             break;\n         case Token.TYPEOF:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.BITNOT:\n             childType \u003d getJSType(n.getFirstChild());\n             if (!childType.matchesInt32Context()) {\n                 t.report(n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n             }\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.POS:\n         case Token.NEG:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.EQ:\n         case Token.NE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                 if (result !\u003d TernaryValue.UNKNOWN) {\n                     if (n.getType() \u003d\u003d Token.NE) {\n                         result \u003d result.not();\n                     }\n                     t.report(n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.SHEQ:\n         case Token.SHNE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                     t.report(n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.LT:\n         case Token.LE:\n         case Token.GT:\n         case Token.GE:\n             leftType \u003d getJSType(n.getFirstChild());\n             rightType \u003d getJSType(n.getLastChild());\n             if (rightType.isNumber()) {\n                 validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n             } else if (leftType.isNumber()) {\n                 validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n             } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n             } else {\n                 String message \u003d \"left side of comparison\";\n                 validator.expectString(t, n, leftType, message);\n                 validator.expectNotVoid(t, n, leftType, message, getNativeType(STRING_TYPE));\n                 message \u003d \"right side of comparison\";\n                 validator.expectString(t, n, rightType, message);\n                 validator.expectNotVoid(t, n, rightType, message, getNativeType(STRING_TYPE));\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.IN:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right);\n             validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n             validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.INSTANCEOF:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n             validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n             validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.ASSIGN:\n             visitAssign(t, n);\n             typeable \u003d false;\n             break;\n         case Token.ASSIGN_LSH:\n         case Token.ASSIGN_RSH:\n         case Token.ASSIGN_URSH:\n         case Token.ASSIGN_DIV:\n         case Token.ASSIGN_MOD:\n         case Token.ASSIGN_BITOR:\n         case Token.ASSIGN_BITXOR:\n         case Token.ASSIGN_BITAND:\n         case Token.ASSIGN_SUB:\n         case Token.ASSIGN_ADD:\n         case Token.ASSIGN_MUL:\n         case Token.LSH:\n         case Token.RSH:\n         case Token.URSH:\n         case Token.DIV:\n         case Token.MOD:\n         case Token.BITOR:\n         case Token.BITXOR:\n         case Token.BITAND:\n         case Token.SUB:\n         case Token.ADD:\n         case Token.MUL:\n             visitBinaryOperator(n.getType(), t, n);\n             break;\n         case Token.DELPROP:\n             if (!isReference(n.getFirstChild())) {\n                 t.report(n, BAD_DELETE);\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.CASE:\n             JSType switchType \u003d getJSType(parent.getFirstChild());\n             JSType caseType \u003d getJSType(n.getFirstChild());\n             validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n             typeable \u003d false;\n             break;\n         case Token.WITH:\n             {\n                 Node child \u003d n.getFirstChild();\n                 childType \u003d getJSType(child);\n                 validator.expectObject(t, child, childType, \"with requires an object\");\n                 typeable \u003d false;\n                 break;\n             }\n         case Token.FUNCTION:\n             visitFunction(t, n);\n             break;\n         case Token.LABEL:\n+        case Token.LABEL_NAME:\n         case Token.SWITCH:\n         case Token.BREAK:\n         case Token.CATCH:\n         case Token.TRY:\n         case Token.SCRIPT:\n         case Token.EXPR_RESULT:\n         case Token.BLOCK:\n         case Token.EMPTY:\n         case Token.DEFAULT:\n         case Token.CONTINUE:\n         case Token.DEBUGGER:\n         case Token.THROW:\n             typeable \u003d false;\n             break;\n         case Token.DO:\n         case Token.FOR:\n         case Token.IF:\n         case Token.WHILE:\n             typeable \u003d false;\n             break;\n         case Token.AND:\n         case Token.HOOK:\n         case Token.OBJECTLIT:\n         case Token.OR:\n             if (n.getJSType() !\u003d null) {\n                 ensureTyped(t, n);\n             } else {\n                 if ((n.getType() \u003d\u003d Token.OBJECTLIT) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                     ensureTyped(t, n, parent.getJSType());\n                 } else {\n                     ensureTyped(t, n);\n                 }\n             }\n             break;\n         default:\n             t.report(n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n             ensureTyped(t, n);\n             break;\n     }\n     typeable \u003d typeable \u0026\u0026 !inExterns;\n     if (typeable) {\n         doPercentTypedAccounting(t, n);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f01925cbf7a39a885e51865208368e861d25a0c1": {
      "type": "Ybodychange",
      "commitMessage": "Tests for deps generation (Nick)\nR\u003dandrew\n\nFix for decomposing assignment-ops. (john)\nR\u003dalan\nDELTA\u003d159  (127 added, 21 deleted, 11 changed)\n\nRemove unneeded imports. (John)\nR\u003drobert\nDELTA\u003d2  (0 added, 2 deleted, 0 changed)\n\nAutomated rollback of:\nRemove now unneeded checks for label names when inspecting NAME nodes. (Robert)\nR\u003dAlan\nDELTA\u003d6  (4 added, 0 deleted, 2 changed)\n\nAutomated rollback of:\nDon\u0027t use NAME for label names, introduce LABEL_NAME. This improves the correctness of the compiler as many passes don\u0027t distinguish between label names and variable names appropriately. (Robert)\nR\u003dAlan\nDELTA\u003d57  (12 added, 29 deleted, 16 changed)\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003dgydkaf\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@167 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/1/10, 7:32 PM",
      "commitName": "f01925cbf7a39a885e51865208368e861d25a0c1",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "3/30/10, 9:01 PM",
      "commitNameOld": "8c5eb247cb5361a6ffa2d86aa4c2de17c234bda7",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 1.94,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "public void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    boolean typeable \u003d true;\n    switch(n.getType()) {\n        case Token.NAME:\n            typeable \u003d visitName(t, n, parent);\n            break;\n        case Token.LP:\n            if (parent.getType() !\u003d Token.FUNCTION) {\n                ensureTyped(t, n, getJSType(n.getFirstChild()));\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.COMMA:\n            ensureTyped(t, n, getJSType(n.getLastChild()));\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.THIS:\n            ensureTyped(t, n, t.getScope().getTypeOfThis());\n            break;\n        case Token.REF_SPECIAL:\n            ensureTyped(t, n);\n            break;\n        case Token.GET_REF:\n            ensureTyped(t, n, getJSType(n.getFirstChild()));\n            break;\n        case Token.NULL:\n            ensureTyped(t, n, NULL_TYPE);\n            break;\n        case Token.NUMBER:\n            if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n                ensureTyped(t, n, NUMBER_TYPE);\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.ARRAYLIT:\n            ensureTyped(t, n, ARRAY_TYPE);\n            break;\n        case Token.STRING:\n            if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n                ensureTyped(t, n, STRING_TYPE);\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.REGEXP:\n            ensureTyped(t, n, REGEXP_TYPE);\n            break;\n        case Token.GETPROP:\n            visitGetProp(t, n, parent);\n            typeable \u003d !(parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n            break;\n        case Token.GETELEM:\n            visitGetElem(t, n);\n            typeable \u003d false;\n            break;\n        case Token.VAR:\n            visitVar(t, n);\n            typeable \u003d false;\n            break;\n        case Token.NEW:\n            visitNew(t, n);\n            typeable \u003d true;\n            break;\n        case Token.CALL:\n            visitCall(t, n);\n            typeable \u003d !NodeUtil.isExpressionNode(parent);\n            break;\n        case Token.RETURN:\n            visitReturn(t, n);\n            typeable \u003d false;\n            break;\n        case Token.DEC:\n        case Token.INC:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.NOT:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.VOID:\n            ensureTyped(t, n, VOID_TYPE);\n            break;\n        case Token.TYPEOF:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.BITNOT:\n            childType \u003d getJSType(n.getFirstChild());\n            if (!childType.matchesInt32Context()) {\n                t.report(n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n            }\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.EQ:\n        case Token.NE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                if (result !\u003d TernaryValue.UNKNOWN) {\n                    if (n.getType() \u003d\u003d Token.NE) {\n                        result \u003d result.not();\n                    }\n                    t.report(n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.SHEQ:\n        case Token.SHNE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                    t.report(n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n            leftType \u003d getJSType(n.getFirstChild());\n            rightType \u003d getJSType(n.getLastChild());\n            if (rightType.isNumber()) {\n                validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n            } else if (leftType.isNumber()) {\n                validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n            } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n            } else {\n                String message \u003d \"left side of comparison\";\n                validator.expectString(t, n, leftType, message);\n                validator.expectNotVoid(t, n, leftType, message, getNativeType(STRING_TYPE));\n                message \u003d \"right side of comparison\";\n                validator.expectString(t, n, rightType, message);\n                validator.expectNotVoid(t, n, rightType, message, getNativeType(STRING_TYPE));\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.IN:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right);\n            validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n            validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.INSTANCEOF:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n            validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n            validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.ASSIGN:\n            visitAssign(t, n);\n            typeable \u003d false;\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.ASSIGN_URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_SUB:\n        case Token.ASSIGN_ADD:\n        case Token.ASSIGN_MUL:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.URSH:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITOR:\n        case Token.BITXOR:\n        case Token.BITAND:\n        case Token.SUB:\n        case Token.ADD:\n        case Token.MUL:\n            visitBinaryOperator(n.getType(), t, n);\n            break;\n        case Token.DELPROP:\n            if (!isReference(n.getFirstChild())) {\n                t.report(n, BAD_DELETE);\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.CASE:\n            JSType switchType \u003d getJSType(parent.getFirstChild());\n            JSType caseType \u003d getJSType(n.getFirstChild());\n            validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n            typeable \u003d false;\n            break;\n        case Token.WITH:\n            {\n                Node child \u003d n.getFirstChild();\n                childType \u003d getJSType(child);\n                validator.expectObject(t, child, childType, \"with requires an object\");\n                typeable \u003d false;\n                break;\n            }\n        case Token.FUNCTION:\n            visitFunction(t, n);\n            break;\n        case Token.LABEL:\n        case Token.SWITCH:\n        case Token.BREAK:\n        case Token.CATCH:\n        case Token.TRY:\n        case Token.SCRIPT:\n        case Token.EXPR_RESULT:\n        case Token.BLOCK:\n        case Token.EMPTY:\n        case Token.DEFAULT:\n        case Token.CONTINUE:\n        case Token.DEBUGGER:\n        case Token.THROW:\n            typeable \u003d false;\n            break;\n        case Token.DO:\n        case Token.FOR:\n        case Token.IF:\n        case Token.WHILE:\n            typeable \u003d false;\n            break;\n        case Token.AND:\n        case Token.HOOK:\n        case Token.OBJECTLIT:\n        case Token.OR:\n            if (n.getJSType() !\u003d null) {\n                ensureTyped(t, n);\n            } else {\n                if ((n.getType() \u003d\u003d Token.OBJECTLIT) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                    ensureTyped(t, n, parent.getJSType());\n                } else {\n                    ensureTyped(t, n);\n                }\n            }\n            break;\n        default:\n            t.report(n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n            ensureTyped(t, n);\n            break;\n    }\n    typeable \u003d typeable \u0026\u0026 !inExterns;\n    if (typeable) {\n        doPercentTypedAccounting(t, n);\n    }\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 436,
      "functionName": "visit",
      "functionAnnotation": "",
      "functionDoc": "This is the meat of the type checking.  It is basically one big switch,\nwith each case representing one type of parse tree node.  The individual\ncases are usually pretty straightforward.\n\n@param t The node traversal object that supplies context, such as the\nscope chain to use in name lookups as well as error reporting.\n@param n The node being visited.\n@param parent The parent of the node n.\n",
      "diff": "@@ -1,273 +1,272 @@\n public void visit(NodeTraversal t, Node n, Node parent) {\n     JSType childType;\n     JSType leftType, rightType;\n     Node left, right;\n     boolean typeable \u003d true;\n     switch(n.getType()) {\n         case Token.NAME:\n             typeable \u003d visitName(t, n, parent);\n             break;\n         case Token.LP:\n             if (parent.getType() !\u003d Token.FUNCTION) {\n                 ensureTyped(t, n, getJSType(n.getFirstChild()));\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.COMMA:\n             ensureTyped(t, n, getJSType(n.getLastChild()));\n             break;\n         case Token.TRUE:\n         case Token.FALSE:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.THIS:\n             ensureTyped(t, n, t.getScope().getTypeOfThis());\n             break;\n         case Token.REF_SPECIAL:\n             ensureTyped(t, n);\n             break;\n         case Token.GET_REF:\n             ensureTyped(t, n, getJSType(n.getFirstChild()));\n             break;\n         case Token.NULL:\n             ensureTyped(t, n, NULL_TYPE);\n             break;\n         case Token.NUMBER:\n             if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n                 ensureTyped(t, n, NUMBER_TYPE);\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.ARRAYLIT:\n             ensureTyped(t, n, ARRAY_TYPE);\n             break;\n         case Token.STRING:\n             if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n                 ensureTyped(t, n, STRING_TYPE);\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.REGEXP:\n             ensureTyped(t, n, REGEXP_TYPE);\n             break;\n         case Token.GETPROP:\n             visitGetProp(t, n, parent);\n             typeable \u003d !(parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n             break;\n         case Token.GETELEM:\n             visitGetElem(t, n);\n             typeable \u003d false;\n             break;\n         case Token.VAR:\n             visitVar(t, n);\n             typeable \u003d false;\n             break;\n         case Token.NEW:\n             visitNew(t, n);\n             typeable \u003d true;\n             break;\n         case Token.CALL:\n             visitCall(t, n);\n             typeable \u003d !NodeUtil.isExpressionNode(parent);\n             break;\n         case Token.RETURN:\n             visitReturn(t, n);\n             typeable \u003d false;\n             break;\n         case Token.DEC:\n         case Token.INC:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.NOT:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.VOID:\n             ensureTyped(t, n, VOID_TYPE);\n             break;\n         case Token.TYPEOF:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.BITNOT:\n             childType \u003d getJSType(n.getFirstChild());\n             if (!childType.matchesInt32Context()) {\n                 t.report(n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n             }\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.POS:\n         case Token.NEG:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.EQ:\n         case Token.NE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                 if (result !\u003d TernaryValue.UNKNOWN) {\n                     if (n.getType() \u003d\u003d Token.NE) {\n                         result \u003d result.not();\n                     }\n                     t.report(n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.SHEQ:\n         case Token.SHNE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                     t.report(n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.LT:\n         case Token.LE:\n         case Token.GT:\n         case Token.GE:\n             leftType \u003d getJSType(n.getFirstChild());\n             rightType \u003d getJSType(n.getLastChild());\n             if (rightType.isNumber()) {\n                 validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n             } else if (leftType.isNumber()) {\n                 validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n             } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n             } else {\n                 String message \u003d \"left side of comparison\";\n                 validator.expectString(t, n, leftType, message);\n                 validator.expectNotVoid(t, n, leftType, message, getNativeType(STRING_TYPE));\n                 message \u003d \"right side of comparison\";\n                 validator.expectString(t, n, rightType, message);\n                 validator.expectNotVoid(t, n, rightType, message, getNativeType(STRING_TYPE));\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.IN:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right);\n             validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n             validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.INSTANCEOF:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n             validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n             validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.ASSIGN:\n             visitAssign(t, n);\n             typeable \u003d false;\n             break;\n         case Token.ASSIGN_LSH:\n         case Token.ASSIGN_RSH:\n         case Token.ASSIGN_URSH:\n         case Token.ASSIGN_DIV:\n         case Token.ASSIGN_MOD:\n         case Token.ASSIGN_BITOR:\n         case Token.ASSIGN_BITXOR:\n         case Token.ASSIGN_BITAND:\n         case Token.ASSIGN_SUB:\n         case Token.ASSIGN_ADD:\n         case Token.ASSIGN_MUL:\n         case Token.LSH:\n         case Token.RSH:\n         case Token.URSH:\n         case Token.DIV:\n         case Token.MOD:\n         case Token.BITOR:\n         case Token.BITXOR:\n         case Token.BITAND:\n         case Token.SUB:\n         case Token.ADD:\n         case Token.MUL:\n             visitBinaryOperator(n.getType(), t, n);\n             break;\n         case Token.DELPROP:\n             if (!isReference(n.getFirstChild())) {\n                 t.report(n, BAD_DELETE);\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.CASE:\n             JSType switchType \u003d getJSType(parent.getFirstChild());\n             JSType caseType \u003d getJSType(n.getFirstChild());\n             validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n             typeable \u003d false;\n             break;\n         case Token.WITH:\n             {\n                 Node child \u003d n.getFirstChild();\n                 childType \u003d getJSType(child);\n                 validator.expectObject(t, child, childType, \"with requires an object\");\n                 typeable \u003d false;\n                 break;\n             }\n         case Token.FUNCTION:\n             visitFunction(t, n);\n             break;\n         case Token.LABEL:\n-        case Token.LABEL_NAME:\n         case Token.SWITCH:\n         case Token.BREAK:\n         case Token.CATCH:\n         case Token.TRY:\n         case Token.SCRIPT:\n         case Token.EXPR_RESULT:\n         case Token.BLOCK:\n         case Token.EMPTY:\n         case Token.DEFAULT:\n         case Token.CONTINUE:\n         case Token.DEBUGGER:\n         case Token.THROW:\n             typeable \u003d false;\n             break;\n         case Token.DO:\n         case Token.FOR:\n         case Token.IF:\n         case Token.WHILE:\n             typeable \u003d false;\n             break;\n         case Token.AND:\n         case Token.HOOK:\n         case Token.OBJECTLIT:\n         case Token.OR:\n             if (n.getJSType() !\u003d null) {\n                 ensureTyped(t, n);\n             } else {\n                 if ((n.getType() \u003d\u003d Token.OBJECTLIT) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                     ensureTyped(t, n, parent.getJSType());\n                 } else {\n                     ensureTyped(t, n);\n                 }\n             }\n             break;\n         default:\n             t.report(n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n             ensureTyped(t, n);\n             break;\n     }\n     typeable \u003d typeable \u0026\u0026 !inExterns;\n     if (typeable) {\n         doPercentTypedAccounting(t, n);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8c5eb247cb5361a6ffa2d86aa4c2de17c234bda7": {
      "type": "Ybodychange",
      "commitMessage": "Refactor how coding conventions are set (Nick)\nR\u003dalan\n\nDon\u0027t use NAME for label names, introduce LABEL_NAME. This improves\nthe correctness of the compiler as many passes don\u0027t distinguish\nbetween label names and variable names appropriately. (John)\nR\u003drobert\nDELTA\u003d57  (29 added, 12 deleted, 16 changed)\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@163 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "3/30/10, 9:01 PM",
      "commitName": "8c5eb247cb5361a6ffa2d86aa4c2de17c234bda7",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "3/29/10, 7:04 AM",
      "commitNameOld": "3cc8b3a5889f8b88ef7a2bd0b8ccea8cb0d916c4",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 1.58,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "public void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    boolean typeable \u003d true;\n    switch(n.getType()) {\n        case Token.NAME:\n            typeable \u003d visitName(t, n, parent);\n            break;\n        case Token.LP:\n            if (parent.getType() !\u003d Token.FUNCTION) {\n                ensureTyped(t, n, getJSType(n.getFirstChild()));\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.COMMA:\n            ensureTyped(t, n, getJSType(n.getLastChild()));\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.THIS:\n            ensureTyped(t, n, t.getScope().getTypeOfThis());\n            break;\n        case Token.REF_SPECIAL:\n            ensureTyped(t, n);\n            break;\n        case Token.GET_REF:\n            ensureTyped(t, n, getJSType(n.getFirstChild()));\n            break;\n        case Token.NULL:\n            ensureTyped(t, n, NULL_TYPE);\n            break;\n        case Token.NUMBER:\n            if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n                ensureTyped(t, n, NUMBER_TYPE);\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.ARRAYLIT:\n            ensureTyped(t, n, ARRAY_TYPE);\n            break;\n        case Token.STRING:\n            if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n                ensureTyped(t, n, STRING_TYPE);\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.REGEXP:\n            ensureTyped(t, n, REGEXP_TYPE);\n            break;\n        case Token.GETPROP:\n            visitGetProp(t, n, parent);\n            typeable \u003d !(parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n            break;\n        case Token.GETELEM:\n            visitGetElem(t, n);\n            typeable \u003d false;\n            break;\n        case Token.VAR:\n            visitVar(t, n);\n            typeable \u003d false;\n            break;\n        case Token.NEW:\n            visitNew(t, n);\n            typeable \u003d true;\n            break;\n        case Token.CALL:\n            visitCall(t, n);\n            typeable \u003d !NodeUtil.isExpressionNode(parent);\n            break;\n        case Token.RETURN:\n            visitReturn(t, n);\n            typeable \u003d false;\n            break;\n        case Token.DEC:\n        case Token.INC:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.NOT:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.VOID:\n            ensureTyped(t, n, VOID_TYPE);\n            break;\n        case Token.TYPEOF:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.BITNOT:\n            childType \u003d getJSType(n.getFirstChild());\n            if (!childType.matchesInt32Context()) {\n                t.report(n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n            }\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.EQ:\n        case Token.NE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                if (result !\u003d TernaryValue.UNKNOWN) {\n                    if (n.getType() \u003d\u003d Token.NE) {\n                        result \u003d result.not();\n                    }\n                    t.report(n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.SHEQ:\n        case Token.SHNE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                    t.report(n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n            leftType \u003d getJSType(n.getFirstChild());\n            rightType \u003d getJSType(n.getLastChild());\n            if (rightType.isNumber()) {\n                validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n            } else if (leftType.isNumber()) {\n                validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n            } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n            } else {\n                String message \u003d \"left side of comparison\";\n                validator.expectString(t, n, leftType, message);\n                validator.expectNotVoid(t, n, leftType, message, getNativeType(STRING_TYPE));\n                message \u003d \"right side of comparison\";\n                validator.expectString(t, n, rightType, message);\n                validator.expectNotVoid(t, n, rightType, message, getNativeType(STRING_TYPE));\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.IN:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right);\n            validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n            validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.INSTANCEOF:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n            validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n            validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.ASSIGN:\n            visitAssign(t, n);\n            typeable \u003d false;\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.ASSIGN_URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_SUB:\n        case Token.ASSIGN_ADD:\n        case Token.ASSIGN_MUL:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.URSH:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITOR:\n        case Token.BITXOR:\n        case Token.BITAND:\n        case Token.SUB:\n        case Token.ADD:\n        case Token.MUL:\n            visitBinaryOperator(n.getType(), t, n);\n            break;\n        case Token.DELPROP:\n            if (!isReference(n.getFirstChild())) {\n                t.report(n, BAD_DELETE);\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.CASE:\n            JSType switchType \u003d getJSType(parent.getFirstChild());\n            JSType caseType \u003d getJSType(n.getFirstChild());\n            validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n            typeable \u003d false;\n            break;\n        case Token.WITH:\n            {\n                Node child \u003d n.getFirstChild();\n                childType \u003d getJSType(child);\n                validator.expectObject(t, child, childType, \"with requires an object\");\n                typeable \u003d false;\n                break;\n            }\n        case Token.FUNCTION:\n            visitFunction(t, n);\n            break;\n        case Token.LABEL:\n        case Token.LABEL_NAME:\n        case Token.SWITCH:\n        case Token.BREAK:\n        case Token.CATCH:\n        case Token.TRY:\n        case Token.SCRIPT:\n        case Token.EXPR_RESULT:\n        case Token.BLOCK:\n        case Token.EMPTY:\n        case Token.DEFAULT:\n        case Token.CONTINUE:\n        case Token.DEBUGGER:\n        case Token.THROW:\n            typeable \u003d false;\n            break;\n        case Token.DO:\n        case Token.FOR:\n        case Token.IF:\n        case Token.WHILE:\n            typeable \u003d false;\n            break;\n        case Token.AND:\n        case Token.HOOK:\n        case Token.OBJECTLIT:\n        case Token.OR:\n            if (n.getJSType() !\u003d null) {\n                ensureTyped(t, n);\n            } else {\n                if ((n.getType() \u003d\u003d Token.OBJECTLIT) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                    ensureTyped(t, n, parent.getJSType());\n                } else {\n                    ensureTyped(t, n);\n                }\n            }\n            break;\n        default:\n            t.report(n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n            ensureTyped(t, n);\n            break;\n    }\n    typeable \u003d typeable \u0026\u0026 !inExterns;\n    if (typeable) {\n        doPercentTypedAccounting(t, n);\n    }\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 436,
      "functionName": "visit",
      "functionAnnotation": "",
      "functionDoc": "This is the meat of the type checking.  It is basically one big switch,\nwith each case representing one type of parse tree node.  The individual\ncases are usually pretty straightforward.\n\n@param t The node traversal object that supplies context, such as the\nscope chain to use in name lookups as well as error reporting.\n@param n The node being visited.\n@param parent The parent of the node n.\n",
      "diff": "@@ -1,272 +1,273 @@\n public void visit(NodeTraversal t, Node n, Node parent) {\n     JSType childType;\n     JSType leftType, rightType;\n     Node left, right;\n     boolean typeable \u003d true;\n     switch(n.getType()) {\n         case Token.NAME:\n             typeable \u003d visitName(t, n, parent);\n             break;\n         case Token.LP:\n             if (parent.getType() !\u003d Token.FUNCTION) {\n                 ensureTyped(t, n, getJSType(n.getFirstChild()));\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.COMMA:\n             ensureTyped(t, n, getJSType(n.getLastChild()));\n             break;\n         case Token.TRUE:\n         case Token.FALSE:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.THIS:\n             ensureTyped(t, n, t.getScope().getTypeOfThis());\n             break;\n         case Token.REF_SPECIAL:\n             ensureTyped(t, n);\n             break;\n         case Token.GET_REF:\n             ensureTyped(t, n, getJSType(n.getFirstChild()));\n             break;\n         case Token.NULL:\n             ensureTyped(t, n, NULL_TYPE);\n             break;\n         case Token.NUMBER:\n             if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n                 ensureTyped(t, n, NUMBER_TYPE);\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.ARRAYLIT:\n             ensureTyped(t, n, ARRAY_TYPE);\n             break;\n         case Token.STRING:\n             if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n                 ensureTyped(t, n, STRING_TYPE);\n             } else {\n                 typeable \u003d false;\n             }\n             break;\n         case Token.REGEXP:\n             ensureTyped(t, n, REGEXP_TYPE);\n             break;\n         case Token.GETPROP:\n             visitGetProp(t, n, parent);\n             typeable \u003d !(parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n             break;\n         case Token.GETELEM:\n             visitGetElem(t, n);\n             typeable \u003d false;\n             break;\n         case Token.VAR:\n             visitVar(t, n);\n             typeable \u003d false;\n             break;\n         case Token.NEW:\n             visitNew(t, n);\n             typeable \u003d true;\n             break;\n         case Token.CALL:\n             visitCall(t, n);\n             typeable \u003d !NodeUtil.isExpressionNode(parent);\n             break;\n         case Token.RETURN:\n             visitReturn(t, n);\n             typeable \u003d false;\n             break;\n         case Token.DEC:\n         case Token.INC:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.NOT:\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.VOID:\n             ensureTyped(t, n, VOID_TYPE);\n             break;\n         case Token.TYPEOF:\n             ensureTyped(t, n, STRING_TYPE);\n             break;\n         case Token.BITNOT:\n             childType \u003d getJSType(n.getFirstChild());\n             if (!childType.matchesInt32Context()) {\n                 t.report(n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n             }\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.POS:\n         case Token.NEG:\n             left \u003d n.getFirstChild();\n             validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n             ensureTyped(t, n, NUMBER_TYPE);\n             break;\n         case Token.EQ:\n         case Token.NE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                 if (result !\u003d TernaryValue.UNKNOWN) {\n                     if (n.getType() \u003d\u003d Token.NE) {\n                         result \u003d result.not();\n                     }\n                     t.report(n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.SHEQ:\n         case Token.SHNE:\n             {\n                 leftType \u003d getJSType(n.getFirstChild());\n                 rightType \u003d getJSType(n.getLastChild());\n                 JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                 JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                 if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                     t.report(n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                 }\n                 ensureTyped(t, n, BOOLEAN_TYPE);\n                 break;\n             }\n         case Token.LT:\n         case Token.LE:\n         case Token.GT:\n         case Token.GE:\n             leftType \u003d getJSType(n.getFirstChild());\n             rightType \u003d getJSType(n.getLastChild());\n             if (rightType.isNumber()) {\n                 validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n             } else if (leftType.isNumber()) {\n                 validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n             } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n             } else {\n                 String message \u003d \"left side of comparison\";\n                 validator.expectString(t, n, leftType, message);\n                 validator.expectNotVoid(t, n, leftType, message, getNativeType(STRING_TYPE));\n                 message \u003d \"right side of comparison\";\n                 validator.expectString(t, n, rightType, message);\n                 validator.expectNotVoid(t, n, rightType, message, getNativeType(STRING_TYPE));\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.IN:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right);\n             validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n             validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.INSTANCEOF:\n             left \u003d n.getFirstChild();\n             right \u003d n.getLastChild();\n             leftType \u003d getJSType(left);\n             rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n             validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n             validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.ASSIGN:\n             visitAssign(t, n);\n             typeable \u003d false;\n             break;\n         case Token.ASSIGN_LSH:\n         case Token.ASSIGN_RSH:\n         case Token.ASSIGN_URSH:\n         case Token.ASSIGN_DIV:\n         case Token.ASSIGN_MOD:\n         case Token.ASSIGN_BITOR:\n         case Token.ASSIGN_BITXOR:\n         case Token.ASSIGN_BITAND:\n         case Token.ASSIGN_SUB:\n         case Token.ASSIGN_ADD:\n         case Token.ASSIGN_MUL:\n         case Token.LSH:\n         case Token.RSH:\n         case Token.URSH:\n         case Token.DIV:\n         case Token.MOD:\n         case Token.BITOR:\n         case Token.BITXOR:\n         case Token.BITAND:\n         case Token.SUB:\n         case Token.ADD:\n         case Token.MUL:\n             visitBinaryOperator(n.getType(), t, n);\n             break;\n         case Token.DELPROP:\n             if (!isReference(n.getFirstChild())) {\n                 t.report(n, BAD_DELETE);\n             }\n             ensureTyped(t, n, BOOLEAN_TYPE);\n             break;\n         case Token.CASE:\n             JSType switchType \u003d getJSType(parent.getFirstChild());\n             JSType caseType \u003d getJSType(n.getFirstChild());\n             validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n             typeable \u003d false;\n             break;\n         case Token.WITH:\n             {\n                 Node child \u003d n.getFirstChild();\n                 childType \u003d getJSType(child);\n                 validator.expectObject(t, child, childType, \"with requires an object\");\n                 typeable \u003d false;\n                 break;\n             }\n         case Token.FUNCTION:\n             visitFunction(t, n);\n             break;\n         case Token.LABEL:\n+        case Token.LABEL_NAME:\n         case Token.SWITCH:\n         case Token.BREAK:\n         case Token.CATCH:\n         case Token.TRY:\n         case Token.SCRIPT:\n         case Token.EXPR_RESULT:\n         case Token.BLOCK:\n         case Token.EMPTY:\n         case Token.DEFAULT:\n         case Token.CONTINUE:\n         case Token.DEBUGGER:\n         case Token.THROW:\n             typeable \u003d false;\n             break;\n         case Token.DO:\n         case Token.FOR:\n         case Token.IF:\n         case Token.WHILE:\n             typeable \u003d false;\n             break;\n         case Token.AND:\n         case Token.HOOK:\n         case Token.OBJECTLIT:\n         case Token.OR:\n             if (n.getJSType() !\u003d null) {\n                 ensureTyped(t, n);\n             } else {\n                 if ((n.getType() \u003d\u003d Token.OBJECTLIT) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                     ensureTyped(t, n, parent.getJSType());\n                 } else {\n                     ensureTyped(t, n);\n                 }\n             }\n             break;\n         default:\n             t.report(n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n             ensureTyped(t, n);\n             break;\n     }\n     typeable \u003d typeable \u0026\u0026 !inExterns;\n     if (typeable) {\n         doPercentTypedAccounting(t, n);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": {
      "type": "Yintroduced",
      "commitMessage": "Initial commit.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/3/09, 3:51 PM",
      "commitName": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "diff": "@@ -0,0 +1,272 @@\n+public void visit(NodeTraversal t, Node n, Node parent) {\n+    JSType childType;\n+    JSType leftType, rightType;\n+    Node left, right;\n+    boolean typeable \u003d true;\n+    switch(n.getType()) {\n+        case Token.NAME:\n+            typeable \u003d visitName(t, n, parent);\n+            break;\n+        case Token.LP:\n+            if (parent.getType() !\u003d Token.FUNCTION) {\n+                ensureTyped(t, n, getJSType(n.getFirstChild()));\n+            } else {\n+                typeable \u003d false;\n+            }\n+            break;\n+        case Token.COMMA:\n+            ensureTyped(t, n, getJSType(n.getLastChild()));\n+            break;\n+        case Token.TRUE:\n+        case Token.FALSE:\n+            ensureTyped(t, n, BOOLEAN_TYPE);\n+            break;\n+        case Token.THIS:\n+            ensureTyped(t, n, t.getScope().getTypeOfThis());\n+            break;\n+        case Token.REF_SPECIAL:\n+            ensureTyped(t, n);\n+            break;\n+        case Token.GET_REF:\n+            ensureTyped(t, n, getJSType(n.getFirstChild()));\n+            break;\n+        case Token.NULL:\n+            ensureTyped(t, n, NULL_TYPE);\n+            break;\n+        case Token.NUMBER:\n+            if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n+                ensureTyped(t, n, NUMBER_TYPE);\n+            } else {\n+                typeable \u003d false;\n+            }\n+            break;\n+        case Token.ARRAYLIT:\n+            ensureTyped(t, n, ARRAY_TYPE);\n+            break;\n+        case Token.STRING:\n+            if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n+                ensureTyped(t, n, STRING_TYPE);\n+            } else {\n+                typeable \u003d false;\n+            }\n+            break;\n+        case Token.REGEXP:\n+            ensureTyped(t, n, REGEXP_TYPE);\n+            break;\n+        case Token.GETPROP:\n+            visitGetProp(t, n, parent);\n+            typeable \u003d !(parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n+            break;\n+        case Token.GETELEM:\n+            visitGetElem(t, n);\n+            typeable \u003d false;\n+            break;\n+        case Token.VAR:\n+            visitVar(t, n);\n+            typeable \u003d false;\n+            break;\n+        case Token.NEW:\n+            visitNew(t, n);\n+            typeable \u003d true;\n+            break;\n+        case Token.CALL:\n+            visitCall(t, n);\n+            typeable \u003d !NodeUtil.isExpressionNode(parent);\n+            break;\n+        case Token.RETURN:\n+            visitReturn(t, n);\n+            typeable \u003d false;\n+            break;\n+        case Token.DEC:\n+        case Token.INC:\n+            left \u003d n.getFirstChild();\n+            validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n+            ensureTyped(t, n, NUMBER_TYPE);\n+            break;\n+        case Token.NOT:\n+            ensureTyped(t, n, BOOLEAN_TYPE);\n+            break;\n+        case Token.VOID:\n+            ensureTyped(t, n, VOID_TYPE);\n+            break;\n+        case Token.TYPEOF:\n+            ensureTyped(t, n, STRING_TYPE);\n+            break;\n+        case Token.BITNOT:\n+            childType \u003d getJSType(n.getFirstChild());\n+            if (!childType.matchesInt32Context()) {\n+                t.report(n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n+            }\n+            ensureTyped(t, n, NUMBER_TYPE);\n+            break;\n+        case Token.POS:\n+        case Token.NEG:\n+            left \u003d n.getFirstChild();\n+            validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n+            ensureTyped(t, n, NUMBER_TYPE);\n+            break;\n+        case Token.EQ:\n+        case Token.NE:\n+            {\n+                leftType \u003d getJSType(n.getFirstChild());\n+                rightType \u003d getJSType(n.getLastChild());\n+                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n+                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n+                TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n+                if (result !\u003d TernaryValue.UNKNOWN) {\n+                    if (n.getType() \u003d\u003d Token.NE) {\n+                        result \u003d result.not();\n+                    }\n+                    t.report(n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n+                }\n+                ensureTyped(t, n, BOOLEAN_TYPE);\n+                break;\n+            }\n+        case Token.SHEQ:\n+        case Token.SHNE:\n+            {\n+                leftType \u003d getJSType(n.getFirstChild());\n+                rightType \u003d getJSType(n.getLastChild());\n+                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n+                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n+                if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n+                    t.report(n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n+                }\n+                ensureTyped(t, n, BOOLEAN_TYPE);\n+                break;\n+            }\n+        case Token.LT:\n+        case Token.LE:\n+        case Token.GT:\n+        case Token.GE:\n+            leftType \u003d getJSType(n.getFirstChild());\n+            rightType \u003d getJSType(n.getLastChild());\n+            if (rightType.isNumber()) {\n+                validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n+            } else if (leftType.isNumber()) {\n+                validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n+            } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n+            } else {\n+                String message \u003d \"left side of comparison\";\n+                validator.expectString(t, n, leftType, message);\n+                validator.expectNotVoid(t, n, leftType, message, getNativeType(STRING_TYPE));\n+                message \u003d \"right side of comparison\";\n+                validator.expectString(t, n, rightType, message);\n+                validator.expectNotVoid(t, n, rightType, message, getNativeType(STRING_TYPE));\n+            }\n+            ensureTyped(t, n, BOOLEAN_TYPE);\n+            break;\n+        case Token.IN:\n+            left \u003d n.getFirstChild();\n+            right \u003d n.getLastChild();\n+            leftType \u003d getJSType(left);\n+            rightType \u003d getJSType(right);\n+            validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n+            validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n+            ensureTyped(t, n, BOOLEAN_TYPE);\n+            break;\n+        case Token.INSTANCEOF:\n+            left \u003d n.getFirstChild();\n+            right \u003d n.getLastChild();\n+            leftType \u003d getJSType(left);\n+            rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n+            validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n+            validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n+            ensureTyped(t, n, BOOLEAN_TYPE);\n+            break;\n+        case Token.ASSIGN:\n+            visitAssign(t, n);\n+            typeable \u003d false;\n+            break;\n+        case Token.ASSIGN_LSH:\n+        case Token.ASSIGN_RSH:\n+        case Token.ASSIGN_URSH:\n+        case Token.ASSIGN_DIV:\n+        case Token.ASSIGN_MOD:\n+        case Token.ASSIGN_BITOR:\n+        case Token.ASSIGN_BITXOR:\n+        case Token.ASSIGN_BITAND:\n+        case Token.ASSIGN_SUB:\n+        case Token.ASSIGN_ADD:\n+        case Token.ASSIGN_MUL:\n+        case Token.LSH:\n+        case Token.RSH:\n+        case Token.URSH:\n+        case Token.DIV:\n+        case Token.MOD:\n+        case Token.BITOR:\n+        case Token.BITXOR:\n+        case Token.BITAND:\n+        case Token.SUB:\n+        case Token.ADD:\n+        case Token.MUL:\n+            visitBinaryOperator(n.getType(), t, n);\n+            break;\n+        case Token.DELPROP:\n+            if (!isReference(n.getFirstChild())) {\n+                t.report(n, BAD_DELETE);\n+            }\n+            ensureTyped(t, n, BOOLEAN_TYPE);\n+            break;\n+        case Token.CASE:\n+            JSType switchType \u003d getJSType(parent.getFirstChild());\n+            JSType caseType \u003d getJSType(n.getFirstChild());\n+            validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n+            typeable \u003d false;\n+            break;\n+        case Token.WITH:\n+            {\n+                Node child \u003d n.getFirstChild();\n+                childType \u003d getJSType(child);\n+                validator.expectObject(t, child, childType, \"with requires an object\");\n+                typeable \u003d false;\n+                break;\n+            }\n+        case Token.FUNCTION:\n+            visitFunction(t, n);\n+            break;\n+        case Token.LABEL:\n+        case Token.SWITCH:\n+        case Token.BREAK:\n+        case Token.CATCH:\n+        case Token.TRY:\n+        case Token.SCRIPT:\n+        case Token.EXPR_RESULT:\n+        case Token.BLOCK:\n+        case Token.EMPTY:\n+        case Token.DEFAULT:\n+        case Token.CONTINUE:\n+        case Token.DEBUGGER:\n+        case Token.THROW:\n+            typeable \u003d false;\n+            break;\n+        case Token.DO:\n+        case Token.FOR:\n+        case Token.IF:\n+        case Token.WHILE:\n+            typeable \u003d false;\n+            break;\n+        case Token.AND:\n+        case Token.HOOK:\n+        case Token.OBJECTLIT:\n+        case Token.OR:\n+            if (n.getJSType() !\u003d null) {\n+                ensureTyped(t, n);\n+            } else {\n+                if ((n.getType() \u003d\u003d Token.OBJECTLIT) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n+                    ensureTyped(t, n, parent.getJSType());\n+                } else {\n+                    ensureTyped(t, n);\n+                }\n+            }\n+            break;\n+        default:\n+            t.report(n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n+            ensureTyped(t, n);\n+            break;\n+    }\n+    typeable \u003d typeable \u0026\u0026 !inExterns;\n+    if (typeable) {\n+        doPercentTypedAccounting(t, n);\n+    }\n+}\n\\ No newline at end of file\n",
      "actualSource": "public void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    boolean typeable \u003d true;\n    switch(n.getType()) {\n        case Token.NAME:\n            typeable \u003d visitName(t, n, parent);\n            break;\n        case Token.LP:\n            if (parent.getType() !\u003d Token.FUNCTION) {\n                ensureTyped(t, n, getJSType(n.getFirstChild()));\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.COMMA:\n            ensureTyped(t, n, getJSType(n.getLastChild()));\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.THIS:\n            ensureTyped(t, n, t.getScope().getTypeOfThis());\n            break;\n        case Token.REF_SPECIAL:\n            ensureTyped(t, n);\n            break;\n        case Token.GET_REF:\n            ensureTyped(t, n, getJSType(n.getFirstChild()));\n            break;\n        case Token.NULL:\n            ensureTyped(t, n, NULL_TYPE);\n            break;\n        case Token.NUMBER:\n            if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n                ensureTyped(t, n, NUMBER_TYPE);\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.ARRAYLIT:\n            ensureTyped(t, n, ARRAY_TYPE);\n            break;\n        case Token.STRING:\n            if (n.getParent().getType() !\u003d Token.OBJECTLIT) {\n                ensureTyped(t, n, STRING_TYPE);\n            } else {\n                typeable \u003d false;\n            }\n            break;\n        case Token.REGEXP:\n            ensureTyped(t, n, REGEXP_TYPE);\n            break;\n        case Token.GETPROP:\n            visitGetProp(t, n, parent);\n            typeable \u003d !(parent.getType() \u003d\u003d Token.ASSIGN \u0026\u0026 parent.getFirstChild() \u003d\u003d n);\n            break;\n        case Token.GETELEM:\n            visitGetElem(t, n);\n            typeable \u003d false;\n            break;\n        case Token.VAR:\n            visitVar(t, n);\n            typeable \u003d false;\n            break;\n        case Token.NEW:\n            visitNew(t, n);\n            typeable \u003d true;\n            break;\n        case Token.CALL:\n            visitCall(t, n);\n            typeable \u003d !NodeUtil.isExpressionNode(parent);\n            break;\n        case Token.RETURN:\n            visitReturn(t, n);\n            typeable \u003d false;\n            break;\n        case Token.DEC:\n        case Token.INC:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.NOT:\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.VOID:\n            ensureTyped(t, n, VOID_TYPE);\n            break;\n        case Token.TYPEOF:\n            ensureTyped(t, n, STRING_TYPE);\n            break;\n        case Token.BITNOT:\n            childType \u003d getJSType(n.getFirstChild());\n            if (!childType.matchesInt32Context()) {\n                t.report(n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\n            }\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.POS:\n        case Token.NEG:\n            left \u003d n.getFirstChild();\n            validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n            ensureTyped(t, n, NUMBER_TYPE);\n            break;\n        case Token.EQ:\n        case Token.NE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                TernaryValue result \u003d leftTypeRestricted.testForEquality(rightTypeRestricted);\n                if (result !\u003d TernaryValue.UNKNOWN) {\n                    if (n.getType() \u003d\u003d Token.NE) {\n                        result \u003d result.not();\n                    }\n                    t.report(n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.SHEQ:\n        case Token.SHNE:\n            {\n                leftType \u003d getJSType(n.getFirstChild());\n                rightType \u003d getJSType(n.getLastChild());\n                JSType leftTypeRestricted \u003d leftType.restrictByNotNullOrUndefined();\n                JSType rightTypeRestricted \u003d rightType.restrictByNotNullOrUndefined();\n                if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                    t.report(n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                }\n                ensureTyped(t, n, BOOLEAN_TYPE);\n                break;\n            }\n        case Token.LT:\n        case Token.LE:\n        case Token.GT:\n        case Token.GE:\n            leftType \u003d getJSType(n.getFirstChild());\n            rightType \u003d getJSType(n.getLastChild());\n            if (rightType.isNumber()) {\n                validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n            } else if (leftType.isNumber()) {\n                validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n            } else if (leftType.matchesNumberContext() \u0026\u0026 rightType.matchesNumberContext()) {\n            } else {\n                String message \u003d \"left side of comparison\";\n                validator.expectString(t, n, leftType, message);\n                validator.expectNotVoid(t, n, leftType, message, getNativeType(STRING_TYPE));\n                message \u003d \"right side of comparison\";\n                validator.expectString(t, n, rightType, message);\n                validator.expectNotVoid(t, n, rightType, message, getNativeType(STRING_TYPE));\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.IN:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right);\n            validator.expectObject(t, n, rightType, \"\u0027in\u0027 requires an object\");\n            validator.expectString(t, left, leftType, \"left side of \u0027in\u0027\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.INSTANCEOF:\n            left \u003d n.getFirstChild();\n            right \u003d n.getLastChild();\n            leftType \u003d getJSType(left);\n            rightType \u003d getJSType(right).restrictByNotNullOrUndefined();\n            validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n            validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.ASSIGN:\n            visitAssign(t, n);\n            typeable \u003d false;\n            break;\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.ASSIGN_URSH:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_SUB:\n        case Token.ASSIGN_ADD:\n        case Token.ASSIGN_MUL:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.URSH:\n        case Token.DIV:\n        case Token.MOD:\n        case Token.BITOR:\n        case Token.BITXOR:\n        case Token.BITAND:\n        case Token.SUB:\n        case Token.ADD:\n        case Token.MUL:\n            visitBinaryOperator(n.getType(), t, n);\n            break;\n        case Token.DELPROP:\n            if (!isReference(n.getFirstChild())) {\n                t.report(n, BAD_DELETE);\n            }\n            ensureTyped(t, n, BOOLEAN_TYPE);\n            break;\n        case Token.CASE:\n            JSType switchType \u003d getJSType(parent.getFirstChild());\n            JSType caseType \u003d getJSType(n.getFirstChild());\n            validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n            typeable \u003d false;\n            break;\n        case Token.WITH:\n            {\n                Node child \u003d n.getFirstChild();\n                childType \u003d getJSType(child);\n                validator.expectObject(t, child, childType, \"with requires an object\");\n                typeable \u003d false;\n                break;\n            }\n        case Token.FUNCTION:\n            visitFunction(t, n);\n            break;\n        case Token.LABEL:\n        case Token.SWITCH:\n        case Token.BREAK:\n        case Token.CATCH:\n        case Token.TRY:\n        case Token.SCRIPT:\n        case Token.EXPR_RESULT:\n        case Token.BLOCK:\n        case Token.EMPTY:\n        case Token.DEFAULT:\n        case Token.CONTINUE:\n        case Token.DEBUGGER:\n        case Token.THROW:\n            typeable \u003d false;\n            break;\n        case Token.DO:\n        case Token.FOR:\n        case Token.IF:\n        case Token.WHILE:\n            typeable \u003d false;\n            break;\n        case Token.AND:\n        case Token.HOOK:\n        case Token.OBJECTLIT:\n        case Token.OR:\n            if (n.getJSType() !\u003d null) {\n                ensureTyped(t, n);\n            } else {\n                if ((n.getType() \u003d\u003d Token.OBJECTLIT) \u0026\u0026 (parent.getJSType() instanceof EnumType)) {\n                    ensureTyped(t, n, parent.getJSType());\n                } else {\n                    ensureTyped(t, n);\n                }\n            }\n            break;\n        default:\n            t.report(n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n            ensureTyped(t, n);\n            break;\n    }\n    typeable \u003d typeable \u0026\u0026 !inExterns;\n    if (typeable) {\n        doPercentTypedAccounting(t, n);\n    }\n}",
      "path": "src/com/google/javascript/jscomp/TypeCheck.java",
      "functionStartLine": 408,
      "functionName": "visit",
      "functionAnnotation": "",
      "functionDoc": "This is the meat of the type checking.  It is basically one big switch,\nwith each case representing one type of parse tree node.  The individual\ncases are usually pretty straightforward.\n\n@param t The node traversal object that supplies context, such as the\nscope chain to use in name lookups as well as error reporting.\n@param n The node being visited.\n@param parent The parent of the node n.\n"
    }
  }
}