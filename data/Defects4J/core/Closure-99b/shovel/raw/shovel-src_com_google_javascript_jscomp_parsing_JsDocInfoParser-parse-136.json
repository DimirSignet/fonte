{
  "origin": "codeshovel",
  "repositoryName": "Closure-99b",
  "repositoryPath": "/tmp/Closure-99b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "JsDocInfoParser.java",
  "functionName": "parse",
  "functionId": "parse",
  "sourceFilePath": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
  "functionAnnotation": "",
  "functionDoc": "Parses a {@link JSDocInfo} object. This parsing method reads all tokens\nreturned by the {@link JsDocTokenStream#getJsDocToken()} method until the\n{@link JsDocToken#EOC} is returned.\n\n@return @code true} if JSDoc information was correctly parsed,\n    {@code false} otherwise\n",
  "functionStartLine": 136,
  "functionEndLine": 786,
  "numCommitsSeen": 15,
  "timeTaken": 1984,
  "changeHistory": [
    "c764a46abf211d4677fadc33f7d466e5b14fa088",
    "52ecbc65e981b9f169466f8898155bc5f8bfad7a",
    "a478193982ce1fb9271e3f7ebcc1369913c9a859",
    "5af11d33f8b3f5403c9987104601f544cddb96c1",
    "2acd6c1986e36bfdbae85c09eb83ac1940b86c73",
    "efd3c178e471df6a689c1a50fbd7c404e778bfaa",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3"
  ],
  "changeHistoryShort": {
    "c764a46abf211d4677fadc33f7d466e5b14fa088": "Ybodychange",
    "52ecbc65e981b9f169466f8898155bc5f8bfad7a": "Ybodychange",
    "a478193982ce1fb9271e3f7ebcc1369913c9a859": "Ybodychange",
    "5af11d33f8b3f5403c9987104601f544cddb96c1": "Ybodychange",
    "2acd6c1986e36bfdbae85c09eb83ac1940b86c73": "Ybodychange",
    "efd3c178e471df6a689c1a50fbd7c404e778bfaa": "Ybodychange",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "c764a46abf211d4677fadc33f7d466e5b14fa088": {
      "type": "Ybodychange",
      "commitMessage": "\nChange on 2010/04/13 by john\n\n        Here is a crazy thought, let\u0027s not require the JSTypeRegistry during\n        parsing.\n\n        There are basically two changes here:\n        1) The IRFactory was looking for enums to seed the JSTypeRegistry, so\n        we do that when we setup for type interence.\n        2) The JSDocParser was checking the types of @defines objects, now do\n        that during ProcessDefines.\n\n        R\u003drobert,mark\n        DELTA\u003d207  (82 added, 89 deleted, 36 changed)\n\nChange on 2010/04/14 by nick\n\n        Add a debugging function for JSType hashcodes.\n        i found this useful, and thought others might too.\n\n        R\u003djohn\n        DELTA\u003d69  (69 added, 0 deleted, 0 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003dfqsoxx\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@183 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/14/10, 9:15 AM",
      "commitName": "c764a46abf211d4677fadc33f7d466e5b14fa088",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "4/9/10, 11:07 AM",
      "commitNameOld": "2dbbe0784ee3e549eb0cc4d679aeddaac1243145",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 4.92,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "boolean parse() {\n    int lineno;\n    int charno;\n    JSTypeExpression type;\n    state \u003d State.SEARCHING_ANNOTATION;\n    JsDocToken token \u003d next();\n    ExtractionInfo blockInfo \u003d extractBlockComment(token);\n    token \u003d blockInfo.token;\n    if (blockInfo.string.length() \u003e 0) {\n        jsdocBuilder.recordBlockDescription(blockInfo.string);\n    }\n    retry: for (; ; ) {\n        switch(token) {\n            case ANNOTATION:\n                if (state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                    state \u003d State.SEARCHING_NEWLINE;\n                    lineno \u003d stream.getLineno();\n                    charno \u003d stream.getCharno();\n                    String annotationName \u003d stream.getString();\n                    Annotation annotation \u003d annotationNames.get(annotationName);\n                    if (annotation \u003d\u003d null) {\n                        parser.addWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno());\n                    } else {\n                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n                        switch(annotation) {\n                            case AUTHOR:\n                                ExtractionInfo authorInfo \u003d extractSingleLineBlock();\n                                String author \u003d authorInfo.string;\n                                if (author.length() \u003d\u003d 0) {\n                                    parser.addWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno());\n                                } else {\n                                    jsdocBuilder.addAuthor(author);\n                                }\n                                token \u003d authorInfo.token;\n                                continue retry;\n                            case CONSTANT:\n                                if (!jsdocBuilder.recordConstancy()) {\n                                    parser.addWarning(\"msg.jsdoc.const\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case CONSTRUCTOR:\n                                if (!jsdocBuilder.recordConstructor()) {\n                                    if (jsdocBuilder.isInterfaceRecorded()) {\n                                        parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case DEPRECATED:\n                                if (!jsdocBuilder.recordDeprecated()) {\n                                    parser.addWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno());\n                                }\n                                ExtractionInfo reasonInfo \u003d extractMultilineTextualBlock(token);\n                                String reason \u003d reasonInfo.string;\n                                if (reason.length() \u003e 0) {\n                                    jsdocBuilder.recordDeprecationReason(reason);\n                                }\n                                token \u003d reasonInfo.token;\n                                continue retry;\n                            case INTERFACE:\n                                if (!jsdocBuilder.recordInterface()) {\n                                    if (jsdocBuilder.isConstructorRecorded()) {\n                                        parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case DESC:\n                                if (jsdocBuilder.isDescriptionRecorded()) {\n                                    parser.addWarning(\"msg.jsdoc.desc.extra\", stream.getLineno(), stream.getCharno());\n                                    token \u003d eatTokensUntilEOL();\n                                    continue retry;\n                                } else {\n                                    ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                    String description \u003d descriptionInfo.string;\n                                    jsdocBuilder.recordDescription(description);\n                                    token \u003d descriptionInfo.token;\n                                    continue retry;\n                                }\n                            case FILE_OVERVIEW:\n                                ExtractionInfo fileOverviewInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.TRIM);\n                                String fileOverview \u003d fileOverviewInfo.string;\n                                if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo !\u003d null) {\n                                    parser.addWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d fileOverviewInfo.token;\n                                continue retry;\n                            case LICENSE:\n                            case PRESERVE:\n                                ExtractionInfo preserveInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);\n                                String preserve \u003d preserveInfo.string;\n                                if (preserve.length() \u003e 0) {\n                                    if (fileLevelJsDocBuilder !\u003d null) {\n                                        fileLevelJsDocBuilder.append(preserve);\n                                    }\n                                }\n                                token \u003d preserveInfo.token;\n                                continue retry;\n                            case ENUM:\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                }\n                                if (type \u003d\u003d null) {\n                                    type \u003d createJSTypeExpression(newStringNode(\"number\"));\n                                }\n                                if (!jsdocBuilder.recordEnumParameterType(type)) {\n                                    parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                }\n                                token \u003d eatTokensUntilEOL(token);\n                                continue retry;\n                            case EXPORT:\n                                if (!jsdocBuilder.recordExport()) {\n                                    parser.addWarning(\"msg.jsdoc.export\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case EXTERNS:\n                                if (!jsdocBuilder.recordExterns()) {\n                                    parser.addWarning(\"msg.jsdoc.externs\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case JAVA_DISPATCH:\n                                if (!jsdocBuilder.recordJavaDispatch()) {\n                                    parser.addWarning(\"msg.jsdoc.javadispatch\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case EXTENDS:\n                            case IMPLEMENTS:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                boolean matchingRc \u003d false;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    token \u003d next();\n                                    matchingRc \u003d true;\n                                }\n                                if (token \u003d\u003d JsDocToken.STRING) {\n                                    Node typeNode \u003d parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);\n                                    lineno \u003d stream.getLineno();\n                                    charno \u003d stream.getCharno();\n                                    typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                    if (typeNode !\u003d null \u0026\u0026 !matchingRc) {\n                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                    }\n                                    type \u003d createJSTypeExpression(typeNode);\n                                    if (annotation \u003d\u003d Annotation.EXTENDS) {\n                                        if (!jsdocBuilder.recordBaseType(type)) {\n                                            parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                        }\n                                    } else {\n                                        Preconditions.checkState(annotation \u003d\u003d Annotation.IMPLEMENTS);\n                                        if (!jsdocBuilder.recordImplementedInterface(type)) {\n                                            parser.addWarning(\"msg.jsdoc.implements.duplicate\", lineno, charno);\n                                        }\n                                    }\n                                    token \u003d next();\n                                    if (matchingRc) {\n                                        if (token !\u003d JsDocToken.RC) {\n                                            parser.addWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                        }\n                                    } else if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOF \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                        parser.addWarning(\"msg.end.annotation.expected\", stream.getLineno(), stream.getCharno());\n                                    }\n                                } else {\n                                    parser.addWarning(\"msg.no.type.name\", lineno, charno);\n                                }\n                                token \u003d eatTokensUntilEOL(token);\n                                continue retry;\n                            case HIDDEN:\n                                if (!jsdocBuilder.recordHiddenness()) {\n                                    parser.addWarning(\"msg.jsdoc.hidden\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_ALIAS:\n                                if (!jsdocBuilder.recordNoAlias()) {\n                                    parser.addWarning(\"msg.jsdoc.noalias\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_TYPE_CHECK:\n                                if (!jsdocBuilder.recordNoTypeCheck()) {\n                                    parser.addWarning(\"msg.jsdoc.nocheck\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NOT_IMPLEMENTED:\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case INHERIT_DOC:\n                            case OVERRIDE:\n                                if (!jsdocBuilder.recordOverride()) {\n                                    parser.addWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case THROWS:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                    if (type \u003d\u003d null) {\n                                        token \u003d eatTokensUntilEOL();\n                                        continue retry;\n                                    }\n                                }\n                                token \u003d current();\n                                jsdocBuilder.recordThrowType(type);\n                                ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                String description \u003d descriptionInfo.string;\n                                if (description.length() \u003e 0) {\n                                    jsdocBuilder.recordThrowDescription(type, description);\n                                }\n                                token \u003d descriptionInfo.token;\n                                continue retry;\n                            case PARAM:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordParamTypeNode(token));\n                                    if (type \u003d\u003d null) {\n                                        token \u003d eatTokensUntilEOL();\n                                        continue retry;\n                                    }\n                                    skipEOLs();\n                                    token \u003d next();\n                                    lineno \u003d stream.getLineno();\n                                    charno \u003d stream.getCharno();\n                                }\n                                String name \u003d null;\n                                boolean isBracketedParam \u003d JsDocToken.LB \u003d\u003d token;\n                                if (isBracketedParam) {\n                                    token \u003d next();\n                                }\n                                if (JsDocToken.STRING !\u003d token) {\n                                    parser.addWarning(\"msg.missing.variable.name\", lineno, charno);\n                                } else {\n                                    name \u003d stream.getString();\n                                    if (isBracketedParam) {\n                                        token \u003d next();\n                                        if (JsDocToken.EQUALS \u003d\u003d token) {\n                                            token \u003d next();\n                                            if (JsDocToken.STRING \u003d\u003d token) {\n                                                token \u003d next();\n                                            }\n                                        }\n                                        if (JsDocToken.RB !\u003d token) {\n                                            reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                                        } else if (type !\u003d null) {\n                                            type \u003d JSTypeExpression.makeOptionalArg(type);\n                                        }\n                                    }\n                                    if (name.indexOf(\u0027.\u0027) \u003e -1) {\n                                        name \u003d null;\n                                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                                        if (jsdocBuilder.hasParameter(name)) {\n                                            parser.addWarning(\"msg.dup.variable.name\", name, lineno, charno);\n                                        } else {\n                                            parser.addWarning(\"msg.jsdoc.incompat.type\", name, lineno, charno);\n                                        }\n                                    }\n                                }\n                                if (name \u003d\u003d null) {\n                                    token \u003d eatTokensUntilEOL(token);\n                                    continue retry;\n                                }\n                                jsdocBuilder.markName(name, lineno, charno);\n                                ExtractionInfo paramDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                String paramDescription \u003d paramDescriptionInfo.string;\n                                if (paramDescription.length() \u003e 0) {\n                                    jsdocBuilder.recordParameterDescription(name, paramDescription);\n                                }\n                                token \u003d paramDescriptionInfo.token;\n                                continue retry;\n                            case PRESERVE_TRY:\n                                if (!jsdocBuilder.recordPreserveTry()) {\n                                    parser.addWarning(\"msg.jsdoc.preservertry\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PRIVATE:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                                    parser.addWarning(\"msg.jsdoc.visibility.private\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PROTECTED:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                                    parser.addWarning(\"msg.jsdoc.visibility.protected\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PUBLIC:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                                    parser.addWarning(\"msg.jsdoc.visibility.public\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_SHADOW:\n                                if (!jsdocBuilder.recordNoShadow()) {\n                                    parser.addWarning(\"msg.jsdoc.noshadow\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_SIDE_EFFECTS:\n                                if (!jsdocBuilder.recordNoSideEffects()) {\n                                    parser.addWarning(\"msg.jsdoc.nosideeffects\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case IMPLICIT_CAST:\n                                if (!jsdocBuilder.recordImplicitCast()) {\n                                    parser.addWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case SEE:\n                                ExtractionInfo referenceInfo \u003d extractSingleLineBlock();\n                                String reference \u003d referenceInfo.string;\n                                if (reference.length() \u003d\u003d 0) {\n                                    parser.addWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno());\n                                } else {\n                                    jsdocBuilder.addReference(reference);\n                                }\n                                token \u003d referenceInfo.token;\n                                continue retry;\n                            case SUPPRESS:\n                                token \u003d parseSuppressTag(next());\n                                continue retry;\n                            case TEMPLATE:\n                                ExtractionInfo templateInfo \u003d extractSingleLineBlock();\n                                String templateTypeName \u003d templateInfo.string;\n                                if (templateTypeName.length() \u003d\u003d 0) {\n                                    parser.addWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno());\n                                } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {\n                                    parser.addWarning(\"msg.jsdoc.template.at.most.once\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d templateInfo.token;\n                                continue retry;\n                            case VERSION:\n                                ExtractionInfo versionInfo \u003d extractSingleLineBlock();\n                                String version \u003d versionInfo.string;\n                                if (version.length() \u003d\u003d 0) {\n                                    parser.addWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno());\n                                } else {\n                                    if (!jsdocBuilder.recordVersion(version)) {\n                                        parser.addWarning(\"msg.jsdoc.extraversion\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d versionInfo.token;\n                                continue retry;\n                            case DEFINE:\n                            case RETURN:\n                            case THIS:\n                            case TYPE:\n                            case TYPEDEF:\n                                skipEOLs();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                token \u003d next();\n                                Node typeNode \u003d parseAndRecordTypeNode(token, lineno, charno);\n                                if (annotation \u003d\u003d Annotation.THIS) {\n                                    typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                    if (typeNode !\u003d null \u0026\u0026 token !\u003d JsDocToken.LC) {\n                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                    }\n                                }\n                                type \u003d createJSTypeExpression(typeNode);\n                                if (type \u003d\u003d null) {\n                                } else {\n                                    switch(annotation) {\n                                        case DEFINE:\n                                            if (!jsdocBuilder.recordDefineType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.define\", lineno, charno);\n                                            }\n                                            break;\n                                        case RETURN:\n                                            if (!jsdocBuilder.recordReturnType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                                break;\n                                            }\n                                            token \u003d current();\n                                            ExtractionInfo returnDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                            String returnDescription \u003d returnDescriptionInfo.string;\n                                            if (returnDescription.length() \u003e 0) {\n                                                jsdocBuilder.recordReturnDescription(returnDescription);\n                                            }\n                                            token \u003d returnDescriptionInfo.token;\n                                            continue retry;\n                                        case THIS:\n                                            if (!jsdocBuilder.recordThisType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                        case TYPE:\n                                            if (!jsdocBuilder.recordType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                        case TYPEDEF:\n                                            if (!jsdocBuilder.recordTypedef(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                    }\n                                    token \u003d eatTokensUntilEOL();\n                                }\n                                continue retry;\n                        }\n                    }\n                }\n                break;\n            case EOC:\n                if (hasParsedFileOverviewDocInfo()) {\n                    fileOverviewJSDocInfo \u003d retrieveAndResetParsedJSDocInfo();\n                }\n                return true;\n            case EOF:\n                jsdocBuilder.build(null);\n                parser.addWarning(\"msg.unexpected.eof\", stream.getLineno(), stream.getCharno());\n                return false;\n            case EOL:\n                if (state \u003d\u003d State.SEARCHING_NEWLINE) {\n                    state \u003d State.SEARCHING_ANNOTATION;\n                }\n                token \u003d next();\n                continue retry;\n            default:\n                if (token \u003d\u003d JsDocToken.STAR \u0026\u0026 state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                    token \u003d next();\n                    continue retry;\n                } else {\n                    state \u003d State.SEARCHING_NEWLINE;\n                    token \u003d eatTokensUntilEOL();\n                    continue retry;\n                }\n        }\n        token \u003d next();\n    }\n}",
      "path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
      "functionStartLine": 133,
      "functionName": "parse",
      "functionAnnotation": "",
      "functionDoc": "Parses a {@link JSDocInfo} object. This parsing method reads all tokens\nreturned by the {@link JsDocTokenStream#getJsDocToken()} method until the\n{@link JsDocToken#EOC} is returned.\n\n@return @code true} if JSDoc information was correctly parsed,\n    {@code false} otherwise\n",
      "diff": "@@ -1,460 +1,458 @@\n boolean parse() {\n     int lineno;\n     int charno;\n     JSTypeExpression type;\n     state \u003d State.SEARCHING_ANNOTATION;\n     JsDocToken token \u003d next();\n     ExtractionInfo blockInfo \u003d extractBlockComment(token);\n     token \u003d blockInfo.token;\n     if (blockInfo.string.length() \u003e 0) {\n         jsdocBuilder.recordBlockDescription(blockInfo.string);\n     }\n     retry: for (; ; ) {\n         switch(token) {\n             case ANNOTATION:\n                 if (state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                     state \u003d State.SEARCHING_NEWLINE;\n                     lineno \u003d stream.getLineno();\n                     charno \u003d stream.getCharno();\n                     String annotationName \u003d stream.getString();\n                     Annotation annotation \u003d annotationNames.get(annotationName);\n                     if (annotation \u003d\u003d null) {\n                         parser.addWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno());\n                     } else {\n                         jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n                         switch(annotation) {\n                             case AUTHOR:\n                                 ExtractionInfo authorInfo \u003d extractSingleLineBlock();\n                                 String author \u003d authorInfo.string;\n                                 if (author.length() \u003d\u003d 0) {\n                                     parser.addWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno());\n                                 } else {\n                                     jsdocBuilder.addAuthor(author);\n                                 }\n                                 token \u003d authorInfo.token;\n                                 continue retry;\n                             case CONSTANT:\n                                 if (!jsdocBuilder.recordConstancy()) {\n                                     parser.addWarning(\"msg.jsdoc.const\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case CONSTRUCTOR:\n                                 if (!jsdocBuilder.recordConstructor()) {\n                                     if (jsdocBuilder.isInterfaceRecorded()) {\n                                         parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                     } else {\n                                         parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case DEPRECATED:\n                                 if (!jsdocBuilder.recordDeprecated()) {\n                                     parser.addWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 ExtractionInfo reasonInfo \u003d extractMultilineTextualBlock(token);\n                                 String reason \u003d reasonInfo.string;\n                                 if (reason.length() \u003e 0) {\n                                     jsdocBuilder.recordDeprecationReason(reason);\n                                 }\n                                 token \u003d reasonInfo.token;\n                                 continue retry;\n                             case INTERFACE:\n                                 if (!jsdocBuilder.recordInterface()) {\n                                     if (jsdocBuilder.isConstructorRecorded()) {\n                                         parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                     } else {\n                                         parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case DESC:\n                                 if (jsdocBuilder.isDescriptionRecorded()) {\n                                     parser.addWarning(\"msg.jsdoc.desc.extra\", stream.getLineno(), stream.getCharno());\n                                     token \u003d eatTokensUntilEOL();\n                                     continue retry;\n                                 } else {\n                                     ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                     String description \u003d descriptionInfo.string;\n                                     jsdocBuilder.recordDescription(description);\n                                     token \u003d descriptionInfo.token;\n                                     continue retry;\n                                 }\n                             case FILE_OVERVIEW:\n                                 ExtractionInfo fileOverviewInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.TRIM);\n                                 String fileOverview \u003d fileOverviewInfo.string;\n                                 if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo !\u003d null) {\n                                     parser.addWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d fileOverviewInfo.token;\n                                 continue retry;\n                             case LICENSE:\n                             case PRESERVE:\n                                 ExtractionInfo preserveInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);\n                                 String preserve \u003d preserveInfo.string;\n                                 if (preserve.length() \u003e 0) {\n                                     if (fileLevelJsDocBuilder !\u003d null) {\n                                         fileLevelJsDocBuilder.append(preserve);\n                                     }\n                                 }\n                                 token \u003d preserveInfo.token;\n                                 continue retry;\n                             case ENUM:\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                 }\n                                 if (type \u003d\u003d null) {\n                                     type \u003d createJSTypeExpression(newStringNode(\"number\"));\n                                 }\n                                 if (!jsdocBuilder.recordEnumParameterType(type)) {\n                                     parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                 }\n                                 token \u003d eatTokensUntilEOL(token);\n                                 continue retry;\n                             case EXPORT:\n                                 if (!jsdocBuilder.recordExport()) {\n                                     parser.addWarning(\"msg.jsdoc.export\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case EXTERNS:\n                                 if (!jsdocBuilder.recordExterns()) {\n                                     parser.addWarning(\"msg.jsdoc.externs\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case JAVA_DISPATCH:\n                                 if (!jsdocBuilder.recordJavaDispatch()) {\n                                     parser.addWarning(\"msg.jsdoc.javadispatch\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case EXTENDS:\n                             case IMPLEMENTS:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 boolean matchingRc \u003d false;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     token \u003d next();\n                                     matchingRc \u003d true;\n                                 }\n                                 if (token \u003d\u003d JsDocToken.STRING) {\n                                     Node typeNode \u003d parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);\n                                     lineno \u003d stream.getLineno();\n                                     charno \u003d stream.getCharno();\n                                     typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                     if (typeNode !\u003d null \u0026\u0026 !matchingRc) {\n                                         typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                     }\n                                     type \u003d createJSTypeExpression(typeNode);\n                                     if (annotation \u003d\u003d Annotation.EXTENDS) {\n                                         if (!jsdocBuilder.recordBaseType(type)) {\n                                             parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                         }\n                                     } else {\n                                         Preconditions.checkState(annotation \u003d\u003d Annotation.IMPLEMENTS);\n                                         if (!jsdocBuilder.recordImplementedInterface(type)) {\n                                             parser.addWarning(\"msg.jsdoc.implements.duplicate\", lineno, charno);\n                                         }\n                                     }\n                                     token \u003d next();\n                                     if (matchingRc) {\n                                         if (token !\u003d JsDocToken.RC) {\n                                             parser.addWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                         }\n                                     } else if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOF \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                         parser.addWarning(\"msg.end.annotation.expected\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 } else {\n                                     parser.addWarning(\"msg.no.type.name\", lineno, charno);\n                                 }\n                                 token \u003d eatTokensUntilEOL(token);\n                                 continue retry;\n                             case HIDDEN:\n                                 if (!jsdocBuilder.recordHiddenness()) {\n                                     parser.addWarning(\"msg.jsdoc.hidden\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_ALIAS:\n                                 if (!jsdocBuilder.recordNoAlias()) {\n                                     parser.addWarning(\"msg.jsdoc.noalias\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_TYPE_CHECK:\n                                 if (!jsdocBuilder.recordNoTypeCheck()) {\n                                     parser.addWarning(\"msg.jsdoc.nocheck\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NOT_IMPLEMENTED:\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case INHERIT_DOC:\n                             case OVERRIDE:\n                                 if (!jsdocBuilder.recordOverride()) {\n                                     parser.addWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case THROWS:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                     if (type \u003d\u003d null) {\n                                         token \u003d eatTokensUntilEOL();\n                                         continue retry;\n                                     }\n                                 }\n                                 token \u003d current();\n                                 jsdocBuilder.recordThrowType(type);\n                                 ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                 String description \u003d descriptionInfo.string;\n                                 if (description.length() \u003e 0) {\n                                     jsdocBuilder.recordThrowDescription(type, description);\n                                 }\n                                 token \u003d descriptionInfo.token;\n                                 continue retry;\n                             case PARAM:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordParamTypeNode(token));\n                                     if (type \u003d\u003d null) {\n                                         token \u003d eatTokensUntilEOL();\n                                         continue retry;\n                                     }\n                                     skipEOLs();\n                                     token \u003d next();\n                                     lineno \u003d stream.getLineno();\n                                     charno \u003d stream.getCharno();\n                                 }\n                                 String name \u003d null;\n                                 boolean isBracketedParam \u003d JsDocToken.LB \u003d\u003d token;\n                                 if (isBracketedParam) {\n                                     token \u003d next();\n                                 }\n                                 if (JsDocToken.STRING !\u003d token) {\n                                     parser.addWarning(\"msg.missing.variable.name\", lineno, charno);\n                                 } else {\n                                     name \u003d stream.getString();\n                                     if (isBracketedParam) {\n                                         token \u003d next();\n                                         if (JsDocToken.EQUALS \u003d\u003d token) {\n                                             token \u003d next();\n                                             if (JsDocToken.STRING \u003d\u003d token) {\n                                                 token \u003d next();\n                                             }\n                                         }\n                                         if (JsDocToken.RB !\u003d token) {\n                                             reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                                         } else if (type !\u003d null) {\n                                             type \u003d JSTypeExpression.makeOptionalArg(type);\n                                         }\n                                     }\n                                     if (name.indexOf(\u0027.\u0027) \u003e -1) {\n                                         name \u003d null;\n                                     } else if (!jsdocBuilder.recordParameter(name, type)) {\n                                         if (jsdocBuilder.hasParameter(name)) {\n                                             parser.addWarning(\"msg.dup.variable.name\", name, lineno, charno);\n                                         } else {\n                                             parser.addWarning(\"msg.jsdoc.incompat.type\", name, lineno, charno);\n                                         }\n                                     }\n                                 }\n                                 if (name \u003d\u003d null) {\n                                     token \u003d eatTokensUntilEOL(token);\n                                     continue retry;\n                                 }\n                                 jsdocBuilder.markName(name, lineno, charno);\n                                 ExtractionInfo paramDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                 String paramDescription \u003d paramDescriptionInfo.string;\n                                 if (paramDescription.length() \u003e 0) {\n                                     jsdocBuilder.recordParameterDescription(name, paramDescription);\n                                 }\n                                 token \u003d paramDescriptionInfo.token;\n                                 continue retry;\n                             case PRESERVE_TRY:\n                                 if (!jsdocBuilder.recordPreserveTry()) {\n                                     parser.addWarning(\"msg.jsdoc.preservertry\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PRIVATE:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                                     parser.addWarning(\"msg.jsdoc.visibility.private\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PROTECTED:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                                     parser.addWarning(\"msg.jsdoc.visibility.protected\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PUBLIC:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                                     parser.addWarning(\"msg.jsdoc.visibility.public\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_SHADOW:\n                                 if (!jsdocBuilder.recordNoShadow()) {\n                                     parser.addWarning(\"msg.jsdoc.noshadow\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_SIDE_EFFECTS:\n                                 if (!jsdocBuilder.recordNoSideEffects()) {\n                                     parser.addWarning(\"msg.jsdoc.nosideeffects\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case IMPLICIT_CAST:\n                                 if (!jsdocBuilder.recordImplicitCast()) {\n                                     parser.addWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case SEE:\n                                 ExtractionInfo referenceInfo \u003d extractSingleLineBlock();\n                                 String reference \u003d referenceInfo.string;\n                                 if (reference.length() \u003d\u003d 0) {\n                                     parser.addWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno());\n                                 } else {\n                                     jsdocBuilder.addReference(reference);\n                                 }\n                                 token \u003d referenceInfo.token;\n                                 continue retry;\n                             case SUPPRESS:\n                                 token \u003d parseSuppressTag(next());\n                                 continue retry;\n                             case TEMPLATE:\n                                 ExtractionInfo templateInfo \u003d extractSingleLineBlock();\n                                 String templateTypeName \u003d templateInfo.string;\n                                 if (templateTypeName.length() \u003d\u003d 0) {\n                                     parser.addWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno());\n                                 } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {\n                                     parser.addWarning(\"msg.jsdoc.template.at.most.once\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d templateInfo.token;\n                                 continue retry;\n                             case VERSION:\n                                 ExtractionInfo versionInfo \u003d extractSingleLineBlock();\n                                 String version \u003d versionInfo.string;\n                                 if (version.length() \u003d\u003d 0) {\n                                     parser.addWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno());\n                                 } else {\n                                     if (!jsdocBuilder.recordVersion(version)) {\n                                         parser.addWarning(\"msg.jsdoc.extraversion\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d versionInfo.token;\n                                 continue retry;\n                             case DEFINE:\n                             case RETURN:\n                             case THIS:\n                             case TYPE:\n                             case TYPEDEF:\n                                 skipEOLs();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 token \u003d next();\n                                 Node typeNode \u003d parseAndRecordTypeNode(token, lineno, charno);\n                                 if (annotation \u003d\u003d Annotation.THIS) {\n                                     typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                     if (typeNode !\u003d null \u0026\u0026 token !\u003d JsDocToken.LC) {\n                                         typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                     }\n                                 }\n                                 type \u003d createJSTypeExpression(typeNode);\n                                 if (type \u003d\u003d null) {\n                                 } else {\n                                     switch(annotation) {\n                                         case DEFINE:\n-                                            if (!isValidDefineType(typeNode)) {\n-                                                parser.addWarning(\"msg.jsdoc.define.badtype\", lineno, charno);\n-                                            } else if (!jsdocBuilder.recordDefineType(type)) {\n+                                            if (!jsdocBuilder.recordDefineType(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.define\", lineno, charno);\n                                             }\n                                             break;\n                                         case RETURN:\n                                             if (!jsdocBuilder.recordReturnType(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                                 break;\n                                             }\n                                             token \u003d current();\n                                             ExtractionInfo returnDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                             String returnDescription \u003d returnDescriptionInfo.string;\n                                             if (returnDescription.length() \u003e 0) {\n                                                 jsdocBuilder.recordReturnDescription(returnDescription);\n                                             }\n                                             token \u003d returnDescriptionInfo.token;\n                                             continue retry;\n                                         case THIS:\n                                             if (!jsdocBuilder.recordThisType(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                         case TYPE:\n                                             if (!jsdocBuilder.recordType(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                         case TYPEDEF:\n                                             if (!jsdocBuilder.recordTypedef(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                     }\n                                     token \u003d eatTokensUntilEOL();\n                                 }\n                                 continue retry;\n                         }\n                     }\n                 }\n                 break;\n             case EOC:\n                 if (hasParsedFileOverviewDocInfo()) {\n                     fileOverviewJSDocInfo \u003d retrieveAndResetParsedJSDocInfo();\n                 }\n                 return true;\n             case EOF:\n                 jsdocBuilder.build(null);\n                 parser.addWarning(\"msg.unexpected.eof\", stream.getLineno(), stream.getCharno());\n                 return false;\n             case EOL:\n                 if (state \u003d\u003d State.SEARCHING_NEWLINE) {\n                     state \u003d State.SEARCHING_ANNOTATION;\n                 }\n                 token \u003d next();\n                 continue retry;\n             default:\n                 if (token \u003d\u003d JsDocToken.STAR \u0026\u0026 state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                     token \u003d next();\n                     continue retry;\n                 } else {\n                     state \u003d State.SEARCHING_NEWLINE;\n                     token \u003d eatTokensUntilEOL();\n                     continue retry;\n                 }\n         }\n         token \u003d next();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "52ecbc65e981b9f169466f8898155bc5f8bfad7a": {
      "type": "Ybodychange",
      "commitMessage": "Add some new externs files: webkit notifications, web storage, and file access.\n\nFix a minor bug in type checking \u0027in\u0027 operators.\n\nFix a bug in warnings filtering.\n\nAdd a @javadispatch annotation.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@81 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "1/28/10, 1:52 PM",
      "commitName": "52ecbc65e981b9f169466f8898155bc5f8bfad7a",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "1/19/10, 7:30 AM",
      "commitNameOld": "026c346555bbcc9d25fdeedbc85a6d68f0307775",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 9.27,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "actualSource": "boolean parse() {\n    int lineno;\n    int charno;\n    JSTypeExpression type;\n    state \u003d State.SEARCHING_ANNOTATION;\n    JsDocToken token \u003d next();\n    ExtractionInfo blockInfo \u003d extractBlockComment(token);\n    token \u003d blockInfo.token;\n    if (blockInfo.string.length() \u003e 0) {\n        jsdocBuilder.recordBlockDescription(blockInfo.string);\n    }\n    retry: for (; ; ) {\n        switch(token) {\n            case ANNOTATION:\n                if (state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                    state \u003d State.SEARCHING_NEWLINE;\n                    lineno \u003d stream.getLineno();\n                    charno \u003d stream.getCharno();\n                    String annotationName \u003d stream.getString();\n                    Annotation annotation \u003d annotationNames.get(annotationName);\n                    if (annotation \u003d\u003d null) {\n                        parser.addWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno());\n                    } else {\n                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n                        switch(annotation) {\n                            case AUTHOR:\n                                ExtractionInfo authorInfo \u003d extractSingleLineBlock();\n                                String author \u003d authorInfo.string;\n                                if (author.length() \u003d\u003d 0) {\n                                    parser.addWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno());\n                                } else {\n                                    jsdocBuilder.addAuthor(author);\n                                }\n                                token \u003d authorInfo.token;\n                                continue retry;\n                            case CONSTANT:\n                                if (!jsdocBuilder.recordConstancy()) {\n                                    parser.addWarning(\"msg.jsdoc.const\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case CONSTRUCTOR:\n                                if (!jsdocBuilder.recordConstructor()) {\n                                    if (jsdocBuilder.isInterfaceRecorded()) {\n                                        parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case DEPRECATED:\n                                if (!jsdocBuilder.recordDeprecated()) {\n                                    parser.addWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno());\n                                }\n                                ExtractionInfo reasonInfo \u003d extractMultilineTextualBlock(token);\n                                String reason \u003d reasonInfo.string;\n                                if (reason.length() \u003e 0) {\n                                    jsdocBuilder.recordDeprecationReason(reason);\n                                }\n                                token \u003d reasonInfo.token;\n                                continue retry;\n                            case INTERFACE:\n                                if (!jsdocBuilder.recordInterface()) {\n                                    if (jsdocBuilder.isConstructorRecorded()) {\n                                        parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case DESC:\n                                if (jsdocBuilder.isDescriptionRecorded()) {\n                                    parser.addWarning(\"msg.jsdoc.desc.extra\", stream.getLineno(), stream.getCharno());\n                                    token \u003d eatTokensUntilEOL();\n                                    continue retry;\n                                } else {\n                                    ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                    String description \u003d descriptionInfo.string;\n                                    jsdocBuilder.recordDescription(description);\n                                    token \u003d descriptionInfo.token;\n                                    continue retry;\n                                }\n                            case FILE_OVERVIEW:\n                                ExtractionInfo fileOverviewInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.TRIM);\n                                String fileOverview \u003d fileOverviewInfo.string;\n                                if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo !\u003d null) {\n                                    parser.addWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d fileOverviewInfo.token;\n                                continue retry;\n                            case LICENSE:\n                            case PRESERVE:\n                                ExtractionInfo preserveInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);\n                                String preserve \u003d preserveInfo.string;\n                                if (preserve.length() \u003e 0) {\n                                    if (fileLevelJsDocBuilder !\u003d null) {\n                                        fileLevelJsDocBuilder.append(preserve);\n                                    }\n                                }\n                                token \u003d preserveInfo.token;\n                                continue retry;\n                            case ENUM:\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                }\n                                if (type \u003d\u003d null) {\n                                    type \u003d createJSTypeExpression(newStringNode(\"number\"));\n                                }\n                                if (!jsdocBuilder.recordEnumParameterType(type)) {\n                                    parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                }\n                                token \u003d eatTokensUntilEOL(token);\n                                continue retry;\n                            case EXPORT:\n                                if (!jsdocBuilder.recordExport()) {\n                                    parser.addWarning(\"msg.jsdoc.export\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case EXTERNS:\n                                if (!jsdocBuilder.recordExterns()) {\n                                    parser.addWarning(\"msg.jsdoc.externs\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case JAVA_DISPATCH:\n                                if (!jsdocBuilder.recordJavaDispatch()) {\n                                    parser.addWarning(\"msg.jsdoc.javadispatch\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case EXTENDS:\n                            case IMPLEMENTS:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                boolean matchingRc \u003d false;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    token \u003d next();\n                                    matchingRc \u003d true;\n                                }\n                                if (token \u003d\u003d JsDocToken.STRING) {\n                                    Node typeNode \u003d parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);\n                                    lineno \u003d stream.getLineno();\n                                    charno \u003d stream.getCharno();\n                                    typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                    if (typeNode !\u003d null \u0026\u0026 !matchingRc) {\n                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                    }\n                                    type \u003d createJSTypeExpression(typeNode);\n                                    if (annotation \u003d\u003d Annotation.EXTENDS) {\n                                        if (!jsdocBuilder.recordBaseType(type)) {\n                                            parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                        }\n                                    } else {\n                                        Preconditions.checkState(annotation \u003d\u003d Annotation.IMPLEMENTS);\n                                        if (!jsdocBuilder.recordImplementedInterface(type)) {\n                                            parser.addWarning(\"msg.jsdoc.implements.duplicate\", lineno, charno);\n                                        }\n                                    }\n                                    token \u003d next();\n                                    if (matchingRc) {\n                                        if (token !\u003d JsDocToken.RC) {\n                                            parser.addWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                        }\n                                    } else if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOF \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                        parser.addWarning(\"msg.end.annotation.expected\", stream.getLineno(), stream.getCharno());\n                                    }\n                                } else {\n                                    parser.addWarning(\"msg.no.type.name\", lineno, charno);\n                                }\n                                token \u003d eatTokensUntilEOL(token);\n                                continue retry;\n                            case HIDDEN:\n                                if (!jsdocBuilder.recordHiddenness()) {\n                                    parser.addWarning(\"msg.jsdoc.hidden\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_ALIAS:\n                                if (!jsdocBuilder.recordNoAlias()) {\n                                    parser.addWarning(\"msg.jsdoc.noalias\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_TYPE_CHECK:\n                                if (!jsdocBuilder.recordNoTypeCheck()) {\n                                    parser.addWarning(\"msg.jsdoc.nocheck\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NOT_IMPLEMENTED:\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case INHERIT_DOC:\n                            case OVERRIDE:\n                                if (!jsdocBuilder.recordOverride()) {\n                                    parser.addWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case THROWS:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                    if (type \u003d\u003d null) {\n                                        token \u003d eatTokensUntilEOL();\n                                        continue retry;\n                                    }\n                                }\n                                token \u003d current();\n                                jsdocBuilder.recordThrowType(type);\n                                ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                String description \u003d descriptionInfo.string;\n                                if (description.length() \u003e 0) {\n                                    jsdocBuilder.recordThrowDescription(type, description);\n                                }\n                                token \u003d descriptionInfo.token;\n                                continue retry;\n                            case PARAM:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordParamTypeNode(token));\n                                    if (type \u003d\u003d null) {\n                                        token \u003d eatTokensUntilEOL();\n                                        continue retry;\n                                    }\n                                    skipEOLs();\n                                    token \u003d next();\n                                    lineno \u003d stream.getLineno();\n                                    charno \u003d stream.getCharno();\n                                }\n                                String name \u003d null;\n                                boolean isBracketedParam \u003d JsDocToken.LB \u003d\u003d token;\n                                if (isBracketedParam) {\n                                    token \u003d next();\n                                }\n                                if (JsDocToken.STRING !\u003d token) {\n                                    parser.addWarning(\"msg.missing.variable.name\", lineno, charno);\n                                } else {\n                                    name \u003d stream.getString();\n                                    if (isBracketedParam) {\n                                        token \u003d next();\n                                        if (JsDocToken.EQUALS \u003d\u003d token) {\n                                            token \u003d next();\n                                            if (JsDocToken.STRING \u003d\u003d token) {\n                                                token \u003d next();\n                                            }\n                                        }\n                                        if (JsDocToken.RB !\u003d token) {\n                                            reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                                        } else if (type !\u003d null) {\n                                            type \u003d JSTypeExpression.makeOptionalArg(type);\n                                        }\n                                    }\n                                    if (name.indexOf(\u0027.\u0027) \u003e -1) {\n                                        name \u003d null;\n                                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                                        if (jsdocBuilder.hasParameter(name)) {\n                                            parser.addWarning(\"msg.dup.variable.name\", name, lineno, charno);\n                                        } else {\n                                            parser.addWarning(\"msg.jsdoc.incompat.type\", name, lineno, charno);\n                                        }\n                                    }\n                                }\n                                if (name \u003d\u003d null) {\n                                    token \u003d eatTokensUntilEOL(token);\n                                    continue retry;\n                                }\n                                jsdocBuilder.markName(name, lineno, charno);\n                                ExtractionInfo paramDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                String paramDescription \u003d paramDescriptionInfo.string;\n                                if (paramDescription.length() \u003e 0) {\n                                    jsdocBuilder.recordParameterDescription(name, paramDescription);\n                                }\n                                token \u003d paramDescriptionInfo.token;\n                                continue retry;\n                            case PRESERVE_TRY:\n                                if (!jsdocBuilder.recordPreserveTry()) {\n                                    parser.addWarning(\"msg.jsdoc.preservertry\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PRIVATE:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                                    parser.addWarning(\"msg.jsdoc.visibility.private\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PROTECTED:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                                    parser.addWarning(\"msg.jsdoc.visibility.protected\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PUBLIC:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                                    parser.addWarning(\"msg.jsdoc.visibility.public\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_SHADOW:\n                                if (!jsdocBuilder.recordNoShadow()) {\n                                    parser.addWarning(\"msg.jsdoc.noshadow\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_SIDE_EFFECTS:\n                                if (!jsdocBuilder.recordNoSideEffects()) {\n                                    parser.addWarning(\"msg.jsdoc.nosideeffects\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case IMPLICIT_CAST:\n                                if (!jsdocBuilder.recordImplicitCast()) {\n                                    parser.addWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case SEE:\n                                ExtractionInfo referenceInfo \u003d extractSingleLineBlock();\n                                String reference \u003d referenceInfo.string;\n                                if (reference.length() \u003d\u003d 0) {\n                                    parser.addWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno());\n                                } else {\n                                    jsdocBuilder.addReference(reference);\n                                }\n                                token \u003d referenceInfo.token;\n                                continue retry;\n                            case SUPPRESS:\n                                token \u003d parseSuppressTag(next());\n                                continue retry;\n                            case TEMPLATE:\n                                ExtractionInfo templateInfo \u003d extractSingleLineBlock();\n                                String templateTypeName \u003d templateInfo.string;\n                                if (templateTypeName.length() \u003d\u003d 0) {\n                                    parser.addWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno());\n                                } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {\n                                    parser.addWarning(\"msg.jsdoc.template.at.most.once\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d templateInfo.token;\n                                continue retry;\n                            case VERSION:\n                                ExtractionInfo versionInfo \u003d extractSingleLineBlock();\n                                String version \u003d versionInfo.string;\n                                if (version.length() \u003d\u003d 0) {\n                                    parser.addWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno());\n                                } else {\n                                    if (!jsdocBuilder.recordVersion(version)) {\n                                        parser.addWarning(\"msg.jsdoc.extraversion\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d versionInfo.token;\n                                continue retry;\n                            case DEFINE:\n                            case RETURN:\n                            case THIS:\n                            case TYPE:\n                            case TYPEDEF:\n                                skipEOLs();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                token \u003d next();\n                                Node typeNode \u003d parseAndRecordTypeNode(token, lineno, charno);\n                                if (annotation \u003d\u003d Annotation.THIS) {\n                                    typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                    if (typeNode !\u003d null \u0026\u0026 token !\u003d JsDocToken.LC) {\n                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                    }\n                                }\n                                type \u003d createJSTypeExpression(typeNode);\n                                if (type \u003d\u003d null) {\n                                } else {\n                                    switch(annotation) {\n                                        case DEFINE:\n                                            if (!isValidDefineType(typeNode)) {\n                                                parser.addWarning(\"msg.jsdoc.define.badtype\", lineno, charno);\n                                            } else if (!jsdocBuilder.recordDefineType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.define\", lineno, charno);\n                                            }\n                                            break;\n                                        case RETURN:\n                                            if (!jsdocBuilder.recordReturnType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                                break;\n                                            }\n                                            token \u003d current();\n                                            ExtractionInfo returnDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                            String returnDescription \u003d returnDescriptionInfo.string;\n                                            if (returnDescription.length() \u003e 0) {\n                                                jsdocBuilder.recordReturnDescription(returnDescription);\n                                            }\n                                            token \u003d returnDescriptionInfo.token;\n                                            continue retry;\n                                        case THIS:\n                                            if (!jsdocBuilder.recordThisType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                        case TYPE:\n                                            if (!jsdocBuilder.recordType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                        case TYPEDEF:\n                                            if (!jsdocBuilder.recordTypedef(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                    }\n                                    token \u003d eatTokensUntilEOL();\n                                }\n                                continue retry;\n                        }\n                    }\n                }\n                break;\n            case EOC:\n                if (hasParsedFileOverviewDocInfo()) {\n                    fileOverviewJSDocInfo \u003d retrieveAndResetParsedJSDocInfo();\n                }\n                return true;\n            case EOF:\n                jsdocBuilder.build(null);\n                parser.addWarning(\"msg.unexpected.eof\", stream.getLineno(), stream.getCharno());\n                return false;\n            case EOL:\n                if (state \u003d\u003d State.SEARCHING_NEWLINE) {\n                    state \u003d State.SEARCHING_ANNOTATION;\n                }\n                token \u003d next();\n                continue retry;\n            default:\n                if (token \u003d\u003d JsDocToken.STAR \u0026\u0026 state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                    token \u003d next();\n                    continue retry;\n                } else {\n                    state \u003d State.SEARCHING_NEWLINE;\n                    token \u003d eatTokensUntilEOL();\n                    continue retry;\n                }\n        }\n        token \u003d next();\n    }\n}",
      "path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
      "functionStartLine": 242,
      "functionName": "parse",
      "functionAnnotation": "",
      "functionDoc": "Parses a {@link JSDocInfo} object. This parsing method reads all tokens\nreturned by the {@link JsDocTokenStream#getJsDocToken()} method until the\n{@link JsDocToken#EOC} is returned.\n\n@return @code true} if JSDoc information was correctly parsed,\n    {@code false} otherwise\n",
      "diff": "@@ -1,454 +1,460 @@\n boolean parse() {\n     int lineno;\n     int charno;\n     JSTypeExpression type;\n     state \u003d State.SEARCHING_ANNOTATION;\n     JsDocToken token \u003d next();\n     ExtractionInfo blockInfo \u003d extractBlockComment(token);\n     token \u003d blockInfo.token;\n     if (blockInfo.string.length() \u003e 0) {\n         jsdocBuilder.recordBlockDescription(blockInfo.string);\n     }\n     retry: for (; ; ) {\n         switch(token) {\n             case ANNOTATION:\n                 if (state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                     state \u003d State.SEARCHING_NEWLINE;\n                     lineno \u003d stream.getLineno();\n                     charno \u003d stream.getCharno();\n                     String annotationName \u003d stream.getString();\n                     Annotation annotation \u003d annotationNames.get(annotationName);\n                     if (annotation \u003d\u003d null) {\n                         parser.addWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno());\n                     } else {\n                         jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n                         switch(annotation) {\n                             case AUTHOR:\n                                 ExtractionInfo authorInfo \u003d extractSingleLineBlock();\n                                 String author \u003d authorInfo.string;\n                                 if (author.length() \u003d\u003d 0) {\n                                     parser.addWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno());\n                                 } else {\n                                     jsdocBuilder.addAuthor(author);\n                                 }\n                                 token \u003d authorInfo.token;\n                                 continue retry;\n                             case CONSTANT:\n                                 if (!jsdocBuilder.recordConstancy()) {\n                                     parser.addWarning(\"msg.jsdoc.const\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case CONSTRUCTOR:\n                                 if (!jsdocBuilder.recordConstructor()) {\n                                     if (jsdocBuilder.isInterfaceRecorded()) {\n                                         parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                     } else {\n                                         parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case DEPRECATED:\n                                 if (!jsdocBuilder.recordDeprecated()) {\n                                     parser.addWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 ExtractionInfo reasonInfo \u003d extractMultilineTextualBlock(token);\n                                 String reason \u003d reasonInfo.string;\n                                 if (reason.length() \u003e 0) {\n                                     jsdocBuilder.recordDeprecationReason(reason);\n                                 }\n                                 token \u003d reasonInfo.token;\n                                 continue retry;\n                             case INTERFACE:\n                                 if (!jsdocBuilder.recordInterface()) {\n                                     if (jsdocBuilder.isConstructorRecorded()) {\n                                         parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                     } else {\n                                         parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case DESC:\n                                 if (jsdocBuilder.isDescriptionRecorded()) {\n                                     parser.addWarning(\"msg.jsdoc.desc.extra\", stream.getLineno(), stream.getCharno());\n                                     token \u003d eatTokensUntilEOL();\n                                     continue retry;\n                                 } else {\n                                     ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                     String description \u003d descriptionInfo.string;\n                                     jsdocBuilder.recordDescription(description);\n                                     token \u003d descriptionInfo.token;\n                                     continue retry;\n                                 }\n                             case FILE_OVERVIEW:\n                                 ExtractionInfo fileOverviewInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.TRIM);\n                                 String fileOverview \u003d fileOverviewInfo.string;\n                                 if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo !\u003d null) {\n                                     parser.addWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d fileOverviewInfo.token;\n                                 continue retry;\n                             case LICENSE:\n                             case PRESERVE:\n                                 ExtractionInfo preserveInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);\n                                 String preserve \u003d preserveInfo.string;\n                                 if (preserve.length() \u003e 0) {\n                                     if (fileLevelJsDocBuilder !\u003d null) {\n                                         fileLevelJsDocBuilder.append(preserve);\n                                     }\n                                 }\n                                 token \u003d preserveInfo.token;\n                                 continue retry;\n                             case ENUM:\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                 }\n                                 if (type \u003d\u003d null) {\n                                     type \u003d createJSTypeExpression(newStringNode(\"number\"));\n                                 }\n                                 if (!jsdocBuilder.recordEnumParameterType(type)) {\n                                     parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                 }\n                                 token \u003d eatTokensUntilEOL(token);\n                                 continue retry;\n                             case EXPORT:\n                                 if (!jsdocBuilder.recordExport()) {\n                                     parser.addWarning(\"msg.jsdoc.export\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case EXTERNS:\n                                 if (!jsdocBuilder.recordExterns()) {\n                                     parser.addWarning(\"msg.jsdoc.externs\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n+                            case JAVA_DISPATCH:\n+                                if (!jsdocBuilder.recordJavaDispatch()) {\n+                                    parser.addWarning(\"msg.jsdoc.javadispatch\", stream.getLineno(), stream.getCharno());\n+                                }\n+                                token \u003d eatTokensUntilEOL();\n+                                continue retry;\n                             case EXTENDS:\n                             case IMPLEMENTS:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 boolean matchingRc \u003d false;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     token \u003d next();\n                                     matchingRc \u003d true;\n                                 }\n                                 if (token \u003d\u003d JsDocToken.STRING) {\n                                     Node typeNode \u003d parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);\n                                     lineno \u003d stream.getLineno();\n                                     charno \u003d stream.getCharno();\n                                     typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                     if (typeNode !\u003d null \u0026\u0026 !matchingRc) {\n                                         typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                     }\n                                     type \u003d createJSTypeExpression(typeNode);\n                                     if (annotation \u003d\u003d Annotation.EXTENDS) {\n                                         if (!jsdocBuilder.recordBaseType(type)) {\n                                             parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                         }\n                                     } else {\n                                         Preconditions.checkState(annotation \u003d\u003d Annotation.IMPLEMENTS);\n                                         if (!jsdocBuilder.recordImplementedInterface(type)) {\n                                             parser.addWarning(\"msg.jsdoc.implements.duplicate\", lineno, charno);\n                                         }\n                                     }\n                                     token \u003d next();\n                                     if (matchingRc) {\n                                         if (token !\u003d JsDocToken.RC) {\n                                             parser.addWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                         }\n                                     } else if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOF \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                         parser.addWarning(\"msg.end.annotation.expected\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 } else {\n                                     parser.addWarning(\"msg.no.type.name\", lineno, charno);\n                                 }\n                                 token \u003d eatTokensUntilEOL(token);\n                                 continue retry;\n                             case HIDDEN:\n                                 if (!jsdocBuilder.recordHiddenness()) {\n                                     parser.addWarning(\"msg.jsdoc.hidden\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_ALIAS:\n                                 if (!jsdocBuilder.recordNoAlias()) {\n                                     parser.addWarning(\"msg.jsdoc.noalias\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_TYPE_CHECK:\n                                 if (!jsdocBuilder.recordNoTypeCheck()) {\n                                     parser.addWarning(\"msg.jsdoc.nocheck\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NOT_IMPLEMENTED:\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case INHERIT_DOC:\n                             case OVERRIDE:\n                                 if (!jsdocBuilder.recordOverride()) {\n                                     parser.addWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case THROWS:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                     if (type \u003d\u003d null) {\n                                         token \u003d eatTokensUntilEOL();\n                                         continue retry;\n                                     }\n                                 }\n                                 token \u003d current();\n                                 jsdocBuilder.recordThrowType(type);\n                                 ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                 String description \u003d descriptionInfo.string;\n                                 if (description.length() \u003e 0) {\n                                     jsdocBuilder.recordThrowDescription(type, description);\n                                 }\n                                 token \u003d descriptionInfo.token;\n                                 continue retry;\n                             case PARAM:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordParamTypeNode(token));\n                                     if (type \u003d\u003d null) {\n                                         token \u003d eatTokensUntilEOL();\n                                         continue retry;\n                                     }\n                                     skipEOLs();\n                                     token \u003d next();\n                                     lineno \u003d stream.getLineno();\n                                     charno \u003d stream.getCharno();\n                                 }\n                                 String name \u003d null;\n                                 boolean isBracketedParam \u003d JsDocToken.LB \u003d\u003d token;\n                                 if (isBracketedParam) {\n                                     token \u003d next();\n                                 }\n                                 if (JsDocToken.STRING !\u003d token) {\n                                     parser.addWarning(\"msg.missing.variable.name\", lineno, charno);\n                                 } else {\n                                     name \u003d stream.getString();\n                                     if (isBracketedParam) {\n                                         token \u003d next();\n                                         if (JsDocToken.EQUALS \u003d\u003d token) {\n                                             token \u003d next();\n                                             if (JsDocToken.STRING \u003d\u003d token) {\n                                                 token \u003d next();\n                                             }\n                                         }\n                                         if (JsDocToken.RB !\u003d token) {\n                                             reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                                         } else if (type !\u003d null) {\n                                             type \u003d JSTypeExpression.makeOptionalArg(type);\n                                         }\n                                     }\n                                     if (name.indexOf(\u0027.\u0027) \u003e -1) {\n                                         name \u003d null;\n                                     } else if (!jsdocBuilder.recordParameter(name, type)) {\n                                         if (jsdocBuilder.hasParameter(name)) {\n                                             parser.addWarning(\"msg.dup.variable.name\", name, lineno, charno);\n                                         } else {\n                                             parser.addWarning(\"msg.jsdoc.incompat.type\", name, lineno, charno);\n                                         }\n                                     }\n                                 }\n                                 if (name \u003d\u003d null) {\n                                     token \u003d eatTokensUntilEOL(token);\n                                     continue retry;\n                                 }\n                                 jsdocBuilder.markName(name, lineno, charno);\n                                 ExtractionInfo paramDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                 String paramDescription \u003d paramDescriptionInfo.string;\n                                 if (paramDescription.length() \u003e 0) {\n                                     jsdocBuilder.recordParameterDescription(name, paramDescription);\n                                 }\n                                 token \u003d paramDescriptionInfo.token;\n                                 continue retry;\n                             case PRESERVE_TRY:\n                                 if (!jsdocBuilder.recordPreserveTry()) {\n                                     parser.addWarning(\"msg.jsdoc.preservertry\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PRIVATE:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                                     parser.addWarning(\"msg.jsdoc.visibility.private\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PROTECTED:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                                     parser.addWarning(\"msg.jsdoc.visibility.protected\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PUBLIC:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                                     parser.addWarning(\"msg.jsdoc.visibility.public\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_SHADOW:\n                                 if (!jsdocBuilder.recordNoShadow()) {\n                                     parser.addWarning(\"msg.jsdoc.noshadow\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_SIDE_EFFECTS:\n                                 if (!jsdocBuilder.recordNoSideEffects()) {\n                                     parser.addWarning(\"msg.jsdoc.nosideeffects\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case IMPLICIT_CAST:\n                                 if (!jsdocBuilder.recordImplicitCast()) {\n                                     parser.addWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case SEE:\n                                 ExtractionInfo referenceInfo \u003d extractSingleLineBlock();\n                                 String reference \u003d referenceInfo.string;\n                                 if (reference.length() \u003d\u003d 0) {\n                                     parser.addWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno());\n                                 } else {\n                                     jsdocBuilder.addReference(reference);\n                                 }\n                                 token \u003d referenceInfo.token;\n                                 continue retry;\n                             case SUPPRESS:\n                                 token \u003d parseSuppressTag(next());\n                                 continue retry;\n                             case TEMPLATE:\n                                 ExtractionInfo templateInfo \u003d extractSingleLineBlock();\n                                 String templateTypeName \u003d templateInfo.string;\n                                 if (templateTypeName.length() \u003d\u003d 0) {\n                                     parser.addWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno());\n                                 } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {\n                                     parser.addWarning(\"msg.jsdoc.template.at.most.once\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d templateInfo.token;\n                                 continue retry;\n                             case VERSION:\n                                 ExtractionInfo versionInfo \u003d extractSingleLineBlock();\n                                 String version \u003d versionInfo.string;\n                                 if (version.length() \u003d\u003d 0) {\n                                     parser.addWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno());\n                                 } else {\n                                     if (!jsdocBuilder.recordVersion(version)) {\n                                         parser.addWarning(\"msg.jsdoc.extraversion\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d versionInfo.token;\n                                 continue retry;\n                             case DEFINE:\n                             case RETURN:\n                             case THIS:\n                             case TYPE:\n                             case TYPEDEF:\n                                 skipEOLs();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 token \u003d next();\n                                 Node typeNode \u003d parseAndRecordTypeNode(token, lineno, charno);\n                                 if (annotation \u003d\u003d Annotation.THIS) {\n                                     typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                     if (typeNode !\u003d null \u0026\u0026 token !\u003d JsDocToken.LC) {\n                                         typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                     }\n                                 }\n                                 type \u003d createJSTypeExpression(typeNode);\n                                 if (type \u003d\u003d null) {\n                                 } else {\n                                     switch(annotation) {\n                                         case DEFINE:\n                                             if (!isValidDefineType(typeNode)) {\n                                                 parser.addWarning(\"msg.jsdoc.define.badtype\", lineno, charno);\n                                             } else if (!jsdocBuilder.recordDefineType(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.define\", lineno, charno);\n                                             }\n                                             break;\n                                         case RETURN:\n                                             if (!jsdocBuilder.recordReturnType(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                                 break;\n                                             }\n                                             token \u003d current();\n                                             ExtractionInfo returnDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                             String returnDescription \u003d returnDescriptionInfo.string;\n                                             if (returnDescription.length() \u003e 0) {\n                                                 jsdocBuilder.recordReturnDescription(returnDescription);\n                                             }\n                                             token \u003d returnDescriptionInfo.token;\n                                             continue retry;\n                                         case THIS:\n                                             if (!jsdocBuilder.recordThisType(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                         case TYPE:\n                                             if (!jsdocBuilder.recordType(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                         case TYPEDEF:\n                                             if (!jsdocBuilder.recordTypedef(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                     }\n                                     token \u003d eatTokensUntilEOL();\n                                 }\n                                 continue retry;\n                         }\n                     }\n                 }\n                 break;\n             case EOC:\n                 if (hasParsedFileOverviewDocInfo()) {\n                     fileOverviewJSDocInfo \u003d retrieveAndResetParsedJSDocInfo();\n                 }\n                 return true;\n             case EOF:\n                 jsdocBuilder.build(null);\n                 parser.addWarning(\"msg.unexpected.eof\", stream.getLineno(), stream.getCharno());\n                 return false;\n             case EOL:\n                 if (state \u003d\u003d State.SEARCHING_NEWLINE) {\n                     state \u003d State.SEARCHING_ANNOTATION;\n                 }\n                 token \u003d next();\n                 continue retry;\n             default:\n                 if (token \u003d\u003d JsDocToken.STAR \u0026\u0026 state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                     token \u003d next();\n                     continue retry;\n                 } else {\n                     state \u003d State.SEARCHING_NEWLINE;\n                     token \u003d eatTokensUntilEOL();\n                     continue retry;\n                 }\n         }\n         token \u003d next();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a478193982ce1fb9271e3f7ebcc1369913c9a859": {
      "type": "Ybodychange",
      "commitMessage": "Add a debugging option for variable renaming.\nBug fixes for direct calls on the arguments array.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@17 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "12/1/09, 8:28 AM",
      "commitName": "a478193982ce1fb9271e3f7ebcc1369913c9a859",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "commitDateOld": "11/19/09, 3:26 PM",
      "commitNameOld": "5af11d33f8b3f5403c9987104601f544cddb96c1",
      "commitAuthorOld": "nicholas.j.santos@gmail.com",
      "daysBetweenCommits": 11.71,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "boolean parse() {\n    int lineno;\n    int charno;\n    JSTypeExpression type;\n    state \u003d State.SEARCHING_ANNOTATION;\n    JsDocToken token \u003d next();\n    ExtractionInfo blockInfo \u003d extractBlockComment(token);\n    token \u003d blockInfo.token;\n    if (blockInfo.string.length() \u003e 0) {\n        jsdocBuilder.recordBlockDescription(blockInfo.string);\n    }\n    retry: for (; ; ) {\n        switch(token) {\n            case ANNOTATION:\n                if (state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                    state \u003d State.SEARCHING_NEWLINE;\n                    lineno \u003d stream.getLineno();\n                    charno \u003d stream.getCharno();\n                    String annotationName \u003d stream.getString();\n                    Annotation annotation \u003d annotationNames.get(annotationName);\n                    if (annotation \u003d\u003d null) {\n                        parser.addWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno());\n                    } else {\n                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n                        switch(annotation) {\n                            case AUTHOR:\n                                ExtractionInfo authorInfo \u003d extractSingleLineBlock();\n                                String author \u003d authorInfo.string;\n                                if (author.length() \u003d\u003d 0) {\n                                    parser.addWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno());\n                                } else {\n                                    jsdocBuilder.addAuthor(author);\n                                }\n                                token \u003d authorInfo.token;\n                                continue retry;\n                            case CONSTANT:\n                                if (!jsdocBuilder.recordConstancy()) {\n                                    parser.addWarning(\"msg.jsdoc.const\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case CONSTRUCTOR:\n                                if (!jsdocBuilder.recordConstructor()) {\n                                    if (jsdocBuilder.isInterfaceRecorded()) {\n                                        parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case DEPRECATED:\n                                if (!jsdocBuilder.recordDeprecated()) {\n                                    parser.addWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno());\n                                }\n                                ExtractionInfo reasonInfo \u003d extractMultilineTextualBlock(token);\n                                String reason \u003d reasonInfo.string;\n                                if (reason.length() \u003e 0) {\n                                    jsdocBuilder.recordDeprecationReason(reason);\n                                }\n                                token \u003d reasonInfo.token;\n                                continue retry;\n                            case INTERFACE:\n                                if (!jsdocBuilder.recordInterface()) {\n                                    if (jsdocBuilder.isConstructorRecorded()) {\n                                        parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case DESC:\n                                if (jsdocBuilder.isDescriptionRecorded()) {\n                                    parser.addWarning(\"msg.jsdoc.desc.extra\", stream.getLineno(), stream.getCharno());\n                                    token \u003d eatTokensUntilEOL();\n                                    continue retry;\n                                } else {\n                                    ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                    String description \u003d descriptionInfo.string;\n                                    jsdocBuilder.recordDescription(description);\n                                    token \u003d descriptionInfo.token;\n                                    continue retry;\n                                }\n                            case FILE_OVERVIEW:\n                                ExtractionInfo fileOverviewInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.TRIM);\n                                String fileOverview \u003d fileOverviewInfo.string;\n                                if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo !\u003d null) {\n                                    parser.addWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d fileOverviewInfo.token;\n                                continue retry;\n                            case LICENSE:\n                            case PRESERVE:\n                                ExtractionInfo preserveInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);\n                                String preserve \u003d preserveInfo.string;\n                                if (preserve.length() \u003e 0) {\n                                    if (fileLevelJsDocBuilder !\u003d null) {\n                                        fileLevelJsDocBuilder.append(preserve);\n                                    }\n                                }\n                                token \u003d preserveInfo.token;\n                                continue retry;\n                            case ENUM:\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                }\n                                if (type \u003d\u003d null) {\n                                    type \u003d createJSTypeExpression(newStringNode(\"number\"));\n                                }\n                                if (!jsdocBuilder.recordEnumParameterType(type)) {\n                                    parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                }\n                                token \u003d eatTokensUntilEOL(token);\n                                continue retry;\n                            case EXPORT:\n                                if (!jsdocBuilder.recordExport()) {\n                                    parser.addWarning(\"msg.jsdoc.export\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case EXTERNS:\n                                if (!jsdocBuilder.recordExterns()) {\n                                    parser.addWarning(\"msg.jsdoc.externs\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case EXTENDS:\n                            case IMPLEMENTS:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                boolean matchingRc \u003d false;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    token \u003d next();\n                                    matchingRc \u003d true;\n                                }\n                                if (token \u003d\u003d JsDocToken.STRING) {\n                                    Node typeNode \u003d parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);\n                                    lineno \u003d stream.getLineno();\n                                    charno \u003d stream.getCharno();\n                                    typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                    if (typeNode !\u003d null \u0026\u0026 !matchingRc) {\n                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                    }\n                                    type \u003d createJSTypeExpression(typeNode);\n                                    if (annotation \u003d\u003d Annotation.EXTENDS) {\n                                        if (!jsdocBuilder.recordBaseType(type)) {\n                                            parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                        }\n                                    } else {\n                                        Preconditions.checkState(annotation \u003d\u003d Annotation.IMPLEMENTS);\n                                        if (!jsdocBuilder.recordImplementedInterface(type)) {\n                                            parser.addWarning(\"msg.jsdoc.implements.duplicate\", lineno, charno);\n                                        }\n                                    }\n                                    token \u003d next();\n                                    if (matchingRc) {\n                                        if (token !\u003d JsDocToken.RC) {\n                                            parser.addWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                        }\n                                    } else if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOF \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                        parser.addWarning(\"msg.end.annotation.expected\", stream.getLineno(), stream.getCharno());\n                                    }\n                                } else {\n                                    parser.addWarning(\"msg.no.type.name\", lineno, charno);\n                                }\n                                token \u003d eatTokensUntilEOL(token);\n                                continue retry;\n                            case HIDDEN:\n                                if (!jsdocBuilder.recordHiddenness()) {\n                                    parser.addWarning(\"msg.jsdoc.hidden\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_ALIAS:\n                                if (!jsdocBuilder.recordNoAlias()) {\n                                    parser.addWarning(\"msg.jsdoc.noalias\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_TYPE_CHECK:\n                                if (!jsdocBuilder.recordNoTypeCheck()) {\n                                    parser.addWarning(\"msg.jsdoc.nocheck\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NOT_IMPLEMENTED:\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case INHERIT_DOC:\n                            case OVERRIDE:\n                                if (!jsdocBuilder.recordOverride()) {\n                                    parser.addWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case THROWS:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                    if (type \u003d\u003d null) {\n                                        token \u003d eatTokensUntilEOL();\n                                        continue retry;\n                                    }\n                                }\n                                token \u003d current();\n                                jsdocBuilder.recordThrowType(type);\n                                ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                String description \u003d descriptionInfo.string;\n                                if (description.length() \u003e 0) {\n                                    jsdocBuilder.recordThrowDescription(type, description);\n                                }\n                                token \u003d descriptionInfo.token;\n                                continue retry;\n                            case PARAM:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordParamTypeNode(token));\n                                    if (type \u003d\u003d null) {\n                                        token \u003d eatTokensUntilEOL();\n                                        continue retry;\n                                    }\n                                    skipEOLs();\n                                    token \u003d next();\n                                    lineno \u003d stream.getLineno();\n                                    charno \u003d stream.getCharno();\n                                }\n                                String name \u003d null;\n                                boolean isBracketedParam \u003d JsDocToken.LB \u003d\u003d token;\n                                if (isBracketedParam) {\n                                    token \u003d next();\n                                }\n                                if (JsDocToken.STRING !\u003d token) {\n                                    parser.addWarning(\"msg.missing.variable.name\", lineno, charno);\n                                } else {\n                                    name \u003d stream.getString();\n                                    if (isBracketedParam) {\n                                        token \u003d next();\n                                        if (JsDocToken.EQUALS \u003d\u003d token) {\n                                            token \u003d next();\n                                            if (JsDocToken.STRING \u003d\u003d token) {\n                                                token \u003d next();\n                                            }\n                                        }\n                                        if (JsDocToken.RB !\u003d token) {\n                                            reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                                        } else if (type !\u003d null) {\n                                            type \u003d JSTypeExpression.makeOptionalArg(type);\n                                        }\n                                    }\n                                    if (name.indexOf(\u0027.\u0027) \u003e -1) {\n                                        name \u003d null;\n                                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                                        if (jsdocBuilder.hasParameter(name)) {\n                                            parser.addWarning(\"msg.dup.variable.name\", name, lineno, charno);\n                                        } else {\n                                            parser.addWarning(\"msg.jsdoc.incompat.type\", name, lineno, charno);\n                                        }\n                                    }\n                                }\n                                if (name \u003d\u003d null) {\n                                    token \u003d eatTokensUntilEOL(token);\n                                    continue retry;\n                                }\n                                jsdocBuilder.markName(name, lineno, charno);\n                                ExtractionInfo paramDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                String paramDescription \u003d paramDescriptionInfo.string;\n                                if (paramDescription.length() \u003e 0) {\n                                    jsdocBuilder.recordParameterDescription(name, paramDescription);\n                                }\n                                token \u003d paramDescriptionInfo.token;\n                                continue retry;\n                            case PRESERVE_TRY:\n                                if (!jsdocBuilder.recordPreserveTry()) {\n                                    parser.addWarning(\"msg.jsdoc.preservertry\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PRIVATE:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                                    parser.addWarning(\"msg.jsdoc.visibility.private\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PROTECTED:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                                    parser.addWarning(\"msg.jsdoc.visibility.protected\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PUBLIC:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                                    parser.addWarning(\"msg.jsdoc.visibility.public\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_SHADOW:\n                                if (!jsdocBuilder.recordNoShadow()) {\n                                    parser.addWarning(\"msg.jsdoc.noshadow\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_SIDE_EFFECTS:\n                                if (!jsdocBuilder.recordNoSideEffects()) {\n                                    parser.addWarning(\"msg.jsdoc.nosideeffects\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case IMPLICIT_CAST:\n                                if (!jsdocBuilder.recordImplicitCast()) {\n                                    parser.addWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case SEE:\n                                ExtractionInfo referenceInfo \u003d extractSingleLineBlock();\n                                String reference \u003d referenceInfo.string;\n                                if (reference.length() \u003d\u003d 0) {\n                                    parser.addWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno());\n                                } else {\n                                    jsdocBuilder.addReference(reference);\n                                }\n                                token \u003d referenceInfo.token;\n                                continue retry;\n                            case SUPPRESS:\n                                token \u003d parseSuppressTag(next());\n                                continue retry;\n                            case TEMPLATE:\n                                ExtractionInfo templateInfo \u003d extractSingleLineBlock();\n                                String templateTypeName \u003d templateInfo.string;\n                                if (templateTypeName.length() \u003d\u003d 0) {\n                                    parser.addWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno());\n                                } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {\n                                    parser.addWarning(\"msg.jsdoc.template.at.most.once\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d templateInfo.token;\n                                continue retry;\n                            case VERSION:\n                                ExtractionInfo versionInfo \u003d extractSingleLineBlock();\n                                String version \u003d versionInfo.string;\n                                if (version.length() \u003d\u003d 0) {\n                                    parser.addWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno());\n                                } else {\n                                    if (!jsdocBuilder.recordVersion(version)) {\n                                        parser.addWarning(\"msg.jsdoc.extraversion\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d versionInfo.token;\n                                continue retry;\n                            case DEFINE:\n                            case RETURN:\n                            case THIS:\n                            case TYPE:\n                            case TYPEDEF:\n                                skipEOLs();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                token \u003d next();\n                                Node typeNode \u003d parseAndRecordTypeNode(token, lineno, charno);\n                                if (annotation \u003d\u003d Annotation.THIS) {\n                                    typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                    if (typeNode !\u003d null \u0026\u0026 token !\u003d JsDocToken.LC) {\n                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                    }\n                                }\n                                type \u003d createJSTypeExpression(typeNode);\n                                if (type \u003d\u003d null) {\n                                } else {\n                                    switch(annotation) {\n                                        case DEFINE:\n                                            if (!isValidDefineType(typeNode)) {\n                                                parser.addWarning(\"msg.jsdoc.define.badtype\", lineno, charno);\n                                            } else if (!jsdocBuilder.recordDefineType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.define\", lineno, charno);\n                                            }\n                                            break;\n                                        case RETURN:\n                                            if (!jsdocBuilder.recordReturnType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                                break;\n                                            }\n                                            token \u003d current();\n                                            ExtractionInfo returnDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                            String returnDescription \u003d returnDescriptionInfo.string;\n                                            if (returnDescription.length() \u003e 0) {\n                                                jsdocBuilder.recordReturnDescription(returnDescription);\n                                            }\n                                            token \u003d returnDescriptionInfo.token;\n                                            continue retry;\n                                        case THIS:\n                                            if (!jsdocBuilder.recordThisType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                        case TYPE:\n                                            if (!jsdocBuilder.recordType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                        case TYPEDEF:\n                                            if (!jsdocBuilder.recordTypedef(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                    }\n                                    token \u003d eatTokensUntilEOL();\n                                }\n                                continue retry;\n                        }\n                    }\n                }\n                break;\n            case EOC:\n                if (hasParsedFileOverviewDocInfo()) {\n                    fileOverviewJSDocInfo \u003d retrieveAndResetParsedJSDocInfo();\n                }\n                return true;\n            case EOF:\n                jsdocBuilder.build(null);\n                parser.addWarning(\"msg.unexpected.eof\", stream.getLineno(), stream.getCharno());\n                return false;\n            case EOL:\n                if (state \u003d\u003d State.SEARCHING_NEWLINE) {\n                    state \u003d State.SEARCHING_ANNOTATION;\n                }\n                token \u003d next();\n                continue retry;\n            default:\n                if (token \u003d\u003d JsDocToken.STAR \u0026\u0026 state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                    token \u003d next();\n                    continue retry;\n                } else {\n                    state \u003d State.SEARCHING_NEWLINE;\n                    token \u003d eatTokensUntilEOL();\n                    continue retry;\n                }\n        }\n        token \u003d next();\n    }\n}",
      "path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
      "functionStartLine": 239,
      "functionName": "parse",
      "functionAnnotation": "",
      "functionDoc": "Parses a {@link JSDocInfo} object. This parsing method reads all tokens\nreturned by the {@link JsDocTokenStream#getJsDocToken()} method until the\n{@link JsDocToken#EOC} is returned.\n\n@return @code true} if JSDoc information was correctly parsed,\n    {@code false} otherwise\n",
      "diff": "@@ -1,448 +1,454 @@\n boolean parse() {\n     int lineno;\n     int charno;\n     JSTypeExpression type;\n     state \u003d State.SEARCHING_ANNOTATION;\n     JsDocToken token \u003d next();\n     ExtractionInfo blockInfo \u003d extractBlockComment(token);\n     token \u003d blockInfo.token;\n     if (blockInfo.string.length() \u003e 0) {\n         jsdocBuilder.recordBlockDescription(blockInfo.string);\n     }\n     retry: for (; ; ) {\n         switch(token) {\n             case ANNOTATION:\n                 if (state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                     state \u003d State.SEARCHING_NEWLINE;\n                     lineno \u003d stream.getLineno();\n                     charno \u003d stream.getCharno();\n                     String annotationName \u003d stream.getString();\n                     Annotation annotation \u003d annotationNames.get(annotationName);\n                     if (annotation \u003d\u003d null) {\n                         parser.addWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno());\n                     } else {\n                         jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n                         switch(annotation) {\n                             case AUTHOR:\n                                 ExtractionInfo authorInfo \u003d extractSingleLineBlock();\n                                 String author \u003d authorInfo.string;\n                                 if (author.length() \u003d\u003d 0) {\n                                     parser.addWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno());\n                                 } else {\n                                     jsdocBuilder.addAuthor(author);\n                                 }\n                                 token \u003d authorInfo.token;\n                                 continue retry;\n                             case CONSTANT:\n                                 if (!jsdocBuilder.recordConstancy()) {\n                                     parser.addWarning(\"msg.jsdoc.const\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case CONSTRUCTOR:\n                                 if (!jsdocBuilder.recordConstructor()) {\n                                     if (jsdocBuilder.isInterfaceRecorded()) {\n                                         parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                     } else {\n                                         parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case DEPRECATED:\n                                 if (!jsdocBuilder.recordDeprecated()) {\n                                     parser.addWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 ExtractionInfo reasonInfo \u003d extractMultilineTextualBlock(token);\n                                 String reason \u003d reasonInfo.string;\n                                 if (reason.length() \u003e 0) {\n                                     jsdocBuilder.recordDeprecationReason(reason);\n                                 }\n                                 token \u003d reasonInfo.token;\n                                 continue retry;\n                             case INTERFACE:\n                                 if (!jsdocBuilder.recordInterface()) {\n                                     if (jsdocBuilder.isConstructorRecorded()) {\n                                         parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                     } else {\n                                         parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case DESC:\n                                 if (jsdocBuilder.isDescriptionRecorded()) {\n                                     parser.addWarning(\"msg.jsdoc.desc.extra\", stream.getLineno(), stream.getCharno());\n                                     token \u003d eatTokensUntilEOL();\n                                     continue retry;\n                                 } else {\n                                     ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                     String description \u003d descriptionInfo.string;\n                                     jsdocBuilder.recordDescription(description);\n                                     token \u003d descriptionInfo.token;\n                                     continue retry;\n                                 }\n                             case FILE_OVERVIEW:\n                                 ExtractionInfo fileOverviewInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.TRIM);\n                                 String fileOverview \u003d fileOverviewInfo.string;\n                                 if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo !\u003d null) {\n                                     parser.addWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d fileOverviewInfo.token;\n                                 continue retry;\n                             case LICENSE:\n                             case PRESERVE:\n                                 ExtractionInfo preserveInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);\n                                 String preserve \u003d preserveInfo.string;\n                                 if (preserve.length() \u003e 0) {\n                                     if (fileLevelJsDocBuilder !\u003d null) {\n                                         fileLevelJsDocBuilder.append(preserve);\n                                     }\n                                 }\n                                 token \u003d preserveInfo.token;\n                                 continue retry;\n                             case ENUM:\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                 }\n                                 if (type \u003d\u003d null) {\n                                     type \u003d createJSTypeExpression(newStringNode(\"number\"));\n                                 }\n                                 if (!jsdocBuilder.recordEnumParameterType(type)) {\n                                     parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                 }\n                                 token \u003d eatTokensUntilEOL(token);\n                                 continue retry;\n                             case EXPORT:\n                                 if (!jsdocBuilder.recordExport()) {\n                                     parser.addWarning(\"msg.jsdoc.export\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n+                            case EXTERNS:\n+                                if (!jsdocBuilder.recordExterns()) {\n+                                    parser.addWarning(\"msg.jsdoc.externs\", stream.getLineno(), stream.getCharno());\n+                                }\n+                                token \u003d eatTokensUntilEOL();\n+                                continue retry;\n                             case EXTENDS:\n                             case IMPLEMENTS:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 boolean matchingRc \u003d false;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     token \u003d next();\n                                     matchingRc \u003d true;\n                                 }\n                                 if (token \u003d\u003d JsDocToken.STRING) {\n                                     Node typeNode \u003d parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);\n                                     lineno \u003d stream.getLineno();\n                                     charno \u003d stream.getCharno();\n                                     typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                     if (typeNode !\u003d null \u0026\u0026 !matchingRc) {\n                                         typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                     }\n                                     type \u003d createJSTypeExpression(typeNode);\n                                     if (annotation \u003d\u003d Annotation.EXTENDS) {\n                                         if (!jsdocBuilder.recordBaseType(type)) {\n                                             parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                         }\n                                     } else {\n                                         Preconditions.checkState(annotation \u003d\u003d Annotation.IMPLEMENTS);\n                                         if (!jsdocBuilder.recordImplementedInterface(type)) {\n                                             parser.addWarning(\"msg.jsdoc.implements.duplicate\", lineno, charno);\n                                         }\n                                     }\n                                     token \u003d next();\n                                     if (matchingRc) {\n                                         if (token !\u003d JsDocToken.RC) {\n                                             parser.addWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                         }\n                                     } else if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOF \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                         parser.addWarning(\"msg.end.annotation.expected\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 } else {\n                                     parser.addWarning(\"msg.no.type.name\", lineno, charno);\n                                 }\n                                 token \u003d eatTokensUntilEOL(token);\n                                 continue retry;\n                             case HIDDEN:\n                                 if (!jsdocBuilder.recordHiddenness()) {\n                                     parser.addWarning(\"msg.jsdoc.hidden\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_ALIAS:\n                                 if (!jsdocBuilder.recordNoAlias()) {\n                                     parser.addWarning(\"msg.jsdoc.noalias\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_TYPE_CHECK:\n                                 if (!jsdocBuilder.recordNoTypeCheck()) {\n                                     parser.addWarning(\"msg.jsdoc.nocheck\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NOT_IMPLEMENTED:\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case INHERIT_DOC:\n                             case OVERRIDE:\n                                 if (!jsdocBuilder.recordOverride()) {\n                                     parser.addWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case THROWS:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                     if (type \u003d\u003d null) {\n                                         token \u003d eatTokensUntilEOL();\n                                         continue retry;\n                                     }\n                                 }\n                                 token \u003d current();\n                                 jsdocBuilder.recordThrowType(type);\n                                 ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                 String description \u003d descriptionInfo.string;\n                                 if (description.length() \u003e 0) {\n                                     jsdocBuilder.recordThrowDescription(type, description);\n                                 }\n                                 token \u003d descriptionInfo.token;\n                                 continue retry;\n                             case PARAM:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordParamTypeNode(token));\n                                     if (type \u003d\u003d null) {\n                                         token \u003d eatTokensUntilEOL();\n                                         continue retry;\n                                     }\n                                     skipEOLs();\n                                     token \u003d next();\n                                     lineno \u003d stream.getLineno();\n                                     charno \u003d stream.getCharno();\n                                 }\n                                 String name \u003d null;\n                                 boolean isBracketedParam \u003d JsDocToken.LB \u003d\u003d token;\n                                 if (isBracketedParam) {\n                                     token \u003d next();\n                                 }\n                                 if (JsDocToken.STRING !\u003d token) {\n                                     parser.addWarning(\"msg.missing.variable.name\", lineno, charno);\n                                 } else {\n                                     name \u003d stream.getString();\n                                     if (isBracketedParam) {\n                                         token \u003d next();\n                                         if (JsDocToken.EQUALS \u003d\u003d token) {\n                                             token \u003d next();\n                                             if (JsDocToken.STRING \u003d\u003d token) {\n                                                 token \u003d next();\n                                             }\n                                         }\n                                         if (JsDocToken.RB !\u003d token) {\n                                             reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                                         } else if (type !\u003d null) {\n                                             type \u003d JSTypeExpression.makeOptionalArg(type);\n                                         }\n                                     }\n                                     if (name.indexOf(\u0027.\u0027) \u003e -1) {\n                                         name \u003d null;\n                                     } else if (!jsdocBuilder.recordParameter(name, type)) {\n                                         if (jsdocBuilder.hasParameter(name)) {\n                                             parser.addWarning(\"msg.dup.variable.name\", name, lineno, charno);\n                                         } else {\n                                             parser.addWarning(\"msg.jsdoc.incompat.type\", name, lineno, charno);\n                                         }\n                                     }\n                                 }\n                                 if (name \u003d\u003d null) {\n                                     token \u003d eatTokensUntilEOL(token);\n                                     continue retry;\n                                 }\n                                 jsdocBuilder.markName(name, lineno, charno);\n                                 ExtractionInfo paramDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                 String paramDescription \u003d paramDescriptionInfo.string;\n                                 if (paramDescription.length() \u003e 0) {\n                                     jsdocBuilder.recordParameterDescription(name, paramDescription);\n                                 }\n                                 token \u003d paramDescriptionInfo.token;\n                                 continue retry;\n                             case PRESERVE_TRY:\n                                 if (!jsdocBuilder.recordPreserveTry()) {\n                                     parser.addWarning(\"msg.jsdoc.preservertry\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PRIVATE:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                                     parser.addWarning(\"msg.jsdoc.visibility.private\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PROTECTED:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                                     parser.addWarning(\"msg.jsdoc.visibility.protected\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PUBLIC:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                                     parser.addWarning(\"msg.jsdoc.visibility.public\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_SHADOW:\n                                 if (!jsdocBuilder.recordNoShadow()) {\n                                     parser.addWarning(\"msg.jsdoc.noshadow\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_SIDE_EFFECTS:\n                                 if (!jsdocBuilder.recordNoSideEffects()) {\n                                     parser.addWarning(\"msg.jsdoc.nosideeffects\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case IMPLICIT_CAST:\n                                 if (!jsdocBuilder.recordImplicitCast()) {\n                                     parser.addWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case SEE:\n                                 ExtractionInfo referenceInfo \u003d extractSingleLineBlock();\n                                 String reference \u003d referenceInfo.string;\n                                 if (reference.length() \u003d\u003d 0) {\n                                     parser.addWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno());\n                                 } else {\n                                     jsdocBuilder.addReference(reference);\n                                 }\n                                 token \u003d referenceInfo.token;\n                                 continue retry;\n                             case SUPPRESS:\n                                 token \u003d parseSuppressTag(next());\n                                 continue retry;\n                             case TEMPLATE:\n                                 ExtractionInfo templateInfo \u003d extractSingleLineBlock();\n                                 String templateTypeName \u003d templateInfo.string;\n                                 if (templateTypeName.length() \u003d\u003d 0) {\n                                     parser.addWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno());\n                                 } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {\n                                     parser.addWarning(\"msg.jsdoc.template.at.most.once\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d templateInfo.token;\n                                 continue retry;\n                             case VERSION:\n                                 ExtractionInfo versionInfo \u003d extractSingleLineBlock();\n                                 String version \u003d versionInfo.string;\n                                 if (version.length() \u003d\u003d 0) {\n                                     parser.addWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno());\n                                 } else {\n                                     if (!jsdocBuilder.recordVersion(version)) {\n                                         parser.addWarning(\"msg.jsdoc.extraversion\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d versionInfo.token;\n                                 continue retry;\n                             case DEFINE:\n                             case RETURN:\n                             case THIS:\n                             case TYPE:\n                             case TYPEDEF:\n                                 skipEOLs();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 token \u003d next();\n                                 Node typeNode \u003d parseAndRecordTypeNode(token, lineno, charno);\n                                 if (annotation \u003d\u003d Annotation.THIS) {\n                                     typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                     if (typeNode !\u003d null \u0026\u0026 token !\u003d JsDocToken.LC) {\n                                         typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                     }\n                                 }\n                                 type \u003d createJSTypeExpression(typeNode);\n                                 if (type \u003d\u003d null) {\n                                 } else {\n                                     switch(annotation) {\n                                         case DEFINE:\n                                             if (!isValidDefineType(typeNode)) {\n                                                 parser.addWarning(\"msg.jsdoc.define.badtype\", lineno, charno);\n                                             } else if (!jsdocBuilder.recordDefineType(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.define\", lineno, charno);\n                                             }\n                                             break;\n                                         case RETURN:\n                                             if (!jsdocBuilder.recordReturnType(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                                 break;\n                                             }\n                                             token \u003d current();\n                                             ExtractionInfo returnDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                             String returnDescription \u003d returnDescriptionInfo.string;\n                                             if (returnDescription.length() \u003e 0) {\n                                                 jsdocBuilder.recordReturnDescription(returnDescription);\n                                             }\n                                             token \u003d returnDescriptionInfo.token;\n                                             continue retry;\n                                         case THIS:\n                                             if (!jsdocBuilder.recordThisType(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                         case TYPE:\n                                             if (!jsdocBuilder.recordType(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                         case TYPEDEF:\n                                             if (!jsdocBuilder.recordTypedef(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                     }\n                                     token \u003d eatTokensUntilEOL();\n                                 }\n                                 continue retry;\n                         }\n                     }\n                 }\n                 break;\n             case EOC:\n                 if (hasParsedFileOverviewDocInfo()) {\n                     fileOverviewJSDocInfo \u003d retrieveAndResetParsedJSDocInfo();\n                 }\n                 return true;\n             case EOF:\n                 jsdocBuilder.build(null);\n                 parser.addWarning(\"msg.unexpected.eof\", stream.getLineno(), stream.getCharno());\n                 return false;\n             case EOL:\n                 if (state \u003d\u003d State.SEARCHING_NEWLINE) {\n                     state \u003d State.SEARCHING_ANNOTATION;\n                 }\n                 token \u003d next();\n                 continue retry;\n             default:\n                 if (token \u003d\u003d JsDocToken.STAR \u0026\u0026 state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                     token \u003d next();\n                     continue retry;\n                 } else {\n                     state \u003d State.SEARCHING_NEWLINE;\n                     token \u003d eatTokensUntilEOL();\n                     continue retry;\n                 }\n         }\n         token \u003d next();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5af11d33f8b3f5403c9987104601f544cddb96c1": {
      "type": "Ybodychange",
      "commitMessage": "Better support for jsdoc toolkit annotations.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@14 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/19/09, 3:26 PM",
      "commitName": "5af11d33f8b3f5403c9987104601f544cddb96c1",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "commitDateOld": "11/16/09, 4:04 PM",
      "commitNameOld": "2acd6c1986e36bfdbae85c09eb83ac1940b86c73",
      "commitAuthorOld": "nicholas.j.santos@gmail.com",
      "daysBetweenCommits": 2.97,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "boolean parse() {\n    int lineno;\n    int charno;\n    JSTypeExpression type;\n    state \u003d State.SEARCHING_ANNOTATION;\n    JsDocToken token \u003d next();\n    ExtractionInfo blockInfo \u003d extractBlockComment(token);\n    token \u003d blockInfo.token;\n    if (blockInfo.string.length() \u003e 0) {\n        jsdocBuilder.recordBlockDescription(blockInfo.string);\n    }\n    retry: for (; ; ) {\n        switch(token) {\n            case ANNOTATION:\n                if (state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                    state \u003d State.SEARCHING_NEWLINE;\n                    lineno \u003d stream.getLineno();\n                    charno \u003d stream.getCharno();\n                    String annotationName \u003d stream.getString();\n                    Annotation annotation \u003d annotationNames.get(annotationName);\n                    if (annotation \u003d\u003d null) {\n                        parser.addWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno());\n                    } else {\n                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n                        switch(annotation) {\n                            case AUTHOR:\n                                ExtractionInfo authorInfo \u003d extractSingleLineBlock();\n                                String author \u003d authorInfo.string;\n                                if (author.length() \u003d\u003d 0) {\n                                    parser.addWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno());\n                                } else {\n                                    jsdocBuilder.addAuthor(author);\n                                }\n                                token \u003d authorInfo.token;\n                                continue retry;\n                            case CONSTANT:\n                                if (!jsdocBuilder.recordConstancy()) {\n                                    parser.addWarning(\"msg.jsdoc.const\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case CONSTRUCTOR:\n                                if (!jsdocBuilder.recordConstructor()) {\n                                    if (jsdocBuilder.isInterfaceRecorded()) {\n                                        parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case DEPRECATED:\n                                if (!jsdocBuilder.recordDeprecated()) {\n                                    parser.addWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno());\n                                }\n                                ExtractionInfo reasonInfo \u003d extractMultilineTextualBlock(token);\n                                String reason \u003d reasonInfo.string;\n                                if (reason.length() \u003e 0) {\n                                    jsdocBuilder.recordDeprecationReason(reason);\n                                }\n                                token \u003d reasonInfo.token;\n                                continue retry;\n                            case INTERFACE:\n                                if (!jsdocBuilder.recordInterface()) {\n                                    if (jsdocBuilder.isConstructorRecorded()) {\n                                        parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case DESC:\n                                if (jsdocBuilder.isDescriptionRecorded()) {\n                                    parser.addWarning(\"msg.jsdoc.desc.extra\", stream.getLineno(), stream.getCharno());\n                                    token \u003d eatTokensUntilEOL();\n                                    continue retry;\n                                } else {\n                                    ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                    String description \u003d descriptionInfo.string;\n                                    jsdocBuilder.recordDescription(description);\n                                    token \u003d descriptionInfo.token;\n                                    continue retry;\n                                }\n                            case FILE_OVERVIEW:\n                                ExtractionInfo fileOverviewInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.TRIM);\n                                String fileOverview \u003d fileOverviewInfo.string;\n                                if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo !\u003d null) {\n                                    parser.addWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d fileOverviewInfo.token;\n                                continue retry;\n                            case LICENSE:\n                            case PRESERVE:\n                                ExtractionInfo preserveInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);\n                                String preserve \u003d preserveInfo.string;\n                                if (preserve.length() \u003e 0) {\n                                    if (fileLevelJsDocBuilder !\u003d null) {\n                                        fileLevelJsDocBuilder.append(preserve);\n                                    }\n                                }\n                                token \u003d preserveInfo.token;\n                                continue retry;\n                            case ENUM:\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                }\n                                if (type \u003d\u003d null) {\n                                    type \u003d createJSTypeExpression(newStringNode(\"number\"));\n                                }\n                                if (!jsdocBuilder.recordEnumParameterType(type)) {\n                                    parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                }\n                                token \u003d eatTokensUntilEOL(token);\n                                continue retry;\n                            case EXPORT:\n                                if (!jsdocBuilder.recordExport()) {\n                                    parser.addWarning(\"msg.jsdoc.export\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case EXTENDS:\n                            case IMPLEMENTS:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                boolean matchingRc \u003d false;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    token \u003d next();\n                                    matchingRc \u003d true;\n                                }\n                                if (token \u003d\u003d JsDocToken.STRING) {\n                                    Node typeNode \u003d parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);\n                                    lineno \u003d stream.getLineno();\n                                    charno \u003d stream.getCharno();\n                                    typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                    if (typeNode !\u003d null \u0026\u0026 !matchingRc) {\n                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                    }\n                                    type \u003d createJSTypeExpression(typeNode);\n                                    if (annotation \u003d\u003d Annotation.EXTENDS) {\n                                        if (!jsdocBuilder.recordBaseType(type)) {\n                                            parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                        }\n                                    } else {\n                                        Preconditions.checkState(annotation \u003d\u003d Annotation.IMPLEMENTS);\n                                        if (!jsdocBuilder.recordImplementedInterface(type)) {\n                                            parser.addWarning(\"msg.jsdoc.implements.duplicate\", lineno, charno);\n                                        }\n                                    }\n                                    token \u003d next();\n                                    if (matchingRc) {\n                                        if (token !\u003d JsDocToken.RC) {\n                                            parser.addWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                        }\n                                    } else if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOF \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                        parser.addWarning(\"msg.end.annotation.expected\", stream.getLineno(), stream.getCharno());\n                                    }\n                                } else {\n                                    parser.addWarning(\"msg.no.type.name\", lineno, charno);\n                                }\n                                token \u003d eatTokensUntilEOL(token);\n                                continue retry;\n                            case HIDDEN:\n                                if (!jsdocBuilder.recordHiddenness()) {\n                                    parser.addWarning(\"msg.jsdoc.hidden\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_ALIAS:\n                                if (!jsdocBuilder.recordNoAlias()) {\n                                    parser.addWarning(\"msg.jsdoc.noalias\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_TYPE_CHECK:\n                                if (!jsdocBuilder.recordNoTypeCheck()) {\n                                    parser.addWarning(\"msg.jsdoc.nocheck\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NOT_IMPLEMENTED:\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case INHERIT_DOC:\n                            case OVERRIDE:\n                                if (!jsdocBuilder.recordOverride()) {\n                                    parser.addWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case THROWS:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                    if (type \u003d\u003d null) {\n                                        token \u003d eatTokensUntilEOL();\n                                        continue retry;\n                                    }\n                                }\n                                token \u003d current();\n                                jsdocBuilder.recordThrowType(type);\n                                ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                String description \u003d descriptionInfo.string;\n                                if (description.length() \u003e 0) {\n                                    jsdocBuilder.recordThrowDescription(type, description);\n                                }\n                                token \u003d descriptionInfo.token;\n                                continue retry;\n                            case PARAM:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordParamTypeNode(token));\n                                    if (type \u003d\u003d null) {\n                                        token \u003d eatTokensUntilEOL();\n                                        continue retry;\n                                    }\n                                    skipEOLs();\n                                    token \u003d next();\n                                    lineno \u003d stream.getLineno();\n                                    charno \u003d stream.getCharno();\n                                }\n                                String name \u003d null;\n                                boolean isBracketedParam \u003d JsDocToken.LB \u003d\u003d token;\n                                if (isBracketedParam) {\n                                    token \u003d next();\n                                }\n                                if (JsDocToken.STRING !\u003d token) {\n                                    parser.addWarning(\"msg.missing.variable.name\", lineno, charno);\n                                } else {\n                                    name \u003d stream.getString();\n                                    if (isBracketedParam) {\n                                        token \u003d next();\n                                        if (JsDocToken.EQUALS \u003d\u003d token) {\n                                            token \u003d next();\n                                            if (JsDocToken.STRING \u003d\u003d token) {\n                                                token \u003d next();\n                                            }\n                                        }\n                                        if (JsDocToken.RB !\u003d token) {\n                                            reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                                        } else if (type !\u003d null) {\n                                            type \u003d JSTypeExpression.makeOptionalArg(type);\n                                        }\n                                    }\n                                    if (name.indexOf(\u0027.\u0027) \u003e -1) {\n                                        name \u003d null;\n                                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                                        if (jsdocBuilder.hasParameter(name)) {\n                                            parser.addWarning(\"msg.dup.variable.name\", name, lineno, charno);\n                                        } else {\n                                            parser.addWarning(\"msg.jsdoc.incompat.type\", name, lineno, charno);\n                                        }\n                                    }\n                                }\n                                if (name \u003d\u003d null) {\n                                    token \u003d eatTokensUntilEOL(token);\n                                    continue retry;\n                                }\n                                jsdocBuilder.markName(name, lineno, charno);\n                                ExtractionInfo paramDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                String paramDescription \u003d paramDescriptionInfo.string;\n                                if (paramDescription.length() \u003e 0) {\n                                    jsdocBuilder.recordParameterDescription(name, paramDescription);\n                                }\n                                token \u003d paramDescriptionInfo.token;\n                                continue retry;\n                            case PRESERVE_TRY:\n                                if (!jsdocBuilder.recordPreserveTry()) {\n                                    parser.addWarning(\"msg.jsdoc.preservertry\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PRIVATE:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                                    parser.addWarning(\"msg.jsdoc.visibility.private\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PROTECTED:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                                    parser.addWarning(\"msg.jsdoc.visibility.protected\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PUBLIC:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                                    parser.addWarning(\"msg.jsdoc.visibility.public\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_SHADOW:\n                                if (!jsdocBuilder.recordNoShadow()) {\n                                    parser.addWarning(\"msg.jsdoc.noshadow\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_SIDE_EFFECTS:\n                                if (!jsdocBuilder.recordNoSideEffects()) {\n                                    parser.addWarning(\"msg.jsdoc.nosideeffects\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case IMPLICIT_CAST:\n                                if (!jsdocBuilder.recordImplicitCast()) {\n                                    parser.addWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case SEE:\n                                ExtractionInfo referenceInfo \u003d extractSingleLineBlock();\n                                String reference \u003d referenceInfo.string;\n                                if (reference.length() \u003d\u003d 0) {\n                                    parser.addWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno());\n                                } else {\n                                    jsdocBuilder.addReference(reference);\n                                }\n                                token \u003d referenceInfo.token;\n                                continue retry;\n                            case SUPPRESS:\n                                token \u003d parseSuppressTag(next());\n                                continue retry;\n                            case TEMPLATE:\n                                ExtractionInfo templateInfo \u003d extractSingleLineBlock();\n                                String templateTypeName \u003d templateInfo.string;\n                                if (templateTypeName.length() \u003d\u003d 0) {\n                                    parser.addWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno());\n                                } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {\n                                    parser.addWarning(\"msg.jsdoc.template.at.most.once\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d templateInfo.token;\n                                continue retry;\n                            case VERSION:\n                                ExtractionInfo versionInfo \u003d extractSingleLineBlock();\n                                String version \u003d versionInfo.string;\n                                if (version.length() \u003d\u003d 0) {\n                                    parser.addWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno());\n                                } else {\n                                    if (!jsdocBuilder.recordVersion(version)) {\n                                        parser.addWarning(\"msg.jsdoc.extraversion\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d versionInfo.token;\n                                continue retry;\n                            case DEFINE:\n                            case RETURN:\n                            case THIS:\n                            case TYPE:\n                            case TYPEDEF:\n                                skipEOLs();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                token \u003d next();\n                                Node typeNode \u003d parseAndRecordTypeNode(token, lineno, charno);\n                                if (annotation \u003d\u003d Annotation.THIS) {\n                                    typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                    if (typeNode !\u003d null \u0026\u0026 token !\u003d JsDocToken.LC) {\n                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                    }\n                                }\n                                type \u003d createJSTypeExpression(typeNode);\n                                if (type \u003d\u003d null) {\n                                } else {\n                                    switch(annotation) {\n                                        case DEFINE:\n                                            if (!isValidDefineType(typeNode)) {\n                                                parser.addWarning(\"msg.jsdoc.define.badtype\", lineno, charno);\n                                            } else if (!jsdocBuilder.recordDefineType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.define\", lineno, charno);\n                                            }\n                                            break;\n                                        case RETURN:\n                                            if (!jsdocBuilder.recordReturnType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                                break;\n                                            }\n                                            token \u003d current();\n                                            ExtractionInfo returnDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                            String returnDescription \u003d returnDescriptionInfo.string;\n                                            if (returnDescription.length() \u003e 0) {\n                                                jsdocBuilder.recordReturnDescription(returnDescription);\n                                            }\n                                            token \u003d returnDescriptionInfo.token;\n                                            continue retry;\n                                        case THIS:\n                                            if (!jsdocBuilder.recordThisType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                        case TYPE:\n                                            if (!jsdocBuilder.recordType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                        case TYPEDEF:\n                                            if (!jsdocBuilder.recordTypedef(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                    }\n                                    token \u003d eatTokensUntilEOL();\n                                }\n                                continue retry;\n                        }\n                    }\n                }\n                break;\n            case EOC:\n                if (hasParsedFileOverviewDocInfo()) {\n                    fileOverviewJSDocInfo \u003d retrieveAndResetParsedJSDocInfo();\n                }\n                return true;\n            case EOF:\n                jsdocBuilder.build(null);\n                parser.addWarning(\"msg.unexpected.eof\", stream.getLineno(), stream.getCharno());\n                return false;\n            case EOL:\n                if (state \u003d\u003d State.SEARCHING_NEWLINE) {\n                    state \u003d State.SEARCHING_ANNOTATION;\n                }\n                token \u003d next();\n                continue retry;\n            default:\n                if (token \u003d\u003d JsDocToken.STAR \u0026\u0026 state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                    token \u003d next();\n                    continue retry;\n                } else {\n                    state \u003d State.SEARCHING_NEWLINE;\n                    token \u003d eatTokensUntilEOL();\n                    continue retry;\n                }\n        }\n        token \u003d next();\n    }\n}",
      "path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
      "functionStartLine": 237,
      "functionName": "parse",
      "functionAnnotation": "",
      "functionDoc": "Parses a {@link JSDocInfo} object. This parsing method reads all tokens\nreturned by the {@link JsDocTokenStream#getJsDocToken()} method until the\n{@link JsDocToken#EOC} is returned.\n\n@return @code true} if JSDoc information was correctly parsed,\n    {@code false} otherwise\n",
      "diff": "@@ -1,440 +1,448 @@\n boolean parse() {\n     int lineno;\n     int charno;\n     JSTypeExpression type;\n     state \u003d State.SEARCHING_ANNOTATION;\n     JsDocToken token \u003d next();\n     ExtractionInfo blockInfo \u003d extractBlockComment(token);\n     token \u003d blockInfo.token;\n     if (blockInfo.string.length() \u003e 0) {\n         jsdocBuilder.recordBlockDescription(blockInfo.string);\n     }\n     retry: for (; ; ) {\n         switch(token) {\n             case ANNOTATION:\n                 if (state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                     state \u003d State.SEARCHING_NEWLINE;\n                     lineno \u003d stream.getLineno();\n                     charno \u003d stream.getCharno();\n                     String annotationName \u003d stream.getString();\n                     Annotation annotation \u003d annotationNames.get(annotationName);\n                     if (annotation \u003d\u003d null) {\n                         parser.addWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno());\n                     } else {\n                         jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n                         switch(annotation) {\n                             case AUTHOR:\n                                 ExtractionInfo authorInfo \u003d extractSingleLineBlock();\n                                 String author \u003d authorInfo.string;\n                                 if (author.length() \u003d\u003d 0) {\n                                     parser.addWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno());\n                                 } else {\n                                     jsdocBuilder.addAuthor(author);\n                                 }\n                                 token \u003d authorInfo.token;\n                                 continue retry;\n                             case CONSTANT:\n                                 if (!jsdocBuilder.recordConstancy()) {\n                                     parser.addWarning(\"msg.jsdoc.const\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case CONSTRUCTOR:\n                                 if (!jsdocBuilder.recordConstructor()) {\n                                     if (jsdocBuilder.isInterfaceRecorded()) {\n                                         parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                     } else {\n                                         parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case DEPRECATED:\n                                 if (!jsdocBuilder.recordDeprecated()) {\n                                     parser.addWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 ExtractionInfo reasonInfo \u003d extractMultilineTextualBlock(token);\n                                 String reason \u003d reasonInfo.string;\n                                 if (reason.length() \u003e 0) {\n                                     jsdocBuilder.recordDeprecationReason(reason);\n                                 }\n                                 token \u003d reasonInfo.token;\n                                 continue retry;\n                             case INTERFACE:\n                                 if (!jsdocBuilder.recordInterface()) {\n                                     if (jsdocBuilder.isConstructorRecorded()) {\n                                         parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                     } else {\n                                         parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case DESC:\n                                 if (jsdocBuilder.isDescriptionRecorded()) {\n                                     parser.addWarning(\"msg.jsdoc.desc.extra\", stream.getLineno(), stream.getCharno());\n                                     token \u003d eatTokensUntilEOL();\n                                     continue retry;\n                                 } else {\n                                     ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                     String description \u003d descriptionInfo.string;\n                                     jsdocBuilder.recordDescription(description);\n                                     token \u003d descriptionInfo.token;\n                                     continue retry;\n                                 }\n                             case FILE_OVERVIEW:\n                                 ExtractionInfo fileOverviewInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.TRIM);\n                                 String fileOverview \u003d fileOverviewInfo.string;\n                                 if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo !\u003d null) {\n                                     parser.addWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d fileOverviewInfo.token;\n                                 continue retry;\n                             case LICENSE:\n                             case PRESERVE:\n                                 ExtractionInfo preserveInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);\n                                 String preserve \u003d preserveInfo.string;\n                                 if (preserve.length() \u003e 0) {\n                                     if (fileLevelJsDocBuilder !\u003d null) {\n                                         fileLevelJsDocBuilder.append(preserve);\n                                     }\n                                 }\n                                 token \u003d preserveInfo.token;\n                                 continue retry;\n                             case ENUM:\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                 }\n                                 if (type \u003d\u003d null) {\n                                     type \u003d createJSTypeExpression(newStringNode(\"number\"));\n                                 }\n                                 if (!jsdocBuilder.recordEnumParameterType(type)) {\n                                     parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                 }\n                                 token \u003d eatTokensUntilEOL(token);\n                                 continue retry;\n                             case EXPORT:\n                                 if (!jsdocBuilder.recordExport()) {\n                                     parser.addWarning(\"msg.jsdoc.export\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case EXTENDS:\n                             case IMPLEMENTS:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 boolean matchingRc \u003d false;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     token \u003d next();\n                                     matchingRc \u003d true;\n                                 }\n                                 if (token \u003d\u003d JsDocToken.STRING) {\n                                     Node typeNode \u003d parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);\n                                     lineno \u003d stream.getLineno();\n                                     charno \u003d stream.getCharno();\n                                     typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                     if (typeNode !\u003d null \u0026\u0026 !matchingRc) {\n                                         typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                     }\n                                     type \u003d createJSTypeExpression(typeNode);\n                                     if (annotation \u003d\u003d Annotation.EXTENDS) {\n                                         if (!jsdocBuilder.recordBaseType(type)) {\n                                             parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                         }\n                                     } else {\n                                         Preconditions.checkState(annotation \u003d\u003d Annotation.IMPLEMENTS);\n                                         if (!jsdocBuilder.recordImplementedInterface(type)) {\n                                             parser.addWarning(\"msg.jsdoc.implements.duplicate\", lineno, charno);\n                                         }\n                                     }\n                                     token \u003d next();\n                                     if (matchingRc) {\n                                         if (token !\u003d JsDocToken.RC) {\n                                             parser.addWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                         }\n                                     } else if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOF \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                         parser.addWarning(\"msg.end.annotation.expected\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 } else {\n                                     parser.addWarning(\"msg.no.type.name\", lineno, charno);\n                                 }\n                                 token \u003d eatTokensUntilEOL(token);\n                                 continue retry;\n                             case HIDDEN:\n                                 if (!jsdocBuilder.recordHiddenness()) {\n                                     parser.addWarning(\"msg.jsdoc.hidden\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_ALIAS:\n                                 if (!jsdocBuilder.recordNoAlias()) {\n                                     parser.addWarning(\"msg.jsdoc.noalias\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_TYPE_CHECK:\n                                 if (!jsdocBuilder.recordNoTypeCheck()) {\n                                     parser.addWarning(\"msg.jsdoc.nocheck\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NOT_IMPLEMENTED:\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case INHERIT_DOC:\n                             case OVERRIDE:\n                                 if (!jsdocBuilder.recordOverride()) {\n                                     parser.addWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case THROWS:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                     if (type \u003d\u003d null) {\n                                         token \u003d eatTokensUntilEOL();\n                                         continue retry;\n                                     }\n                                 }\n                                 token \u003d current();\n                                 jsdocBuilder.recordThrowType(type);\n                                 ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                 String description \u003d descriptionInfo.string;\n                                 if (description.length() \u003e 0) {\n                                     jsdocBuilder.recordThrowDescription(type, description);\n                                 }\n                                 token \u003d descriptionInfo.token;\n                                 continue retry;\n                             case PARAM:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordParamTypeNode(token));\n                                     if (type \u003d\u003d null) {\n                                         token \u003d eatTokensUntilEOL();\n                                         continue retry;\n                                     }\n                                     skipEOLs();\n                                     token \u003d next();\n                                     lineno \u003d stream.getLineno();\n                                     charno \u003d stream.getCharno();\n                                 }\n                                 String name \u003d null;\n                                 boolean isBracketedParam \u003d JsDocToken.LB \u003d\u003d token;\n                                 if (isBracketedParam) {\n                                     token \u003d next();\n                                 }\n                                 if (JsDocToken.STRING !\u003d token) {\n                                     parser.addWarning(\"msg.missing.variable.name\", lineno, charno);\n                                 } else {\n                                     name \u003d stream.getString();\n                                     if (isBracketedParam) {\n                                         token \u003d next();\n+                                        if (JsDocToken.EQUALS \u003d\u003d token) {\n+                                            token \u003d next();\n+                                            if (JsDocToken.STRING \u003d\u003d token) {\n+                                                token \u003d next();\n+                                            }\n+                                        }\n                                         if (JsDocToken.RB !\u003d token) {\n                                             reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                                         } else if (type !\u003d null) {\n                                             type \u003d JSTypeExpression.makeOptionalArg(type);\n                                         }\n                                     }\n-                                    if (!jsdocBuilder.recordParameter(name, type)) {\n+                                    if (name.indexOf(\u0027.\u0027) \u003e -1) {\n+                                        name \u003d null;\n+                                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                                         if (jsdocBuilder.hasParameter(name)) {\n                                             parser.addWarning(\"msg.dup.variable.name\", name, lineno, charno);\n                                         } else {\n                                             parser.addWarning(\"msg.jsdoc.incompat.type\", name, lineno, charno);\n                                         }\n                                     }\n                                 }\n                                 if (name \u003d\u003d null) {\n                                     token \u003d eatTokensUntilEOL(token);\n                                     continue retry;\n                                 }\n                                 jsdocBuilder.markName(name, lineno, charno);\n                                 ExtractionInfo paramDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                 String paramDescription \u003d paramDescriptionInfo.string;\n                                 if (paramDescription.length() \u003e 0) {\n                                     jsdocBuilder.recordParameterDescription(name, paramDescription);\n                                 }\n                                 token \u003d paramDescriptionInfo.token;\n                                 continue retry;\n                             case PRESERVE_TRY:\n                                 if (!jsdocBuilder.recordPreserveTry()) {\n                                     parser.addWarning(\"msg.jsdoc.preservertry\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PRIVATE:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                                     parser.addWarning(\"msg.jsdoc.visibility.private\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PROTECTED:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                                     parser.addWarning(\"msg.jsdoc.visibility.protected\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PUBLIC:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                                     parser.addWarning(\"msg.jsdoc.visibility.public\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_SHADOW:\n                                 if (!jsdocBuilder.recordNoShadow()) {\n                                     parser.addWarning(\"msg.jsdoc.noshadow\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_SIDE_EFFECTS:\n                                 if (!jsdocBuilder.recordNoSideEffects()) {\n                                     parser.addWarning(\"msg.jsdoc.nosideeffects\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case IMPLICIT_CAST:\n                                 if (!jsdocBuilder.recordImplicitCast()) {\n                                     parser.addWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case SEE:\n                                 ExtractionInfo referenceInfo \u003d extractSingleLineBlock();\n                                 String reference \u003d referenceInfo.string;\n                                 if (reference.length() \u003d\u003d 0) {\n                                     parser.addWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno());\n                                 } else {\n                                     jsdocBuilder.addReference(reference);\n                                 }\n                                 token \u003d referenceInfo.token;\n                                 continue retry;\n                             case SUPPRESS:\n                                 token \u003d parseSuppressTag(next());\n                                 continue retry;\n                             case TEMPLATE:\n                                 ExtractionInfo templateInfo \u003d extractSingleLineBlock();\n                                 String templateTypeName \u003d templateInfo.string;\n                                 if (templateTypeName.length() \u003d\u003d 0) {\n                                     parser.addWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno());\n                                 } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {\n                                     parser.addWarning(\"msg.jsdoc.template.at.most.once\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d templateInfo.token;\n                                 continue retry;\n                             case VERSION:\n                                 ExtractionInfo versionInfo \u003d extractSingleLineBlock();\n                                 String version \u003d versionInfo.string;\n                                 if (version.length() \u003d\u003d 0) {\n                                     parser.addWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno());\n                                 } else {\n                                     if (!jsdocBuilder.recordVersion(version)) {\n                                         parser.addWarning(\"msg.jsdoc.extraversion\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d versionInfo.token;\n                                 continue retry;\n                             case DEFINE:\n                             case RETURN:\n                             case THIS:\n                             case TYPE:\n                             case TYPEDEF:\n                                 skipEOLs();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 token \u003d next();\n                                 Node typeNode \u003d parseAndRecordTypeNode(token, lineno, charno);\n                                 if (annotation \u003d\u003d Annotation.THIS) {\n                                     typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                     if (typeNode !\u003d null \u0026\u0026 token !\u003d JsDocToken.LC) {\n                                         typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                     }\n                                 }\n                                 type \u003d createJSTypeExpression(typeNode);\n                                 if (type \u003d\u003d null) {\n                                 } else {\n                                     switch(annotation) {\n                                         case DEFINE:\n                                             if (!isValidDefineType(typeNode)) {\n                                                 parser.addWarning(\"msg.jsdoc.define.badtype\", lineno, charno);\n                                             } else if (!jsdocBuilder.recordDefineType(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.define\", lineno, charno);\n                                             }\n                                             break;\n                                         case RETURN:\n                                             if (!jsdocBuilder.recordReturnType(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                                 break;\n                                             }\n                                             token \u003d current();\n                                             ExtractionInfo returnDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                             String returnDescription \u003d returnDescriptionInfo.string;\n                                             if (returnDescription.length() \u003e 0) {\n                                                 jsdocBuilder.recordReturnDescription(returnDescription);\n                                             }\n                                             token \u003d returnDescriptionInfo.token;\n                                             continue retry;\n                                         case THIS:\n                                             if (!jsdocBuilder.recordThisType(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                         case TYPE:\n                                             if (!jsdocBuilder.recordType(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                         case TYPEDEF:\n                                             if (!jsdocBuilder.recordTypedef(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                     }\n                                     token \u003d eatTokensUntilEOL();\n                                 }\n                                 continue retry;\n                         }\n                     }\n                 }\n                 break;\n             case EOC:\n                 if (hasParsedFileOverviewDocInfo()) {\n                     fileOverviewJSDocInfo \u003d retrieveAndResetParsedJSDocInfo();\n                 }\n                 return true;\n             case EOF:\n                 jsdocBuilder.build(null);\n                 parser.addWarning(\"msg.unexpected.eof\", stream.getLineno(), stream.getCharno());\n                 return false;\n             case EOL:\n                 if (state \u003d\u003d State.SEARCHING_NEWLINE) {\n                     state \u003d State.SEARCHING_ANNOTATION;\n                 }\n                 token \u003d next();\n                 continue retry;\n             default:\n                 if (token \u003d\u003d JsDocToken.STAR \u0026\u0026 state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                     token \u003d next();\n                     continue retry;\n                 } else {\n                     state \u003d State.SEARCHING_NEWLINE;\n                     token \u003d eatTokensUntilEOL();\n                     continue retry;\n                 }\n         }\n         token \u003d next();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2acd6c1986e36bfdbae85c09eb83ac1940b86c73": {
      "type": "Ybodychange",
      "commitMessage": "Fix if-folding compiler crash (issue 43)\nFix property-collapsing compiler crash (issue 34)\nFix labeled VAR compiler crash (issue 41)\nMake [paramName] syntax denote optionality (issue #26)\nBetter function inlining.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@11 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/16/09, 4:04 PM",
      "commitName": "2acd6c1986e36bfdbae85c09eb83ac1940b86c73",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "commitDateOld": "11/13/09, 11:38 AM",
      "commitNameOld": "efd3c178e471df6a689c1a50fbd7c404e778bfaa",
      "commitAuthorOld": "nicholas.j.santos@gmail.com",
      "daysBetweenCommits": 3.18,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "boolean parse() {\n    int lineno;\n    int charno;\n    JSTypeExpression type;\n    state \u003d State.SEARCHING_ANNOTATION;\n    JsDocToken token \u003d next();\n    ExtractionInfo blockInfo \u003d extractBlockComment(token);\n    token \u003d blockInfo.token;\n    if (blockInfo.string.length() \u003e 0) {\n        jsdocBuilder.recordBlockDescription(blockInfo.string);\n    }\n    retry: for (; ; ) {\n        switch(token) {\n            case ANNOTATION:\n                if (state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                    state \u003d State.SEARCHING_NEWLINE;\n                    lineno \u003d stream.getLineno();\n                    charno \u003d stream.getCharno();\n                    String annotationName \u003d stream.getString();\n                    Annotation annotation \u003d annotationNames.get(annotationName);\n                    if (annotation \u003d\u003d null) {\n                        parser.addWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno());\n                    } else {\n                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n                        switch(annotation) {\n                            case AUTHOR:\n                                ExtractionInfo authorInfo \u003d extractSingleLineBlock();\n                                String author \u003d authorInfo.string;\n                                if (author.length() \u003d\u003d 0) {\n                                    parser.addWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno());\n                                } else {\n                                    jsdocBuilder.addAuthor(author);\n                                }\n                                token \u003d authorInfo.token;\n                                continue retry;\n                            case CONSTANT:\n                                if (!jsdocBuilder.recordConstancy()) {\n                                    parser.addWarning(\"msg.jsdoc.const\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case CONSTRUCTOR:\n                                if (!jsdocBuilder.recordConstructor()) {\n                                    if (jsdocBuilder.isInterfaceRecorded()) {\n                                        parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case DEPRECATED:\n                                if (!jsdocBuilder.recordDeprecated()) {\n                                    parser.addWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno());\n                                }\n                                ExtractionInfo reasonInfo \u003d extractMultilineTextualBlock(token);\n                                String reason \u003d reasonInfo.string;\n                                if (reason.length() \u003e 0) {\n                                    jsdocBuilder.recordDeprecationReason(reason);\n                                }\n                                token \u003d reasonInfo.token;\n                                continue retry;\n                            case INTERFACE:\n                                if (!jsdocBuilder.recordInterface()) {\n                                    if (jsdocBuilder.isConstructorRecorded()) {\n                                        parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case DESC:\n                                if (jsdocBuilder.isDescriptionRecorded()) {\n                                    parser.addWarning(\"msg.jsdoc.desc.extra\", stream.getLineno(), stream.getCharno());\n                                    token \u003d eatTokensUntilEOL();\n                                    continue retry;\n                                } else {\n                                    ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                    String description \u003d descriptionInfo.string;\n                                    jsdocBuilder.recordDescription(description);\n                                    token \u003d descriptionInfo.token;\n                                    continue retry;\n                                }\n                            case FILE_OVERVIEW:\n                                ExtractionInfo fileOverviewInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.TRIM);\n                                String fileOverview \u003d fileOverviewInfo.string;\n                                if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo !\u003d null) {\n                                    parser.addWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d fileOverviewInfo.token;\n                                continue retry;\n                            case LICENSE:\n                            case PRESERVE:\n                                ExtractionInfo preserveInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);\n                                String preserve \u003d preserveInfo.string;\n                                if (preserve.length() \u003e 0) {\n                                    if (fileLevelJsDocBuilder !\u003d null) {\n                                        fileLevelJsDocBuilder.append(preserve);\n                                    }\n                                }\n                                token \u003d preserveInfo.token;\n                                continue retry;\n                            case ENUM:\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                }\n                                if (type \u003d\u003d null) {\n                                    type \u003d createJSTypeExpression(newStringNode(\"number\"));\n                                }\n                                if (!jsdocBuilder.recordEnumParameterType(type)) {\n                                    parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                }\n                                token \u003d eatTokensUntilEOL(token);\n                                continue retry;\n                            case EXPORT:\n                                if (!jsdocBuilder.recordExport()) {\n                                    parser.addWarning(\"msg.jsdoc.export\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case EXTENDS:\n                            case IMPLEMENTS:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                boolean matchingRc \u003d false;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    token \u003d next();\n                                    matchingRc \u003d true;\n                                }\n                                if (token \u003d\u003d JsDocToken.STRING) {\n                                    Node typeNode \u003d parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);\n                                    lineno \u003d stream.getLineno();\n                                    charno \u003d stream.getCharno();\n                                    typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                    if (typeNode !\u003d null \u0026\u0026 !matchingRc) {\n                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                    }\n                                    type \u003d createJSTypeExpression(typeNode);\n                                    if (annotation \u003d\u003d Annotation.EXTENDS) {\n                                        if (!jsdocBuilder.recordBaseType(type)) {\n                                            parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                        }\n                                    } else {\n                                        Preconditions.checkState(annotation \u003d\u003d Annotation.IMPLEMENTS);\n                                        if (!jsdocBuilder.recordImplementedInterface(type)) {\n                                            parser.addWarning(\"msg.jsdoc.implements.duplicate\", lineno, charno);\n                                        }\n                                    }\n                                    token \u003d next();\n                                    if (matchingRc) {\n                                        if (token !\u003d JsDocToken.RC) {\n                                            parser.addWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                        }\n                                    } else if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOF \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                        parser.addWarning(\"msg.end.annotation.expected\", stream.getLineno(), stream.getCharno());\n                                    }\n                                } else {\n                                    parser.addWarning(\"msg.no.type.name\", lineno, charno);\n                                }\n                                token \u003d eatTokensUntilEOL(token);\n                                continue retry;\n                            case HIDDEN:\n                                if (!jsdocBuilder.recordHiddenness()) {\n                                    parser.addWarning(\"msg.jsdoc.hidden\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_ALIAS:\n                                if (!jsdocBuilder.recordNoAlias()) {\n                                    parser.addWarning(\"msg.jsdoc.noalias\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_TYPE_CHECK:\n                                if (!jsdocBuilder.recordNoTypeCheck()) {\n                                    parser.addWarning(\"msg.jsdoc.nocheck\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NOT_IMPLEMENTED:\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case INHERIT_DOC:\n                            case OVERRIDE:\n                                if (!jsdocBuilder.recordOverride()) {\n                                    parser.addWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case THROWS:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                    if (type \u003d\u003d null) {\n                                        token \u003d eatTokensUntilEOL();\n                                        continue retry;\n                                    }\n                                }\n                                token \u003d current();\n                                jsdocBuilder.recordThrowType(type);\n                                ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                String description \u003d descriptionInfo.string;\n                                if (description.length() \u003e 0) {\n                                    jsdocBuilder.recordThrowDescription(type, description);\n                                }\n                                token \u003d descriptionInfo.token;\n                                continue retry;\n                            case PARAM:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordParamTypeNode(token));\n                                    if (type \u003d\u003d null) {\n                                        token \u003d eatTokensUntilEOL();\n                                        continue retry;\n                                    }\n                                    skipEOLs();\n                                    token \u003d next();\n                                    lineno \u003d stream.getLineno();\n                                    charno \u003d stream.getCharno();\n                                }\n                                String name \u003d null;\n                                boolean isBracketedParam \u003d JsDocToken.LB \u003d\u003d token;\n                                if (isBracketedParam) {\n                                    token \u003d next();\n                                }\n                                if (JsDocToken.STRING !\u003d token) {\n                                    parser.addWarning(\"msg.missing.variable.name\", lineno, charno);\n                                } else {\n                                    name \u003d stream.getString();\n                                    if (isBracketedParam) {\n                                        token \u003d next();\n                                        if (JsDocToken.RB !\u003d token) {\n                                            reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                                        } else if (type !\u003d null) {\n                                            type \u003d JSTypeExpression.makeOptionalArg(type);\n                                        }\n                                    }\n                                    if (!jsdocBuilder.recordParameter(name, type)) {\n                                        if (jsdocBuilder.hasParameter(name)) {\n                                            parser.addWarning(\"msg.dup.variable.name\", name, lineno, charno);\n                                        } else {\n                                            parser.addWarning(\"msg.jsdoc.incompat.type\", name, lineno, charno);\n                                        }\n                                    }\n                                }\n                                if (name \u003d\u003d null) {\n                                    token \u003d eatTokensUntilEOL(token);\n                                    continue retry;\n                                }\n                                jsdocBuilder.markName(name, lineno, charno);\n                                ExtractionInfo paramDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                String paramDescription \u003d paramDescriptionInfo.string;\n                                if (paramDescription.length() \u003e 0) {\n                                    jsdocBuilder.recordParameterDescription(name, paramDescription);\n                                }\n                                token \u003d paramDescriptionInfo.token;\n                                continue retry;\n                            case PRESERVE_TRY:\n                                if (!jsdocBuilder.recordPreserveTry()) {\n                                    parser.addWarning(\"msg.jsdoc.preservertry\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PRIVATE:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                                    parser.addWarning(\"msg.jsdoc.visibility.private\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PROTECTED:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                                    parser.addWarning(\"msg.jsdoc.visibility.protected\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PUBLIC:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                                    parser.addWarning(\"msg.jsdoc.visibility.public\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_SHADOW:\n                                if (!jsdocBuilder.recordNoShadow()) {\n                                    parser.addWarning(\"msg.jsdoc.noshadow\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_SIDE_EFFECTS:\n                                if (!jsdocBuilder.recordNoSideEffects()) {\n                                    parser.addWarning(\"msg.jsdoc.nosideeffects\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case IMPLICIT_CAST:\n                                if (!jsdocBuilder.recordImplicitCast()) {\n                                    parser.addWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case SEE:\n                                ExtractionInfo referenceInfo \u003d extractSingleLineBlock();\n                                String reference \u003d referenceInfo.string;\n                                if (reference.length() \u003d\u003d 0) {\n                                    parser.addWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno());\n                                } else {\n                                    jsdocBuilder.addReference(reference);\n                                }\n                                token \u003d referenceInfo.token;\n                                continue retry;\n                            case SUPPRESS:\n                                token \u003d parseSuppressTag(next());\n                                continue retry;\n                            case TEMPLATE:\n                                ExtractionInfo templateInfo \u003d extractSingleLineBlock();\n                                String templateTypeName \u003d templateInfo.string;\n                                if (templateTypeName.length() \u003d\u003d 0) {\n                                    parser.addWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno());\n                                } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {\n                                    parser.addWarning(\"msg.jsdoc.template.at.most.once\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d templateInfo.token;\n                                continue retry;\n                            case VERSION:\n                                ExtractionInfo versionInfo \u003d extractSingleLineBlock();\n                                String version \u003d versionInfo.string;\n                                if (version.length() \u003d\u003d 0) {\n                                    parser.addWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno());\n                                } else {\n                                    if (!jsdocBuilder.recordVersion(version)) {\n                                        parser.addWarning(\"msg.jsdoc.extraversion\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d versionInfo.token;\n                                continue retry;\n                            case DEFINE:\n                            case RETURN:\n                            case THIS:\n                            case TYPE:\n                            case TYPEDEF:\n                                skipEOLs();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                token \u003d next();\n                                Node typeNode \u003d parseAndRecordTypeNode(token, lineno, charno);\n                                if (annotation \u003d\u003d Annotation.THIS) {\n                                    typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                    if (typeNode !\u003d null \u0026\u0026 token !\u003d JsDocToken.LC) {\n                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                    }\n                                }\n                                type \u003d createJSTypeExpression(typeNode);\n                                if (type \u003d\u003d null) {\n                                } else {\n                                    switch(annotation) {\n                                        case DEFINE:\n                                            if (!isValidDefineType(typeNode)) {\n                                                parser.addWarning(\"msg.jsdoc.define.badtype\", lineno, charno);\n                                            } else if (!jsdocBuilder.recordDefineType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.define\", lineno, charno);\n                                            }\n                                            break;\n                                        case RETURN:\n                                            if (!jsdocBuilder.recordReturnType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                                break;\n                                            }\n                                            token \u003d current();\n                                            ExtractionInfo returnDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                            String returnDescription \u003d returnDescriptionInfo.string;\n                                            if (returnDescription.length() \u003e 0) {\n                                                jsdocBuilder.recordReturnDescription(returnDescription);\n                                            }\n                                            token \u003d returnDescriptionInfo.token;\n                                            continue retry;\n                                        case THIS:\n                                            if (!jsdocBuilder.recordThisType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                        case TYPE:\n                                            if (!jsdocBuilder.recordType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                        case TYPEDEF:\n                                            if (!jsdocBuilder.recordTypedef(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                    }\n                                    token \u003d eatTokensUntilEOL();\n                                }\n                                continue retry;\n                        }\n                    }\n                }\n                break;\n            case EOC:\n                if (hasParsedFileOverviewDocInfo()) {\n                    fileOverviewJSDocInfo \u003d retrieveAndResetParsedJSDocInfo();\n                }\n                return true;\n            case EOF:\n                jsdocBuilder.build(null);\n                parser.addWarning(\"msg.unexpected.eof\", stream.getLineno(), stream.getCharno());\n                return false;\n            case EOL:\n                if (state \u003d\u003d State.SEARCHING_NEWLINE) {\n                    state \u003d State.SEARCHING_ANNOTATION;\n                }\n                token \u003d next();\n                continue retry;\n            default:\n                if (token \u003d\u003d JsDocToken.STAR \u0026\u0026 state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                    token \u003d next();\n                    continue retry;\n                } else {\n                    state \u003d State.SEARCHING_NEWLINE;\n                    token \u003d eatTokensUntilEOL();\n                    continue retry;\n                }\n        }\n        token \u003d next();\n    }\n}",
      "path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
      "functionStartLine": 237,
      "functionName": "parse",
      "functionAnnotation": "",
      "functionDoc": "Parses a {@link JSDocInfo} object. This parsing method reads all tokens\nreturned by the {@link JsDocTokenStream#getJsDocToken()} method until the\n{@link JsDocToken#EOC} is returned.\n\n@return @code true} if JSDoc information was correctly parsed,\n    {@code false} otherwise\n",
      "diff": "@@ -1,438 +1,440 @@\n boolean parse() {\n     int lineno;\n     int charno;\n     JSTypeExpression type;\n     state \u003d State.SEARCHING_ANNOTATION;\n     JsDocToken token \u003d next();\n     ExtractionInfo blockInfo \u003d extractBlockComment(token);\n     token \u003d blockInfo.token;\n     if (blockInfo.string.length() \u003e 0) {\n         jsdocBuilder.recordBlockDescription(blockInfo.string);\n     }\n     retry: for (; ; ) {\n         switch(token) {\n             case ANNOTATION:\n                 if (state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                     state \u003d State.SEARCHING_NEWLINE;\n                     lineno \u003d stream.getLineno();\n                     charno \u003d stream.getCharno();\n                     String annotationName \u003d stream.getString();\n                     Annotation annotation \u003d annotationNames.get(annotationName);\n                     if (annotation \u003d\u003d null) {\n                         parser.addWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno());\n                     } else {\n                         jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n                         switch(annotation) {\n                             case AUTHOR:\n                                 ExtractionInfo authorInfo \u003d extractSingleLineBlock();\n                                 String author \u003d authorInfo.string;\n                                 if (author.length() \u003d\u003d 0) {\n                                     parser.addWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno());\n                                 } else {\n                                     jsdocBuilder.addAuthor(author);\n                                 }\n                                 token \u003d authorInfo.token;\n                                 continue retry;\n                             case CONSTANT:\n                                 if (!jsdocBuilder.recordConstancy()) {\n                                     parser.addWarning(\"msg.jsdoc.const\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case CONSTRUCTOR:\n                                 if (!jsdocBuilder.recordConstructor()) {\n                                     if (jsdocBuilder.isInterfaceRecorded()) {\n                                         parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                     } else {\n                                         parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case DEPRECATED:\n                                 if (!jsdocBuilder.recordDeprecated()) {\n                                     parser.addWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 ExtractionInfo reasonInfo \u003d extractMultilineTextualBlock(token);\n                                 String reason \u003d reasonInfo.string;\n                                 if (reason.length() \u003e 0) {\n                                     jsdocBuilder.recordDeprecationReason(reason);\n                                 }\n                                 token \u003d reasonInfo.token;\n                                 continue retry;\n                             case INTERFACE:\n                                 if (!jsdocBuilder.recordInterface()) {\n                                     if (jsdocBuilder.isConstructorRecorded()) {\n                                         parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                     } else {\n                                         parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case DESC:\n                                 if (jsdocBuilder.isDescriptionRecorded()) {\n                                     parser.addWarning(\"msg.jsdoc.desc.extra\", stream.getLineno(), stream.getCharno());\n                                     token \u003d eatTokensUntilEOL();\n                                     continue retry;\n                                 } else {\n                                     ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                     String description \u003d descriptionInfo.string;\n                                     jsdocBuilder.recordDescription(description);\n                                     token \u003d descriptionInfo.token;\n                                     continue retry;\n                                 }\n                             case FILE_OVERVIEW:\n                                 ExtractionInfo fileOverviewInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.TRIM);\n                                 String fileOverview \u003d fileOverviewInfo.string;\n                                 if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo !\u003d null) {\n                                     parser.addWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d fileOverviewInfo.token;\n                                 continue retry;\n                             case LICENSE:\n                             case PRESERVE:\n                                 ExtractionInfo preserveInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);\n                                 String preserve \u003d preserveInfo.string;\n                                 if (preserve.length() \u003e 0) {\n                                     if (fileLevelJsDocBuilder !\u003d null) {\n                                         fileLevelJsDocBuilder.append(preserve);\n                                     }\n                                 }\n                                 token \u003d preserveInfo.token;\n                                 continue retry;\n                             case ENUM:\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                 }\n                                 if (type \u003d\u003d null) {\n                                     type \u003d createJSTypeExpression(newStringNode(\"number\"));\n                                 }\n                                 if (!jsdocBuilder.recordEnumParameterType(type)) {\n                                     parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                 }\n                                 token \u003d eatTokensUntilEOL(token);\n                                 continue retry;\n                             case EXPORT:\n                                 if (!jsdocBuilder.recordExport()) {\n                                     parser.addWarning(\"msg.jsdoc.export\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case EXTENDS:\n                             case IMPLEMENTS:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 boolean matchingRc \u003d false;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     token \u003d next();\n                                     matchingRc \u003d true;\n                                 }\n                                 if (token \u003d\u003d JsDocToken.STRING) {\n                                     Node typeNode \u003d parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);\n                                     lineno \u003d stream.getLineno();\n                                     charno \u003d stream.getCharno();\n                                     typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                     if (typeNode !\u003d null \u0026\u0026 !matchingRc) {\n                                         typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                     }\n                                     type \u003d createJSTypeExpression(typeNode);\n                                     if (annotation \u003d\u003d Annotation.EXTENDS) {\n                                         if (!jsdocBuilder.recordBaseType(type)) {\n                                             parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                         }\n                                     } else {\n                                         Preconditions.checkState(annotation \u003d\u003d Annotation.IMPLEMENTS);\n                                         if (!jsdocBuilder.recordImplementedInterface(type)) {\n                                             parser.addWarning(\"msg.jsdoc.implements.duplicate\", lineno, charno);\n                                         }\n                                     }\n                                     token \u003d next();\n                                     if (matchingRc) {\n                                         if (token !\u003d JsDocToken.RC) {\n                                             parser.addWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                         }\n                                     } else if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOF \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                         parser.addWarning(\"msg.end.annotation.expected\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 } else {\n                                     parser.addWarning(\"msg.no.type.name\", lineno, charno);\n                                 }\n                                 token \u003d eatTokensUntilEOL(token);\n                                 continue retry;\n                             case HIDDEN:\n                                 if (!jsdocBuilder.recordHiddenness()) {\n                                     parser.addWarning(\"msg.jsdoc.hidden\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_ALIAS:\n                                 if (!jsdocBuilder.recordNoAlias()) {\n                                     parser.addWarning(\"msg.jsdoc.noalias\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_TYPE_CHECK:\n                                 if (!jsdocBuilder.recordNoTypeCheck()) {\n                                     parser.addWarning(\"msg.jsdoc.nocheck\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NOT_IMPLEMENTED:\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case INHERIT_DOC:\n                             case OVERRIDE:\n                                 if (!jsdocBuilder.recordOverride()) {\n                                     parser.addWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case THROWS:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                     if (type \u003d\u003d null) {\n                                         token \u003d eatTokensUntilEOL();\n                                         continue retry;\n                                     }\n                                 }\n                                 token \u003d current();\n                                 jsdocBuilder.recordThrowType(type);\n                                 ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                 String description \u003d descriptionInfo.string;\n                                 if (description.length() \u003e 0) {\n                                     jsdocBuilder.recordThrowDescription(type, description);\n                                 }\n                                 token \u003d descriptionInfo.token;\n                                 continue retry;\n                             case PARAM:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordParamTypeNode(token));\n                                     if (type \u003d\u003d null) {\n                                         token \u003d eatTokensUntilEOL();\n                                         continue retry;\n                                     }\n                                     skipEOLs();\n                                     token \u003d next();\n                                     lineno \u003d stream.getLineno();\n                                     charno \u003d stream.getCharno();\n                                 }\n                                 String name \u003d null;\n                                 boolean isBracketedParam \u003d JsDocToken.LB \u003d\u003d token;\n                                 if (isBracketedParam) {\n                                     token \u003d next();\n                                 }\n                                 if (JsDocToken.STRING !\u003d token) {\n                                     parser.addWarning(\"msg.missing.variable.name\", lineno, charno);\n                                 } else {\n                                     name \u003d stream.getString();\n                                     if (isBracketedParam) {\n                                         token \u003d next();\n                                         if (JsDocToken.RB !\u003d token) {\n                                             reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n+                                        } else if (type !\u003d null) {\n+                                            type \u003d JSTypeExpression.makeOptionalArg(type);\n                                         }\n                                     }\n                                     if (!jsdocBuilder.recordParameter(name, type)) {\n                                         if (jsdocBuilder.hasParameter(name)) {\n                                             parser.addWarning(\"msg.dup.variable.name\", name, lineno, charno);\n                                         } else {\n                                             parser.addWarning(\"msg.jsdoc.incompat.type\", name, lineno, charno);\n                                         }\n                                     }\n                                 }\n                                 if (name \u003d\u003d null) {\n                                     token \u003d eatTokensUntilEOL(token);\n                                     continue retry;\n                                 }\n                                 jsdocBuilder.markName(name, lineno, charno);\n                                 ExtractionInfo paramDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                 String paramDescription \u003d paramDescriptionInfo.string;\n                                 if (paramDescription.length() \u003e 0) {\n                                     jsdocBuilder.recordParameterDescription(name, paramDescription);\n                                 }\n                                 token \u003d paramDescriptionInfo.token;\n                                 continue retry;\n                             case PRESERVE_TRY:\n                                 if (!jsdocBuilder.recordPreserveTry()) {\n                                     parser.addWarning(\"msg.jsdoc.preservertry\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PRIVATE:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                                     parser.addWarning(\"msg.jsdoc.visibility.private\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PROTECTED:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                                     parser.addWarning(\"msg.jsdoc.visibility.protected\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PUBLIC:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                                     parser.addWarning(\"msg.jsdoc.visibility.public\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_SHADOW:\n                                 if (!jsdocBuilder.recordNoShadow()) {\n                                     parser.addWarning(\"msg.jsdoc.noshadow\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_SIDE_EFFECTS:\n                                 if (!jsdocBuilder.recordNoSideEffects()) {\n                                     parser.addWarning(\"msg.jsdoc.nosideeffects\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case IMPLICIT_CAST:\n                                 if (!jsdocBuilder.recordImplicitCast()) {\n                                     parser.addWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case SEE:\n                                 ExtractionInfo referenceInfo \u003d extractSingleLineBlock();\n                                 String reference \u003d referenceInfo.string;\n                                 if (reference.length() \u003d\u003d 0) {\n                                     parser.addWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno());\n                                 } else {\n                                     jsdocBuilder.addReference(reference);\n                                 }\n                                 token \u003d referenceInfo.token;\n                                 continue retry;\n                             case SUPPRESS:\n                                 token \u003d parseSuppressTag(next());\n                                 continue retry;\n                             case TEMPLATE:\n                                 ExtractionInfo templateInfo \u003d extractSingleLineBlock();\n                                 String templateTypeName \u003d templateInfo.string;\n                                 if (templateTypeName.length() \u003d\u003d 0) {\n                                     parser.addWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno());\n                                 } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {\n                                     parser.addWarning(\"msg.jsdoc.template.at.most.once\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d templateInfo.token;\n                                 continue retry;\n                             case VERSION:\n                                 ExtractionInfo versionInfo \u003d extractSingleLineBlock();\n                                 String version \u003d versionInfo.string;\n                                 if (version.length() \u003d\u003d 0) {\n                                     parser.addWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno());\n                                 } else {\n                                     if (!jsdocBuilder.recordVersion(version)) {\n                                         parser.addWarning(\"msg.jsdoc.extraversion\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d versionInfo.token;\n                                 continue retry;\n                             case DEFINE:\n                             case RETURN:\n                             case THIS:\n                             case TYPE:\n                             case TYPEDEF:\n                                 skipEOLs();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 token \u003d next();\n                                 Node typeNode \u003d parseAndRecordTypeNode(token, lineno, charno);\n                                 if (annotation \u003d\u003d Annotation.THIS) {\n                                     typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                     if (typeNode !\u003d null \u0026\u0026 token !\u003d JsDocToken.LC) {\n                                         typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                     }\n                                 }\n                                 type \u003d createJSTypeExpression(typeNode);\n                                 if (type \u003d\u003d null) {\n                                 } else {\n                                     switch(annotation) {\n                                         case DEFINE:\n                                             if (!isValidDefineType(typeNode)) {\n                                                 parser.addWarning(\"msg.jsdoc.define.badtype\", lineno, charno);\n                                             } else if (!jsdocBuilder.recordDefineType(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.define\", lineno, charno);\n                                             }\n                                             break;\n                                         case RETURN:\n                                             if (!jsdocBuilder.recordReturnType(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                                 break;\n                                             }\n                                             token \u003d current();\n                                             ExtractionInfo returnDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                             String returnDescription \u003d returnDescriptionInfo.string;\n                                             if (returnDescription.length() \u003e 0) {\n                                                 jsdocBuilder.recordReturnDescription(returnDescription);\n                                             }\n                                             token \u003d returnDescriptionInfo.token;\n                                             continue retry;\n                                         case THIS:\n                                             if (!jsdocBuilder.recordThisType(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                         case TYPE:\n                                             if (!jsdocBuilder.recordType(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                         case TYPEDEF:\n                                             if (!jsdocBuilder.recordTypedef(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                     }\n                                     token \u003d eatTokensUntilEOL();\n                                 }\n                                 continue retry;\n                         }\n                     }\n                 }\n                 break;\n             case EOC:\n                 if (hasParsedFileOverviewDocInfo()) {\n                     fileOverviewJSDocInfo \u003d retrieveAndResetParsedJSDocInfo();\n                 }\n                 return true;\n             case EOF:\n                 jsdocBuilder.build(null);\n                 parser.addWarning(\"msg.unexpected.eof\", stream.getLineno(), stream.getCharno());\n                 return false;\n             case EOL:\n                 if (state \u003d\u003d State.SEARCHING_NEWLINE) {\n                     state \u003d State.SEARCHING_ANNOTATION;\n                 }\n                 token \u003d next();\n                 continue retry;\n             default:\n                 if (token \u003d\u003d JsDocToken.STAR \u0026\u0026 state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                     token \u003d next();\n                     continue retry;\n                 } else {\n                     state \u003d State.SEARCHING_NEWLINE;\n                     token \u003d eatTokensUntilEOL();\n                     continue retry;\n                 }\n         }\n         token \u003d next();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "efd3c178e471df6a689c1a50fbd7c404e778bfaa": {
      "type": "Ybodychange",
      "commitMessage": "Better number printing.\nAdd flags for fine-grained warning controls.\nBetter type-declaration finding.\nAdded some missing externs.\nMarked externs that don\u0027t have side effects.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@10 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/13/09, 11:38 AM",
      "commitName": "efd3c178e471df6a689c1a50fbd7c404e778bfaa",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "commitDateOld": "11/3/09, 3:51 PM",
      "commitNameOld": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthorOld": "nicholas.j.santos@gmail.com",
      "daysBetweenCommits": 9.82,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "boolean parse() {\n    int lineno;\n    int charno;\n    JSTypeExpression type;\n    state \u003d State.SEARCHING_ANNOTATION;\n    JsDocToken token \u003d next();\n    ExtractionInfo blockInfo \u003d extractBlockComment(token);\n    token \u003d blockInfo.token;\n    if (blockInfo.string.length() \u003e 0) {\n        jsdocBuilder.recordBlockDescription(blockInfo.string);\n    }\n    retry: for (; ; ) {\n        switch(token) {\n            case ANNOTATION:\n                if (state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                    state \u003d State.SEARCHING_NEWLINE;\n                    lineno \u003d stream.getLineno();\n                    charno \u003d stream.getCharno();\n                    String annotationName \u003d stream.getString();\n                    Annotation annotation \u003d annotationNames.get(annotationName);\n                    if (annotation \u003d\u003d null) {\n                        parser.addWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno());\n                    } else {\n                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n                        switch(annotation) {\n                            case AUTHOR:\n                                ExtractionInfo authorInfo \u003d extractSingleLineBlock();\n                                String author \u003d authorInfo.string;\n                                if (author.length() \u003d\u003d 0) {\n                                    parser.addWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno());\n                                } else {\n                                    jsdocBuilder.addAuthor(author);\n                                }\n                                token \u003d authorInfo.token;\n                                continue retry;\n                            case CONSTANT:\n                                if (!jsdocBuilder.recordConstancy()) {\n                                    parser.addWarning(\"msg.jsdoc.const\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case CONSTRUCTOR:\n                                if (!jsdocBuilder.recordConstructor()) {\n                                    if (jsdocBuilder.isInterfaceRecorded()) {\n                                        parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case DEPRECATED:\n                                if (!jsdocBuilder.recordDeprecated()) {\n                                    parser.addWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno());\n                                }\n                                ExtractionInfo reasonInfo \u003d extractMultilineTextualBlock(token);\n                                String reason \u003d reasonInfo.string;\n                                if (reason.length() \u003e 0) {\n                                    jsdocBuilder.recordDeprecationReason(reason);\n                                }\n                                token \u003d reasonInfo.token;\n                                continue retry;\n                            case INTERFACE:\n                                if (!jsdocBuilder.recordInterface()) {\n                                    if (jsdocBuilder.isConstructorRecorded()) {\n                                        parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case DESC:\n                                if (jsdocBuilder.isDescriptionRecorded()) {\n                                    parser.addWarning(\"msg.jsdoc.desc.extra\", stream.getLineno(), stream.getCharno());\n                                    token \u003d eatTokensUntilEOL();\n                                    continue retry;\n                                } else {\n                                    ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                    String description \u003d descriptionInfo.string;\n                                    jsdocBuilder.recordDescription(description);\n                                    token \u003d descriptionInfo.token;\n                                    continue retry;\n                                }\n                            case FILE_OVERVIEW:\n                                ExtractionInfo fileOverviewInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.TRIM);\n                                String fileOverview \u003d fileOverviewInfo.string;\n                                if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo !\u003d null) {\n                                    parser.addWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d fileOverviewInfo.token;\n                                continue retry;\n                            case LICENSE:\n                            case PRESERVE:\n                                ExtractionInfo preserveInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);\n                                String preserve \u003d preserveInfo.string;\n                                if (preserve.length() \u003e 0) {\n                                    if (fileLevelJsDocBuilder !\u003d null) {\n                                        fileLevelJsDocBuilder.append(preserve);\n                                    }\n                                }\n                                token \u003d preserveInfo.token;\n                                continue retry;\n                            case ENUM:\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                }\n                                if (type \u003d\u003d null) {\n                                    type \u003d createJSTypeExpression(newStringNode(\"number\"));\n                                }\n                                if (!jsdocBuilder.recordEnumParameterType(type)) {\n                                    parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                }\n                                token \u003d eatTokensUntilEOL(token);\n                                continue retry;\n                            case EXPORT:\n                                if (!jsdocBuilder.recordExport()) {\n                                    parser.addWarning(\"msg.jsdoc.export\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case EXTENDS:\n                            case IMPLEMENTS:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                boolean matchingRc \u003d false;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    token \u003d next();\n                                    matchingRc \u003d true;\n                                }\n                                if (token \u003d\u003d JsDocToken.STRING) {\n                                    Node typeNode \u003d parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);\n                                    lineno \u003d stream.getLineno();\n                                    charno \u003d stream.getCharno();\n                                    typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                    if (typeNode !\u003d null \u0026\u0026 !matchingRc) {\n                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                    }\n                                    type \u003d createJSTypeExpression(typeNode);\n                                    if (annotation \u003d\u003d Annotation.EXTENDS) {\n                                        if (!jsdocBuilder.recordBaseType(type)) {\n                                            parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                        }\n                                    } else {\n                                        Preconditions.checkState(annotation \u003d\u003d Annotation.IMPLEMENTS);\n                                        if (!jsdocBuilder.recordImplementedInterface(type)) {\n                                            parser.addWarning(\"msg.jsdoc.implements.duplicate\", lineno, charno);\n                                        }\n                                    }\n                                    token \u003d next();\n                                    if (matchingRc) {\n                                        if (token !\u003d JsDocToken.RC) {\n                                            parser.addWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                        }\n                                    } else if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOF \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                        parser.addWarning(\"msg.end.annotation.expected\", stream.getLineno(), stream.getCharno());\n                                    }\n                                } else {\n                                    parser.addWarning(\"msg.no.type.name\", lineno, charno);\n                                }\n                                token \u003d eatTokensUntilEOL(token);\n                                continue retry;\n                            case HIDDEN:\n                                if (!jsdocBuilder.recordHiddenness()) {\n                                    parser.addWarning(\"msg.jsdoc.hidden\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_ALIAS:\n                                if (!jsdocBuilder.recordNoAlias()) {\n                                    parser.addWarning(\"msg.jsdoc.noalias\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_TYPE_CHECK:\n                                if (!jsdocBuilder.recordNoTypeCheck()) {\n                                    parser.addWarning(\"msg.jsdoc.nocheck\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NOT_IMPLEMENTED:\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case INHERIT_DOC:\n                            case OVERRIDE:\n                                if (!jsdocBuilder.recordOverride()) {\n                                    parser.addWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case THROWS:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                    if (type \u003d\u003d null) {\n                                        token \u003d eatTokensUntilEOL();\n                                        continue retry;\n                                    }\n                                }\n                                token \u003d current();\n                                jsdocBuilder.recordThrowType(type);\n                                ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                String description \u003d descriptionInfo.string;\n                                if (description.length() \u003e 0) {\n                                    jsdocBuilder.recordThrowDescription(type, description);\n                                }\n                                token \u003d descriptionInfo.token;\n                                continue retry;\n                            case PARAM:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordParamTypeNode(token));\n                                    if (type \u003d\u003d null) {\n                                        token \u003d eatTokensUntilEOL();\n                                        continue retry;\n                                    }\n                                    skipEOLs();\n                                    token \u003d next();\n                                    lineno \u003d stream.getLineno();\n                                    charno \u003d stream.getCharno();\n                                }\n                                String name \u003d null;\n                                boolean isBracketedParam \u003d JsDocToken.LB \u003d\u003d token;\n                                if (isBracketedParam) {\n                                    token \u003d next();\n                                }\n                                if (JsDocToken.STRING !\u003d token) {\n                                    parser.addWarning(\"msg.missing.variable.name\", lineno, charno);\n                                } else {\n                                    name \u003d stream.getString();\n                                    if (isBracketedParam) {\n                                        token \u003d next();\n                                        if (JsDocToken.RB !\u003d token) {\n                                            reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                                        }\n                                    }\n                                    if (!jsdocBuilder.recordParameter(name, type)) {\n                                        if (jsdocBuilder.hasParameter(name)) {\n                                            parser.addWarning(\"msg.dup.variable.name\", name, lineno, charno);\n                                        } else {\n                                            parser.addWarning(\"msg.jsdoc.incompat.type\", name, lineno, charno);\n                                        }\n                                    }\n                                }\n                                if (name \u003d\u003d null) {\n                                    token \u003d eatTokensUntilEOL(token);\n                                    continue retry;\n                                }\n                                jsdocBuilder.markName(name, lineno, charno);\n                                ExtractionInfo paramDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                String paramDescription \u003d paramDescriptionInfo.string;\n                                if (paramDescription.length() \u003e 0) {\n                                    jsdocBuilder.recordParameterDescription(name, paramDescription);\n                                }\n                                token \u003d paramDescriptionInfo.token;\n                                continue retry;\n                            case PRESERVE_TRY:\n                                if (!jsdocBuilder.recordPreserveTry()) {\n                                    parser.addWarning(\"msg.jsdoc.preservertry\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PRIVATE:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                                    parser.addWarning(\"msg.jsdoc.visibility.private\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PROTECTED:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                                    parser.addWarning(\"msg.jsdoc.visibility.protected\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PUBLIC:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                                    parser.addWarning(\"msg.jsdoc.visibility.public\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_SHADOW:\n                                if (!jsdocBuilder.recordNoShadow()) {\n                                    parser.addWarning(\"msg.jsdoc.noshadow\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_SIDE_EFFECTS:\n                                if (!jsdocBuilder.recordNoSideEffects()) {\n                                    parser.addWarning(\"msg.jsdoc.nosideeffects\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case IMPLICIT_CAST:\n                                if (!jsdocBuilder.recordImplicitCast()) {\n                                    parser.addWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case SEE:\n                                ExtractionInfo referenceInfo \u003d extractSingleLineBlock();\n                                String reference \u003d referenceInfo.string;\n                                if (reference.length() \u003d\u003d 0) {\n                                    parser.addWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno());\n                                } else {\n                                    jsdocBuilder.addReference(reference);\n                                }\n                                token \u003d referenceInfo.token;\n                                continue retry;\n                            case SUPPRESS:\n                                token \u003d parseSuppressTag(next());\n                                continue retry;\n                            case TEMPLATE:\n                                ExtractionInfo templateInfo \u003d extractSingleLineBlock();\n                                String templateTypeName \u003d templateInfo.string;\n                                if (templateTypeName.length() \u003d\u003d 0) {\n                                    parser.addWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno());\n                                } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {\n                                    parser.addWarning(\"msg.jsdoc.template.at.most.once\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d templateInfo.token;\n                                continue retry;\n                            case VERSION:\n                                ExtractionInfo versionInfo \u003d extractSingleLineBlock();\n                                String version \u003d versionInfo.string;\n                                if (version.length() \u003d\u003d 0) {\n                                    parser.addWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno());\n                                } else {\n                                    if (!jsdocBuilder.recordVersion(version)) {\n                                        parser.addWarning(\"msg.jsdoc.extraversion\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d versionInfo.token;\n                                continue retry;\n                            case DEFINE:\n                            case RETURN:\n                            case THIS:\n                            case TYPE:\n                            case TYPEDEF:\n                                skipEOLs();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                token \u003d next();\n                                Node typeNode \u003d parseAndRecordTypeNode(token, lineno, charno);\n                                if (annotation \u003d\u003d Annotation.THIS) {\n                                    typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                    if (typeNode !\u003d null \u0026\u0026 token !\u003d JsDocToken.LC) {\n                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                    }\n                                }\n                                type \u003d createJSTypeExpression(typeNode);\n                                if (type \u003d\u003d null) {\n                                } else {\n                                    switch(annotation) {\n                                        case DEFINE:\n                                            if (!isValidDefineType(typeNode)) {\n                                                parser.addWarning(\"msg.jsdoc.define.badtype\", lineno, charno);\n                                            } else if (!jsdocBuilder.recordDefineType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.define\", lineno, charno);\n                                            }\n                                            break;\n                                        case RETURN:\n                                            if (!jsdocBuilder.recordReturnType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                                break;\n                                            }\n                                            token \u003d current();\n                                            ExtractionInfo returnDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                            String returnDescription \u003d returnDescriptionInfo.string;\n                                            if (returnDescription.length() \u003e 0) {\n                                                jsdocBuilder.recordReturnDescription(returnDescription);\n                                            }\n                                            token \u003d returnDescriptionInfo.token;\n                                            continue retry;\n                                        case THIS:\n                                            if (!jsdocBuilder.recordThisType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                        case TYPE:\n                                            if (!jsdocBuilder.recordType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                        case TYPEDEF:\n                                            if (!jsdocBuilder.recordTypedef(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                    }\n                                    token \u003d eatTokensUntilEOL();\n                                }\n                                continue retry;\n                        }\n                    }\n                }\n                break;\n            case EOC:\n                if (hasParsedFileOverviewDocInfo()) {\n                    fileOverviewJSDocInfo \u003d retrieveAndResetParsedJSDocInfo();\n                }\n                return true;\n            case EOF:\n                jsdocBuilder.build(null);\n                parser.addWarning(\"msg.unexpected.eof\", stream.getLineno(), stream.getCharno());\n                return false;\n            case EOL:\n                if (state \u003d\u003d State.SEARCHING_NEWLINE) {\n                    state \u003d State.SEARCHING_ANNOTATION;\n                }\n                token \u003d next();\n                continue retry;\n            default:\n                if (token \u003d\u003d JsDocToken.STAR \u0026\u0026 state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                    token \u003d next();\n                    continue retry;\n                } else {\n                    state \u003d State.SEARCHING_NEWLINE;\n                    token \u003d eatTokensUntilEOL();\n                    continue retry;\n                }\n        }\n        token \u003d next();\n    }\n}",
      "path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
      "functionStartLine": 237,
      "functionName": "parse",
      "functionAnnotation": "",
      "functionDoc": "Parses a {@link JSDocInfo} object. This parsing method reads all tokens\nreturned by the {@link JsDocTokenStream#getJsDocToken()} method until the\n{@link JsDocToken#EOC} is returned.\n\n@return @code true} if JSDoc information was correctly parsed,\n    {@code false} otherwise\n",
      "diff": "@@ -1,428 +1,438 @@\n boolean parse() {\n     int lineno;\n     int charno;\n     JSTypeExpression type;\n     state \u003d State.SEARCHING_ANNOTATION;\n     JsDocToken token \u003d next();\n     ExtractionInfo blockInfo \u003d extractBlockComment(token);\n     token \u003d blockInfo.token;\n     if (blockInfo.string.length() \u003e 0) {\n         jsdocBuilder.recordBlockDescription(blockInfo.string);\n     }\n     retry: for (; ; ) {\n         switch(token) {\n             case ANNOTATION:\n                 if (state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                     state \u003d State.SEARCHING_NEWLINE;\n                     lineno \u003d stream.getLineno();\n                     charno \u003d stream.getCharno();\n                     String annotationName \u003d stream.getString();\n                     Annotation annotation \u003d annotationNames.get(annotationName);\n                     if (annotation \u003d\u003d null) {\n                         parser.addWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno());\n                     } else {\n                         jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n                         switch(annotation) {\n                             case AUTHOR:\n                                 ExtractionInfo authorInfo \u003d extractSingleLineBlock();\n                                 String author \u003d authorInfo.string;\n                                 if (author.length() \u003d\u003d 0) {\n                                     parser.addWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno());\n                                 } else {\n                                     jsdocBuilder.addAuthor(author);\n                                 }\n                                 token \u003d authorInfo.token;\n                                 continue retry;\n                             case CONSTANT:\n                                 if (!jsdocBuilder.recordConstancy()) {\n                                     parser.addWarning(\"msg.jsdoc.const\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case CONSTRUCTOR:\n                                 if (!jsdocBuilder.recordConstructor()) {\n                                     if (jsdocBuilder.isInterfaceRecorded()) {\n                                         parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                     } else {\n                                         parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case DEPRECATED:\n                                 if (!jsdocBuilder.recordDeprecated()) {\n                                     parser.addWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 ExtractionInfo reasonInfo \u003d extractMultilineTextualBlock(token);\n                                 String reason \u003d reasonInfo.string;\n                                 if (reason.length() \u003e 0) {\n                                     jsdocBuilder.recordDeprecationReason(reason);\n                                 }\n                                 token \u003d reasonInfo.token;\n                                 continue retry;\n                             case INTERFACE:\n                                 if (!jsdocBuilder.recordInterface()) {\n                                     if (jsdocBuilder.isConstructorRecorded()) {\n                                         parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                     } else {\n                                         parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case DESC:\n                                 if (jsdocBuilder.isDescriptionRecorded()) {\n                                     parser.addWarning(\"msg.jsdoc.desc.extra\", stream.getLineno(), stream.getCharno());\n                                     token \u003d eatTokensUntilEOL();\n                                     continue retry;\n                                 } else {\n                                     ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                     String description \u003d descriptionInfo.string;\n                                     jsdocBuilder.recordDescription(description);\n                                     token \u003d descriptionInfo.token;\n                                     continue retry;\n                                 }\n                             case FILE_OVERVIEW:\n                                 ExtractionInfo fileOverviewInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.TRIM);\n                                 String fileOverview \u003d fileOverviewInfo.string;\n                                 if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo !\u003d null) {\n                                     parser.addWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d fileOverviewInfo.token;\n                                 continue retry;\n                             case LICENSE:\n                             case PRESERVE:\n                                 ExtractionInfo preserveInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);\n                                 String preserve \u003d preserveInfo.string;\n                                 if (preserve.length() \u003e 0) {\n                                     if (fileLevelJsDocBuilder !\u003d null) {\n                                         fileLevelJsDocBuilder.append(preserve);\n                                     }\n                                 }\n                                 token \u003d preserveInfo.token;\n                                 continue retry;\n                             case ENUM:\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                 }\n                                 if (type \u003d\u003d null) {\n                                     type \u003d createJSTypeExpression(newStringNode(\"number\"));\n                                 }\n                                 if (!jsdocBuilder.recordEnumParameterType(type)) {\n                                     parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                 }\n                                 token \u003d eatTokensUntilEOL(token);\n                                 continue retry;\n                             case EXPORT:\n                                 if (!jsdocBuilder.recordExport()) {\n                                     parser.addWarning(\"msg.jsdoc.export\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case EXTENDS:\n                             case IMPLEMENTS:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 boolean matchingRc \u003d false;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     token \u003d next();\n                                     matchingRc \u003d true;\n                                 }\n                                 if (token \u003d\u003d JsDocToken.STRING) {\n                                     Node typeNode \u003d parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);\n                                     lineno \u003d stream.getLineno();\n                                     charno \u003d stream.getCharno();\n                                     typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                     if (typeNode !\u003d null \u0026\u0026 !matchingRc) {\n                                         typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                     }\n                                     type \u003d createJSTypeExpression(typeNode);\n                                     if (annotation \u003d\u003d Annotation.EXTENDS) {\n                                         if (!jsdocBuilder.recordBaseType(type)) {\n                                             parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                         }\n                                     } else {\n                                         Preconditions.checkState(annotation \u003d\u003d Annotation.IMPLEMENTS);\n                                         if (!jsdocBuilder.recordImplementedInterface(type)) {\n                                             parser.addWarning(\"msg.jsdoc.implements.duplicate\", lineno, charno);\n                                         }\n                                     }\n                                     token \u003d next();\n                                     if (matchingRc) {\n                                         if (token !\u003d JsDocToken.RC) {\n                                             parser.addWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                         }\n                                     } else if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOF \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                         parser.addWarning(\"msg.end.annotation.expected\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 } else {\n                                     parser.addWarning(\"msg.no.type.name\", lineno, charno);\n                                 }\n                                 token \u003d eatTokensUntilEOL(token);\n                                 continue retry;\n                             case HIDDEN:\n                                 if (!jsdocBuilder.recordHiddenness()) {\n                                     parser.addWarning(\"msg.jsdoc.hidden\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_ALIAS:\n                                 if (!jsdocBuilder.recordNoAlias()) {\n                                     parser.addWarning(\"msg.jsdoc.noalias\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_TYPE_CHECK:\n                                 if (!jsdocBuilder.recordNoTypeCheck()) {\n                                     parser.addWarning(\"msg.jsdoc.nocheck\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NOT_IMPLEMENTED:\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case INHERIT_DOC:\n                             case OVERRIDE:\n                                 if (!jsdocBuilder.recordOverride()) {\n                                     parser.addWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case THROWS:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                     if (type \u003d\u003d null) {\n                                         token \u003d eatTokensUntilEOL();\n                                         continue retry;\n                                     }\n                                 }\n                                 token \u003d current();\n                                 jsdocBuilder.recordThrowType(type);\n                                 ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                 String description \u003d descriptionInfo.string;\n                                 if (description.length() \u003e 0) {\n                                     jsdocBuilder.recordThrowDescription(type, description);\n                                 }\n                                 token \u003d descriptionInfo.token;\n                                 continue retry;\n                             case PARAM:\n                                 skipEOLs();\n                                 token \u003d next();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 type \u003d null;\n                                 if (token \u003d\u003d JsDocToken.LC) {\n                                     type \u003d createJSTypeExpression(parseAndRecordParamTypeNode(token));\n                                     if (type \u003d\u003d null) {\n                                         token \u003d eatTokensUntilEOL();\n                                         continue retry;\n                                     }\n                                     skipEOLs();\n                                     token \u003d next();\n                                     lineno \u003d stream.getLineno();\n                                     charno \u003d stream.getCharno();\n                                 }\n                                 String name \u003d null;\n+                                boolean isBracketedParam \u003d JsDocToken.LB \u003d\u003d token;\n+                                if (isBracketedParam) {\n+                                    token \u003d next();\n+                                }\n                                 if (JsDocToken.STRING !\u003d token) {\n                                     parser.addWarning(\"msg.missing.variable.name\", lineno, charno);\n                                 } else {\n                                     name \u003d stream.getString();\n+                                    if (isBracketedParam) {\n+                                        token \u003d next();\n+                                        if (JsDocToken.RB !\u003d token) {\n+                                            reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n+                                        }\n+                                    }\n                                     if (!jsdocBuilder.recordParameter(name, type)) {\n                                         if (jsdocBuilder.hasParameter(name)) {\n                                             parser.addWarning(\"msg.dup.variable.name\", name, lineno, charno);\n                                         } else {\n                                             parser.addWarning(\"msg.jsdoc.incompat.type\", name, lineno, charno);\n                                         }\n                                     }\n                                 }\n                                 if (name \u003d\u003d null) {\n                                     token \u003d eatTokensUntilEOL(token);\n                                     continue retry;\n                                 }\n                                 jsdocBuilder.markName(name, lineno, charno);\n                                 ExtractionInfo paramDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                 String paramDescription \u003d paramDescriptionInfo.string;\n                                 if (paramDescription.length() \u003e 0) {\n                                     jsdocBuilder.recordParameterDescription(name, paramDescription);\n                                 }\n                                 token \u003d paramDescriptionInfo.token;\n                                 continue retry;\n                             case PRESERVE_TRY:\n                                 if (!jsdocBuilder.recordPreserveTry()) {\n                                     parser.addWarning(\"msg.jsdoc.preservertry\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PRIVATE:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                                     parser.addWarning(\"msg.jsdoc.visibility.private\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PROTECTED:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                                     parser.addWarning(\"msg.jsdoc.visibility.protected\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case PUBLIC:\n                                 if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                                     parser.addWarning(\"msg.jsdoc.visibility.public\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_SHADOW:\n                                 if (!jsdocBuilder.recordNoShadow()) {\n                                     parser.addWarning(\"msg.jsdoc.noshadow\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case NO_SIDE_EFFECTS:\n                                 if (!jsdocBuilder.recordNoSideEffects()) {\n                                     parser.addWarning(\"msg.jsdoc.nosideeffects\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case IMPLICIT_CAST:\n                                 if (!jsdocBuilder.recordImplicitCast()) {\n                                     parser.addWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d eatTokensUntilEOL();\n                                 continue retry;\n                             case SEE:\n                                 ExtractionInfo referenceInfo \u003d extractSingleLineBlock();\n                                 String reference \u003d referenceInfo.string;\n                                 if (reference.length() \u003d\u003d 0) {\n                                     parser.addWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno());\n                                 } else {\n                                     jsdocBuilder.addReference(reference);\n                                 }\n                                 token \u003d referenceInfo.token;\n                                 continue retry;\n                             case SUPPRESS:\n                                 token \u003d parseSuppressTag(next());\n                                 continue retry;\n                             case TEMPLATE:\n                                 ExtractionInfo templateInfo \u003d extractSingleLineBlock();\n                                 String templateTypeName \u003d templateInfo.string;\n                                 if (templateTypeName.length() \u003d\u003d 0) {\n                                     parser.addWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno());\n                                 } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {\n                                     parser.addWarning(\"msg.jsdoc.template.at.most.once\", stream.getLineno(), stream.getCharno());\n                                 }\n                                 token \u003d templateInfo.token;\n                                 continue retry;\n                             case VERSION:\n                                 ExtractionInfo versionInfo \u003d extractSingleLineBlock();\n                                 String version \u003d versionInfo.string;\n                                 if (version.length() \u003d\u003d 0) {\n                                     parser.addWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno());\n                                 } else {\n                                     if (!jsdocBuilder.recordVersion(version)) {\n                                         parser.addWarning(\"msg.jsdoc.extraversion\", stream.getLineno(), stream.getCharno());\n                                     }\n                                 }\n                                 token \u003d versionInfo.token;\n                                 continue retry;\n                             case DEFINE:\n                             case RETURN:\n                             case THIS:\n                             case TYPE:\n                             case TYPEDEF:\n                                 skipEOLs();\n                                 lineno \u003d stream.getLineno();\n                                 charno \u003d stream.getCharno();\n                                 token \u003d next();\n                                 Node typeNode \u003d parseAndRecordTypeNode(token, lineno, charno);\n                                 if (annotation \u003d\u003d Annotation.THIS) {\n                                     typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                     if (typeNode !\u003d null \u0026\u0026 token !\u003d JsDocToken.LC) {\n                                         typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                     }\n                                 }\n                                 type \u003d createJSTypeExpression(typeNode);\n                                 if (type \u003d\u003d null) {\n                                 } else {\n                                     switch(annotation) {\n                                         case DEFINE:\n                                             if (!isValidDefineType(typeNode)) {\n                                                 parser.addWarning(\"msg.jsdoc.define.badtype\", lineno, charno);\n                                             } else if (!jsdocBuilder.recordDefineType(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.define\", lineno, charno);\n                                             }\n                                             break;\n                                         case RETURN:\n                                             if (!jsdocBuilder.recordReturnType(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                                 break;\n                                             }\n                                             token \u003d current();\n                                             ExtractionInfo returnDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                             String returnDescription \u003d returnDescriptionInfo.string;\n                                             if (returnDescription.length() \u003e 0) {\n                                                 jsdocBuilder.recordReturnDescription(returnDescription);\n                                             }\n                                             token \u003d returnDescriptionInfo.token;\n                                             continue retry;\n                                         case THIS:\n                                             if (!jsdocBuilder.recordThisType(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                         case TYPE:\n                                             if (!jsdocBuilder.recordType(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                         case TYPEDEF:\n                                             if (!jsdocBuilder.recordTypedef(type)) {\n                                                 parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                             }\n                                             break;\n                                     }\n                                     token \u003d eatTokensUntilEOL();\n                                 }\n                                 continue retry;\n                         }\n                     }\n                 }\n                 break;\n             case EOC:\n                 if (hasParsedFileOverviewDocInfo()) {\n                     fileOverviewJSDocInfo \u003d retrieveAndResetParsedJSDocInfo();\n                 }\n                 return true;\n             case EOF:\n                 jsdocBuilder.build(null);\n                 parser.addWarning(\"msg.unexpected.eof\", stream.getLineno(), stream.getCharno());\n                 return false;\n             case EOL:\n                 if (state \u003d\u003d State.SEARCHING_NEWLINE) {\n                     state \u003d State.SEARCHING_ANNOTATION;\n                 }\n                 token \u003d next();\n                 continue retry;\n             default:\n                 if (token \u003d\u003d JsDocToken.STAR \u0026\u0026 state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                     token \u003d next();\n                     continue retry;\n                 } else {\n                     state \u003d State.SEARCHING_NEWLINE;\n                     token \u003d eatTokensUntilEOL();\n                     continue retry;\n                 }\n         }\n         token \u003d next();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": {
      "type": "Yintroduced",
      "commitMessage": "Initial commit.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/3/09, 3:51 PM",
      "commitName": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "diff": "@@ -0,0 +1,428 @@\n+boolean parse() {\n+    int lineno;\n+    int charno;\n+    JSTypeExpression type;\n+    state \u003d State.SEARCHING_ANNOTATION;\n+    JsDocToken token \u003d next();\n+    ExtractionInfo blockInfo \u003d extractBlockComment(token);\n+    token \u003d blockInfo.token;\n+    if (blockInfo.string.length() \u003e 0) {\n+        jsdocBuilder.recordBlockDescription(blockInfo.string);\n+    }\n+    retry: for (; ; ) {\n+        switch(token) {\n+            case ANNOTATION:\n+                if (state \u003d\u003d State.SEARCHING_ANNOTATION) {\n+                    state \u003d State.SEARCHING_NEWLINE;\n+                    lineno \u003d stream.getLineno();\n+                    charno \u003d stream.getCharno();\n+                    String annotationName \u003d stream.getString();\n+                    Annotation annotation \u003d annotationNames.get(annotationName);\n+                    if (annotation \u003d\u003d null) {\n+                        parser.addWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno());\n+                    } else {\n+                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n+                        switch(annotation) {\n+                            case AUTHOR:\n+                                ExtractionInfo authorInfo \u003d extractSingleLineBlock();\n+                                String author \u003d authorInfo.string;\n+                                if (author.length() \u003d\u003d 0) {\n+                                    parser.addWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno());\n+                                } else {\n+                                    jsdocBuilder.addAuthor(author);\n+                                }\n+                                token \u003d authorInfo.token;\n+                                continue retry;\n+                            case CONSTANT:\n+                                if (!jsdocBuilder.recordConstancy()) {\n+                                    parser.addWarning(\"msg.jsdoc.const\", stream.getLineno(), stream.getCharno());\n+                                }\n+                                token \u003d eatTokensUntilEOL();\n+                                continue retry;\n+                            case CONSTRUCTOR:\n+                                if (!jsdocBuilder.recordConstructor()) {\n+                                    if (jsdocBuilder.isInterfaceRecorded()) {\n+                                        parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n+                                    } else {\n+                                        parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n+                                    }\n+                                }\n+                                token \u003d eatTokensUntilEOL();\n+                                continue retry;\n+                            case DEPRECATED:\n+                                if (!jsdocBuilder.recordDeprecated()) {\n+                                    parser.addWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno());\n+                                }\n+                                ExtractionInfo reasonInfo \u003d extractMultilineTextualBlock(token);\n+                                String reason \u003d reasonInfo.string;\n+                                if (reason.length() \u003e 0) {\n+                                    jsdocBuilder.recordDeprecationReason(reason);\n+                                }\n+                                token \u003d reasonInfo.token;\n+                                continue retry;\n+                            case INTERFACE:\n+                                if (!jsdocBuilder.recordInterface()) {\n+                                    if (jsdocBuilder.isConstructorRecorded()) {\n+                                        parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n+                                    } else {\n+                                        parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n+                                    }\n+                                }\n+                                token \u003d eatTokensUntilEOL();\n+                                continue retry;\n+                            case DESC:\n+                                if (jsdocBuilder.isDescriptionRecorded()) {\n+                                    parser.addWarning(\"msg.jsdoc.desc.extra\", stream.getLineno(), stream.getCharno());\n+                                    token \u003d eatTokensUntilEOL();\n+                                    continue retry;\n+                                } else {\n+                                    ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n+                                    String description \u003d descriptionInfo.string;\n+                                    jsdocBuilder.recordDescription(description);\n+                                    token \u003d descriptionInfo.token;\n+                                    continue retry;\n+                                }\n+                            case FILE_OVERVIEW:\n+                                ExtractionInfo fileOverviewInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.TRIM);\n+                                String fileOverview \u003d fileOverviewInfo.string;\n+                                if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo !\u003d null) {\n+                                    parser.addWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno());\n+                                }\n+                                token \u003d fileOverviewInfo.token;\n+                                continue retry;\n+                            case LICENSE:\n+                            case PRESERVE:\n+                                ExtractionInfo preserveInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);\n+                                String preserve \u003d preserveInfo.string;\n+                                if (preserve.length() \u003e 0) {\n+                                    if (fileLevelJsDocBuilder !\u003d null) {\n+                                        fileLevelJsDocBuilder.append(preserve);\n+                                    }\n+                                }\n+                                token \u003d preserveInfo.token;\n+                                continue retry;\n+                            case ENUM:\n+                                token \u003d next();\n+                                lineno \u003d stream.getLineno();\n+                                charno \u003d stream.getCharno();\n+                                type \u003d null;\n+                                if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOC) {\n+                                    type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n+                                }\n+                                if (type \u003d\u003d null) {\n+                                    type \u003d createJSTypeExpression(newStringNode(\"number\"));\n+                                }\n+                                if (!jsdocBuilder.recordEnumParameterType(type)) {\n+                                    parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n+                                }\n+                                token \u003d eatTokensUntilEOL(token);\n+                                continue retry;\n+                            case EXPORT:\n+                                if (!jsdocBuilder.recordExport()) {\n+                                    parser.addWarning(\"msg.jsdoc.export\", stream.getLineno(), stream.getCharno());\n+                                }\n+                                token \u003d eatTokensUntilEOL();\n+                                continue retry;\n+                            case EXTENDS:\n+                            case IMPLEMENTS:\n+                                skipEOLs();\n+                                token \u003d next();\n+                                lineno \u003d stream.getLineno();\n+                                charno \u003d stream.getCharno();\n+                                boolean matchingRc \u003d false;\n+                                if (token \u003d\u003d JsDocToken.LC) {\n+                                    token \u003d next();\n+                                    matchingRc \u003d true;\n+                                }\n+                                if (token \u003d\u003d JsDocToken.STRING) {\n+                                    Node typeNode \u003d parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);\n+                                    lineno \u003d stream.getLineno();\n+                                    charno \u003d stream.getCharno();\n+                                    typeNode \u003d wrapNode(Token.BANG, typeNode);\n+                                    if (typeNode !\u003d null \u0026\u0026 !matchingRc) {\n+                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n+                                    }\n+                                    type \u003d createJSTypeExpression(typeNode);\n+                                    if (annotation \u003d\u003d Annotation.EXTENDS) {\n+                                        if (!jsdocBuilder.recordBaseType(type)) {\n+                                            parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n+                                        }\n+                                    } else {\n+                                        Preconditions.checkState(annotation \u003d\u003d Annotation.IMPLEMENTS);\n+                                        if (!jsdocBuilder.recordImplementedInterface(type)) {\n+                                            parser.addWarning(\"msg.jsdoc.implements.duplicate\", lineno, charno);\n+                                        }\n+                                    }\n+                                    token \u003d next();\n+                                    if (matchingRc) {\n+                                        if (token !\u003d JsDocToken.RC) {\n+                                            parser.addWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n+                                        }\n+                                    } else if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOF \u0026\u0026 token !\u003d JsDocToken.EOC) {\n+                                        parser.addWarning(\"msg.end.annotation.expected\", stream.getLineno(), stream.getCharno());\n+                                    }\n+                                } else {\n+                                    parser.addWarning(\"msg.no.type.name\", lineno, charno);\n+                                }\n+                                token \u003d eatTokensUntilEOL(token);\n+                                continue retry;\n+                            case HIDDEN:\n+                                if (!jsdocBuilder.recordHiddenness()) {\n+                                    parser.addWarning(\"msg.jsdoc.hidden\", stream.getLineno(), stream.getCharno());\n+                                }\n+                                token \u003d eatTokensUntilEOL();\n+                                continue retry;\n+                            case NO_ALIAS:\n+                                if (!jsdocBuilder.recordNoAlias()) {\n+                                    parser.addWarning(\"msg.jsdoc.noalias\", stream.getLineno(), stream.getCharno());\n+                                }\n+                                token \u003d eatTokensUntilEOL();\n+                                continue retry;\n+                            case NO_TYPE_CHECK:\n+                                if (!jsdocBuilder.recordNoTypeCheck()) {\n+                                    parser.addWarning(\"msg.jsdoc.nocheck\", stream.getLineno(), stream.getCharno());\n+                                }\n+                                token \u003d eatTokensUntilEOL();\n+                                continue retry;\n+                            case NOT_IMPLEMENTED:\n+                                token \u003d eatTokensUntilEOL();\n+                                continue retry;\n+                            case INHERIT_DOC:\n+                            case OVERRIDE:\n+                                if (!jsdocBuilder.recordOverride()) {\n+                                    parser.addWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno());\n+                                }\n+                                token \u003d eatTokensUntilEOL();\n+                                continue retry;\n+                            case THROWS:\n+                                skipEOLs();\n+                                token \u003d next();\n+                                lineno \u003d stream.getLineno();\n+                                charno \u003d stream.getCharno();\n+                                type \u003d null;\n+                                if (token \u003d\u003d JsDocToken.LC) {\n+                                    type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n+                                    if (type \u003d\u003d null) {\n+                                        token \u003d eatTokensUntilEOL();\n+                                        continue retry;\n+                                    }\n+                                }\n+                                token \u003d current();\n+                                jsdocBuilder.recordThrowType(type);\n+                                ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n+                                String description \u003d descriptionInfo.string;\n+                                if (description.length() \u003e 0) {\n+                                    jsdocBuilder.recordThrowDescription(type, description);\n+                                }\n+                                token \u003d descriptionInfo.token;\n+                                continue retry;\n+                            case PARAM:\n+                                skipEOLs();\n+                                token \u003d next();\n+                                lineno \u003d stream.getLineno();\n+                                charno \u003d stream.getCharno();\n+                                type \u003d null;\n+                                if (token \u003d\u003d JsDocToken.LC) {\n+                                    type \u003d createJSTypeExpression(parseAndRecordParamTypeNode(token));\n+                                    if (type \u003d\u003d null) {\n+                                        token \u003d eatTokensUntilEOL();\n+                                        continue retry;\n+                                    }\n+                                    skipEOLs();\n+                                    token \u003d next();\n+                                    lineno \u003d stream.getLineno();\n+                                    charno \u003d stream.getCharno();\n+                                }\n+                                String name \u003d null;\n+                                if (JsDocToken.STRING !\u003d token) {\n+                                    parser.addWarning(\"msg.missing.variable.name\", lineno, charno);\n+                                } else {\n+                                    name \u003d stream.getString();\n+                                    if (!jsdocBuilder.recordParameter(name, type)) {\n+                                        if (jsdocBuilder.hasParameter(name)) {\n+                                            parser.addWarning(\"msg.dup.variable.name\", name, lineno, charno);\n+                                        } else {\n+                                            parser.addWarning(\"msg.jsdoc.incompat.type\", name, lineno, charno);\n+                                        }\n+                                    }\n+                                }\n+                                if (name \u003d\u003d null) {\n+                                    token \u003d eatTokensUntilEOL(token);\n+                                    continue retry;\n+                                }\n+                                jsdocBuilder.markName(name, lineno, charno);\n+                                ExtractionInfo paramDescriptionInfo \u003d extractMultilineTextualBlock(token);\n+                                String paramDescription \u003d paramDescriptionInfo.string;\n+                                if (paramDescription.length() \u003e 0) {\n+                                    jsdocBuilder.recordParameterDescription(name, paramDescription);\n+                                }\n+                                token \u003d paramDescriptionInfo.token;\n+                                continue retry;\n+                            case PRESERVE_TRY:\n+                                if (!jsdocBuilder.recordPreserveTry()) {\n+                                    parser.addWarning(\"msg.jsdoc.preservertry\", stream.getLineno(), stream.getCharno());\n+                                }\n+                                token \u003d eatTokensUntilEOL();\n+                                continue retry;\n+                            case PRIVATE:\n+                                if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n+                                    parser.addWarning(\"msg.jsdoc.visibility.private\", stream.getLineno(), stream.getCharno());\n+                                }\n+                                token \u003d eatTokensUntilEOL();\n+                                continue retry;\n+                            case PROTECTED:\n+                                if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n+                                    parser.addWarning(\"msg.jsdoc.visibility.protected\", stream.getLineno(), stream.getCharno());\n+                                }\n+                                token \u003d eatTokensUntilEOL();\n+                                continue retry;\n+                            case PUBLIC:\n+                                if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n+                                    parser.addWarning(\"msg.jsdoc.visibility.public\", stream.getLineno(), stream.getCharno());\n+                                }\n+                                token \u003d eatTokensUntilEOL();\n+                                continue retry;\n+                            case NO_SHADOW:\n+                                if (!jsdocBuilder.recordNoShadow()) {\n+                                    parser.addWarning(\"msg.jsdoc.noshadow\", stream.getLineno(), stream.getCharno());\n+                                }\n+                                token \u003d eatTokensUntilEOL();\n+                                continue retry;\n+                            case NO_SIDE_EFFECTS:\n+                                if (!jsdocBuilder.recordNoSideEffects()) {\n+                                    parser.addWarning(\"msg.jsdoc.nosideeffects\", stream.getLineno(), stream.getCharno());\n+                                }\n+                                token \u003d eatTokensUntilEOL();\n+                                continue retry;\n+                            case IMPLICIT_CAST:\n+                                if (!jsdocBuilder.recordImplicitCast()) {\n+                                    parser.addWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno());\n+                                }\n+                                token \u003d eatTokensUntilEOL();\n+                                continue retry;\n+                            case SEE:\n+                                ExtractionInfo referenceInfo \u003d extractSingleLineBlock();\n+                                String reference \u003d referenceInfo.string;\n+                                if (reference.length() \u003d\u003d 0) {\n+                                    parser.addWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno());\n+                                } else {\n+                                    jsdocBuilder.addReference(reference);\n+                                }\n+                                token \u003d referenceInfo.token;\n+                                continue retry;\n+                            case SUPPRESS:\n+                                token \u003d parseSuppressTag(next());\n+                                continue retry;\n+                            case TEMPLATE:\n+                                ExtractionInfo templateInfo \u003d extractSingleLineBlock();\n+                                String templateTypeName \u003d templateInfo.string;\n+                                if (templateTypeName.length() \u003d\u003d 0) {\n+                                    parser.addWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno());\n+                                } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {\n+                                    parser.addWarning(\"msg.jsdoc.template.at.most.once\", stream.getLineno(), stream.getCharno());\n+                                }\n+                                token \u003d templateInfo.token;\n+                                continue retry;\n+                            case VERSION:\n+                                ExtractionInfo versionInfo \u003d extractSingleLineBlock();\n+                                String version \u003d versionInfo.string;\n+                                if (version.length() \u003d\u003d 0) {\n+                                    parser.addWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno());\n+                                } else {\n+                                    if (!jsdocBuilder.recordVersion(version)) {\n+                                        parser.addWarning(\"msg.jsdoc.extraversion\", stream.getLineno(), stream.getCharno());\n+                                    }\n+                                }\n+                                token \u003d versionInfo.token;\n+                                continue retry;\n+                            case DEFINE:\n+                            case RETURN:\n+                            case THIS:\n+                            case TYPE:\n+                            case TYPEDEF:\n+                                skipEOLs();\n+                                lineno \u003d stream.getLineno();\n+                                charno \u003d stream.getCharno();\n+                                token \u003d next();\n+                                Node typeNode \u003d parseAndRecordTypeNode(token, lineno, charno);\n+                                if (annotation \u003d\u003d Annotation.THIS) {\n+                                    typeNode \u003d wrapNode(Token.BANG, typeNode);\n+                                    if (typeNode !\u003d null \u0026\u0026 token !\u003d JsDocToken.LC) {\n+                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n+                                    }\n+                                }\n+                                type \u003d createJSTypeExpression(typeNode);\n+                                if (type \u003d\u003d null) {\n+                                } else {\n+                                    switch(annotation) {\n+                                        case DEFINE:\n+                                            if (!isValidDefineType(typeNode)) {\n+                                                parser.addWarning(\"msg.jsdoc.define.badtype\", lineno, charno);\n+                                            } else if (!jsdocBuilder.recordDefineType(type)) {\n+                                                parser.addWarning(\"msg.jsdoc.define\", lineno, charno);\n+                                            }\n+                                            break;\n+                                        case RETURN:\n+                                            if (!jsdocBuilder.recordReturnType(type)) {\n+                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n+                                                break;\n+                                            }\n+                                            token \u003d current();\n+                                            ExtractionInfo returnDescriptionInfo \u003d extractMultilineTextualBlock(token);\n+                                            String returnDescription \u003d returnDescriptionInfo.string;\n+                                            if (returnDescription.length() \u003e 0) {\n+                                                jsdocBuilder.recordReturnDescription(returnDescription);\n+                                            }\n+                                            token \u003d returnDescriptionInfo.token;\n+                                            continue retry;\n+                                        case THIS:\n+                                            if (!jsdocBuilder.recordThisType(type)) {\n+                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n+                                            }\n+                                            break;\n+                                        case TYPE:\n+                                            if (!jsdocBuilder.recordType(type)) {\n+                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n+                                            }\n+                                            break;\n+                                        case TYPEDEF:\n+                                            if (!jsdocBuilder.recordTypedef(type)) {\n+                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n+                                            }\n+                                            break;\n+                                    }\n+                                    token \u003d eatTokensUntilEOL();\n+                                }\n+                                continue retry;\n+                        }\n+                    }\n+                }\n+                break;\n+            case EOC:\n+                if (hasParsedFileOverviewDocInfo()) {\n+                    fileOverviewJSDocInfo \u003d retrieveAndResetParsedJSDocInfo();\n+                }\n+                return true;\n+            case EOF:\n+                jsdocBuilder.build(null);\n+                parser.addWarning(\"msg.unexpected.eof\", stream.getLineno(), stream.getCharno());\n+                return false;\n+            case EOL:\n+                if (state \u003d\u003d State.SEARCHING_NEWLINE) {\n+                    state \u003d State.SEARCHING_ANNOTATION;\n+                }\n+                token \u003d next();\n+                continue retry;\n+            default:\n+                if (token \u003d\u003d JsDocToken.STAR \u0026\u0026 state \u003d\u003d State.SEARCHING_ANNOTATION) {\n+                    token \u003d next();\n+                    continue retry;\n+                } else {\n+                    state \u003d State.SEARCHING_NEWLINE;\n+                    token \u003d eatTokensUntilEOL();\n+                    continue retry;\n+                }\n+        }\n+        token \u003d next();\n+    }\n+}\n\\ No newline at end of file\n",
      "actualSource": "boolean parse() {\n    int lineno;\n    int charno;\n    JSTypeExpression type;\n    state \u003d State.SEARCHING_ANNOTATION;\n    JsDocToken token \u003d next();\n    ExtractionInfo blockInfo \u003d extractBlockComment(token);\n    token \u003d blockInfo.token;\n    if (blockInfo.string.length() \u003e 0) {\n        jsdocBuilder.recordBlockDescription(blockInfo.string);\n    }\n    retry: for (; ; ) {\n        switch(token) {\n            case ANNOTATION:\n                if (state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                    state \u003d State.SEARCHING_NEWLINE;\n                    lineno \u003d stream.getLineno();\n                    charno \u003d stream.getCharno();\n                    String annotationName \u003d stream.getString();\n                    Annotation annotation \u003d annotationNames.get(annotationName);\n                    if (annotation \u003d\u003d null) {\n                        parser.addWarning(\"msg.bad.jsdoc.tag\", annotationName, stream.getLineno(), stream.getCharno());\n                    } else {\n                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n                        switch(annotation) {\n                            case AUTHOR:\n                                ExtractionInfo authorInfo \u003d extractSingleLineBlock();\n                                String author \u003d authorInfo.string;\n                                if (author.length() \u003d\u003d 0) {\n                                    parser.addWarning(\"msg.jsdoc.authormissing\", stream.getLineno(), stream.getCharno());\n                                } else {\n                                    jsdocBuilder.addAuthor(author);\n                                }\n                                token \u003d authorInfo.token;\n                                continue retry;\n                            case CONSTANT:\n                                if (!jsdocBuilder.recordConstancy()) {\n                                    parser.addWarning(\"msg.jsdoc.const\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case CONSTRUCTOR:\n                                if (!jsdocBuilder.recordConstructor()) {\n                                    if (jsdocBuilder.isInterfaceRecorded()) {\n                                        parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case DEPRECATED:\n                                if (!jsdocBuilder.recordDeprecated()) {\n                                    parser.addWarning(\"msg.jsdoc.deprecated\", stream.getLineno(), stream.getCharno());\n                                }\n                                ExtractionInfo reasonInfo \u003d extractMultilineTextualBlock(token);\n                                String reason \u003d reasonInfo.string;\n                                if (reason.length() \u003e 0) {\n                                    jsdocBuilder.recordDeprecationReason(reason);\n                                }\n                                token \u003d reasonInfo.token;\n                                continue retry;\n                            case INTERFACE:\n                                if (!jsdocBuilder.recordInterface()) {\n                                    if (jsdocBuilder.isConstructorRecorded()) {\n                                        parser.addWarning(\"msg.jsdoc.interface.constructor\", stream.getLineno(), stream.getCharno());\n                                    } else {\n                                        parser.addWarning(\"msg.jsdoc.incompat.type\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case DESC:\n                                if (jsdocBuilder.isDescriptionRecorded()) {\n                                    parser.addWarning(\"msg.jsdoc.desc.extra\", stream.getLineno(), stream.getCharno());\n                                    token \u003d eatTokensUntilEOL();\n                                    continue retry;\n                                } else {\n                                    ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                    String description \u003d descriptionInfo.string;\n                                    jsdocBuilder.recordDescription(description);\n                                    token \u003d descriptionInfo.token;\n                                    continue retry;\n                                }\n                            case FILE_OVERVIEW:\n                                ExtractionInfo fileOverviewInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.TRIM);\n                                String fileOverview \u003d fileOverviewInfo.string;\n                                if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo !\u003d null) {\n                                    parser.addWarning(\"msg.jsdoc.fileoverview.extra\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d fileOverviewInfo.token;\n                                continue retry;\n                            case LICENSE:\n                            case PRESERVE:\n                                ExtractionInfo preserveInfo \u003d extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);\n                                String preserve \u003d preserveInfo.string;\n                                if (preserve.length() \u003e 0) {\n                                    if (fileLevelJsDocBuilder !\u003d null) {\n                                        fileLevelJsDocBuilder.append(preserve);\n                                    }\n                                }\n                                token \u003d preserveInfo.token;\n                                continue retry;\n                            case ENUM:\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                }\n                                if (type \u003d\u003d null) {\n                                    type \u003d createJSTypeExpression(newStringNode(\"number\"));\n                                }\n                                if (!jsdocBuilder.recordEnumParameterType(type)) {\n                                    parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                }\n                                token \u003d eatTokensUntilEOL(token);\n                                continue retry;\n                            case EXPORT:\n                                if (!jsdocBuilder.recordExport()) {\n                                    parser.addWarning(\"msg.jsdoc.export\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case EXTENDS:\n                            case IMPLEMENTS:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                boolean matchingRc \u003d false;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    token \u003d next();\n                                    matchingRc \u003d true;\n                                }\n                                if (token \u003d\u003d JsDocToken.STRING) {\n                                    Node typeNode \u003d parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);\n                                    lineno \u003d stream.getLineno();\n                                    charno \u003d stream.getCharno();\n                                    typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                    if (typeNode !\u003d null \u0026\u0026 !matchingRc) {\n                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                    }\n                                    type \u003d createJSTypeExpression(typeNode);\n                                    if (annotation \u003d\u003d Annotation.EXTENDS) {\n                                        if (!jsdocBuilder.recordBaseType(type)) {\n                                            parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                        }\n                                    } else {\n                                        Preconditions.checkState(annotation \u003d\u003d Annotation.IMPLEMENTS);\n                                        if (!jsdocBuilder.recordImplementedInterface(type)) {\n                                            parser.addWarning(\"msg.jsdoc.implements.duplicate\", lineno, charno);\n                                        }\n                                    }\n                                    token \u003d next();\n                                    if (matchingRc) {\n                                        if (token !\u003d JsDocToken.RC) {\n                                            parser.addWarning(\"msg.jsdoc.missing.rc\", stream.getLineno(), stream.getCharno());\n                                        }\n                                    } else if (token !\u003d JsDocToken.EOL \u0026\u0026 token !\u003d JsDocToken.EOF \u0026\u0026 token !\u003d JsDocToken.EOC) {\n                                        parser.addWarning(\"msg.end.annotation.expected\", stream.getLineno(), stream.getCharno());\n                                    }\n                                } else {\n                                    parser.addWarning(\"msg.no.type.name\", lineno, charno);\n                                }\n                                token \u003d eatTokensUntilEOL(token);\n                                continue retry;\n                            case HIDDEN:\n                                if (!jsdocBuilder.recordHiddenness()) {\n                                    parser.addWarning(\"msg.jsdoc.hidden\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_ALIAS:\n                                if (!jsdocBuilder.recordNoAlias()) {\n                                    parser.addWarning(\"msg.jsdoc.noalias\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_TYPE_CHECK:\n                                if (!jsdocBuilder.recordNoTypeCheck()) {\n                                    parser.addWarning(\"msg.jsdoc.nocheck\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NOT_IMPLEMENTED:\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case INHERIT_DOC:\n                            case OVERRIDE:\n                                if (!jsdocBuilder.recordOverride()) {\n                                    parser.addWarning(\"msg.jsdoc.override\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case THROWS:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordTypeNode(token));\n                                    if (type \u003d\u003d null) {\n                                        token \u003d eatTokensUntilEOL();\n                                        continue retry;\n                                    }\n                                }\n                                token \u003d current();\n                                jsdocBuilder.recordThrowType(type);\n                                ExtractionInfo descriptionInfo \u003d extractMultilineTextualBlock(token);\n                                String description \u003d descriptionInfo.string;\n                                if (description.length() \u003e 0) {\n                                    jsdocBuilder.recordThrowDescription(type, description);\n                                }\n                                token \u003d descriptionInfo.token;\n                                continue retry;\n                            case PARAM:\n                                skipEOLs();\n                                token \u003d next();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                type \u003d null;\n                                if (token \u003d\u003d JsDocToken.LC) {\n                                    type \u003d createJSTypeExpression(parseAndRecordParamTypeNode(token));\n                                    if (type \u003d\u003d null) {\n                                        token \u003d eatTokensUntilEOL();\n                                        continue retry;\n                                    }\n                                    skipEOLs();\n                                    token \u003d next();\n                                    lineno \u003d stream.getLineno();\n                                    charno \u003d stream.getCharno();\n                                }\n                                String name \u003d null;\n                                if (JsDocToken.STRING !\u003d token) {\n                                    parser.addWarning(\"msg.missing.variable.name\", lineno, charno);\n                                } else {\n                                    name \u003d stream.getString();\n                                    if (!jsdocBuilder.recordParameter(name, type)) {\n                                        if (jsdocBuilder.hasParameter(name)) {\n                                            parser.addWarning(\"msg.dup.variable.name\", name, lineno, charno);\n                                        } else {\n                                            parser.addWarning(\"msg.jsdoc.incompat.type\", name, lineno, charno);\n                                        }\n                                    }\n                                }\n                                if (name \u003d\u003d null) {\n                                    token \u003d eatTokensUntilEOL(token);\n                                    continue retry;\n                                }\n                                jsdocBuilder.markName(name, lineno, charno);\n                                ExtractionInfo paramDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                String paramDescription \u003d paramDescriptionInfo.string;\n                                if (paramDescription.length() \u003e 0) {\n                                    jsdocBuilder.recordParameterDescription(name, paramDescription);\n                                }\n                                token \u003d paramDescriptionInfo.token;\n                                continue retry;\n                            case PRESERVE_TRY:\n                                if (!jsdocBuilder.recordPreserveTry()) {\n                                    parser.addWarning(\"msg.jsdoc.preservertry\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PRIVATE:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                                    parser.addWarning(\"msg.jsdoc.visibility.private\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PROTECTED:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                                    parser.addWarning(\"msg.jsdoc.visibility.protected\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case PUBLIC:\n                                if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                                    parser.addWarning(\"msg.jsdoc.visibility.public\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_SHADOW:\n                                if (!jsdocBuilder.recordNoShadow()) {\n                                    parser.addWarning(\"msg.jsdoc.noshadow\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case NO_SIDE_EFFECTS:\n                                if (!jsdocBuilder.recordNoSideEffects()) {\n                                    parser.addWarning(\"msg.jsdoc.nosideeffects\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case IMPLICIT_CAST:\n                                if (!jsdocBuilder.recordImplicitCast()) {\n                                    parser.addWarning(\"msg.jsdoc.implicitcast\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d eatTokensUntilEOL();\n                                continue retry;\n                            case SEE:\n                                ExtractionInfo referenceInfo \u003d extractSingleLineBlock();\n                                String reference \u003d referenceInfo.string;\n                                if (reference.length() \u003d\u003d 0) {\n                                    parser.addWarning(\"msg.jsdoc.seemissing\", stream.getLineno(), stream.getCharno());\n                                } else {\n                                    jsdocBuilder.addReference(reference);\n                                }\n                                token \u003d referenceInfo.token;\n                                continue retry;\n                            case SUPPRESS:\n                                token \u003d parseSuppressTag(next());\n                                continue retry;\n                            case TEMPLATE:\n                                ExtractionInfo templateInfo \u003d extractSingleLineBlock();\n                                String templateTypeName \u003d templateInfo.string;\n                                if (templateTypeName.length() \u003d\u003d 0) {\n                                    parser.addWarning(\"msg.jsdoc.templatemissing\", stream.getLineno(), stream.getCharno());\n                                } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {\n                                    parser.addWarning(\"msg.jsdoc.template.at.most.once\", stream.getLineno(), stream.getCharno());\n                                }\n                                token \u003d templateInfo.token;\n                                continue retry;\n                            case VERSION:\n                                ExtractionInfo versionInfo \u003d extractSingleLineBlock();\n                                String version \u003d versionInfo.string;\n                                if (version.length() \u003d\u003d 0) {\n                                    parser.addWarning(\"msg.jsdoc.versionmissing\", stream.getLineno(), stream.getCharno());\n                                } else {\n                                    if (!jsdocBuilder.recordVersion(version)) {\n                                        parser.addWarning(\"msg.jsdoc.extraversion\", stream.getLineno(), stream.getCharno());\n                                    }\n                                }\n                                token \u003d versionInfo.token;\n                                continue retry;\n                            case DEFINE:\n                            case RETURN:\n                            case THIS:\n                            case TYPE:\n                            case TYPEDEF:\n                                skipEOLs();\n                                lineno \u003d stream.getLineno();\n                                charno \u003d stream.getCharno();\n                                token \u003d next();\n                                Node typeNode \u003d parseAndRecordTypeNode(token, lineno, charno);\n                                if (annotation \u003d\u003d Annotation.THIS) {\n                                    typeNode \u003d wrapNode(Token.BANG, typeNode);\n                                    if (typeNode !\u003d null \u0026\u0026 token !\u003d JsDocToken.LC) {\n                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                                    }\n                                }\n                                type \u003d createJSTypeExpression(typeNode);\n                                if (type \u003d\u003d null) {\n                                } else {\n                                    switch(annotation) {\n                                        case DEFINE:\n                                            if (!isValidDefineType(typeNode)) {\n                                                parser.addWarning(\"msg.jsdoc.define.badtype\", lineno, charno);\n                                            } else if (!jsdocBuilder.recordDefineType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.define\", lineno, charno);\n                                            }\n                                            break;\n                                        case RETURN:\n                                            if (!jsdocBuilder.recordReturnType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                                break;\n                                            }\n                                            token \u003d current();\n                                            ExtractionInfo returnDescriptionInfo \u003d extractMultilineTextualBlock(token);\n                                            String returnDescription \u003d returnDescriptionInfo.string;\n                                            if (returnDescription.length() \u003e 0) {\n                                                jsdocBuilder.recordReturnDescription(returnDescription);\n                                            }\n                                            token \u003d returnDescriptionInfo.token;\n                                            continue retry;\n                                        case THIS:\n                                            if (!jsdocBuilder.recordThisType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                        case TYPE:\n                                            if (!jsdocBuilder.recordType(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                        case TYPEDEF:\n                                            if (!jsdocBuilder.recordTypedef(type)) {\n                                                parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                                            }\n                                            break;\n                                    }\n                                    token \u003d eatTokensUntilEOL();\n                                }\n                                continue retry;\n                        }\n                    }\n                }\n                break;\n            case EOC:\n                if (hasParsedFileOverviewDocInfo()) {\n                    fileOverviewJSDocInfo \u003d retrieveAndResetParsedJSDocInfo();\n                }\n                return true;\n            case EOF:\n                jsdocBuilder.build(null);\n                parser.addWarning(\"msg.unexpected.eof\", stream.getLineno(), stream.getCharno());\n                return false;\n            case EOL:\n                if (state \u003d\u003d State.SEARCHING_NEWLINE) {\n                    state \u003d State.SEARCHING_ANNOTATION;\n                }\n                token \u003d next();\n                continue retry;\n            default:\n                if (token \u003d\u003d JsDocToken.STAR \u0026\u0026 state \u003d\u003d State.SEARCHING_ANNOTATION) {\n                    token \u003d next();\n                    continue retry;\n                } else {\n                    state \u003d State.SEARCHING_NEWLINE;\n                    token \u003d eatTokensUntilEOL();\n                    continue retry;\n                }\n        }\n        token \u003d next();\n    }\n}",
      "path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
      "functionStartLine": 237,
      "functionName": "parse",
      "functionAnnotation": "",
      "functionDoc": "Parses a {@link JSDocInfo} object. This parsing method reads all tokens\nreturned by the {@link JsDocTokenStream#getJsDocToken()} method until the\n{@link JsDocToken#EOC} is returned.\n\n@return @code true} if JSDoc information was correctly parsed,\n    {@code false} otherwise\n"
    }
  }
}