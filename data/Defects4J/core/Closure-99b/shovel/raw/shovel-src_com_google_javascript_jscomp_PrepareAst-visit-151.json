{
  "origin": "codeshovel",
  "repositoryName": "Closure-99b",
  "repositoryPath": "/tmp/Closure-99b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "PrepareAst.java",
  "functionName": "visit",
  "functionId": "$visit___t-NodeTraversal__n-Node__parent-Node",
  "sourceFilePath": "src/com/google/javascript/jscomp/PrepareAst.java",
  "functionAnnotation": "",
  "functionDoc": "In the AST that Rhino gives us, it needs to make a distinction\nbetween jsdoc on the object literal node and jsdoc on the object literal\nvalue. For example,\n\u003cpre\u003e\nvar x \u003d {\n  / JSDOC /\n  a: \u0027b\u0027,\n  c: / JSDOC / \u0027d\u0027\n};\n\u003c/pre\u003e\n\nBut in few narrow cases (in particular, function literals), it\u0027s\na lot easier for us if the doc is attached to the value.\n",
  "functionStartLine": 151,
  "functionEndLine": 227,
  "numCommitsSeen": 7,
  "timeTaken": 748,
  "changeHistory": [
    "9a1ddf5f982e54ecbc3e028dfa84ef9bd07a8044",
    "8ba5e1f86eaf3c31b9279f92823b4fa2a50574a3",
    "6a36f04485599820ff86441accee002b4deec2eb",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3"
  ],
  "changeHistoryShort": {
    "9a1ddf5f982e54ecbc3e028dfa84ef9bd07a8044": "Ymultichange(Ymovefromfile,Ybodychange,Yannotationchange,Ydocchange)",
    "8ba5e1f86eaf3c31b9279f92823b4fa2a50574a3": "Ybodychange",
    "6a36f04485599820ff86441accee002b4deec2eb": "Ybodychange",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "9a1ddf5f982e54ecbc3e028dfa84ef9bd07a8044": {
      "type": "Ymultichange(Ymovefromfile,Ybodychange,Yannotationchange,Ydocchange)",
      "commitMessage": "Merge NodeTypeNormalizer and CodingConventionAnnotator into\na single pass. (Nick)\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@116 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "2/24/10, 8:37 PM",
      "commitName": "9a1ddf5f982e54ecbc3e028dfa84ef9bd07a8044",
      "commitAuthor": "Nicholas.J.Santos",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "Merge NodeTypeNormalizer and CodingConventionAnnotator into\na single pass. (Nick)\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@116 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "2/24/10, 8:37 PM",
          "commitName": "9a1ddf5f982e54ecbc3e028dfa84ef9bd07a8044",
          "commitAuthor": "Nicholas.J.Santos",
          "commitDateOld": "2/24/10, 4:14 PM",
          "commitNameOld": "4922461babcc37fb037d2a6db3fcb33fe4127a60",
          "commitAuthorOld": "Nicholas.J.Santos",
          "daysBetweenCommits": 0.18,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public void visit(NodeTraversal t, Node n, Node parent) {\n    int nType \u003d n.getType();\n    switch(nType) {\n        case Token.NAME:\n        case Token.STRING:\n            String nString \u003d n.getString();\n            if (nType \u003d\u003d Token.NAME \u0026\u0026 n.getParent().getType() \u003d\u003d Token.CALL \u0026\u0026 \"eval\".equals(nString)) {\n                n.putBooleanProp(Node.DIRECT_EVAL, true);\n            }\n            if (convention.isConstant(nString)) {\n                n.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n            }\n            break;\n        case Token.FUNCTION:\n            JSDocInfo fnInfo \u003d n.getJSDocInfo();\n            if (fnInfo \u003d\u003d null) {\n                if (parent.getType() \u003d\u003d Token.ASSIGN) {\n                    fnInfo \u003d parent.getJSDocInfo();\n                } else if (parent.getType() \u003d\u003d Token.NAME) {\n                    fnInfo \u003d parent.getParent().getJSDocInfo();\n                }\n            }\n            Node args \u003d n.getFirstChild().getNext();\n            for (Node arg \u003d args.getFirstChild(); arg !\u003d null; arg \u003d arg.getNext()) {\n                String argName \u003d arg.getString();\n                JSTypeExpression typeExpr \u003d fnInfo \u003d\u003d null ? null : fnInfo.getParameterType(argName);\n                if (convention.isOptionalParameter(arg) || typeExpr !\u003d null \u0026\u0026 typeExpr.isOptionalArg()) {\n                    arg.putBooleanProp(Node.IS_OPTIONAL_PARAM, true);\n                }\n                if (convention.isVarArgsParameter(arg) || typeExpr !\u003d null \u0026\u0026 typeExpr.isVarArgs()) {\n                    arg.putBooleanProp(Node.IS_VAR_ARGS_PARAM, true);\n                }\n            }\n            break;\n        case Token.OBJECTLIT:\n            if (n.getType() \u003d\u003d Token.OBJECTLIT) {\n                for (Node key \u003d n.getFirstChild(); key !\u003d null; key \u003d key.getNext().getNext()) {\n                    Node value \u003d key.getNext();\n                    if (key.getJSDocInfo() !\u003d null \u0026\u0026 key.getNext().getType() \u003d\u003d Token.FUNCTION) {\n                        value.setJSDocInfo(key.getJSDocInfo());\n                    }\n                }\n            }\n            break;\n    }\n    if (n.getJSDocInfo() !\u003d null \u0026\u0026 n.getJSDocInfo().isJavaDispatch()) {\n        if (n.getType() \u003d\u003d Token.ASSIGN) {\n            Node fnNode \u003d n.getLastChild();\n            Preconditions.checkState(fnNode.getType() \u003d\u003d Token.FUNCTION);\n            fnNode.putBooleanProp(Node.IS_DISPATCHER, true);\n        }\n    }\n}",
          "path": "src/com/google/javascript/jscomp/PrepareAst.java",
          "functionStartLine": 150,
          "functionName": "visit",
          "functionAnnotation": "",
          "functionDoc": "In the AST that Rhino gives us, it needs to make a distinction\nbetween jsdoc on the object literal node and jsdoc on the object literal\nvalue. For example,\n\u003cpre\u003e\nvar x \u003d {\n  / JSDOC /\n  a: \u0027b\u0027,\n  c: / JSDOC / \u0027d\u0027\n};\n\u003c/pre\u003e\n\nBut in few narrow cases (in particular, function literals), it\u0027s\na lot easier for us if the doc is attached to the value.\n",
          "diff": "@@ -1,37 +1,53 @@\n-@Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n     int nType \u003d n.getType();\n     switch(nType) {\n         case Token.NAME:\n         case Token.STRING:\n             String nString \u003d n.getString();\n             if (nType \u003d\u003d Token.NAME \u0026\u0026 n.getParent().getType() \u003d\u003d Token.CALL \u0026\u0026 \"eval\".equals(nString)) {\n                 n.putBooleanProp(Node.DIRECT_EVAL, true);\n             }\n             if (convention.isConstant(nString)) {\n                 n.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n             }\n             break;\n         case Token.FUNCTION:\n             JSDocInfo fnInfo \u003d n.getJSDocInfo();\n             if (fnInfo \u003d\u003d null) {\n                 if (parent.getType() \u003d\u003d Token.ASSIGN) {\n                     fnInfo \u003d parent.getJSDocInfo();\n                 } else if (parent.getType() \u003d\u003d Token.NAME) {\n                     fnInfo \u003d parent.getParent().getJSDocInfo();\n                 }\n             }\n             Node args \u003d n.getFirstChild().getNext();\n             for (Node arg \u003d args.getFirstChild(); arg !\u003d null; arg \u003d arg.getNext()) {\n                 String argName \u003d arg.getString();\n                 JSTypeExpression typeExpr \u003d fnInfo \u003d\u003d null ? null : fnInfo.getParameterType(argName);\n                 if (convention.isOptionalParameter(arg) || typeExpr !\u003d null \u0026\u0026 typeExpr.isOptionalArg()) {\n                     arg.putBooleanProp(Node.IS_OPTIONAL_PARAM, true);\n                 }\n                 if (convention.isVarArgsParameter(arg) || typeExpr !\u003d null \u0026\u0026 typeExpr.isVarArgs()) {\n                     arg.putBooleanProp(Node.IS_VAR_ARGS_PARAM, true);\n                 }\n             }\n             break;\n+        case Token.OBJECTLIT:\n+            if (n.getType() \u003d\u003d Token.OBJECTLIT) {\n+                for (Node key \u003d n.getFirstChild(); key !\u003d null; key \u003d key.getNext().getNext()) {\n+                    Node value \u003d key.getNext();\n+                    if (key.getJSDocInfo() !\u003d null \u0026\u0026 key.getNext().getType() \u003d\u003d Token.FUNCTION) {\n+                        value.setJSDocInfo(key.getJSDocInfo());\n+                    }\n+                }\n+            }\n+            break;\n+    }\n+    if (n.getJSDocInfo() !\u003d null \u0026\u0026 n.getJSDocInfo().isJavaDispatch()) {\n+        if (n.getType() \u003d\u003d Token.ASSIGN) {\n+            Node fnNode \u003d n.getLastChild();\n+            Preconditions.checkState(fnNode.getType() \u003d\u003d Token.FUNCTION);\n+            fnNode.putBooleanProp(Node.IS_DISPATCHER, true);\n+        }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldPath": "src/com/google/javascript/jscomp/CodingConventionAnnotator.java",
            "newPath": "src/com/google/javascript/jscomp/PrepareAst.java",
            "oldMethodName": "visit",
            "newMethodName": "visit"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Merge NodeTypeNormalizer and CodingConventionAnnotator into\na single pass. (Nick)\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@116 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "2/24/10, 8:37 PM",
          "commitName": "9a1ddf5f982e54ecbc3e028dfa84ef9bd07a8044",
          "commitAuthor": "Nicholas.J.Santos",
          "commitDateOld": "2/24/10, 4:14 PM",
          "commitNameOld": "4922461babcc37fb037d2a6db3fcb33fe4127a60",
          "commitAuthorOld": "Nicholas.J.Santos",
          "daysBetweenCommits": 0.18,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public void visit(NodeTraversal t, Node n, Node parent) {\n    int nType \u003d n.getType();\n    switch(nType) {\n        case Token.NAME:\n        case Token.STRING:\n            String nString \u003d n.getString();\n            if (nType \u003d\u003d Token.NAME \u0026\u0026 n.getParent().getType() \u003d\u003d Token.CALL \u0026\u0026 \"eval\".equals(nString)) {\n                n.putBooleanProp(Node.DIRECT_EVAL, true);\n            }\n            if (convention.isConstant(nString)) {\n                n.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n            }\n            break;\n        case Token.FUNCTION:\n            JSDocInfo fnInfo \u003d n.getJSDocInfo();\n            if (fnInfo \u003d\u003d null) {\n                if (parent.getType() \u003d\u003d Token.ASSIGN) {\n                    fnInfo \u003d parent.getJSDocInfo();\n                } else if (parent.getType() \u003d\u003d Token.NAME) {\n                    fnInfo \u003d parent.getParent().getJSDocInfo();\n                }\n            }\n            Node args \u003d n.getFirstChild().getNext();\n            for (Node arg \u003d args.getFirstChild(); arg !\u003d null; arg \u003d arg.getNext()) {\n                String argName \u003d arg.getString();\n                JSTypeExpression typeExpr \u003d fnInfo \u003d\u003d null ? null : fnInfo.getParameterType(argName);\n                if (convention.isOptionalParameter(arg) || typeExpr !\u003d null \u0026\u0026 typeExpr.isOptionalArg()) {\n                    arg.putBooleanProp(Node.IS_OPTIONAL_PARAM, true);\n                }\n                if (convention.isVarArgsParameter(arg) || typeExpr !\u003d null \u0026\u0026 typeExpr.isVarArgs()) {\n                    arg.putBooleanProp(Node.IS_VAR_ARGS_PARAM, true);\n                }\n            }\n            break;\n        case Token.OBJECTLIT:\n            if (n.getType() \u003d\u003d Token.OBJECTLIT) {\n                for (Node key \u003d n.getFirstChild(); key !\u003d null; key \u003d key.getNext().getNext()) {\n                    Node value \u003d key.getNext();\n                    if (key.getJSDocInfo() !\u003d null \u0026\u0026 key.getNext().getType() \u003d\u003d Token.FUNCTION) {\n                        value.setJSDocInfo(key.getJSDocInfo());\n                    }\n                }\n            }\n            break;\n    }\n    if (n.getJSDocInfo() !\u003d null \u0026\u0026 n.getJSDocInfo().isJavaDispatch()) {\n        if (n.getType() \u003d\u003d Token.ASSIGN) {\n            Node fnNode \u003d n.getLastChild();\n            Preconditions.checkState(fnNode.getType() \u003d\u003d Token.FUNCTION);\n            fnNode.putBooleanProp(Node.IS_DISPATCHER, true);\n        }\n    }\n}",
          "path": "src/com/google/javascript/jscomp/PrepareAst.java",
          "functionStartLine": 150,
          "functionName": "visit",
          "functionAnnotation": "",
          "functionDoc": "In the AST that Rhino gives us, it needs to make a distinction\nbetween jsdoc on the object literal node and jsdoc on the object literal\nvalue. For example,\n\u003cpre\u003e\nvar x \u003d {\n  / JSDOC /\n  a: \u0027b\u0027,\n  c: / JSDOC / \u0027d\u0027\n};\n\u003c/pre\u003e\n\nBut in few narrow cases (in particular, function literals), it\u0027s\na lot easier for us if the doc is attached to the value.\n",
          "diff": "@@ -1,37 +1,53 @@\n-@Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n     int nType \u003d n.getType();\n     switch(nType) {\n         case Token.NAME:\n         case Token.STRING:\n             String nString \u003d n.getString();\n             if (nType \u003d\u003d Token.NAME \u0026\u0026 n.getParent().getType() \u003d\u003d Token.CALL \u0026\u0026 \"eval\".equals(nString)) {\n                 n.putBooleanProp(Node.DIRECT_EVAL, true);\n             }\n             if (convention.isConstant(nString)) {\n                 n.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n             }\n             break;\n         case Token.FUNCTION:\n             JSDocInfo fnInfo \u003d n.getJSDocInfo();\n             if (fnInfo \u003d\u003d null) {\n                 if (parent.getType() \u003d\u003d Token.ASSIGN) {\n                     fnInfo \u003d parent.getJSDocInfo();\n                 } else if (parent.getType() \u003d\u003d Token.NAME) {\n                     fnInfo \u003d parent.getParent().getJSDocInfo();\n                 }\n             }\n             Node args \u003d n.getFirstChild().getNext();\n             for (Node arg \u003d args.getFirstChild(); arg !\u003d null; arg \u003d arg.getNext()) {\n                 String argName \u003d arg.getString();\n                 JSTypeExpression typeExpr \u003d fnInfo \u003d\u003d null ? null : fnInfo.getParameterType(argName);\n                 if (convention.isOptionalParameter(arg) || typeExpr !\u003d null \u0026\u0026 typeExpr.isOptionalArg()) {\n                     arg.putBooleanProp(Node.IS_OPTIONAL_PARAM, true);\n                 }\n                 if (convention.isVarArgsParameter(arg) || typeExpr !\u003d null \u0026\u0026 typeExpr.isVarArgs()) {\n                     arg.putBooleanProp(Node.IS_VAR_ARGS_PARAM, true);\n                 }\n             }\n             break;\n+        case Token.OBJECTLIT:\n+            if (n.getType() \u003d\u003d Token.OBJECTLIT) {\n+                for (Node key \u003d n.getFirstChild(); key !\u003d null; key \u003d key.getNext().getNext()) {\n+                    Node value \u003d key.getNext();\n+                    if (key.getJSDocInfo() !\u003d null \u0026\u0026 key.getNext().getType() \u003d\u003d Token.FUNCTION) {\n+                        value.setJSDocInfo(key.getJSDocInfo());\n+                    }\n+                }\n+            }\n+            break;\n+    }\n+    if (n.getJSDocInfo() !\u003d null \u0026\u0026 n.getJSDocInfo().isJavaDispatch()) {\n+        if (n.getType() \u003d\u003d Token.ASSIGN) {\n+            Node fnNode \u003d n.getLastChild();\n+            Preconditions.checkState(fnNode.getType() \u003d\u003d Token.FUNCTION);\n+            fnNode.putBooleanProp(Node.IS_DISPATCHER, true);\n+        }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Yannotationchange",
          "commitMessage": "Merge NodeTypeNormalizer and CodingConventionAnnotator into\na single pass. (Nick)\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@116 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "2/24/10, 8:37 PM",
          "commitName": "9a1ddf5f982e54ecbc3e028dfa84ef9bd07a8044",
          "commitAuthor": "Nicholas.J.Santos",
          "commitDateOld": "2/24/10, 4:14 PM",
          "commitNameOld": "4922461babcc37fb037d2a6db3fcb33fe4127a60",
          "commitAuthorOld": "Nicholas.J.Santos",
          "daysBetweenCommits": 0.18,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public void visit(NodeTraversal t, Node n, Node parent) {\n    int nType \u003d n.getType();\n    switch(nType) {\n        case Token.NAME:\n        case Token.STRING:\n            String nString \u003d n.getString();\n            if (nType \u003d\u003d Token.NAME \u0026\u0026 n.getParent().getType() \u003d\u003d Token.CALL \u0026\u0026 \"eval\".equals(nString)) {\n                n.putBooleanProp(Node.DIRECT_EVAL, true);\n            }\n            if (convention.isConstant(nString)) {\n                n.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n            }\n            break;\n        case Token.FUNCTION:\n            JSDocInfo fnInfo \u003d n.getJSDocInfo();\n            if (fnInfo \u003d\u003d null) {\n                if (parent.getType() \u003d\u003d Token.ASSIGN) {\n                    fnInfo \u003d parent.getJSDocInfo();\n                } else if (parent.getType() \u003d\u003d Token.NAME) {\n                    fnInfo \u003d parent.getParent().getJSDocInfo();\n                }\n            }\n            Node args \u003d n.getFirstChild().getNext();\n            for (Node arg \u003d args.getFirstChild(); arg !\u003d null; arg \u003d arg.getNext()) {\n                String argName \u003d arg.getString();\n                JSTypeExpression typeExpr \u003d fnInfo \u003d\u003d null ? null : fnInfo.getParameterType(argName);\n                if (convention.isOptionalParameter(arg) || typeExpr !\u003d null \u0026\u0026 typeExpr.isOptionalArg()) {\n                    arg.putBooleanProp(Node.IS_OPTIONAL_PARAM, true);\n                }\n                if (convention.isVarArgsParameter(arg) || typeExpr !\u003d null \u0026\u0026 typeExpr.isVarArgs()) {\n                    arg.putBooleanProp(Node.IS_VAR_ARGS_PARAM, true);\n                }\n            }\n            break;\n        case Token.OBJECTLIT:\n            if (n.getType() \u003d\u003d Token.OBJECTLIT) {\n                for (Node key \u003d n.getFirstChild(); key !\u003d null; key \u003d key.getNext().getNext()) {\n                    Node value \u003d key.getNext();\n                    if (key.getJSDocInfo() !\u003d null \u0026\u0026 key.getNext().getType() \u003d\u003d Token.FUNCTION) {\n                        value.setJSDocInfo(key.getJSDocInfo());\n                    }\n                }\n            }\n            break;\n    }\n    if (n.getJSDocInfo() !\u003d null \u0026\u0026 n.getJSDocInfo().isJavaDispatch()) {\n        if (n.getType() \u003d\u003d Token.ASSIGN) {\n            Node fnNode \u003d n.getLastChild();\n            Preconditions.checkState(fnNode.getType() \u003d\u003d Token.FUNCTION);\n            fnNode.putBooleanProp(Node.IS_DISPATCHER, true);\n        }\n    }\n}",
          "path": "src/com/google/javascript/jscomp/PrepareAst.java",
          "functionStartLine": 150,
          "functionName": "visit",
          "functionAnnotation": "",
          "functionDoc": "In the AST that Rhino gives us, it needs to make a distinction\nbetween jsdoc on the object literal node and jsdoc on the object literal\nvalue. For example,\n\u003cpre\u003e\nvar x \u003d {\n  / JSDOC /\n  a: \u0027b\u0027,\n  c: / JSDOC / \u0027d\u0027\n};\n\u003c/pre\u003e\n\nBut in few narrow cases (in particular, function literals), it\u0027s\na lot easier for us if the doc is attached to the value.\n",
          "diff": "@@ -1,37 +1,53 @@\n-@Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n     int nType \u003d n.getType();\n     switch(nType) {\n         case Token.NAME:\n         case Token.STRING:\n             String nString \u003d n.getString();\n             if (nType \u003d\u003d Token.NAME \u0026\u0026 n.getParent().getType() \u003d\u003d Token.CALL \u0026\u0026 \"eval\".equals(nString)) {\n                 n.putBooleanProp(Node.DIRECT_EVAL, true);\n             }\n             if (convention.isConstant(nString)) {\n                 n.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n             }\n             break;\n         case Token.FUNCTION:\n             JSDocInfo fnInfo \u003d n.getJSDocInfo();\n             if (fnInfo \u003d\u003d null) {\n                 if (parent.getType() \u003d\u003d Token.ASSIGN) {\n                     fnInfo \u003d parent.getJSDocInfo();\n                 } else if (parent.getType() \u003d\u003d Token.NAME) {\n                     fnInfo \u003d parent.getParent().getJSDocInfo();\n                 }\n             }\n             Node args \u003d n.getFirstChild().getNext();\n             for (Node arg \u003d args.getFirstChild(); arg !\u003d null; arg \u003d arg.getNext()) {\n                 String argName \u003d arg.getString();\n                 JSTypeExpression typeExpr \u003d fnInfo \u003d\u003d null ? null : fnInfo.getParameterType(argName);\n                 if (convention.isOptionalParameter(arg) || typeExpr !\u003d null \u0026\u0026 typeExpr.isOptionalArg()) {\n                     arg.putBooleanProp(Node.IS_OPTIONAL_PARAM, true);\n                 }\n                 if (convention.isVarArgsParameter(arg) || typeExpr !\u003d null \u0026\u0026 typeExpr.isVarArgs()) {\n                     arg.putBooleanProp(Node.IS_VAR_ARGS_PARAM, true);\n                 }\n             }\n             break;\n+        case Token.OBJECTLIT:\n+            if (n.getType() \u003d\u003d Token.OBJECTLIT) {\n+                for (Node key \u003d n.getFirstChild(); key !\u003d null; key \u003d key.getNext().getNext()) {\n+                    Node value \u003d key.getNext();\n+                    if (key.getJSDocInfo() !\u003d null \u0026\u0026 key.getNext().getType() \u003d\u003d Token.FUNCTION) {\n+                        value.setJSDocInfo(key.getJSDocInfo());\n+                    }\n+                }\n+            }\n+            break;\n+    }\n+    if (n.getJSDocInfo() !\u003d null \u0026\u0026 n.getJSDocInfo().isJavaDispatch()) {\n+        if (n.getType() \u003d\u003d Token.ASSIGN) {\n+            Node fnNode \u003d n.getLastChild();\n+            Preconditions.checkState(fnNode.getType() \u003d\u003d Token.FUNCTION);\n+            fnNode.putBooleanProp(Node.IS_DISPATCHER, true);\n+        }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "@Override",
            "newValue": ""
          }
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Merge NodeTypeNormalizer and CodingConventionAnnotator into\na single pass. (Nick)\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@116 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "2/24/10, 8:37 PM",
          "commitName": "9a1ddf5f982e54ecbc3e028dfa84ef9bd07a8044",
          "commitAuthor": "Nicholas.J.Santos",
          "commitDateOld": "2/24/10, 4:14 PM",
          "commitNameOld": "4922461babcc37fb037d2a6db3fcb33fe4127a60",
          "commitAuthorOld": "Nicholas.J.Santos",
          "daysBetweenCommits": 0.18,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public void visit(NodeTraversal t, Node n, Node parent) {\n    int nType \u003d n.getType();\n    switch(nType) {\n        case Token.NAME:\n        case Token.STRING:\n            String nString \u003d n.getString();\n            if (nType \u003d\u003d Token.NAME \u0026\u0026 n.getParent().getType() \u003d\u003d Token.CALL \u0026\u0026 \"eval\".equals(nString)) {\n                n.putBooleanProp(Node.DIRECT_EVAL, true);\n            }\n            if (convention.isConstant(nString)) {\n                n.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n            }\n            break;\n        case Token.FUNCTION:\n            JSDocInfo fnInfo \u003d n.getJSDocInfo();\n            if (fnInfo \u003d\u003d null) {\n                if (parent.getType() \u003d\u003d Token.ASSIGN) {\n                    fnInfo \u003d parent.getJSDocInfo();\n                } else if (parent.getType() \u003d\u003d Token.NAME) {\n                    fnInfo \u003d parent.getParent().getJSDocInfo();\n                }\n            }\n            Node args \u003d n.getFirstChild().getNext();\n            for (Node arg \u003d args.getFirstChild(); arg !\u003d null; arg \u003d arg.getNext()) {\n                String argName \u003d arg.getString();\n                JSTypeExpression typeExpr \u003d fnInfo \u003d\u003d null ? null : fnInfo.getParameterType(argName);\n                if (convention.isOptionalParameter(arg) || typeExpr !\u003d null \u0026\u0026 typeExpr.isOptionalArg()) {\n                    arg.putBooleanProp(Node.IS_OPTIONAL_PARAM, true);\n                }\n                if (convention.isVarArgsParameter(arg) || typeExpr !\u003d null \u0026\u0026 typeExpr.isVarArgs()) {\n                    arg.putBooleanProp(Node.IS_VAR_ARGS_PARAM, true);\n                }\n            }\n            break;\n        case Token.OBJECTLIT:\n            if (n.getType() \u003d\u003d Token.OBJECTLIT) {\n                for (Node key \u003d n.getFirstChild(); key !\u003d null; key \u003d key.getNext().getNext()) {\n                    Node value \u003d key.getNext();\n                    if (key.getJSDocInfo() !\u003d null \u0026\u0026 key.getNext().getType() \u003d\u003d Token.FUNCTION) {\n                        value.setJSDocInfo(key.getJSDocInfo());\n                    }\n                }\n            }\n            break;\n    }\n    if (n.getJSDocInfo() !\u003d null \u0026\u0026 n.getJSDocInfo().isJavaDispatch()) {\n        if (n.getType() \u003d\u003d Token.ASSIGN) {\n            Node fnNode \u003d n.getLastChild();\n            Preconditions.checkState(fnNode.getType() \u003d\u003d Token.FUNCTION);\n            fnNode.putBooleanProp(Node.IS_DISPATCHER, true);\n        }\n    }\n}",
          "path": "src/com/google/javascript/jscomp/PrepareAst.java",
          "functionStartLine": 150,
          "functionName": "visit",
          "functionAnnotation": "",
          "functionDoc": "In the AST that Rhino gives us, it needs to make a distinction\nbetween jsdoc on the object literal node and jsdoc on the object literal\nvalue. For example,\n\u003cpre\u003e\nvar x \u003d {\n  / JSDOC /\n  a: \u0027b\u0027,\n  c: / JSDOC / \u0027d\u0027\n};\n\u003c/pre\u003e\n\nBut in few narrow cases (in particular, function literals), it\u0027s\na lot easier for us if the doc is attached to the value.\n",
          "diff": "@@ -1,37 +1,53 @@\n-@Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n     int nType \u003d n.getType();\n     switch(nType) {\n         case Token.NAME:\n         case Token.STRING:\n             String nString \u003d n.getString();\n             if (nType \u003d\u003d Token.NAME \u0026\u0026 n.getParent().getType() \u003d\u003d Token.CALL \u0026\u0026 \"eval\".equals(nString)) {\n                 n.putBooleanProp(Node.DIRECT_EVAL, true);\n             }\n             if (convention.isConstant(nString)) {\n                 n.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n             }\n             break;\n         case Token.FUNCTION:\n             JSDocInfo fnInfo \u003d n.getJSDocInfo();\n             if (fnInfo \u003d\u003d null) {\n                 if (parent.getType() \u003d\u003d Token.ASSIGN) {\n                     fnInfo \u003d parent.getJSDocInfo();\n                 } else if (parent.getType() \u003d\u003d Token.NAME) {\n                     fnInfo \u003d parent.getParent().getJSDocInfo();\n                 }\n             }\n             Node args \u003d n.getFirstChild().getNext();\n             for (Node arg \u003d args.getFirstChild(); arg !\u003d null; arg \u003d arg.getNext()) {\n                 String argName \u003d arg.getString();\n                 JSTypeExpression typeExpr \u003d fnInfo \u003d\u003d null ? null : fnInfo.getParameterType(argName);\n                 if (convention.isOptionalParameter(arg) || typeExpr !\u003d null \u0026\u0026 typeExpr.isOptionalArg()) {\n                     arg.putBooleanProp(Node.IS_OPTIONAL_PARAM, true);\n                 }\n                 if (convention.isVarArgsParameter(arg) || typeExpr !\u003d null \u0026\u0026 typeExpr.isVarArgs()) {\n                     arg.putBooleanProp(Node.IS_VAR_ARGS_PARAM, true);\n                 }\n             }\n             break;\n+        case Token.OBJECTLIT:\n+            if (n.getType() \u003d\u003d Token.OBJECTLIT) {\n+                for (Node key \u003d n.getFirstChild(); key !\u003d null; key \u003d key.getNext().getNext()) {\n+                    Node value \u003d key.getNext();\n+                    if (key.getJSDocInfo() !\u003d null \u0026\u0026 key.getNext().getType() \u003d\u003d Token.FUNCTION) {\n+                        value.setJSDocInfo(key.getJSDocInfo());\n+                    }\n+                }\n+            }\n+            break;\n+    }\n+    if (n.getJSDocInfo() !\u003d null \u0026\u0026 n.getJSDocInfo().isJavaDispatch()) {\n+        if (n.getType() \u003d\u003d Token.ASSIGN) {\n+            Node fnNode \u003d n.getLastChild();\n+            Preconditions.checkState(fnNode.getType() \u003d\u003d Token.FUNCTION);\n+            fnNode.putBooleanProp(Node.IS_DISPATCHER, true);\n+        }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "",
            "newValue": "In the AST that Rhino gives us, it needs to make a distinction\nbetween jsdoc on the object literal node and jsdoc on the object literal\nvalue. For example,\n\u003cpre\u003e\nvar x \u003d {\n  / JSDOC /\n  a: \u0027b\u0027,\n  c: / JSDOC / \u0027d\u0027\n};\n\u003c/pre\u003e\n\nBut in few narrow cases (in particular, function literals), it\u0027s\na lot easier for us if the doc is attached to the value.\n"
          }
        }
      ]
    },
    "8ba5e1f86eaf3c31b9279f92823b4fa2a50574a3": {
      "type": "Ybodychange",
      "commitMessage": "Print indirect calls to eval correctly (issue 81)\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@79 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "1/27/10, 5:22 PM",
      "commitName": "8ba5e1f86eaf3c31b9279f92823b4fa2a50574a3",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "11/11/09, 11:05 AM",
      "commitNameOld": "6a36f04485599820ff86441accee002b4deec2eb",
      "commitAuthorOld": "nicholas.j.santos@gmail.com",
      "daysBetweenCommits": 77.26,
      "commitsBetweenForRepo": 51,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    int nType \u003d n.getType();\n    switch(nType) {\n        case Token.NAME:\n        case Token.STRING:\n            String nString \u003d n.getString();\n            if (nType \u003d\u003d Token.NAME \u0026\u0026 n.getParent().getType() \u003d\u003d Token.CALL \u0026\u0026 \"eval\".equals(nString)) {\n                n.putBooleanProp(Node.DIRECT_EVAL, true);\n            }\n            if (convention.isConstant(nString)) {\n                n.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n            }\n            break;\n        case Token.FUNCTION:\n            JSDocInfo fnInfo \u003d n.getJSDocInfo();\n            if (fnInfo \u003d\u003d null) {\n                if (parent.getType() \u003d\u003d Token.ASSIGN) {\n                    fnInfo \u003d parent.getJSDocInfo();\n                } else if (parent.getType() \u003d\u003d Token.NAME) {\n                    fnInfo \u003d parent.getParent().getJSDocInfo();\n                }\n            }\n            Node args \u003d n.getFirstChild().getNext();\n            for (Node arg \u003d args.getFirstChild(); arg !\u003d null; arg \u003d arg.getNext()) {\n                String argName \u003d arg.getString();\n                JSTypeExpression typeExpr \u003d fnInfo \u003d\u003d null ? null : fnInfo.getParameterType(argName);\n                if (convention.isOptionalParameter(arg) || typeExpr !\u003d null \u0026\u0026 typeExpr.isOptionalArg()) {\n                    arg.putBooleanProp(Node.IS_OPTIONAL_PARAM, true);\n                }\n                if (convention.isVarArgsParameter(arg) || typeExpr !\u003d null \u0026\u0026 typeExpr.isVarArgs()) {\n                    arg.putBooleanProp(Node.IS_VAR_ARGS_PARAM, true);\n                }\n            }\n            break;\n    }\n}",
      "path": "src/com/google/javascript/jscomp/CodingConventionAnnotator.java",
      "functionStartLine": 56,
      "functionName": "visit",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,32 +1,37 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n+    int nType \u003d n.getType();\n+    switch(nType) {\n         case Token.NAME:\n         case Token.STRING:\n-            if (convention.isConstant(n.getString())) {\n+            String nString \u003d n.getString();\n+            if (nType \u003d\u003d Token.NAME \u0026\u0026 n.getParent().getType() \u003d\u003d Token.CALL \u0026\u0026 \"eval\".equals(nString)) {\n+                n.putBooleanProp(Node.DIRECT_EVAL, true);\n+            }\n+            if (convention.isConstant(nString)) {\n                 n.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n             }\n             break;\n         case Token.FUNCTION:\n             JSDocInfo fnInfo \u003d n.getJSDocInfo();\n             if (fnInfo \u003d\u003d null) {\n                 if (parent.getType() \u003d\u003d Token.ASSIGN) {\n                     fnInfo \u003d parent.getJSDocInfo();\n                 } else if (parent.getType() \u003d\u003d Token.NAME) {\n                     fnInfo \u003d parent.getParent().getJSDocInfo();\n                 }\n             }\n             Node args \u003d n.getFirstChild().getNext();\n             for (Node arg \u003d args.getFirstChild(); arg !\u003d null; arg \u003d arg.getNext()) {\n                 String argName \u003d arg.getString();\n                 JSTypeExpression typeExpr \u003d fnInfo \u003d\u003d null ? null : fnInfo.getParameterType(argName);\n                 if (convention.isOptionalParameter(arg) || typeExpr !\u003d null \u0026\u0026 typeExpr.isOptionalArg()) {\n                     arg.putBooleanProp(Node.IS_OPTIONAL_PARAM, true);\n                 }\n                 if (convention.isVarArgsParameter(arg) || typeExpr !\u003d null \u0026\u0026 typeExpr.isVarArgs()) {\n                     arg.putBooleanProp(Node.IS_VAR_ARGS_PARAM, true);\n                 }\n             }\n             break;\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6a36f04485599820ff86441accee002b4deec2eb": {
      "type": "Ybodychange",
      "commitMessage": "Fixes for issues 14 and 16.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@7 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/11/09, 11:05 AM",
      "commitName": "6a36f04485599820ff86441accee002b4deec2eb",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "commitDateOld": "11/3/09, 3:51 PM",
      "commitNameOld": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthorOld": "nicholas.j.santos@gmail.com",
      "daysBetweenCommits": 7.8,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.NAME:\n        case Token.STRING:\n            if (convention.isConstant(n.getString())) {\n                n.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n            }\n            break;\n        case Token.FUNCTION:\n            JSDocInfo fnInfo \u003d n.getJSDocInfo();\n            if (fnInfo \u003d\u003d null) {\n                if (parent.getType() \u003d\u003d Token.ASSIGN) {\n                    fnInfo \u003d parent.getJSDocInfo();\n                } else if (parent.getType() \u003d\u003d Token.NAME) {\n                    fnInfo \u003d parent.getParent().getJSDocInfo();\n                }\n            }\n            Node args \u003d n.getFirstChild().getNext();\n            for (Node arg \u003d args.getFirstChild(); arg !\u003d null; arg \u003d arg.getNext()) {\n                String argName \u003d arg.getString();\n                JSTypeExpression typeExpr \u003d fnInfo \u003d\u003d null ? null : fnInfo.getParameterType(argName);\n                if (convention.isOptionalParameter(arg) || typeExpr !\u003d null \u0026\u0026 typeExpr.isOptionalArg()) {\n                    arg.putBooleanProp(Node.IS_OPTIONAL_PARAM, true);\n                }\n                if (convention.isVarArgsParameter(arg) || typeExpr !\u003d null \u0026\u0026 typeExpr.isVarArgs()) {\n                    arg.putBooleanProp(Node.IS_VAR_ARGS_PARAM, true);\n                }\n            }\n            break;\n    }\n}",
      "path": "src/com/google/javascript/jscomp/CodingConventionAnnotator.java",
      "functionStartLine": 53,
      "functionName": "visit",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,32 +1,32 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n     switch(n.getType()) {\n         case Token.NAME:\n         case Token.STRING:\n             if (convention.isConstant(n.getString())) {\n                 n.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n             }\n             break;\n         case Token.FUNCTION:\n             JSDocInfo fnInfo \u003d n.getJSDocInfo();\n             if (fnInfo \u003d\u003d null) {\n                 if (parent.getType() \u003d\u003d Token.ASSIGN) {\n                     fnInfo \u003d parent.getJSDocInfo();\n                 } else if (parent.getType() \u003d\u003d Token.NAME) {\n                     fnInfo \u003d parent.getParent().getJSDocInfo();\n                 }\n             }\n             Node args \u003d n.getFirstChild().getNext();\n             for (Node arg \u003d args.getFirstChild(); arg !\u003d null; arg \u003d arg.getNext()) {\n                 String argName \u003d arg.getString();\n                 JSTypeExpression typeExpr \u003d fnInfo \u003d\u003d null ? null : fnInfo.getParameterType(argName);\n-                if (convention.isOptionalParameter(argName) || typeExpr !\u003d null \u0026\u0026 typeExpr.isOptionalArg()) {\n+                if (convention.isOptionalParameter(arg) || typeExpr !\u003d null \u0026\u0026 typeExpr.isOptionalArg()) {\n                     arg.putBooleanProp(Node.IS_OPTIONAL_PARAM, true);\n                 }\n-                if (convention.isVarArgsParameter(arg, argName) || typeExpr !\u003d null \u0026\u0026 typeExpr.isVarArgs()) {\n+                if (convention.isVarArgsParameter(arg) || typeExpr !\u003d null \u0026\u0026 typeExpr.isVarArgs()) {\n                     arg.putBooleanProp(Node.IS_VAR_ARGS_PARAM, true);\n                 }\n             }\n             break;\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": {
      "type": "Yintroduced",
      "commitMessage": "Initial commit.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/3/09, 3:51 PM",
      "commitName": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "diff": "@@ -0,0 +1,32 @@\n+@Override\n+public void visit(NodeTraversal t, Node n, Node parent) {\n+    switch(n.getType()) {\n+        case Token.NAME:\n+        case Token.STRING:\n+            if (convention.isConstant(n.getString())) {\n+                n.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n+            }\n+            break;\n+        case Token.FUNCTION:\n+            JSDocInfo fnInfo \u003d n.getJSDocInfo();\n+            if (fnInfo \u003d\u003d null) {\n+                if (parent.getType() \u003d\u003d Token.ASSIGN) {\n+                    fnInfo \u003d parent.getJSDocInfo();\n+                } else if (parent.getType() \u003d\u003d Token.NAME) {\n+                    fnInfo \u003d parent.getParent().getJSDocInfo();\n+                }\n+            }\n+            Node args \u003d n.getFirstChild().getNext();\n+            for (Node arg \u003d args.getFirstChild(); arg !\u003d null; arg \u003d arg.getNext()) {\n+                String argName \u003d arg.getString();\n+                JSTypeExpression typeExpr \u003d fnInfo \u003d\u003d null ? null : fnInfo.getParameterType(argName);\n+                if (convention.isOptionalParameter(argName) || typeExpr !\u003d null \u0026\u0026 typeExpr.isOptionalArg()) {\n+                    arg.putBooleanProp(Node.IS_OPTIONAL_PARAM, true);\n+                }\n+                if (convention.isVarArgsParameter(arg, argName) || typeExpr !\u003d null \u0026\u0026 typeExpr.isVarArgs()) {\n+                    arg.putBooleanProp(Node.IS_VAR_ARGS_PARAM, true);\n+                }\n+            }\n+            break;\n+    }\n+}\n\\ No newline at end of file\n",
      "actualSource": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    switch(n.getType()) {\n        case Token.NAME:\n        case Token.STRING:\n            if (convention.isConstant(n.getString())) {\n                n.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n            }\n            break;\n        case Token.FUNCTION:\n            JSDocInfo fnInfo \u003d n.getJSDocInfo();\n            if (fnInfo \u003d\u003d null) {\n                if (parent.getType() \u003d\u003d Token.ASSIGN) {\n                    fnInfo \u003d parent.getJSDocInfo();\n                } else if (parent.getType() \u003d\u003d Token.NAME) {\n                    fnInfo \u003d parent.getParent().getJSDocInfo();\n                }\n            }\n            Node args \u003d n.getFirstChild().getNext();\n            for (Node arg \u003d args.getFirstChild(); arg !\u003d null; arg \u003d arg.getNext()) {\n                String argName \u003d arg.getString();\n                JSTypeExpression typeExpr \u003d fnInfo \u003d\u003d null ? null : fnInfo.getParameterType(argName);\n                if (convention.isOptionalParameter(argName) || typeExpr !\u003d null \u0026\u0026 typeExpr.isOptionalArg()) {\n                    arg.putBooleanProp(Node.IS_OPTIONAL_PARAM, true);\n                }\n                if (convention.isVarArgsParameter(arg, argName) || typeExpr !\u003d null \u0026\u0026 typeExpr.isVarArgs()) {\n                    arg.putBooleanProp(Node.IS_VAR_ARGS_PARAM, true);\n                }\n            }\n            break;\n    }\n}",
      "path": "src/com/google/javascript/jscomp/CodingConventionAnnotator.java",
      "functionStartLine": 53,
      "functionName": "visit",
      "functionAnnotation": "@Override",
      "functionDoc": ""
    }
  }
}