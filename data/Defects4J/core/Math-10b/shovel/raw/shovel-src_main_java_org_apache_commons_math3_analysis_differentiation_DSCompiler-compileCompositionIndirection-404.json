{
  "origin": "codeshovel",
  "repositoryName": "Math-10b",
  "repositoryPath": "/tmp/Math-10b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "DSCompiler.java",
  "functionName": "compileCompositionIndirection",
  "functionId": "compileCompositionIndirection___parameters-int(modifiers-final)__order-int(modifiers-final)__valueCompiler-DSCompiler(modifiers-final)__derivativeCompiler-DSCompiler(modifiers-final)__sizes-int[][](modifiers-final)__derivativesIndirection-int[][](modifiers-final)",
  "sourceFilePath": "src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java",
  "functionAnnotation": "",
  "functionDoc": "Compile the function composition indirection array.\n\u003cp\u003e\nThis indirection array contains the indices of all sets of elements\ninvolved when computing a composition. This allows a straightforward\nloop-based composition (see {@link #compose(double[], int, double[], double[], int)}).\n\u003c/p\u003e\n\n@param parameters number of free parameters\n@param order derivation order\n@param valueCompiler compiler for the value part\n@param derivativeCompiler compiler for the derivative part\n@param sizes sizes array\n@param derivativesIndirection derivatives indirection array\n@return multiplication indirection array\n",
  "functionStartLine": 404,
  "functionEndLine": 500,
  "numCommitsSeen": 33,
  "timeTaken": 2701,
  "changeHistory": [
    "95ffd4c253513ca9dd7f73d39e8e0bdb1c14b861",
    "96dfe1afa1c06fb243e312d3366daf99b88ca7b5"
  ],
  "changeHistoryShort": {
    "95ffd4c253513ca9dd7f73d39e8e0bdb1c14b861": "Ymultichange(Yparameterchange,Ydocchange)",
    "96dfe1afa1c06fb243e312d3366daf99b88ca7b5": "Yintroduced"
  },
  "changeHistoryDetails": {
    "95ffd4c253513ca9dd7f73d39e8e0bdb1c14b861": {
      "type": "Ymultichange(Yparameterchange,Ydocchange)",
      "commitMessage": "Fixed PMD warnings.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@1421949 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/14/12, 7:53 AM",
      "commitName": "95ffd4c253513ca9dd7f73d39e8e0bdb1c14b861",
      "commitAuthor": "Luc Maisonobe",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Fixed PMD warnings.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@1421949 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "12/14/12, 7:53 AM",
          "commitName": "95ffd4c253513ca9dd7f73d39e8e0bdb1c14b861",
          "commitAuthor": "Luc Maisonobe",
          "commitDateOld": "10/21/12, 9:32 AM",
          "commitNameOld": "c657a840cc1ce8f80ecbdb761851c356a82cf41b",
          "commitAuthorOld": "Thomas Neidhart",
          "daysBetweenCommits": 53.97,
          "commitsBetweenForRepo": 180,
          "commitsBetweenForFile": 1,
          "actualSource": "private static int[][][] compileCompositionIndirection(final int parameters, final int order, final DSCompiler valueCompiler, final DSCompiler derivativeCompiler, final int[][] sizes, final int[][] derivativesIndirection) {\n    if ((parameters \u003d\u003d 0) || (order \u003d\u003d 0)) {\n        return new int[][][] { { { 1, 0 } } };\n    }\n    final int vSize \u003d valueCompiler.compIndirection.length;\n    final int dSize \u003d derivativeCompiler.compIndirection.length;\n    final int[][][] compIndirection \u003d new int[vSize + dSize][][];\n    System.arraycopy(valueCompiler.compIndirection, 0, compIndirection, 0, vSize);\n    for (int i \u003d 0; i \u003c dSize; ++i) {\n        List\u003cint[]\u003e row \u003d new ArrayList\u003cint[]\u003e();\n        for (int[] term : derivativeCompiler.compIndirection[i]) {\n            int[] derivedTermF \u003d new int[term.length + 1];\n            derivedTermF[0] \u003d term[0];\n            derivedTermF[1] \u003d term[1] + 1;\n            int[] orders \u003d new int[parameters];\n            orders[parameters - 1] \u003d 1;\n            derivedTermF[term.length] \u003d getPartialDerivativeIndex(parameters, order, sizes, orders);\n            for (int j \u003d 2; j \u003c term.length; ++j) {\n                derivedTermF[j] \u003d convertIndex(term[j], parameters, derivativeCompiler.derivativesIndirection, parameters, order, sizes);\n            }\n            Arrays.sort(derivedTermF, 2, derivedTermF.length);\n            row.add(derivedTermF);\n            for (int l \u003d 2; l \u003c term.length; ++l) {\n                int[] derivedTermG \u003d new int[term.length];\n                derivedTermG[0] \u003d term[0];\n                derivedTermG[1] \u003d term[1];\n                for (int j \u003d 2; j \u003c term.length; ++j) {\n                    derivedTermG[j] \u003d convertIndex(term[j], parameters, derivativeCompiler.derivativesIndirection, parameters, order, sizes);\n                    if (j \u003d\u003d l) {\n                        System.arraycopy(derivativesIndirection[derivedTermG[j]], 0, orders, 0, parameters);\n                        orders[parameters - 1]++;\n                        derivedTermG[j] \u003d getPartialDerivativeIndex(parameters, order, sizes, orders);\n                    }\n                }\n                Arrays.sort(derivedTermG, 2, derivedTermG.length);\n                row.add(derivedTermG);\n            }\n        }\n        final List\u003cint[]\u003e combined \u003d new ArrayList\u003cint[]\u003e(row.size());\n        for (int j \u003d 0; j \u003c row.size(); ++j) {\n            final int[] termJ \u003d row.get(j);\n            if (termJ[0] \u003e 0) {\n                for (int k \u003d j + 1; k \u003c row.size(); ++k) {\n                    final int[] termK \u003d row.get(k);\n                    boolean equals \u003d termJ.length \u003d\u003d termK.length;\n                    for (int l \u003d 1; equals \u0026\u0026 l \u003c termJ.length; ++l) {\n                        equals \u0026\u003d termJ[l] \u003d\u003d termK[l];\n                    }\n                    if (equals) {\n                        termJ[0] +\u003d termK[0];\n                        termK[0] \u003d 0;\n                    }\n                }\n                combined.add(termJ);\n            }\n        }\n        compIndirection[vSize + i] \u003d combined.toArray(new int[combined.size()][]);\n    }\n    return compIndirection;\n}",
          "path": "src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java",
          "functionStartLine": 404,
          "functionName": "compileCompositionIndirection",
          "functionAnnotation": "",
          "functionDoc": "Compile the function composition indirection array.\n\u003cp\u003e\nThis indirection array contains the indices of all sets of elements\ninvolved when computing a composition. This allows a straightforward\nloop-based composition (see {@link #compose(double[], int, double[], double[], int)}).\n\u003c/p\u003e\n\n@param parameters number of free parameters\n@param order derivation order\n@param valueCompiler compiler for the value part\n@param derivativeCompiler compiler for the derivative part\n@param sizes sizes array\n@param derivativesIndirection derivatives indirection array\n@return multiplication indirection array\n",
          "diff": "@@ -1,60 +1,60 @@\n-private static int[][][] compileCompositionIndirection(final int parameters, final int order, final DSCompiler valueCompiler, final DSCompiler derivativeCompiler, final int[][] sizes, final int[][] derivativesIndirection, final int[] lowerIndirection) {\n+private static int[][][] compileCompositionIndirection(final int parameters, final int order, final DSCompiler valueCompiler, final DSCompiler derivativeCompiler, final int[][] sizes, final int[][] derivativesIndirection) {\n     if ((parameters \u003d\u003d 0) || (order \u003d\u003d 0)) {\n         return new int[][][] { { { 1, 0 } } };\n     }\n     final int vSize \u003d valueCompiler.compIndirection.length;\n     final int dSize \u003d derivativeCompiler.compIndirection.length;\n     final int[][][] compIndirection \u003d new int[vSize + dSize][][];\n     System.arraycopy(valueCompiler.compIndirection, 0, compIndirection, 0, vSize);\n     for (int i \u003d 0; i \u003c dSize; ++i) {\n         List\u003cint[]\u003e row \u003d new ArrayList\u003cint[]\u003e();\n         for (int[] term : derivativeCompiler.compIndirection[i]) {\n             int[] derivedTermF \u003d new int[term.length + 1];\n             derivedTermF[0] \u003d term[0];\n             derivedTermF[1] \u003d term[1] + 1;\n             int[] orders \u003d new int[parameters];\n             orders[parameters - 1] \u003d 1;\n             derivedTermF[term.length] \u003d getPartialDerivativeIndex(parameters, order, sizes, orders);\n             for (int j \u003d 2; j \u003c term.length; ++j) {\n                 derivedTermF[j] \u003d convertIndex(term[j], parameters, derivativeCompiler.derivativesIndirection, parameters, order, sizes);\n             }\n             Arrays.sort(derivedTermF, 2, derivedTermF.length);\n             row.add(derivedTermF);\n             for (int l \u003d 2; l \u003c term.length; ++l) {\n                 int[] derivedTermG \u003d new int[term.length];\n                 derivedTermG[0] \u003d term[0];\n                 derivedTermG[1] \u003d term[1];\n                 for (int j \u003d 2; j \u003c term.length; ++j) {\n                     derivedTermG[j] \u003d convertIndex(term[j], parameters, derivativeCompiler.derivativesIndirection, parameters, order, sizes);\n                     if (j \u003d\u003d l) {\n                         System.arraycopy(derivativesIndirection[derivedTermG[j]], 0, orders, 0, parameters);\n                         orders[parameters - 1]++;\n                         derivedTermG[j] \u003d getPartialDerivativeIndex(parameters, order, sizes, orders);\n                     }\n                 }\n                 Arrays.sort(derivedTermG, 2, derivedTermG.length);\n                 row.add(derivedTermG);\n             }\n         }\n         final List\u003cint[]\u003e combined \u003d new ArrayList\u003cint[]\u003e(row.size());\n         for (int j \u003d 0; j \u003c row.size(); ++j) {\n             final int[] termJ \u003d row.get(j);\n             if (termJ[0] \u003e 0) {\n                 for (int k \u003d j + 1; k \u003c row.size(); ++k) {\n                     final int[] termK \u003d row.get(k);\n                     boolean equals \u003d termJ.length \u003d\u003d termK.length;\n                     for (int l \u003d 1; equals \u0026\u0026 l \u003c termJ.length; ++l) {\n                         equals \u0026\u003d termJ[l] \u003d\u003d termK[l];\n                     }\n                     if (equals) {\n                         termJ[0] +\u003d termK[0];\n                         termK[0] \u003d 0;\n                     }\n                 }\n                 combined.add(termJ);\n             }\n         }\n         compIndirection[vSize + i] \u003d combined.toArray(new int[combined.size()][]);\n     }\n     return compIndirection;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[parameters-int(modifiers-final), order-int(modifiers-final), valueCompiler-DSCompiler(modifiers-final), derivativeCompiler-DSCompiler(modifiers-final), sizes-int[][](modifiers-final), derivativesIndirection-int[][](modifiers-final), lowerIndirection-int[](modifiers-final)]",
            "newValue": "[parameters-int(modifiers-final), order-int(modifiers-final), valueCompiler-DSCompiler(modifiers-final), derivativeCompiler-DSCompiler(modifiers-final), sizes-int[][](modifiers-final), derivativesIndirection-int[][](modifiers-final)]"
          }
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Fixed PMD warnings.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@1421949 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "12/14/12, 7:53 AM",
          "commitName": "95ffd4c253513ca9dd7f73d39e8e0bdb1c14b861",
          "commitAuthor": "Luc Maisonobe",
          "commitDateOld": "10/21/12, 9:32 AM",
          "commitNameOld": "c657a840cc1ce8f80ecbdb761851c356a82cf41b",
          "commitAuthorOld": "Thomas Neidhart",
          "daysBetweenCommits": 53.97,
          "commitsBetweenForRepo": 180,
          "commitsBetweenForFile": 1,
          "actualSource": "private static int[][][] compileCompositionIndirection(final int parameters, final int order, final DSCompiler valueCompiler, final DSCompiler derivativeCompiler, final int[][] sizes, final int[][] derivativesIndirection) {\n    if ((parameters \u003d\u003d 0) || (order \u003d\u003d 0)) {\n        return new int[][][] { { { 1, 0 } } };\n    }\n    final int vSize \u003d valueCompiler.compIndirection.length;\n    final int dSize \u003d derivativeCompiler.compIndirection.length;\n    final int[][][] compIndirection \u003d new int[vSize + dSize][][];\n    System.arraycopy(valueCompiler.compIndirection, 0, compIndirection, 0, vSize);\n    for (int i \u003d 0; i \u003c dSize; ++i) {\n        List\u003cint[]\u003e row \u003d new ArrayList\u003cint[]\u003e();\n        for (int[] term : derivativeCompiler.compIndirection[i]) {\n            int[] derivedTermF \u003d new int[term.length + 1];\n            derivedTermF[0] \u003d term[0];\n            derivedTermF[1] \u003d term[1] + 1;\n            int[] orders \u003d new int[parameters];\n            orders[parameters - 1] \u003d 1;\n            derivedTermF[term.length] \u003d getPartialDerivativeIndex(parameters, order, sizes, orders);\n            for (int j \u003d 2; j \u003c term.length; ++j) {\n                derivedTermF[j] \u003d convertIndex(term[j], parameters, derivativeCompiler.derivativesIndirection, parameters, order, sizes);\n            }\n            Arrays.sort(derivedTermF, 2, derivedTermF.length);\n            row.add(derivedTermF);\n            for (int l \u003d 2; l \u003c term.length; ++l) {\n                int[] derivedTermG \u003d new int[term.length];\n                derivedTermG[0] \u003d term[0];\n                derivedTermG[1] \u003d term[1];\n                for (int j \u003d 2; j \u003c term.length; ++j) {\n                    derivedTermG[j] \u003d convertIndex(term[j], parameters, derivativeCompiler.derivativesIndirection, parameters, order, sizes);\n                    if (j \u003d\u003d l) {\n                        System.arraycopy(derivativesIndirection[derivedTermG[j]], 0, orders, 0, parameters);\n                        orders[parameters - 1]++;\n                        derivedTermG[j] \u003d getPartialDerivativeIndex(parameters, order, sizes, orders);\n                    }\n                }\n                Arrays.sort(derivedTermG, 2, derivedTermG.length);\n                row.add(derivedTermG);\n            }\n        }\n        final List\u003cint[]\u003e combined \u003d new ArrayList\u003cint[]\u003e(row.size());\n        for (int j \u003d 0; j \u003c row.size(); ++j) {\n            final int[] termJ \u003d row.get(j);\n            if (termJ[0] \u003e 0) {\n                for (int k \u003d j + 1; k \u003c row.size(); ++k) {\n                    final int[] termK \u003d row.get(k);\n                    boolean equals \u003d termJ.length \u003d\u003d termK.length;\n                    for (int l \u003d 1; equals \u0026\u0026 l \u003c termJ.length; ++l) {\n                        equals \u0026\u003d termJ[l] \u003d\u003d termK[l];\n                    }\n                    if (equals) {\n                        termJ[0] +\u003d termK[0];\n                        termK[0] \u003d 0;\n                    }\n                }\n                combined.add(termJ);\n            }\n        }\n        compIndirection[vSize + i] \u003d combined.toArray(new int[combined.size()][]);\n    }\n    return compIndirection;\n}",
          "path": "src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java",
          "functionStartLine": 404,
          "functionName": "compileCompositionIndirection",
          "functionAnnotation": "",
          "functionDoc": "Compile the function composition indirection array.\n\u003cp\u003e\nThis indirection array contains the indices of all sets of elements\ninvolved when computing a composition. This allows a straightforward\nloop-based composition (see {@link #compose(double[], int, double[], double[], int)}).\n\u003c/p\u003e\n\n@param parameters number of free parameters\n@param order derivation order\n@param valueCompiler compiler for the value part\n@param derivativeCompiler compiler for the derivative part\n@param sizes sizes array\n@param derivativesIndirection derivatives indirection array\n@return multiplication indirection array\n",
          "diff": "@@ -1,60 +1,60 @@\n-private static int[][][] compileCompositionIndirection(final int parameters, final int order, final DSCompiler valueCompiler, final DSCompiler derivativeCompiler, final int[][] sizes, final int[][] derivativesIndirection, final int[] lowerIndirection) {\n+private static int[][][] compileCompositionIndirection(final int parameters, final int order, final DSCompiler valueCompiler, final DSCompiler derivativeCompiler, final int[][] sizes, final int[][] derivativesIndirection) {\n     if ((parameters \u003d\u003d 0) || (order \u003d\u003d 0)) {\n         return new int[][][] { { { 1, 0 } } };\n     }\n     final int vSize \u003d valueCompiler.compIndirection.length;\n     final int dSize \u003d derivativeCompiler.compIndirection.length;\n     final int[][][] compIndirection \u003d new int[vSize + dSize][][];\n     System.arraycopy(valueCompiler.compIndirection, 0, compIndirection, 0, vSize);\n     for (int i \u003d 0; i \u003c dSize; ++i) {\n         List\u003cint[]\u003e row \u003d new ArrayList\u003cint[]\u003e();\n         for (int[] term : derivativeCompiler.compIndirection[i]) {\n             int[] derivedTermF \u003d new int[term.length + 1];\n             derivedTermF[0] \u003d term[0];\n             derivedTermF[1] \u003d term[1] + 1;\n             int[] orders \u003d new int[parameters];\n             orders[parameters - 1] \u003d 1;\n             derivedTermF[term.length] \u003d getPartialDerivativeIndex(parameters, order, sizes, orders);\n             for (int j \u003d 2; j \u003c term.length; ++j) {\n                 derivedTermF[j] \u003d convertIndex(term[j], parameters, derivativeCompiler.derivativesIndirection, parameters, order, sizes);\n             }\n             Arrays.sort(derivedTermF, 2, derivedTermF.length);\n             row.add(derivedTermF);\n             for (int l \u003d 2; l \u003c term.length; ++l) {\n                 int[] derivedTermG \u003d new int[term.length];\n                 derivedTermG[0] \u003d term[0];\n                 derivedTermG[1] \u003d term[1];\n                 for (int j \u003d 2; j \u003c term.length; ++j) {\n                     derivedTermG[j] \u003d convertIndex(term[j], parameters, derivativeCompiler.derivativesIndirection, parameters, order, sizes);\n                     if (j \u003d\u003d l) {\n                         System.arraycopy(derivativesIndirection[derivedTermG[j]], 0, orders, 0, parameters);\n                         orders[parameters - 1]++;\n                         derivedTermG[j] \u003d getPartialDerivativeIndex(parameters, order, sizes, orders);\n                     }\n                 }\n                 Arrays.sort(derivedTermG, 2, derivedTermG.length);\n                 row.add(derivedTermG);\n             }\n         }\n         final List\u003cint[]\u003e combined \u003d new ArrayList\u003cint[]\u003e(row.size());\n         for (int j \u003d 0; j \u003c row.size(); ++j) {\n             final int[] termJ \u003d row.get(j);\n             if (termJ[0] \u003e 0) {\n                 for (int k \u003d j + 1; k \u003c row.size(); ++k) {\n                     final int[] termK \u003d row.get(k);\n                     boolean equals \u003d termJ.length \u003d\u003d termK.length;\n                     for (int l \u003d 1; equals \u0026\u0026 l \u003c termJ.length; ++l) {\n                         equals \u0026\u003d termJ[l] \u003d\u003d termK[l];\n                     }\n                     if (equals) {\n                         termJ[0] +\u003d termK[0];\n                         termK[0] \u003d 0;\n                     }\n                 }\n                 combined.add(termJ);\n             }\n         }\n         compIndirection[vSize + i] \u003d combined.toArray(new int[combined.size()][]);\n     }\n     return compIndirection;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Compile the function composition indirection array.\n\u003cp\u003e\nThis indirection array contains the indices of all sets of elements\ninvolved when computing a composition. This allows a straightforward\nloop-based composition (see {@link #compose(double[], int, double[], double[], int)}).\n\u003c/p\u003e\n\n@param parameters number of free parameters\n@param order derivation order\n@param valueCompiler compiler for the value part\n@param derivativeCompiler compiler for the derivative part\n@param sizes sizes array\n@param derivativesIndirection derivatives indirection array\n@param lowerIndirection lower derivatives indirection array\n@return multiplication indirection array\n",
            "newValue": "Compile the function composition indirection array.\n\u003cp\u003e\nThis indirection array contains the indices of all sets of elements\ninvolved when computing a composition. This allows a straightforward\nloop-based composition (see {@link #compose(double[], int, double[], double[], int)}).\n\u003c/p\u003e\n\n@param parameters number of free parameters\n@param order derivation order\n@param valueCompiler compiler for the value part\n@param derivativeCompiler compiler for the derivative part\n@param sizes sizes array\n@param derivativesIndirection derivatives indirection array\n@return multiplication indirection array\n"
          }
        }
      ]
    },
    "96dfe1afa1c06fb243e312d3366daf99b88ca7b5": {
      "type": "Yintroduced",
      "commitMessage": "Added a new package dealing with differentials.\n\nThe package is intended to deals with one or more free parameters and\nderivation order 1 or higher.\n\nThe core elements are based on Dan Kalman paper \"Recursive Multivariate\nAutomatic Differentiation\", Mathematics Magazine, vol. 75, no. 3, June\n2002. For efficiency, the recursive structure is compiled as simple\nloops once for each pair (number of free parameters, derivation order).\n\nThis is work in progress, there are still some features missing even in\nthe most basic blocks (typically the asin, acos, atan, atant2 and taylor\nmethods in DSCompiler). There are also still no high level\ndifferentiator implementation.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@1370951 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "8/8/12, 1:33 PM",
      "commitName": "96dfe1afa1c06fb243e312d3366daf99b88ca7b5",
      "commitAuthor": "Luc Maisonobe",
      "diff": "@@ -0,0 +1,60 @@\n+private static int[][][] compileCompositionIndirection(final int parameters, final int order, final DSCompiler valueCompiler, final DSCompiler derivativeCompiler, final int[][] sizes, final int[][] derivativesIndirection, final int[] lowerIndirection) {\n+    if ((parameters \u003d\u003d 0) || (order \u003d\u003d 0)) {\n+        return new int[][][] { { { 1, 0 } } };\n+    }\n+    final int vSize \u003d valueCompiler.compIndirection.length;\n+    final int dSize \u003d derivativeCompiler.compIndirection.length;\n+    final int[][][] compIndirection \u003d new int[vSize + dSize][][];\n+    System.arraycopy(valueCompiler.compIndirection, 0, compIndirection, 0, vSize);\n+    for (int i \u003d 0; i \u003c dSize; ++i) {\n+        List\u003cint[]\u003e row \u003d new ArrayList\u003cint[]\u003e();\n+        for (int[] term : derivativeCompiler.compIndirection[i]) {\n+            int[] derivedTermF \u003d new int[term.length + 1];\n+            derivedTermF[0] \u003d term[0];\n+            derivedTermF[1] \u003d term[1] + 1;\n+            int[] orders \u003d new int[parameters];\n+            orders[parameters - 1] \u003d 1;\n+            derivedTermF[term.length] \u003d getPartialDerivativeIndex(parameters, order, sizes, orders);\n+            for (int j \u003d 2; j \u003c term.length; ++j) {\n+                derivedTermF[j] \u003d convertIndex(term[j], parameters, derivativeCompiler.derivativesIndirection, parameters, order, sizes);\n+            }\n+            Arrays.sort(derivedTermF, 2, derivedTermF.length);\n+            row.add(derivedTermF);\n+            for (int l \u003d 2; l \u003c term.length; ++l) {\n+                int[] derivedTermG \u003d new int[term.length];\n+                derivedTermG[0] \u003d term[0];\n+                derivedTermG[1] \u003d term[1];\n+                for (int j \u003d 2; j \u003c term.length; ++j) {\n+                    derivedTermG[j] \u003d convertIndex(term[j], parameters, derivativeCompiler.derivativesIndirection, parameters, order, sizes);\n+                    if (j \u003d\u003d l) {\n+                        System.arraycopy(derivativesIndirection[derivedTermG[j]], 0, orders, 0, parameters);\n+                        orders[parameters - 1]++;\n+                        derivedTermG[j] \u003d getPartialDerivativeIndex(parameters, order, sizes, orders);\n+                    }\n+                }\n+                Arrays.sort(derivedTermG, 2, derivedTermG.length);\n+                row.add(derivedTermG);\n+            }\n+        }\n+        final List\u003cint[]\u003e combined \u003d new ArrayList\u003cint[]\u003e(row.size());\n+        for (int j \u003d 0; j \u003c row.size(); ++j) {\n+            final int[] termJ \u003d row.get(j);\n+            if (termJ[0] \u003e 0) {\n+                for (int k \u003d j + 1; k \u003c row.size(); ++k) {\n+                    final int[] termK \u003d row.get(k);\n+                    boolean equals \u003d termJ.length \u003d\u003d termK.length;\n+                    for (int l \u003d 1; equals \u0026\u0026 l \u003c termJ.length; ++l) {\n+                        equals \u0026\u003d termJ[l] \u003d\u003d termK[l];\n+                    }\n+                    if (equals) {\n+                        termJ[0] +\u003d termK[0];\n+                        termK[0] \u003d 0;\n+                    }\n+                }\n+                combined.add(termJ);\n+            }\n+        }\n+        compIndirection[vSize + i] \u003d combined.toArray(new int[combined.size()][]);\n+    }\n+    return compIndirection;\n+}\n\\ No newline at end of file\n",
      "actualSource": "private static int[][][] compileCompositionIndirection(final int parameters, final int order, final DSCompiler valueCompiler, final DSCompiler derivativeCompiler, final int[][] sizes, final int[][] derivativesIndirection, final int[] lowerIndirection) {\n    if ((parameters \u003d\u003d 0) || (order \u003d\u003d 0)) {\n        return new int[][][] { { { 1, 0 } } };\n    }\n    final int vSize \u003d valueCompiler.compIndirection.length;\n    final int dSize \u003d derivativeCompiler.compIndirection.length;\n    final int[][][] compIndirection \u003d new int[vSize + dSize][][];\n    System.arraycopy(valueCompiler.compIndirection, 0, compIndirection, 0, vSize);\n    for (int i \u003d 0; i \u003c dSize; ++i) {\n        List\u003cint[]\u003e row \u003d new ArrayList\u003cint[]\u003e();\n        for (int[] term : derivativeCompiler.compIndirection[i]) {\n            int[] derivedTermF \u003d new int[term.length + 1];\n            derivedTermF[0] \u003d term[0];\n            derivedTermF[1] \u003d term[1] + 1;\n            int[] orders \u003d new int[parameters];\n            orders[parameters - 1] \u003d 1;\n            derivedTermF[term.length] \u003d getPartialDerivativeIndex(parameters, order, sizes, orders);\n            for (int j \u003d 2; j \u003c term.length; ++j) {\n                derivedTermF[j] \u003d convertIndex(term[j], parameters, derivativeCompiler.derivativesIndirection, parameters, order, sizes);\n            }\n            Arrays.sort(derivedTermF, 2, derivedTermF.length);\n            row.add(derivedTermF);\n            for (int l \u003d 2; l \u003c term.length; ++l) {\n                int[] derivedTermG \u003d new int[term.length];\n                derivedTermG[0] \u003d term[0];\n                derivedTermG[1] \u003d term[1];\n                for (int j \u003d 2; j \u003c term.length; ++j) {\n                    derivedTermG[j] \u003d convertIndex(term[j], parameters, derivativeCompiler.derivativesIndirection, parameters, order, sizes);\n                    if (j \u003d\u003d l) {\n                        System.arraycopy(derivativesIndirection[derivedTermG[j]], 0, orders, 0, parameters);\n                        orders[parameters - 1]++;\n                        derivedTermG[j] \u003d getPartialDerivativeIndex(parameters, order, sizes, orders);\n                    }\n                }\n                Arrays.sort(derivedTermG, 2, derivedTermG.length);\n                row.add(derivedTermG);\n            }\n        }\n        final List\u003cint[]\u003e combined \u003d new ArrayList\u003cint[]\u003e(row.size());\n        for (int j \u003d 0; j \u003c row.size(); ++j) {\n            final int[] termJ \u003d row.get(j);\n            if (termJ[0] \u003e 0) {\n                for (int k \u003d j + 1; k \u003c row.size(); ++k) {\n                    final int[] termK \u003d row.get(k);\n                    boolean equals \u003d termJ.length \u003d\u003d termK.length;\n                    for (int l \u003d 1; equals \u0026\u0026 l \u003c termJ.length; ++l) {\n                        equals \u0026\u003d termJ[l] \u003d\u003d termK[l];\n                    }\n                    if (equals) {\n                        termJ[0] +\u003d termK[0];\n                        termK[0] \u003d 0;\n                    }\n                }\n                combined.add(termJ);\n            }\n        }\n        compIndirection[vSize + i] \u003d combined.toArray(new int[combined.size()][]);\n    }\n    return compIndirection;\n}",
      "path": "src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java",
      "functionStartLine": 406,
      "functionName": "compileCompositionIndirection",
      "functionAnnotation": "",
      "functionDoc": "Compile the function composition indirection array.\n\u003cp\u003e\nThis indirection array contains the indices of all sets of elements\ninvolved when computing a composition. This allows a straightforward\nloop-based composition (see {@link #compose(double[], int, double[], double[], int)}).\n\u003c/p\u003e\n\n@param parameters number of free parameters\n@param order derivation order\n@param valueCompiler compiler for the value part\n@param derivativeCompiler compiler for the derivative part\n@param sizes sizes array\n@param derivativesIndirection derivatives indirection array\n@param lowerIndirection lower derivatives indirection array\n@return multiplication indirection array\n"
    }
  }
}