{
  "origin": "codeshovel",
  "repositoryName": "Closure-21b",
  "repositoryPath": "/tmp/Closure-21b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "CheckSideEffects.java",
  "functionName": "visit",
  "functionId": "visit___t-NodeTraversal__n-Node__parent-Node",
  "sourceFilePath": "src/com/google/javascript/jscomp/CheckSideEffects.java",
  "functionAnnotation": "@Override",
  "functionDoc": "",
  "functionStartLine": 84,
  "functionEndLine": 166,
  "numCommitsSeen": 20,
  "timeTaken": 1284,
  "changeHistory": [
    "dbf6ea95477810188582b9e9ac6c9645717cbe95",
    "43a55234ef122a1ed98681ce0350506207b878d5",
    "70a5626922ea7e8c98747e22b6986638ba38fadc",
    "ff9dc85e994c34448130ee5bb38f801ab2f6ba16",
    "5f8b6f54294ce8b454f78165f5230b3759d11e37",
    "4e976ac213f448bab78f5c1432340c489b533d7b",
    "ec324a9bb23eb78c76f537f4c4170ba88d542f1c",
    "76abdf11394c0e7515ae63335676ea3657badb45",
    "a07ce4c8fa380151233f3a155fff1e37c117aae0",
    "80fe41fd0173c3eaa56f4abb783031966ea89cef",
    "3cc8b3a5889f8b88ef7a2bd0b8ccea8cb0d916c4",
    "c857311f08df730f98cc47e9b59383b0349fe9b3",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3"
  ],
  "changeHistoryShort": {
    "dbf6ea95477810188582b9e9ac6c9645717cbe95": "Ybodychange",
    "43a55234ef122a1ed98681ce0350506207b878d5": "Ybodychange",
    "70a5626922ea7e8c98747e22b6986638ba38fadc": "Ybodychange",
    "ff9dc85e994c34448130ee5bb38f801ab2f6ba16": "Ybodychange",
    "5f8b6f54294ce8b454f78165f5230b3759d11e37": "Ybodychange",
    "4e976ac213f448bab78f5c1432340c489b533d7b": "Ybodychange",
    "ec324a9bb23eb78c76f537f4c4170ba88d542f1c": "Ybodychange",
    "76abdf11394c0e7515ae63335676ea3657badb45": "Yannotationchange",
    "a07ce4c8fa380151233f3a155fff1e37c117aae0": "Ybodychange",
    "80fe41fd0173c3eaa56f4abb783031966ea89cef": "Ybodychange",
    "3cc8b3a5889f8b88ef7a2bd0b8ccea8cb0d916c4": "Ybodychange",
    "c857311f08df730f98cc47e9b59383b0349fe9b3": "Ybodychange",
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "dbf6ea95477810188582b9e9ac6c9645717cbe95": {
      "type": "Ybodychange",
      "commitMessage": "\nAutomated g4 rollback\n\n*** Reason for rollback ***\n\nbroke some stuff\n\n*** Original change description ***\n\nYou are in a maze of twisty \u0027if\u0027 branches, all alike.\ncleanup the logic for identifying dead expressions.\nFixes issue 753\n\nDELTA\u003d73  (35 added, 22 deleted, 16 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d5044\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2056 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "6/19/12, 2:43 PM",
      "commitName": "dbf6ea95477810188582b9e9ac6c9645717cbe95",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "6/19/12, 1:55 PM",
      "commitNameOld": "43a55234ef122a1ed98681ce0350506207b878d5",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.isEmpty() || n.isComma()) {\n        return;\n    }\n    if (parent \u003d\u003d null) {\n        return;\n    }\n    int pt \u003d parent.getType();\n    if (pt \u003d\u003d Token.COMMA) {\n        Node gramps \u003d parent.getParent();\n        if (gramps.isCall() \u0026\u0026 parent \u003d\u003d gramps.getFirstChild()) {\n            if (n \u003d\u003d parent.getFirstChild() \u0026\u0026 parent.getChildCount() \u003d\u003d 2 \u0026\u0026 n.getNext().isName() \u0026\u0026 \"eval\".equals(n.getNext().getString())) {\n                return;\n            }\n        }\n        if (n \u003d\u003d parent.getLastChild()) {\n            for (Node an : parent.getAncestors()) {\n                int ancestorType \u003d an.getType();\n                if (ancestorType \u003d\u003d Token.COMMA)\n                    continue;\n                if (ancestorType !\u003d Token.EXPR_RESULT \u0026\u0026 ancestorType !\u003d Token.BLOCK)\n                    return;\n                else\n                    break;\n            }\n        }\n    } else if (pt !\u003d Token.EXPR_RESULT \u0026\u0026 pt !\u003d Token.BLOCK) {\n        if (pt \u003d\u003d Token.FOR \u0026\u0026 parent.getChildCount() \u003d\u003d 4 \u0026\u0026 (n \u003d\u003d parent.getFirstChild() || n \u003d\u003d parent.getFirstChild().getNext().getNext())) {\n        } else {\n            return;\n        }\n    }\n    boolean isSimpleOp \u003d NodeUtil.isSimpleOperatorType(n.getType());\n    if (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler())) {\n        if (n.isQualifiedName() \u0026\u0026 n.getJSDocInfo() !\u003d null) {\n            return;\n        } else if (n.isExprResult()) {\n            return;\n        }\n        String msg \u003d \"This code lacks side-effects. Is there a bug?\";\n        if (n.isString()) {\n            msg \u003d \"Is there a missing \u0027+\u0027 on the previous line?\";\n        } else if (isSimpleOp) {\n            msg \u003d \"The result of the \u0027\" + Token.name(n.getType()).toLowerCase() + \"\u0027 operator is not being used.\";\n        }\n        t.getCompiler().report(t.makeError(n, level, USELESS_CODE_ERROR, msg));\n        if (!NodeUtil.isStatement(n)) {\n            problemNodes.add(n);\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/CheckSideEffects.java",
      "functionStartLine": 84,
      "functionName": "visit",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,29 +1,52 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n     if (n.isEmpty() || n.isComma()) {\n         return;\n     }\n     if (parent \u003d\u003d null) {\n         return;\n     }\n-    if (n.isExprResult() || n.isBlock()) {\n-        return;\n+    int pt \u003d parent.getType();\n+    if (pt \u003d\u003d Token.COMMA) {\n+        Node gramps \u003d parent.getParent();\n+        if (gramps.isCall() \u0026\u0026 parent \u003d\u003d gramps.getFirstChild()) {\n+            if (n \u003d\u003d parent.getFirstChild() \u0026\u0026 parent.getChildCount() \u003d\u003d 2 \u0026\u0026 n.getNext().isName() \u0026\u0026 \"eval\".equals(n.getNext().getString())) {\n+                return;\n+            }\n+        }\n+        if (n \u003d\u003d parent.getLastChild()) {\n+            for (Node an : parent.getAncestors()) {\n+                int ancestorType \u003d an.getType();\n+                if (ancestorType \u003d\u003d Token.COMMA)\n+                    continue;\n+                if (ancestorType !\u003d Token.EXPR_RESULT \u0026\u0026 ancestorType !\u003d Token.BLOCK)\n+                    return;\n+                else\n+                    break;\n+            }\n+        }\n+    } else if (pt !\u003d Token.EXPR_RESULT \u0026\u0026 pt !\u003d Token.BLOCK) {\n+        if (pt \u003d\u003d Token.FOR \u0026\u0026 parent.getChildCount() \u003d\u003d 4 \u0026\u0026 (n \u003d\u003d parent.getFirstChild() || n \u003d\u003d parent.getFirstChild().getNext().getNext())) {\n+        } else {\n+            return;\n+        }\n     }\n-    if (n.isQualifiedName() \u0026\u0026 n.getJSDocInfo() !\u003d null) {\n-        return;\n-    }\n-    boolean isResultUsed \u003d NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp \u003d NodeUtil.isSimpleOperatorType(n.getType());\n-    if (!isResultUsed \u0026\u0026 (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n+    if (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler())) {\n+        if (n.isQualifiedName() \u0026\u0026 n.getJSDocInfo() !\u003d null) {\n+            return;\n+        } else if (n.isExprResult()) {\n+            return;\n+        }\n         String msg \u003d \"This code lacks side-effects. Is there a bug?\";\n         if (n.isString()) {\n             msg \u003d \"Is there a missing \u0027+\u0027 on the previous line?\";\n         } else if (isSimpleOp) {\n             msg \u003d \"The result of the \u0027\" + Token.name(n.getType()).toLowerCase() + \"\u0027 operator is not being used.\";\n         }\n         t.getCompiler().report(t.makeError(n, level, USELESS_CODE_ERROR, msg));\n         if (!NodeUtil.isStatement(n)) {\n             problemNodes.add(n);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "43a55234ef122a1ed98681ce0350506207b878d5": {
      "type": "Ybodychange",
      "commitMessage": "\nYou are in a maze of twisty \u0027if\u0027 branches, all alike.\ncleanup the logic for identifying dead expressions.\nFixes issue 753\n\nR\u003djohnlenz\nDELTA\u003d78  (29 added, 42 deleted, 7 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d5031\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2054 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "6/19/12, 1:55 PM",
      "commitName": "43a55234ef122a1ed98681ce0350506207b878d5",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "5/18/12, 11:09 AM",
      "commitNameOld": "70a5626922ea7e8c98747e22b6986638ba38fadc",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 32.12,
      "commitsBetweenForRepo": 75,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.isEmpty() || n.isComma()) {\n        return;\n    }\n    if (parent \u003d\u003d null) {\n        return;\n    }\n    if (n.isExprResult() || n.isBlock()) {\n        return;\n    }\n    if (n.isQualifiedName() \u0026\u0026 n.getJSDocInfo() !\u003d null) {\n        return;\n    }\n    boolean isResultUsed \u003d NodeUtil.isExpressionResultUsed(n);\n    boolean isSimpleOp \u003d NodeUtil.isSimpleOperatorType(n.getType());\n    if (!isResultUsed \u0026\u0026 (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n        String msg \u003d \"This code lacks side-effects. Is there a bug?\";\n        if (n.isString()) {\n            msg \u003d \"Is there a missing \u0027+\u0027 on the previous line?\";\n        } else if (isSimpleOp) {\n            msg \u003d \"The result of the \u0027\" + Token.name(n.getType()).toLowerCase() + \"\u0027 operator is not being used.\";\n        }\n        t.getCompiler().report(t.makeError(n, level, USELESS_CODE_ERROR, msg));\n        if (!NodeUtil.isStatement(n)) {\n            problemNodes.add(n);\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/CheckSideEffects.java",
      "functionStartLine": 84,
      "functionName": "visit",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,52 +1,29 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n     if (n.isEmpty() || n.isComma()) {\n         return;\n     }\n     if (parent \u003d\u003d null) {\n         return;\n     }\n-    int pt \u003d parent.getType();\n-    if (pt \u003d\u003d Token.COMMA) {\n-        Node gramps \u003d parent.getParent();\n-        if (gramps.isCall() \u0026\u0026 parent \u003d\u003d gramps.getFirstChild()) {\n-            if (n \u003d\u003d parent.getFirstChild() \u0026\u0026 parent.getChildCount() \u003d\u003d 2 \u0026\u0026 n.getNext().isName() \u0026\u0026 \"eval\".equals(n.getNext().getString())) {\n-                return;\n-            }\n-        }\n-        if (n \u003d\u003d parent.getLastChild()) {\n-            for (Node an : parent.getAncestors()) {\n-                int ancestorType \u003d an.getType();\n-                if (ancestorType \u003d\u003d Token.COMMA)\n-                    continue;\n-                if (ancestorType !\u003d Token.EXPR_RESULT \u0026\u0026 ancestorType !\u003d Token.BLOCK)\n-                    return;\n-                else\n-                    break;\n-            }\n-        }\n-    } else if (pt !\u003d Token.EXPR_RESULT \u0026\u0026 pt !\u003d Token.BLOCK) {\n-        if (pt \u003d\u003d Token.FOR \u0026\u0026 parent.getChildCount() \u003d\u003d 4 \u0026\u0026 (n \u003d\u003d parent.getFirstChild() || n \u003d\u003d parent.getFirstChild().getNext().getNext())) {\n-        } else {\n-            return;\n-        }\n+    if (n.isExprResult() || n.isBlock()) {\n+        return;\n     }\n+    if (n.isQualifiedName() \u0026\u0026 n.getJSDocInfo() !\u003d null) {\n+        return;\n+    }\n+    boolean isResultUsed \u003d NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp \u003d NodeUtil.isSimpleOperatorType(n.getType());\n-    if (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler())) {\n-        if (n.isQualifiedName() \u0026\u0026 n.getJSDocInfo() !\u003d null) {\n-            return;\n-        } else if (n.isExprResult()) {\n-            return;\n-        }\n+    if (!isResultUsed \u0026\u0026 (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n         String msg \u003d \"This code lacks side-effects. Is there a bug?\";\n         if (n.isString()) {\n             msg \u003d \"Is there a missing \u0027+\u0027 on the previous line?\";\n         } else if (isSimpleOp) {\n             msg \u003d \"The result of the \u0027\" + Token.name(n.getType()).toLowerCase() + \"\u0027 operator is not being used.\";\n         }\n         t.getCompiler().report(t.makeError(n, level, USELESS_CODE_ERROR, msg));\n         if (!NodeUtil.isStatement(n)) {\n             problemNodes.add(n);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "70a5626922ea7e8c98747e22b6986638ba38fadc": {
      "type": "Ybodychange",
      "commitMessage": "\nFix various typos, spelling and grammar errors.\nFixes issue 734. \nContributed by Robert Gust Bardon\n\nR\u003dnicksantos\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d4827\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1979 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "5/18/12, 11:09 AM",
      "commitName": "70a5626922ea7e8c98747e22b6986638ba38fadc",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "1/13/12, 2:07 PM",
      "commitNameOld": "ff9dc85e994c34448130ee5bb38f801ab2f6ba16",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 125.83,
      "commitsBetweenForRepo": 213,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.isEmpty() || n.isComma()) {\n        return;\n    }\n    if (parent \u003d\u003d null) {\n        return;\n    }\n    int pt \u003d parent.getType();\n    if (pt \u003d\u003d Token.COMMA) {\n        Node gramps \u003d parent.getParent();\n        if (gramps.isCall() \u0026\u0026 parent \u003d\u003d gramps.getFirstChild()) {\n            if (n \u003d\u003d parent.getFirstChild() \u0026\u0026 parent.getChildCount() \u003d\u003d 2 \u0026\u0026 n.getNext().isName() \u0026\u0026 \"eval\".equals(n.getNext().getString())) {\n                return;\n            }\n        }\n        if (n \u003d\u003d parent.getLastChild()) {\n            for (Node an : parent.getAncestors()) {\n                int ancestorType \u003d an.getType();\n                if (ancestorType \u003d\u003d Token.COMMA)\n                    continue;\n                if (ancestorType !\u003d Token.EXPR_RESULT \u0026\u0026 ancestorType !\u003d Token.BLOCK)\n                    return;\n                else\n                    break;\n            }\n        }\n    } else if (pt !\u003d Token.EXPR_RESULT \u0026\u0026 pt !\u003d Token.BLOCK) {\n        if (pt \u003d\u003d Token.FOR \u0026\u0026 parent.getChildCount() \u003d\u003d 4 \u0026\u0026 (n \u003d\u003d parent.getFirstChild() || n \u003d\u003d parent.getFirstChild().getNext().getNext())) {\n        } else {\n            return;\n        }\n    }\n    boolean isSimpleOp \u003d NodeUtil.isSimpleOperatorType(n.getType());\n    if (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler())) {\n        if (n.isQualifiedName() \u0026\u0026 n.getJSDocInfo() !\u003d null) {\n            return;\n        } else if (n.isExprResult()) {\n            return;\n        }\n        String msg \u003d \"This code lacks side-effects. Is there a bug?\";\n        if (n.isString()) {\n            msg \u003d \"Is there a missing \u0027+\u0027 on the previous line?\";\n        } else if (isSimpleOp) {\n            msg \u003d \"The result of the \u0027\" + Token.name(n.getType()).toLowerCase() + \"\u0027 operator is not being used.\";\n        }\n        t.getCompiler().report(t.makeError(n, level, USELESS_CODE_ERROR, msg));\n        if (!NodeUtil.isStatement(n)) {\n            problemNodes.add(n);\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/CheckSideEffects.java",
      "functionStartLine": 84,
      "functionName": "visit",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {}
    },
    "ff9dc85e994c34448130ee5bb38f801ab2f6ba16": {
      "type": "Ybodychange",
      "commitMessage": "\nProtect appearently side-effect free code from removal.\nFixes issue 64\nFixes issue 398\n\nR\u003dnicksantos\nDELTA\u003d256  (218 added, 11 deleted, 27 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d4091\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1725 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "1/13/12, 2:07 PM",
      "commitName": "ff9dc85e994c34448130ee5bb38f801ab2f6ba16",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "1/4/12, 11:53 AM",
      "commitNameOld": "5f8b6f54294ce8b454f78165f5230b3759d11e37",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 9.09,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.isEmpty() || n.isComma()) {\n        return;\n    }\n    if (parent \u003d\u003d null) {\n        return;\n    }\n    int pt \u003d parent.getType();\n    if (pt \u003d\u003d Token.COMMA) {\n        Node gramps \u003d parent.getParent();\n        if (gramps.isCall() \u0026\u0026 parent \u003d\u003d gramps.getFirstChild()) {\n            if (n \u003d\u003d parent.getFirstChild() \u0026\u0026 parent.getChildCount() \u003d\u003d 2 \u0026\u0026 n.getNext().isName() \u0026\u0026 \"eval\".equals(n.getNext().getString())) {\n                return;\n            }\n        }\n        if (n \u003d\u003d parent.getLastChild()) {\n            for (Node an : parent.getAncestors()) {\n                int ancestorType \u003d an.getType();\n                if (ancestorType \u003d\u003d Token.COMMA)\n                    continue;\n                if (ancestorType !\u003d Token.EXPR_RESULT \u0026\u0026 ancestorType !\u003d Token.BLOCK)\n                    return;\n                else\n                    break;\n            }\n        }\n    } else if (pt !\u003d Token.EXPR_RESULT \u0026\u0026 pt !\u003d Token.BLOCK) {\n        if (pt \u003d\u003d Token.FOR \u0026\u0026 parent.getChildCount() \u003d\u003d 4 \u0026\u0026 (n \u003d\u003d parent.getFirstChild() || n \u003d\u003d parent.getFirstChild().getNext().getNext())) {\n        } else {\n            return;\n        }\n    }\n    boolean isSimpleOp \u003d NodeUtil.isSimpleOperatorType(n.getType());\n    if (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler())) {\n        if (n.isQualifiedName() \u0026\u0026 n.getJSDocInfo() !\u003d null) {\n            return;\n        } else if (n.isExprResult()) {\n            return;\n        }\n        String msg \u003d \"This code lacks side-effects. Is there a bug?\";\n        if (n.isString()) {\n            msg \u003d \"Is there a missing \u0027+\u0027 on the previous line?\";\n        } else if (isSimpleOp) {\n            msg \u003d \"The result of the \u0027\" + Token.name(n.getType()).toLowerCase() + \"\u0027 operator is not being used.\";\n        }\n        t.getCompiler().report(t.makeError(n, level, USELESS_CODE_ERROR, msg));\n        if (!NodeUtil.isStatement(n)) {\n            problemNodes.add(n);\n        }\n    }\n}",
      "path": "src/com/google/javascript/jscomp/CheckSideEffects.java",
      "functionStartLine": 84,
      "functionName": "visit",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,48 +1,52 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n     if (n.isEmpty() || n.isComma()) {\n         return;\n     }\n-    if (parent \u003d\u003d null)\n+    if (parent \u003d\u003d null) {\n         return;\n+    }\n     int pt \u003d parent.getType();\n     if (pt \u003d\u003d Token.COMMA) {\n         Node gramps \u003d parent.getParent();\n         if (gramps.isCall() \u0026\u0026 parent \u003d\u003d gramps.getFirstChild()) {\n             if (n \u003d\u003d parent.getFirstChild() \u0026\u0026 parent.getChildCount() \u003d\u003d 2 \u0026\u0026 n.getNext().isName() \u0026\u0026 \"eval\".equals(n.getNext().getString())) {\n                 return;\n             }\n         }\n         if (n \u003d\u003d parent.getLastChild()) {\n             for (Node an : parent.getAncestors()) {\n                 int ancestorType \u003d an.getType();\n                 if (ancestorType \u003d\u003d Token.COMMA)\n                     continue;\n                 if (ancestorType !\u003d Token.EXPR_RESULT \u0026\u0026 ancestorType !\u003d Token.BLOCK)\n                     return;\n                 else\n                     break;\n             }\n         }\n     } else if (pt !\u003d Token.EXPR_RESULT \u0026\u0026 pt !\u003d Token.BLOCK) {\n         if (pt \u003d\u003d Token.FOR \u0026\u0026 parent.getChildCount() \u003d\u003d 4 \u0026\u0026 (n \u003d\u003d parent.getFirstChild() || n \u003d\u003d parent.getFirstChild().getNext().getNext())) {\n         } else {\n             return;\n         }\n     }\n     boolean isSimpleOp \u003d NodeUtil.isSimpleOperatorType(n.getType());\n     if (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler())) {\n         if (n.isQualifiedName() \u0026\u0026 n.getJSDocInfo() !\u003d null) {\n             return;\n         } else if (n.isExprResult()) {\n             return;\n         }\n         String msg \u003d \"This code lacks side-effects. Is there a bug?\";\n         if (n.isString()) {\n             msg \u003d \"Is there a missing \u0027+\u0027 on the previous line?\";\n         } else if (isSimpleOp) {\n             msg \u003d \"The result of the \u0027\" + Token.name(n.getType()).toLowerCase() + \"\u0027 operator is not being used.\";\n         }\n         t.getCompiler().report(t.makeError(n, level, USELESS_CODE_ERROR, msg));\n+        if (!NodeUtil.isStatement(n)) {\n+            problemNodes.add(n);\n+        }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5f8b6f54294ce8b454f78165f5230b3759d11e37": {
      "type": "Ybodychange",
      "commitMessage": "\nInline NodeUtil.isExpressionNode\n\nR\u003dnicksantos\nDELTA\u003d37  (0 added, 4 deleted, 33 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d4037\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1702 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "1/4/12, 11:53 AM",
      "commitName": "5f8b6f54294ce8b454f78165f5230b3759d11e37",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "11/17/11, 10:08 AM",
      "commitNameOld": "4e976ac213f448bab78f5c1432340c489b533d7b",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 48.07,
      "commitsBetweenForRepo": 77,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.isEmpty() || n.isComma()) {\n        return;\n    }\n    if (parent \u003d\u003d null)\n        return;\n    int pt \u003d parent.getType();\n    if (pt \u003d\u003d Token.COMMA) {\n        Node gramps \u003d parent.getParent();\n        if (gramps.isCall() \u0026\u0026 parent \u003d\u003d gramps.getFirstChild()) {\n            if (n \u003d\u003d parent.getFirstChild() \u0026\u0026 parent.getChildCount() \u003d\u003d 2 \u0026\u0026 n.getNext().isName() \u0026\u0026 \"eval\".equals(n.getNext().getString())) {\n                return;\n            }\n        }\n        if (n \u003d\u003d parent.getLastChild()) {\n            for (Node an : parent.getAncestors()) {\n                int ancestorType \u003d an.getType();\n                if (ancestorType \u003d\u003d Token.COMMA)\n                    continue;\n                if (ancestorType !\u003d Token.EXPR_RESULT \u0026\u0026 ancestorType !\u003d Token.BLOCK)\n                    return;\n                else\n                    break;\n            }\n        }\n    } else if (pt !\u003d Token.EXPR_RESULT \u0026\u0026 pt !\u003d Token.BLOCK) {\n        if (pt \u003d\u003d Token.FOR \u0026\u0026 parent.getChildCount() \u003d\u003d 4 \u0026\u0026 (n \u003d\u003d parent.getFirstChild() || n \u003d\u003d parent.getFirstChild().getNext().getNext())) {\n        } else {\n            return;\n        }\n    }\n    boolean isSimpleOp \u003d NodeUtil.isSimpleOperatorType(n.getType());\n    if (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler())) {\n        if (n.isQualifiedName() \u0026\u0026 n.getJSDocInfo() !\u003d null) {\n            return;\n        } else if (n.isExprResult()) {\n            return;\n        }\n        String msg \u003d \"This code lacks side-effects. Is there a bug?\";\n        if (n.isString()) {\n            msg \u003d \"Is there a missing \u0027+\u0027 on the previous line?\";\n        } else if (isSimpleOp) {\n            msg \u003d \"The result of the \u0027\" + Token.name(n.getType()).toLowerCase() + \"\u0027 operator is not being used.\";\n        }\n        t.getCompiler().report(t.makeError(n, level, USELESS_CODE_ERROR, msg));\n    }\n}",
      "path": "src/com/google/javascript/jscomp/CheckSideEffects.java",
      "functionStartLine": 48,
      "functionName": "visit",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,48 +1,48 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n     if (n.isEmpty() || n.isComma()) {\n         return;\n     }\n     if (parent \u003d\u003d null)\n         return;\n     int pt \u003d parent.getType();\n     if (pt \u003d\u003d Token.COMMA) {\n         Node gramps \u003d parent.getParent();\n         if (gramps.isCall() \u0026\u0026 parent \u003d\u003d gramps.getFirstChild()) {\n             if (n \u003d\u003d parent.getFirstChild() \u0026\u0026 parent.getChildCount() \u003d\u003d 2 \u0026\u0026 n.getNext().isName() \u0026\u0026 \"eval\".equals(n.getNext().getString())) {\n                 return;\n             }\n         }\n         if (n \u003d\u003d parent.getLastChild()) {\n             for (Node an : parent.getAncestors()) {\n                 int ancestorType \u003d an.getType();\n                 if (ancestorType \u003d\u003d Token.COMMA)\n                     continue;\n                 if (ancestorType !\u003d Token.EXPR_RESULT \u0026\u0026 ancestorType !\u003d Token.BLOCK)\n                     return;\n                 else\n                     break;\n             }\n         }\n     } else if (pt !\u003d Token.EXPR_RESULT \u0026\u0026 pt !\u003d Token.BLOCK) {\n         if (pt \u003d\u003d Token.FOR \u0026\u0026 parent.getChildCount() \u003d\u003d 4 \u0026\u0026 (n \u003d\u003d parent.getFirstChild() || n \u003d\u003d parent.getFirstChild().getNext().getNext())) {\n         } else {\n             return;\n         }\n     }\n     boolean isSimpleOp \u003d NodeUtil.isSimpleOperatorType(n.getType());\n     if (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler())) {\n         if (n.isQualifiedName() \u0026\u0026 n.getJSDocInfo() !\u003d null) {\n             return;\n-        } else if (NodeUtil.isExpressionNode(n)) {\n+        } else if (n.isExprResult()) {\n             return;\n         }\n         String msg \u003d \"This code lacks side-effects. Is there a bug?\";\n         if (n.isString()) {\n             msg \u003d \"Is there a missing \u0027+\u0027 on the previous line?\";\n         } else if (isSimpleOp) {\n             msg \u003d \"The result of the \u0027\" + Token.name(n.getType()).toLowerCase() + \"\u0027 operator is not being used.\";\n         }\n         t.getCompiler().report(t.makeError(n, level, USELESS_CODE_ERROR, msg));\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4e976ac213f448bab78f5c1432340c489b533d7b": {
      "type": "Ybodychange",
      "commitMessage": "\nRemove redundant Token to string function.\n\nR\u003dnicksantos\nDELTA\u003d148  (16 added, 89 deleted, 43 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3765\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1621 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/17/11, 10:08 AM",
      "commitName": "4e976ac213f448bab78f5c1432340c489b533d7b",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "11/10/11, 8:36 AM",
      "commitNameOld": "ec324a9bb23eb78c76f537f4c4170ba88d542f1c",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 7.06,
      "commitsBetweenForRepo": 30,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.isEmpty() || n.isComma()) {\n        return;\n    }\n    if (parent \u003d\u003d null)\n        return;\n    int pt \u003d parent.getType();\n    if (pt \u003d\u003d Token.COMMA) {\n        Node gramps \u003d parent.getParent();\n        if (gramps.isCall() \u0026\u0026 parent \u003d\u003d gramps.getFirstChild()) {\n            if (n \u003d\u003d parent.getFirstChild() \u0026\u0026 parent.getChildCount() \u003d\u003d 2 \u0026\u0026 n.getNext().isName() \u0026\u0026 \"eval\".equals(n.getNext().getString())) {\n                return;\n            }\n        }\n        if (n \u003d\u003d parent.getLastChild()) {\n            for (Node an : parent.getAncestors()) {\n                int ancestorType \u003d an.getType();\n                if (ancestorType \u003d\u003d Token.COMMA)\n                    continue;\n                if (ancestorType !\u003d Token.EXPR_RESULT \u0026\u0026 ancestorType !\u003d Token.BLOCK)\n                    return;\n                else\n                    break;\n            }\n        }\n    } else if (pt !\u003d Token.EXPR_RESULT \u0026\u0026 pt !\u003d Token.BLOCK) {\n        if (pt \u003d\u003d Token.FOR \u0026\u0026 parent.getChildCount() \u003d\u003d 4 \u0026\u0026 (n \u003d\u003d parent.getFirstChild() || n \u003d\u003d parent.getFirstChild().getNext().getNext())) {\n        } else {\n            return;\n        }\n    }\n    boolean isSimpleOp \u003d NodeUtil.isSimpleOperatorType(n.getType());\n    if (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler())) {\n        if (n.isQualifiedName() \u0026\u0026 n.getJSDocInfo() !\u003d null) {\n            return;\n        } else if (NodeUtil.isExpressionNode(n)) {\n            return;\n        }\n        String msg \u003d \"This code lacks side-effects. Is there a bug?\";\n        if (n.isString()) {\n            msg \u003d \"Is there a missing \u0027+\u0027 on the previous line?\";\n        } else if (isSimpleOp) {\n            msg \u003d \"The result of the \u0027\" + Token.name(n.getType()).toLowerCase() + \"\u0027 operator is not being used.\";\n        }\n        t.getCompiler().report(t.makeError(n, level, USELESS_CODE_ERROR, msg));\n    }\n}",
      "path": "src/com/google/javascript/jscomp/CheckSideEffects.java",
      "functionStartLine": 48,
      "functionName": "visit",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,48 +1,48 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n     if (n.isEmpty() || n.isComma()) {\n         return;\n     }\n     if (parent \u003d\u003d null)\n         return;\n     int pt \u003d parent.getType();\n     if (pt \u003d\u003d Token.COMMA) {\n         Node gramps \u003d parent.getParent();\n         if (gramps.isCall() \u0026\u0026 parent \u003d\u003d gramps.getFirstChild()) {\n             if (n \u003d\u003d parent.getFirstChild() \u0026\u0026 parent.getChildCount() \u003d\u003d 2 \u0026\u0026 n.getNext().isName() \u0026\u0026 \"eval\".equals(n.getNext().getString())) {\n                 return;\n             }\n         }\n         if (n \u003d\u003d parent.getLastChild()) {\n             for (Node an : parent.getAncestors()) {\n                 int ancestorType \u003d an.getType();\n                 if (ancestorType \u003d\u003d Token.COMMA)\n                     continue;\n                 if (ancestorType !\u003d Token.EXPR_RESULT \u0026\u0026 ancestorType !\u003d Token.BLOCK)\n                     return;\n                 else\n                     break;\n             }\n         }\n     } else if (pt !\u003d Token.EXPR_RESULT \u0026\u0026 pt !\u003d Token.BLOCK) {\n         if (pt \u003d\u003d Token.FOR \u0026\u0026 parent.getChildCount() \u003d\u003d 4 \u0026\u0026 (n \u003d\u003d parent.getFirstChild() || n \u003d\u003d parent.getFirstChild().getNext().getNext())) {\n         } else {\n             return;\n         }\n     }\n     boolean isSimpleOp \u003d NodeUtil.isSimpleOperatorType(n.getType());\n     if (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler())) {\n         if (n.isQualifiedName() \u0026\u0026 n.getJSDocInfo() !\u003d null) {\n             return;\n         } else if (NodeUtil.isExpressionNode(n)) {\n             return;\n         }\n         String msg \u003d \"This code lacks side-effects. Is there a bug?\";\n         if (n.isString()) {\n             msg \u003d \"Is there a missing \u0027+\u0027 on the previous line?\";\n         } else if (isSimpleOp) {\n-            msg \u003d \"The result of the \u0027\" + Node.tokenToName(n.getType()) + \"\u0027 operator is not being used.\";\n+            msg \u003d \"The result of the \u0027\" + Token.name(n.getType()).toLowerCase() + \"\u0027 operator is not being used.\";\n         }\n         t.getCompiler().report(t.makeError(n, level, USELESS_CODE_ERROR, msg));\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ec324a9bb23eb78c76f537f4c4170ba88d542f1c": {
      "type": "Ybodychange",
      "commitMessage": "\nReplace the bulk of the Node.getType() \u003d\u003d Token.XXX calls with\nNode.isXXX calls.\n\nR\u003dnicksantos\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d3677\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1582 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/10/11, 8:36 AM",
      "commitName": "ec324a9bb23eb78c76f537f4c4170ba88d542f1c",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "7/28/11, 4:19 PM",
      "commitNameOld": "76abdf11394c0e7515ae63335676ea3657badb45",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 104.72,
      "commitsBetweenForRepo": 250,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.isEmpty() || n.isComma()) {\n        return;\n    }\n    if (parent \u003d\u003d null)\n        return;\n    int pt \u003d parent.getType();\n    if (pt \u003d\u003d Token.COMMA) {\n        Node gramps \u003d parent.getParent();\n        if (gramps.isCall() \u0026\u0026 parent \u003d\u003d gramps.getFirstChild()) {\n            if (n \u003d\u003d parent.getFirstChild() \u0026\u0026 parent.getChildCount() \u003d\u003d 2 \u0026\u0026 n.getNext().isName() \u0026\u0026 \"eval\".equals(n.getNext().getString())) {\n                return;\n            }\n        }\n        if (n \u003d\u003d parent.getLastChild()) {\n            for (Node an : parent.getAncestors()) {\n                int ancestorType \u003d an.getType();\n                if (ancestorType \u003d\u003d Token.COMMA)\n                    continue;\n                if (ancestorType !\u003d Token.EXPR_RESULT \u0026\u0026 ancestorType !\u003d Token.BLOCK)\n                    return;\n                else\n                    break;\n            }\n        }\n    } else if (pt !\u003d Token.EXPR_RESULT \u0026\u0026 pt !\u003d Token.BLOCK) {\n        if (pt \u003d\u003d Token.FOR \u0026\u0026 parent.getChildCount() \u003d\u003d 4 \u0026\u0026 (n \u003d\u003d parent.getFirstChild() || n \u003d\u003d parent.getFirstChild().getNext().getNext())) {\n        } else {\n            return;\n        }\n    }\n    boolean isSimpleOp \u003d NodeUtil.isSimpleOperatorType(n.getType());\n    if (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler())) {\n        if (n.isQualifiedName() \u0026\u0026 n.getJSDocInfo() !\u003d null) {\n            return;\n        } else if (NodeUtil.isExpressionNode(n)) {\n            return;\n        }\n        String msg \u003d \"This code lacks side-effects. Is there a bug?\";\n        if (n.isString()) {\n            msg \u003d \"Is there a missing \u0027+\u0027 on the previous line?\";\n        } else if (isSimpleOp) {\n            msg \u003d \"The result of the \u0027\" + Node.tokenToName(n.getType()) + \"\u0027 operator is not being used.\";\n        }\n        t.getCompiler().report(t.makeError(n, level, USELESS_CODE_ERROR, msg));\n    }\n}",
      "path": "src/com/google/javascript/jscomp/CheckSideEffects.java",
      "functionStartLine": 48,
      "functionName": "visit",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,48 +1,48 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.getType() \u003d\u003d Token.EMPTY || n.getType() \u003d\u003d Token.COMMA) {\n+    if (n.isEmpty() || n.isComma()) {\n         return;\n     }\n     if (parent \u003d\u003d null)\n         return;\n     int pt \u003d parent.getType();\n     if (pt \u003d\u003d Token.COMMA) {\n         Node gramps \u003d parent.getParent();\n-        if (gramps.getType() \u003d\u003d Token.CALL \u0026\u0026 parent \u003d\u003d gramps.getFirstChild()) {\n-            if (n \u003d\u003d parent.getFirstChild() \u0026\u0026 parent.getChildCount() \u003d\u003d 2 \u0026\u0026 n.getNext().getType() \u003d\u003d Token.NAME \u0026\u0026 \"eval\".equals(n.getNext().getString())) {\n+        if (gramps.isCall() \u0026\u0026 parent \u003d\u003d gramps.getFirstChild()) {\n+            if (n \u003d\u003d parent.getFirstChild() \u0026\u0026 parent.getChildCount() \u003d\u003d 2 \u0026\u0026 n.getNext().isName() \u0026\u0026 \"eval\".equals(n.getNext().getString())) {\n                 return;\n             }\n         }\n         if (n \u003d\u003d parent.getLastChild()) {\n             for (Node an : parent.getAncestors()) {\n                 int ancestorType \u003d an.getType();\n                 if (ancestorType \u003d\u003d Token.COMMA)\n                     continue;\n                 if (ancestorType !\u003d Token.EXPR_RESULT \u0026\u0026 ancestorType !\u003d Token.BLOCK)\n                     return;\n                 else\n                     break;\n             }\n         }\n     } else if (pt !\u003d Token.EXPR_RESULT \u0026\u0026 pt !\u003d Token.BLOCK) {\n         if (pt \u003d\u003d Token.FOR \u0026\u0026 parent.getChildCount() \u003d\u003d 4 \u0026\u0026 (n \u003d\u003d parent.getFirstChild() || n \u003d\u003d parent.getFirstChild().getNext().getNext())) {\n         } else {\n             return;\n         }\n     }\n     boolean isSimpleOp \u003d NodeUtil.isSimpleOperatorType(n.getType());\n     if (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler())) {\n         if (n.isQualifiedName() \u0026\u0026 n.getJSDocInfo() !\u003d null) {\n             return;\n         } else if (NodeUtil.isExpressionNode(n)) {\n             return;\n         }\n         String msg \u003d \"This code lacks side-effects. Is there a bug?\";\n-        if (n.getType() \u003d\u003d Token.STRING) {\n+        if (n.isString()) {\n             msg \u003d \"Is there a missing \u0027+\u0027 on the previous line?\";\n         } else if (isSimpleOp) {\n             msg \u003d \"The result of the \u0027\" + Node.tokenToName(n.getType()) + \"\u0027 operator is not being used.\";\n         }\n         t.getCompiler().report(t.makeError(n, level, USELESS_CODE_ERROR, msg));\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "76abdf11394c0e7515ae63335676ea3657badb45": {
      "type": "Yannotationchange",
      "commitMessage": "\nMake our build warnings free.\n\nR\u003dacleung\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d2830\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1301 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "7/28/11, 4:19 PM",
      "commitName": "76abdf11394c0e7515ae63335676ea3657badb45",
      "commitAuthor": "johnlenz@google.com",
      "commitDateOld": "7/6/11, 8:14 PM",
      "commitNameOld": "a07ce4c8fa380151233f3a155fff1e37c117aae0",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 21.84,
      "commitsBetweenForRepo": 48,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() \u003d\u003d Token.EMPTY || n.getType() \u003d\u003d Token.COMMA) {\n        return;\n    }\n    if (parent \u003d\u003d null)\n        return;\n    int pt \u003d parent.getType();\n    if (pt \u003d\u003d Token.COMMA) {\n        Node gramps \u003d parent.getParent();\n        if (gramps.getType() \u003d\u003d Token.CALL \u0026\u0026 parent \u003d\u003d gramps.getFirstChild()) {\n            if (n \u003d\u003d parent.getFirstChild() \u0026\u0026 parent.getChildCount() \u003d\u003d 2 \u0026\u0026 n.getNext().getType() \u003d\u003d Token.NAME \u0026\u0026 \"eval\".equals(n.getNext().getString())) {\n                return;\n            }\n        }\n        if (n \u003d\u003d parent.getLastChild()) {\n            for (Node an : parent.getAncestors()) {\n                int ancestorType \u003d an.getType();\n                if (ancestorType \u003d\u003d Token.COMMA)\n                    continue;\n                if (ancestorType !\u003d Token.EXPR_RESULT \u0026\u0026 ancestorType !\u003d Token.BLOCK)\n                    return;\n                else\n                    break;\n            }\n        }\n    } else if (pt !\u003d Token.EXPR_RESULT \u0026\u0026 pt !\u003d Token.BLOCK) {\n        if (pt \u003d\u003d Token.FOR \u0026\u0026 parent.getChildCount() \u003d\u003d 4 \u0026\u0026 (n \u003d\u003d parent.getFirstChild() || n \u003d\u003d parent.getFirstChild().getNext().getNext())) {\n        } else {\n            return;\n        }\n    }\n    boolean isSimpleOp \u003d NodeUtil.isSimpleOperatorType(n.getType());\n    if (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler())) {\n        if (n.isQualifiedName() \u0026\u0026 n.getJSDocInfo() !\u003d null) {\n            return;\n        } else if (NodeUtil.isExpressionNode(n)) {\n            return;\n        }\n        String msg \u003d \"This code lacks side-effects. Is there a bug?\";\n        if (n.getType() \u003d\u003d Token.STRING) {\n            msg \u003d \"Is there a missing \u0027+\u0027 on the previous line?\";\n        } else if (isSimpleOp) {\n            msg \u003d \"The result of the \u0027\" + Node.tokenToName(n.getType()) + \"\u0027 operator is not being used.\";\n        }\n        t.getCompiler().report(t.makeError(n, level, USELESS_CODE_ERROR, msg));\n    }\n}",
      "path": "src/com/google/javascript/jscomp/CheckSideEffects.java",
      "functionStartLine": 48,
      "functionName": "visit",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,47 +1,48 @@\n+@Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n     if (n.getType() \u003d\u003d Token.EMPTY || n.getType() \u003d\u003d Token.COMMA) {\n         return;\n     }\n     if (parent \u003d\u003d null)\n         return;\n     int pt \u003d parent.getType();\n     if (pt \u003d\u003d Token.COMMA) {\n         Node gramps \u003d parent.getParent();\n         if (gramps.getType() \u003d\u003d Token.CALL \u0026\u0026 parent \u003d\u003d gramps.getFirstChild()) {\n             if (n \u003d\u003d parent.getFirstChild() \u0026\u0026 parent.getChildCount() \u003d\u003d 2 \u0026\u0026 n.getNext().getType() \u003d\u003d Token.NAME \u0026\u0026 \"eval\".equals(n.getNext().getString())) {\n                 return;\n             }\n         }\n         if (n \u003d\u003d parent.getLastChild()) {\n             for (Node an : parent.getAncestors()) {\n                 int ancestorType \u003d an.getType();\n                 if (ancestorType \u003d\u003d Token.COMMA)\n                     continue;\n                 if (ancestorType !\u003d Token.EXPR_RESULT \u0026\u0026 ancestorType !\u003d Token.BLOCK)\n                     return;\n                 else\n                     break;\n             }\n         }\n     } else if (pt !\u003d Token.EXPR_RESULT \u0026\u0026 pt !\u003d Token.BLOCK) {\n         if (pt \u003d\u003d Token.FOR \u0026\u0026 parent.getChildCount() \u003d\u003d 4 \u0026\u0026 (n \u003d\u003d parent.getFirstChild() || n \u003d\u003d parent.getFirstChild().getNext().getNext())) {\n         } else {\n             return;\n         }\n     }\n     boolean isSimpleOp \u003d NodeUtil.isSimpleOperatorType(n.getType());\n     if (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler())) {\n         if (n.isQualifiedName() \u0026\u0026 n.getJSDocInfo() !\u003d null) {\n             return;\n         } else if (NodeUtil.isExpressionNode(n)) {\n             return;\n         }\n         String msg \u003d \"This code lacks side-effects. Is there a bug?\";\n         if (n.getType() \u003d\u003d Token.STRING) {\n             msg \u003d \"Is there a missing \u0027+\u0027 on the previous line?\";\n         } else if (isSimpleOp) {\n             msg \u003d \"The result of the \u0027\" + Node.tokenToName(n.getType()) + \"\u0027 operator is not being used.\";\n         }\n         t.getCompiler().report(t.makeError(n, level, USELESS_CODE_ERROR, msg));\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "",
        "newValue": "@Override"
      }
    },
    "a07ce4c8fa380151233f3a155fff1e37c117aae0": {
      "type": "Ybodychange",
      "commitMessage": "\nBetter error messaging about operators whose result is unused.\n\nR\u003dacleung\nDELTA\u003d13  (12 added, 0 deleted, 1 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d2507\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1249 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "7/6/11, 8:14 PM",
      "commitName": "a07ce4c8fa380151233f3a155fff1e37c117aae0",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "4/12/11, 12:15 PM",
      "commitNameOld": "f322be0e576d5e2114cb59c0a6537197997b9c59",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 85.33,
      "commitsBetweenForRepo": 241,
      "commitsBetweenForFile": 1,
      "actualSource": "public void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() \u003d\u003d Token.EMPTY || n.getType() \u003d\u003d Token.COMMA) {\n        return;\n    }\n    if (parent \u003d\u003d null)\n        return;\n    int pt \u003d parent.getType();\n    if (pt \u003d\u003d Token.COMMA) {\n        Node gramps \u003d parent.getParent();\n        if (gramps.getType() \u003d\u003d Token.CALL \u0026\u0026 parent \u003d\u003d gramps.getFirstChild()) {\n            if (n \u003d\u003d parent.getFirstChild() \u0026\u0026 parent.getChildCount() \u003d\u003d 2 \u0026\u0026 n.getNext().getType() \u003d\u003d Token.NAME \u0026\u0026 \"eval\".equals(n.getNext().getString())) {\n                return;\n            }\n        }\n        if (n \u003d\u003d parent.getLastChild()) {\n            for (Node an : parent.getAncestors()) {\n                int ancestorType \u003d an.getType();\n                if (ancestorType \u003d\u003d Token.COMMA)\n                    continue;\n                if (ancestorType !\u003d Token.EXPR_RESULT \u0026\u0026 ancestorType !\u003d Token.BLOCK)\n                    return;\n                else\n                    break;\n            }\n        }\n    } else if (pt !\u003d Token.EXPR_RESULT \u0026\u0026 pt !\u003d Token.BLOCK) {\n        if (pt \u003d\u003d Token.FOR \u0026\u0026 parent.getChildCount() \u003d\u003d 4 \u0026\u0026 (n \u003d\u003d parent.getFirstChild() || n \u003d\u003d parent.getFirstChild().getNext().getNext())) {\n        } else {\n            return;\n        }\n    }\n    boolean isSimpleOp \u003d NodeUtil.isSimpleOperatorType(n.getType());\n    if (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler())) {\n        if (n.isQualifiedName() \u0026\u0026 n.getJSDocInfo() !\u003d null) {\n            return;\n        } else if (NodeUtil.isExpressionNode(n)) {\n            return;\n        }\n        String msg \u003d \"This code lacks side-effects. Is there a bug?\";\n        if (n.getType() \u003d\u003d Token.STRING) {\n            msg \u003d \"Is there a missing \u0027+\u0027 on the previous line?\";\n        } else if (isSimpleOp) {\n            msg \u003d \"The result of the \u0027\" + Node.tokenToName(n.getType()) + \"\u0027 operator is not being used.\";\n        }\n        t.getCompiler().report(t.makeError(n, level, USELESS_CODE_ERROR, msg));\n    }\n}",
      "path": "src/com/google/javascript/jscomp/CheckSideEffects.java",
      "functionStartLine": 47,
      "functionName": "visit",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,44 +1,47 @@\n public void visit(NodeTraversal t, Node n, Node parent) {\n     if (n.getType() \u003d\u003d Token.EMPTY || n.getType() \u003d\u003d Token.COMMA) {\n         return;\n     }\n     if (parent \u003d\u003d null)\n         return;\n     int pt \u003d parent.getType();\n     if (pt \u003d\u003d Token.COMMA) {\n         Node gramps \u003d parent.getParent();\n         if (gramps.getType() \u003d\u003d Token.CALL \u0026\u0026 parent \u003d\u003d gramps.getFirstChild()) {\n             if (n \u003d\u003d parent.getFirstChild() \u0026\u0026 parent.getChildCount() \u003d\u003d 2 \u0026\u0026 n.getNext().getType() \u003d\u003d Token.NAME \u0026\u0026 \"eval\".equals(n.getNext().getString())) {\n                 return;\n             }\n         }\n         if (n \u003d\u003d parent.getLastChild()) {\n             for (Node an : parent.getAncestors()) {\n                 int ancestorType \u003d an.getType();\n                 if (ancestorType \u003d\u003d Token.COMMA)\n                     continue;\n                 if (ancestorType !\u003d Token.EXPR_RESULT \u0026\u0026 ancestorType !\u003d Token.BLOCK)\n                     return;\n                 else\n                     break;\n             }\n         }\n     } else if (pt !\u003d Token.EXPR_RESULT \u0026\u0026 pt !\u003d Token.BLOCK) {\n         if (pt \u003d\u003d Token.FOR \u0026\u0026 parent.getChildCount() \u003d\u003d 4 \u0026\u0026 (n \u003d\u003d parent.getFirstChild() || n \u003d\u003d parent.getFirstChild().getNext().getNext())) {\n         } else {\n             return;\n         }\n     }\n-    if (NodeUtil.isSimpleOperatorType(n.getType()) || !NodeUtil.mayHaveSideEffects(n, t.getCompiler())) {\n+    boolean isSimpleOp \u003d NodeUtil.isSimpleOperatorType(n.getType());\n+    if (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler())) {\n         if (n.isQualifiedName() \u0026\u0026 n.getJSDocInfo() !\u003d null) {\n             return;\n         } else if (NodeUtil.isExpressionNode(n)) {\n             return;\n         }\n         String msg \u003d \"This code lacks side-effects. Is there a bug?\";\n         if (n.getType() \u003d\u003d Token.STRING) {\n             msg \u003d \"Is there a missing \u0027+\u0027 on the previous line?\";\n+        } else if (isSimpleOp) {\n+            msg \u003d \"The result of the \u0027\" + Node.tokenToName(n.getType()) + \"\u0027 operator is not being used.\";\n         }\n         t.getCompiler().report(t.makeError(n, level, USELESS_CODE_ERROR, msg));\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "80fe41fd0173c3eaa56f4abb783031966ea89cef": {
      "type": "Ybodychange",
      "commitMessage": "\nChange on 2010/04/09 by john\n\n        Part II: Use global RegExp reference information to optimize references when possible.\n\n        R\u003dalan\n        DELTA\u003d231  (173 added, 17 deleted, 41 changed)\n\nChange on 2010/04/09 by nicksantos\n\n        Make JsFileLineParser much more efficient for large files\n        (we were running into problems with it running out of memory.)\n\n        R\u003dandrew\n        DELTA\u003d192  (157 added, 1 deleted, 34 changed)\n\nChange on 2010/04/09 by alan\n\n        Fix typed code gen crash when generating typed code.\n\n        R\u003dnicksantos\n        DELTA\u003d35  (24 added, 2 deleted, 9 changed)\n\nChange on 2010/04/09 by alan\n\n        Disable method motion on functions that reads closure variables.\n\n        R\u003dnicksantos\n        DELTA\u003d171  (162 added, 1 deleted, 8 changed)\n\nChange on 2010/04/12 by nada\n\n        In AmbiguateProperties, invert the related type relationship, by\n        considering subclasses and implementors (down) instead of superclasses\n        and implemented interfaces (up). This has two advantages:\n\n        - The \u0027independent of\u0027 relationship is simplified, because we only\n          need to consider whether the related types intersect.\n\n        - We can account for \u0027multiple inheritance\u0027, which is a practical\n          issue because of interfaces.\n\n        Note that the \u0027up\u0027 relationship allows us to easily find common\n        ancestors while the \u0027down\u0027 relationship allows us to easily find\n        common descendants -- and this is what we care about for ambiguation.\n\n\n        R\u003dmoedinger\n        DELTA\u003d173  (124 added, 15 deleted, 34 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003dmwgnge\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@180 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/12/10, 7:59 AM",
      "commitName": "80fe41fd0173c3eaa56f4abb783031966ea89cef",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "3/29/10, 7:04 AM",
      "commitNameOld": "3cc8b3a5889f8b88ef7a2bd0b8ccea8cb0d916c4",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 14.04,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "actualSource": "public void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() \u003d\u003d Token.EMPTY || n.getType() \u003d\u003d Token.COMMA) {\n        return;\n    }\n    if (parent \u003d\u003d null)\n        return;\n    int pt \u003d parent.getType();\n    if (pt \u003d\u003d Token.COMMA) {\n        Node gramps \u003d parent.getParent();\n        if (gramps.getType() \u003d\u003d Token.CALL \u0026\u0026 parent \u003d\u003d gramps.getFirstChild()) {\n            if (n \u003d\u003d parent.getFirstChild() \u0026\u0026 parent.getChildCount() \u003d\u003d 2 \u0026\u0026 n.getNext().getType() \u003d\u003d Token.NAME \u0026\u0026 \"eval\".equals(n.getNext().getString())) {\n                return;\n            }\n        }\n        if (n \u003d\u003d parent.getLastChild()) {\n            for (Node an : parent.getAncestors()) {\n                int ancestorType \u003d an.getType();\n                if (ancestorType \u003d\u003d Token.COMMA)\n                    continue;\n                if (ancestorType !\u003d Token.EXPR_RESULT \u0026\u0026 ancestorType !\u003d Token.BLOCK)\n                    return;\n                else\n                    break;\n            }\n        }\n    } else if (pt !\u003d Token.EXPR_RESULT \u0026\u0026 pt !\u003d Token.BLOCK) {\n        if (pt \u003d\u003d Token.FOR \u0026\u0026 parent.getChildCount() \u003d\u003d 4 \u0026\u0026 (n \u003d\u003d parent.getFirstChild() || n \u003d\u003d parent.getFirstChild().getNext().getNext())) {\n        } else {\n            return;\n        }\n    }\n    if (NodeUtil.isSimpleOperatorType(n.getType()) || !NodeUtil.mayHaveSideEffects(n, t.getCompiler())) {\n        if (n.isQualifiedName() \u0026\u0026 n.getJSDocInfo() !\u003d null) {\n            return;\n        } else if (NodeUtil.isExpressionNode(n)) {\n            return;\n        }\n        String msg \u003d \"This code lacks side-effects. Is there a bug?\";\n        if (n.getType() \u003d\u003d Token.STRING) {\n            msg \u003d \"Is there a missing \u0027+\u0027 on the previous line?\";\n        }\n        t.getCompiler().report(t.makeError(n, level, USELESS_CODE_ERROR, msg));\n    }\n}",
      "path": "src/com/google/javascript/jscomp/CheckSideEffects.java",
      "functionStartLine": 49,
      "functionName": "visit",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,44 +1,44 @@\n public void visit(NodeTraversal t, Node n, Node parent) {\n     if (n.getType() \u003d\u003d Token.EMPTY || n.getType() \u003d\u003d Token.COMMA) {\n         return;\n     }\n     if (parent \u003d\u003d null)\n         return;\n     int pt \u003d parent.getType();\n     if (pt \u003d\u003d Token.COMMA) {\n         Node gramps \u003d parent.getParent();\n         if (gramps.getType() \u003d\u003d Token.CALL \u0026\u0026 parent \u003d\u003d gramps.getFirstChild()) {\n             if (n \u003d\u003d parent.getFirstChild() \u0026\u0026 parent.getChildCount() \u003d\u003d 2 \u0026\u0026 n.getNext().getType() \u003d\u003d Token.NAME \u0026\u0026 \"eval\".equals(n.getNext().getString())) {\n                 return;\n             }\n         }\n         if (n \u003d\u003d parent.getLastChild()) {\n             for (Node an : parent.getAncestors()) {\n                 int ancestorType \u003d an.getType();\n                 if (ancestorType \u003d\u003d Token.COMMA)\n                     continue;\n                 if (ancestorType !\u003d Token.EXPR_RESULT \u0026\u0026 ancestorType !\u003d Token.BLOCK)\n                     return;\n                 else\n                     break;\n             }\n         }\n     } else if (pt !\u003d Token.EXPR_RESULT \u0026\u0026 pt !\u003d Token.BLOCK) {\n         if (pt \u003d\u003d Token.FOR \u0026\u0026 parent.getChildCount() \u003d\u003d 4 \u0026\u0026 (n \u003d\u003d parent.getFirstChild() || n \u003d\u003d parent.getFirstChild().getNext().getNext())) {\n         } else {\n             return;\n         }\n     }\n-    if (NodeUtil.isSimpleOperatorType(n.getType()) || !NodeUtil.mayHaveSideEffects(n)) {\n+    if (NodeUtil.isSimpleOperatorType(n.getType()) || !NodeUtil.mayHaveSideEffects(n, t.getCompiler())) {\n         if (n.isQualifiedName() \u0026\u0026 n.getJSDocInfo() !\u003d null) {\n             return;\n         } else if (NodeUtil.isExpressionNode(n)) {\n             return;\n         }\n         String msg \u003d \"This code lacks side-effects. Is there a bug?\";\n         if (n.getType() \u003d\u003d Token.STRING) {\n             msg \u003d \"Is there a missing \u0027+\u0027 on the previous line?\";\n         }\n         t.getCompiler().report(t.makeError(n, level, USELESS_CODE_ERROR, msg));\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3cc8b3a5889f8b88ef7a2bd0b8ccea8cb0d916c4": {
      "type": "Ybodychange",
      "commitMessage": "Remove circular dependency between error-reporting and the rest\nof the compiler. (Nick)\nR\u003dalan\nDELTA\u003d152  (27 added, 28 deleted, 97 changed)\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@159 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "3/29/10, 7:04 AM",
      "commitName": "3cc8b3a5889f8b88ef7a2bd0b8ccea8cb0d916c4",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "1/27/10, 3:48 PM",
      "commitNameOld": "c857311f08df730f98cc47e9b59383b0349fe9b3",
      "commitAuthorOld": "dbentley@google.com",
      "daysBetweenCommits": 60.6,
      "commitsBetweenForRepo": 77,
      "commitsBetweenForFile": 1,
      "actualSource": "public void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() \u003d\u003d Token.EMPTY || n.getType() \u003d\u003d Token.COMMA) {\n        return;\n    }\n    if (parent \u003d\u003d null)\n        return;\n    int pt \u003d parent.getType();\n    if (pt \u003d\u003d Token.COMMA) {\n        Node gramps \u003d parent.getParent();\n        if (gramps.getType() \u003d\u003d Token.CALL \u0026\u0026 parent \u003d\u003d gramps.getFirstChild()) {\n            if (n \u003d\u003d parent.getFirstChild() \u0026\u0026 parent.getChildCount() \u003d\u003d 2 \u0026\u0026 n.getNext().getType() \u003d\u003d Token.NAME \u0026\u0026 \"eval\".equals(n.getNext().getString())) {\n                return;\n            }\n        }\n        if (n \u003d\u003d parent.getLastChild()) {\n            for (Node an : parent.getAncestors()) {\n                int ancestorType \u003d an.getType();\n                if (ancestorType \u003d\u003d Token.COMMA)\n                    continue;\n                if (ancestorType !\u003d Token.EXPR_RESULT \u0026\u0026 ancestorType !\u003d Token.BLOCK)\n                    return;\n                else\n                    break;\n            }\n        }\n    } else if (pt !\u003d Token.EXPR_RESULT \u0026\u0026 pt !\u003d Token.BLOCK) {\n        if (pt \u003d\u003d Token.FOR \u0026\u0026 parent.getChildCount() \u003d\u003d 4 \u0026\u0026 (n \u003d\u003d parent.getFirstChild() || n \u003d\u003d parent.getFirstChild().getNext().getNext())) {\n        } else {\n            return;\n        }\n    }\n    if (NodeUtil.isSimpleOperatorType(n.getType()) || !NodeUtil.mayHaveSideEffects(n)) {\n        if (n.isQualifiedName() \u0026\u0026 n.getJSDocInfo() !\u003d null) {\n            return;\n        } else if (NodeUtil.isExpressionNode(n)) {\n            return;\n        }\n        String msg \u003d \"This code lacks side-effects. Is there a bug?\";\n        if (n.getType() \u003d\u003d Token.STRING) {\n            msg \u003d \"Is there a missing \u0027+\u0027 on the previous line?\";\n        }\n        t.getCompiler().report(t.makeError(n, level, USELESS_CODE_ERROR, msg));\n    }\n}",
      "path": "src/com/google/javascript/jscomp/CheckSideEffects.java",
      "functionStartLine": 49,
      "functionName": "visit",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,44 +1,44 @@\n public void visit(NodeTraversal t, Node n, Node parent) {\n     if (n.getType() \u003d\u003d Token.EMPTY || n.getType() \u003d\u003d Token.COMMA) {\n         return;\n     }\n     if (parent \u003d\u003d null)\n         return;\n     int pt \u003d parent.getType();\n     if (pt \u003d\u003d Token.COMMA) {\n         Node gramps \u003d parent.getParent();\n         if (gramps.getType() \u003d\u003d Token.CALL \u0026\u0026 parent \u003d\u003d gramps.getFirstChild()) {\n             if (n \u003d\u003d parent.getFirstChild() \u0026\u0026 parent.getChildCount() \u003d\u003d 2 \u0026\u0026 n.getNext().getType() \u003d\u003d Token.NAME \u0026\u0026 \"eval\".equals(n.getNext().getString())) {\n                 return;\n             }\n         }\n         if (n \u003d\u003d parent.getLastChild()) {\n             for (Node an : parent.getAncestors()) {\n                 int ancestorType \u003d an.getType();\n                 if (ancestorType \u003d\u003d Token.COMMA)\n                     continue;\n                 if (ancestorType !\u003d Token.EXPR_RESULT \u0026\u0026 ancestorType !\u003d Token.BLOCK)\n                     return;\n                 else\n                     break;\n             }\n         }\n     } else if (pt !\u003d Token.EXPR_RESULT \u0026\u0026 pt !\u003d Token.BLOCK) {\n         if (pt \u003d\u003d Token.FOR \u0026\u0026 parent.getChildCount() \u003d\u003d 4 \u0026\u0026 (n \u003d\u003d parent.getFirstChild() || n \u003d\u003d parent.getFirstChild().getNext().getNext())) {\n         } else {\n             return;\n         }\n     }\n     if (NodeUtil.isSimpleOperatorType(n.getType()) || !NodeUtil.mayHaveSideEffects(n)) {\n         if (n.isQualifiedName() \u0026\u0026 n.getJSDocInfo() !\u003d null) {\n             return;\n         } else if (NodeUtil.isExpressionNode(n)) {\n             return;\n         }\n         String msg \u003d \"This code lacks side-effects. Is there a bug?\";\n         if (n.getType() \u003d\u003d Token.STRING) {\n             msg \u003d \"Is there a missing \u0027+\u0027 on the previous line?\";\n         }\n-        t.getCompiler().report(JSError.make(t, n, level, USELESS_CODE_ERROR, msg));\n+        t.getCompiler().report(t.makeError(n, level, USELESS_CODE_ERROR, msg));\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c857311f08df730f98cc47e9b59383b0349fe9b3": {
      "type": "Ybodychange",
      "commitMessage": "Allow the COMMA operator to be used to make a call to eval indirect.\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@78 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "1/27/10, 3:48 PM",
      "commitName": "c857311f08df730f98cc47e9b59383b0349fe9b3",
      "commitAuthor": "dbentley@google.com",
      "commitDateOld": "11/3/09, 3:51 PM",
      "commitNameOld": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthorOld": "nicholas.j.santos@gmail.com",
      "daysBetweenCommits": 85.0,
      "commitsBetweenForRepo": 55,
      "commitsBetweenForFile": 1,
      "actualSource": "public void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() \u003d\u003d Token.EMPTY || n.getType() \u003d\u003d Token.COMMA) {\n        return;\n    }\n    if (parent \u003d\u003d null)\n        return;\n    int pt \u003d parent.getType();\n    if (pt \u003d\u003d Token.COMMA) {\n        Node gramps \u003d parent.getParent();\n        if (gramps.getType() \u003d\u003d Token.CALL \u0026\u0026 parent \u003d\u003d gramps.getFirstChild()) {\n            if (n \u003d\u003d parent.getFirstChild() \u0026\u0026 parent.getChildCount() \u003d\u003d 2 \u0026\u0026 n.getNext().getType() \u003d\u003d Token.NAME \u0026\u0026 \"eval\".equals(n.getNext().getString())) {\n                return;\n            }\n        }\n        if (n \u003d\u003d parent.getLastChild()) {\n            for (Node an : parent.getAncestors()) {\n                int ancestorType \u003d an.getType();\n                if (ancestorType \u003d\u003d Token.COMMA)\n                    continue;\n                if (ancestorType !\u003d Token.EXPR_RESULT \u0026\u0026 ancestorType !\u003d Token.BLOCK)\n                    return;\n                else\n                    break;\n            }\n        }\n    } else if (pt !\u003d Token.EXPR_RESULT \u0026\u0026 pt !\u003d Token.BLOCK) {\n        if (pt \u003d\u003d Token.FOR \u0026\u0026 parent.getChildCount() \u003d\u003d 4 \u0026\u0026 (n \u003d\u003d parent.getFirstChild() || n \u003d\u003d parent.getFirstChild().getNext().getNext())) {\n        } else {\n            return;\n        }\n    }\n    if (NodeUtil.isSimpleOperatorType(n.getType()) || !NodeUtil.mayHaveSideEffects(n)) {\n        if (n.isQualifiedName() \u0026\u0026 n.getJSDocInfo() !\u003d null) {\n            return;\n        } else if (NodeUtil.isExpressionNode(n)) {\n            return;\n        }\n        String msg \u003d \"This code lacks side-effects. Is there a bug?\";\n        if (n.getType() \u003d\u003d Token.STRING) {\n            msg \u003d \"Is there a missing \u0027+\u0027 on the previous line?\";\n        }\n        t.getCompiler().report(JSError.make(t, n, level, USELESS_CODE_ERROR, msg));\n    }\n}",
      "path": "src/com/google/javascript/jscomp/CheckSideEffects.java",
      "functionStartLine": 49,
      "functionName": "visit",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,38 +1,44 @@\n public void visit(NodeTraversal t, Node n, Node parent) {\n     if (n.getType() \u003d\u003d Token.EMPTY || n.getType() \u003d\u003d Token.COMMA) {\n         return;\n     }\n     if (parent \u003d\u003d null)\n         return;\n     int pt \u003d parent.getType();\n     if (pt \u003d\u003d Token.COMMA) {\n+        Node gramps \u003d parent.getParent();\n+        if (gramps.getType() \u003d\u003d Token.CALL \u0026\u0026 parent \u003d\u003d gramps.getFirstChild()) {\n+            if (n \u003d\u003d parent.getFirstChild() \u0026\u0026 parent.getChildCount() \u003d\u003d 2 \u0026\u0026 n.getNext().getType() \u003d\u003d Token.NAME \u0026\u0026 \"eval\".equals(n.getNext().getString())) {\n+                return;\n+            }\n+        }\n         if (n \u003d\u003d parent.getLastChild()) {\n             for (Node an : parent.getAncestors()) {\n                 int ancestorType \u003d an.getType();\n                 if (ancestorType \u003d\u003d Token.COMMA)\n                     continue;\n                 if (ancestorType !\u003d Token.EXPR_RESULT \u0026\u0026 ancestorType !\u003d Token.BLOCK)\n                     return;\n                 else\n                     break;\n             }\n         }\n     } else if (pt !\u003d Token.EXPR_RESULT \u0026\u0026 pt !\u003d Token.BLOCK) {\n         if (pt \u003d\u003d Token.FOR \u0026\u0026 parent.getChildCount() \u003d\u003d 4 \u0026\u0026 (n \u003d\u003d parent.getFirstChild() || n \u003d\u003d parent.getFirstChild().getNext().getNext())) {\n         } else {\n             return;\n         }\n     }\n     if (NodeUtil.isSimpleOperatorType(n.getType()) || !NodeUtil.mayHaveSideEffects(n)) {\n         if (n.isQualifiedName() \u0026\u0026 n.getJSDocInfo() !\u003d null) {\n             return;\n         } else if (NodeUtil.isExpressionNode(n)) {\n             return;\n         }\n         String msg \u003d \"This code lacks side-effects. Is there a bug?\";\n         if (n.getType() \u003d\u003d Token.STRING) {\n             msg \u003d \"Is there a missing \u0027+\u0027 on the previous line?\";\n         }\n         t.getCompiler().report(JSError.make(t, n, level, USELESS_CODE_ERROR, msg));\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3": {
      "type": "Yintroduced",
      "commitMessage": "Initial commit.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@2 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "11/3/09, 3:51 PM",
      "commitName": "6b49cfd9022fe111bdad745c78ea877fbc2f7ba3",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "diff": "@@ -0,0 +1,38 @@\n+public void visit(NodeTraversal t, Node n, Node parent) {\n+    if (n.getType() \u003d\u003d Token.EMPTY || n.getType() \u003d\u003d Token.COMMA) {\n+        return;\n+    }\n+    if (parent \u003d\u003d null)\n+        return;\n+    int pt \u003d parent.getType();\n+    if (pt \u003d\u003d Token.COMMA) {\n+        if (n \u003d\u003d parent.getLastChild()) {\n+            for (Node an : parent.getAncestors()) {\n+                int ancestorType \u003d an.getType();\n+                if (ancestorType \u003d\u003d Token.COMMA)\n+                    continue;\n+                if (ancestorType !\u003d Token.EXPR_RESULT \u0026\u0026 ancestorType !\u003d Token.BLOCK)\n+                    return;\n+                else\n+                    break;\n+            }\n+        }\n+    } else if (pt !\u003d Token.EXPR_RESULT \u0026\u0026 pt !\u003d Token.BLOCK) {\n+        if (pt \u003d\u003d Token.FOR \u0026\u0026 parent.getChildCount() \u003d\u003d 4 \u0026\u0026 (n \u003d\u003d parent.getFirstChild() || n \u003d\u003d parent.getFirstChild().getNext().getNext())) {\n+        } else {\n+            return;\n+        }\n+    }\n+    if (NodeUtil.isSimpleOperatorType(n.getType()) || !NodeUtil.mayHaveSideEffects(n)) {\n+        if (n.isQualifiedName() \u0026\u0026 n.getJSDocInfo() !\u003d null) {\n+            return;\n+        } else if (NodeUtil.isExpressionNode(n)) {\n+            return;\n+        }\n+        String msg \u003d \"This code lacks side-effects. Is there a bug?\";\n+        if (n.getType() \u003d\u003d Token.STRING) {\n+            msg \u003d \"Is there a missing \u0027+\u0027 on the previous line?\";\n+        }\n+        t.getCompiler().report(JSError.make(t, n, level, USELESS_CODE_ERROR, msg));\n+    }\n+}\n\\ No newline at end of file\n",
      "actualSource": "public void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() \u003d\u003d Token.EMPTY || n.getType() \u003d\u003d Token.COMMA) {\n        return;\n    }\n    if (parent \u003d\u003d null)\n        return;\n    int pt \u003d parent.getType();\n    if (pt \u003d\u003d Token.COMMA) {\n        if (n \u003d\u003d parent.getLastChild()) {\n            for (Node an : parent.getAncestors()) {\n                int ancestorType \u003d an.getType();\n                if (ancestorType \u003d\u003d Token.COMMA)\n                    continue;\n                if (ancestorType !\u003d Token.EXPR_RESULT \u0026\u0026 ancestorType !\u003d Token.BLOCK)\n                    return;\n                else\n                    break;\n            }\n        }\n    } else if (pt !\u003d Token.EXPR_RESULT \u0026\u0026 pt !\u003d Token.BLOCK) {\n        if (pt \u003d\u003d Token.FOR \u0026\u0026 parent.getChildCount() \u003d\u003d 4 \u0026\u0026 (n \u003d\u003d parent.getFirstChild() || n \u003d\u003d parent.getFirstChild().getNext().getNext())) {\n        } else {\n            return;\n        }\n    }\n    if (NodeUtil.isSimpleOperatorType(n.getType()) || !NodeUtil.mayHaveSideEffects(n)) {\n        if (n.isQualifiedName() \u0026\u0026 n.getJSDocInfo() !\u003d null) {\n            return;\n        } else if (NodeUtil.isExpressionNode(n)) {\n            return;\n        }\n        String msg \u003d \"This code lacks side-effects. Is there a bug?\";\n        if (n.getType() \u003d\u003d Token.STRING) {\n            msg \u003d \"Is there a missing \u0027+\u0027 on the previous line?\";\n        }\n        t.getCompiler().report(JSError.make(t, n, level, USELESS_CODE_ERROR, msg));\n    }\n}",
      "path": "src/com/google/javascript/jscomp/CheckSideEffects.java",
      "functionStartLine": 49,
      "functionName": "visit",
      "functionAnnotation": "",
      "functionDoc": ""
    }
  }
}