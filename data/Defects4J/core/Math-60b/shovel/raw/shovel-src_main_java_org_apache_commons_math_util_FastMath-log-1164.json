{
  "origin": "codeshovel",
  "repositoryName": "Math-60b",
  "repositoryPath": "/tmp/Math-60b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FastMath.java",
  "functionName": "log",
  "functionId": "log___x-double(modifiers-final)__hiPrec-double[](modifiers-final)",
  "sourceFilePath": "src/main/java/org/apache/commons/math/util/FastMath.java",
  "functionAnnotation": "",
  "functionDoc": "Internal helper method for natural logarithm function.\n\n@param x original argument of the natural logarithm function\n@param hiPrec extra bits of precision on output (To Be Confirmed)\n@return log(x)\n",
  "functionStartLine": 1164,
  "functionEndLine": 1381,
  "numCommitsSeen": 6,
  "timeTaken": 10369,
  "changeHistory": [
    "2bc1662e8b098f6de01f893ba7c672306447fd70",
    "80b1e90b42a34856b61cec628fcea6633d1000cd"
  ],
  "changeHistoryShort": {
    "2bc1662e8b098f6de01f893ba7c672306447fd70": "Ybodychange",
    "80b1e90b42a34856b61cec628fcea6633d1000cd": "Yintroduced"
  },
  "changeHistoryDetails": {
    "2bc1662e8b098f6de01f893ba7c672306447fd70": {
      "type": "Ybodychange",
      "commitMessage": "added fast cubic root computation\nJIRA: MATH-375\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@996172 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "9/11/10, 9:57 AM",
      "commitName": "2bc1662e8b098f6de01f893ba7c672306447fd70",
      "commitAuthor": "Luc Maisonobe",
      "commitDateOld": "9/5/10, 12:27 PM",
      "commitNameOld": "90279e83d82389db2ba88898ec985a1827849e6e",
      "commitAuthorOld": "Luc Maisonobe",
      "daysBetweenCommits": 5.9,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "actualSource": "private static double log(final double x, final double[] hiPrec) {\n    long bits \u003d Double.doubleToLongBits(x);\n    if ((bits \u0026 0x8000000000000000L) !\u003d 0 || x !\u003d x) {\n        if (x !\u003d 0.0) {\n            if (hiPrec !\u003d null) {\n                hiPrec[0] \u003d Double.NaN;\n            }\n            return Double.NaN;\n        }\n    }\n    if (x \u003d\u003d Double.POSITIVE_INFINITY) {\n        if (hiPrec !\u003d null) {\n            hiPrec[0] \u003d Double.POSITIVE_INFINITY;\n        }\n        return Double.POSITIVE_INFINITY;\n    }\n    int exp \u003d (int) (bits \u003e\u003e 52) - 1023;\n    if ((bits \u0026 0x7ff0000000000000L) \u003d\u003d 0) {\n        if (x \u003d\u003d 0) {\n            if (hiPrec !\u003d null) {\n                hiPrec[0] \u003d Double.NEGATIVE_INFINITY;\n            }\n            return Double.NEGATIVE_INFINITY;\n        }\n        bits \u003c\u003c\u003d 1;\n        while ((bits \u0026 0x0010000000000000L) \u003d\u003d 0) {\n            exp--;\n            bits \u003c\u003c\u003d 1;\n        }\n    }\n    if (exp \u003d\u003d -1 || exp \u003d\u003d 0) {\n        if (x \u003c 1.01 \u0026\u0026 x \u003e 0.99 \u0026\u0026 hiPrec \u003d\u003d null) {\n            double xa \u003d x - 1.0;\n            double xb \u003d xa - x + 1.0;\n            double tmp \u003d xa * 1073741824.0;\n            double aa \u003d xa + tmp - tmp;\n            double ab \u003d xa - aa;\n            xa \u003d aa;\n            xb \u003d ab;\n            double ya \u003d LN_QUICK_COEF[LN_QUICK_COEF.length - 1][0];\n            double yb \u003d LN_QUICK_COEF[LN_QUICK_COEF.length - 1][1];\n            for (int i \u003d LN_QUICK_COEF.length - 2; i \u003e\u003d 0; i--) {\n                aa \u003d ya * xa;\n                ab \u003d ya * xb + yb * xa + yb * xb;\n                tmp \u003d aa * 1073741824.0;\n                ya \u003d aa + tmp - tmp;\n                yb \u003d aa - ya + ab;\n                aa \u003d ya + LN_QUICK_COEF[i][0];\n                ab \u003d yb + LN_QUICK_COEF[i][1];\n                tmp \u003d aa * 1073741824.0;\n                ya \u003d aa + tmp - tmp;\n                yb \u003d aa - ya + ab;\n            }\n            aa \u003d ya * xa;\n            ab \u003d ya * xb + yb * xa + yb * xb;\n            tmp \u003d aa * 1073741824.0;\n            ya \u003d aa + tmp - tmp;\n            yb \u003d aa - ya + ab;\n            return ya + yb;\n        }\n    }\n    double[] lnm \u003d LN_MANT[(int) ((bits \u0026 0x000ffc0000000000L) \u003e\u003e 42)];\n    double epsilon \u003d (double) (bits \u0026 0x3ffffffffffL) / (4503599627370496.0 + (bits \u0026 0x000ffc0000000000L));\n    double lnza \u003d 0.0;\n    double lnzb \u003d 0.0;\n    if (hiPrec !\u003d null) {\n        double tmp \u003d epsilon * 1073741824.0;\n        double aa \u003d epsilon + tmp - tmp;\n        double ab \u003d epsilon - aa;\n        double xa \u003d aa;\n        double xb \u003d ab;\n        double numer \u003d (double) (bits \u0026 0x3ffffffffffL);\n        double denom \u003d 4503599627370496.0 + (bits \u0026 0x000ffc0000000000L);\n        aa \u003d numer - xa * denom - xb * denom;\n        xb +\u003d aa / denom;\n        double ya \u003d LN_HI_PREC_COEF[LN_HI_PREC_COEF.length - 1][0];\n        double yb \u003d LN_HI_PREC_COEF[LN_HI_PREC_COEF.length - 1][1];\n        for (int i \u003d LN_HI_PREC_COEF.length - 2; i \u003e\u003d 0; i--) {\n            aa \u003d ya * xa;\n            ab \u003d ya * xb + yb * xa + yb * xb;\n            tmp \u003d aa * 1073741824.0;\n            ya \u003d aa + tmp - tmp;\n            yb \u003d aa - ya + ab;\n            aa \u003d ya + LN_HI_PREC_COEF[i][0];\n            ab \u003d yb + LN_HI_PREC_COEF[i][1];\n            tmp \u003d aa * 1073741824.0;\n            ya \u003d aa + tmp - tmp;\n            yb \u003d aa - ya + ab;\n        }\n        aa \u003d ya * xa;\n        ab \u003d ya * xb + yb * xa + yb * xb;\n        lnza \u003d aa + ab;\n        lnzb \u003d -(lnza - aa - ab);\n    } else {\n        lnza \u003d -0.16624882440418567;\n        lnza \u003d lnza * epsilon + 0.19999954120254515;\n        lnza \u003d lnza * epsilon + -0.2499999997677497;\n        lnza \u003d lnza * epsilon + 0.3333333333332802;\n        lnza \u003d lnza * epsilon + -0.5;\n        lnza \u003d lnza * epsilon + 1.0;\n        lnza \u003d lnza * epsilon;\n    }\n    double a \u003d LN_2_A * exp;\n    double b \u003d 0.0;\n    double c \u003d a + lnm[0];\n    double d \u003d -(c - a - lnm[0]);\n    a \u003d c;\n    b \u003d b + d;\n    c \u003d a + lnza;\n    d \u003d -(c - a - lnza);\n    a \u003d c;\n    b \u003d b + d;\n    c \u003d a + LN_2_B * exp;\n    d \u003d -(c - a - LN_2_B * exp);\n    a \u003d c;\n    b \u003d b + d;\n    c \u003d a + lnm[1];\n    d \u003d -(c - a - lnm[1]);\n    a \u003d c;\n    b \u003d b + d;\n    c \u003d a + lnzb;\n    d \u003d -(c - a - lnzb);\n    a \u003d c;\n    b \u003d b + d;\n    if (hiPrec !\u003d null) {\n        hiPrec[0] \u003d a;\n        hiPrec[1] \u003d b;\n    }\n    return a + b;\n}",
      "path": "src/main/java/org/apache/commons/math/util/FastMath.java",
      "functionStartLine": 933,
      "functionName": "log",
      "functionAnnotation": "",
      "functionDoc": "Internal helper method for natural logarithm function.\n\n@param x original argument of the natural logarithm function\n@param hiPrec extra bits of precision on output (To Be Confirmed)\n@return log(x)\n",
      "diff": "@@ -1,134 +1,130 @@\n private static double log(final double x, final double[] hiPrec) {\n     long bits \u003d Double.doubleToLongBits(x);\n     if ((bits \u0026 0x8000000000000000L) !\u003d 0 || x !\u003d x) {\n         if (x !\u003d 0.0) {\n             if (hiPrec !\u003d null) {\n                 hiPrec[0] \u003d Double.NaN;\n             }\n             return Double.NaN;\n         }\n     }\n     if (x \u003d\u003d Double.POSITIVE_INFINITY) {\n         if (hiPrec !\u003d null) {\n             hiPrec[0] \u003d Double.POSITIVE_INFINITY;\n         }\n         return Double.POSITIVE_INFINITY;\n     }\n     int exp \u003d (int) (bits \u003e\u003e 52) - 1023;\n     if ((bits \u0026 0x7ff0000000000000L) \u003d\u003d 0) {\n         if (x \u003d\u003d 0) {\n             if (hiPrec !\u003d null) {\n                 hiPrec[0] \u003d Double.NEGATIVE_INFINITY;\n             }\n             return Double.NEGATIVE_INFINITY;\n         }\n         bits \u003c\u003c\u003d 1;\n         while ((bits \u0026 0x0010000000000000L) \u003d\u003d 0) {\n             exp--;\n             bits \u003c\u003c\u003d 1;\n         }\n     }\n     if (exp \u003d\u003d -1 || exp \u003d\u003d 0) {\n         if (x \u003c 1.01 \u0026\u0026 x \u003e 0.99 \u0026\u0026 hiPrec \u003d\u003d null) {\n             double xa \u003d x - 1.0;\n             double xb \u003d xa - x + 1.0;\n             double tmp \u003d xa * 1073741824.0;\n             double aa \u003d xa + tmp - tmp;\n             double ab \u003d xa - aa;\n             xa \u003d aa;\n             xb \u003d ab;\n             double ya \u003d LN_QUICK_COEF[LN_QUICK_COEF.length - 1][0];\n             double yb \u003d LN_QUICK_COEF[LN_QUICK_COEF.length - 1][1];\n             for (int i \u003d LN_QUICK_COEF.length - 2; i \u003e\u003d 0; i--) {\n                 aa \u003d ya * xa;\n                 ab \u003d ya * xb + yb * xa + yb * xb;\n                 tmp \u003d aa * 1073741824.0;\n                 ya \u003d aa + tmp - tmp;\n                 yb \u003d aa - ya + ab;\n                 aa \u003d ya + LN_QUICK_COEF[i][0];\n                 ab \u003d yb + LN_QUICK_COEF[i][1];\n                 tmp \u003d aa * 1073741824.0;\n                 ya \u003d aa + tmp - tmp;\n                 yb \u003d aa - ya + ab;\n             }\n             aa \u003d ya * xa;\n             ab \u003d ya * xb + yb * xa + yb * xb;\n             tmp \u003d aa * 1073741824.0;\n             ya \u003d aa + tmp - tmp;\n             yb \u003d aa - ya + ab;\n-            if (hiPrec !\u003d null) {\n-                hiPrec[0] \u003d ya;\n-                hiPrec[1] \u003d yb;\n-            }\n             return ya + yb;\n         }\n     }\n     double[] lnm \u003d LN_MANT[(int) ((bits \u0026 0x000ffc0000000000L) \u003e\u003e 42)];\n     double epsilon \u003d (double) (bits \u0026 0x3ffffffffffL) / (4503599627370496.0 + (bits \u0026 0x000ffc0000000000L));\n     double lnza \u003d 0.0;\n     double lnzb \u003d 0.0;\n     if (hiPrec !\u003d null) {\n         double tmp \u003d epsilon * 1073741824.0;\n         double aa \u003d epsilon + tmp - tmp;\n         double ab \u003d epsilon - aa;\n         double xa \u003d aa;\n         double xb \u003d ab;\n         double numer \u003d (double) (bits \u0026 0x3ffffffffffL);\n         double denom \u003d 4503599627370496.0 + (bits \u0026 0x000ffc0000000000L);\n         aa \u003d numer - xa * denom - xb * denom;\n         xb +\u003d aa / denom;\n         double ya \u003d LN_HI_PREC_COEF[LN_HI_PREC_COEF.length - 1][0];\n         double yb \u003d LN_HI_PREC_COEF[LN_HI_PREC_COEF.length - 1][1];\n         for (int i \u003d LN_HI_PREC_COEF.length - 2; i \u003e\u003d 0; i--) {\n             aa \u003d ya * xa;\n             ab \u003d ya * xb + yb * xa + yb * xb;\n             tmp \u003d aa * 1073741824.0;\n             ya \u003d aa + tmp - tmp;\n             yb \u003d aa - ya + ab;\n             aa \u003d ya + LN_HI_PREC_COEF[i][0];\n             ab \u003d yb + LN_HI_PREC_COEF[i][1];\n             tmp \u003d aa * 1073741824.0;\n             ya \u003d aa + tmp - tmp;\n             yb \u003d aa - ya + ab;\n         }\n         aa \u003d ya * xa;\n         ab \u003d ya * xb + yb * xa + yb * xb;\n         lnza \u003d aa + ab;\n         lnzb \u003d -(lnza - aa - ab);\n     } else {\n         lnza \u003d -0.16624882440418567;\n         lnza \u003d lnza * epsilon + 0.19999954120254515;\n         lnza \u003d lnza * epsilon + -0.2499999997677497;\n         lnza \u003d lnza * epsilon + 0.3333333333332802;\n         lnza \u003d lnza * epsilon + -0.5;\n         lnza \u003d lnza * epsilon + 1.0;\n         lnza \u003d lnza * epsilon;\n     }\n     double a \u003d LN_2_A * exp;\n     double b \u003d 0.0;\n     double c \u003d a + lnm[0];\n     double d \u003d -(c - a - lnm[0]);\n     a \u003d c;\n     b \u003d b + d;\n     c \u003d a + lnza;\n     d \u003d -(c - a - lnza);\n     a \u003d c;\n     b \u003d b + d;\n     c \u003d a + LN_2_B * exp;\n     d \u003d -(c - a - LN_2_B * exp);\n     a \u003d c;\n     b \u003d b + d;\n     c \u003d a + lnm[1];\n     d \u003d -(c - a - lnm[1]);\n     a \u003d c;\n     b \u003d b + d;\n     c \u003d a + lnzb;\n     d \u003d -(c - a - lnzb);\n     a \u003d c;\n     b \u003d b + d;\n     if (hiPrec !\u003d null) {\n         hiPrec[0] \u003d a;\n         hiPrec[1] \u003d b;\n     }\n     return a + b;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "80b1e90b42a34856b61cec628fcea6633d1000cd": {
      "type": "Yintroduced",
      "commitMessage": "added FastMath and used it everywhere in replacement of java.util.Math\nthe unit tests have not been added yet (waiting for dfp library addition)\nJIRA: MATH-375\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@990658 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "8/29/10, 3:04 PM",
      "commitName": "80b1e90b42a34856b61cec628fcea6633d1000cd",
      "commitAuthor": "Luc Maisonobe",
      "diff": "@@ -0,0 +1,134 @@\n+private static double log(final double x, final double[] hiPrec) {\n+    long bits \u003d Double.doubleToLongBits(x);\n+    if ((bits \u0026 0x8000000000000000L) !\u003d 0 || x !\u003d x) {\n+        if (x !\u003d 0.0) {\n+            if (hiPrec !\u003d null) {\n+                hiPrec[0] \u003d Double.NaN;\n+            }\n+            return Double.NaN;\n+        }\n+    }\n+    if (x \u003d\u003d Double.POSITIVE_INFINITY) {\n+        if (hiPrec !\u003d null) {\n+            hiPrec[0] \u003d Double.POSITIVE_INFINITY;\n+        }\n+        return Double.POSITIVE_INFINITY;\n+    }\n+    int exp \u003d (int) (bits \u003e\u003e 52) - 1023;\n+    if ((bits \u0026 0x7ff0000000000000L) \u003d\u003d 0) {\n+        if (x \u003d\u003d 0) {\n+            if (hiPrec !\u003d null) {\n+                hiPrec[0] \u003d Double.NEGATIVE_INFINITY;\n+            }\n+            return Double.NEGATIVE_INFINITY;\n+        }\n+        bits \u003c\u003c\u003d 1;\n+        while ((bits \u0026 0x0010000000000000L) \u003d\u003d 0) {\n+            exp--;\n+            bits \u003c\u003c\u003d 1;\n+        }\n+    }\n+    if (exp \u003d\u003d -1 || exp \u003d\u003d 0) {\n+        if (x \u003c 1.01 \u0026\u0026 x \u003e 0.99 \u0026\u0026 hiPrec \u003d\u003d null) {\n+            double xa \u003d x - 1.0;\n+            double xb \u003d xa - x + 1.0;\n+            double tmp \u003d xa * 1073741824.0;\n+            double aa \u003d xa + tmp - tmp;\n+            double ab \u003d xa - aa;\n+            xa \u003d aa;\n+            xb \u003d ab;\n+            double ya \u003d LN_QUICK_COEF[LN_QUICK_COEF.length - 1][0];\n+            double yb \u003d LN_QUICK_COEF[LN_QUICK_COEF.length - 1][1];\n+            for (int i \u003d LN_QUICK_COEF.length - 2; i \u003e\u003d 0; i--) {\n+                aa \u003d ya * xa;\n+                ab \u003d ya * xb + yb * xa + yb * xb;\n+                tmp \u003d aa * 1073741824.0;\n+                ya \u003d aa + tmp - tmp;\n+                yb \u003d aa - ya + ab;\n+                aa \u003d ya + LN_QUICK_COEF[i][0];\n+                ab \u003d yb + LN_QUICK_COEF[i][1];\n+                tmp \u003d aa * 1073741824.0;\n+                ya \u003d aa + tmp - tmp;\n+                yb \u003d aa - ya + ab;\n+            }\n+            aa \u003d ya * xa;\n+            ab \u003d ya * xb + yb * xa + yb * xb;\n+            tmp \u003d aa * 1073741824.0;\n+            ya \u003d aa + tmp - tmp;\n+            yb \u003d aa - ya + ab;\n+            if (hiPrec !\u003d null) {\n+                hiPrec[0] \u003d ya;\n+                hiPrec[1] \u003d yb;\n+            }\n+            return ya + yb;\n+        }\n+    }\n+    double[] lnm \u003d LN_MANT[(int) ((bits \u0026 0x000ffc0000000000L) \u003e\u003e 42)];\n+    double epsilon \u003d (double) (bits \u0026 0x3ffffffffffL) / (4503599627370496.0 + (bits \u0026 0x000ffc0000000000L));\n+    double lnza \u003d 0.0;\n+    double lnzb \u003d 0.0;\n+    if (hiPrec !\u003d null) {\n+        double tmp \u003d epsilon * 1073741824.0;\n+        double aa \u003d epsilon + tmp - tmp;\n+        double ab \u003d epsilon - aa;\n+        double xa \u003d aa;\n+        double xb \u003d ab;\n+        double numer \u003d (double) (bits \u0026 0x3ffffffffffL);\n+        double denom \u003d 4503599627370496.0 + (bits \u0026 0x000ffc0000000000L);\n+        aa \u003d numer - xa * denom - xb * denom;\n+        xb +\u003d aa / denom;\n+        double ya \u003d LN_HI_PREC_COEF[LN_HI_PREC_COEF.length - 1][0];\n+        double yb \u003d LN_HI_PREC_COEF[LN_HI_PREC_COEF.length - 1][1];\n+        for (int i \u003d LN_HI_PREC_COEF.length - 2; i \u003e\u003d 0; i--) {\n+            aa \u003d ya * xa;\n+            ab \u003d ya * xb + yb * xa + yb * xb;\n+            tmp \u003d aa * 1073741824.0;\n+            ya \u003d aa + tmp - tmp;\n+            yb \u003d aa - ya + ab;\n+            aa \u003d ya + LN_HI_PREC_COEF[i][0];\n+            ab \u003d yb + LN_HI_PREC_COEF[i][1];\n+            tmp \u003d aa * 1073741824.0;\n+            ya \u003d aa + tmp - tmp;\n+            yb \u003d aa - ya + ab;\n+        }\n+        aa \u003d ya * xa;\n+        ab \u003d ya * xb + yb * xa + yb * xb;\n+        lnza \u003d aa + ab;\n+        lnzb \u003d -(lnza - aa - ab);\n+    } else {\n+        lnza \u003d -0.16624882440418567;\n+        lnza \u003d lnza * epsilon + 0.19999954120254515;\n+        lnza \u003d lnza * epsilon + -0.2499999997677497;\n+        lnza \u003d lnza * epsilon + 0.3333333333332802;\n+        lnza \u003d lnza * epsilon + -0.5;\n+        lnza \u003d lnza * epsilon + 1.0;\n+        lnza \u003d lnza * epsilon;\n+    }\n+    double a \u003d LN_2_A * exp;\n+    double b \u003d 0.0;\n+    double c \u003d a + lnm[0];\n+    double d \u003d -(c - a - lnm[0]);\n+    a \u003d c;\n+    b \u003d b + d;\n+    c \u003d a + lnza;\n+    d \u003d -(c - a - lnza);\n+    a \u003d c;\n+    b \u003d b + d;\n+    c \u003d a + LN_2_B * exp;\n+    d \u003d -(c - a - LN_2_B * exp);\n+    a \u003d c;\n+    b \u003d b + d;\n+    c \u003d a + lnm[1];\n+    d \u003d -(c - a - lnm[1]);\n+    a \u003d c;\n+    b \u003d b + d;\n+    c \u003d a + lnzb;\n+    d \u003d -(c - a - lnzb);\n+    a \u003d c;\n+    b \u003d b + d;\n+    if (hiPrec !\u003d null) {\n+        hiPrec[0] \u003d a;\n+        hiPrec[1] \u003d b;\n+    }\n+    return a + b;\n+}\n\\ No newline at end of file\n",
      "actualSource": "private static double log(final double x, final double[] hiPrec) {\n    long bits \u003d Double.doubleToLongBits(x);\n    if ((bits \u0026 0x8000000000000000L) !\u003d 0 || x !\u003d x) {\n        if (x !\u003d 0.0) {\n            if (hiPrec !\u003d null) {\n                hiPrec[0] \u003d Double.NaN;\n            }\n            return Double.NaN;\n        }\n    }\n    if (x \u003d\u003d Double.POSITIVE_INFINITY) {\n        if (hiPrec !\u003d null) {\n            hiPrec[0] \u003d Double.POSITIVE_INFINITY;\n        }\n        return Double.POSITIVE_INFINITY;\n    }\n    int exp \u003d (int) (bits \u003e\u003e 52) - 1023;\n    if ((bits \u0026 0x7ff0000000000000L) \u003d\u003d 0) {\n        if (x \u003d\u003d 0) {\n            if (hiPrec !\u003d null) {\n                hiPrec[0] \u003d Double.NEGATIVE_INFINITY;\n            }\n            return Double.NEGATIVE_INFINITY;\n        }\n        bits \u003c\u003c\u003d 1;\n        while ((bits \u0026 0x0010000000000000L) \u003d\u003d 0) {\n            exp--;\n            bits \u003c\u003c\u003d 1;\n        }\n    }\n    if (exp \u003d\u003d -1 || exp \u003d\u003d 0) {\n        if (x \u003c 1.01 \u0026\u0026 x \u003e 0.99 \u0026\u0026 hiPrec \u003d\u003d null) {\n            double xa \u003d x - 1.0;\n            double xb \u003d xa - x + 1.0;\n            double tmp \u003d xa * 1073741824.0;\n            double aa \u003d xa + tmp - tmp;\n            double ab \u003d xa - aa;\n            xa \u003d aa;\n            xb \u003d ab;\n            double ya \u003d LN_QUICK_COEF[LN_QUICK_COEF.length - 1][0];\n            double yb \u003d LN_QUICK_COEF[LN_QUICK_COEF.length - 1][1];\n            for (int i \u003d LN_QUICK_COEF.length - 2; i \u003e\u003d 0; i--) {\n                aa \u003d ya * xa;\n                ab \u003d ya * xb + yb * xa + yb * xb;\n                tmp \u003d aa * 1073741824.0;\n                ya \u003d aa + tmp - tmp;\n                yb \u003d aa - ya + ab;\n                aa \u003d ya + LN_QUICK_COEF[i][0];\n                ab \u003d yb + LN_QUICK_COEF[i][1];\n                tmp \u003d aa * 1073741824.0;\n                ya \u003d aa + tmp - tmp;\n                yb \u003d aa - ya + ab;\n            }\n            aa \u003d ya * xa;\n            ab \u003d ya * xb + yb * xa + yb * xb;\n            tmp \u003d aa * 1073741824.0;\n            ya \u003d aa + tmp - tmp;\n            yb \u003d aa - ya + ab;\n            if (hiPrec !\u003d null) {\n                hiPrec[0] \u003d ya;\n                hiPrec[1] \u003d yb;\n            }\n            return ya + yb;\n        }\n    }\n    double[] lnm \u003d LN_MANT[(int) ((bits \u0026 0x000ffc0000000000L) \u003e\u003e 42)];\n    double epsilon \u003d (double) (bits \u0026 0x3ffffffffffL) / (4503599627370496.0 + (bits \u0026 0x000ffc0000000000L));\n    double lnza \u003d 0.0;\n    double lnzb \u003d 0.0;\n    if (hiPrec !\u003d null) {\n        double tmp \u003d epsilon * 1073741824.0;\n        double aa \u003d epsilon + tmp - tmp;\n        double ab \u003d epsilon - aa;\n        double xa \u003d aa;\n        double xb \u003d ab;\n        double numer \u003d (double) (bits \u0026 0x3ffffffffffL);\n        double denom \u003d 4503599627370496.0 + (bits \u0026 0x000ffc0000000000L);\n        aa \u003d numer - xa * denom - xb * denom;\n        xb +\u003d aa / denom;\n        double ya \u003d LN_HI_PREC_COEF[LN_HI_PREC_COEF.length - 1][0];\n        double yb \u003d LN_HI_PREC_COEF[LN_HI_PREC_COEF.length - 1][1];\n        for (int i \u003d LN_HI_PREC_COEF.length - 2; i \u003e\u003d 0; i--) {\n            aa \u003d ya * xa;\n            ab \u003d ya * xb + yb * xa + yb * xb;\n            tmp \u003d aa * 1073741824.0;\n            ya \u003d aa + tmp - tmp;\n            yb \u003d aa - ya + ab;\n            aa \u003d ya + LN_HI_PREC_COEF[i][0];\n            ab \u003d yb + LN_HI_PREC_COEF[i][1];\n            tmp \u003d aa * 1073741824.0;\n            ya \u003d aa + tmp - tmp;\n            yb \u003d aa - ya + ab;\n        }\n        aa \u003d ya * xa;\n        ab \u003d ya * xb + yb * xa + yb * xb;\n        lnza \u003d aa + ab;\n        lnzb \u003d -(lnza - aa - ab);\n    } else {\n        lnza \u003d -0.16624882440418567;\n        lnza \u003d lnza * epsilon + 0.19999954120254515;\n        lnza \u003d lnza * epsilon + -0.2499999997677497;\n        lnza \u003d lnza * epsilon + 0.3333333333332802;\n        lnza \u003d lnza * epsilon + -0.5;\n        lnza \u003d lnza * epsilon + 1.0;\n        lnza \u003d lnza * epsilon;\n    }\n    double a \u003d LN_2_A * exp;\n    double b \u003d 0.0;\n    double c \u003d a + lnm[0];\n    double d \u003d -(c - a - lnm[0]);\n    a \u003d c;\n    b \u003d b + d;\n    c \u003d a + lnza;\n    d \u003d -(c - a - lnza);\n    a \u003d c;\n    b \u003d b + d;\n    c \u003d a + LN_2_B * exp;\n    d \u003d -(c - a - LN_2_B * exp);\n    a \u003d c;\n    b \u003d b + d;\n    c \u003d a + lnm[1];\n    d \u003d -(c - a - lnm[1]);\n    a \u003d c;\n    b \u003d b + d;\n    c \u003d a + lnzb;\n    d \u003d -(c - a - lnzb);\n    a \u003d c;\n    b \u003d b + d;\n    if (hiPrec !\u003d null) {\n        hiPrec[0] \u003d a;\n        hiPrec[1] \u003d b;\n    }\n    return a + b;\n}",
      "path": "src/main/java/org/apache/commons/math/util/FastMath.java",
      "functionStartLine": 942,
      "functionName": "log",
      "functionAnnotation": "",
      "functionDoc": "Internal helper method for natural logarithm function.\n\n@param x original argument of the natural logarithm function\n@param hiPrec extra bits of precision on output (To Be Confirmed)\n@return log(x)\n"
    }
  }
}