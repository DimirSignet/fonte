{
  "origin": "codeshovel",
  "repositoryName": "Math-60b",
  "repositoryPath": "/tmp/Math-60b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ContinuedFraction.java",
  "functionName": "evaluate",
  "functionId": "evaluate___x-double__epsilon-double__maxIterations-int",
  "sourceFilePath": "src/main/java/org/apache/commons/math/util/ContinuedFraction.java",
  "functionAnnotation": "",
  "functionDoc": "\u003cp\u003e\nEvaluates the continued fraction at the value x.\n\u003c/p\u003e\n\n\u003cp\u003e\nThe implementation of this method is based on equations 14-17 of:\n\u003cul\u003e\n\u003cli\u003e\n  Eric W. Weisstein. \"Continued Fraction.\" From MathWorld--A Wolfram Web\n  Resource. \u003ca target\u003d\"_blank\"\n  href\u003d\"http://mathworld.wolfram.com/ContinuedFraction.html\"\u003e\n  http://mathworld.wolfram.com/ContinuedFraction.html\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\nThe recurrence relationship defined in those equations can result in\nvery large intermediate results which can result in numerical overflow.\nAs a means to combat these overflow conditions, the intermediate results\nare scaled whenever they threaten to become numerically unstable.\u003c/p\u003e\n\n@param x the evaluation point.\n@param epsilon maximum error allowed.\n@param maxIterations maximum number of convergents\n@return the value of the continued fraction evaluated at x.\n@throws MathException if the algorithm fails to converge.\n",
  "functionStartLine": 126,
  "functionEndLine": 207,
  "numCommitsSeen": 30,
  "timeTaken": 1234,
  "changeHistory": [
    "80b1e90b42a34856b61cec628fcea6633d1000cd",
    "1eaea0b549f685bd416cef68faa3a137b9bb3519",
    "fcabfb5a821e31e42aa15740ebc7d740e689819f",
    "26dac5a0e7fc9c6be9571b3e71a15d8502480d96",
    "d6a438e931412713e99624cf9ed74470f1040184",
    "7f88773d6c3c96c0a2fd24c3e50d1eb80daca11d",
    "fd0f87590d1c88c18f669e9b168c8fd20631f23c",
    "479f7773075c136b43a9cf120704c77c0a4880ab",
    "d2d4c5fd63f279be0797468277593ef72506c696",
    "6ef3b2932f4ca9219e41784bb0cd229dcabcdb11",
    "ad6929ea0c89c085422c1e43bb3f763a0e3d25e4",
    "7b22aec5529fb3bad1e8098938271398d13c92ba",
    "0a904461932f2c0455611e77ec6a8d8aced2980b"
  ],
  "changeHistoryShort": {
    "80b1e90b42a34856b61cec628fcea6633d1000cd": "Ybodychange",
    "1eaea0b549f685bd416cef68faa3a137b9bb3519": "Ybodychange",
    "fcabfb5a821e31e42aa15740ebc7d740e689819f": "Ybodychange",
    "26dac5a0e7fc9c6be9571b3e71a15d8502480d96": "Yformatchange",
    "d6a438e931412713e99624cf9ed74470f1040184": "Yfilerename",
    "7f88773d6c3c96c0a2fd24c3e50d1eb80daca11d": "Ybodychange",
    "fd0f87590d1c88c18f669e9b168c8fd20631f23c": "Ybodychange",
    "479f7773075c136b43a9cf120704c77c0a4880ab": "Ydocchange",
    "d2d4c5fd63f279be0797468277593ef72506c696": "Ybodychange",
    "6ef3b2932f4ca9219e41784bb0cd229dcabcdb11": "Yformatchange",
    "ad6929ea0c89c085422c1e43bb3f763a0e3d25e4": "Ymultichange(Ybodychange,Ydocchange)",
    "7b22aec5529fb3bad1e8098938271398d13c92ba": "Ydocchange",
    "0a904461932f2c0455611e77ec6a8d8aced2980b": "Yintroduced"
  },
  "changeHistoryDetails": {
    "80b1e90b42a34856b61cec628fcea6633d1000cd": {
      "type": "Ybodychange",
      "commitMessage": "added FastMath and used it everywhere in replacement of java.util.Math\nthe unit tests have not been added yet (waiting for dfp library addition)\nJIRA: MATH-375\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@990658 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "8/29/10, 3:04 PM",
      "commitName": "80b1e90b42a34856b61cec628fcea6633d1000cd",
      "commitAuthor": "Luc Maisonobe",
      "commitDateOld": "8/10/10, 3:46 AM",
      "commitNameOld": "986597f52ce9c6c1ff13fb134b91696de6ec2796",
      "commitAuthorOld": "Gilles Sadowski",
      "daysBetweenCommits": 19.47,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "actualSource": "public double evaluate(double x, double epsilon, int maxIterations) throws MathException {\n    double p0 \u003d 1.0;\n    double p1 \u003d getA(0, x);\n    double q0 \u003d 0.0;\n    double q1 \u003d 1.0;\n    double c \u003d p1 / q1;\n    int n \u003d 0;\n    double relativeError \u003d Double.MAX_VALUE;\n    while (n \u003c maxIterations \u0026\u0026 relativeError \u003e epsilon) {\n        ++n;\n        double a \u003d getA(n, x);\n        double b \u003d getB(n, x);\n        double p2 \u003d a * p1 + b * p0;\n        double q2 \u003d a * q1 + b * q0;\n        boolean infinite \u003d false;\n        if (Double.isInfinite(p2) || Double.isInfinite(q2)) {\n            double scaleFactor \u003d 1d;\n            double lastScaleFactor \u003d 1d;\n            final int maxPower \u003d 5;\n            final double scale \u003d FastMath.max(a, b);\n            if (scale \u003c\u003d 0) {\n                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n            }\n            infinite \u003d true;\n            for (int i \u003d 0; i \u003c maxPower; i++) {\n                lastScaleFactor \u003d scaleFactor;\n                scaleFactor *\u003d scale;\n                if (a !\u003d 0.0 \u0026\u0026 a \u003e b) {\n                    p2 \u003d p1 / lastScaleFactor + (b / scaleFactor * p0);\n                    q2 \u003d q1 / lastScaleFactor + (b / scaleFactor * q0);\n                } else if (b !\u003d 0) {\n                    p2 \u003d (a / scaleFactor * p1) + p0 / lastScaleFactor;\n                    q2 \u003d (a / scaleFactor * q1) + q0 / lastScaleFactor;\n                }\n                infinite \u003d Double.isInfinite(p2) || Double.isInfinite(q2);\n                if (!infinite) {\n                    break;\n                }\n            }\n        }\n        if (infinite) {\n            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n        }\n        double r \u003d p2 / q2;\n        if (Double.isNaN(r)) {\n            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE, x);\n        }\n        relativeError \u003d FastMath.abs(r / c - 1.0);\n        c \u003d p2 / q2;\n        p0 \u003d p1;\n        p1 \u003d p2;\n        q0 \u003d q1;\n        q1 \u003d q2;\n    }\n    if (n \u003e\u003d maxIterations) {\n        throw new MaxIterationsExceededException(maxIterations, LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION, x);\n    }\n    return c;\n}",
      "path": "src/main/java/org/apache/commons/math/util/ContinuedFraction.java",
      "functionStartLine": 126,
      "functionName": "evaluate",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003e\nEvaluates the continued fraction at the value x.\n\u003c/p\u003e\n\n\u003cp\u003e\nThe implementation of this method is based on equations 14-17 of:\n\u003cul\u003e\n\u003cli\u003e\n  Eric W. Weisstein. \"Continued Fraction.\" From MathWorld--A Wolfram Web\n  Resource. \u003ca target\u003d\"_blank\"\n  href\u003d\"http://mathworld.wolfram.com/ContinuedFraction.html\"\u003e\n  http://mathworld.wolfram.com/ContinuedFraction.html\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\nThe recurrence relationship defined in those equations can result in\nvery large intermediate results which can result in numerical overflow.\nAs a means to combat these overflow conditions, the intermediate results\nare scaled whenever they threaten to become numerically unstable.\u003c/p\u003e\n\n@param x the evaluation point.\n@param epsilon maximum error allowed.\n@param maxIterations maximum number of convergents\n@return the value of the continued fraction evaluated at x.\n@throws MathException if the algorithm fails to converge.\n",
      "diff": "@@ -1,59 +1,59 @@\n public double evaluate(double x, double epsilon, int maxIterations) throws MathException {\n     double p0 \u003d 1.0;\n     double p1 \u003d getA(0, x);\n     double q0 \u003d 0.0;\n     double q1 \u003d 1.0;\n     double c \u003d p1 / q1;\n     int n \u003d 0;\n     double relativeError \u003d Double.MAX_VALUE;\n     while (n \u003c maxIterations \u0026\u0026 relativeError \u003e epsilon) {\n         ++n;\n         double a \u003d getA(n, x);\n         double b \u003d getB(n, x);\n         double p2 \u003d a * p1 + b * p0;\n         double q2 \u003d a * q1 + b * q0;\n         boolean infinite \u003d false;\n         if (Double.isInfinite(p2) || Double.isInfinite(q2)) {\n             double scaleFactor \u003d 1d;\n             double lastScaleFactor \u003d 1d;\n             final int maxPower \u003d 5;\n-            final double scale \u003d Math.max(a, b);\n+            final double scale \u003d FastMath.max(a, b);\n             if (scale \u003c\u003d 0) {\n                 throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n             }\n             infinite \u003d true;\n             for (int i \u003d 0; i \u003c maxPower; i++) {\n                 lastScaleFactor \u003d scaleFactor;\n                 scaleFactor *\u003d scale;\n                 if (a !\u003d 0.0 \u0026\u0026 a \u003e b) {\n                     p2 \u003d p1 / lastScaleFactor + (b / scaleFactor * p0);\n                     q2 \u003d q1 / lastScaleFactor + (b / scaleFactor * q0);\n                 } else if (b !\u003d 0) {\n                     p2 \u003d (a / scaleFactor * p1) + p0 / lastScaleFactor;\n                     q2 \u003d (a / scaleFactor * q1) + q0 / lastScaleFactor;\n                 }\n                 infinite \u003d Double.isInfinite(p2) || Double.isInfinite(q2);\n                 if (!infinite) {\n                     break;\n                 }\n             }\n         }\n         if (infinite) {\n             throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n         }\n         double r \u003d p2 / q2;\n         if (Double.isNaN(r)) {\n             throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE, x);\n         }\n-        relativeError \u003d Math.abs(r / c - 1.0);\n+        relativeError \u003d FastMath.abs(r / c - 1.0);\n         c \u003d p2 / q2;\n         p0 \u003d p1;\n         p1 \u003d p2;\n         q0 \u003d q1;\n         q1 \u003d q2;\n     }\n     if (n \u003e\u003d maxIterations) {\n         throw new MaxIterationsExceededException(maxIterations, LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION, x);\n     }\n     return c;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1eaea0b549f685bd416cef68faa3a137b9bb3519": {
      "type": "Ybodychange",
      "commitMessage": "changed the localization mechanism for error messages. The new system is based on an enum rather than on duplicated string literals.\nJIRA: MATH-361\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@955423 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "6/16/10, 4:03 PM",
      "commitName": "1eaea0b549f685bd416cef68faa3a137b9bb3519",
      "commitAuthor": "Luc Maisonobe",
      "commitDateOld": "3/8/10, 2:57 PM",
      "commitNameOld": "fcabfb5a821e31e42aa15740ebc7d740e689819f",
      "commitAuthorOld": "Phil Steitz",
      "daysBetweenCommits": 100.0,
      "commitsBetweenForRepo": 113,
      "commitsBetweenForFile": 1,
      "actualSource": "public double evaluate(double x, double epsilon, int maxIterations) throws MathException {\n    double p0 \u003d 1.0;\n    double p1 \u003d getA(0, x);\n    double q0 \u003d 0.0;\n    double q1 \u003d 1.0;\n    double c \u003d p1 / q1;\n    int n \u003d 0;\n    double relativeError \u003d Double.MAX_VALUE;\n    while (n \u003c maxIterations \u0026\u0026 relativeError \u003e epsilon) {\n        ++n;\n        double a \u003d getA(n, x);\n        double b \u003d getB(n, x);\n        double p2 \u003d a * p1 + b * p0;\n        double q2 \u003d a * q1 + b * q0;\n        boolean infinite \u003d false;\n        if (Double.isInfinite(p2) || Double.isInfinite(q2)) {\n            double scaleFactor \u003d 1d;\n            double lastScaleFactor \u003d 1d;\n            final int maxPower \u003d 5;\n            final double scale \u003d Math.max(a, b);\n            if (scale \u003c\u003d 0) {\n                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n            }\n            infinite \u003d true;\n            for (int i \u003d 0; i \u003c maxPower; i++) {\n                lastScaleFactor \u003d scaleFactor;\n                scaleFactor *\u003d scale;\n                if (a !\u003d 0.0 \u0026\u0026 a \u003e b) {\n                    p2 \u003d p1 / lastScaleFactor + (b / scaleFactor * p0);\n                    q2 \u003d q1 / lastScaleFactor + (b / scaleFactor * q0);\n                } else if (b !\u003d 0) {\n                    p2 \u003d (a / scaleFactor * p1) + p0 / lastScaleFactor;\n                    q2 \u003d (a / scaleFactor * q1) + q0 / lastScaleFactor;\n                }\n                infinite \u003d Double.isInfinite(p2) || Double.isInfinite(q2);\n                if (!infinite) {\n                    break;\n                }\n            }\n        }\n        if (infinite) {\n            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n        }\n        double r \u003d p2 / q2;\n        if (Double.isNaN(r)) {\n            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE, x);\n        }\n        relativeError \u003d Math.abs(r / c - 1.0);\n        c \u003d p2 / q2;\n        p0 \u003d p1;\n        p1 \u003d p2;\n        q0 \u003d q1;\n        q1 \u003d q2;\n    }\n    if (n \u003e\u003d maxIterations) {\n        throw new MaxIterationsExceededException(maxIterations, LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION, x);\n    }\n    return c;\n}",
      "path": "src/main/java/org/apache/commons/math/util/ContinuedFraction.java",
      "functionStartLine": 125,
      "functionName": "evaluate",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003e\nEvaluates the continued fraction at the value x.\n\u003c/p\u003e\n\n\u003cp\u003e\nThe implementation of this method is based on equations 14-17 of:\n\u003cul\u003e\n\u003cli\u003e\n  Eric W. Weisstein. \"Continued Fraction.\" From MathWorld--A Wolfram Web\n  Resource. \u003ca target\u003d\"_blank\"\n  href\u003d\"http://mathworld.wolfram.com/ContinuedFraction.html\"\u003e\n  http://mathworld.wolfram.com/ContinuedFraction.html\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\nThe recurrence relationship defined in those equations can result in\nvery large intermediate results which can result in numerical overflow.\nAs a means to combat these overflow conditions, the intermediate results\nare scaled whenever they threaten to become numerically unstable.\u003c/p\u003e\n\n@param x the evaluation point.\n@param epsilon maximum error allowed.\n@param maxIterations maximum number of convergents\n@return the value of the continued fraction evaluated at x.\n@throws MathException if the algorithm fails to converge.\n",
      "diff": "@@ -1,59 +1,59 @@\n public double evaluate(double x, double epsilon, int maxIterations) throws MathException {\n     double p0 \u003d 1.0;\n     double p1 \u003d getA(0, x);\n     double q0 \u003d 0.0;\n     double q1 \u003d 1.0;\n     double c \u003d p1 / q1;\n     int n \u003d 0;\n     double relativeError \u003d Double.MAX_VALUE;\n     while (n \u003c maxIterations \u0026\u0026 relativeError \u003e epsilon) {\n         ++n;\n         double a \u003d getA(n, x);\n         double b \u003d getB(n, x);\n         double p2 \u003d a * p1 + b * p0;\n         double q2 \u003d a * q1 + b * q0;\n         boolean infinite \u003d false;\n         if (Double.isInfinite(p2) || Double.isInfinite(q2)) {\n             double scaleFactor \u003d 1d;\n             double lastScaleFactor \u003d 1d;\n             final int maxPower \u003d 5;\n             final double scale \u003d Math.max(a, b);\n             if (scale \u003c\u003d 0) {\n-                throw new ConvergenceException(\"Continued fraction convergents diverged to +/- infinity for value {0}\", x);\n+                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n             }\n             infinite \u003d true;\n             for (int i \u003d 0; i \u003c maxPower; i++) {\n                 lastScaleFactor \u003d scaleFactor;\n                 scaleFactor *\u003d scale;\n                 if (a !\u003d 0.0 \u0026\u0026 a \u003e b) {\n                     p2 \u003d p1 / lastScaleFactor + (b / scaleFactor * p0);\n                     q2 \u003d q1 / lastScaleFactor + (b / scaleFactor * q0);\n                 } else if (b !\u003d 0) {\n                     p2 \u003d (a / scaleFactor * p1) + p0 / lastScaleFactor;\n                     q2 \u003d (a / scaleFactor * q1) + q0 / lastScaleFactor;\n                 }\n                 infinite \u003d Double.isInfinite(p2) || Double.isInfinite(q2);\n                 if (!infinite) {\n                     break;\n                 }\n             }\n         }\n         if (infinite) {\n-            throw new ConvergenceException(\"Continued fraction convergents diverged to +/- infinity for value {0}\", x);\n+            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n         }\n         double r \u003d p2 / q2;\n         if (Double.isNaN(r)) {\n-            throw new ConvergenceException(\"Continued fraction diverged to NaN for value {0}\", x);\n+            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE, x);\n         }\n         relativeError \u003d Math.abs(r / c - 1.0);\n         c \u003d p2 / q2;\n         p0 \u003d p1;\n         p1 \u003d p2;\n         q0 \u003d q1;\n         q1 \u003d q2;\n     }\n     if (n \u003e\u003d maxIterations) {\n-        throw new MaxIterationsExceededException(maxIterations, \"Continued fraction convergents failed to converge for value {0}\", x);\n+        throw new MaxIterationsExceededException(maxIterations, LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION, x);\n     }\n     return c;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fcabfb5a821e31e42aa15740ebc7d740e689819f": {
      "type": "Ybodychange",
      "commitMessage": "Resolved multiple problems leading to inaccuracy and/or failure to compute Normal, ChiSquare and \nPoisson probabilities, Erf and Gamma functions.\n\nJIRA: MATH-282\nJIRA: MATH-301\n\nSummary of changes:\n\n* BrentSolver has been changed to expose its configured absolute accuracy. This solver is used by\n  the default inverse cum implementation in AbstractContinuousDistribution and the hard-coded setting\n  (1E-6) was limiting accuracy in inverse cumulative probability estimates. AbstractContinuousDistribution\n  was changed to allow distributions to set this value and NormalDistributionImpl was changed to set it to\n  1E-9 by default and allow users to configure it via a constructor argument.\n\n* AbstractContinuousDistribution and AbstractIntegerDistribution inverseCumulativeProbability methods\n  have been modified to check for NaN values returned by cumulativeProbability and throw MathExceptions\n  when this happens.\n\n* The criteria for choosing between the Lanczos series and continued fraction expansion when computing\n  regularized gamma functions has been changed to (x \u003e\u003d a + 1). When using the series approximation\n  (regularizedGammaP), divergence to infinity is checked and when this happens, 1 is returned.\n\n* When scaling continued fractions to (try to) avoid divergence to infinity, the larger of a and b is\n  used as a scale factor and the attempt to scale is repeated up to 5 times, using successive powers\n  of the scale factor.\n\n* The maximum number of iterations used in estimating cumulative probabilities for PoissonDistributionImpl\n  has been decreased from Integer.MAX_VALUE to 10000000 and made configurable.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@920558 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "3/8/10, 2:57 PM",
      "commitName": "fcabfb5a821e31e42aa15740ebc7d740e689819f",
      "commitAuthor": "Phil Steitz",
      "commitDateOld": "9/5/09, 10:36 AM",
      "commitNameOld": "26dac5a0e7fc9c6be9571b3e71a15d8502480d96",
      "commitAuthorOld": "Phil Steitz",
      "daysBetweenCommits": 184.22,
      "commitsBetweenForRepo": 162,
      "commitsBetweenForFile": 1,
      "actualSource": "public double evaluate(double x, double epsilon, int maxIterations) throws MathException {\n    double p0 \u003d 1.0;\n    double p1 \u003d getA(0, x);\n    double q0 \u003d 0.0;\n    double q1 \u003d 1.0;\n    double c \u003d p1 / q1;\n    int n \u003d 0;\n    double relativeError \u003d Double.MAX_VALUE;\n    while (n \u003c maxIterations \u0026\u0026 relativeError \u003e epsilon) {\n        ++n;\n        double a \u003d getA(n, x);\n        double b \u003d getB(n, x);\n        double p2 \u003d a * p1 + b * p0;\n        double q2 \u003d a * q1 + b * q0;\n        boolean infinite \u003d false;\n        if (Double.isInfinite(p2) || Double.isInfinite(q2)) {\n            double scaleFactor \u003d 1d;\n            double lastScaleFactor \u003d 1d;\n            final int maxPower \u003d 5;\n            final double scale \u003d Math.max(a, b);\n            if (scale \u003c\u003d 0) {\n                throw new ConvergenceException(\"Continued fraction convergents diverged to +/- infinity for value {0}\", x);\n            }\n            infinite \u003d true;\n            for (int i \u003d 0; i \u003c maxPower; i++) {\n                lastScaleFactor \u003d scaleFactor;\n                scaleFactor *\u003d scale;\n                if (a !\u003d 0.0 \u0026\u0026 a \u003e b) {\n                    p2 \u003d p1 / lastScaleFactor + (b / scaleFactor * p0);\n                    q2 \u003d q1 / lastScaleFactor + (b / scaleFactor * q0);\n                } else if (b !\u003d 0) {\n                    p2 \u003d (a / scaleFactor * p1) + p0 / lastScaleFactor;\n                    q2 \u003d (a / scaleFactor * q1) + q0 / lastScaleFactor;\n                }\n                infinite \u003d Double.isInfinite(p2) || Double.isInfinite(q2);\n                if (!infinite) {\n                    break;\n                }\n            }\n        }\n        if (infinite) {\n            throw new ConvergenceException(\"Continued fraction convergents diverged to +/- infinity for value {0}\", x);\n        }\n        double r \u003d p2 / q2;\n        if (Double.isNaN(r)) {\n            throw new ConvergenceException(\"Continued fraction diverged to NaN for value {0}\", x);\n        }\n        relativeError \u003d Math.abs(r / c - 1.0);\n        c \u003d p2 / q2;\n        p0 \u003d p1;\n        p1 \u003d p2;\n        q0 \u003d q1;\n        q1 \u003d q2;\n    }\n    if (n \u003e\u003d maxIterations) {\n        throw new MaxIterationsExceededException(maxIterations, \"Continued fraction convergents failed to converge for value {0}\", x);\n    }\n    return c;\n}",
      "path": "src/main/java/org/apache/commons/math/util/ContinuedFraction.java",
      "functionStartLine": 125,
      "functionName": "evaluate",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003e\nEvaluates the continued fraction at the value x.\n\u003c/p\u003e\n\n\u003cp\u003e\nThe implementation of this method is based on equations 14-17 of:\n\u003cul\u003e\n\u003cli\u003e\n  Eric W. Weisstein. \"Continued Fraction.\" From MathWorld--A Wolfram Web\n  Resource. \u003ca target\u003d\"_blank\"\n  href\u003d\"http://mathworld.wolfram.com/ContinuedFraction.html\"\u003e\n  http://mathworld.wolfram.com/ContinuedFraction.html\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\nThe recurrence relationship defined in those equations can result in\nvery large intermediate results which can result in numerical overflow.\nAs a means to combat these overflow conditions, the intermediate results\nare scaled whenever they threaten to become numerically unstable.\u003c/p\u003e\n\n@param x the evaluation point.\n@param epsilon maximum error allowed.\n@param maxIterations maximum number of convergents\n@return the value of the continued fraction evaluated at x.\n@throws MathException if the algorithm fails to converge.\n",
      "diff": "@@ -1,38 +1,59 @@\n public double evaluate(double x, double epsilon, int maxIterations) throws MathException {\n     double p0 \u003d 1.0;\n     double p1 \u003d getA(0, x);\n     double q0 \u003d 0.0;\n     double q1 \u003d 1.0;\n     double c \u003d p1 / q1;\n     int n \u003d 0;\n     double relativeError \u003d Double.MAX_VALUE;\n     while (n \u003c maxIterations \u0026\u0026 relativeError \u003e epsilon) {\n         ++n;\n         double a \u003d getA(n, x);\n         double b \u003d getB(n, x);\n         double p2 \u003d a * p1 + b * p0;\n         double q2 \u003d a * q1 + b * q0;\n+        boolean infinite \u003d false;\n         if (Double.isInfinite(p2) || Double.isInfinite(q2)) {\n-            if (a !\u003d 0.0) {\n-                p2 \u003d p1 + (b / a * p0);\n-                q2 \u003d q1 + (b / a * q0);\n-            } else if (b !\u003d 0) {\n-                p2 \u003d (a / b * p1) + p0;\n-                q2 \u003d (a / b * q1) + q0;\n-            } else {\n+            double scaleFactor \u003d 1d;\n+            double lastScaleFactor \u003d 1d;\n+            final int maxPower \u003d 5;\n+            final double scale \u003d Math.max(a, b);\n+            if (scale \u003c\u003d 0) {\n                 throw new ConvergenceException(\"Continued fraction convergents diverged to +/- infinity for value {0}\", x);\n             }\n+            infinite \u003d true;\n+            for (int i \u003d 0; i \u003c maxPower; i++) {\n+                lastScaleFactor \u003d scaleFactor;\n+                scaleFactor *\u003d scale;\n+                if (a !\u003d 0.0 \u0026\u0026 a \u003e b) {\n+                    p2 \u003d p1 / lastScaleFactor + (b / scaleFactor * p0);\n+                    q2 \u003d q1 / lastScaleFactor + (b / scaleFactor * q0);\n+                } else if (b !\u003d 0) {\n+                    p2 \u003d (a / scaleFactor * p1) + p0 / lastScaleFactor;\n+                    q2 \u003d (a / scaleFactor * q1) + q0 / lastScaleFactor;\n+                }\n+                infinite \u003d Double.isInfinite(p2) || Double.isInfinite(q2);\n+                if (!infinite) {\n+                    break;\n+                }\n+            }\n+        }\n+        if (infinite) {\n+            throw new ConvergenceException(\"Continued fraction convergents diverged to +/- infinity for value {0}\", x);\n         }\n         double r \u003d p2 / q2;\n+        if (Double.isNaN(r)) {\n+            throw new ConvergenceException(\"Continued fraction diverged to NaN for value {0}\", x);\n+        }\n         relativeError \u003d Math.abs(r / c - 1.0);\n         c \u003d p2 / q2;\n         p0 \u003d p1;\n         p1 \u003d p2;\n         q0 \u003d q1;\n         q1 \u003d q2;\n     }\n     if (n \u003e\u003d maxIterations) {\n         throw new MaxIterationsExceededException(maxIterations, \"Continued fraction convergents failed to converge for value {0}\", x);\n     }\n     return c;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "26dac5a0e7fc9c6be9571b3e71a15d8502480d96": {
      "type": "Yformatchange",
      "commitMessage": "Removed trailing spaces.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@811685 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "9/5/09, 10:36 AM",
      "commitName": "26dac5a0e7fc9c6be9571b3e71a15d8502480d96",
      "commitAuthor": "Phil Steitz",
      "commitDateOld": "8/1/09, 7:30 AM",
      "commitNameOld": "d6a438e931412713e99624cf9ed74470f1040184",
      "commitAuthorOld": "Luc Maisonobe",
      "daysBetweenCommits": 35.13,
      "commitsBetweenForRepo": 44,
      "commitsBetweenForFile": 1,
      "actualSource": "public double evaluate(double x, double epsilon, int maxIterations) throws MathException {\n    double p0 \u003d 1.0;\n    double p1 \u003d getA(0, x);\n    double q0 \u003d 0.0;\n    double q1 \u003d 1.0;\n    double c \u003d p1 / q1;\n    int n \u003d 0;\n    double relativeError \u003d Double.MAX_VALUE;\n    while (n \u003c maxIterations \u0026\u0026 relativeError \u003e epsilon) {\n        ++n;\n        double a \u003d getA(n, x);\n        double b \u003d getB(n, x);\n        double p2 \u003d a * p1 + b * p0;\n        double q2 \u003d a * q1 + b * q0;\n        if (Double.isInfinite(p2) || Double.isInfinite(q2)) {\n            if (a !\u003d 0.0) {\n                p2 \u003d p1 + (b / a * p0);\n                q2 \u003d q1 + (b / a * q0);\n            } else if (b !\u003d 0) {\n                p2 \u003d (a / b * p1) + p0;\n                q2 \u003d (a / b * q1) + q0;\n            } else {\n                throw new ConvergenceException(\"Continued fraction convergents diverged to +/- infinity for value {0}\", x);\n            }\n        }\n        double r \u003d p2 / q2;\n        relativeError \u003d Math.abs(r / c - 1.0);\n        c \u003d p2 / q2;\n        p0 \u003d p1;\n        p1 \u003d p2;\n        q0 \u003d q1;\n        q1 \u003d q2;\n    }\n    if (n \u003e\u003d maxIterations) {\n        throw new MaxIterationsExceededException(maxIterations, \"Continued fraction convergents failed to converge for value {0}\", x);\n    }\n    return c;\n}",
      "path": "src/main/java/org/apache/commons/math/util/ContinuedFraction.java",
      "functionStartLine": 125,
      "functionName": "evaluate",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003e\nEvaluates the continued fraction at the value x.\n\u003c/p\u003e\n\n\u003cp\u003e\nThe implementation of this method is based on equations 14-17 of:\n\u003cul\u003e\n\u003cli\u003e\n  Eric W. Weisstein. \"Continued Fraction.\" From MathWorld--A Wolfram Web\n  Resource. \u003ca target\u003d\"_blank\"\n  href\u003d\"http://mathworld.wolfram.com/ContinuedFraction.html\"\u003e\n  http://mathworld.wolfram.com/ContinuedFraction.html\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\nThe recurrence relationship defined in those equations can result in\nvery large intermediate results which can result in numerical overflow.\nAs a means to combat these overflow conditions, the intermediate results\nare scaled whenever they threaten to become numerically unstable.\u003c/p\u003e\n\n@param x the evaluation point.\n@param epsilon maximum error allowed.\n@param maxIterations maximum number of convergents\n@return the value of the continued fraction evaluated at x.\n@throws MathException if the algorithm fails to converge.\n",
      "diff": "",
      "extendedDetails": {}
    },
    "d6a438e931412713e99624cf9ed74470f1040184": {
      "type": "Yfilerename",
      "commitMessage": "moved main java directory for compliance with maven standard directory layout\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@799870 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "8/1/09, 7:30 AM",
      "commitName": "d6a438e931412713e99624cf9ed74470f1040184",
      "commitAuthor": "Luc Maisonobe",
      "commitDateOld": "8/1/09, 7:23 AM",
      "commitNameOld": "2ad5ef61630be627f46ae1c266cf796f044bd4a8",
      "commitAuthorOld": "Luc Maisonobe",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public double evaluate(double x, double epsilon, int maxIterations) throws MathException {\n    double p0 \u003d 1.0;\n    double p1 \u003d getA(0, x);\n    double q0 \u003d 0.0;\n    double q1 \u003d 1.0;\n    double c \u003d p1 / q1;\n    int n \u003d 0;\n    double relativeError \u003d Double.MAX_VALUE;\n    while (n \u003c maxIterations \u0026\u0026 relativeError \u003e epsilon) {\n        ++n;\n        double a \u003d getA(n, x);\n        double b \u003d getB(n, x);\n        double p2 \u003d a * p1 + b * p0;\n        double q2 \u003d a * q1 + b * q0;\n        if (Double.isInfinite(p2) || Double.isInfinite(q2)) {\n            if (a !\u003d 0.0) {\n                p2 \u003d p1 + (b / a * p0);\n                q2 \u003d q1 + (b / a * q0);\n            } else if (b !\u003d 0) {\n                p2 \u003d (a / b * p1) + p0;\n                q2 \u003d (a / b * q1) + q0;\n            } else {\n                throw new ConvergenceException(\"Continued fraction convergents diverged to +/- infinity for value {0}\", x);\n            }\n        }\n        double r \u003d p2 / q2;\n        relativeError \u003d Math.abs(r / c - 1.0);\n        c \u003d p2 / q2;\n        p0 \u003d p1;\n        p1 \u003d p2;\n        q0 \u003d q1;\n        q1 \u003d q2;\n    }\n    if (n \u003e\u003d maxIterations) {\n        throw new MaxIterationsExceededException(maxIterations, \"Continued fraction convergents failed to converge for value {0}\", x);\n    }\n    return c;\n}",
      "path": "src/main/java/org/apache/commons/math/util/ContinuedFraction.java",
      "functionStartLine": 125,
      "functionName": "evaluate",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003e\nEvaluates the continued fraction at the value x.\n\u003c/p\u003e\n\n\u003cp\u003e\nThe implementation of this method is based on equations 14-17 of:\n\u003cul\u003e\n\u003cli\u003e\n  Eric W. Weisstein. \"Continued Fraction.\" From MathWorld--A Wolfram Web\n  Resource. \u003ca target\u003d\"_blank\"\n  href\u003d\"http://mathworld.wolfram.com/ContinuedFraction.html\"\u003e\n  http://mathworld.wolfram.com/ContinuedFraction.html\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\nThe recurrence relationship defined in those equations can result in\nvery large intermediate results which can result in numerical overflow.\nAs a means to combat these overflow conditions, the intermediate results\nare scaled whenever they threaten to become numerically unstable.\u003c/p\u003e\n\n@param x the evaluation point.\n@param epsilon maximum error allowed.\n@param maxIterations maximum number of convergents\n@return the value of the continued fraction evaluated at x.\n@throws MathException if the algorithm fails to converge.\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/commons/math/util/ContinuedFraction.java",
        "newPath": "src/main/java/org/apache/commons/math/util/ContinuedFraction.java"
      }
    },
    "7f88773d6c3c96c0a2fd24c3e50d1eb80daca11d": {
      "type": "Ybodychange",
      "commitMessage": "replaced Object[] parameters by variable arguments in exceptions constructors\nthis allows simpler error declaration and removes the need for the strange\nnull argument with fixed messages\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@746578 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2/21/09, 12:01 PM",
      "commitName": "7f88773d6c3c96c0a2fd24c3e50d1eb80daca11d",
      "commitAuthor": "Luc Maisonobe",
      "commitDateOld": "6/10/08, 12:32 PM",
      "commitNameOld": "fd0f87590d1c88c18f669e9b168c8fd20631f23c",
      "commitAuthorOld": "Luc Maisonobe",
      "daysBetweenCommits": 256.02,
      "commitsBetweenForRepo": 285,
      "commitsBetweenForFile": 1,
      "actualSource": "public double evaluate(double x, double epsilon, int maxIterations) throws MathException {\n    double p0 \u003d 1.0;\n    double p1 \u003d getA(0, x);\n    double q0 \u003d 0.0;\n    double q1 \u003d 1.0;\n    double c \u003d p1 / q1;\n    int n \u003d 0;\n    double relativeError \u003d Double.MAX_VALUE;\n    while (n \u003c maxIterations \u0026\u0026 relativeError \u003e epsilon) {\n        ++n;\n        double a \u003d getA(n, x);\n        double b \u003d getB(n, x);\n        double p2 \u003d a * p1 + b * p0;\n        double q2 \u003d a * q1 + b * q0;\n        if (Double.isInfinite(p2) || Double.isInfinite(q2)) {\n            if (a !\u003d 0.0) {\n                p2 \u003d p1 + (b / a * p0);\n                q2 \u003d q1 + (b / a * q0);\n            } else if (b !\u003d 0) {\n                p2 \u003d (a / b * p1) + p0;\n                q2 \u003d (a / b * q1) + q0;\n            } else {\n                throw new ConvergenceException(\"Continued fraction convergents diverged to +/- infinity for value {0}\", x);\n            }\n        }\n        double r \u003d p2 / q2;\n        relativeError \u003d Math.abs(r / c - 1.0);\n        c \u003d p2 / q2;\n        p0 \u003d p1;\n        p1 \u003d p2;\n        q0 \u003d q1;\n        q1 \u003d q2;\n    }\n    if (n \u003e\u003d maxIterations) {\n        throw new MaxIterationsExceededException(maxIterations, \"Continued fraction convergents failed to converge for value {0}\", x);\n    }\n    return c;\n}",
      "path": "src/java/org/apache/commons/math/util/ContinuedFraction.java",
      "functionStartLine": 130,
      "functionName": "evaluate",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003e\nEvaluates the continued fraction at the value x.\n\u003c/p\u003e\n\n\u003cp\u003e\nThe implementation of this method is based on equations 14-17 of:\n\u003cul\u003e\n\u003cli\u003e\n  Eric W. Weisstein. \"Continued Fraction.\" From MathWorld--A Wolfram Web\n  Resource. \u003ca target\u003d\"_blank\"\n  href\u003d\"http://mathworld.wolfram.com/ContinuedFraction.html\"\u003e\n  http://mathworld.wolfram.com/ContinuedFraction.html\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\nThe recurrence relationship defined in those equations can result in\nvery large intermediate results which can result in numerical overflow.\nAs a means to combat these overflow conditions, the intermediate results\nare scaled whenever they threaten to become numerically unstable.\u003c/p\u003e\n\n@param x the evaluation point.\n@param epsilon maximum error allowed.\n@param maxIterations maximum number of convergents\n@return the value of the continued fraction evaluated at x.\n@throws MathException if the algorithm fails to converge.\n",
      "diff": "@@ -1,38 +1,38 @@\n public double evaluate(double x, double epsilon, int maxIterations) throws MathException {\n     double p0 \u003d 1.0;\n     double p1 \u003d getA(0, x);\n     double q0 \u003d 0.0;\n     double q1 \u003d 1.0;\n     double c \u003d p1 / q1;\n     int n \u003d 0;\n     double relativeError \u003d Double.MAX_VALUE;\n     while (n \u003c maxIterations \u0026\u0026 relativeError \u003e epsilon) {\n         ++n;\n         double a \u003d getA(n, x);\n         double b \u003d getB(n, x);\n         double p2 \u003d a * p1 + b * p0;\n         double q2 \u003d a * q1 + b * q0;\n         if (Double.isInfinite(p2) || Double.isInfinite(q2)) {\n             if (a !\u003d 0.0) {\n                 p2 \u003d p1 + (b / a * p0);\n                 q2 \u003d q1 + (b / a * q0);\n             } else if (b !\u003d 0) {\n                 p2 \u003d (a / b * p1) + p0;\n                 q2 \u003d (a / b * q1) + q0;\n             } else {\n-                throw new ConvergenceException(\"Continued fraction convergents diverged to +/- infinity for value {0}\", new Object[] { Double.valueOf(x) });\n+                throw new ConvergenceException(\"Continued fraction convergents diverged to +/- infinity for value {0}\", x);\n             }\n         }\n         double r \u003d p2 / q2;\n         relativeError \u003d Math.abs(r / c - 1.0);\n         c \u003d p2 / q2;\n         p0 \u003d p1;\n         p1 \u003d p2;\n         q0 \u003d q1;\n         q1 \u003d q2;\n     }\n     if (n \u003e\u003d maxIterations) {\n-        throw new MaxIterationsExceededException(maxIterations, \"Continued fraction convergents failed to converge for value {0}\", new Object[] { Double.valueOf(x) });\n+        throw new MaxIterationsExceededException(maxIterations, \"Continued fraction convergents failed to converge for value {0}\", x);\n     }\n     return c;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fd0f87590d1c88c18f669e9b168c8fd20631f23c": {
      "type": "Ybodychange",
      "commitMessage": "replaced inefficient use of constructors for Integer, Long, Float and Double\nby the recommended static valueOf methods that cache results\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/branches/MATH_2_0@666292 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "6/10/08, 12:32 PM",
      "commitName": "fd0f87590d1c88c18f669e9b168c8fd20631f23c",
      "commitAuthor": "Luc Maisonobe",
      "commitDateOld": "2/2/08, 9:54 PM",
      "commitNameOld": "479f7773075c136b43a9cf120704c77c0a4880ab",
      "commitAuthorOld": "Phil Steitz",
      "daysBetweenCommits": 128.57,
      "commitsBetweenForRepo": 121,
      "commitsBetweenForFile": 1,
      "actualSource": "public double evaluate(double x, double epsilon, int maxIterations) throws MathException {\n    double p0 \u003d 1.0;\n    double p1 \u003d getA(0, x);\n    double q0 \u003d 0.0;\n    double q1 \u003d 1.0;\n    double c \u003d p1 / q1;\n    int n \u003d 0;\n    double relativeError \u003d Double.MAX_VALUE;\n    while (n \u003c maxIterations \u0026\u0026 relativeError \u003e epsilon) {\n        ++n;\n        double a \u003d getA(n, x);\n        double b \u003d getB(n, x);\n        double p2 \u003d a * p1 + b * p0;\n        double q2 \u003d a * q1 + b * q0;\n        if (Double.isInfinite(p2) || Double.isInfinite(q2)) {\n            if (a !\u003d 0.0) {\n                p2 \u003d p1 + (b / a * p0);\n                q2 \u003d q1 + (b / a * q0);\n            } else if (b !\u003d 0) {\n                p2 \u003d (a / b * p1) + p0;\n                q2 \u003d (a / b * q1) + q0;\n            } else {\n                throw new ConvergenceException(\"Continued fraction convergents diverged to +/- infinity for value {0}\", new Object[] { Double.valueOf(x) });\n            }\n        }\n        double r \u003d p2 / q2;\n        relativeError \u003d Math.abs(r / c - 1.0);\n        c \u003d p2 / q2;\n        p0 \u003d p1;\n        p1 \u003d p2;\n        q0 \u003d q1;\n        q1 \u003d q2;\n    }\n    if (n \u003e\u003d maxIterations) {\n        throw new MaxIterationsExceededException(maxIterations, \"Continued fraction convergents failed to converge for value {0}\", new Object[] { Double.valueOf(x) });\n    }\n    return c;\n}",
      "path": "src/java/org/apache/commons/math/util/ContinuedFraction.java",
      "functionStartLine": 130,
      "functionName": "evaluate",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003e\nEvaluates the continued fraction at the value x.\n\u003c/p\u003e\n\n\u003cp\u003e\nThe implementation of this method is based on equations 14-17 of:\n\u003cul\u003e\n\u003cli\u003e\n  Eric W. Weisstein. \"Continued Fraction.\" From MathWorld--A Wolfram Web\n  Resource. \u003ca target\u003d\"_blank\"\n  href\u003d\"http://mathworld.wolfram.com/ContinuedFraction.html\"\u003e\n  http://mathworld.wolfram.com/ContinuedFraction.html\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\nThe recurrence relationship defined in those equations can result in\nvery large intermediate results which can result in numerical overflow.\nAs a means to combat these overflow conditions, the intermediate results\nare scaled whenever they threaten to become numerically unstable.\u003c/p\u003e\n\n@param x the evaluation point.\n@param epsilon maximum error allowed.\n@param maxIterations maximum number of convergents\n@return the value of the continued fraction evaluated at x.\n@throws MathException if the algorithm fails to converge.\n",
      "diff": "@@ -1,38 +1,38 @@\n public double evaluate(double x, double epsilon, int maxIterations) throws MathException {\n     double p0 \u003d 1.0;\n     double p1 \u003d getA(0, x);\n     double q0 \u003d 0.0;\n     double q1 \u003d 1.0;\n     double c \u003d p1 / q1;\n     int n \u003d 0;\n     double relativeError \u003d Double.MAX_VALUE;\n     while (n \u003c maxIterations \u0026\u0026 relativeError \u003e epsilon) {\n         ++n;\n         double a \u003d getA(n, x);\n         double b \u003d getB(n, x);\n         double p2 \u003d a * p1 + b * p0;\n         double q2 \u003d a * q1 + b * q0;\n         if (Double.isInfinite(p2) || Double.isInfinite(q2)) {\n             if (a !\u003d 0.0) {\n                 p2 \u003d p1 + (b / a * p0);\n                 q2 \u003d q1 + (b / a * q0);\n             } else if (b !\u003d 0) {\n                 p2 \u003d (a / b * p1) + p0;\n                 q2 \u003d (a / b * q1) + q0;\n             } else {\n-                throw new ConvergenceException(\"Continued fraction convergents diverged to +/- infinity for value {0}\", new Object[] { new Double(x) });\n+                throw new ConvergenceException(\"Continued fraction convergents diverged to +/- infinity for value {0}\", new Object[] { Double.valueOf(x) });\n             }\n         }\n         double r \u003d p2 / q2;\n         relativeError \u003d Math.abs(r / c - 1.0);\n         c \u003d p2 / q2;\n         p0 \u003d p1;\n         p1 \u003d p2;\n         q0 \u003d q1;\n         q1 \u003d q2;\n     }\n     if (n \u003e\u003d maxIterations) {\n-        throw new MaxIterationsExceededException(maxIterations, \"Continued fraction convergents failed to converge for value {0}\", new Object[] { new Double(x) });\n+        throw new MaxIterationsExceededException(maxIterations, \"Continued fraction convergents failed to converge for value {0}\", new Object[] { Double.valueOf(x) });\n     }\n     return c;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "479f7773075c136b43a9cf120704c77c0a4880ab": {
      "type": "Ydocchange",
      "commitMessage": "Javadoc only.  Added missing \u003c/p\u003e\u0027s\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@617953 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2/2/08, 9:54 PM",
      "commitName": "479f7773075c136b43a9cf120704c77c0a4880ab",
      "commitAuthor": "Phil Steitz",
      "commitDateOld": "2/12/07, 11:17 AM",
      "commitNameOld": "d2d4c5fd63f279be0797468277593ef72506c696",
      "commitAuthorOld": "Luc Maisonobe",
      "daysBetweenCommits": 355.44,
      "commitsBetweenForRepo": 266,
      "commitsBetweenForFile": 1,
      "actualSource": "public double evaluate(double x, double epsilon, int maxIterations) throws MathException {\n    double p0 \u003d 1.0;\n    double p1 \u003d getA(0, x);\n    double q0 \u003d 0.0;\n    double q1 \u003d 1.0;\n    double c \u003d p1 / q1;\n    int n \u003d 0;\n    double relativeError \u003d Double.MAX_VALUE;\n    while (n \u003c maxIterations \u0026\u0026 relativeError \u003e epsilon) {\n        ++n;\n        double a \u003d getA(n, x);\n        double b \u003d getB(n, x);\n        double p2 \u003d a * p1 + b * p0;\n        double q2 \u003d a * q1 + b * q0;\n        if (Double.isInfinite(p2) || Double.isInfinite(q2)) {\n            if (a !\u003d 0.0) {\n                p2 \u003d p1 + (b / a * p0);\n                q2 \u003d q1 + (b / a * q0);\n            } else if (b !\u003d 0) {\n                p2 \u003d (a / b * p1) + p0;\n                q2 \u003d (a / b * q1) + q0;\n            } else {\n                throw new ConvergenceException(\"Continued fraction convergents diverged to +/- infinity for value {0}\", new Object[] { new Double(x) });\n            }\n        }\n        double r \u003d p2 / q2;\n        relativeError \u003d Math.abs(r / c - 1.0);\n        c \u003d p2 / q2;\n        p0 \u003d p1;\n        p1 \u003d p2;\n        q0 \u003d q1;\n        q1 \u003d q2;\n    }\n    if (n \u003e\u003d maxIterations) {\n        throw new MaxIterationsExceededException(maxIterations, \"Continued fraction convergents failed to converge for value {0}\", new Object[] { new Double(x) });\n    }\n    return c;\n}",
      "path": "src/java/org/apache/commons/math/util/ContinuedFraction.java",
      "functionStartLine": 130,
      "functionName": "evaluate",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003e\nEvaluates the continued fraction at the value x.\n\u003c/p\u003e\n\n\u003cp\u003e\nThe implementation of this method is based on equations 14-17 of:\n\u003cul\u003e\n\u003cli\u003e\n  Eric W. Weisstein. \"Continued Fraction.\" From MathWorld--A Wolfram Web\n  Resource. \u003ca target\u003d\"_blank\"\n  href\u003d\"http://mathworld.wolfram.com/ContinuedFraction.html\"\u003e\n  http://mathworld.wolfram.com/ContinuedFraction.html\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\nThe recurrence relationship defined in those equations can result in\nvery large intermediate results which can result in numerical overflow.\nAs a means to combat these overflow conditions, the intermediate results\nare scaled whenever they threaten to become numerically unstable.\u003c/p\u003e\n\n@param x the evaluation point.\n@param epsilon maximum error allowed.\n@param maxIterations maximum number of convergents\n@return the value of the continued fraction evaluated at x.\n@throws MathException if the algorithm fails to converge.\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "\u003cp\u003e\nEvaluates the continued fraction at the value x.\n\u003c/p\u003e\n\n\u003cp\u003e\nThe implementation of this method is based on equations 14-17 of:\n\u003cul\u003e\n\u003cli\u003e\n  Eric W. Weisstein. \"Continued Fraction.\" From MathWorld--A Wolfram Web\n  Resource. \u003ca target\u003d\"_blank\"\n  href\u003d\"http://mathworld.wolfram.com/ContinuedFraction.html\"\u003e\n  http://mathworld.wolfram.com/ContinuedFraction.html\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\nThe recurrence relationship defined in those equations can result in\nvery large intermediate results which can result in numerical overflow.\nAs a means to combat these overflow conditions, the intermediate results\nare scaled whenever they threaten to become numerically unstable.\n\n@param x the evaluation point.\n@param epsilon maximum error allowed.\n@param maxIterations maximum number of convergents\n@return the value of the continued fraction evaluated at x.\n@throws MathException if the algorithm fails to converge.\n",
        "newValue": "\u003cp\u003e\nEvaluates the continued fraction at the value x.\n\u003c/p\u003e\n\n\u003cp\u003e\nThe implementation of this method is based on equations 14-17 of:\n\u003cul\u003e\n\u003cli\u003e\n  Eric W. Weisstein. \"Continued Fraction.\" From MathWorld--A Wolfram Web\n  Resource. \u003ca target\u003d\"_blank\"\n  href\u003d\"http://mathworld.wolfram.com/ContinuedFraction.html\"\u003e\n  http://mathworld.wolfram.com/ContinuedFraction.html\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\nThe recurrence relationship defined in those equations can result in\nvery large intermediate results which can result in numerical overflow.\nAs a means to combat these overflow conditions, the intermediate results\nare scaled whenever they threaten to become numerically unstable.\u003c/p\u003e\n\n@param x the evaluation point.\n@param epsilon maximum error allowed.\n@param maxIterations maximum number of convergents\n@return the value of the continued fraction evaluated at x.\n@throws MathException if the algorithm fails to converge.\n"
      }
    },
    "d2d4c5fd63f279be0797468277593ef72506c696": {
      "type": "Ybodychange",
      "commitMessage": "Added and used a specialized convergence exception for exceeded iteration counts\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/math/trunk@506585 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2/12/07, 11:17 AM",
      "commitName": "d2d4c5fd63f279be0797468277593ef72506c696",
      "commitAuthor": "Luc Maisonobe",
      "commitDateOld": "11/28/06, 11:14 PM",
      "commitNameOld": "05f7f6059bd0cbb69b5dd49c061f1f3520e0ee1e",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 75.5,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "public double evaluate(double x, double epsilon, int maxIterations) throws MathException {\n    double p0 \u003d 1.0;\n    double p1 \u003d getA(0, x);\n    double q0 \u003d 0.0;\n    double q1 \u003d 1.0;\n    double c \u003d p1 / q1;\n    int n \u003d 0;\n    double relativeError \u003d Double.MAX_VALUE;\n    while (n \u003c maxIterations \u0026\u0026 relativeError \u003e epsilon) {\n        ++n;\n        double a \u003d getA(n, x);\n        double b \u003d getB(n, x);\n        double p2 \u003d a * p1 + b * p0;\n        double q2 \u003d a * q1 + b * q0;\n        if (Double.isInfinite(p2) || Double.isInfinite(q2)) {\n            if (a !\u003d 0.0) {\n                p2 \u003d p1 + (b / a * p0);\n                q2 \u003d q1 + (b / a * q0);\n            } else if (b !\u003d 0) {\n                p2 \u003d (a / b * p1) + p0;\n                q2 \u003d (a / b * q1) + q0;\n            } else {\n                throw new ConvergenceException(\"Continued fraction convergents diverged to +/- infinity for value {0}\", new Object[] { new Double(x) });\n            }\n        }\n        double r \u003d p2 / q2;\n        relativeError \u003d Math.abs(r / c - 1.0);\n        c \u003d p2 / q2;\n        p0 \u003d p1;\n        p1 \u003d p2;\n        q0 \u003d q1;\n        q1 \u003d q2;\n    }\n    if (n \u003e\u003d maxIterations) {\n        throw new MaxIterationsExceededException(maxIterations, \"Continued fraction convergents failed to converge for value {0}\", new Object[] { new Double(x) });\n    }\n    return c;\n}",
      "path": "src/java/org/apache/commons/math/util/ContinuedFraction.java",
      "functionStartLine": 130,
      "functionName": "evaluate",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003e\nEvaluates the continued fraction at the value x.\n\u003c/p\u003e\n\n\u003cp\u003e\nThe implementation of this method is based on equations 14-17 of:\n\u003cul\u003e\n\u003cli\u003e\n  Eric W. Weisstein. \"Continued Fraction.\" From MathWorld--A Wolfram Web\n  Resource. \u003ca target\u003d\"_blank\"\n  href\u003d\"http://mathworld.wolfram.com/ContinuedFraction.html\"\u003e\n  http://mathworld.wolfram.com/ContinuedFraction.html\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\nThe recurrence relationship defined in those equations can result in\nvery large intermediate results which can result in numerical overflow.\nAs a means to combat these overflow conditions, the intermediate results\nare scaled whenever they threaten to become numerically unstable.\n\n@param x the evaluation point.\n@param epsilon maximum error allowed.\n@param maxIterations maximum number of convergents\n@return the value of the continued fraction evaluated at x.\n@throws MathException if the algorithm fails to converge.\n",
      "diff": "@@ -1,38 +1,38 @@\n public double evaluate(double x, double epsilon, int maxIterations) throws MathException {\n     double p0 \u003d 1.0;\n     double p1 \u003d getA(0, x);\n     double q0 \u003d 0.0;\n     double q1 \u003d 1.0;\n     double c \u003d p1 / q1;\n     int n \u003d 0;\n     double relativeError \u003d Double.MAX_VALUE;\n     while (n \u003c maxIterations \u0026\u0026 relativeError \u003e epsilon) {\n         ++n;\n         double a \u003d getA(n, x);\n         double b \u003d getB(n, x);\n         double p2 \u003d a * p1 + b * p0;\n         double q2 \u003d a * q1 + b * q0;\n         if (Double.isInfinite(p2) || Double.isInfinite(q2)) {\n             if (a !\u003d 0.0) {\n                 p2 \u003d p1 + (b / a * p0);\n                 q2 \u003d q1 + (b / a * q0);\n             } else if (b !\u003d 0) {\n                 p2 \u003d (a / b * p1) + p0;\n                 q2 \u003d (a / b * q1) + q0;\n             } else {\n-                throw new ConvergenceException(\"Continued fraction convergents diverged to +/- \" + \"infinity.\");\n+                throw new ConvergenceException(\"Continued fraction convergents diverged to +/- infinity for value {0}\", new Object[] { new Double(x) });\n             }\n         }\n         double r \u003d p2 / q2;\n         relativeError \u003d Math.abs(r / c - 1.0);\n         c \u003d p2 / q2;\n         p0 \u003d p1;\n         p1 \u003d p2;\n         q0 \u003d q1;\n         q1 \u003d q2;\n     }\n     if (n \u003e\u003d maxIterations) {\n-        throw new ConvergenceException(\"Continued fraction convergents failed to converge.\");\n+        throw new MaxIterationsExceededException(maxIterations, \"Continued fraction convergents failed to converge for value {0}\", new Object[] { new Double(x) });\n     }\n     return c;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6ef3b2932f4ca9219e41784bb0cd229dcabcdb11": {
      "type": "Yformatchange",
      "commitMessage": "Merged (final) src changes from MATH_1_1 release branch r321516-358399\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/math/trunk@358631 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/22/05, 1:16 PM",
      "commitName": "6ef3b2932f4ca9219e41784bb0cd229dcabcdb11",
      "commitAuthor": "Phil Steitz",
      "commitDateOld": "8/22/05, 7:27 PM",
      "commitNameOld": "ad6929ea0c89c085422c1e43bb3f763a0e3d25e4",
      "commitAuthorOld": "Brent Worden",
      "daysBetweenCommits": 121.78,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "actualSource": "public double evaluate(double x, double epsilon, int maxIterations) throws MathException {\n    double p0 \u003d 1.0;\n    double p1 \u003d getA(0, x);\n    double q0 \u003d 0.0;\n    double q1 \u003d 1.0;\n    double c \u003d p1 / q1;\n    int n \u003d 0;\n    double relativeError \u003d Double.MAX_VALUE;\n    while (n \u003c maxIterations \u0026\u0026 relativeError \u003e epsilon) {\n        ++n;\n        double a \u003d getA(n, x);\n        double b \u003d getB(n, x);\n        double p2 \u003d a * p1 + b * p0;\n        double q2 \u003d a * q1 + b * q0;\n        if (Double.isInfinite(p2) || Double.isInfinite(q2)) {\n            if (a !\u003d 0.0) {\n                p2 \u003d p1 + (b / a * p0);\n                q2 \u003d q1 + (b / a * q0);\n            } else if (b !\u003d 0) {\n                p2 \u003d (a / b * p1) + p0;\n                q2 \u003d (a / b * q1) + q0;\n            } else {\n                throw new ConvergenceException(\"Continued fraction convergents diverged to +/- \" + \"infinity.\");\n            }\n        }\n        double r \u003d p2 / q2;\n        relativeError \u003d Math.abs(r / c - 1.0);\n        c \u003d p2 / q2;\n        p0 \u003d p1;\n        p1 \u003d p2;\n        q0 \u003d q1;\n        q1 \u003d q2;\n    }\n    if (n \u003e\u003d maxIterations) {\n        throw new ConvergenceException(\"Continued fraction convergents failed to converge.\");\n    }\n    return c;\n}",
      "path": "src/java/org/apache/commons/math/util/ContinuedFraction.java",
      "functionStartLine": 128,
      "functionName": "evaluate",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003e\nEvaluates the continued fraction at the value x.\n\u003c/p\u003e\n\n\u003cp\u003e\nThe implementation of this method is based on equations 14-17 of:\n\u003cul\u003e\n\u003cli\u003e\n  Eric W. Weisstein. \"Continued Fraction.\" From MathWorld--A Wolfram Web\n  Resource. \u003ca target\u003d\"_blank\"\n  href\u003d\"http://mathworld.wolfram.com/ContinuedFraction.html\"\u003e\n  http://mathworld.wolfram.com/ContinuedFraction.html\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\nThe recurrence relationship defined in those equations can result in\nvery large intermediate results which can result in numerical overflow.\nAs a means to combat these overflow conditions, the intermediate results\nare scaled whenever they threaten to become numerically unstable.\n\n@param x the evaluation point.\n@param epsilon maximum error allowed.\n@param maxIterations maximum number of convergents\n@return the value of the continued fraction evaluated at x.\n@throws MathException if the algorithm fails to converge.\n",
      "diff": "",
      "extendedDetails": {}
    },
    "ad6929ea0c89c085422c1e43bb3f763a0e3d25e4": {
      "type": "Ymultichange(Ybodychange,Ydocchange)",
      "commitMessage": "Merged changes in MATH_1_1 branch to trunk.  This includes revision 232577 through revision 234481.\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/math/trunk@239294 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "8/22/05, 7:27 PM",
      "commitName": "ad6929ea0c89c085422c1e43bb3f763a0e3d25e4",
      "commitAuthor": "Brent Worden",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "Merged changes in MATH_1_1 branch to trunk.  This includes revision 232577 through revision 234481.\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/math/trunk@239294 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "8/22/05, 7:27 PM",
          "commitName": "ad6929ea0c89c085422c1e43bb3f763a0e3d25e4",
          "commitAuthor": "Brent Worden",
          "commitDateOld": "2/26/05, 5:11 AM",
          "commitNameOld": "65b65f88b74de6b3462b04b2cf2a69f064a77557",
          "commitAuthorOld": "Dirk Verbeeck",
          "daysBetweenCommits": 177.55,
          "commitsBetweenForRepo": 77,
          "commitsBetweenForFile": 1,
          "actualSource": "public double evaluate(double x, double epsilon, int maxIterations) throws MathException {\n    double p0 \u003d 1.0;\n    double p1 \u003d getA(0, x);\n    double q0 \u003d 0.0;\n    double q1 \u003d 1.0;\n    double c \u003d p1 / q1;\n    int n \u003d 0;\n    double relativeError \u003d Double.MAX_VALUE;\n    while (n \u003c maxIterations \u0026\u0026 relativeError \u003e epsilon) {\n        ++n;\n        double a \u003d getA(n, x);\n        double b \u003d getB(n, x);\n        double p2 \u003d a * p1 + b * p0;\n        double q2 \u003d a * q1 + b * q0;\n        if (Double.isInfinite(p2) || Double.isInfinite(q2)) {\n            if (a !\u003d 0.0) {\n                p2 \u003d p1 + (b / a * p0);\n                q2 \u003d q1 + (b / a * q0);\n            } else if (b !\u003d 0) {\n                p2 \u003d (a / b * p1) + p0;\n                q2 \u003d (a / b * q1) + q0;\n            } else {\n                throw new ConvergenceException(\"Continued fraction convergents diverged to +/- \" + \"infinity.\");\n            }\n        }\n        double r \u003d p2 / q2;\n        relativeError \u003d Math.abs(r / c - 1.0);\n        c \u003d p2 / q2;\n        p0 \u003d p1;\n        p1 \u003d p2;\n        q0 \u003d q1;\n        q1 \u003d q2;\n    }\n    if (n \u003e\u003d maxIterations) {\n        throw new ConvergenceException(\"Continued fraction convergents failed to converge.\");\n    }\n    return c;\n}",
          "path": "src/java/org/apache/commons/math/util/ContinuedFraction.java",
          "functionStartLine": 128,
          "functionName": "evaluate",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003e\nEvaluates the continued fraction at the value x.\n\u003c/p\u003e\n\n\u003cp\u003e\nThe implementation of this method is based on equations 14-17 of:\n\u003cul\u003e\n\u003cli\u003e\n  Eric W. Weisstein. \"Continued Fraction.\" From MathWorld--A Wolfram Web\n  Resource. \u003ca target\u003d\"_blank\"\n  href\u003d\"http://mathworld.wolfram.com/ContinuedFraction.html\"\u003e\n  http://mathworld.wolfram.com/ContinuedFraction.html\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\nThe recurrence relationship defined in those equations can result in\nvery large intermediate results which can result in numerical overflow.\nAs a means to combat these overflow conditions, the intermediate results\nare scaled whenever they threaten to become numerically unstable.\n\n@param x the evaluation point.\n@param epsilon maximum error allowed.\n@param maxIterations maximum number of convergents\n@return the value of the continued fraction evaluated at x.\n@throws MathException if the algorithm fails to converge.\n",
          "diff": "@@ -1,10 +1,38 @@\n public double evaluate(double x, double epsilon, int maxIterations) throws MathException {\n-    double[][] f \u003d new double[2][2];\n-    double[][] a \u003d new double[2][2];\n-    double[][] an \u003d new double[2][2];\n-    a[0][0] \u003d getA(0, x);\n-    a[0][1] \u003d 1.0;\n-    a[1][0] \u003d 1.0;\n-    a[1][1] \u003d 0.0;\n-    return evaluate(1, x, a, an, f, epsilon, maxIterations);\n+    double p0 \u003d 1.0;\n+    double p1 \u003d getA(0, x);\n+    double q0 \u003d 0.0;\n+    double q1 \u003d 1.0;\n+    double c \u003d p1 / q1;\n+    int n \u003d 0;\n+    double relativeError \u003d Double.MAX_VALUE;\n+    while (n \u003c maxIterations \u0026\u0026 relativeError \u003e epsilon) {\n+        ++n;\n+        double a \u003d getA(n, x);\n+        double b \u003d getB(n, x);\n+        double p2 \u003d a * p1 + b * p0;\n+        double q2 \u003d a * q1 + b * q0;\n+        if (Double.isInfinite(p2) || Double.isInfinite(q2)) {\n+            if (a !\u003d 0.0) {\n+                p2 \u003d p1 + (b / a * p0);\n+                q2 \u003d q1 + (b / a * q0);\n+            } else if (b !\u003d 0) {\n+                p2 \u003d (a / b * p1) + p0;\n+                q2 \u003d (a / b * q1) + q0;\n+            } else {\n+                throw new ConvergenceException(\"Continued fraction convergents diverged to +/- \" + \"infinity.\");\n+            }\n+        }\n+        double r \u003d p2 / q2;\n+        relativeError \u003d Math.abs(r / c - 1.0);\n+        c \u003d p2 / q2;\n+        p0 \u003d p1;\n+        p1 \u003d p2;\n+        q0 \u003d q1;\n+        q1 \u003d q2;\n+    }\n+    if (n \u003e\u003d maxIterations) {\n+        throw new ConvergenceException(\"Continued fraction convergents failed to converge.\");\n+    }\n+    return c;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Merged changes in MATH_1_1 branch to trunk.  This includes revision 232577 through revision 234481.\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/math/trunk@239294 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "8/22/05, 7:27 PM",
          "commitName": "ad6929ea0c89c085422c1e43bb3f763a0e3d25e4",
          "commitAuthor": "Brent Worden",
          "commitDateOld": "2/26/05, 5:11 AM",
          "commitNameOld": "65b65f88b74de6b3462b04b2cf2a69f064a77557",
          "commitAuthorOld": "Dirk Verbeeck",
          "daysBetweenCommits": 177.55,
          "commitsBetweenForRepo": 77,
          "commitsBetweenForFile": 1,
          "actualSource": "public double evaluate(double x, double epsilon, int maxIterations) throws MathException {\n    double p0 \u003d 1.0;\n    double p1 \u003d getA(0, x);\n    double q0 \u003d 0.0;\n    double q1 \u003d 1.0;\n    double c \u003d p1 / q1;\n    int n \u003d 0;\n    double relativeError \u003d Double.MAX_VALUE;\n    while (n \u003c maxIterations \u0026\u0026 relativeError \u003e epsilon) {\n        ++n;\n        double a \u003d getA(n, x);\n        double b \u003d getB(n, x);\n        double p2 \u003d a * p1 + b * p0;\n        double q2 \u003d a * q1 + b * q0;\n        if (Double.isInfinite(p2) || Double.isInfinite(q2)) {\n            if (a !\u003d 0.0) {\n                p2 \u003d p1 + (b / a * p0);\n                q2 \u003d q1 + (b / a * q0);\n            } else if (b !\u003d 0) {\n                p2 \u003d (a / b * p1) + p0;\n                q2 \u003d (a / b * q1) + q0;\n            } else {\n                throw new ConvergenceException(\"Continued fraction convergents diverged to +/- \" + \"infinity.\");\n            }\n        }\n        double r \u003d p2 / q2;\n        relativeError \u003d Math.abs(r / c - 1.0);\n        c \u003d p2 / q2;\n        p0 \u003d p1;\n        p1 \u003d p2;\n        q0 \u003d q1;\n        q1 \u003d q2;\n    }\n    if (n \u003e\u003d maxIterations) {\n        throw new ConvergenceException(\"Continued fraction convergents failed to converge.\");\n    }\n    return c;\n}",
          "path": "src/java/org/apache/commons/math/util/ContinuedFraction.java",
          "functionStartLine": 128,
          "functionName": "evaluate",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003e\nEvaluates the continued fraction at the value x.\n\u003c/p\u003e\n\n\u003cp\u003e\nThe implementation of this method is based on equations 14-17 of:\n\u003cul\u003e\n\u003cli\u003e\n  Eric W. Weisstein. \"Continued Fraction.\" From MathWorld--A Wolfram Web\n  Resource. \u003ca target\u003d\"_blank\"\n  href\u003d\"http://mathworld.wolfram.com/ContinuedFraction.html\"\u003e\n  http://mathworld.wolfram.com/ContinuedFraction.html\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\nThe recurrence relationship defined in those equations can result in\nvery large intermediate results which can result in numerical overflow.\nAs a means to combat these overflow conditions, the intermediate results\nare scaled whenever they threaten to become numerically unstable.\n\n@param x the evaluation point.\n@param epsilon maximum error allowed.\n@param maxIterations maximum number of convergents\n@return the value of the continued fraction evaluated at x.\n@throws MathException if the algorithm fails to converge.\n",
          "diff": "@@ -1,10 +1,38 @@\n public double evaluate(double x, double epsilon, int maxIterations) throws MathException {\n-    double[][] f \u003d new double[2][2];\n-    double[][] a \u003d new double[2][2];\n-    double[][] an \u003d new double[2][2];\n-    a[0][0] \u003d getA(0, x);\n-    a[0][1] \u003d 1.0;\n-    a[1][0] \u003d 1.0;\n-    a[1][1] \u003d 0.0;\n-    return evaluate(1, x, a, an, f, epsilon, maxIterations);\n+    double p0 \u003d 1.0;\n+    double p1 \u003d getA(0, x);\n+    double q0 \u003d 0.0;\n+    double q1 \u003d 1.0;\n+    double c \u003d p1 / q1;\n+    int n \u003d 0;\n+    double relativeError \u003d Double.MAX_VALUE;\n+    while (n \u003c maxIterations \u0026\u0026 relativeError \u003e epsilon) {\n+        ++n;\n+        double a \u003d getA(n, x);\n+        double b \u003d getB(n, x);\n+        double p2 \u003d a * p1 + b * p0;\n+        double q2 \u003d a * q1 + b * q0;\n+        if (Double.isInfinite(p2) || Double.isInfinite(q2)) {\n+            if (a !\u003d 0.0) {\n+                p2 \u003d p1 + (b / a * p0);\n+                q2 \u003d q1 + (b / a * q0);\n+            } else if (b !\u003d 0) {\n+                p2 \u003d (a / b * p1) + p0;\n+                q2 \u003d (a / b * q1) + q0;\n+            } else {\n+                throw new ConvergenceException(\"Continued fraction convergents diverged to +/- \" + \"infinity.\");\n+            }\n+        }\n+        double r \u003d p2 / q2;\n+        relativeError \u003d Math.abs(r / c - 1.0);\n+        c \u003d p2 / q2;\n+        p0 \u003d p1;\n+        p1 \u003d p2;\n+        q0 \u003d q1;\n+        q1 \u003d q2;\n+    }\n+    if (n \u003e\u003d maxIterations) {\n+        throw new ConvergenceException(\"Continued fraction convergents failed to converge.\");\n+    }\n+    return c;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Evaluates the continued fraction at the value x.\n\nThe implementation of this method is based on:\n\u003cul\u003e\n\u003cli\u003eO. E-gecio-glu, C . K. Koc, J. Rifa i Coma,\n\u003ca href\u003d\"http://citeseer.ist.psu.edu/egecioglu91fast.html\"\u003e\nOn Fast Computation of Continued Fractions\u003c/a\u003e, Computers Math. Applic.,\n21(2--3), 1991, 167--169.\u003c/li\u003e\n\u003c/ul\u003e\n\n@param x the evaluation point.\n@param epsilon maximum error allowed.\n@param maxIterations maximum number of convergents\n@return the value of the continued fraction evaluated at x.\n@throws MathException if the algorithm fails to converge.\n",
            "newValue": "\u003cp\u003e\nEvaluates the continued fraction at the value x.\n\u003c/p\u003e\n\n\u003cp\u003e\nThe implementation of this method is based on equations 14-17 of:\n\u003cul\u003e\n\u003cli\u003e\n  Eric W. Weisstein. \"Continued Fraction.\" From MathWorld--A Wolfram Web\n  Resource. \u003ca target\u003d\"_blank\"\n  href\u003d\"http://mathworld.wolfram.com/ContinuedFraction.html\"\u003e\n  http://mathworld.wolfram.com/ContinuedFraction.html\u003c/a\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\nThe recurrence relationship defined in those equations can result in\nvery large intermediate results which can result in numerical overflow.\nAs a means to combat these overflow conditions, the intermediate results\nare scaled whenever they threaten to become numerically unstable.\n\n@param x the evaluation point.\n@param epsilon maximum error allowed.\n@param maxIterations maximum number of convergents\n@return the value of the continued fraction evaluated at x.\n@throws MathException if the algorithm fails to converge.\n"
          }
        }
      ]
    },
    "7b22aec5529fb3bad1e8098938271398d13c92ba": {
      "type": "Ydocchange",
      "commitMessage": "Fixed javadoc, checkstyle, and link warnings.  Made some corrections and additions to the user guide.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/math/trunk@141331 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "6/23/04, 9:26 AM",
      "commitName": "7b22aec5529fb3bad1e8098938271398d13c92ba",
      "commitAuthor": "Brent Worden",
      "commitDateOld": "6/1/04, 5:15 PM",
      "commitNameOld": "1a46b43aed7d8ee2541e294ed6c11c178de3241e",
      "commitAuthorOld": "Mark R. Diggory",
      "daysBetweenCommits": 21.67,
      "commitsBetweenForRepo": 62,
      "commitsBetweenForFile": 1,
      "actualSource": "public double evaluate(double x, double epsilon, int maxIterations) throws MathException {\n    double[][] f \u003d new double[2][2];\n    double[][] a \u003d new double[2][2];\n    double[][] an \u003d new double[2][2];\n    a[0][0] \u003d getA(0, x);\n    a[0][1] \u003d 1.0;\n    a[1][0] \u003d 1.0;\n    a[1][1] \u003d 0.0;\n    return evaluate(1, x, a, an, f, epsilon, maxIterations);\n}",
      "path": "src/java/org/apache/commons/math/util/ContinuedFraction.java",
      "functionStartLine": 119,
      "functionName": "evaluate",
      "functionAnnotation": "",
      "functionDoc": "Evaluates the continued fraction at the value x.\n\nThe implementation of this method is based on:\n\u003cul\u003e\n\u003cli\u003eO. E-gecio-glu, C . K. Koc, J. Rifa i Coma,\n\u003ca href\u003d\"http://citeseer.ist.psu.edu/egecioglu91fast.html\"\u003e\nOn Fast Computation of Continued Fractions\u003c/a\u003e, Computers Math. Applic.,\n21(2--3), 1991, 167--169.\u003c/li\u003e\n\u003c/ul\u003e\n\n@param x the evaluation point.\n@param epsilon maximum error allowed.\n@param maxIterations maximum number of convergents\n@return the value of the continued fraction evaluated at x.\n@throws MathException if the algorithm fails to converge.\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "Evaluates the continued fraction at the value x.\n\nThe implementation of this method is based on:\n\u003cul\u003e\n\u003cli\u003eO. E-gecio-glu, C . K. Koc, J. Rifa i Coma,\n\u003ca href\u003d\"http://citeseer.nj.nec.com/egecioglu91fast.html\"\u003e\nFast Computation of Continued Fractions\u003c/a\u003e, Computers Math. Applic.,\n21(2--3), 1991, 167--169.\u003c/li\u003e\n\u003c/ul\u003e\n\n@param x the evaluation point.\n@param epsilon maximum error allowed.\n@param maxIterations maximum number of convergents\n@return the value of the continued fraction evaluated at x.\n@throws MathException if the algorithm fails to converge.\n",
        "newValue": "Evaluates the continued fraction at the value x.\n\nThe implementation of this method is based on:\n\u003cul\u003e\n\u003cli\u003eO. E-gecio-glu, C . K. Koc, J. Rifa i Coma,\n\u003ca href\u003d\"http://citeseer.ist.psu.edu/egecioglu91fast.html\"\u003e\nOn Fast Computation of Continued Fractions\u003c/a\u003e, Computers Math. Applic.,\n21(2--3), 1991, 167--169.\u003c/li\u003e\n\u003c/ul\u003e\n\n@param x the evaluation point.\n@param epsilon maximum error allowed.\n@param maxIterations maximum number of convergents\n@return the value of the continued fraction evaluated at x.\n@throws MathException if the algorithm fails to converge.\n"
      }
    },
    "0a904461932f2c0455611e77ec6a8d8aced2980b": {
      "type": "Yintroduced",
      "commitMessage": "Attempting to recover last revision.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/math/trunk@141013 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/14/03, 2:25 PM",
      "commitName": "0a904461932f2c0455611e77ec6a8d8aced2980b",
      "commitAuthor": "Mark R. Diggory",
      "diff": "@@ -0,0 +1,10 @@\n+public double evaluate(double x, double epsilon, int maxIterations) throws MathException {\n+    double[][] f \u003d new double[2][2];\n+    double[][] a \u003d new double[2][2];\n+    double[][] an \u003d new double[2][2];\n+    a[0][0] \u003d getA(0, x);\n+    a[0][1] \u003d 1.0;\n+    a[1][0] \u003d 1.0;\n+    a[1][1] \u003d 0.0;\n+    return evaluate(1, x, a, an, f, epsilon, maxIterations);\n+}\n\\ No newline at end of file\n",
      "actualSource": "public double evaluate(double x, double epsilon, int maxIterations) throws MathException {\n    double[][] f \u003d new double[2][2];\n    double[][] a \u003d new double[2][2];\n    double[][] an \u003d new double[2][2];\n    a[0][0] \u003d getA(0, x);\n    a[0][1] \u003d 1.0;\n    a[1][0] \u003d 1.0;\n    a[1][1] \u003d 0.0;\n    return evaluate(1, x, a, an, f, epsilon, maxIterations);\n}",
      "path": "src/java/org/apache/commons/math/util/ContinuedFraction.java",
      "functionStartLine": 148,
      "functionName": "evaluate",
      "functionAnnotation": "",
      "functionDoc": "Evaluates the continued fraction at the value x.\n\nThe implementation of this method is based on:\n\u003cul\u003e\n\u003cli\u003eO. E-gecio-glu, C . K. Koc, J. Rifa i Coma,\n\u003ca href\u003d\"http://citeseer.nj.nec.com/egecioglu91fast.html\"\u003e\nFast Computation of Continued Fractions\u003c/a\u003e, Computers Math. Applic.,\n21(2--3), 1991, 167--169.\u003c/li\u003e\n\u003c/ul\u003e\n\n@param x the evaluation point.\n@param epsilon maximum error allowed.\n@param maxIterations maximum number of convergents\n@return the value of the continued fraction evaluated at x.\n@throws MathException if the algorithm fails to converge.\n"
    }
  }
}