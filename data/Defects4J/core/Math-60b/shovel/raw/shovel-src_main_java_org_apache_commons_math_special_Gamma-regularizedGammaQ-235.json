{
  "origin": "codeshovel",
  "repositoryName": "Math-60b",
  "repositoryPath": "/tmp/Math-60b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "Gamma.java",
  "functionName": "regularizedGammaQ",
  "functionId": "regularizedGammaQ___a-double(modifiers-final)__x-double__epsilon-double__maxIterations-int",
  "sourceFilePath": "src/main/java/org/apache/commons/math/special/Gamma.java",
  "functionAnnotation": "",
  "functionDoc": "Returns the regularized gamma function Q(a, x) \u003d 1 - P(a, x).\n\nThe implementation of this method is based on:\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href\u003d\"http://mathworld.wolfram.com/RegularizedGammaFunction.html\"\u003e\nRegularized Gamma Function\u003c/a\u003e, equation (1).\u003c/li\u003e\n\u003cli\u003e\n\u003ca href\u003d\"http://functions.wolfram.com/GammaBetaErf/GammaRegularized/10/0003/\"\u003e\nRegularized incomplete gamma function: Continued fraction representations  (formula 06.08.10.0003)\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n@param a the a parameter.\n@param x the value.\n@param epsilon When the absolute value of the nth item in the\n               series is less than epsilon the approximation ceases\n               to calculate further elements in the series.\n@param maxIterations Maximum number of \"iterations\" to complete.\n@return the regularized gamma function P(a, x)\n@throws MathException if the algorithm fails to converge.\n",
  "functionStartLine": 235,
  "functionEndLine": 271,
  "numCommitsSeen": 41,
  "timeTaken": 1283,
  "changeHistory": [
    "80b1e90b42a34856b61cec628fcea6633d1000cd",
    "fcabfb5a821e31e42aa15740ebc7d740e689819f",
    "26dac5a0e7fc9c6be9571b3e71a15d8502480d96",
    "d6a438e931412713e99624cf9ed74470f1040184",
    "82d1aa22e3b737b9d83016a33c7d06ddcf009036",
    "9c8d2c79c1ef565337599849cd066ff63b8d5816",
    "d2d4c5fd63f279be0797468277593ef72506c696",
    "ad6929ea0c89c085422c1e43bb3f763a0e3d25e4",
    "5e15690d8e079588b3e4beedadbba6417b28d33a",
    "a25f1e4515b215f4510088cd1787725479390b14"
  ],
  "changeHistoryShort": {
    "80b1e90b42a34856b61cec628fcea6633d1000cd": "Ybodychange",
    "fcabfb5a821e31e42aa15740ebc7d740e689819f": "Ymultichange(Ybodychange,Ydocchange)",
    "26dac5a0e7fc9c6be9571b3e71a15d8502480d96": "Yformatchange",
    "d6a438e931412713e99624cf9ed74470f1040184": "Yfilerename",
    "82d1aa22e3b737b9d83016a33c7d06ddcf009036": "Ybodychange",
    "9c8d2c79c1ef565337599849cd066ff63b8d5816": "Ybodychange",
    "d2d4c5fd63f279be0797468277593ef72506c696": "Ybodychange",
    "ad6929ea0c89c085422c1e43bb3f763a0e3d25e4": "Ybodychange",
    "5e15690d8e079588b3e4beedadbba6417b28d33a": "Ybodychange",
    "a25f1e4515b215f4510088cd1787725479390b14": "Yintroduced"
  },
  "changeHistoryDetails": {
    "80b1e90b42a34856b61cec628fcea6633d1000cd": {
      "type": "Ybodychange",
      "commitMessage": "added FastMath and used it everywhere in replacement of java.util.Math\nthe unit tests have not been added yet (waiting for dfp library addition)\nJIRA: MATH-375\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@990658 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "8/29/10, 3:04 PM",
      "commitName": "80b1e90b42a34856b61cec628fcea6633d1000cd",
      "commitAuthor": "Luc Maisonobe",
      "commitDateOld": "3/8/10, 2:57 PM",
      "commitNameOld": "fcabfb5a821e31e42aa15740ebc7d740e689819f",
      "commitAuthorOld": "Phil Steitz",
      "daysBetweenCommits": 173.96,
      "commitsBetweenForRepo": 178,
      "commitsBetweenForFile": 1,
      "actualSource": "public static double regularizedGammaQ(final double a, double x, double epsilon, int maxIterations) throws MathException {\n    double ret;\n    if (Double.isNaN(a) || Double.isNaN(x) || (a \u003c\u003d 0.0) || (x \u003c 0.0)) {\n        ret \u003d Double.NaN;\n    } else if (x \u003d\u003d 0.0) {\n        ret \u003d 1.0;\n    } else if (x \u003c a + 1.0) {\n        ret \u003d 1.0 - regularizedGammaP(a, x, epsilon, maxIterations);\n    } else {\n        ContinuedFraction cf \u003d new ContinuedFraction() {\n\n            @Override\n            protected double getA(int n, double x) {\n                return ((2.0 * n) + 1.0) - a + x;\n            }\n\n            @Override\n            protected double getB(int n, double x) {\n                return n * (a - n);\n            }\n        };\n        ret \u003d 1.0 / cf.evaluate(x, epsilon, maxIterations);\n        ret \u003d FastMath.exp(-x + (a * FastMath.log(x)) - logGamma(a)) * ret;\n    }\n    return ret;\n}",
      "path": "src/main/java/org/apache/commons/math/special/Gamma.java",
      "functionStartLine": 235,
      "functionName": "regularizedGammaQ",
      "functionAnnotation": "",
      "functionDoc": "Returns the regularized gamma function Q(a, x) \u003d 1 - P(a, x).\n\nThe implementation of this method is based on:\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href\u003d\"http://mathworld.wolfram.com/RegularizedGammaFunction.html\"\u003e\nRegularized Gamma Function\u003c/a\u003e, equation (1).\u003c/li\u003e\n\u003cli\u003e\n\u003ca href\u003d\"http://functions.wolfram.com/GammaBetaErf/GammaRegularized/10/0003/\"\u003e\nRegularized incomplete gamma function: Continued fraction representations  (formula 06.08.10.0003)\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n@param a the a parameter.\n@param x the value.\n@param epsilon When the absolute value of the nth item in the\n               series is less than epsilon the approximation ceases\n               to calculate further elements in the series.\n@param maxIterations Maximum number of \"iterations\" to complete.\n@return the regularized gamma function P(a, x)\n@throws MathException if the algorithm fails to converge.\n",
      "diff": "@@ -1,26 +1,26 @@\n public static double regularizedGammaQ(final double a, double x, double epsilon, int maxIterations) throws MathException {\n     double ret;\n     if (Double.isNaN(a) || Double.isNaN(x) || (a \u003c\u003d 0.0) || (x \u003c 0.0)) {\n         ret \u003d Double.NaN;\n     } else if (x \u003d\u003d 0.0) {\n         ret \u003d 1.0;\n     } else if (x \u003c a + 1.0) {\n         ret \u003d 1.0 - regularizedGammaP(a, x, epsilon, maxIterations);\n     } else {\n         ContinuedFraction cf \u003d new ContinuedFraction() {\n \n             @Override\n             protected double getA(int n, double x) {\n                 return ((2.0 * n) + 1.0) - a + x;\n             }\n \n             @Override\n             protected double getB(int n, double x) {\n                 return n * (a - n);\n             }\n         };\n         ret \u003d 1.0 / cf.evaluate(x, epsilon, maxIterations);\n-        ret \u003d Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * ret;\n+        ret \u003d FastMath.exp(-x + (a * FastMath.log(x)) - logGamma(a)) * ret;\n     }\n     return ret;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fcabfb5a821e31e42aa15740ebc7d740e689819f": {
      "type": "Ymultichange(Ybodychange,Ydocchange)",
      "commitMessage": "Resolved multiple problems leading to inaccuracy and/or failure to compute Normal, ChiSquare and \nPoisson probabilities, Erf and Gamma functions.\n\nJIRA: MATH-282\nJIRA: MATH-301\n\nSummary of changes:\n\n* BrentSolver has been changed to expose its configured absolute accuracy. This solver is used by\n  the default inverse cum implementation in AbstractContinuousDistribution and the hard-coded setting\n  (1E-6) was limiting accuracy in inverse cumulative probability estimates. AbstractContinuousDistribution\n  was changed to allow distributions to set this value and NormalDistributionImpl was changed to set it to\n  1E-9 by default and allow users to configure it via a constructor argument.\n\n* AbstractContinuousDistribution and AbstractIntegerDistribution inverseCumulativeProbability methods\n  have been modified to check for NaN values returned by cumulativeProbability and throw MathExceptions\n  when this happens.\n\n* The criteria for choosing between the Lanczos series and continued fraction expansion when computing\n  regularized gamma functions has been changed to (x \u003e\u003d a + 1). When using the series approximation\n  (regularizedGammaP), divergence to infinity is checked and when this happens, 1 is returned.\n\n* When scaling continued fractions to (try to) avoid divergence to infinity, the larger of a and b is\n  used as a scale factor and the attempt to scale is repeated up to 5 times, using successive powers\n  of the scale factor.\n\n* The maximum number of iterations used in estimating cumulative probabilities for PoissonDistributionImpl\n  has been decreased from Integer.MAX_VALUE to 10000000 and made configurable.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@920558 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "3/8/10, 2:57 PM",
      "commitName": "fcabfb5a821e31e42aa15740ebc7d740e689819f",
      "commitAuthor": "Phil Steitz",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "Resolved multiple problems leading to inaccuracy and/or failure to compute Normal, ChiSquare and \nPoisson probabilities, Erf and Gamma functions.\n\nJIRA: MATH-282\nJIRA: MATH-301\n\nSummary of changes:\n\n* BrentSolver has been changed to expose its configured absolute accuracy. This solver is used by\n  the default inverse cum implementation in AbstractContinuousDistribution and the hard-coded setting\n  (1E-6) was limiting accuracy in inverse cumulative probability estimates. AbstractContinuousDistribution\n  was changed to allow distributions to set this value and NormalDistributionImpl was changed to set it to\n  1E-9 by default and allow users to configure it via a constructor argument.\n\n* AbstractContinuousDistribution and AbstractIntegerDistribution inverseCumulativeProbability methods\n  have been modified to check for NaN values returned by cumulativeProbability and throw MathExceptions\n  when this happens.\n\n* The criteria for choosing between the Lanczos series and continued fraction expansion when computing\n  regularized gamma functions has been changed to (x \u003e\u003d a + 1). When using the series approximation\n  (regularizedGammaP), divergence to infinity is checked and when this happens, 1 is returned.\n\n* When scaling continued fractions to (try to) avoid divergence to infinity, the larger of a and b is\n  used as a scale factor and the attempt to scale is repeated up to 5 times, using successive powers\n  of the scale factor.\n\n* The maximum number of iterations used in estimating cumulative probabilities for PoissonDistributionImpl\n  has been decreased from Integer.MAX_VALUE to 10000000 and made configurable.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@920558 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "3/8/10, 2:57 PM",
          "commitName": "fcabfb5a821e31e42aa15740ebc7d740e689819f",
          "commitAuthor": "Phil Steitz",
          "commitDateOld": "9/6/09, 8:32 AM",
          "commitNameOld": "292e891aab4d737a83ebf786c02bf4003ae0442d",
          "commitAuthorOld": "Luc Maisonobe",
          "daysBetweenCommits": 183.31,
          "commitsBetweenForRepo": 156,
          "commitsBetweenForFile": 1,
          "actualSource": "public static double regularizedGammaQ(final double a, double x, double epsilon, int maxIterations) throws MathException {\n    double ret;\n    if (Double.isNaN(a) || Double.isNaN(x) || (a \u003c\u003d 0.0) || (x \u003c 0.0)) {\n        ret \u003d Double.NaN;\n    } else if (x \u003d\u003d 0.0) {\n        ret \u003d 1.0;\n    } else if (x \u003c a + 1.0) {\n        ret \u003d 1.0 - regularizedGammaP(a, x, epsilon, maxIterations);\n    } else {\n        ContinuedFraction cf \u003d new ContinuedFraction() {\n\n            @Override\n            protected double getA(int n, double x) {\n                return ((2.0 * n) + 1.0) - a + x;\n            }\n\n            @Override\n            protected double getB(int n, double x) {\n                return n * (a - n);\n            }\n        };\n        ret \u003d 1.0 / cf.evaluate(x, epsilon, maxIterations);\n        ret \u003d Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * ret;\n    }\n    return ret;\n}",
          "path": "src/main/java/org/apache/commons/math/special/Gamma.java",
          "functionStartLine": 234,
          "functionName": "regularizedGammaQ",
          "functionAnnotation": "",
          "functionDoc": "Returns the regularized gamma function Q(a, x) \u003d 1 - P(a, x).\n\nThe implementation of this method is based on:\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href\u003d\"http://mathworld.wolfram.com/RegularizedGammaFunction.html\"\u003e\nRegularized Gamma Function\u003c/a\u003e, equation (1).\u003c/li\u003e\n\u003cli\u003e\n\u003ca href\u003d\"http://functions.wolfram.com/GammaBetaErf/GammaRegularized/10/0003/\"\u003e\nRegularized incomplete gamma function: Continued fraction representations  (formula 06.08.10.0003)\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n@param a the a parameter.\n@param x the value.\n@param epsilon When the absolute value of the nth item in the\n               series is less than epsilon the approximation ceases\n               to calculate further elements in the series.\n@param maxIterations Maximum number of \"iterations\" to complete.\n@return the regularized gamma function P(a, x)\n@throws MathException if the algorithm fails to converge.\n",
          "diff": "@@ -1,26 +1,26 @@\n public static double regularizedGammaQ(final double a, double x, double epsilon, int maxIterations) throws MathException {\n     double ret;\n     if (Double.isNaN(a) || Double.isNaN(x) || (a \u003c\u003d 0.0) || (x \u003c 0.0)) {\n         ret \u003d Double.NaN;\n     } else if (x \u003d\u003d 0.0) {\n         ret \u003d 1.0;\n-    } else if (x \u003c a || a \u003c 1.0) {\n+    } else if (x \u003c a + 1.0) {\n         ret \u003d 1.0 - regularizedGammaP(a, x, epsilon, maxIterations);\n     } else {\n         ContinuedFraction cf \u003d new ContinuedFraction() {\n \n             @Override\n             protected double getA(int n, double x) {\n                 return ((2.0 * n) + 1.0) - a + x;\n             }\n \n             @Override\n             protected double getB(int n, double x) {\n                 return n * (a - n);\n             }\n         };\n         ret \u003d 1.0 / cf.evaluate(x, epsilon, maxIterations);\n         ret \u003d Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * ret;\n     }\n     return ret;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Resolved multiple problems leading to inaccuracy and/or failure to compute Normal, ChiSquare and \nPoisson probabilities, Erf and Gamma functions.\n\nJIRA: MATH-282\nJIRA: MATH-301\n\nSummary of changes:\n\n* BrentSolver has been changed to expose its configured absolute accuracy. This solver is used by\n  the default inverse cum implementation in AbstractContinuousDistribution and the hard-coded setting\n  (1E-6) was limiting accuracy in inverse cumulative probability estimates. AbstractContinuousDistribution\n  was changed to allow distributions to set this value and NormalDistributionImpl was changed to set it to\n  1E-9 by default and allow users to configure it via a constructor argument.\n\n* AbstractContinuousDistribution and AbstractIntegerDistribution inverseCumulativeProbability methods\n  have been modified to check for NaN values returned by cumulativeProbability and throw MathExceptions\n  when this happens.\n\n* The criteria for choosing between the Lanczos series and continued fraction expansion when computing\n  regularized gamma functions has been changed to (x \u003e\u003d a + 1). When using the series approximation\n  (regularizedGammaP), divergence to infinity is checked and when this happens, 1 is returned.\n\n* When scaling continued fractions to (try to) avoid divergence to infinity, the larger of a and b is\n  used as a scale factor and the attempt to scale is repeated up to 5 times, using successive powers\n  of the scale factor.\n\n* The maximum number of iterations used in estimating cumulative probabilities for PoissonDistributionImpl\n  has been decreased from Integer.MAX_VALUE to 10000000 and made configurable.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@920558 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "3/8/10, 2:57 PM",
          "commitName": "fcabfb5a821e31e42aa15740ebc7d740e689819f",
          "commitAuthor": "Phil Steitz",
          "commitDateOld": "9/6/09, 8:32 AM",
          "commitNameOld": "292e891aab4d737a83ebf786c02bf4003ae0442d",
          "commitAuthorOld": "Luc Maisonobe",
          "daysBetweenCommits": 183.31,
          "commitsBetweenForRepo": 156,
          "commitsBetweenForFile": 1,
          "actualSource": "public static double regularizedGammaQ(final double a, double x, double epsilon, int maxIterations) throws MathException {\n    double ret;\n    if (Double.isNaN(a) || Double.isNaN(x) || (a \u003c\u003d 0.0) || (x \u003c 0.0)) {\n        ret \u003d Double.NaN;\n    } else if (x \u003d\u003d 0.0) {\n        ret \u003d 1.0;\n    } else if (x \u003c a + 1.0) {\n        ret \u003d 1.0 - regularizedGammaP(a, x, epsilon, maxIterations);\n    } else {\n        ContinuedFraction cf \u003d new ContinuedFraction() {\n\n            @Override\n            protected double getA(int n, double x) {\n                return ((2.0 * n) + 1.0) - a + x;\n            }\n\n            @Override\n            protected double getB(int n, double x) {\n                return n * (a - n);\n            }\n        };\n        ret \u003d 1.0 / cf.evaluate(x, epsilon, maxIterations);\n        ret \u003d Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * ret;\n    }\n    return ret;\n}",
          "path": "src/main/java/org/apache/commons/math/special/Gamma.java",
          "functionStartLine": 234,
          "functionName": "regularizedGammaQ",
          "functionAnnotation": "",
          "functionDoc": "Returns the regularized gamma function Q(a, x) \u003d 1 - P(a, x).\n\nThe implementation of this method is based on:\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href\u003d\"http://mathworld.wolfram.com/RegularizedGammaFunction.html\"\u003e\nRegularized Gamma Function\u003c/a\u003e, equation (1).\u003c/li\u003e\n\u003cli\u003e\n\u003ca href\u003d\"http://functions.wolfram.com/GammaBetaErf/GammaRegularized/10/0003/\"\u003e\nRegularized incomplete gamma function: Continued fraction representations  (formula 06.08.10.0003)\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n@param a the a parameter.\n@param x the value.\n@param epsilon When the absolute value of the nth item in the\n               series is less than epsilon the approximation ceases\n               to calculate further elements in the series.\n@param maxIterations Maximum number of \"iterations\" to complete.\n@return the regularized gamma function P(a, x)\n@throws MathException if the algorithm fails to converge.\n",
          "diff": "@@ -1,26 +1,26 @@\n public static double regularizedGammaQ(final double a, double x, double epsilon, int maxIterations) throws MathException {\n     double ret;\n     if (Double.isNaN(a) || Double.isNaN(x) || (a \u003c\u003d 0.0) || (x \u003c 0.0)) {\n         ret \u003d Double.NaN;\n     } else if (x \u003d\u003d 0.0) {\n         ret \u003d 1.0;\n-    } else if (x \u003c a || a \u003c 1.0) {\n+    } else if (x \u003c a + 1.0) {\n         ret \u003d 1.0 - regularizedGammaP(a, x, epsilon, maxIterations);\n     } else {\n         ContinuedFraction cf \u003d new ContinuedFraction() {\n \n             @Override\n             protected double getA(int n, double x) {\n                 return ((2.0 * n) + 1.0) - a + x;\n             }\n \n             @Override\n             protected double getB(int n, double x) {\n                 return n * (a - n);\n             }\n         };\n         ret \u003d 1.0 / cf.evaluate(x, epsilon, maxIterations);\n         ret \u003d Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * ret;\n     }\n     return ret;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Returns the regularized gamma function Q(a, x) \u003d 1 - P(a, x).\n\nThe implementation of this method is based on:\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href\u003d\"http://mathworld.wolfram.com/RegularizedGammaFunction.html\"\u003e\nRegularized Gamma Function\u003c/a\u003e, equation (1).\u003c/li\u003e\n\u003cli\u003e\n\u003ca href\u003d\"    http://functions.wolfram.com/GammaBetaErf/GammaRegularized/10/0003/\"\u003e\nRegularized incomplete gamma function: Continued fraction representations  (formula 06.08.10.0003)\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n@param a the a parameter.\n@param x the value.\n@param epsilon When the absolute value of the nth item in the\n               series is less than epsilon the approximation ceases\n               to calculate further elements in the series.\n@param maxIterations Maximum number of \"iterations\" to complete.\n@return the regularized gamma function P(a, x)\n@throws MathException if the algorithm fails to converge.\n",
            "newValue": "Returns the regularized gamma function Q(a, x) \u003d 1 - P(a, x).\n\nThe implementation of this method is based on:\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href\u003d\"http://mathworld.wolfram.com/RegularizedGammaFunction.html\"\u003e\nRegularized Gamma Function\u003c/a\u003e, equation (1).\u003c/li\u003e\n\u003cli\u003e\n\u003ca href\u003d\"http://functions.wolfram.com/GammaBetaErf/GammaRegularized/10/0003/\"\u003e\nRegularized incomplete gamma function: Continued fraction representations  (formula 06.08.10.0003)\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n@param a the a parameter.\n@param x the value.\n@param epsilon When the absolute value of the nth item in the\n               series is less than epsilon the approximation ceases\n               to calculate further elements in the series.\n@param maxIterations Maximum number of \"iterations\" to complete.\n@return the regularized gamma function P(a, x)\n@throws MathException if the algorithm fails to converge.\n"
          }
        }
      ]
    },
    "26dac5a0e7fc9c6be9571b3e71a15d8502480d96": {
      "type": "Yformatchange",
      "commitMessage": "Removed trailing spaces.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@811685 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "9/5/09, 10:36 AM",
      "commitName": "26dac5a0e7fc9c6be9571b3e71a15d8502480d96",
      "commitAuthor": "Phil Steitz",
      "commitDateOld": "9/1/09, 12:47 PM",
      "commitNameOld": "a0943be0de0b41c646328b38a9a728c39f21002b",
      "commitAuthorOld": "Luc Maisonobe",
      "daysBetweenCommits": 3.91,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "public static double regularizedGammaQ(final double a, double x, double epsilon, int maxIterations) throws MathException {\n    double ret;\n    if (Double.isNaN(a) || Double.isNaN(x) || (a \u003c\u003d 0.0) || (x \u003c 0.0)) {\n        ret \u003d Double.NaN;\n    } else if (x \u003d\u003d 0.0) {\n        ret \u003d 1.0;\n    } else if (x \u003c a || a \u003c 1.0) {\n        ret \u003d 1.0 - regularizedGammaP(a, x, epsilon, maxIterations);\n    } else {\n        ContinuedFraction cf \u003d new ContinuedFraction() {\n\n            @Override\n            protected double getA(int n, double x) {\n                return ((2.0 * n) + 1.0) - a + x;\n            }\n\n            @Override\n            protected double getB(int n, double x) {\n                return n * (a - n);\n            }\n        };\n        ret \u003d 1.0 / cf.evaluate(x, epsilon, maxIterations);\n        ret \u003d Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * ret;\n    }\n    return ret;\n}",
      "path": "src/main/java/org/apache/commons/math/special/Gamma.java",
      "functionStartLine": 226,
      "functionName": "regularizedGammaQ",
      "functionAnnotation": "",
      "functionDoc": "Returns the regularized gamma function Q(a, x) \u003d 1 - P(a, x).\n\nThe implementation of this method is based on:\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href\u003d\"http://mathworld.wolfram.com/RegularizedGammaFunction.html\"\u003e\nRegularized Gamma Function\u003c/a\u003e, equation (1).\u003c/li\u003e\n\u003cli\u003e\n\u003ca href\u003d\"    http://functions.wolfram.com/GammaBetaErf/GammaRegularized/10/0003/\"\u003e\nRegularized incomplete gamma function: Continued fraction representations  (formula 06.08.10.0003)\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n@param a the a parameter.\n@param x the value.\n@param epsilon When the absolute value of the nth item in the\n               series is less than epsilon the approximation ceases\n               to calculate further elements in the series.\n@param maxIterations Maximum number of \"iterations\" to complete.\n@return the regularized gamma function P(a, x)\n@throws MathException if the algorithm fails to converge.\n",
      "diff": "",
      "extendedDetails": {}
    },
    "d6a438e931412713e99624cf9ed74470f1040184": {
      "type": "Yfilerename",
      "commitMessage": "moved main java directory for compliance with maven standard directory layout\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@799870 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "8/1/09, 7:30 AM",
      "commitName": "d6a438e931412713e99624cf9ed74470f1040184",
      "commitAuthor": "Luc Maisonobe",
      "commitDateOld": "8/1/09, 7:23 AM",
      "commitNameOld": "2ad5ef61630be627f46ae1c266cf796f044bd4a8",
      "commitAuthorOld": "Luc Maisonobe",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public static double regularizedGammaQ(final double a, double x, double epsilon, int maxIterations) throws MathException {\n    double ret;\n    if (Double.isNaN(a) || Double.isNaN(x) || (a \u003c\u003d 0.0) || (x \u003c 0.0)) {\n        ret \u003d Double.NaN;\n    } else if (x \u003d\u003d 0.0) {\n        ret \u003d 1.0;\n    } else if (x \u003c a || a \u003c 1.0) {\n        ret \u003d 1.0 - regularizedGammaP(a, x, epsilon, maxIterations);\n    } else {\n        ContinuedFraction cf \u003d new ContinuedFraction() {\n\n            @Override\n            protected double getA(int n, double x) {\n                return ((2.0 * n) + 1.0) - a + x;\n            }\n\n            @Override\n            protected double getB(int n, double x) {\n                return n * (a - n);\n            }\n        };\n        ret \u003d 1.0 / cf.evaluate(x, epsilon, maxIterations);\n        ret \u003d Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * ret;\n    }\n    return ret;\n}",
      "path": "src/main/java/org/apache/commons/math/special/Gamma.java",
      "functionStartLine": 226,
      "functionName": "regularizedGammaQ",
      "functionAnnotation": "",
      "functionDoc": "Returns the regularized gamma function Q(a, x) \u003d 1 - P(a, x).\n\nThe implementation of this method is based on:\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href\u003d\"http://mathworld.wolfram.com/RegularizedGammaFunction.html\"\u003e\nRegularized Gamma Function\u003c/a\u003e, equation (1).\u003c/li\u003e\n\u003cli\u003e\n\u003ca href\u003d\"    http://functions.wolfram.com/GammaBetaErf/GammaRegularized/10/0003/\"\u003e\nRegularized incomplete gamma function: Continued fraction representations  (formula 06.08.10.0003)\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n@param a the a parameter.\n@param x the value.\n@param epsilon When the absolute value of the nth item in the\n               series is less than epsilon the approximation ceases\n               to calculate further elements in the series.\n@param maxIterations Maximum number of \"iterations\" to complete.\n@return the regularized gamma function P(a, x)\n@throws MathException if the algorithm fails to converge.\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/commons/math/special/Gamma.java",
        "newPath": "src/main/java/org/apache/commons/math/special/Gamma.java"
      }
    },
    "82d1aa22e3b737b9d83016a33c7d06ddcf009036": {
      "type": "Ybodychange",
      "commitMessage": "Serializable changes to util\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@778522 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "5/25/09, 3:24 PM",
      "commitName": "82d1aa22e3b737b9d83016a33c7d06ddcf009036",
      "commitAuthor": "William Barker",
      "commitDateOld": "5/25/09, 6:20 AM",
      "commitNameOld": "c0f3bdaed8cccc8ca76e8d060e96a657fa0f2476",
      "commitAuthorOld": "Phil Steitz",
      "daysBetweenCommits": 0.38,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "public static double regularizedGammaQ(final double a, double x, double epsilon, int maxIterations) throws MathException {\n    double ret;\n    if (Double.isNaN(a) || Double.isNaN(x) || (a \u003c\u003d 0.0) || (x \u003c 0.0)) {\n        ret \u003d Double.NaN;\n    } else if (x \u003d\u003d 0.0) {\n        ret \u003d 1.0;\n    } else if (x \u003c a || a \u003c 1.0) {\n        ret \u003d 1.0 - regularizedGammaP(a, x, epsilon, maxIterations);\n    } else {\n        ContinuedFraction cf \u003d new ContinuedFraction() {\n\n            @Override\n            protected double getA(int n, double x) {\n                return ((2.0 * n) + 1.0) - a + x;\n            }\n\n            @Override\n            protected double getB(int n, double x) {\n                return n * (a - n);\n            }\n        };\n        ret \u003d 1.0 / cf.evaluate(x, epsilon, maxIterations);\n        ret \u003d Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * ret;\n    }\n    return ret;\n}",
      "path": "src/java/org/apache/commons/math/special/Gamma.java",
      "functionStartLine": 231,
      "functionName": "regularizedGammaQ",
      "functionAnnotation": "",
      "functionDoc": "Returns the regularized gamma function Q(a, x) \u003d 1 - P(a, x).\n\nThe implementation of this method is based on:\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href\u003d\"http://mathworld.wolfram.com/RegularizedGammaFunction.html\"\u003e\nRegularized Gamma Function\u003c/a\u003e, equation (1).\u003c/li\u003e\n\u003cli\u003e\n\u003ca href\u003d\"    http://functions.wolfram.com/GammaBetaErf/GammaRegularized/10/0003/\"\u003e\nRegularized incomplete gamma function: Continued fraction representations  (formula 06.08.10.0003)\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n@param a the a parameter.\n@param x the value.\n@param epsilon When the absolute value of the nth item in the\n               series is less than epsilon the approximation ceases\n               to calculate further elements in the series.\n@param maxIterations Maximum number of \"iterations\" to complete.\n@return the regularized gamma function P(a, x)\n@throws MathException if the algorithm fails to converge.\n",
      "diff": "@@ -1,28 +1,26 @@\n public static double regularizedGammaQ(final double a, double x, double epsilon, int maxIterations) throws MathException {\n     double ret;\n     if (Double.isNaN(a) || Double.isNaN(x) || (a \u003c\u003d 0.0) || (x \u003c 0.0)) {\n         ret \u003d Double.NaN;\n     } else if (x \u003d\u003d 0.0) {\n         ret \u003d 1.0;\n     } else if (x \u003c a || a \u003c 1.0) {\n         ret \u003d 1.0 - regularizedGammaP(a, x, epsilon, maxIterations);\n     } else {\n         ContinuedFraction cf \u003d new ContinuedFraction() {\n \n-            private static final long serialVersionUID \u003d 5378525034886164398L;\n-\n             @Override\n             protected double getA(int n, double x) {\n                 return ((2.0 * n) + 1.0) - a + x;\n             }\n \n             @Override\n             protected double getB(int n, double x) {\n                 return n * (a - n);\n             }\n         };\n         ret \u003d 1.0 / cf.evaluate(x, epsilon, maxIterations);\n         ret \u003d Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * ret;\n     }\n     return ret;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9c8d2c79c1ef565337599849cd066ff63b8d5816": {
      "type": "Ybodychange",
      "commitMessage": "added missing @Override annotations\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@762087 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "4/5/09, 7:20 AM",
      "commitName": "9c8d2c79c1ef565337599849cd066ff63b8d5816",
      "commitAuthor": "Luc Maisonobe",
      "commitDateOld": "6/20/07, 3:24 PM",
      "commitNameOld": "e39a7750ef362679599b623b05bfadb150832515",
      "commitAuthorOld": "Phil Steitz",
      "daysBetweenCommits": 654.66,
      "commitsBetweenForRepo": 652,
      "commitsBetweenForFile": 1,
      "actualSource": "public static double regularizedGammaQ(final double a, double x, double epsilon, int maxIterations) throws MathException {\n    double ret;\n    if (Double.isNaN(a) || Double.isNaN(x) || (a \u003c\u003d 0.0) || (x \u003c 0.0)) {\n        ret \u003d Double.NaN;\n    } else if (x \u003d\u003d 0.0) {\n        ret \u003d 1.0;\n    } else if (x \u003c a || a \u003c 1.0) {\n        ret \u003d 1.0 - regularizedGammaP(a, x, epsilon, maxIterations);\n    } else {\n        ContinuedFraction cf \u003d new ContinuedFraction() {\n\n            private static final long serialVersionUID \u003d 5378525034886164398L;\n\n            @Override\n            protected double getA(int n, double x) {\n                return ((2.0 * n) + 1.0) - a + x;\n            }\n\n            @Override\n            protected double getB(int n, double x) {\n                return n * (a - n);\n            }\n        };\n        ret \u003d 1.0 / cf.evaluate(x, epsilon, maxIterations);\n        ret \u003d Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * ret;\n    }\n    return ret;\n}",
      "path": "src/java/org/apache/commons/math/special/Gamma.java",
      "functionStartLine": 225,
      "functionName": "regularizedGammaQ",
      "functionAnnotation": "",
      "functionDoc": "Returns the regularized gamma function Q(a, x) \u003d 1 - P(a, x).\n\nThe implementation of this method is based on:\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href\u003d\"http://mathworld.wolfram.com/RegularizedGammaFunction.html\"\u003e\nRegularized Gamma Function\u003c/a\u003e, equation (1).\u003c/li\u003e\n\u003cli\u003e\n\u003ca href\u003d\"    http://functions.wolfram.com/GammaBetaErf/GammaRegularized/10/0003/\"\u003e\nRegularized incomplete gamma function: Continued fraction representations  (formula 06.08.10.0003)\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n@param a the a parameter.\n@param x the value.\n@param epsilon When the absolute value of the nth item in the\n               series is less than epsilon the approximation ceases\n               to calculate further elements in the series.\n@param maxIterations Maximum number of \"iterations\" to complete.\n@return the regularized gamma function P(a, x)\n@throws MathException if the algorithm fails to converge.\n",
      "diff": "@@ -1,26 +1,28 @@\n public static double regularizedGammaQ(final double a, double x, double epsilon, int maxIterations) throws MathException {\n     double ret;\n     if (Double.isNaN(a) || Double.isNaN(x) || (a \u003c\u003d 0.0) || (x \u003c 0.0)) {\n         ret \u003d Double.NaN;\n     } else if (x \u003d\u003d 0.0) {\n         ret \u003d 1.0;\n     } else if (x \u003c a || a \u003c 1.0) {\n         ret \u003d 1.0 - regularizedGammaP(a, x, epsilon, maxIterations);\n     } else {\n         ContinuedFraction cf \u003d new ContinuedFraction() {\n \n             private static final long serialVersionUID \u003d 5378525034886164398L;\n \n+            @Override\n             protected double getA(int n, double x) {\n                 return ((2.0 * n) + 1.0) - a + x;\n             }\n \n+            @Override\n             protected double getB(int n, double x) {\n                 return n * (a - n);\n             }\n         };\n         ret \u003d 1.0 / cf.evaluate(x, epsilon, maxIterations);\n         ret \u003d Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * ret;\n     }\n     return ret;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d2d4c5fd63f279be0797468277593ef72506c696": {
      "type": "Ybodychange",
      "commitMessage": "Added and used a specialized convergence exception for exceeded iteration counts\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/math/trunk@506585 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2/12/07, 11:17 AM",
      "commitName": "d2d4c5fd63f279be0797468277593ef72506c696",
      "commitAuthor": "Luc Maisonobe",
      "commitDateOld": "11/28/06, 11:14 PM",
      "commitNameOld": "05f7f6059bd0cbb69b5dd49c061f1f3520e0ee1e",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 75.5,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "public static double regularizedGammaQ(final double a, double x, double epsilon, int maxIterations) throws MathException {\n    double ret;\n    if (Double.isNaN(a) || Double.isNaN(x) || (a \u003c\u003d 0.0) || (x \u003c 0.0)) {\n        ret \u003d Double.NaN;\n    } else if (x \u003d\u003d 0.0) {\n        ret \u003d 1.0;\n    } else if (x \u003c a || a \u003c 1.0) {\n        ret \u003d 1.0 - regularizedGammaP(a, x, epsilon, maxIterations);\n    } else {\n        ContinuedFraction cf \u003d new ContinuedFraction() {\n\n            private static final long serialVersionUID \u003d 5378525034886164398L;\n\n            protected double getA(int n, double x) {\n                return ((2.0 * n) + 1.0) - a + x;\n            }\n\n            protected double getB(int n, double x) {\n                return n * (a - n);\n            }\n        };\n        ret \u003d 1.0 / cf.evaluate(x, epsilon, maxIterations);\n        ret \u003d Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * ret;\n    }\n    return ret;\n}",
      "path": "src/java/org/apache/commons/math/special/Gamma.java",
      "functionStartLine": 225,
      "functionName": "regularizedGammaQ",
      "functionAnnotation": "",
      "functionDoc": "Returns the regularized gamma function Q(a, x) \u003d 1 - P(a, x).\n\nThe implementation of this method is based on:\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href\u003d\"http://mathworld.wolfram.com/RegularizedGammaFunction.html\"\u003e\nRegularized Gamma Function\u003c/a\u003e, equation (1).\u003c/li\u003e\n\u003cli\u003e\n\u003ca href\u003d\"    http://functions.wolfram.com/GammaBetaErf/GammaRegularized/10/0003/\"\u003e\nRegularized incomplete gamma function: Continued fraction representations  (formula 06.08.10.0003)\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n@param a the a parameter.\n@param x the value.\n@param epsilon When the absolute value of the nth item in the\n               series is less than epsilon the approximation ceases\n               to calculate further elements in the series.\n@param maxIterations Maximum number of \"iterations\" to complete.\n@return the regularized gamma function P(a, x)\n@throws MathException if the algorithm fails to converge.\n",
      "diff": "@@ -1,24 +1,26 @@\n public static double regularizedGammaQ(final double a, double x, double epsilon, int maxIterations) throws MathException {\n     double ret;\n     if (Double.isNaN(a) || Double.isNaN(x) || (a \u003c\u003d 0.0) || (x \u003c 0.0)) {\n         ret \u003d Double.NaN;\n     } else if (x \u003d\u003d 0.0) {\n         ret \u003d 1.0;\n     } else if (x \u003c a || a \u003c 1.0) {\n         ret \u003d 1.0 - regularizedGammaP(a, x, epsilon, maxIterations);\n     } else {\n         ContinuedFraction cf \u003d new ContinuedFraction() {\n \n+            private static final long serialVersionUID \u003d 5378525034886164398L;\n+\n             protected double getA(int n, double x) {\n                 return ((2.0 * n) + 1.0) - a + x;\n             }\n \n             protected double getB(int n, double x) {\n                 return n * (a - n);\n             }\n         };\n         ret \u003d 1.0 / cf.evaluate(x, epsilon, maxIterations);\n         ret \u003d Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * ret;\n     }\n     return ret;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ad6929ea0c89c085422c1e43bb3f763a0e3d25e4": {
      "type": "Ybodychange",
      "commitMessage": "Merged changes in MATH_1_1 branch to trunk.  This includes revision 232577 through revision 234481.\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/math/trunk@239294 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "8/22/05, 7:27 PM",
      "commitName": "ad6929ea0c89c085422c1e43bb3f763a0e3d25e4",
      "commitAuthor": "Brent Worden",
      "commitDateOld": "2/26/05, 5:11 AM",
      "commitNameOld": "65b65f88b74de6b3462b04b2cf2a69f064a77557",
      "commitAuthorOld": "Dirk Verbeeck",
      "daysBetweenCommits": 177.55,
      "commitsBetweenForRepo": 77,
      "commitsBetweenForFile": 1,
      "actualSource": "public static double regularizedGammaQ(final double a, double x, double epsilon, int maxIterations) throws MathException {\n    double ret;\n    if (Double.isNaN(a) || Double.isNaN(x) || (a \u003c\u003d 0.0) || (x \u003c 0.0)) {\n        ret \u003d Double.NaN;\n    } else if (x \u003d\u003d 0.0) {\n        ret \u003d 1.0;\n    } else if (x \u003c a || a \u003c 1.0) {\n        ret \u003d 1.0 - regularizedGammaP(a, x, epsilon, maxIterations);\n    } else {\n        ContinuedFraction cf \u003d new ContinuedFraction() {\n\n            protected double getA(int n, double x) {\n                return ((2.0 * n) + 1.0) - a + x;\n            }\n\n            protected double getB(int n, double x) {\n                return n * (a - n);\n            }\n        };\n        ret \u003d 1.0 / cf.evaluate(x, epsilon, maxIterations);\n        ret \u003d Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * ret;\n    }\n    return ret;\n}",
      "path": "src/java/org/apache/commons/math/special/Gamma.java",
      "functionStartLine": 222,
      "functionName": "regularizedGammaQ",
      "functionAnnotation": "",
      "functionDoc": "Returns the regularized gamma function Q(a, x) \u003d 1 - P(a, x).\n\nThe implementation of this method is based on:\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href\u003d\"http://mathworld.wolfram.com/RegularizedGammaFunction.html\"\u003e\nRegularized Gamma Function\u003c/a\u003e, equation (1).\u003c/li\u003e\n\u003cli\u003e\n\u003ca href\u003d\"    http://functions.wolfram.com/GammaBetaErf/GammaRegularized/10/0003/\"\u003e\nRegularized incomplete gamma function: Continued fraction representations  (formula 06.08.10.0003)\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n@param a the a parameter.\n@param x the value.\n@param epsilon When the absolute value of the nth item in the\n               series is less than epsilon the approximation ceases\n               to calculate further elements in the series.\n@param maxIterations Maximum number of \"iterations\" to complete.\n@return the regularized gamma function P(a, x)\n@throws MathException if the algorithm fails to converge.\n",
      "diff": "@@ -1,24 +1,24 @@\n public static double regularizedGammaQ(final double a, double x, double epsilon, int maxIterations) throws MathException {\n     double ret;\n     if (Double.isNaN(a) || Double.isNaN(x) || (a \u003c\u003d 0.0) || (x \u003c 0.0)) {\n         ret \u003d Double.NaN;\n     } else if (x \u003d\u003d 0.0) {\n         ret \u003d 1.0;\n-    } else if (x \u003c a || a \u003c\u003d 1.0) {\n+    } else if (x \u003c a || a \u003c 1.0) {\n         ret \u003d 1.0 - regularizedGammaP(a, x, epsilon, maxIterations);\n     } else {\n         ContinuedFraction cf \u003d new ContinuedFraction() {\n \n             protected double getA(int n, double x) {\n                 return ((2.0 * n) + 1.0) - a + x;\n             }\n \n             protected double getB(int n, double x) {\n                 return n * (a - n);\n             }\n         };\n         ret \u003d 1.0 / cf.evaluate(x, epsilon, maxIterations);\n         ret \u003d Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * ret;\n     }\n     return ret;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5e15690d8e079588b3e4beedadbba6417b28d33a": {
      "type": "Ybodychange",
      "commitMessage": "removed some condition logic by changing the continued fraction representation.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/math/trunk@141290 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "6/10/04, 11:34 AM",
      "commitName": "5e15690d8e079588b3e4beedadbba6417b28d33a",
      "commitAuthor": "Brent Worden",
      "commitDateOld": "6/7/04, 1:30 PM",
      "commitNameOld": "a25f1e4515b215f4510088cd1787725479390b14",
      "commitAuthorOld": "Brent Worden",
      "daysBetweenCommits": 2.92,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "public static double regularizedGammaQ(final double a, double x, double epsilon, int maxIterations) throws MathException {\n    double ret;\n    if (Double.isNaN(a) || Double.isNaN(x) || (a \u003c\u003d 0.0) || (x \u003c 0.0)) {\n        ret \u003d Double.NaN;\n    } else if (x \u003d\u003d 0.0) {\n        ret \u003d 1.0;\n    } else if (x \u003c a || a \u003c\u003d 1.0) {\n        ret \u003d 1.0 - regularizedGammaP(a, x, epsilon, maxIterations);\n    } else {\n        ContinuedFraction cf \u003d new ContinuedFraction() {\n\n            protected double getA(int n, double x) {\n                return ((2.0 * n) + 1.0) - a + x;\n            }\n\n            protected double getB(int n, double x) {\n                return n * (a - n);\n            }\n        };\n        ret \u003d 1.0 / cf.evaluate(x, epsilon, maxIterations);\n        ret \u003d Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * ret;\n    }\n    return ret;\n}",
      "path": "src/java/org/apache/commons/math/special/Gamma.java",
      "functionStartLine": 219,
      "functionName": "regularizedGammaQ",
      "functionAnnotation": "",
      "functionDoc": "Returns the regularized gamma function Q(a, x) \u003d 1 - P(a, x).\n\nThe implementation of this method is based on:\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href\u003d\"http://mathworld.wolfram.com/RegularizedGammaFunction.html\"\u003e\nRegularized Gamma Function\u003c/a\u003e, equation (1).\u003c/li\u003e\n\u003cli\u003e\n\u003ca href\u003d\"    http://functions.wolfram.com/GammaBetaErf/GammaRegularized/10/0003/\"\u003e\nRegularized incomplete gamma function: Continued fraction representations  (formula 06.08.10.0003)\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n@param a the a parameter.\n@param x the value.\n@param epsilon When the absolute value of the nth item in the\n               series is less than epsilon the approximation ceases\n               to calculate further elements in the series.\n@param maxIterations Maximum number of \"iterations\" to complete.\n@return the regularized gamma function P(a, x)\n@throws MathException if the algorithm fails to converge.\n",
      "diff": "@@ -1,44 +1,24 @@\n public static double regularizedGammaQ(final double a, double x, double epsilon, int maxIterations) throws MathException {\n     double ret;\n     if (Double.isNaN(a) || Double.isNaN(x) || (a \u003c\u003d 0.0) || (x \u003c 0.0)) {\n         ret \u003d Double.NaN;\n     } else if (x \u003d\u003d 0.0) {\n         ret \u003d 1.0;\n     } else if (x \u003c a || a \u003c\u003d 1.0) {\n         ret \u003d 1.0 - regularizedGammaP(a, x, epsilon, maxIterations);\n     } else {\n         ContinuedFraction cf \u003d new ContinuedFraction() {\n \n             protected double getA(int n, double x) {\n-                double ret;\n-                switch(n) {\n-                    case 0:\n-                        ret \u003d 0.0;\n-                        break;\n-                    default:\n-                        ret \u003d ((2.0 * n) - 1.0) - a + x;\n-                        break;\n-                }\n-                return ret;\n+                return ((2.0 * n) + 1.0) - a + x;\n             }\n \n             protected double getB(int n, double x) {\n-                double ret;\n-                double t;\n-                switch(n) {\n-                    case 1:\n-                        ret \u003d 1.0;\n-                        break;\n-                    default:\n-                        t \u003d n - 1.0;\n-                        ret \u003d t * (a - t);\n-                        break;\n-                }\n-                return ret;\n+                return n * (a - n);\n             }\n         };\n-        ret \u003d cf.evaluate(x, epsilon, maxIterations);\n+        ret \u003d 1.0 / cf.evaluate(x, epsilon, maxIterations);\n         ret \u003d Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * ret;\n     }\n     return ret;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a25f1e4515b215f4510088cd1787725479390b14": {
      "type": "Yintroduced",
      "commitMessage": "PR: 29419\nAdded an implementation of regularized gamma function, Q(a, x) \u003d 1 - P(a,x), based on a continued fraction.  This converges much faster for the large x case.  I added the example submitted by Scott as a test case and ran all the test cases with everything passing.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/math/trunk@141286 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "6/7/04, 1:30 PM",
      "commitName": "a25f1e4515b215f4510088cd1787725479390b14",
      "commitAuthor": "Brent Worden",
      "diff": "@@ -0,0 +1,44 @@\n+public static double regularizedGammaQ(final double a, double x, double epsilon, int maxIterations) throws MathException {\n+    double ret;\n+    if (Double.isNaN(a) || Double.isNaN(x) || (a \u003c\u003d 0.0) || (x \u003c 0.0)) {\n+        ret \u003d Double.NaN;\n+    } else if (x \u003d\u003d 0.0) {\n+        ret \u003d 1.0;\n+    } else if (x \u003c a || a \u003c\u003d 1.0) {\n+        ret \u003d 1.0 - regularizedGammaP(a, x, epsilon, maxIterations);\n+    } else {\n+        ContinuedFraction cf \u003d new ContinuedFraction() {\n+\n+            protected double getA(int n, double x) {\n+                double ret;\n+                switch(n) {\n+                    case 0:\n+                        ret \u003d 0.0;\n+                        break;\n+                    default:\n+                        ret \u003d ((2.0 * n) - 1.0) - a + x;\n+                        break;\n+                }\n+                return ret;\n+            }\n+\n+            protected double getB(int n, double x) {\n+                double ret;\n+                double t;\n+                switch(n) {\n+                    case 1:\n+                        ret \u003d 1.0;\n+                        break;\n+                    default:\n+                        t \u003d n - 1.0;\n+                        ret \u003d t * (a - t);\n+                        break;\n+                }\n+                return ret;\n+            }\n+        };\n+        ret \u003d cf.evaluate(x, epsilon, maxIterations);\n+        ret \u003d Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * ret;\n+    }\n+    return ret;\n+}\n\\ No newline at end of file\n",
      "actualSource": "public static double regularizedGammaQ(final double a, double x, double epsilon, int maxIterations) throws MathException {\n    double ret;\n    if (Double.isNaN(a) || Double.isNaN(x) || (a \u003c\u003d 0.0) || (x \u003c 0.0)) {\n        ret \u003d Double.NaN;\n    } else if (x \u003d\u003d 0.0) {\n        ret \u003d 1.0;\n    } else if (x \u003c a || a \u003c\u003d 1.0) {\n        ret \u003d 1.0 - regularizedGammaP(a, x, epsilon, maxIterations);\n    } else {\n        ContinuedFraction cf \u003d new ContinuedFraction() {\n\n            protected double getA(int n, double x) {\n                double ret;\n                switch(n) {\n                    case 0:\n                        ret \u003d 0.0;\n                        break;\n                    default:\n                        ret \u003d ((2.0 * n) - 1.0) - a + x;\n                        break;\n                }\n                return ret;\n            }\n\n            protected double getB(int n, double x) {\n                double ret;\n                double t;\n                switch(n) {\n                    case 1:\n                        ret \u003d 1.0;\n                        break;\n                    default:\n                        t \u003d n - 1.0;\n                        ret \u003d t * (a - t);\n                        break;\n                }\n                return ret;\n            }\n        };\n        ret \u003d cf.evaluate(x, epsilon, maxIterations);\n        ret \u003d Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * ret;\n    }\n    return ret;\n}",
      "path": "src/java/org/apache/commons/math/special/Gamma.java",
      "functionStartLine": 219,
      "functionName": "regularizedGammaQ",
      "functionAnnotation": "",
      "functionDoc": "Returns the regularized gamma function Q(a, x) \u003d 1 - P(a, x).\n\nThe implementation of this method is based on:\n\u003cul\u003e\n\u003cli\u003e\n\u003ca href\u003d\"http://mathworld.wolfram.com/RegularizedGammaFunction.html\"\u003e\nRegularized Gamma Function\u003c/a\u003e, equation (1).\u003c/li\u003e\n\u003cli\u003e\n\u003ca href\u003d\"    http://functions.wolfram.com/GammaBetaErf/GammaRegularized/10/0003/\"\u003e\nRegularized incomplete gamma function: Continued fraction representations  (formula 06.08.10.0003)\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n@param a the a parameter.\n@param x the value.\n@param epsilon When the absolute value of the nth item in the\n               series is less than epsilon the approximation ceases\n               to calculate further elements in the series.\n@param maxIterations Maximum number of \"iterations\" to complete.\n@return the regularized gamma function P(a, x)\n@throws MathException if the algorithm fails to converge.\n"
    }
  }
}