{
  "origin": "codeshovel",
  "repositoryName": "Closure-59b",
  "repositoryPath": "/tmp/Closure-59b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "PeepholeRemoveDeadCode.java",
  "functionName": "trySimplifyUnusedResult",
  "functionId": "trySimplifyUnusedResult___n-Node__removeUnused-boolean",
  "sourceFilePath": "src/com/google/javascript/jscomp/PeepholeRemoveDeadCode.java",
  "functionAnnotation": "",
  "functionDoc": "General cascading unused operation node removal.\n\n@param n The root of the expression to simplify.\n@param removeUnused If true, the node is removed from the AST if\n    it is not useful, otherwise it replaced with an EMPTY node.\n@return The replacement node, or null if the node was is not useful.\n",
  "functionStartLine": 169,
  "functionEndLine": 279,
  "numCommitsSeen": 49,
  "timeTaken": 2085,
  "changeHistory": [
    "fbaadc736f0031dd84bebea33abae497b47158cb",
    "48701cc70fde194c05ecd008fc1015b9d82921d1"
  ],
  "changeHistoryShort": {
    "fbaadc736f0031dd84bebea33abae497b47158cb": "Ymultichange(Yrename,Ybodychange)",
    "48701cc70fde194c05ecd008fc1015b9d82921d1": "Yintroduced"
  },
  "changeHistoryDetails": {
    "fbaadc736f0031dd84bebea33abae497b47158cb": {
      "type": "Ymultichange(Yrename,Ybodychange)",
      "commitMessage": "\nfix a mishandling of the void keyword\nalso fix a bunch of apis\nfixes issue 504\n\nR\u003djohnlenz\nDELTA\u003d126  (29 added, 0 deleted, 97 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d2506\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1248 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "7/6/11, 7:58 PM",
      "commitName": "fbaadc736f0031dd84bebea33abae497b47158cb",
      "commitAuthor": "nicksantos@google.com",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "\nfix a mishandling of the void keyword\nalso fix a bunch of apis\nfixes issue 504\n\nR\u003djohnlenz\nDELTA\u003d126  (29 added, 0 deleted, 97 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d2506\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1248 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "7/6/11, 7:58 PM",
          "commitName": "fbaadc736f0031dd84bebea33abae497b47158cb",
          "commitAuthor": "nicksantos@google.com",
          "commitDateOld": "7/6/11, 6:16 AM",
          "commitNameOld": "8d4d6cd2fd8b58826396e45d13463376455abc13",
          "commitAuthorOld": "zhuyi@google.com",
          "daysBetweenCommits": 0.57,
          "commitsBetweenForRepo": 3,
          "commitsBetweenForFile": 1,
          "actualSource": "private Node trySimplifyUnusedResult(Node n, boolean removeUnused) {\n    Node result \u003d n;\n    switch(n.getType()) {\n        case Token.HOOK:\n            Node trueNode \u003d trySimplifyUnusedResult(n.getFirstChild().getNext());\n            Node falseNode \u003d trySimplifyUnusedResult(n.getLastChild());\n            if (trueNode \u003d\u003d null \u0026\u0026 falseNode !\u003d null) {\n                n.setType(Token.OR);\n                Preconditions.checkState(n.getChildCount() \u003d\u003d 2);\n            } else if (trueNode !\u003d null \u0026\u0026 falseNode \u003d\u003d null) {\n                n.setType(Token.AND);\n                Preconditions.checkState(n.getChildCount() \u003d\u003d 2);\n            } else if (trueNode \u003d\u003d null \u0026\u0026 falseNode \u003d\u003d null) {\n                result \u003d trySimplifyUnusedResult(n.getFirstChild());\n            } else {\n                result \u003d n;\n            }\n            break;\n        case Token.AND:\n        case Token.OR:\n            Node conditionalResultNode \u003d trySimplifyUnusedResult(n.getLastChild());\n            if (conditionalResultNode \u003d\u003d null) {\n                Preconditions.checkState(n.hasOneChild());\n                result \u003d trySimplifyUnusedResult(n.getFirstChild());\n            }\n            break;\n        case Token.FUNCTION:\n            result \u003d null;\n            break;\n        case Token.COMMA:\n            Node left \u003d trySimplifyUnusedResult(n.getFirstChild());\n            Node right \u003d trySimplifyUnusedResult(n.getLastChild());\n            if (left \u003d\u003d null \u0026\u0026 right \u003d\u003d null) {\n                result \u003d null;\n            } else if (left \u003d\u003d null) {\n                result \u003d right;\n            } else if (right \u003d\u003d null) {\n                result \u003d left;\n            } else {\n                result \u003d n;\n            }\n            break;\n        default:\n            if (!NodeUtil.nodeTypeMayHaveSideEffects(n)) {\n                Node resultList \u003d null;\n                for (Node next, c \u003d n.getFirstChild(); c !\u003d null; c \u003d next) {\n                    next \u003d c.getNext();\n                    c \u003d trySimplifyUnusedResult(c);\n                    if (c !\u003d null) {\n                        c.detachFromParent();\n                        if (resultList \u003d\u003d null) {\n                            resultList \u003d c;\n                        } else {\n                            resultList \u003d new Node(Token.COMMA, resultList, c).copyInformationFrom(c);\n                        }\n                    }\n                }\n                result \u003d resultList;\n            }\n    }\n    if (n !\u003d result) {\n        Node parent \u003d n.getParent();\n        if (result \u003d\u003d null) {\n            if (removeUnused) {\n                parent.removeChild(n);\n            } else {\n                result \u003d new Node(Token.EMPTY).copyInformationFrom(n);\n                parent.replaceChild(n, result);\n            }\n        } else {\n            if (result.getParent() !\u003d null) {\n                result.detachFromParent();\n            }\n            n.getParent().replaceChild(n, result);\n        }\n        reportCodeChange();\n    }\n    return result;\n}",
          "path": "src/com/google/javascript/jscomp/PeepholeRemoveDeadCode.java",
          "functionStartLine": 169,
          "functionName": "trySimplifyUnusedResult",
          "functionAnnotation": "",
          "functionDoc": "General cascading unused operation node removal.\n\n@param n The root of the expression to simplify.\n@param removeUnused If true, the node is removed from the AST if\n    it is not useful, otherwise it replaced with an EMPTY node.\n@return The replacement node, or null if the node was is not useful.\n",
          "diff": "@@ -1,79 +1,79 @@\n-private Node trySimpilifyUnusedResult(Node n, boolean removeUnused) {\n+private Node trySimplifyUnusedResult(Node n, boolean removeUnused) {\n     Node result \u003d n;\n     switch(n.getType()) {\n         case Token.HOOK:\n-            Node trueNode \u003d trySimpilifyUnusedResult(n.getFirstChild().getNext());\n-            Node falseNode \u003d trySimpilifyUnusedResult(n.getLastChild());\n+            Node trueNode \u003d trySimplifyUnusedResult(n.getFirstChild().getNext());\n+            Node falseNode \u003d trySimplifyUnusedResult(n.getLastChild());\n             if (trueNode \u003d\u003d null \u0026\u0026 falseNode !\u003d null) {\n                 n.setType(Token.OR);\n                 Preconditions.checkState(n.getChildCount() \u003d\u003d 2);\n             } else if (trueNode !\u003d null \u0026\u0026 falseNode \u003d\u003d null) {\n                 n.setType(Token.AND);\n                 Preconditions.checkState(n.getChildCount() \u003d\u003d 2);\n             } else if (trueNode \u003d\u003d null \u0026\u0026 falseNode \u003d\u003d null) {\n-                result \u003d trySimpilifyUnusedResult(n.getFirstChild());\n+                result \u003d trySimplifyUnusedResult(n.getFirstChild());\n             } else {\n                 result \u003d n;\n             }\n             break;\n         case Token.AND:\n         case Token.OR:\n-            Node conditionalResultNode \u003d trySimpilifyUnusedResult(n.getLastChild());\n+            Node conditionalResultNode \u003d trySimplifyUnusedResult(n.getLastChild());\n             if (conditionalResultNode \u003d\u003d null) {\n                 Preconditions.checkState(n.hasOneChild());\n-                result \u003d trySimpilifyUnusedResult(n.getFirstChild());\n+                result \u003d trySimplifyUnusedResult(n.getFirstChild());\n             }\n             break;\n         case Token.FUNCTION:\n             result \u003d null;\n             break;\n         case Token.COMMA:\n-            Node left \u003d trySimpilifyUnusedResult(n.getFirstChild());\n-            Node right \u003d trySimpilifyUnusedResult(n.getLastChild());\n+            Node left \u003d trySimplifyUnusedResult(n.getFirstChild());\n+            Node right \u003d trySimplifyUnusedResult(n.getLastChild());\n             if (left \u003d\u003d null \u0026\u0026 right \u003d\u003d null) {\n                 result \u003d null;\n             } else if (left \u003d\u003d null) {\n                 result \u003d right;\n             } else if (right \u003d\u003d null) {\n                 result \u003d left;\n             } else {\n                 result \u003d n;\n             }\n             break;\n         default:\n             if (!NodeUtil.nodeTypeMayHaveSideEffects(n)) {\n                 Node resultList \u003d null;\n                 for (Node next, c \u003d n.getFirstChild(); c !\u003d null; c \u003d next) {\n                     next \u003d c.getNext();\n-                    c \u003d trySimpilifyUnusedResult(c);\n+                    c \u003d trySimplifyUnusedResult(c);\n                     if (c !\u003d null) {\n                         c.detachFromParent();\n                         if (resultList \u003d\u003d null) {\n                             resultList \u003d c;\n                         } else {\n                             resultList \u003d new Node(Token.COMMA, resultList, c).copyInformationFrom(c);\n                         }\n                     }\n                 }\n                 result \u003d resultList;\n             }\n     }\n     if (n !\u003d result) {\n         Node parent \u003d n.getParent();\n         if (result \u003d\u003d null) {\n             if (removeUnused) {\n                 parent.removeChild(n);\n             } else {\n                 result \u003d new Node(Token.EMPTY).copyInformationFrom(n);\n                 parent.replaceChild(n, result);\n             }\n         } else {\n             if (result.getParent() !\u003d null) {\n                 result.detachFromParent();\n             }\n             n.getParent().replaceChild(n, result);\n         }\n         reportCodeChange();\n     }\n     return result;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "trySimpilifyUnusedResult",
            "newValue": "trySimplifyUnusedResult"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "\nfix a mishandling of the void keyword\nalso fix a bunch of apis\nfixes issue 504\n\nR\u003djohnlenz\nDELTA\u003d126  (29 added, 0 deleted, 97 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d2506\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1248 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
          "commitDate": "7/6/11, 7:58 PM",
          "commitName": "fbaadc736f0031dd84bebea33abae497b47158cb",
          "commitAuthor": "nicksantos@google.com",
          "commitDateOld": "7/6/11, 6:16 AM",
          "commitNameOld": "8d4d6cd2fd8b58826396e45d13463376455abc13",
          "commitAuthorOld": "zhuyi@google.com",
          "daysBetweenCommits": 0.57,
          "commitsBetweenForRepo": 3,
          "commitsBetweenForFile": 1,
          "actualSource": "private Node trySimplifyUnusedResult(Node n, boolean removeUnused) {\n    Node result \u003d n;\n    switch(n.getType()) {\n        case Token.HOOK:\n            Node trueNode \u003d trySimplifyUnusedResult(n.getFirstChild().getNext());\n            Node falseNode \u003d trySimplifyUnusedResult(n.getLastChild());\n            if (trueNode \u003d\u003d null \u0026\u0026 falseNode !\u003d null) {\n                n.setType(Token.OR);\n                Preconditions.checkState(n.getChildCount() \u003d\u003d 2);\n            } else if (trueNode !\u003d null \u0026\u0026 falseNode \u003d\u003d null) {\n                n.setType(Token.AND);\n                Preconditions.checkState(n.getChildCount() \u003d\u003d 2);\n            } else if (trueNode \u003d\u003d null \u0026\u0026 falseNode \u003d\u003d null) {\n                result \u003d trySimplifyUnusedResult(n.getFirstChild());\n            } else {\n                result \u003d n;\n            }\n            break;\n        case Token.AND:\n        case Token.OR:\n            Node conditionalResultNode \u003d trySimplifyUnusedResult(n.getLastChild());\n            if (conditionalResultNode \u003d\u003d null) {\n                Preconditions.checkState(n.hasOneChild());\n                result \u003d trySimplifyUnusedResult(n.getFirstChild());\n            }\n            break;\n        case Token.FUNCTION:\n            result \u003d null;\n            break;\n        case Token.COMMA:\n            Node left \u003d trySimplifyUnusedResult(n.getFirstChild());\n            Node right \u003d trySimplifyUnusedResult(n.getLastChild());\n            if (left \u003d\u003d null \u0026\u0026 right \u003d\u003d null) {\n                result \u003d null;\n            } else if (left \u003d\u003d null) {\n                result \u003d right;\n            } else if (right \u003d\u003d null) {\n                result \u003d left;\n            } else {\n                result \u003d n;\n            }\n            break;\n        default:\n            if (!NodeUtil.nodeTypeMayHaveSideEffects(n)) {\n                Node resultList \u003d null;\n                for (Node next, c \u003d n.getFirstChild(); c !\u003d null; c \u003d next) {\n                    next \u003d c.getNext();\n                    c \u003d trySimplifyUnusedResult(c);\n                    if (c !\u003d null) {\n                        c.detachFromParent();\n                        if (resultList \u003d\u003d null) {\n                            resultList \u003d c;\n                        } else {\n                            resultList \u003d new Node(Token.COMMA, resultList, c).copyInformationFrom(c);\n                        }\n                    }\n                }\n                result \u003d resultList;\n            }\n    }\n    if (n !\u003d result) {\n        Node parent \u003d n.getParent();\n        if (result \u003d\u003d null) {\n            if (removeUnused) {\n                parent.removeChild(n);\n            } else {\n                result \u003d new Node(Token.EMPTY).copyInformationFrom(n);\n                parent.replaceChild(n, result);\n            }\n        } else {\n            if (result.getParent() !\u003d null) {\n                result.detachFromParent();\n            }\n            n.getParent().replaceChild(n, result);\n        }\n        reportCodeChange();\n    }\n    return result;\n}",
          "path": "src/com/google/javascript/jscomp/PeepholeRemoveDeadCode.java",
          "functionStartLine": 169,
          "functionName": "trySimplifyUnusedResult",
          "functionAnnotation": "",
          "functionDoc": "General cascading unused operation node removal.\n\n@param n The root of the expression to simplify.\n@param removeUnused If true, the node is removed from the AST if\n    it is not useful, otherwise it replaced with an EMPTY node.\n@return The replacement node, or null if the node was is not useful.\n",
          "diff": "@@ -1,79 +1,79 @@\n-private Node trySimpilifyUnusedResult(Node n, boolean removeUnused) {\n+private Node trySimplifyUnusedResult(Node n, boolean removeUnused) {\n     Node result \u003d n;\n     switch(n.getType()) {\n         case Token.HOOK:\n-            Node trueNode \u003d trySimpilifyUnusedResult(n.getFirstChild().getNext());\n-            Node falseNode \u003d trySimpilifyUnusedResult(n.getLastChild());\n+            Node trueNode \u003d trySimplifyUnusedResult(n.getFirstChild().getNext());\n+            Node falseNode \u003d trySimplifyUnusedResult(n.getLastChild());\n             if (trueNode \u003d\u003d null \u0026\u0026 falseNode !\u003d null) {\n                 n.setType(Token.OR);\n                 Preconditions.checkState(n.getChildCount() \u003d\u003d 2);\n             } else if (trueNode !\u003d null \u0026\u0026 falseNode \u003d\u003d null) {\n                 n.setType(Token.AND);\n                 Preconditions.checkState(n.getChildCount() \u003d\u003d 2);\n             } else if (trueNode \u003d\u003d null \u0026\u0026 falseNode \u003d\u003d null) {\n-                result \u003d trySimpilifyUnusedResult(n.getFirstChild());\n+                result \u003d trySimplifyUnusedResult(n.getFirstChild());\n             } else {\n                 result \u003d n;\n             }\n             break;\n         case Token.AND:\n         case Token.OR:\n-            Node conditionalResultNode \u003d trySimpilifyUnusedResult(n.getLastChild());\n+            Node conditionalResultNode \u003d trySimplifyUnusedResult(n.getLastChild());\n             if (conditionalResultNode \u003d\u003d null) {\n                 Preconditions.checkState(n.hasOneChild());\n-                result \u003d trySimpilifyUnusedResult(n.getFirstChild());\n+                result \u003d trySimplifyUnusedResult(n.getFirstChild());\n             }\n             break;\n         case Token.FUNCTION:\n             result \u003d null;\n             break;\n         case Token.COMMA:\n-            Node left \u003d trySimpilifyUnusedResult(n.getFirstChild());\n-            Node right \u003d trySimpilifyUnusedResult(n.getLastChild());\n+            Node left \u003d trySimplifyUnusedResult(n.getFirstChild());\n+            Node right \u003d trySimplifyUnusedResult(n.getLastChild());\n             if (left \u003d\u003d null \u0026\u0026 right \u003d\u003d null) {\n                 result \u003d null;\n             } else if (left \u003d\u003d null) {\n                 result \u003d right;\n             } else if (right \u003d\u003d null) {\n                 result \u003d left;\n             } else {\n                 result \u003d n;\n             }\n             break;\n         default:\n             if (!NodeUtil.nodeTypeMayHaveSideEffects(n)) {\n                 Node resultList \u003d null;\n                 for (Node next, c \u003d n.getFirstChild(); c !\u003d null; c \u003d next) {\n                     next \u003d c.getNext();\n-                    c \u003d trySimpilifyUnusedResult(c);\n+                    c \u003d trySimplifyUnusedResult(c);\n                     if (c !\u003d null) {\n                         c.detachFromParent();\n                         if (resultList \u003d\u003d null) {\n                             resultList \u003d c;\n                         } else {\n                             resultList \u003d new Node(Token.COMMA, resultList, c).copyInformationFrom(c);\n                         }\n                     }\n                 }\n                 result \u003d resultList;\n             }\n     }\n     if (n !\u003d result) {\n         Node parent \u003d n.getParent();\n         if (result \u003d\u003d null) {\n             if (removeUnused) {\n                 parent.removeChild(n);\n             } else {\n                 result \u003d new Node(Token.EMPTY).copyInformationFrom(n);\n                 parent.replaceChild(n, result);\n             }\n         } else {\n             if (result.getParent() !\u003d null) {\n                 result.detachFromParent();\n             }\n             n.getParent().replaceChild(n, result);\n         }\n         reportCodeChange();\n     }\n     return result;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "48701cc70fde194c05ecd008fc1015b9d82921d1": {
      "type": "Yintroduced",
      "commitMessage": "\n- Generalize unused operation removal and remove a couple of special cases (HOOK, NOT).\n- Add handling for other AST locations that can have unused ops removed (COMMA lhs and FOR increment expressions).\n\nR\u003dacleung\nDELTA\u003d358  (260 added, 80 deleted, 18 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d197245\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@390 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "8/27/10, 3:09 PM",
      "commitName": "48701cc70fde194c05ecd008fc1015b9d82921d1",
      "commitAuthor": "johnlenz@google.com",
      "diff": "@@ -0,0 +1,79 @@\n+private Node trySimpilifyUnusedResult(Node n, boolean removeUnused) {\n+    Node result \u003d n;\n+    switch(n.getType()) {\n+        case Token.HOOK:\n+            Node trueNode \u003d trySimpilifyUnusedResult(n.getFirstChild().getNext());\n+            Node falseNode \u003d trySimpilifyUnusedResult(n.getLastChild());\n+            if (trueNode \u003d\u003d null \u0026\u0026 falseNode !\u003d null) {\n+                n.setType(Token.OR);\n+                Preconditions.checkState(n.getChildCount() \u003d\u003d 2);\n+            } else if (trueNode !\u003d null \u0026\u0026 falseNode \u003d\u003d null) {\n+                n.setType(Token.AND);\n+                Preconditions.checkState(n.getChildCount() \u003d\u003d 2);\n+            } else if (trueNode \u003d\u003d null \u0026\u0026 falseNode \u003d\u003d null) {\n+                result \u003d trySimpilifyUnusedResult(n.getFirstChild());\n+            } else {\n+                result \u003d n;\n+            }\n+            break;\n+        case Token.AND:\n+        case Token.OR:\n+            Node conditionalResultNode \u003d trySimpilifyUnusedResult(n.getLastChild());\n+            if (conditionalResultNode \u003d\u003d null) {\n+                Preconditions.checkState(n.hasOneChild());\n+                result \u003d trySimpilifyUnusedResult(n.getFirstChild());\n+            }\n+            break;\n+        case Token.FUNCTION:\n+            result \u003d null;\n+            break;\n+        case Token.COMMA:\n+            Node left \u003d trySimpilifyUnusedResult(n.getFirstChild());\n+            Node right \u003d trySimpilifyUnusedResult(n.getLastChild());\n+            if (left \u003d\u003d null \u0026\u0026 right \u003d\u003d null) {\n+                result \u003d null;\n+            } else if (left \u003d\u003d null) {\n+                result \u003d right;\n+            } else if (right \u003d\u003d null) {\n+                result \u003d left;\n+            } else {\n+                result \u003d n;\n+            }\n+            break;\n+        default:\n+            if (!NodeUtil.nodeTypeMayHaveSideEffects(n)) {\n+                Node resultList \u003d null;\n+                for (Node next, c \u003d n.getFirstChild(); c !\u003d null; c \u003d next) {\n+                    next \u003d c.getNext();\n+                    c \u003d trySimpilifyUnusedResult(c);\n+                    if (c !\u003d null) {\n+                        c.detachFromParent();\n+                        if (resultList \u003d\u003d null) {\n+                            resultList \u003d c;\n+                        } else {\n+                            resultList \u003d new Node(Token.COMMA, resultList, c).copyInformationFrom(c);\n+                        }\n+                    }\n+                }\n+                result \u003d resultList;\n+            }\n+    }\n+    if (n !\u003d result) {\n+        Node parent \u003d n.getParent();\n+        if (result \u003d\u003d null) {\n+            if (removeUnused) {\n+                parent.removeChild(n);\n+            } else {\n+                result \u003d new Node(Token.EMPTY).copyInformationFrom(n);\n+                parent.replaceChild(n, result);\n+            }\n+        } else {\n+            if (result.getParent() !\u003d null) {\n+                result.detachFromParent();\n+            }\n+            n.getParent().replaceChild(n, result);\n+        }\n+        reportCodeChange();\n+    }\n+    return result;\n+}\n\\ No newline at end of file\n",
      "actualSource": "private Node trySimpilifyUnusedResult(Node n, boolean removeUnused) {\n    Node result \u003d n;\n    switch(n.getType()) {\n        case Token.HOOK:\n            Node trueNode \u003d trySimpilifyUnusedResult(n.getFirstChild().getNext());\n            Node falseNode \u003d trySimpilifyUnusedResult(n.getLastChild());\n            if (trueNode \u003d\u003d null \u0026\u0026 falseNode !\u003d null) {\n                n.setType(Token.OR);\n                Preconditions.checkState(n.getChildCount() \u003d\u003d 2);\n            } else if (trueNode !\u003d null \u0026\u0026 falseNode \u003d\u003d null) {\n                n.setType(Token.AND);\n                Preconditions.checkState(n.getChildCount() \u003d\u003d 2);\n            } else if (trueNode \u003d\u003d null \u0026\u0026 falseNode \u003d\u003d null) {\n                result \u003d trySimpilifyUnusedResult(n.getFirstChild());\n            } else {\n                result \u003d n;\n            }\n            break;\n        case Token.AND:\n        case Token.OR:\n            Node conditionalResultNode \u003d trySimpilifyUnusedResult(n.getLastChild());\n            if (conditionalResultNode \u003d\u003d null) {\n                Preconditions.checkState(n.hasOneChild());\n                result \u003d trySimpilifyUnusedResult(n.getFirstChild());\n            }\n            break;\n        case Token.FUNCTION:\n            result \u003d null;\n            break;\n        case Token.COMMA:\n            Node left \u003d trySimpilifyUnusedResult(n.getFirstChild());\n            Node right \u003d trySimpilifyUnusedResult(n.getLastChild());\n            if (left \u003d\u003d null \u0026\u0026 right \u003d\u003d null) {\n                result \u003d null;\n            } else if (left \u003d\u003d null) {\n                result \u003d right;\n            } else if (right \u003d\u003d null) {\n                result \u003d left;\n            } else {\n                result \u003d n;\n            }\n            break;\n        default:\n            if (!NodeUtil.nodeTypeMayHaveSideEffects(n)) {\n                Node resultList \u003d null;\n                for (Node next, c \u003d n.getFirstChild(); c !\u003d null; c \u003d next) {\n                    next \u003d c.getNext();\n                    c \u003d trySimpilifyUnusedResult(c);\n                    if (c !\u003d null) {\n                        c.detachFromParent();\n                        if (resultList \u003d\u003d null) {\n                            resultList \u003d c;\n                        } else {\n                            resultList \u003d new Node(Token.COMMA, resultList, c).copyInformationFrom(c);\n                        }\n                    }\n                }\n                result \u003d resultList;\n            }\n    }\n    if (n !\u003d result) {\n        Node parent \u003d n.getParent();\n        if (result \u003d\u003d null) {\n            if (removeUnused) {\n                parent.removeChild(n);\n            } else {\n                result \u003d new Node(Token.EMPTY).copyInformationFrom(n);\n                parent.replaceChild(n, result);\n            }\n        } else {\n            if (result.getParent() !\u003d null) {\n                result.detachFromParent();\n            }\n            n.getParent().replaceChild(n, result);\n        }\n        reportCodeChange();\n    }\n    return result;\n}",
      "path": "src/com/google/javascript/jscomp/PeepholeRemoveDeadCode.java",
      "functionStartLine": 106,
      "functionName": "trySimpilifyUnusedResult",
      "functionAnnotation": "",
      "functionDoc": "General cascading unused operation node removal.\n\n@param n The root of the expression to simplify.\n@param removeUnused If true, the node is removed from the AST if\n    it is not useful, otherwise it replaced with an EMPTY node.\n@return The replacement node, or null if the node was is not useful.\n"
    }
  }
}