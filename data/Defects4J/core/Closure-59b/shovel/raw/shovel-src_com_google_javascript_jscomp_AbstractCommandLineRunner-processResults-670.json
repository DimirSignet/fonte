{
  "origin": "codeshovel",
  "repositoryName": "Closure-59b",
  "repositoryPath": "/tmp/Closure-59b//.git",
  "startCommitName": "HEAD",
  "sourceFileName": "AbstractCommandLineRunner.java",
  "functionName": "processResults",
  "functionId": "processResults___result-Result__modules-List__JSModule____options-B",
  "sourceFilePath": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
  "functionAnnotation": "",
  "functionDoc": "Processes the results of the compile job, and returns an error code.\n",
  "functionStartLine": 670,
  "functionEndLine": 788,
  "numCommitsSeen": 91,
  "timeTaken": 4228,
  "changeHistory": [
    "ab9dfefc6f8799aa4e8f69d4e4e52d055152b25a",
    "1a400824eb5299485e84d40698d811c4e284511e",
    "d6ac4fe53569b1415f66db221d7511c74f4a965b",
    "3e42e575f21275d2d0f8196f2f22b4ea06995d5b",
    "36a890d0dd7911a5a1b8e1682435945972a05cdc",
    "4b5d62920ef4606fd30dfa42eb72df2785415533",
    "4cede4f156740b7ce93d92d824066e9a42257541",
    "61b5204064333144810c184d38b4dc78f947bd62",
    "82a9956c6337d2f5d4a94ebe624d64faa54d9182",
    "6a94702f5cf769973528adc8b3dc3e9cf56277c8",
    "260f0ffc9243ef15bd17e324c9cf7e2dfac9cc6a",
    "97bbbffb65eda01aa9b38a5cec43a598afb39070",
    "c080c668a4ccd9eb151cbb4f90980ddbbfbaba44",
    "848ace840362a1f5558bec065cb40548ff66587a",
    "c0face2a48665e46f4829f54ee24cfa4cf8d4589",
    "bca9abb0e3062d373fe52c0e8340337588c05708",
    "915752b8e4ffd312eea298fb749dddd0edc0db2e"
  ],
  "changeHistoryShort": {
    "ab9dfefc6f8799aa4e8f69d4e4e52d055152b25a": "Ybodychange",
    "1a400824eb5299485e84d40698d811c4e284511e": "Ybodychange",
    "d6ac4fe53569b1415f66db221d7511c74f4a965b": "Ybodychange",
    "3e42e575f21275d2d0f8196f2f22b4ea06995d5b": "Yformatchange",
    "36a890d0dd7911a5a1b8e1682435945972a05cdc": "Ybodychange",
    "4b5d62920ef4606fd30dfa42eb72df2785415533": "Ybodychange",
    "4cede4f156740b7ce93d92d824066e9a42257541": "Ybodychange",
    "61b5204064333144810c184d38b4dc78f947bd62": "Yparameterchange",
    "82a9956c6337d2f5d4a94ebe624d64faa54d9182": "Ybodychange",
    "6a94702f5cf769973528adc8b3dc3e9cf56277c8": "Ybodychange",
    "260f0ffc9243ef15bd17e324c9cf7e2dfac9cc6a": "Ybodychange",
    "97bbbffb65eda01aa9b38a5cec43a598afb39070": "Ybodychange",
    "c080c668a4ccd9eb151cbb4f90980ddbbfbaba44": "Ybodychange",
    "848ace840362a1f5558bec065cb40548ff66587a": "Yfilerename",
    "c0face2a48665e46f4829f54ee24cfa4cf8d4589": "Ybodychange",
    "bca9abb0e3062d373fe52c0e8340337588c05708": "Ybodychange",
    "915752b8e4ffd312eea298fb749dddd0edc0db2e": "Yintroduced"
  },
  "changeHistoryDetails": {
    "ab9dfefc6f8799aa4e8f69d4e4e52d055152b25a": {
      "type": "Ybodychange",
      "commitMessage": "\nCreate -output_bundle flag for JSCompiler to generate bundle files\n\nR\u003dnicksantos\nDELTA\u003d223  (156 added, 7 deleted, 60 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d2369\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1198 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "6/21/11, 3:09 PM",
      "commitName": "ab9dfefc6f8799aa4e8f69d4e4e52d055152b25a",
      "commitAuthor": "zhuyi@google.com",
      "commitDateOld": "6/14/11, 10:53 AM",
      "commitNameOld": "48cccf202b6cd853409e169d98918462f91301a8",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 7.18,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "actualSource": "int processResults(Result result, List\u003cJSModule\u003e modules, B options) throws FlagUsageException, IOException {\n    if (config.computePhaseOrdering) {\n        return 0;\n    }\n    if (config.printPassGraph) {\n        if (compiler.getRoot() \u003d\u003d null) {\n            return 1;\n        } else {\n            jsOutput.append(DotFormatter.toDot(compiler.getPassConfig().getPassGraph()));\n            jsOutput.append(\u0027\\n\u0027);\n            return 0;\n        }\n    }\n    if (config.printAst) {\n        if (compiler.getRoot() \u003d\u003d null) {\n            return 1;\n        } else {\n            ControlFlowGraph\u003cNode\u003e cfg \u003d compiler.computeCFG();\n            DotFormatter.appendDot(compiler.getRoot().getLastChild(), cfg, jsOutput);\n            jsOutput.append(\u0027\\n\u0027);\n            return 0;\n        }\n    }\n    if (config.printTree) {\n        if (compiler.getRoot() \u003d\u003d null) {\n            jsOutput.append(\"Code contains errors; no tree was generated.\\n\");\n            return 1;\n        } else {\n            compiler.getRoot().appendStringTree(jsOutput);\n            jsOutput.append(\"\\n\");\n            return 0;\n        }\n    }\n    if (config.skipNormalOutputs) {\n        outputManifest();\n        outputBundle();\n        return 0;\n    } else if (result.success) {\n        if (modules \u003d\u003d null) {\n            writeOutput(jsOutput, compiler, compiler.toSource(), config.outputWrapper, OUTPUT_WRAPPER_MARKER);\n            outputSourceMap(options);\n        } else {\n            String moduleFilePrefix \u003d config.moduleOutputPathPrefix;\n            maybeCreateDirsForPath(moduleFilePrefix);\n            Map\u003cString, String\u003e moduleWrappers \u003d parseModuleWrappers(config.moduleWrapper, modules);\n            Writer mapOut \u003d null;\n            if (!shouldGenerateMapPerModule(options)) {\n                mapOut \u003d fileNameToOutputWriter(expandSourceMapPath(options, null));\n            }\n            for (JSModule m : modules) {\n                if (shouldGenerateMapPerModule(options)) {\n                    mapOut \u003d fileNameToOutputWriter(expandSourceMapPath(options, m));\n                }\n                Writer writer \u003d fileNameToOutputWriter(moduleFilePrefix + m.getName() + \".js\");\n                if (options.sourceMapOutputPath !\u003d null) {\n                    compiler.getSourceMap().reset();\n                }\n                writeOutput(writer, compiler, compiler.toSource(m), moduleWrappers.get(m.getName()), \"%s\");\n                if (options.sourceMapOutputPath !\u003d null) {\n                    compiler.getSourceMap().appendTo(mapOut, m.getName());\n                }\n                writer.close();\n                if (shouldGenerateMapPerModule(options) \u0026\u0026 mapOut !\u003d null) {\n                    mapOut.close();\n                    mapOut \u003d null;\n                }\n            }\n            if (mapOut !\u003d null) {\n                mapOut.close();\n            }\n        }\n        if (options.externExportsPath !\u003d null) {\n            Writer eeOut \u003d openExternExportsStream(options, options.jsOutputFile);\n            eeOut.append(result.externExport);\n            eeOut.close();\n        }\n        outputNameMaps(options);\n        outputManifest();\n        outputBundle();\n    }\n    return Math.min(result.errors.length, 0x7f);\n}",
      "path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
      "functionStartLine": 670,
      "functionName": "processResults",
      "functionAnnotation": "",
      "functionDoc": "Processes the results of the compile job, and returns an error code.\n",
      "diff": "@@ -1,80 +1,82 @@\n int processResults(Result result, List\u003cJSModule\u003e modules, B options) throws FlagUsageException, IOException {\n     if (config.computePhaseOrdering) {\n         return 0;\n     }\n     if (config.printPassGraph) {\n         if (compiler.getRoot() \u003d\u003d null) {\n             return 1;\n         } else {\n             jsOutput.append(DotFormatter.toDot(compiler.getPassConfig().getPassGraph()));\n             jsOutput.append(\u0027\\n\u0027);\n             return 0;\n         }\n     }\n     if (config.printAst) {\n         if (compiler.getRoot() \u003d\u003d null) {\n             return 1;\n         } else {\n             ControlFlowGraph\u003cNode\u003e cfg \u003d compiler.computeCFG();\n             DotFormatter.appendDot(compiler.getRoot().getLastChild(), cfg, jsOutput);\n             jsOutput.append(\u0027\\n\u0027);\n             return 0;\n         }\n     }\n     if (config.printTree) {\n         if (compiler.getRoot() \u003d\u003d null) {\n             jsOutput.append(\"Code contains errors; no tree was generated.\\n\");\n             return 1;\n         } else {\n             compiler.getRoot().appendStringTree(jsOutput);\n             jsOutput.append(\"\\n\");\n             return 0;\n         }\n     }\n     if (config.skipNormalOutputs) {\n         outputManifest();\n+        outputBundle();\n         return 0;\n     } else if (result.success) {\n         if (modules \u003d\u003d null) {\n             writeOutput(jsOutput, compiler, compiler.toSource(), config.outputWrapper, OUTPUT_WRAPPER_MARKER);\n             outputSourceMap(options);\n         } else {\n             String moduleFilePrefix \u003d config.moduleOutputPathPrefix;\n             maybeCreateDirsForPath(moduleFilePrefix);\n             Map\u003cString, String\u003e moduleWrappers \u003d parseModuleWrappers(config.moduleWrapper, modules);\n             Writer mapOut \u003d null;\n             if (!shouldGenerateMapPerModule(options)) {\n                 mapOut \u003d fileNameToOutputWriter(expandSourceMapPath(options, null));\n             }\n             for (JSModule m : modules) {\n                 if (shouldGenerateMapPerModule(options)) {\n                     mapOut \u003d fileNameToOutputWriter(expandSourceMapPath(options, m));\n                 }\n                 Writer writer \u003d fileNameToOutputWriter(moduleFilePrefix + m.getName() + \".js\");\n                 if (options.sourceMapOutputPath !\u003d null) {\n                     compiler.getSourceMap().reset();\n                 }\n                 writeOutput(writer, compiler, compiler.toSource(m), moduleWrappers.get(m.getName()), \"%s\");\n                 if (options.sourceMapOutputPath !\u003d null) {\n                     compiler.getSourceMap().appendTo(mapOut, m.getName());\n                 }\n                 writer.close();\n                 if (shouldGenerateMapPerModule(options) \u0026\u0026 mapOut !\u003d null) {\n                     mapOut.close();\n                     mapOut \u003d null;\n                 }\n             }\n             if (mapOut !\u003d null) {\n                 mapOut.close();\n             }\n         }\n         if (options.externExportsPath !\u003d null) {\n             Writer eeOut \u003d openExternExportsStream(options, options.jsOutputFile);\n             eeOut.append(result.externExport);\n             eeOut.close();\n         }\n         outputNameMaps(options);\n         outputManifest();\n+        outputBundle();\n     }\n     return Math.min(result.errors.length, 0x7f);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1a400824eb5299485e84d40698d811c4e284511e": {
      "type": "Ybodychange",
      "commitMessage": "\nAdd skip_normal_outputs to do dummy compilation (initialize modules and check dependency), used when we want to generate MF/bundle files but compile \u003d 0\n\nR\u003dnicksantos\nDELTA\u003d151  (144 added, 1 deleted, 6 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d2254\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@1175 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "6/13/11, 11:04 AM",
      "commitName": "1a400824eb5299485e84d40698d811c4e284511e",
      "commitAuthor": "zhuyi@google.com",
      "commitDateOld": "5/18/11, 12:14 PM",
      "commitNameOld": "e4e139965fccdb7dbe55d04151fa4305bb4bac48",
      "commitAuthorOld": "rsturgell@google.com",
      "daysBetweenCommits": 25.95,
      "commitsBetweenForRepo": 60,
      "commitsBetweenForFile": 1,
      "actualSource": "int processResults(Result result, List\u003cJSModule\u003e modules, B options) throws FlagUsageException, IOException {\n    if (config.computePhaseOrdering) {\n        return 0;\n    }\n    if (config.printPassGraph) {\n        if (compiler.getRoot() \u003d\u003d null) {\n            return 1;\n        } else {\n            jsOutput.append(DotFormatter.toDot(compiler.getPassConfig().getPassGraph()));\n            jsOutput.append(\u0027\\n\u0027);\n            return 0;\n        }\n    }\n    if (config.printAst) {\n        if (compiler.getRoot() \u003d\u003d null) {\n            return 1;\n        } else {\n            ControlFlowGraph\u003cNode\u003e cfg \u003d compiler.computeCFG();\n            DotFormatter.appendDot(compiler.getRoot().getLastChild(), cfg, jsOutput);\n            jsOutput.append(\u0027\\n\u0027);\n            return 0;\n        }\n    }\n    if (config.printTree) {\n        if (compiler.getRoot() \u003d\u003d null) {\n            jsOutput.append(\"Code contains errors; no tree was generated.\\n\");\n            return 1;\n        } else {\n            compiler.getRoot().appendStringTree(jsOutput);\n            jsOutput.append(\"\\n\");\n            return 0;\n        }\n    }\n    if (config.skipNormalOutputs) {\n        outputManifest();\n        return 0;\n    } else if (result.success) {\n        if (modules \u003d\u003d null) {\n            writeOutput(jsOutput, compiler, compiler.toSource(), config.outputWrapper, OUTPUT_WRAPPER_MARKER);\n            outputSourceMap(options);\n        } else {\n            String moduleFilePrefix \u003d config.moduleOutputPathPrefix;\n            maybeCreateDirsForPath(moduleFilePrefix);\n            Map\u003cString, String\u003e moduleWrappers \u003d parseModuleWrappers(config.moduleWrapper, modules);\n            Writer mapOut \u003d null;\n            if (!shouldGenerateMapPerModule(options)) {\n                mapOut \u003d fileNameToOutputWriter(expandSourceMapPath(options, null));\n            }\n            for (JSModule m : modules) {\n                if (shouldGenerateMapPerModule(options)) {\n                    mapOut \u003d fileNameToOutputWriter(expandSourceMapPath(options, m));\n                }\n                Writer writer \u003d fileNameToOutputWriter(moduleFilePrefix + m.getName() + \".js\");\n                if (options.sourceMapOutputPath !\u003d null) {\n                    compiler.getSourceMap().reset();\n                }\n                writeOutput(writer, compiler, compiler.toSource(m), moduleWrappers.get(m.getName()), \"%s\");\n                if (options.sourceMapOutputPath !\u003d null) {\n                    compiler.getSourceMap().appendTo(mapOut, m.getName());\n                }\n                writer.close();\n                if (shouldGenerateMapPerModule(options) \u0026\u0026 mapOut !\u003d null) {\n                    mapOut.close();\n                    mapOut \u003d null;\n                }\n            }\n            if (mapOut !\u003d null) {\n                mapOut.close();\n            }\n        }\n        if (options.externExportsPath !\u003d null) {\n            Writer eeOut \u003d openExternExportsStream(options, options.jsOutputFile);\n            eeOut.append(result.externExport);\n            eeOut.close();\n        }\n        outputNameMaps(options);\n        outputManifest();\n    }\n    return Math.min(result.errors.length, 0x7f);\n}",
      "path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
      "functionStartLine": 669,
      "functionName": "processResults",
      "functionAnnotation": "",
      "functionDoc": "Processes the results of the compile job, and returns an error code.\n",
      "diff": "@@ -1,77 +1,80 @@\n int processResults(Result result, List\u003cJSModule\u003e modules, B options) throws FlagUsageException, IOException {\n     if (config.computePhaseOrdering) {\n         return 0;\n     }\n     if (config.printPassGraph) {\n         if (compiler.getRoot() \u003d\u003d null) {\n             return 1;\n         } else {\n             jsOutput.append(DotFormatter.toDot(compiler.getPassConfig().getPassGraph()));\n             jsOutput.append(\u0027\\n\u0027);\n             return 0;\n         }\n     }\n     if (config.printAst) {\n         if (compiler.getRoot() \u003d\u003d null) {\n             return 1;\n         } else {\n             ControlFlowGraph\u003cNode\u003e cfg \u003d compiler.computeCFG();\n             DotFormatter.appendDot(compiler.getRoot().getLastChild(), cfg, jsOutput);\n             jsOutput.append(\u0027\\n\u0027);\n             return 0;\n         }\n     }\n     if (config.printTree) {\n         if (compiler.getRoot() \u003d\u003d null) {\n             jsOutput.append(\"Code contains errors; no tree was generated.\\n\");\n             return 1;\n         } else {\n             compiler.getRoot().appendStringTree(jsOutput);\n             jsOutput.append(\"\\n\");\n             return 0;\n         }\n     }\n-    if (result.success) {\n+    if (config.skipNormalOutputs) {\n+        outputManifest();\n+        return 0;\n+    } else if (result.success) {\n         if (modules \u003d\u003d null) {\n             writeOutput(jsOutput, compiler, compiler.toSource(), config.outputWrapper, OUTPUT_WRAPPER_MARKER);\n             outputSourceMap(options);\n         } else {\n             String moduleFilePrefix \u003d config.moduleOutputPathPrefix;\n             maybeCreateDirsForPath(moduleFilePrefix);\n             Map\u003cString, String\u003e moduleWrappers \u003d parseModuleWrappers(config.moduleWrapper, modules);\n             Writer mapOut \u003d null;\n             if (!shouldGenerateMapPerModule(options)) {\n                 mapOut \u003d fileNameToOutputWriter(expandSourceMapPath(options, null));\n             }\n             for (JSModule m : modules) {\n                 if (shouldGenerateMapPerModule(options)) {\n                     mapOut \u003d fileNameToOutputWriter(expandSourceMapPath(options, m));\n                 }\n                 Writer writer \u003d fileNameToOutputWriter(moduleFilePrefix + m.getName() + \".js\");\n                 if (options.sourceMapOutputPath !\u003d null) {\n                     compiler.getSourceMap().reset();\n                 }\n                 writeOutput(writer, compiler, compiler.toSource(m), moduleWrappers.get(m.getName()), \"%s\");\n                 if (options.sourceMapOutputPath !\u003d null) {\n                     compiler.getSourceMap().appendTo(mapOut, m.getName());\n                 }\n                 writer.close();\n                 if (shouldGenerateMapPerModule(options) \u0026\u0026 mapOut !\u003d null) {\n                     mapOut.close();\n                     mapOut \u003d null;\n                 }\n             }\n             if (mapOut !\u003d null) {\n                 mapOut.close();\n             }\n         }\n         if (options.externExportsPath !\u003d null) {\n             Writer eeOut \u003d openExternExportsStream(options, options.jsOutputFile);\n             eeOut.append(result.externExport);\n             eeOut.close();\n         }\n         outputNameMaps(options);\n         outputManifest();\n     }\n     return Math.min(result.errors.length, 0x7f);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d6ac4fe53569b1415f66db221d7511c74f4a965b": {
      "type": "Ybodychange",
      "commitMessage": "\nClean up stream-handing a bit\nRemove compute_phase_ordering flag\nFixes issue 412\n\nR\u003djohnlenz\nDELTA\u003d43  (16 added, 7 deleted, 20 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d1315\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@989 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "4/11/11, 10:28 AM",
      "commitName": "d6ac4fe53569b1415f66db221d7511c74f4a965b",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "4/6/11, 11:16 AM",
      "commitNameOld": "fcccf543e85a214f0948d1ac5cab3fa05363e845",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 4.97,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "actualSource": "int processResults(Result result, List\u003cJSModule\u003e modules, B options) throws FlagUsageException, IOException {\n    if (config.computePhaseOrdering) {\n        return 0;\n    }\n    if (config.printPassGraph) {\n        if (compiler.getRoot() \u003d\u003d null) {\n            return 1;\n        } else {\n            jsOutput.append(DotFormatter.toDot(compiler.getPassConfig().getPassGraph()));\n            jsOutput.append(\u0027\\n\u0027);\n            return 0;\n        }\n    }\n    if (config.printAst) {\n        if (compiler.getRoot() \u003d\u003d null) {\n            return 1;\n        } else {\n            ControlFlowGraph\u003cNode\u003e cfg \u003d compiler.computeCFG();\n            DotFormatter.appendDot(compiler.getRoot().getLastChild(), cfg, jsOutput);\n            jsOutput.append(\u0027\\n\u0027);\n            return 0;\n        }\n    }\n    if (config.printTree) {\n        if (compiler.getRoot() \u003d\u003d null) {\n            jsOutput.append(\"Code contains errors; no tree was generated.\\n\");\n            return 1;\n        } else {\n            compiler.getRoot().appendStringTree(jsOutput);\n            jsOutput.append(\"\\n\");\n            return 0;\n        }\n    }\n    if (result.success) {\n        if (modules \u003d\u003d null) {\n            writeOutput(jsOutput, compiler, compiler.toSource(), config.outputWrapper, OUTPUT_WRAPPER_MARKER);\n            outputSourceMap(options);\n        } else {\n            String moduleFilePrefix \u003d config.moduleOutputPathPrefix;\n            maybeCreateDirsForPath(moduleFilePrefix);\n            Map\u003cString, String\u003e moduleWrappers \u003d parseModuleWrappers(config.moduleWrapper, modules);\n            Writer mapOut \u003d null;\n            if (!shouldGenerateMapPerModule(options)) {\n                mapOut \u003d fileNameToOutputWriter(expandSourceMapPath(options, null));\n            }\n            for (JSModule m : modules) {\n                if (shouldGenerateMapPerModule(options)) {\n                    mapOut \u003d fileNameToOutputWriter(expandSourceMapPath(options, m));\n                }\n                Writer writer \u003d fileNameToOutputWriter(moduleFilePrefix + m.getName() + \".js\");\n                if (options.sourceMapOutputPath !\u003d null) {\n                    compiler.getSourceMap().reset();\n                }\n                writeOutput(writer, compiler, compiler.toSource(m), moduleWrappers.get(m.getName()), \"%s\");\n                if (options.sourceMapOutputPath !\u003d null) {\n                    compiler.getSourceMap().appendTo(mapOut, m.getName());\n                }\n                writer.close();\n                if (shouldGenerateMapPerModule(options) \u0026\u0026 mapOut !\u003d null) {\n                    mapOut.close();\n                    mapOut \u003d null;\n                }\n            }\n            if (mapOut !\u003d null) {\n                mapOut.close();\n            }\n        }\n        if (options.externExportsPath !\u003d null) {\n            Writer eeOut \u003d openExternExportsStream(options, options.jsOutputFile);\n            eeOut.append(result.externExport);\n            eeOut.close();\n        }\n        outputNameMaps(options);\n        outputManifest();\n    }\n    return Math.min(result.errors.length, 0x7f);\n}",
      "path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
      "functionStartLine": 646,
      "functionName": "processResults",
      "functionAnnotation": "",
      "functionDoc": "Processes the results of the compile job, and returns an error code.\n",
      "diff": "@@ -1,77 +1,77 @@\n int processResults(Result result, List\u003cJSModule\u003e modules, B options) throws FlagUsageException, IOException {\n     if (config.computePhaseOrdering) {\n         return 0;\n     }\n     if (config.printPassGraph) {\n         if (compiler.getRoot() \u003d\u003d null) {\n             return 1;\n         } else {\n-            out.append(DotFormatter.toDot(compiler.getPassConfig().getPassGraph()));\n-            out.append(\u0027\\n\u0027);\n+            jsOutput.append(DotFormatter.toDot(compiler.getPassConfig().getPassGraph()));\n+            jsOutput.append(\u0027\\n\u0027);\n             return 0;\n         }\n     }\n     if (config.printAst) {\n         if (compiler.getRoot() \u003d\u003d null) {\n             return 1;\n         } else {\n             ControlFlowGraph\u003cNode\u003e cfg \u003d compiler.computeCFG();\n-            DotFormatter.appendDot(compiler.getRoot().getLastChild(), cfg, out);\n-            out.append(\u0027\\n\u0027);\n+            DotFormatter.appendDot(compiler.getRoot().getLastChild(), cfg, jsOutput);\n+            jsOutput.append(\u0027\\n\u0027);\n             return 0;\n         }\n     }\n     if (config.printTree) {\n         if (compiler.getRoot() \u003d\u003d null) {\n-            out.append(\"Code contains errors; no tree was generated.\\n\");\n+            jsOutput.append(\"Code contains errors; no tree was generated.\\n\");\n             return 1;\n         } else {\n-            compiler.getRoot().appendStringTree(out);\n-            out.append(\"\\n\");\n+            compiler.getRoot().appendStringTree(jsOutput);\n+            jsOutput.append(\"\\n\");\n             return 0;\n         }\n     }\n     if (result.success) {\n         if (modules \u003d\u003d null) {\n-            writeOutput(out, compiler, compiler.toSource(), config.outputWrapper, OUTPUT_WRAPPER_MARKER);\n+            writeOutput(jsOutput, compiler, compiler.toSource(), config.outputWrapper, OUTPUT_WRAPPER_MARKER);\n             outputSourceMap(options);\n         } else {\n             String moduleFilePrefix \u003d config.moduleOutputPathPrefix;\n             maybeCreateDirsForPath(moduleFilePrefix);\n             Map\u003cString, String\u003e moduleWrappers \u003d parseModuleWrappers(config.moduleWrapper, modules);\n             Writer mapOut \u003d null;\n             if (!shouldGenerateMapPerModule(options)) {\n                 mapOut \u003d fileNameToOutputWriter(expandSourceMapPath(options, null));\n             }\n             for (JSModule m : modules) {\n                 if (shouldGenerateMapPerModule(options)) {\n                     mapOut \u003d fileNameToOutputWriter(expandSourceMapPath(options, m));\n                 }\n                 Writer writer \u003d fileNameToOutputWriter(moduleFilePrefix + m.getName() + \".js\");\n                 if (options.sourceMapOutputPath !\u003d null) {\n                     compiler.getSourceMap().reset();\n                 }\n                 writeOutput(writer, compiler, compiler.toSource(m), moduleWrappers.get(m.getName()), \"%s\");\n                 if (options.sourceMapOutputPath !\u003d null) {\n                     compiler.getSourceMap().appendTo(mapOut, m.getName());\n                 }\n                 writer.close();\n                 if (shouldGenerateMapPerModule(options) \u0026\u0026 mapOut !\u003d null) {\n                     mapOut.close();\n                     mapOut \u003d null;\n                 }\n             }\n             if (mapOut !\u003d null) {\n                 mapOut.close();\n             }\n         }\n         if (options.externExportsPath !\u003d null) {\n             Writer eeOut \u003d openExternExportsStream(options, options.jsOutputFile);\n             eeOut.append(result.externExport);\n             eeOut.close();\n         }\n         outputNameMaps(options);\n         outputManifest();\n     }\n     return Math.min(result.errors.length, 0x7f);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3e42e575f21275d2d0f8196f2f22b4ea06995d5b": {
      "type": "Yformatchange",
      "commitMessage": "\nMake CommandLineRunner more extensible\nFixes issue 353.\nContributed by Ibrahim Chaehoi\n\nRevision created by MOE tool push_codebase.\n\nR\u003djohnlenz\nDELTA\u003d45  (30 added, 2 deleted, 13 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d679\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@823 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "2/25/11, 12:23 PM",
      "commitName": "3e42e575f21275d2d0f8196f2f22b4ea06995d5b",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "2/8/11, 9:38 PM",
      "commitNameOld": "d38121222cc7c1d5e8dd2c34dcea4c2dc7468450",
      "commitAuthorOld": "kochi@google.com",
      "daysBetweenCommits": 16.61,
      "commitsBetweenForRepo": 50,
      "commitsBetweenForFile": 1,
      "actualSource": "int processResults(Result result, List\u003cJSModule\u003e modules, B options) throws FlagUsageException, IOException {\n    if (config.computePhaseOrdering) {\n        return 0;\n    }\n    if (config.printPassGraph) {\n        if (compiler.getRoot() \u003d\u003d null) {\n            return 1;\n        } else {\n            out.append(DotFormatter.toDot(compiler.getPassConfig().getPassGraph()));\n            out.append(\u0027\\n\u0027);\n            return 0;\n        }\n    }\n    if (config.printAst) {\n        if (compiler.getRoot() \u003d\u003d null) {\n            return 1;\n        } else {\n            ControlFlowGraph\u003cNode\u003e cfg \u003d compiler.computeCFG();\n            DotFormatter.appendDot(compiler.getRoot().getLastChild(), cfg, out);\n            out.append(\u0027\\n\u0027);\n            return 0;\n        }\n    }\n    if (config.printTree) {\n        if (compiler.getRoot() \u003d\u003d null) {\n            out.append(\"Code contains errors; no tree was generated.\\n\");\n            return 1;\n        } else {\n            compiler.getRoot().appendStringTree(out);\n            out.append(\"\\n\");\n            return 0;\n        }\n    }\n    if (result.success) {\n        if (modules \u003d\u003d null) {\n            writeOutput(out, compiler, compiler.toSource(), config.outputWrapper, OUTPUT_WRAPPER_MARKER);\n            outputSourceMap(options);\n        } else {\n            String moduleFilePrefix \u003d config.moduleOutputPathPrefix;\n            maybeCreateDirsForPath(moduleFilePrefix);\n            Map\u003cString, String\u003e moduleWrappers \u003d parseModuleWrappers(config.moduleWrapper, modules);\n            Writer mapOut \u003d null;\n            if (!shouldGenerateMapPerModule(options)) {\n                mapOut \u003d fileNameToOutputWriter(expandSourceMapPath(options, null));\n            }\n            for (JSModule m : modules) {\n                if (shouldGenerateMapPerModule(options)) {\n                    mapOut \u003d fileNameToOutputWriter(expandSourceMapPath(options, m));\n                }\n                Writer writer \u003d fileNameToOutputWriter(moduleFilePrefix + m.getName() + \".js\");\n                if (options.sourceMapOutputPath !\u003d null) {\n                    compiler.getSourceMap().reset();\n                }\n                writeOutput(writer, compiler, compiler.toSource(m), moduleWrappers.get(m.getName()), \"%s\");\n                if (options.sourceMapOutputPath !\u003d null) {\n                    compiler.getSourceMap().appendTo(mapOut, m.getName());\n                }\n                writer.close();\n                if (shouldGenerateMapPerModule(options) \u0026\u0026 mapOut !\u003d null) {\n                    mapOut.close();\n                    mapOut \u003d null;\n                }\n            }\n            if (mapOut !\u003d null) {\n                mapOut.close();\n            }\n        }\n        if (options.externExportsPath !\u003d null) {\n            Writer eeOut \u003d openExternExportsStream(options, options.jsOutputFile);\n            eeOut.append(result.externExport);\n            eeOut.close();\n        }\n        outputNameMaps(options);\n        outputManifest();\n    }\n    return Math.min(result.errors.length, 0x7f);\n}",
      "path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
      "functionStartLine": 632,
      "functionName": "processResults",
      "functionAnnotation": "",
      "functionDoc": "Processes the results of the compile job, and returns an error code.\n",
      "diff": "",
      "extendedDetails": {}
    },
    "36a890d0dd7911a5a1b8e1682435945972a05cdc": {
      "type": "Ybodychange",
      "commitMessage": "\nRemove the --output_wrapper_marker flag.\nNo one uses this, and it makes the API harder to understand.\n\nR\u003dacleung\nDELTA\u003d26  (2 added, 23 deleted, 1 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d409\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@741 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "1/31/11, 4:27 PM",
      "commitName": "36a890d0dd7911a5a1b8e1682435945972a05cdc",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "1/13/11, 11:07 AM",
      "commitNameOld": "606015f2b48ebaefb3cb1193d2b9d0310f3dc2f5",
      "commitAuthorOld": "agrieve@google.com",
      "daysBetweenCommits": 18.22,
      "commitsBetweenForRepo": 45,
      "commitsBetweenForFile": 1,
      "actualSource": "int processResults(Result result, List\u003cJSModule\u003e modules, B options) throws FlagUsageException, IOException {\n    if (config.computePhaseOrdering) {\n        return 0;\n    }\n    if (config.printPassGraph) {\n        if (compiler.getRoot() \u003d\u003d null) {\n            return 1;\n        } else {\n            out.append(DotFormatter.toDot(compiler.getPassConfig().getPassGraph()));\n            out.append(\u0027\\n\u0027);\n            return 0;\n        }\n    }\n    if (config.printAst) {\n        if (compiler.getRoot() \u003d\u003d null) {\n            return 1;\n        } else {\n            ControlFlowGraph\u003cNode\u003e cfg \u003d compiler.computeCFG();\n            DotFormatter.appendDot(compiler.getRoot().getLastChild(), cfg, out);\n            out.append(\u0027\\n\u0027);\n            return 0;\n        }\n    }\n    if (config.printTree) {\n        if (compiler.getRoot() \u003d\u003d null) {\n            out.append(\"Code contains errors; no tree was generated.\\n\");\n            return 1;\n        } else {\n            compiler.getRoot().appendStringTree(out);\n            out.append(\"\\n\");\n            return 0;\n        }\n    }\n    if (result.success) {\n        if (modules \u003d\u003d null) {\n            writeOutput(out, compiler, compiler.toSource(), config.outputWrapper, OUTPUT_WRAPPER_MARKER);\n            outputSourceMap(options);\n        } else {\n            String moduleFilePrefix \u003d config.moduleOutputPathPrefix;\n            maybeCreateDirsForPath(moduleFilePrefix);\n            Map\u003cString, String\u003e moduleWrappers \u003d parseModuleWrappers(config.moduleWrapper, modules);\n            Writer mapOut \u003d null;\n            if (!shouldGenerateMapPerModule(options)) {\n                mapOut \u003d fileNameToOutputWriter(expandSourceMapPath(options, null));\n            }\n            for (JSModule m : modules) {\n                if (shouldGenerateMapPerModule(options)) {\n                    mapOut \u003d fileNameToOutputWriter(expandSourceMapPath(options, m));\n                }\n                Writer writer \u003d fileNameToOutputWriter(moduleFilePrefix + m.getName() + \".js\");\n                if (options.sourceMapOutputPath !\u003d null) {\n                    compiler.getSourceMap().reset();\n                }\n                writeOutput(writer, compiler, compiler.toSource(m), moduleWrappers.get(m.getName()), \"%s\");\n                if (options.sourceMapOutputPath !\u003d null) {\n                    compiler.getSourceMap().appendTo(mapOut, m.getName());\n                }\n                writer.close();\n                if (shouldGenerateMapPerModule(options) \u0026\u0026 mapOut !\u003d null) {\n                    mapOut.close();\n                    mapOut \u003d null;\n                }\n            }\n            if (mapOut !\u003d null) {\n                mapOut.close();\n            }\n        }\n        if (options.externExportsPath !\u003d null) {\n            Writer eeOut \u003d openExternExportsStream(options, options.jsOutputFile);\n            eeOut.append(result.externExport);\n            eeOut.close();\n        }\n        outputNameMaps(options);\n        outputManifest();\n    }\n    return Math.min(result.errors.length, 0x7f);\n}",
      "path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
      "functionStartLine": 604,
      "functionName": "processResults",
      "functionAnnotation": "",
      "functionDoc": "Processes the results of the compile job, and returns an error code.\n",
      "diff": "@@ -1,77 +1,77 @@\n int processResults(Result result, List\u003cJSModule\u003e modules, B options) throws FlagUsageException, IOException {\n     if (config.computePhaseOrdering) {\n         return 0;\n     }\n     if (config.printPassGraph) {\n         if (compiler.getRoot() \u003d\u003d null) {\n             return 1;\n         } else {\n             out.append(DotFormatter.toDot(compiler.getPassConfig().getPassGraph()));\n             out.append(\u0027\\n\u0027);\n             return 0;\n         }\n     }\n     if (config.printAst) {\n         if (compiler.getRoot() \u003d\u003d null) {\n             return 1;\n         } else {\n             ControlFlowGraph\u003cNode\u003e cfg \u003d compiler.computeCFG();\n             DotFormatter.appendDot(compiler.getRoot().getLastChild(), cfg, out);\n             out.append(\u0027\\n\u0027);\n             return 0;\n         }\n     }\n     if (config.printTree) {\n         if (compiler.getRoot() \u003d\u003d null) {\n             out.append(\"Code contains errors; no tree was generated.\\n\");\n             return 1;\n         } else {\n             compiler.getRoot().appendStringTree(out);\n             out.append(\"\\n\");\n             return 0;\n         }\n     }\n     if (result.success) {\n         if (modules \u003d\u003d null) {\n-            writeOutput(out, compiler, compiler.toSource(), config.outputWrapper, config.outputWrapperMarker);\n+            writeOutput(out, compiler, compiler.toSource(), config.outputWrapper, OUTPUT_WRAPPER_MARKER);\n             outputSourceMap(options);\n         } else {\n             String moduleFilePrefix \u003d config.moduleOutputPathPrefix;\n             maybeCreateDirsForPath(moduleFilePrefix);\n             Map\u003cString, String\u003e moduleWrappers \u003d parseModuleWrappers(config.moduleWrapper, modules);\n             Writer mapOut \u003d null;\n             if (!shouldGenerateMapPerModule(options)) {\n                 mapOut \u003d fileNameToOutputWriter(expandSourceMapPath(options, null));\n             }\n             for (JSModule m : modules) {\n                 if (shouldGenerateMapPerModule(options)) {\n                     mapOut \u003d fileNameToOutputWriter(expandSourceMapPath(options, m));\n                 }\n                 Writer writer \u003d fileNameToOutputWriter(moduleFilePrefix + m.getName() + \".js\");\n                 if (options.sourceMapOutputPath !\u003d null) {\n                     compiler.getSourceMap().reset();\n                 }\n                 writeOutput(writer, compiler, compiler.toSource(m), moduleWrappers.get(m.getName()), \"%s\");\n                 if (options.sourceMapOutputPath !\u003d null) {\n                     compiler.getSourceMap().appendTo(mapOut, m.getName());\n                 }\n                 writer.close();\n                 if (shouldGenerateMapPerModule(options) \u0026\u0026 mapOut !\u003d null) {\n                     mapOut.close();\n                     mapOut \u003d null;\n                 }\n             }\n             if (mapOut !\u003d null) {\n                 mapOut.close();\n             }\n         }\n         if (options.externExportsPath !\u003d null) {\n             Writer eeOut \u003d openExternExportsStream(options, options.jsOutputFile);\n             eeOut.append(result.externExport);\n             eeOut.close();\n         }\n         outputNameMaps(options);\n         outputManifest();\n     }\n     return Math.min(result.errors.length, 0x7f);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4b5d62920ef4606fd30dfa42eb72df2785415533": {
      "type": "Ybodychange",
      "commitMessage": "\ndon\u0027t print the externs files in --print_ast.\n\nR\u003dacleung\nDELTA\u003d23  (18 added, 3 deleted, 2 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d235672\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@447 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "9/20/10, 9:35 PM",
      "commitName": "4b5d62920ef4606fd30dfa42eb72df2785415533",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "8/30/10, 4:16 PM",
      "commitNameOld": "4cede4f156740b7ce93d92d824066e9a42257541",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 21.22,
      "commitsBetweenForRepo": 49,
      "commitsBetweenForFile": 1,
      "actualSource": "int processResults(Result result, List\u003cJSModule\u003e modules, B options) throws FlagUsageException, IOException {\n    if (config.computePhaseOrdering) {\n        return 0;\n    }\n    if (config.printPassGraph) {\n        if (compiler.getRoot() \u003d\u003d null) {\n            return 1;\n        } else {\n            out.append(DotFormatter.toDot(compiler.getPassConfig().getPassGraph()));\n            out.append(\u0027\\n\u0027);\n            return 0;\n        }\n    }\n    if (config.printAst) {\n        if (compiler.getRoot() \u003d\u003d null) {\n            return 1;\n        } else {\n            ControlFlowGraph\u003cNode\u003e cfg \u003d compiler.computeCFG();\n            DotFormatter.appendDot(compiler.getRoot().getLastChild(), cfg, out);\n            out.append(\u0027\\n\u0027);\n            return 0;\n        }\n    }\n    if (config.printTree) {\n        if (compiler.getRoot() \u003d\u003d null) {\n            out.append(\"Code contains errors; no tree was generated.\\n\");\n            return 1;\n        } else {\n            compiler.getRoot().appendStringTree(out);\n            out.append(\"\\n\");\n            return 0;\n        }\n    }\n    if (result.success) {\n        if (modules \u003d\u003d null) {\n            writeOutput(out, compiler, compiler.toSource(), config.outputWrapper, config.outputWrapperMarker);\n            outputSourceMap(options);\n        } else {\n            String moduleFilePrefix \u003d config.moduleOutputPathPrefix;\n            maybeCreateDirsForPath(moduleFilePrefix);\n            Map\u003cString, String\u003e moduleWrappers \u003d parseModuleWrappers(config.moduleWrapper, modules);\n            Writer mapOut \u003d null;\n            if (!shouldGenerateMapPerModule(options)) {\n                mapOut \u003d fileNameToOutputWriter(expandSourceMapPath(options, null));\n            }\n            for (JSModule m : modules) {\n                if (shouldGenerateMapPerModule(options)) {\n                    mapOut \u003d fileNameToOutputWriter(expandSourceMapPath(options, m));\n                }\n                Writer writer \u003d fileNameToOutputWriter(moduleFilePrefix + m.getName() + \".js\");\n                if (options.sourceMapOutputPath !\u003d null) {\n                    compiler.getSourceMap().reset();\n                }\n                writeOutput(writer, compiler, compiler.toSource(m), moduleWrappers.get(m.getName()), \"%s\");\n                if (options.sourceMapOutputPath !\u003d null) {\n                    compiler.getSourceMap().appendTo(mapOut, m.getName());\n                }\n                writer.close();\n                if (shouldGenerateMapPerModule(options) \u0026\u0026 mapOut !\u003d null) {\n                    mapOut.close();\n                    mapOut \u003d null;\n                }\n            }\n            if (mapOut !\u003d null) {\n                mapOut.close();\n            }\n        }\n        if (options.externExportsPath !\u003d null) {\n            Writer eeOut \u003d openExternExportsStream(options, options.jsOutputFile);\n            eeOut.append(result.externExport);\n            eeOut.close();\n        }\n        outputNameMaps(options);\n        outputManifest();\n    }\n    return Math.min(result.errors.length, 0x7f);\n}",
      "path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
      "functionStartLine": 594,
      "functionName": "processResults",
      "functionAnnotation": "",
      "functionDoc": "Processes the results of the compile job, and returns an error code.\n",
      "diff": "@@ -1,77 +1,77 @@\n int processResults(Result result, List\u003cJSModule\u003e modules, B options) throws FlagUsageException, IOException {\n     if (config.computePhaseOrdering) {\n         return 0;\n     }\n     if (config.printPassGraph) {\n         if (compiler.getRoot() \u003d\u003d null) {\n             return 1;\n         } else {\n             out.append(DotFormatter.toDot(compiler.getPassConfig().getPassGraph()));\n             out.append(\u0027\\n\u0027);\n             return 0;\n         }\n     }\n     if (config.printAst) {\n         if (compiler.getRoot() \u003d\u003d null) {\n             return 1;\n         } else {\n             ControlFlowGraph\u003cNode\u003e cfg \u003d compiler.computeCFG();\n-            DotFormatter.appendDot(compiler.getRoot(), cfg, out);\n+            DotFormatter.appendDot(compiler.getRoot().getLastChild(), cfg, out);\n             out.append(\u0027\\n\u0027);\n             return 0;\n         }\n     }\n     if (config.printTree) {\n         if (compiler.getRoot() \u003d\u003d null) {\n             out.append(\"Code contains errors; no tree was generated.\\n\");\n             return 1;\n         } else {\n             compiler.getRoot().appendStringTree(out);\n             out.append(\"\\n\");\n             return 0;\n         }\n     }\n     if (result.success) {\n         if (modules \u003d\u003d null) {\n             writeOutput(out, compiler, compiler.toSource(), config.outputWrapper, config.outputWrapperMarker);\n             outputSourceMap(options);\n         } else {\n             String moduleFilePrefix \u003d config.moduleOutputPathPrefix;\n             maybeCreateDirsForPath(moduleFilePrefix);\n             Map\u003cString, String\u003e moduleWrappers \u003d parseModuleWrappers(config.moduleWrapper, modules);\n             Writer mapOut \u003d null;\n             if (!shouldGenerateMapPerModule(options)) {\n                 mapOut \u003d fileNameToOutputWriter(expandSourceMapPath(options, null));\n             }\n             for (JSModule m : modules) {\n                 if (shouldGenerateMapPerModule(options)) {\n                     mapOut \u003d fileNameToOutputWriter(expandSourceMapPath(options, m));\n                 }\n                 Writer writer \u003d fileNameToOutputWriter(moduleFilePrefix + m.getName() + \".js\");\n                 if (options.sourceMapOutputPath !\u003d null) {\n                     compiler.getSourceMap().reset();\n                 }\n                 writeOutput(writer, compiler, compiler.toSource(m), moduleWrappers.get(m.getName()), \"%s\");\n                 if (options.sourceMapOutputPath !\u003d null) {\n                     compiler.getSourceMap().appendTo(mapOut, m.getName());\n                 }\n                 writer.close();\n                 if (shouldGenerateMapPerModule(options) \u0026\u0026 mapOut !\u003d null) {\n                     mapOut.close();\n                     mapOut \u003d null;\n                 }\n             }\n             if (mapOut !\u003d null) {\n                 mapOut.close();\n             }\n         }\n         if (options.externExportsPath !\u003d null) {\n             Writer eeOut \u003d openExternExportsStream(options, options.jsOutputFile);\n             eeOut.append(result.externExport);\n             eeOut.close();\n         }\n         outputNameMaps(options);\n         outputManifest();\n     }\n     return Math.min(result.errors.length, 0x7f);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4cede4f156740b7ce93d92d824066e9a42257541": {
      "type": "Ybodychange",
      "commitMessage": "\nUnify output encoding for real this time\nFixes issue 224.\n\nRevision created by MOE tool push_codebase.\n\nR\u003djohnlenz\nDELTA\u003d39  (5 added, 5 deleted, 29 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d196345\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@394 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "8/30/10, 4:16 PM",
      "commitName": "4cede4f156740b7ce93d92d824066e9a42257541",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "8/27/10, 3:52 PM",
      "commitNameOld": "e152ec001d2c6a9bbd6e0d9443552371d11e461f",
      "commitAuthorOld": "nicksantos@google.com",
      "daysBetweenCommits": 3.02,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "int processResults(Result result, List\u003cJSModule\u003e modules, B options) throws FlagUsageException, IOException {\n    if (config.computePhaseOrdering) {\n        return 0;\n    }\n    if (config.printPassGraph) {\n        if (compiler.getRoot() \u003d\u003d null) {\n            return 1;\n        } else {\n            out.append(DotFormatter.toDot(compiler.getPassConfig().getPassGraph()));\n            out.append(\u0027\\n\u0027);\n            return 0;\n        }\n    }\n    if (config.printAst) {\n        if (compiler.getRoot() \u003d\u003d null) {\n            return 1;\n        } else {\n            ControlFlowGraph\u003cNode\u003e cfg \u003d compiler.computeCFG();\n            DotFormatter.appendDot(compiler.getRoot(), cfg, out);\n            out.append(\u0027\\n\u0027);\n            return 0;\n        }\n    }\n    if (config.printTree) {\n        if (compiler.getRoot() \u003d\u003d null) {\n            out.append(\"Code contains errors; no tree was generated.\\n\");\n            return 1;\n        } else {\n            compiler.getRoot().appendStringTree(out);\n            out.append(\"\\n\");\n            return 0;\n        }\n    }\n    if (result.success) {\n        if (modules \u003d\u003d null) {\n            writeOutput(out, compiler, compiler.toSource(), config.outputWrapper, config.outputWrapperMarker);\n            outputSourceMap(options);\n        } else {\n            String moduleFilePrefix \u003d config.moduleOutputPathPrefix;\n            maybeCreateDirsForPath(moduleFilePrefix);\n            Map\u003cString, String\u003e moduleWrappers \u003d parseModuleWrappers(config.moduleWrapper, modules);\n            Writer mapOut \u003d null;\n            if (!shouldGenerateMapPerModule(options)) {\n                mapOut \u003d fileNameToOutputWriter(expandSourceMapPath(options, null));\n            }\n            for (JSModule m : modules) {\n                if (shouldGenerateMapPerModule(options)) {\n                    mapOut \u003d fileNameToOutputWriter(expandSourceMapPath(options, m));\n                }\n                Writer writer \u003d fileNameToOutputWriter(moduleFilePrefix + m.getName() + \".js\");\n                if (options.sourceMapOutputPath !\u003d null) {\n                    compiler.getSourceMap().reset();\n                }\n                writeOutput(writer, compiler, compiler.toSource(m), moduleWrappers.get(m.getName()), \"%s\");\n                if (options.sourceMapOutputPath !\u003d null) {\n                    compiler.getSourceMap().appendTo(mapOut, m.getName());\n                }\n                writer.close();\n                if (shouldGenerateMapPerModule(options) \u0026\u0026 mapOut !\u003d null) {\n                    mapOut.close();\n                    mapOut \u003d null;\n                }\n            }\n            if (mapOut !\u003d null) {\n                mapOut.close();\n            }\n        }\n        if (options.externExportsPath !\u003d null) {\n            Writer eeOut \u003d openExternExportsStream(options, options.jsOutputFile);\n            eeOut.append(result.externExport);\n            eeOut.close();\n        }\n        outputNameMaps(options);\n        outputManifest();\n    }\n    return Math.min(result.errors.length, 0x7f);\n}",
      "path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
      "functionStartLine": 594,
      "functionName": "processResults",
      "functionAnnotation": "",
      "functionDoc": "Processes the results of the compile job, and returns an error code.\n",
      "diff": "@@ -1,77 +1,77 @@\n int processResults(Result result, List\u003cJSModule\u003e modules, B options) throws FlagUsageException, IOException {\n     if (config.computePhaseOrdering) {\n         return 0;\n     }\n     if (config.printPassGraph) {\n         if (compiler.getRoot() \u003d\u003d null) {\n             return 1;\n         } else {\n             out.append(DotFormatter.toDot(compiler.getPassConfig().getPassGraph()));\n             out.append(\u0027\\n\u0027);\n             return 0;\n         }\n     }\n     if (config.printAst) {\n         if (compiler.getRoot() \u003d\u003d null) {\n             return 1;\n         } else {\n             ControlFlowGraph\u003cNode\u003e cfg \u003d compiler.computeCFG();\n             DotFormatter.appendDot(compiler.getRoot(), cfg, out);\n             out.append(\u0027\\n\u0027);\n             return 0;\n         }\n     }\n     if (config.printTree) {\n         if (compiler.getRoot() \u003d\u003d null) {\n             out.append(\"Code contains errors; no tree was generated.\\n\");\n             return 1;\n         } else {\n             compiler.getRoot().appendStringTree(out);\n             out.append(\"\\n\");\n             return 0;\n         }\n     }\n     if (result.success) {\n         if (modules \u003d\u003d null) {\n             writeOutput(out, compiler, compiler.toSource(), config.outputWrapper, config.outputWrapperMarker);\n             outputSourceMap(options);\n         } else {\n             String moduleFilePrefix \u003d config.moduleOutputPathPrefix;\n             maybeCreateDirsForPath(moduleFilePrefix);\n             Map\u003cString, String\u003e moduleWrappers \u003d parseModuleWrappers(config.moduleWrapper, modules);\n             Writer mapOut \u003d null;\n             if (!shouldGenerateMapPerModule(options)) {\n-                mapOut \u003d toWriter(expandSourceMapPath(options, null));\n+                mapOut \u003d fileNameToOutputWriter(expandSourceMapPath(options, null));\n             }\n             for (JSModule m : modules) {\n                 if (shouldGenerateMapPerModule(options)) {\n-                    mapOut \u003d toWriter(expandSourceMapPath(options, m));\n+                    mapOut \u003d fileNameToOutputWriter(expandSourceMapPath(options, m));\n                 }\n-                Writer writer \u003d toWriter(moduleFilePrefix + m.getName() + \".js\");\n+                Writer writer \u003d fileNameToOutputWriter(moduleFilePrefix + m.getName() + \".js\");\n                 if (options.sourceMapOutputPath !\u003d null) {\n                     compiler.getSourceMap().reset();\n                 }\n                 writeOutput(writer, compiler, compiler.toSource(m), moduleWrappers.get(m.getName()), \"%s\");\n                 if (options.sourceMapOutputPath !\u003d null) {\n                     compiler.getSourceMap().appendTo(mapOut, m.getName());\n                 }\n                 writer.close();\n                 if (shouldGenerateMapPerModule(options) \u0026\u0026 mapOut !\u003d null) {\n                     mapOut.close();\n                     mapOut \u003d null;\n                 }\n             }\n             if (mapOut !\u003d null) {\n                 mapOut.close();\n             }\n         }\n         if (options.externExportsPath !\u003d null) {\n             Writer eeOut \u003d openExternExportsStream(options, options.jsOutputFile);\n             eeOut.append(result.externExport);\n             eeOut.close();\n         }\n         outputNameMaps(options);\n         outputManifest();\n     }\n     return Math.min(result.errors.length, 0x7f);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "61b5204064333144810c184d38b4dc78f947bd62": {
      "type": "Yparameterchange",
      "commitMessage": "\nCreate a much better integration test for CommandLineRunner.\n\nR\u003dacleung\nDELTA\u003d188  (118 added, 33 deleted, 37 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d181025\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@375 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "8/20/10, 4:46 PM",
      "commitName": "61b5204064333144810c184d38b4dc78f947bd62",
      "commitAuthor": "nicksantos@google.com",
      "commitDateOld": "8/19/10, 6:17 PM",
      "commitNameOld": "e859f6f557d0ac39f3bf45949691b2a0e150a2e4",
      "commitAuthorOld": "johnlenz@google.com",
      "daysBetweenCommits": 0.94,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "int processResults(Result result, List\u003cJSModule\u003e modules, B options) throws FlagUsageException, IOException {\n    if (config.computePhaseOrdering) {\n        return 0;\n    }\n    if (config.printPassGraph) {\n        if (compiler.getRoot() \u003d\u003d null) {\n            return 1;\n        } else {\n            out.append(DotFormatter.toDot(compiler.getPassConfig().getPassGraph()));\n            out.append(\u0027\\n\u0027);\n            return 0;\n        }\n    }\n    if (config.printAst) {\n        if (compiler.getRoot() \u003d\u003d null) {\n            return 1;\n        } else {\n            ControlFlowGraph\u003cNode\u003e cfg \u003d compiler.computeCFG();\n            DotFormatter.appendDot(compiler.getRoot(), cfg, out);\n            out.append(\u0027\\n\u0027);\n            return 0;\n        }\n    }\n    if (config.printTree) {\n        if (compiler.getRoot() \u003d\u003d null) {\n            out.append(\"Code contains errors; no tree was generated.\\n\");\n            return 1;\n        } else {\n            compiler.getRoot().appendStringTree(out);\n            out.append(\"\\n\");\n            return 0;\n        }\n    }\n    if (result.success) {\n        if (modules \u003d\u003d null) {\n            writeOutput(out, compiler, compiler.toSource(), config.outputWrapper, config.outputWrapperMarker);\n            outputSourceMap(options);\n        } else {\n            String moduleFilePrefix \u003d config.moduleOutputPathPrefix;\n            maybeCreateDirsForPath(moduleFilePrefix);\n            Map\u003cString, String\u003e moduleWrappers \u003d parseModuleWrappers(config.moduleWrapper, modules);\n            Writer mapOut \u003d null;\n            if (!shouldGenerateMapPerModule(options)) {\n                mapOut \u003d toWriter(expandSourceMapPath(options, null));\n            }\n            for (JSModule m : modules) {\n                if (shouldGenerateMapPerModule(options)) {\n                    mapOut \u003d toWriter(expandSourceMapPath(options, m));\n                }\n                Writer writer \u003d toWriter(moduleFilePrefix + m.getName() + \".js\");\n                if (options.sourceMapOutputPath !\u003d null) {\n                    compiler.getSourceMap().reset();\n                }\n                writeOutput(writer, compiler, compiler.toSource(m), moduleWrappers.get(m.getName()), \"%s\");\n                if (options.sourceMapOutputPath !\u003d null) {\n                    compiler.getSourceMap().appendTo(mapOut, m.getName());\n                }\n                writer.close();\n                if (shouldGenerateMapPerModule(options) \u0026\u0026 mapOut !\u003d null) {\n                    mapOut.close();\n                    mapOut \u003d null;\n                }\n            }\n            if (mapOut !\u003d null) {\n                mapOut.close();\n            }\n        }\n        if (options.externExportsPath !\u003d null) {\n            Writer eeOut \u003d openExternExportsStream(options, options.jsOutputFile);\n            eeOut.append(result.externExport);\n            eeOut.close();\n        }\n        outputNameMaps(options);\n        outputManifest();\n    }\n    return Math.min(result.errors.length, 0x7f);\n}",
      "path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
      "functionStartLine": 590,
      "functionName": "processResults",
      "functionAnnotation": "",
      "functionDoc": "Processes the results of the compile job, and returns an error code.\n",
      "diff": "@@ -1,77 +1,77 @@\n-int processResults(Result result, JSModule[] modules, B options) throws FlagUsageException, IOException {\n+int processResults(Result result, List\u003cJSModule\u003e modules, B options) throws FlagUsageException, IOException {\n     if (config.computePhaseOrdering) {\n         return 0;\n     }\n     if (config.printPassGraph) {\n         if (compiler.getRoot() \u003d\u003d null) {\n             return 1;\n         } else {\n             out.append(DotFormatter.toDot(compiler.getPassConfig().getPassGraph()));\n             out.append(\u0027\\n\u0027);\n             return 0;\n         }\n     }\n     if (config.printAst) {\n         if (compiler.getRoot() \u003d\u003d null) {\n             return 1;\n         } else {\n             ControlFlowGraph\u003cNode\u003e cfg \u003d compiler.computeCFG();\n             DotFormatter.appendDot(compiler.getRoot(), cfg, out);\n             out.append(\u0027\\n\u0027);\n             return 0;\n         }\n     }\n     if (config.printTree) {\n         if (compiler.getRoot() \u003d\u003d null) {\n             out.append(\"Code contains errors; no tree was generated.\\n\");\n             return 1;\n         } else {\n             compiler.getRoot().appendStringTree(out);\n             out.append(\"\\n\");\n             return 0;\n         }\n     }\n     if (result.success) {\n         if (modules \u003d\u003d null) {\n             writeOutput(out, compiler, compiler.toSource(), config.outputWrapper, config.outputWrapperMarker);\n             outputSourceMap(options);\n         } else {\n             String moduleFilePrefix \u003d config.moduleOutputPathPrefix;\n             maybeCreateDirsForPath(moduleFilePrefix);\n             Map\u003cString, String\u003e moduleWrappers \u003d parseModuleWrappers(config.moduleWrapper, modules);\n             Writer mapOut \u003d null;\n             if (!shouldGenerateMapPerModule(options)) {\n                 mapOut \u003d toWriter(expandSourceMapPath(options, null));\n             }\n             for (JSModule m : modules) {\n                 if (shouldGenerateMapPerModule(options)) {\n                     mapOut \u003d toWriter(expandSourceMapPath(options, m));\n                 }\n                 Writer writer \u003d toWriter(moduleFilePrefix + m.getName() + \".js\");\n                 if (options.sourceMapOutputPath !\u003d null) {\n                     compiler.getSourceMap().reset();\n                 }\n                 writeOutput(writer, compiler, compiler.toSource(m), moduleWrappers.get(m.getName()), \"%s\");\n                 if (options.sourceMapOutputPath !\u003d null) {\n                     compiler.getSourceMap().appendTo(mapOut, m.getName());\n                 }\n                 writer.close();\n                 if (shouldGenerateMapPerModule(options) \u0026\u0026 mapOut !\u003d null) {\n                     mapOut.close();\n                     mapOut \u003d null;\n                 }\n             }\n             if (mapOut !\u003d null) {\n                 mapOut.close();\n             }\n         }\n         if (options.externExportsPath !\u003d null) {\n             Writer eeOut \u003d openExternExportsStream(options, options.jsOutputFile);\n             eeOut.append(result.externExport);\n             eeOut.close();\n         }\n         outputNameMaps(options);\n         outputManifest();\n     }\n     return Math.min(result.errors.length, 0x7f);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[result-Result, modules-JSModule[], options-B]",
        "newValue": "[result-Result, modules-List\u003cJSModule\u003e, options-B]"
      }
    },
    "82a9956c6337d2f5d4a94ebe624d64faa54d9182": {
      "type": "Ybodychange",
      "commitMessage": "\nChange on 2010/07/09 08:36:29 by nicksantos\n\n        when injecting param checks, do not inject them before any function\n        declarations, because that will break normalization constraints.\n\n        R\u003djohnlenz\n        DELTA\u003d22  (18 added, 0 deleted, 4 changed)\n\nChange on 2010/07/09 09:36:54 by johnlenz\n\n        Prefer FileWriter to PrintStream when charset translation isn\u0027t needed.\n\n        R\u003dacleung\n        DELTA\u003d68  (13 added, 2 deleted, 53 changed)\n\nChange on 2010/07/09 10:54:42 by nicksantos\n\n        our mechanism for injecting boilerplate does not work\n        for code that uses @const externs. So just don\u0027t use\n        any @const externs.\n\n        R\u003djohnlenz\n        DELTA\u003d3  (1 added, 0 deleted, 2 changed)\n\nChange on 2010/07/09 11:30:29 by nicksantos\n\n        Scan functional properties of object literals for invalid use\n        of \"this\".\n        Fixes issue 182.\n\n        R\u003dacleung\n        DELTA\u003d21  (19 added, 0 deleted, 2 changed)\n\nChange on 2010/07/09 12:40:16 by dcc\n\n        Separate pass instance for peephole preprocessing.\n        Now that I\u0027m writing instructions for how people can add their own\n        peephole passes, I want to make sure that the preprocessing\n        peephole optimizations that relies on don\u0027t get disturbed.\n\n        R\u003djohnlenz\n        DELTA\u003d18  (15 added, 0 deleted, 3 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d49008\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@270 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "7/9/10, 4:02 PM",
      "commitName": "82a9956c6337d2f5d4a94ebe624d64faa54d9182",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "7/8/10, 5:15 PM",
      "commitNameOld": "0c8a0c53b2124d05b017a63bdbc720a57c89ead2",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 0.95,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "int processResults(Result result, JSModule[] modules, B options) throws FlagUsageException, IOException {\n    if (config.computePhaseOrdering) {\n        return 0;\n    }\n    if (config.printPassGraph) {\n        if (compiler.getRoot() \u003d\u003d null) {\n            return 1;\n        } else {\n            out.append(DotFormatter.toDot(compiler.getPassConfig().getPassGraph()));\n            out.append(\u0027\\n\u0027);\n            return 0;\n        }\n    }\n    if (config.printAst) {\n        if (compiler.getRoot() \u003d\u003d null) {\n            return 1;\n        } else {\n            ControlFlowGraph\u003cNode\u003e cfg \u003d compiler.computeCFG();\n            DotFormatter.appendDot(compiler.getRoot(), cfg, out);\n            out.append(\u0027\\n\u0027);\n            return 0;\n        }\n    }\n    if (config.printTree) {\n        if (compiler.getRoot() \u003d\u003d null) {\n            out.append(\"Code contains errors; no tree was generated.\\n\");\n            return 1;\n        } else {\n            compiler.getRoot().appendStringTree(out);\n            out.append(\"\\n\");\n            return 0;\n        }\n    }\n    if (result.success) {\n        if (modules \u003d\u003d null) {\n            writeOutput(out, compiler, compiler.toSource(), config.outputWrapper, config.outputWrapperMarker);\n            outputSourceMap(options);\n        } else {\n            String moduleFilePrefix \u003d config.moduleOutputPathPrefix;\n            maybeCreateDirsForPath(moduleFilePrefix);\n            Map\u003cString, String\u003e moduleWrappers \u003d parseModuleWrappers(config.moduleWrapper, modules);\n            Writer mapOut \u003d null;\n            if (!shouldGenerateMapPerModule(options)) {\n                mapOut \u003d toWriter(expandSourceMapPath(options, null));\n            }\n            for (JSModule m : modules) {\n                if (shouldGenerateMapPerModule(options)) {\n                    mapOut \u003d toWriter(expandSourceMapPath(options, m));\n                }\n                Writer writer \u003d toWriter(moduleFilePrefix + m.getName() + \".js\");\n                if (options.sourceMapOutputPath !\u003d null) {\n                    compiler.getSourceMap().reset();\n                }\n                writeOutput(writer, compiler, compiler.toSource(m), moduleWrappers.get(m.getName()), \"%s\");\n                if (options.sourceMapOutputPath !\u003d null) {\n                    compiler.getSourceMap().appendTo(mapOut, m.getName());\n                }\n                writer.close();\n                if (shouldGenerateMapPerModule(options) \u0026\u0026 mapOut !\u003d null) {\n                    mapOut.close();\n                    mapOut \u003d null;\n                }\n            }\n            if (mapOut !\u003d null) {\n                mapOut.close();\n            }\n        }\n        if (options.externExportsPath !\u003d null) {\n            Writer eeOut \u003d openExternExportsStream(options, options.jsOutputFile);\n            eeOut.append(result.externExport);\n            eeOut.close();\n        }\n        outputNameMaps(options);\n        outputManifest();\n    }\n    return Math.min(result.errors.length, 0x7f);\n}",
      "path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
      "functionStartLine": 533,
      "functionName": "processResults",
      "functionAnnotation": "",
      "functionDoc": "Processes the results of the compile job, and returns an error code.\n",
      "diff": "@@ -1,77 +1,77 @@\n int processResults(Result result, JSModule[] modules, B options) throws FlagUsageException, IOException {\n     if (config.computePhaseOrdering) {\n         return 0;\n     }\n     if (config.printPassGraph) {\n         if (compiler.getRoot() \u003d\u003d null) {\n             return 1;\n         } else {\n             out.append(DotFormatter.toDot(compiler.getPassConfig().getPassGraph()));\n-            out.println();\n+            out.append(\u0027\\n\u0027);\n             return 0;\n         }\n     }\n     if (config.printAst) {\n         if (compiler.getRoot() \u003d\u003d null) {\n             return 1;\n         } else {\n             ControlFlowGraph\u003cNode\u003e cfg \u003d compiler.computeCFG();\n             DotFormatter.appendDot(compiler.getRoot(), cfg, out);\n-            out.println();\n+            out.append(\u0027\\n\u0027);\n             return 0;\n         }\n     }\n     if (config.printTree) {\n         if (compiler.getRoot() \u003d\u003d null) {\n-            out.println(\"Code contains errors; no tree was generated.\");\n+            out.append(\"Code contains errors; no tree was generated.\\n\");\n             return 1;\n         } else {\n             compiler.getRoot().appendStringTree(out);\n-            out.println(\"\");\n+            out.append(\"\\n\");\n             return 0;\n         }\n     }\n     if (result.success) {\n         if (modules \u003d\u003d null) {\n             writeOutput(out, compiler, compiler.toSource(), config.outputWrapper, config.outputWrapperMarker);\n             outputSourceMap(options);\n         } else {\n             String moduleFilePrefix \u003d config.moduleOutputPathPrefix;\n             maybeCreateDirsForPath(moduleFilePrefix);\n             Map\u003cString, String\u003e moduleWrappers \u003d parseModuleWrappers(config.moduleWrapper, modules);\n-            PrintStream mapOut \u003d null;\n+            Writer mapOut \u003d null;\n             if (!shouldGenerateMapPerModule(options)) {\n-                mapOut \u003d toPrintStream(expandSourceMapPath(options, null));\n+                mapOut \u003d toWriter(expandSourceMapPath(options, null));\n             }\n             for (JSModule m : modules) {\n                 if (shouldGenerateMapPerModule(options)) {\n-                    mapOut \u003d toPrintStream(expandSourceMapPath(options, m));\n+                    mapOut \u003d toWriter(expandSourceMapPath(options, m));\n                 }\n-                PrintStream ps \u003d toPrintStream(moduleFilePrefix + m.getName() + \".js\");\n+                Writer writer \u003d toWriter(moduleFilePrefix + m.getName() + \".js\");\n                 if (options.sourceMapOutputPath !\u003d null) {\n                     compiler.getSourceMap().reset();\n                 }\n-                writeOutput(ps, compiler, compiler.toSource(m), moduleWrappers.get(m.getName()), \"%s\");\n+                writeOutput(writer, compiler, compiler.toSource(m), moduleWrappers.get(m.getName()), \"%s\");\n                 if (options.sourceMapOutputPath !\u003d null) {\n                     compiler.getSourceMap().appendTo(mapOut, m.getName());\n                 }\n-                ps.close();\n+                writer.close();\n                 if (shouldGenerateMapPerModule(options) \u0026\u0026 mapOut !\u003d null) {\n                     mapOut.close();\n                     mapOut \u003d null;\n                 }\n             }\n             if (mapOut !\u003d null) {\n                 mapOut.close();\n             }\n         }\n         if (options.externExportsPath !\u003d null) {\n-            PrintStream eeOut \u003d openExternExportsStream(options, options.jsOutputFile);\n+            Writer eeOut \u003d openExternExportsStream(options, options.jsOutputFile);\n             eeOut.append(result.externExport);\n             eeOut.close();\n         }\n         outputNameMaps(options);\n         outputManifest();\n     }\n     return Math.min(result.errors.length, 0x7f);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6a94702f5cf769973528adc8b3dc3e9cf56277c8": {
      "type": "Ybodychange",
      "commitMessage": "\nChange on 2010/07/07 15:59:31 by johnlenz\n\n        Automated g4 rollback.\n\n        *** Reason for rollback ***\n\n          If an output file is openned, close it to be sure it is flushed.\n\n        *** Original change description ***\n\n        Automated g4 rollback.\n\n        *** Reason for rollback ***\n\n          \u003center reason for rollback\u003e\n\n        *** Original change description ***\n\n        Buffer file stream to improve file system performance.\n\n        R\u003dacleung\n        DELTA\u003d36  (26 added, 1 deleted, 9 changed)\n\nChange on 2010/07/07 16:31:41 by nicksantos\n\n        Sort and namespace the baked-in externs files, so that\n        they do not conflict with the user\u0027s file names.\n        Fixes issue 194\n\n        R\u003dacleung\n        DELTA\u003d90  (69 added, 17 deleted, 4 changed)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d50002\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@266 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "7/8/10, 4:28 PM",
      "commitName": "6a94702f5cf769973528adc8b3dc3e9cf56277c8",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "5/27/10, 10:18 PM",
      "commitNameOld": "6d00ac1a68612aade8a19d7ecc9b180f00ae5234",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 41.76,
      "commitsBetweenForRepo": 31,
      "commitsBetweenForFile": 1,
      "actualSource": "int processResults(Result result, JSModule[] modules, B options) throws FlagUsageException, IOException {\n    if (config.computePhaseOrdering) {\n        return 0;\n    }\n    if (config.printPassGraph) {\n        if (compiler.getRoot() \u003d\u003d null) {\n            return 1;\n        } else {\n            out.append(DotFormatter.toDot(compiler.getPassConfig().getPassGraph()));\n            out.println();\n            return 0;\n        }\n    }\n    if (config.printAst) {\n        if (compiler.getRoot() \u003d\u003d null) {\n            return 1;\n        } else {\n            ControlFlowGraph\u003cNode\u003e cfg \u003d compiler.computeCFG();\n            DotFormatter.appendDot(compiler.getRoot(), cfg, out);\n            out.println();\n            return 0;\n        }\n    }\n    if (config.printTree) {\n        if (compiler.getRoot() \u003d\u003d null) {\n            out.println(\"Code contains errors; no tree was generated.\");\n            return 1;\n        } else {\n            compiler.getRoot().appendStringTree(out);\n            out.println(\"\");\n            return 0;\n        }\n    }\n    if (result.success) {\n        if (modules \u003d\u003d null) {\n            writeOutput(out, compiler, compiler.toSource(), config.outputWrapper, config.outputWrapperMarker);\n            outputSourceMap(options);\n        } else {\n            String moduleFilePrefix \u003d config.moduleOutputPathPrefix;\n            maybeCreateDirsForPath(moduleFilePrefix);\n            Map\u003cString, String\u003e moduleWrappers \u003d parseModuleWrappers(config.moduleWrapper, modules);\n            PrintStream mapOut \u003d null;\n            if (!shouldGenerateMapPerModule(options)) {\n                mapOut \u003d toPrintStream(expandSourceMapPath(options, null));\n            }\n            for (JSModule m : modules) {\n                if (shouldGenerateMapPerModule(options)) {\n                    mapOut \u003d toPrintStream(expandSourceMapPath(options, m));\n                }\n                PrintStream ps \u003d toPrintStream(moduleFilePrefix + m.getName() + \".js\");\n                if (options.sourceMapOutputPath !\u003d null) {\n                    compiler.getSourceMap().reset();\n                }\n                writeOutput(ps, compiler, compiler.toSource(m), moduleWrappers.get(m.getName()), \"%s\");\n                if (options.sourceMapOutputPath !\u003d null) {\n                    compiler.getSourceMap().appendTo(mapOut, m.getName());\n                }\n                ps.close();\n                if (shouldGenerateMapPerModule(options) \u0026\u0026 mapOut !\u003d null) {\n                    mapOut.close();\n                    mapOut \u003d null;\n                }\n            }\n            if (mapOut !\u003d null) {\n                mapOut.close();\n            }\n        }\n        if (options.externExportsPath !\u003d null) {\n            PrintStream eeOut \u003d openExternExportsStream(options, options.jsOutputFile);\n            eeOut.append(result.externExport);\n            eeOut.close();\n        }\n        outputNameMaps(options);\n        outputManifest();\n    }\n    return Math.min(result.errors.length, 0x7f);\n}",
      "path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
      "functionStartLine": 530,
      "functionName": "processResults",
      "functionAnnotation": "",
      "functionDoc": "Processes the results of the compile job, and returns an error code.\n",
      "diff": "@@ -1,77 +1,77 @@\n int processResults(Result result, JSModule[] modules, B options) throws FlagUsageException, IOException {\n     if (config.computePhaseOrdering) {\n         return 0;\n     }\n     if (config.printPassGraph) {\n         if (compiler.getRoot() \u003d\u003d null) {\n             return 1;\n         } else {\n             out.append(DotFormatter.toDot(compiler.getPassConfig().getPassGraph()));\n             out.println();\n             return 0;\n         }\n     }\n     if (config.printAst) {\n         if (compiler.getRoot() \u003d\u003d null) {\n             return 1;\n         } else {\n             ControlFlowGraph\u003cNode\u003e cfg \u003d compiler.computeCFG();\n             DotFormatter.appendDot(compiler.getRoot(), cfg, out);\n             out.println();\n             return 0;\n         }\n     }\n     if (config.printTree) {\n         if (compiler.getRoot() \u003d\u003d null) {\n             out.println(\"Code contains errors; no tree was generated.\");\n             return 1;\n         } else {\n             compiler.getRoot().appendStringTree(out);\n             out.println(\"\");\n             return 0;\n         }\n     }\n     if (result.success) {\n         if (modules \u003d\u003d null) {\n             writeOutput(out, compiler, compiler.toSource(), config.outputWrapper, config.outputWrapperMarker);\n             outputSourceMap(options);\n         } else {\n             String moduleFilePrefix \u003d config.moduleOutputPathPrefix;\n             maybeCreateDirsForPath(moduleFilePrefix);\n             Map\u003cString, String\u003e moduleWrappers \u003d parseModuleWrappers(config.moduleWrapper, modules);\n             PrintStream mapOut \u003d null;\n             if (!shouldGenerateMapPerModule(options)) {\n                 mapOut \u003d toPrintStream(expandSourceMapPath(options, null));\n             }\n             for (JSModule m : modules) {\n                 if (shouldGenerateMapPerModule(options)) {\n                     mapOut \u003d toPrintStream(expandSourceMapPath(options, m));\n                 }\n-                PrintStream ps \u003d new PrintStream(new FileOutputStream(moduleFilePrefix + m.getName() + \".js\"));\n+                PrintStream ps \u003d toPrintStream(moduleFilePrefix + m.getName() + \".js\");\n                 if (options.sourceMapOutputPath !\u003d null) {\n                     compiler.getSourceMap().reset();\n                 }\n                 writeOutput(ps, compiler, compiler.toSource(m), moduleWrappers.get(m.getName()), \"%s\");\n                 if (options.sourceMapOutputPath !\u003d null) {\n                     compiler.getSourceMap().appendTo(mapOut, m.getName());\n                 }\n                 ps.close();\n                 if (shouldGenerateMapPerModule(options) \u0026\u0026 mapOut !\u003d null) {\n                     mapOut.close();\n                     mapOut \u003d null;\n                 }\n             }\n             if (mapOut !\u003d null) {\n                 mapOut.close();\n             }\n         }\n         if (options.externExportsPath !\u003d null) {\n             PrintStream eeOut \u003d openExternExportsStream(options, options.jsOutputFile);\n             eeOut.append(result.externExport);\n             eeOut.close();\n         }\n         outputNameMaps(options);\n         outputManifest();\n     }\n     return Math.min(result.errors.length, 0x7f);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "260f0ffc9243ef15bd17e324c9cf7e2dfac9cc6a": {
      "type": "Ybodychange",
      "commitMessage": "\nChange on 2010/05/13 by nick\n\n        add an --output_manifest flag.\n\n        R\u003djoey\n        DELTA\u003d112  (107 added, 0 deleted, 5 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d2002\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@210 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "5/13/10, 5:34 PM",
      "commitName": "260f0ffc9243ef15bd17e324c9cf7e2dfac9cc6a",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "5/13/10, 10:46 AM",
      "commitNameOld": "97bbbffb65eda01aa9b38a5cec43a598afb39070",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 0.28,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "int processResults(Result result, JSModule[] modules, B options) throws FlagUsageException, IOException {\n    if (config.computePhaseOrdering) {\n        return 0;\n    }\n    if (config.printPassGraph) {\n        if (compiler.getRoot() \u003d\u003d null) {\n            return 1;\n        } else {\n            out.append(DotFormatter.toDot(compiler.getPassConfig().getPassGraph()));\n            out.println();\n            return 0;\n        }\n    }\n    if (config.printAst) {\n        if (compiler.getRoot() \u003d\u003d null) {\n            return 1;\n        } else {\n            ControlFlowGraph\u003cNode\u003e cfg \u003d compiler.computeCFG();\n            DotFormatter.appendDot(compiler.getRoot(), cfg, out);\n            out.println();\n            return 0;\n        }\n    }\n    if (config.printTree) {\n        if (compiler.getRoot() \u003d\u003d null) {\n            out.println(\"Code contains errors; no tree was generated.\");\n            return 1;\n        } else {\n            compiler.getRoot().appendStringTree(out);\n            out.println(\"\");\n            return 0;\n        }\n    }\n    if (result.success) {\n        if (modules \u003d\u003d null) {\n            writeOutput(out, compiler, compiler.toSource(), config.outputWrapper, config.outputWrapperMarker);\n            outputSourceMap(options);\n        } else {\n            String moduleFilePrefix \u003d config.moduleOutputPathPrefix;\n            maybeCreateDirsForPath(moduleFilePrefix);\n            Map\u003cString, String\u003e moduleWrappers \u003d parseModuleWrappers(config.moduleWrapper, modules);\n            PrintStream mapOut \u003d null;\n            if (!shouldGenerateMapPerModule(options)) {\n                mapOut \u003d toPrintStream(expandSourceMapPath(options, null));\n            }\n            for (JSModule m : modules) {\n                if (shouldGenerateMapPerModule(options)) {\n                    mapOut \u003d toPrintStream(expandSourceMapPath(options, m));\n                }\n                PrintStream ps \u003d new PrintStream(new FileOutputStream(moduleFilePrefix + m.getName() + \".js\"));\n                if (options.sourceMapOutputPath !\u003d null) {\n                    compiler.getSourceMap().reset();\n                }\n                writeOutput(ps, compiler, compiler.toSource(m), moduleWrappers.get(m.getName()), \"%s\");\n                if (options.sourceMapOutputPath !\u003d null) {\n                    compiler.getSourceMap().appendTo(mapOut, m.getName());\n                }\n                ps.close();\n                if (shouldGenerateMapPerModule(options) \u0026\u0026 mapOut !\u003d null) {\n                    mapOut.close();\n                    mapOut \u003d null;\n                }\n            }\n            if (mapOut !\u003d null) {\n                mapOut.close();\n            }\n        }\n        if (options.externExportsPath !\u003d null) {\n            PrintStream eeOut \u003d openExternExportsStream(options, options.jsOutputFile);\n            eeOut.append(result.externExport);\n            eeOut.close();\n        }\n        outputNameMaps(options);\n        outputManifest();\n    }\n    return Math.min(result.errors.length, 0x7f);\n}",
      "path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
      "functionStartLine": 523,
      "functionName": "processResults",
      "functionAnnotation": "",
      "functionDoc": "Processes the results of the compile job, and returns an error code.\n",
      "diff": "@@ -1,76 +1,77 @@\n int processResults(Result result, JSModule[] modules, B options) throws FlagUsageException, IOException {\n     if (config.computePhaseOrdering) {\n         return 0;\n     }\n     if (config.printPassGraph) {\n         if (compiler.getRoot() \u003d\u003d null) {\n             return 1;\n         } else {\n             out.append(DotFormatter.toDot(compiler.getPassConfig().getPassGraph()));\n             out.println();\n             return 0;\n         }\n     }\n     if (config.printAst) {\n         if (compiler.getRoot() \u003d\u003d null) {\n             return 1;\n         } else {\n             ControlFlowGraph\u003cNode\u003e cfg \u003d compiler.computeCFG();\n             DotFormatter.appendDot(compiler.getRoot(), cfg, out);\n             out.println();\n             return 0;\n         }\n     }\n     if (config.printTree) {\n         if (compiler.getRoot() \u003d\u003d null) {\n             out.println(\"Code contains errors; no tree was generated.\");\n             return 1;\n         } else {\n             compiler.getRoot().appendStringTree(out);\n             out.println(\"\");\n             return 0;\n         }\n     }\n     if (result.success) {\n         if (modules \u003d\u003d null) {\n             writeOutput(out, compiler, compiler.toSource(), config.outputWrapper, config.outputWrapperMarker);\n             outputSourceMap(options);\n         } else {\n             String moduleFilePrefix \u003d config.moduleOutputPathPrefix;\n             maybeCreateDirsForPath(moduleFilePrefix);\n             Map\u003cString, String\u003e moduleWrappers \u003d parseModuleWrappers(config.moduleWrapper, modules);\n             PrintStream mapOut \u003d null;\n             if (!shouldGenerateMapPerModule(options)) {\n                 mapOut \u003d toPrintStream(expandSourceMapPath(options, null));\n             }\n             for (JSModule m : modules) {\n                 if (shouldGenerateMapPerModule(options)) {\n                     mapOut \u003d toPrintStream(expandSourceMapPath(options, m));\n                 }\n                 PrintStream ps \u003d new PrintStream(new FileOutputStream(moduleFilePrefix + m.getName() + \".js\"));\n                 if (options.sourceMapOutputPath !\u003d null) {\n                     compiler.getSourceMap().reset();\n                 }\n                 writeOutput(ps, compiler, compiler.toSource(m), moduleWrappers.get(m.getName()), \"%s\");\n                 if (options.sourceMapOutputPath !\u003d null) {\n                     compiler.getSourceMap().appendTo(mapOut, m.getName());\n                 }\n                 ps.close();\n                 if (shouldGenerateMapPerModule(options) \u0026\u0026 mapOut !\u003d null) {\n                     mapOut.close();\n                     mapOut \u003d null;\n                 }\n             }\n             if (mapOut !\u003d null) {\n                 mapOut.close();\n             }\n         }\n         if (options.externExportsPath !\u003d null) {\n             PrintStream eeOut \u003d openExternExportsStream(options, options.jsOutputFile);\n             eeOut.append(result.externExport);\n             eeOut.close();\n         }\n         outputNameMaps(options);\n+        outputManifest();\n     }\n     return Math.min(result.errors.length, 0x7f);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "97bbbffb65eda01aa9b38a5cec43a598afb39070": {
      "type": "Ybodychange",
      "commitMessage": "\nChange on 2010/05/12 by nick\n\n        simplify how we build source map paths.\n\n        R\u003djoey\n        DELTA\u003d111  (76 added, 4 deleted, 31 changed)\n\nChange on 2010/05/12 by nick\n\n        Use generics magic to clean up the graph code a bit.\n        These changes don\u0027t give the performance improvements that I hoped,\n        but i think they\u0027re good changes anyway.\n\n        R\u003dalan\n        DELTA\u003d253  (69 added, 121 deleted, 63 changed)\n\nChange on 2010/05/12 by nick\n\n        API clean-up: don\u0027t store null return types or parameter-list types.\n\n        R\u003drobert\n        DELTA\u003d195  (89 added, 54 deleted, 52 changed)\n\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003ddzaoho\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@209 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "5/13/10, 10:46 AM",
      "commitName": "97bbbffb65eda01aa9b38a5cec43a598afb39070",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "5/3/10, 7:03 AM",
      "commitNameOld": "9147da9979fb00599efd700fa5e0cccfa93d25a5",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 10.15,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "actualSource": "int processResults(Result result, JSModule[] modules, B options) throws FlagUsageException, IOException {\n    if (config.computePhaseOrdering) {\n        return 0;\n    }\n    if (config.printPassGraph) {\n        if (compiler.getRoot() \u003d\u003d null) {\n            return 1;\n        } else {\n            out.append(DotFormatter.toDot(compiler.getPassConfig().getPassGraph()));\n            out.println();\n            return 0;\n        }\n    }\n    if (config.printAst) {\n        if (compiler.getRoot() \u003d\u003d null) {\n            return 1;\n        } else {\n            ControlFlowGraph\u003cNode\u003e cfg \u003d compiler.computeCFG();\n            DotFormatter.appendDot(compiler.getRoot(), cfg, out);\n            out.println();\n            return 0;\n        }\n    }\n    if (config.printTree) {\n        if (compiler.getRoot() \u003d\u003d null) {\n            out.println(\"Code contains errors; no tree was generated.\");\n            return 1;\n        } else {\n            compiler.getRoot().appendStringTree(out);\n            out.println(\"\");\n            return 0;\n        }\n    }\n    if (result.success) {\n        if (modules \u003d\u003d null) {\n            writeOutput(out, compiler, compiler.toSource(), config.outputWrapper, config.outputWrapperMarker);\n            outputSourceMap(options);\n        } else {\n            String moduleFilePrefix \u003d config.moduleOutputPathPrefix;\n            maybeCreateDirsForPath(moduleFilePrefix);\n            Map\u003cString, String\u003e moduleWrappers \u003d parseModuleWrappers(config.moduleWrapper, modules);\n            PrintStream mapOut \u003d null;\n            if (!shouldGenerateMapPerModule(options)) {\n                mapOut \u003d toPrintStream(expandSourceMapPath(options, null));\n            }\n            for (JSModule m : modules) {\n                if (shouldGenerateMapPerModule(options)) {\n                    mapOut \u003d toPrintStream(expandSourceMapPath(options, m));\n                }\n                PrintStream ps \u003d new PrintStream(new FileOutputStream(moduleFilePrefix + m.getName() + \".js\"));\n                if (options.sourceMapOutputPath !\u003d null) {\n                    compiler.getSourceMap().reset();\n                }\n                writeOutput(ps, compiler, compiler.toSource(m), moduleWrappers.get(m.getName()), \"%s\");\n                if (options.sourceMapOutputPath !\u003d null) {\n                    compiler.getSourceMap().appendTo(mapOut, m.getName());\n                }\n                ps.close();\n                if (shouldGenerateMapPerModule(options) \u0026\u0026 mapOut !\u003d null) {\n                    mapOut.close();\n                    mapOut \u003d null;\n                }\n            }\n            if (mapOut !\u003d null) {\n                mapOut.close();\n            }\n        }\n        if (options.externExportsPath !\u003d null) {\n            PrintStream eeOut \u003d openExternExportsStream(options, options.jsOutputFile);\n            eeOut.append(result.externExport);\n            eeOut.close();\n        }\n        outputNameMaps(options);\n    }\n    return Math.min(result.errors.length, 0x7f);\n}",
      "path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
      "functionStartLine": 523,
      "functionName": "processResults",
      "functionAnnotation": "",
      "functionDoc": "Processes the results of the compile job, and returns an error code.\n",
      "diff": "@@ -1,76 +1,76 @@\n int processResults(Result result, JSModule[] modules, B options) throws FlagUsageException, IOException {\n     if (config.computePhaseOrdering) {\n         return 0;\n     }\n     if (config.printPassGraph) {\n         if (compiler.getRoot() \u003d\u003d null) {\n             return 1;\n         } else {\n             out.append(DotFormatter.toDot(compiler.getPassConfig().getPassGraph()));\n             out.println();\n             return 0;\n         }\n     }\n     if (config.printAst) {\n         if (compiler.getRoot() \u003d\u003d null) {\n             return 1;\n         } else {\n             ControlFlowGraph\u003cNode\u003e cfg \u003d compiler.computeCFG();\n             DotFormatter.appendDot(compiler.getRoot(), cfg, out);\n             out.println();\n             return 0;\n         }\n     }\n     if (config.printTree) {\n         if (compiler.getRoot() \u003d\u003d null) {\n             out.println(\"Code contains errors; no tree was generated.\");\n             return 1;\n         } else {\n             compiler.getRoot().appendStringTree(out);\n             out.println(\"\");\n             return 0;\n         }\n     }\n     if (result.success) {\n         if (modules \u003d\u003d null) {\n             writeOutput(out, compiler, compiler.toSource(), config.outputWrapper, config.outputWrapperMarker);\n-            outputSourceMap(options, options.jsOutputFile);\n+            outputSourceMap(options);\n         } else {\n             String moduleFilePrefix \u003d config.moduleOutputPathPrefix;\n             maybeCreateDirsForPath(moduleFilePrefix);\n             Map\u003cString, String\u003e moduleWrappers \u003d parseModuleWrappers(config.moduleWrapper, modules);\n             PrintStream mapOut \u003d null;\n             if (!shouldGenerateMapPerModule(options)) {\n-                mapOut \u003d openSourceMapStream(options, moduleFilePrefix);\n+                mapOut \u003d toPrintStream(expandSourceMapPath(options, null));\n             }\n             for (JSModule m : modules) {\n                 if (shouldGenerateMapPerModule(options)) {\n-                    mapOut \u003d openSourceMapStream(options, moduleFilePrefix + m.getName() + \".js\");\n+                    mapOut \u003d toPrintStream(expandSourceMapPath(options, m));\n                 }\n                 PrintStream ps \u003d new PrintStream(new FileOutputStream(moduleFilePrefix + m.getName() + \".js\"));\n                 if (options.sourceMapOutputPath !\u003d null) {\n                     compiler.getSourceMap().reset();\n                 }\n                 writeOutput(ps, compiler, compiler.toSource(m), moduleWrappers.get(m.getName()), \"%s\");\n                 if (options.sourceMapOutputPath !\u003d null) {\n                     compiler.getSourceMap().appendTo(mapOut, m.getName());\n                 }\n                 ps.close();\n                 if (shouldGenerateMapPerModule(options) \u0026\u0026 mapOut !\u003d null) {\n                     mapOut.close();\n                     mapOut \u003d null;\n                 }\n             }\n             if (mapOut !\u003d null) {\n                 mapOut.close();\n             }\n         }\n         if (options.externExportsPath !\u003d null) {\n             PrintStream eeOut \u003d openExternExportsStream(options, options.jsOutputFile);\n             eeOut.append(result.externExport);\n             eeOut.close();\n         }\n         outputNameMaps(options);\n     }\n     return Math.min(result.errors.length, 0x7f);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c080c668a4ccd9eb151cbb4f90980ddbbfbaba44": {
      "type": "Ybodychange",
      "commitMessage": "rolling back the EventTarget changes for a little bit\n\ndecouple command-line options from command-line parsing. (Nick)\n\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@127 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "3/4/10, 10:33 AM",
      "commitName": "c080c668a4ccd9eb151cbb4f90980ddbbfbaba44",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "2/26/10, 6:04 PM",
      "commitNameOld": "848ace840362a1f5558bec065cb40548ff66587a",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 5.69,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "int processResults(Result result, JSModule[] modules, B options) throws FlagUsageException, IOException {\n    if (config.computePhaseOrdering) {\n        return 0;\n    }\n    if (config.printPassGraph) {\n        if (compiler.getRoot() \u003d\u003d null) {\n            return 1;\n        } else {\n            out.append(DotFormatter.toDot(compiler.getPassConfig().getPassGraph()));\n            out.println();\n            return 0;\n        }\n    }\n    if (config.printAst) {\n        if (compiler.getRoot() \u003d\u003d null) {\n            return 1;\n        } else {\n            ControlFlowGraph\u003cNode\u003e cfg \u003d compiler.computeCFG();\n            DotFormatter.appendDot(compiler.getRoot(), cfg, out);\n            out.println();\n            return 0;\n        }\n    }\n    if (config.printTree) {\n        if (compiler.getRoot() \u003d\u003d null) {\n            out.println(\"Code contains errors; no tree was generated.\");\n            return 1;\n        } else {\n            compiler.getRoot().appendStringTree(out);\n            out.println(\"\");\n            return 0;\n        }\n    }\n    if (result.success) {\n        if (modules \u003d\u003d null) {\n            writeOutput(out, compiler, compiler.toSource(), config.outputWrapper, config.outputWrapperMarker);\n            outputSourceMap(options, options.jsOutputFile);\n        } else {\n            String moduleFilePrefix \u003d config.moduleOutputPathPrefix;\n            maybeCreateDirsForPath(moduleFilePrefix);\n            Map\u003cString, String\u003e moduleWrappers \u003d parseModuleWrappers(config.moduleWrapper, modules);\n            PrintStream mapOut \u003d null;\n            if (!shouldGenerateMapPerModule(options)) {\n                mapOut \u003d openSourceMapStream(options, moduleFilePrefix);\n            }\n            for (JSModule m : modules) {\n                if (shouldGenerateMapPerModule(options)) {\n                    mapOut \u003d openSourceMapStream(options, moduleFilePrefix + m.getName() + \".js\");\n                }\n                PrintStream ps \u003d new PrintStream(new FileOutputStream(moduleFilePrefix + m.getName() + \".js\"));\n                if (options.sourceMapOutputPath !\u003d null) {\n                    compiler.getSourceMap().reset();\n                }\n                writeOutput(ps, compiler, compiler.toSource(m), moduleWrappers.get(m.getName()), \"%s\");\n                if (options.sourceMapOutputPath !\u003d null) {\n                    compiler.getSourceMap().appendTo(mapOut, m.getName());\n                }\n                ps.close();\n                if (shouldGenerateMapPerModule(options) \u0026\u0026 mapOut !\u003d null) {\n                    mapOut.close();\n                    mapOut \u003d null;\n                }\n            }\n            if (mapOut !\u003d null) {\n                mapOut.close();\n            }\n        }\n        if (options.externExportsPath !\u003d null) {\n            PrintStream eeOut \u003d openExternExportsStream(options, options.jsOutputFile);\n            eeOut.append(result.externExport);\n            eeOut.close();\n        }\n        outputNameMaps(options);\n    }\n    return Math.min(result.errors.length, 0x7f);\n}",
      "path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
      "functionStartLine": 522,
      "functionName": "processResults",
      "functionAnnotation": "",
      "functionDoc": "Processes the results of the compile job, and returns an error code.\n",
      "diff": "@@ -1,76 +1,76 @@\n int processResults(Result result, JSModule[] modules, B options) throws FlagUsageException, IOException {\n-    if (FLAG_compute_phase_ordering.get()) {\n+    if (config.computePhaseOrdering) {\n         return 0;\n     }\n-    if (FLAG_print_pass_graph.get()) {\n+    if (config.printPassGraph) {\n         if (compiler.getRoot() \u003d\u003d null) {\n             return 1;\n         } else {\n             out.append(DotFormatter.toDot(compiler.getPassConfig().getPassGraph()));\n             out.println();\n             return 0;\n         }\n     }\n-    if (FLAG_print_ast.get()) {\n+    if (config.printAst) {\n         if (compiler.getRoot() \u003d\u003d null) {\n             return 1;\n         } else {\n             ControlFlowGraph\u003cNode\u003e cfg \u003d compiler.computeCFG();\n             DotFormatter.appendDot(compiler.getRoot(), cfg, out);\n             out.println();\n             return 0;\n         }\n     }\n-    if (FLAG_print_tree.get()) {\n+    if (config.printTree) {\n         if (compiler.getRoot() \u003d\u003d null) {\n             out.println(\"Code contains errors; no tree was generated.\");\n             return 1;\n         } else {\n             compiler.getRoot().appendStringTree(out);\n             out.println(\"\");\n             return 0;\n         }\n     }\n     if (result.success) {\n         if (modules \u003d\u003d null) {\n-            writeOutput(out, compiler, compiler.toSource(), FLAG_output_wrapper.get(), FLAG_output_wrapper_marker.get());\n+            writeOutput(out, compiler, compiler.toSource(), config.outputWrapper, config.outputWrapperMarker);\n             outputSourceMap(options, options.jsOutputFile);\n         } else {\n-            String moduleFilePrefix \u003d FLAG_module_output_path_prefix.get();\n+            String moduleFilePrefix \u003d config.moduleOutputPathPrefix;\n             maybeCreateDirsForPath(moduleFilePrefix);\n-            Map\u003cString, String\u003e moduleWrappers \u003d parseModuleWrappers(FLAG_module_wrapper.get(), modules);\n+            Map\u003cString, String\u003e moduleWrappers \u003d parseModuleWrappers(config.moduleWrapper, modules);\n             PrintStream mapOut \u003d null;\n             if (!shouldGenerateMapPerModule(options)) {\n                 mapOut \u003d openSourceMapStream(options, moduleFilePrefix);\n             }\n             for (JSModule m : modules) {\n                 if (shouldGenerateMapPerModule(options)) {\n                     mapOut \u003d openSourceMapStream(options, moduleFilePrefix + m.getName() + \".js\");\n                 }\n                 PrintStream ps \u003d new PrintStream(new FileOutputStream(moduleFilePrefix + m.getName() + \".js\"));\n                 if (options.sourceMapOutputPath !\u003d null) {\n                     compiler.getSourceMap().reset();\n                 }\n                 writeOutput(ps, compiler, compiler.toSource(m), moduleWrappers.get(m.getName()), \"%s\");\n                 if (options.sourceMapOutputPath !\u003d null) {\n                     compiler.getSourceMap().appendTo(mapOut, m.getName());\n                 }\n                 ps.close();\n                 if (shouldGenerateMapPerModule(options) \u0026\u0026 mapOut !\u003d null) {\n                     mapOut.close();\n                     mapOut \u003d null;\n                 }\n             }\n             if (mapOut !\u003d null) {\n                 mapOut.close();\n             }\n         }\n         if (options.externExportsPath !\u003d null) {\n             PrintStream eeOut \u003d openExternExportsStream(options, options.jsOutputFile);\n             eeOut.append(result.externExport);\n             eeOut.close();\n         }\n         outputNameMaps(options);\n     }\n     return Math.min(result.errors.length, 0x7f);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "848ace840362a1f5558bec065cb40548ff66587a": {
      "type": "Yfilerename",
      "commitMessage": "Rename CompilerRunner -\u003e CommandLineRunner.\nI\u0027ll also do this for JSCompilerRunner, but it will be a much\nbigger change. (Nick)\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION\u003d\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@119 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "2/26/10, 6:04 PM",
      "commitName": "848ace840362a1f5558bec065cb40548ff66587a",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "2/26/10, 3:45 PM",
      "commitNameOld": "50c1b3d39ff5b17c956a2235f97f7b5da05ab6f0",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "int processResults(Result result, JSModule[] modules, B options) throws FlagUsageException, IOException {\n    if (FLAG_compute_phase_ordering.get()) {\n        return 0;\n    }\n    if (FLAG_print_pass_graph.get()) {\n        if (compiler.getRoot() \u003d\u003d null) {\n            return 1;\n        } else {\n            out.append(DotFormatter.toDot(compiler.getPassConfig().getPassGraph()));\n            out.println();\n            return 0;\n        }\n    }\n    if (FLAG_print_ast.get()) {\n        if (compiler.getRoot() \u003d\u003d null) {\n            return 1;\n        } else {\n            ControlFlowGraph\u003cNode\u003e cfg \u003d compiler.computeCFG();\n            DotFormatter.appendDot(compiler.getRoot(), cfg, out);\n            out.println();\n            return 0;\n        }\n    }\n    if (FLAG_print_tree.get()) {\n        if (compiler.getRoot() \u003d\u003d null) {\n            out.println(\"Code contains errors; no tree was generated.\");\n            return 1;\n        } else {\n            compiler.getRoot().appendStringTree(out);\n            out.println(\"\");\n            return 0;\n        }\n    }\n    if (result.success) {\n        if (modules \u003d\u003d null) {\n            writeOutput(out, compiler, compiler.toSource(), FLAG_output_wrapper.get(), FLAG_output_wrapper_marker.get());\n            outputSourceMap(options, options.jsOutputFile);\n        } else {\n            String moduleFilePrefix \u003d FLAG_module_output_path_prefix.get();\n            maybeCreateDirsForPath(moduleFilePrefix);\n            Map\u003cString, String\u003e moduleWrappers \u003d parseModuleWrappers(FLAG_module_wrapper.get(), modules);\n            PrintStream mapOut \u003d null;\n            if (!shouldGenerateMapPerModule(options)) {\n                mapOut \u003d openSourceMapStream(options, moduleFilePrefix);\n            }\n            for (JSModule m : modules) {\n                if (shouldGenerateMapPerModule(options)) {\n                    mapOut \u003d openSourceMapStream(options, moduleFilePrefix + m.getName() + \".js\");\n                }\n                PrintStream ps \u003d new PrintStream(new FileOutputStream(moduleFilePrefix + m.getName() + \".js\"));\n                if (options.sourceMapOutputPath !\u003d null) {\n                    compiler.getSourceMap().reset();\n                }\n                writeOutput(ps, compiler, compiler.toSource(m), moduleWrappers.get(m.getName()), \"%s\");\n                if (options.sourceMapOutputPath !\u003d null) {\n                    compiler.getSourceMap().appendTo(mapOut, m.getName());\n                }\n                ps.close();\n                if (shouldGenerateMapPerModule(options) \u0026\u0026 mapOut !\u003d null) {\n                    mapOut.close();\n                    mapOut \u003d null;\n                }\n            }\n            if (mapOut !\u003d null) {\n                mapOut.close();\n            }\n        }\n        if (options.externExportsPath !\u003d null) {\n            PrintStream eeOut \u003d openExternExportsStream(options, options.jsOutputFile);\n            eeOut.append(result.externExport);\n            eeOut.close();\n        }\n        outputNameMaps(options);\n    }\n    return Math.min(result.errors.length, 0x7f);\n}",
      "path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
      "functionStartLine": 675,
      "functionName": "processResults",
      "functionAnnotation": "",
      "functionDoc": "Processes the results of the compile job, and returns an error code.\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/com/google/javascript/jscomp/AbstractCompilerRunner.java",
        "newPath": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java"
      }
    },
    "c0face2a48665e46f4829f54ee24cfa4cf8d4589": {
      "type": "Ybodychange",
      "commitMessage": "Fix a bug in type inference when there are more than two inner\nfunctions in a local scope.\n\nAdd a --print_pass_graph flag that prints the passes run as a DOT file.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@96 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "2/8/10, 3:25 PM",
      "commitName": "c0face2a48665e46f4829f54ee24cfa4cf8d4589",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "2/3/10, 4:00 PM",
      "commitNameOld": "5592f80e96e7fe3b7751c441efdd8eba6ccfc4ba",
      "commitAuthorOld": "Nicholas.J.Santos",
      "daysBetweenCommits": 4.98,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "int processResults(Result result, JSModule[] modules, B options) throws FlagUsageException, IOException {\n    if (FLAG_compute_phase_ordering.get()) {\n        return 0;\n    }\n    if (FLAG_print_pass_graph.get()) {\n        if (compiler.getRoot() \u003d\u003d null) {\n            return 1;\n        } else {\n            out.append(DotFormatter.toDot(compiler.getPassConfig().getPassGraph()));\n            out.println();\n            return 0;\n        }\n    }\n    if (FLAG_print_ast.get()) {\n        if (compiler.getRoot() \u003d\u003d null) {\n            return 1;\n        } else {\n            ControlFlowGraph\u003cNode\u003e cfg \u003d compiler.computeCFG();\n            DotFormatter.appendDot(compiler.getRoot(), cfg, out);\n            out.println();\n            return 0;\n        }\n    }\n    if (FLAG_print_tree.get()) {\n        if (compiler.getRoot() \u003d\u003d null) {\n            out.println(\"Code contains errors; no tree was generated.\");\n            return 1;\n        } else {\n            compiler.getRoot().appendStringTree(out);\n            out.println(\"\");\n            return 0;\n        }\n    }\n    if (result.success) {\n        if (modules \u003d\u003d null) {\n            writeOutput(out, compiler, compiler.toSource(), FLAG_output_wrapper.get(), FLAG_output_wrapper_marker.get());\n            outputSourceMap(options, options.jsOutputFile);\n        } else {\n            String moduleFilePrefix \u003d FLAG_module_output_path_prefix.get();\n            maybeCreateDirsForPath(moduleFilePrefix);\n            Map\u003cString, String\u003e moduleWrappers \u003d parseModuleWrappers(FLAG_module_wrapper.get(), modules);\n            PrintStream mapOut \u003d null;\n            if (!shouldGenerateMapPerModule(options)) {\n                mapOut \u003d openSourceMapStream(options, moduleFilePrefix);\n            }\n            for (JSModule m : modules) {\n                if (shouldGenerateMapPerModule(options)) {\n                    mapOut \u003d openSourceMapStream(options, moduleFilePrefix + m.getName() + \".js\");\n                }\n                PrintStream ps \u003d new PrintStream(new FileOutputStream(moduleFilePrefix + m.getName() + \".js\"));\n                if (options.sourceMapOutputPath !\u003d null) {\n                    compiler.getSourceMap().reset();\n                }\n                writeOutput(ps, compiler, compiler.toSource(m), moduleWrappers.get(m.getName()), \"%s\");\n                if (options.sourceMapOutputPath !\u003d null) {\n                    compiler.getSourceMap().appendTo(mapOut, m.getName());\n                }\n                ps.close();\n                if (shouldGenerateMapPerModule(options) \u0026\u0026 mapOut !\u003d null) {\n                    mapOut.close();\n                    mapOut \u003d null;\n                }\n            }\n            if (mapOut !\u003d null) {\n                mapOut.close();\n            }\n        }\n        if (options.externExportsPath !\u003d null) {\n            PrintStream eeOut \u003d openExternExportsStream(options, options.jsOutputFile);\n            eeOut.append(result.externExport);\n            eeOut.close();\n        }\n        outputNameMaps(options);\n    }\n    return Math.min(result.errors.length, 0x7f);\n}",
      "path": "src/com/google/javascript/jscomp/AbstractCompilerRunner.java",
      "functionStartLine": 675,
      "functionName": "processResults",
      "functionAnnotation": "",
      "functionDoc": "Processes the results of the compile job, and returns an error code.\n",
      "diff": "@@ -1,67 +1,76 @@\n int processResults(Result result, JSModule[] modules, B options) throws FlagUsageException, IOException {\n     if (FLAG_compute_phase_ordering.get()) {\n         return 0;\n     }\n+    if (FLAG_print_pass_graph.get()) {\n+        if (compiler.getRoot() \u003d\u003d null) {\n+            return 1;\n+        } else {\n+            out.append(DotFormatter.toDot(compiler.getPassConfig().getPassGraph()));\n+            out.println();\n+            return 0;\n+        }\n+    }\n     if (FLAG_print_ast.get()) {\n         if (compiler.getRoot() \u003d\u003d null) {\n             return 1;\n         } else {\n             ControlFlowGraph\u003cNode\u003e cfg \u003d compiler.computeCFG();\n             DotFormatter.appendDot(compiler.getRoot(), cfg, out);\n             out.println();\n             return 0;\n         }\n     }\n     if (FLAG_print_tree.get()) {\n         if (compiler.getRoot() \u003d\u003d null) {\n             out.println(\"Code contains errors; no tree was generated.\");\n             return 1;\n         } else {\n             compiler.getRoot().appendStringTree(out);\n             out.println(\"\");\n             return 0;\n         }\n     }\n     if (result.success) {\n         if (modules \u003d\u003d null) {\n             writeOutput(out, compiler, compiler.toSource(), FLAG_output_wrapper.get(), FLAG_output_wrapper_marker.get());\n             outputSourceMap(options, options.jsOutputFile);\n         } else {\n             String moduleFilePrefix \u003d FLAG_module_output_path_prefix.get();\n             maybeCreateDirsForPath(moduleFilePrefix);\n             Map\u003cString, String\u003e moduleWrappers \u003d parseModuleWrappers(FLAG_module_wrapper.get(), modules);\n             PrintStream mapOut \u003d null;\n             if (!shouldGenerateMapPerModule(options)) {\n                 mapOut \u003d openSourceMapStream(options, moduleFilePrefix);\n             }\n             for (JSModule m : modules) {\n                 if (shouldGenerateMapPerModule(options)) {\n                     mapOut \u003d openSourceMapStream(options, moduleFilePrefix + m.getName() + \".js\");\n                 }\n                 PrintStream ps \u003d new PrintStream(new FileOutputStream(moduleFilePrefix + m.getName() + \".js\"));\n                 if (options.sourceMapOutputPath !\u003d null) {\n                     compiler.getSourceMap().reset();\n                 }\n                 writeOutput(ps, compiler, compiler.toSource(m), moduleWrappers.get(m.getName()), \"%s\");\n                 if (options.sourceMapOutputPath !\u003d null) {\n                     compiler.getSourceMap().appendTo(mapOut, m.getName());\n                 }\n                 ps.close();\n                 if (shouldGenerateMapPerModule(options) \u0026\u0026 mapOut !\u003d null) {\n                     mapOut.close();\n                     mapOut \u003d null;\n                 }\n             }\n             if (mapOut !\u003d null) {\n                 mapOut.close();\n             }\n         }\n         if (options.externExportsPath !\u003d null) {\n             PrintStream eeOut \u003d openExternExportsStream(options, options.jsOutputFile);\n             eeOut.append(result.externExport);\n             eeOut.close();\n         }\n         outputNameMaps(options);\n     }\n     return Math.min(result.errors.length, 0x7f);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "bca9abb0e3062d373fe52c0e8340337588c05708": {
      "type": "Ybodychange",
      "commitMessage": "Make sure that InlineVariables can inline variables that are never defined.\n\nCreate a function-inlining blacklist.\n\nSome minor type inference fixes.\n\nStart re-architecting type resolution to happen differently.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@77 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "1/26/10, 1:59 PM",
      "commitName": "bca9abb0e3062d373fe52c0e8340337588c05708",
      "commitAuthor": "Nicholas.J.Santos",
      "commitDateOld": "1/8/10, 1:41 PM",
      "commitNameOld": "6d374c3ee4c9c2651ffb44048924e127fd2bf37c",
      "commitAuthorOld": "nicholas.j.santos@gmail.com",
      "daysBetweenCommits": 18.01,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "actualSource": "int processResults(Result result, JSModule[] modules, B options) throws FlagUsageException, IOException {\n    if (FLAG_compute_phase_ordering.get()) {\n        return 0;\n    }\n    if (FLAG_print_ast.get()) {\n        if (compiler.getRoot() \u003d\u003d null) {\n            return 1;\n        } else {\n            ControlFlowGraph\u003cNode\u003e cfg \u003d compiler.computeCFG();\n            DotFormatter.appendDot(compiler.getRoot(), cfg, out);\n            out.println();\n            return 0;\n        }\n    }\n    if (FLAG_print_tree.get()) {\n        if (compiler.getRoot() \u003d\u003d null) {\n            out.println(\"Code contains errors; no tree was generated.\");\n            return 1;\n        } else {\n            compiler.getRoot().appendStringTree(out);\n            out.println(\"\");\n            return 0;\n        }\n    }\n    if (result.success) {\n        if (modules \u003d\u003d null) {\n            writeOutput(out, compiler, compiler.toSource(), FLAG_output_wrapper.get(), FLAG_output_wrapper_marker.get());\n            outputSourceMap(options, options.jsOutputFile);\n        } else {\n            String moduleFilePrefix \u003d FLAG_module_output_path_prefix.get();\n            maybeCreateDirsForPath(moduleFilePrefix);\n            Map\u003cString, String\u003e moduleWrappers \u003d parseModuleWrappers(FLAG_module_wrapper.get(), modules);\n            PrintStream mapOut \u003d null;\n            if (!shouldGenerateMapPerModule(options)) {\n                mapOut \u003d openSourceMapStream(options, moduleFilePrefix);\n            }\n            for (JSModule m : modules) {\n                if (shouldGenerateMapPerModule(options)) {\n                    mapOut \u003d openSourceMapStream(options, moduleFilePrefix + m.getName() + \".js\");\n                }\n                PrintStream ps \u003d new PrintStream(new FileOutputStream(moduleFilePrefix + m.getName() + \".js\"));\n                if (options.sourceMapOutputPath !\u003d null) {\n                    compiler.getSourceMap().reset();\n                }\n                writeOutput(ps, compiler, compiler.toSource(m), moduleWrappers.get(m.getName()), \"%s\");\n                if (options.sourceMapOutputPath !\u003d null) {\n                    compiler.getSourceMap().appendTo(mapOut, m.getName());\n                }\n                ps.close();\n                if (shouldGenerateMapPerModule(options) \u0026\u0026 mapOut !\u003d null) {\n                    mapOut.close();\n                    mapOut \u003d null;\n                }\n            }\n            if (mapOut !\u003d null) {\n                mapOut.close();\n            }\n        }\n        if (options.externExportsPath !\u003d null) {\n            PrintStream eeOut \u003d openExternExportsStream(options, options.jsOutputFile);\n            eeOut.append(result.externExport);\n            eeOut.close();\n        }\n        outputNameMaps(options);\n    }\n    return Math.min(result.errors.length, 0x7f);\n}",
      "path": "src/com/google/javascript/jscomp/AbstractCompilerRunner.java",
      "functionStartLine": 666,
      "functionName": "processResults",
      "functionAnnotation": "",
      "functionDoc": "Processes the results of the compile job, and returns an error code.\n",
      "diff": "@@ -1,67 +1,67 @@\n int processResults(Result result, JSModule[] modules, B options) throws FlagUsageException, IOException {\n     if (FLAG_compute_phase_ordering.get()) {\n         return 0;\n     }\n     if (FLAG_print_ast.get()) {\n         if (compiler.getRoot() \u003d\u003d null) {\n             return 1;\n         } else {\n             ControlFlowGraph\u003cNode\u003e cfg \u003d compiler.computeCFG();\n             DotFormatter.appendDot(compiler.getRoot(), cfg, out);\n             out.println();\n             return 0;\n         }\n     }\n     if (FLAG_print_tree.get()) {\n         if (compiler.getRoot() \u003d\u003d null) {\n             out.println(\"Code contains errors; no tree was generated.\");\n             return 1;\n         } else {\n             compiler.getRoot().appendStringTree(out);\n             out.println(\"\");\n             return 0;\n         }\n     }\n     if (result.success) {\n         if (modules \u003d\u003d null) {\n             writeOutput(out, compiler, compiler.toSource(), FLAG_output_wrapper.get(), FLAG_output_wrapper_marker.get());\n             outputSourceMap(options, options.jsOutputFile);\n         } else {\n             String moduleFilePrefix \u003d FLAG_module_output_path_prefix.get();\n             maybeCreateDirsForPath(moduleFilePrefix);\n             Map\u003cString, String\u003e moduleWrappers \u003d parseModuleWrappers(FLAG_module_wrapper.get(), modules);\n             PrintStream mapOut \u003d null;\n             if (!shouldGenerateMapPerModule(options)) {\n-                mapOut \u003d openSourceMapStream(options, moduleFilePrefix, null);\n+                mapOut \u003d openSourceMapStream(options, moduleFilePrefix);\n             }\n             for (JSModule m : modules) {\n                 if (shouldGenerateMapPerModule(options)) {\n-                    mapOut \u003d openSourceMapStream(options, moduleFilePrefix, m.getName());\n+                    mapOut \u003d openSourceMapStream(options, moduleFilePrefix + m.getName() + \".js\");\n                 }\n                 PrintStream ps \u003d new PrintStream(new FileOutputStream(moduleFilePrefix + m.getName() + \".js\"));\n                 if (options.sourceMapOutputPath !\u003d null) {\n                     compiler.getSourceMap().reset();\n                 }\n                 writeOutput(ps, compiler, compiler.toSource(m), moduleWrappers.get(m.getName()), \"%s\");\n                 if (options.sourceMapOutputPath !\u003d null) {\n                     compiler.getSourceMap().appendTo(mapOut, m.getName());\n                 }\n                 ps.close();\n                 if (shouldGenerateMapPerModule(options) \u0026\u0026 mapOut !\u003d null) {\n                     mapOut.close();\n                     mapOut \u003d null;\n                 }\n             }\n             if (mapOut !\u003d null) {\n                 mapOut.close();\n             }\n         }\n         if (options.externExportsPath !\u003d null) {\n             PrintStream eeOut \u003d openExternExportsStream(options, options.jsOutputFile);\n             eeOut.append(result.externExport);\n             eeOut.close();\n         }\n         outputNameMaps(options);\n     }\n     return Math.min(result.errors.length, 0x7f);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "915752b8e4ffd312eea298fb749dddd0edc0db2e": {
      "type": "Yintroduced",
      "commitMessage": "Add boatloads of tests.\n\nAdd support for --jscomp_warning\u003dcheckTypes\n\nAdd phase optimization improvements.\n\n\n\ngit-svn-id: https://closure-compiler.googlecode.com/svn/trunk@49 b0f006be-c8cd-11de-a2e8-8d36a3108c74\n",
      "commitDate": "12/23/09, 9:33 AM",
      "commitName": "915752b8e4ffd312eea298fb749dddd0edc0db2e",
      "commitAuthor": "nicholas.j.santos@gmail.com",
      "diff": "@@ -0,0 +1,67 @@\n+int processResults(Result result, JSModule[] modules, B options) throws FlagUsageException, IOException {\n+    if (FLAG_compute_phase_ordering.get()) {\n+        return 0;\n+    }\n+    if (FLAG_print_ast.get()) {\n+        if (compiler.getRoot() \u003d\u003d null) {\n+            return 1;\n+        } else {\n+            ControlFlowGraph\u003cNode\u003e cfg \u003d compiler.computeCFG();\n+            DotFormatter.appendDot(compiler.getRoot(), cfg, out);\n+            out.println();\n+            return 0;\n+        }\n+    }\n+    if (FLAG_print_tree.get()) {\n+        if (compiler.getRoot() \u003d\u003d null) {\n+            out.println(\"Code contains errors; no tree was generated.\");\n+            return 1;\n+        } else {\n+            compiler.getRoot().appendStringTree(out);\n+            out.println(\"\");\n+            return 0;\n+        }\n+    }\n+    if (result.success) {\n+        if (modules \u003d\u003d null) {\n+            writeOutput(out, compiler, compiler.toSource(), FLAG_output_wrapper.get(), FLAG_output_wrapper_marker.get());\n+            outputSourceMap(options, options.jsOutputFile);\n+        } else {\n+            String moduleFilePrefix \u003d FLAG_module_output_path_prefix.get();\n+            maybeCreateDirsForPath(moduleFilePrefix);\n+            Map\u003cString, String\u003e moduleWrappers \u003d parseModuleWrappers(FLAG_module_wrapper.get(), modules);\n+            PrintStream mapOut \u003d null;\n+            if (!shouldGenerateMapPerModule(options)) {\n+                mapOut \u003d openSourceMapStream(options, moduleFilePrefix, null);\n+            }\n+            for (JSModule m : modules) {\n+                if (shouldGenerateMapPerModule(options)) {\n+                    mapOut \u003d openSourceMapStream(options, moduleFilePrefix, m.getName());\n+                }\n+                PrintStream ps \u003d new PrintStream(new FileOutputStream(moduleFilePrefix + m.getName() + \".js\"));\n+                if (options.sourceMapOutputPath !\u003d null) {\n+                    compiler.getSourceMap().reset();\n+                }\n+                writeOutput(ps, compiler, compiler.toSource(m), moduleWrappers.get(m.getName()), \"%s\");\n+                if (options.sourceMapOutputPath !\u003d null) {\n+                    compiler.getSourceMap().appendTo(mapOut, m.getName());\n+                }\n+                ps.close();\n+                if (shouldGenerateMapPerModule(options) \u0026\u0026 mapOut !\u003d null) {\n+                    mapOut.close();\n+                    mapOut \u003d null;\n+                }\n+            }\n+            if (mapOut !\u003d null) {\n+                mapOut.close();\n+            }\n+        }\n+        if (options.externExportsPath !\u003d null) {\n+            PrintStream eeOut \u003d openExternExportsStream(options, options.jsOutputFile);\n+            eeOut.append(result.externExport);\n+            eeOut.close();\n+        }\n+        outputNameMaps(options);\n+    }\n+    return Math.min(result.errors.length, 0x7f);\n+}\n\\ No newline at end of file\n",
      "actualSource": "int processResults(Result result, JSModule[] modules, B options) throws FlagUsageException, IOException {\n    if (FLAG_compute_phase_ordering.get()) {\n        return 0;\n    }\n    if (FLAG_print_ast.get()) {\n        if (compiler.getRoot() \u003d\u003d null) {\n            return 1;\n        } else {\n            ControlFlowGraph\u003cNode\u003e cfg \u003d compiler.computeCFG();\n            DotFormatter.appendDot(compiler.getRoot(), cfg, out);\n            out.println();\n            return 0;\n        }\n    }\n    if (FLAG_print_tree.get()) {\n        if (compiler.getRoot() \u003d\u003d null) {\n            out.println(\"Code contains errors; no tree was generated.\");\n            return 1;\n        } else {\n            compiler.getRoot().appendStringTree(out);\n            out.println(\"\");\n            return 0;\n        }\n    }\n    if (result.success) {\n        if (modules \u003d\u003d null) {\n            writeOutput(out, compiler, compiler.toSource(), FLAG_output_wrapper.get(), FLAG_output_wrapper_marker.get());\n            outputSourceMap(options, options.jsOutputFile);\n        } else {\n            String moduleFilePrefix \u003d FLAG_module_output_path_prefix.get();\n            maybeCreateDirsForPath(moduleFilePrefix);\n            Map\u003cString, String\u003e moduleWrappers \u003d parseModuleWrappers(FLAG_module_wrapper.get(), modules);\n            PrintStream mapOut \u003d null;\n            if (!shouldGenerateMapPerModule(options)) {\n                mapOut \u003d openSourceMapStream(options, moduleFilePrefix, null);\n            }\n            for (JSModule m : modules) {\n                if (shouldGenerateMapPerModule(options)) {\n                    mapOut \u003d openSourceMapStream(options, moduleFilePrefix, m.getName());\n                }\n                PrintStream ps \u003d new PrintStream(new FileOutputStream(moduleFilePrefix + m.getName() + \".js\"));\n                if (options.sourceMapOutputPath !\u003d null) {\n                    compiler.getSourceMap().reset();\n                }\n                writeOutput(ps, compiler, compiler.toSource(m), moduleWrappers.get(m.getName()), \"%s\");\n                if (options.sourceMapOutputPath !\u003d null) {\n                    compiler.getSourceMap().appendTo(mapOut, m.getName());\n                }\n                ps.close();\n                if (shouldGenerateMapPerModule(options) \u0026\u0026 mapOut !\u003d null) {\n                    mapOut.close();\n                    mapOut \u003d null;\n                }\n            }\n            if (mapOut !\u003d null) {\n                mapOut.close();\n            }\n        }\n        if (options.externExportsPath !\u003d null) {\n            PrintStream eeOut \u003d openExternExportsStream(options, options.jsOutputFile);\n            eeOut.append(result.externExport);\n            eeOut.close();\n        }\n        outputNameMaps(options);\n    }\n    return Math.min(result.errors.length, 0x7f);\n}",
      "path": "src/com/google/javascript/jscomp/AbstractCompilerRunner.java",
      "functionStartLine": 666,
      "functionName": "processResults",
      "functionAnnotation": "",
      "functionDoc": "Processes the results of the compile job, and returns an error code.\n"
    }
  }
}